[
    {
        "title": "Root Equals Sum of Children",
        "question_content": "You are given the root of a binary tree that consists of exactly 3 nodes: the root, its left child, and its right child.\nReturn true if the value of the root is equal to the sum of the values of its two children, or false otherwise.\n&nbsp;\nExample 1:\n\nInput: root = [10,4,6]\nOutput: true\nExplanation: The values of the root, its left child, and its right child are 10, 4, and 6, respectively.\n10 is equal to 4 + 6, so we return true.\n\nExample 2:\n\nInput: root = [5,3,1]\nOutput: false\nExplanation: The values of the root, its left child, and its right child are 5, 3, and 1, respectively.\n5 is not equal to 3 + 1, so we return false.\n\n&nbsp;\nConstraints:\n\n\tThe tree consists only of the root, its left child, and its right child.\n\t-100 <= Node.val <= 100",
        "solutions": [
            {
                "id": 2775146,
                "title": "java-easy-1-liner-o-1-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n       return root.val == root.right.val + root.left.val; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n       return root.val == root.right.val + root.left.val; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977620,
                "title": "java-c-python-1line-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "**As a professional with a passion for problem-solving and collaboration, I am always looking to expand my network of like-minded individuals on LinkedIn. By connecting with me, we can work together to tackle complex challenges, share ideas, and grow both professionally and personally.**\\n\\n**Whether you\\'re an expert in your field or just starting out, I welcome connections from all backgrounds and experiences. By building a diverse and collaborative network, we can leverage our unique perspectives and skill sets to push the boundaries of what\\'s possible.**\\n\\n**So, if you\\'re interested in connecting and exploring the potential for future collaborations, please don\\'t hesitate to reach out. Let\\'s start a conversation and see where it takes us!**\\n\\n---\\n\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\n\\n---\\n***Java***\\n```\\nclass Solution\\n{\\n    public boolean checkTree(TreeNode root)\\n\\t{\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution\\n{\\npublic:\\n    bool checkTree(TreeNode* root)\\n\\t{\\n       if((root->left->val)+(root->right->val)==root->val) return true;\\n        return false;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public boolean checkTree(TreeNode root)\\n\\t{\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\npublic:\\n    bool checkTree(TreeNode* root)\\n\\t{\\n       if((root->left->val)+(root->right->val)==root->val) return true;\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934995,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)",
                "codeTag": "Java"
            },
            {
                "id": 2180137,
                "title": "python-easy-solution-with-explanation",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        # As per the def of binary tree node, we can compare the root value \\\\\\n        # with the TreeNode function, the root.left.val retrieves value of left node \\\\\\n        # the root.right.val retrieves value of right node. \\'==\\' compares two values\\n        if root.val == root.left.val + root.right.val:  \\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        # As per the def of binary tree node, we can compare the root value \\\\\\n        # with the TreeNode function, the root.left.val retrieves value of left node \\\\\\n        # the root.right.val retrieves value of right node. \\'==\\' compares two values\\n        if root.val == root.left.val + root.right.val:  \\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053858,
                "title": "javascript-solution-o-1-one-liner-81ms-basic-comparison-maths-examples",
                "content": "***Happy Coding..!* Feel free to ask Q\\'s...**\\n\\n```\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\n\\nconst checkTree = root => root.val === (root.left.val + root.right.val);\\n\\n```\\n\\n// Tree Node\\nfunction TreeNode(val, left, right) {\\n    this.val = (val === undefined ? 0 : val)\\n    this.left = (left === undefined ? null : left)\\n    this.right = (right === undefined ? null : right)\\n}\\n\\n// Test Case 1\\n// root = [10, 4, 6]\\nlet tNode1 = new TreeNode(10);\\nlet tNode2 = new TreeNode(4);\\nlet tNode3 = new TreeNode(6);\\n\\ntNode1.left = tNode2;\\ntNode1.right = tNode3;\\n\\nlet root = tNode1;\\nconsole.log(checkTree(root)); // true\\n\\n\\n***#happytohelpu***\\n\\n# ***Do upvote if you find this solution useful..***\\n",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\n\\nconst checkTree = root => root.val === (root.left.val + root.right.val);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3130162,
                "title": "easy-to-understand-for-beginners-python-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDirect Tree approach ATTACKKKKKKKKK\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val + root.right.val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val + root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058305,
                "title": "c-easy-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961431,
                "title": "hardest-binary-tree-problem-hard",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == (root->left->val+root->right->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == (root->left->val+root->right->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937186,
                "title": "javascript-one-liner",
                "content": "Let me know if you have any doubts. I try to answer/help.\\n\\nPlease upvote if you liked the solution.\\n\\n```\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1939586,
                "title": "cpp-one-liner-beats-100",
                "content": "Since we are guaranteed by the contstraints that ```root``` has a right and a left child all that we need to do is just check if the sum of the children values is equal to the value of the root.\\n```cpp\\nbool checkTree(TreeNode* root) {\\n   return root->val == root->left->val + root->right->val;    \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```root```\n```cpp\\nbool checkTree(TreeNode* root) {\\n   return root->val == root->left->val + root->right->val;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519510,
                "title": "my-checktree",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524372,
                "title": "python-one-line-solution-easy",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val+root.right.val\\n```\\n**An upvote will be encouraging**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val+root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795902,
                "title": "python-one-liner-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546066,
                "title": "javascript-easy-to-understand-one-line-solution",
                "content": "```/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3731720,
                "title": "i-ask-why-u-are-seeing-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLOL U Still opened this ......\\n# Code\\n```\\nNOTHING HERE BRO - SORRY !\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nNOTHING HERE BRO - SORRY !\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011338,
                "title": "using-single-line-expression-body",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) => root.val == root.left.val + root.right.val;\\n    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) => root.val == root.left.val + root.right.val;\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695970,
                "title": "python-simple-solution-in-4-lines",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == (root.left.val + root.right.val):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == (root.left.val + root.right.val):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602756,
                "title": "c-generic-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n      queue<TreeNode*>q;\\n      q.push(root);\\n      while(!q.empty()){\\n          int size = q.size();\\n          for(int i=0;i<size;i++){\\n          TreeNode* curr = q.front();\\n          q.pop();\\n          int parentValue = curr->val;\\n          int childValue = 0;\\n          int child = 0;\\n          if(curr->left){\\n              q.push(curr->left);\\n              childValue+=curr->left->val;\\n          }else{\\n              child++;\\n          }\\n          if(curr->right){\\n          q.push(curr->right);\\n          childValue+=curr->right->val;\\n          }else{\\n              child++;\\n          }\\n          if(child==2) continue;\\n          if(parentValue != childValue) return false;\\n          }\\n      }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n      queue<TreeNode*>q;\\n      q.push(root);\\n      while(!q.empty()){\\n          int size = q.size();\\n          for(int i=0;i<size;i++){\\n          TreeNode* curr = q.front();\\n          q.pop();\\n          int parentValue = curr->val;\\n          int childValue = 0;\\n          int child = 0;\\n          if(curr->left){\\n              q.push(curr->left);\\n              childValue+=curr->left->val;\\n          }else{\\n              child++;\\n          }\\n          if(curr->right){\\n          q.push(curr->right);\\n          childValue+=curr->right->val;\\n          }else{\\n              child++;\\n          }\\n          if(child==2) continue;\\n          if(parentValue != childValue) return false;\\n          }\\n      }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178260,
                "title": "python-oneliner",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.left.val+root.right.val == root.val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.left.val+root.right.val == root.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935634,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let root_node = root.as_ref().unwrap().borrow();\\n        let left_node = root_node.left.as_ref().unwrap().borrow();\\n        let right_node = root_node.right.as_ref().unwrap().borrow();\\n\\n        root_node.val == left_node.val + right_node.val\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let root_node = root.as_ref().unwrap().borrow();\\n        let left_node = root_node.left.as_ref().unwrap().borrow();\\n        let right_node = root_node.right.as_ref().unwrap().borrow();\\n\\n        root_node.val == left_node.val + right_node.val\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2973035,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nbool checkTree(struct TreeNode* root){\\n    if(root->val == ((root->left->val) + (root->right->val))){\\n        return true;\\n    }else {\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nbool checkTree(struct TreeNode* root){\\n    if(root->val == ((root->left->val) + (root->right->val))){\\n        return true;\\n    }else {\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2945899,
                "title": "c-one-line-code-super-easy",
                "content": "![image](https://assets.leetcode.com/users/images/be24e3a1-f1ff-4926-b2f1-9e892f9e7992_1671888672.6683366.png)\\n\\n**TC->O(1) && SC->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool checkTree(TreeNode* root) {\\n\\t\\t\\treturn root->val==root->left->val+root->right->val;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool checkTree(TreeNode* root) {\\n\\t\\t\\treturn root->val==root->left->val+root->right->val;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2683146,
                "title": "python-one-liner-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef checkTree(self, root: Optional[TreeNode]) -> bool:\\n\\t\\t\\treturn root.val == (root.left.val + root.right.val)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef checkTree(self, root: Optional[TreeNode]) -> bool:\\n\\t\\t\\treturn root.val == (root.left.val + root.right.val)",
                "codeTag": "Java"
            },
            {
                "id": 2603021,
                "title": "rust-0-ms-simple-solution-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/804824674/) employs simple operations with smart pointers. It demonstrated **0 ms runtime (100.00%)** and used **2.1 MB memory (67.14%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution \\n{\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool \\n    {\\n        // unfortunately, in Rust the use of smart pointers\\n        // is challenging due to security issues;\\n        // also, an Option requires unwrapping...\\n        \\n        // [1] unpack smart pointer and borrow TreeNode\\n        let root_node = root.as_ref().unwrap().borrow();\\n\\n        // [2] unpack left & right smart pointers and borrow their TreeNodes\\n        let left_node = root_node.left.as_ref().unwrap().borrow();\\n        let right_node = root_node.right.as_ref().unwrap().borrow();\\n\\n        root_node.val == left_node.val + right_node.val\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution \\n{\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool \\n    {\\n        // unfortunately, in Rust the use of smart pointers\\n        // is challenging due to security issues;\\n        // also, an Option requires unwrapping...\\n        \\n        // [1] unpack smart pointer and borrow TreeNode\\n        let root_node = root.as_ref().unwrap().borrow();\\n\\n        // [2] unpack left & right smart pointers and borrow their TreeNodes\\n        let left_node = root_node.left.as_ref().unwrap().borrow();\\n        let right_node = root_node.right.as_ref().unwrap().borrow();\\n\\n        root_node.val == left_node.val + right_node.val\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2581688,
                "title": "rust-solution-with-pattern-matching",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        // type(root): Option<...>, use pattern matching to handle this\\n        match root {\\n            Some(root) =>  {\\n                // what happend when we use root.borrow() ?\\n                //    1. In rust, all smart pointers(like Rc<T> here) implement Deref trait.\\n                //    2. Deref coersion, a feature provided by rust. It will convert automatically\\n                //       for us:\\n                //           a reference to a type that implements Deref \\n                //       ->  a reference to a type that Deref can convert the original type into. \\n                //    3. The borrow() method accepts a &self paramater. However, the type of root is Rc<RefCell<TreeNode>>>.\\n                //    4. We can imagine the conversion here:\\n                //           Rc<RefCell<TreeNode>> -> &RefCell<TreeNode> -> &TreeNode\\n                //                               get reference         borrows the wrapped value.\\n                let root_node = root.borrow();\\n                // type(root_node.left/right) = Option<Rc<RefCell<TreeNode>>>\\n                // , which means we need to call .unwrap() method\\n                // why use .as_ref() here ?\\n                //     because we need to take care of the ownship\\'s problem :)\\n                let left_child = root_node.left.as_ref().unwrap().borrow();\\n                let right_child = root_node.right.as_ref().unwrap().borrow();\\n                root_node.val == left_child.val + right_child.val\\n            }\\n            // a empty root is ok\\n            None => true,\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        // type(root): Option<...>, use pattern matching to handle this\\n        match root {\\n            Some(root) =>  {\\n                // what happend when we use root.borrow() ?\\n                //    1. In rust, all smart pointers(like Rc<T> here) implement Deref trait.\\n                //    2. Deref coersion, a feature provided by rust. It will convert automatically\\n                //       for us:\\n                //           a reference to a type that implements Deref \\n                //       ->  a reference to a type that Deref can convert the original type into. \\n                //    3. The borrow() method accepts a &self paramater. However, the type of root is Rc<RefCell<TreeNode>>>.\\n                //    4. We can imagine the conversion here:\\n                //           Rc<RefCell<TreeNode>> -> &RefCell<TreeNode> -> &TreeNode\\n                //                               get reference         borrows the wrapped value.\\n                let root_node = root.borrow();\\n                // type(root_node.left/right) = Option<Rc<RefCell<TreeNode>>>\\n                // , which means we need to call .unwrap() method\\n                // why use .as_ref() here ?\\n                //     because we need to take care of the ownship\\'s problem :)\\n                let left_child = root_node.left.as_ref().unwrap().borrow();\\n                let right_child = root_node.right.as_ref().unwrap().borrow();\\n                root_node.val == left_child.val + right_child.val\\n            }\\n            // a empty root is ok\\n            None => true,\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426866,
                "title": "with-explanation-comments-time-0-ms-100-space-12-6-mb-66-2",
                "content": "**Like it? ->Upvote please!**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        //check if the left & the right values equals the main root value\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        //check if the left & the right values equals the main root value\\n        return root->val == root->left->val + root->right->val;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2239768,
                "title": "swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n                guard let root = root, let leftVal = root.left?.val, let rightVal = root.right?.val else { return false }\\n        return root.val == leftVal + rightVal\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n                guard let root = root, let leftVal = root.left?.val, let rightVal = root.right?.val else { return false }\\n        return root.val == leftVal + rightVal\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096471,
                "title": "beginner-friendly-solutoin-one-line-solution",
                "content": "**Time Complexity : O(1)**\\njava\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\njavascript\\n```\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val\\n};\\n```\\npython\\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        return root.val == root.left.val + root.right.val\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\n```\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val\\n};\\n```\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        return root.val == root.left.val + root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054085,
                "title": "c-one-liner",
                "content": "```\\npublic class Solution \\n{\\n    public bool CheckTree(TreeNode root) => root.val == root.left.val+root.right.val;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public bool CheckTree(TreeNode root) => root.val == root.left.val+root.right.val;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953001,
                "title": "java-o-1-one-line-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937707,
                "title": "one-liner-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nconst checkTree = root => {\\n    return root.val === root.left.val + root.right.val \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst checkTree = root => {\\n    return root.val === root.left.val + root.right.val \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3448027,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if(root.val==root.right.val+root.left.val):\\n            return(True)\\n        return(False)\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if(root.val==root.right.val+root.left.val):\\n            return(True)\\n        return(False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360082,
                "title": "easy-to-understand-c-solution-beats-100-of-other-solutions",
                "content": "Please upvote if you like it.\\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if (root -> val == (root -> left -> val + root -> right -> val)){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if (root -> val == (root -> left -> val + root -> right -> val)){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3215805,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        return false;\\n        if(root->left->val+root->right->val==root->val)\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        return false;\\n        if(root->left->val+root->right->val==root->val)\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```\n```Java []\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761196,
                "title": "python-easy-solution",
                "content": "**Please upvote if you like my solution. Let me know in the comments if you have any suggestions to increase performance or readability.**\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```\\n\\n**Happy coding!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671683,
                "title": "c-java-python-one-line-code-faster-than-100",
                "content": "C++ : \\n-------------------------------------------------------------------\\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\nJAVA : \\n--------------------------------------------------------------------\\n```\\nclass Solution\\n{\\n    public boolean checkTree(TreeNode root)\\n\\t{\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```\\n\\n\\nPYTHON :\\n--------------------------------------------------------------------\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```\\n\\n\\nplz upvote; happy coding :)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\n    public boolean checkTree(TreeNode root)\\n\\t{\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663173,
                "title": "java-solution-one-line-code",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) { \\n        return (root.val == root.left.val + root.right.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) { \\n        return (root.val == root.left.val + root.right.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254854,
                "title": "one-line-js",
                "content": "```\\nconst checkTree =  (root) => root.val === root.right.val + root.left.val\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst checkTree =  (root) => root.val === root.right.val + root.left.val\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246142,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val ==(root.left.val +root.right.val)\\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val ==(root.left.val +root.right.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219867,
                "title": "kotlin-resolve-o-1-space",
                "content": "It is known from the condition that the binary tree consists of exactly 3 nodes. Therefore, there is no need to specify Nullable in the root: TreeNode argument. The final solution without using secure calls will take the following form:\\n```\\nclass Solution {\\n        fun checkTree(root: TreeNode) = root.`val` == root.left.`val` + root.right.`val`\\n    }\\n\\t",
                "solutionTags": [],
                "code": "class Solution {\\n        fun checkTree(root: TreeNode) = root.`val` == root.left.`val` + root.right.`val`\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3196201,
                "title": "java-easy-sol-0ms-beats-100-one-liner",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196200,
                "title": "beats-100-easy",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->left->val+root->right->val==root->val ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->left->val+root->right->val==root->val ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074170,
                "title": "java-applicable-to-all-trees-for-beginners-o-1",
                "content": "Can be used for all Trees\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// Applicable to all Trees\\nclass Solution \\n{\\n    int num = 0;\\n\\n    public boolean checkTree(TreeNode root) \\n    {\\n        inorder(root);\\n\\n        //subtract the root val and cmp them\\n        if((num - root.val) == root.val)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    //recursive function\\n    public void inorder(TreeNode node)\\n    {\\n        //if reach the end\\n        if (node == null)\\n            return;\\n \\n        //recuring on the left child\\n        inorder(node.left);\\n \\n        //add all the values\\n        num += node.val;\\n \\n        //then recuring on the right child\\n        inorder(node.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// Applicable to all Trees\\nclass Solution \\n{\\n    int num = 0;\\n\\n    public boolean checkTree(TreeNode root) \\n    {\\n        inorder(root);\\n\\n        //subtract the root val and cmp them\\n        if((num - root.val) == root.val)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    //recursive function\\n    public void inorder(TreeNode node)\\n    {\\n        //if reach the end\\n        if (node == null)\\n            return;\\n \\n        //recuring on the left child\\n        inorder(node.left);\\n \\n        //add all the values\\n        num += node.val;\\n \\n        //then recuring on the right child\\n        inorder(node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925093,
                "title": "98-faster-solution-easy-to-understand",
                "content": "![Screenshot 2022-12-18 at 16.02.43.png](https://assets.leetcode.com/users/images/f4d30438-82c5-495e-9d39-e54807f78a6b_1671361444.7605064.png)\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val+root.right.val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val+root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895960,
                "title": "c-easiest-way-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        TreeNode* l = root->left;\\n        TreeNode* r = root->right;\\n\\n        return root->val == l->val + r->val;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        TreeNode* l = root->left;\\n        TreeNode* r = root->right;\\n\\n        return root->val == l->val + r->val;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827085,
                "title": "java-one-line-code",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val==root.left.val+root.right.val;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val==root.left.val+root.right.val;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792297,
                "title": "c-one-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n     return (root->val==(root->left->val + root->right->val));  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n     return (root->val==(root->left->val + root->right->val));  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766329,
                "title": "one-line-solution",
                "content": "```\\ndef checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==(root.left.val+root.right.val)\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\ndef checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==(root.left.val+root.right.val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2761009,
                "title": "c-1-line-approach-o-1-time-complexity",
                "content": "bool checkTree(TreeNode* root) {\\n       \\n        if(root->val == (root->left->val + root->right->val))return true;\\n        else return false;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "bool checkTree(TreeNode* root) {\\n       \\n        if(root->val == (root->left->val + root->right->val))return true;\\n        else return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2755142,
                "title": "python-simple-python-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 58 ms, faster than 50.14% of Python3 online submissions for Root Equals Sum of Children.\\n# Memory Usage: 13.8 MB, less than 94.99% of Python3 online submissions for Root Equals Sum of Children.\\n\\n\\tclass Solution:\\n\\t\\tdef checkTree(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tif root != None:\\n\\n\\t\\t\\t\\tif root.val == root.left.val + root.right.val:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 58 ms, faster than 50.14% of Python3 online submissions for Root Equals Sum of Children.\\n# Memory Usage: 13.8 MB, less than 94.99% of Python3 online submissions for Root Equals Sum of Children.\\n\\n\\tclass Solution:\\n\\t\\tdef checkTree(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tif root != None:\\n\\n\\t\\t\\t\\tif root.val == root.left.val + root.right.val:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2744279,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2509473,
                "title": "three-different-solutions-for-beginner-s",
                "content": "##### **Solution : 1**\\n```\\n    def checkTree(self, root):\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        return False\\n```\\n\\n##### **Solution : 2**\\n```\\n    def checkTree(self, root):\\n        return (root.val == root.left.val + root.right.val)\\n```\\n\\n##### **Solution : 3**\\n```\\n    def checkTree(self, root):\\n        total = root.left.val + root.right.val\\n        return total == root.val\\n```\\n\\nLiked it? Please **UpVote**",
                "solutionTags": [],
                "code": "```\\n    def checkTree(self, root):\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        return False\\n```\n```\\n    def checkTree(self, root):\\n        return (root.val == root.left.val + root.right.val)\\n```\n```\\n    def checkTree(self, root):\\n        total = root.left.val + root.right.val\\n        return total == root.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2506582,
                "title": "python-one-line-code-tree",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499960,
                "title": "java-solution-one-line-of-code-1ms-runtime-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return (root.left.val + root.right.val) == root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return (root.left.val + root.right.val) == root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403440,
                "title": "java-one-liner",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393335,
                "title": "safest-1-line-kotlin-solution-all-edge-cases-covered",
                "content": "```class Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return if((root?.`val` ?: 0) == (root?.right?.`val` ?: 0) + (root?.left?.`val` ?: 0)) true else false\\n    }\\n}",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "class Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return if((root?.`val` ?: 0) == (root?.right?.`val` ?: 0) + (root?.left?.`val` ?: 0)) true else false\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2262869,
                "title": "c-simple-oneline-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == root->left->val + root->right->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == root->left->val + root->right->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098710,
                "title": "c-one-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val==root->right->val+root->left->val?1:0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val==root->right->val+root->left->val?1:0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005563,
                "title": "python-solution",
                "content": "**Upvote** if you like solution and feel **free to ask** If you have any question.\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == (root.left.val + root.right.val):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == (root.left.val + root.right.val):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978941,
                "title": "haven-t-seen-this-much-simple-question",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val) \\n            return true; \\n        return false;\\n    }\\n}; // please upvote if it helps you!\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val) \\n            return true; \\n        return false;\\n    }\\n}; // please upvote if it helps you!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004701,
                "title": "0ms-beats-100-00-of-users-with-c-1-line-code",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->left->val+root->right->val==root->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->left->val+root->right->val==root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985693,
                "title": "c-1-line-code-tc-o-n",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAs they have informed tree has only 3 nodes , so its easy to access them . left + right == root ?\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984030,
                "title": "easy-one-liner-solution-in-c",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->left->val + root->right->val == root->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->left->val + root->right->val == root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783934,
                "title": "fix-documentation-before",
                "content": "# Fix documentation\\nProperties of TreeNode were not type hinted, after fixing this, solution is easy!\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     public $val = null;\\n *     public TreeNode $left = null;\\n *     public TreeNode $right = null;\\n *     function __construct($val = 0, TreeNode $left = null, TreeNode $right = null) {\\n *         $this->val = $val;\\n *         $this->left = $left;\\n *         $this->right = $right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function checkTree(TreeNode $root) {\\n        return $root->val === ($root->left->val + $root->right->val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     public $val = null;\\n *     public TreeNode $left = null;\\n *     public TreeNode $right = null;\\n *     function __construct($val = 0, TreeNode $left = null, TreeNode $right = null) {\\n *         $this->val = $val;\\n *         $this->left = $left;\\n *         $this->right = $right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function checkTree(TreeNode $root) {\\n        return $root->val === ($root->left->val + $root->right->val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735396,
                "title": "easy-3-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665571,
                "title": "check-this-out",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        bool checkRootValue = root.val == (root.left.val + root.right.val) ? true : false;\\n        return checkRootValue;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        bool checkRootValue = root.val == (root.left.val + root.right.val) ? true : false;\\n        return checkRootValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410421,
                "title": "what-if-the-height-of-the-tree-was-more-than-two",
                "content": "\\n\\n**This code will work for the tree with  any number of height.**\\n# Code\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null&&root.right==null)\\n        return true;\\n        int sum=0;\\n        if(root.left!=null)\\n         sum+=root.left.val;\\n        \\n        if(root.right!=null) \\n        sum+=root.right.val;\\n       \\n        return (sum==root.val&&checkTree(root.left)&&checkTree(root.right));\\n    }\\n}\\n```\\nplease upvote if you find it helpful.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null&&root.right==null)\\n        return true;\\n        int sum=0;\\n        if(root.left!=null)\\n         sum+=root.left.val;\\n        \\n        if(root.right!=null) \\n        sum+=root.right.val;\\n       \\n        return (sum==root.val&&checkTree(root.left)&&checkTree(root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364957,
                "title": "c-1-liner",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val +root->right->val));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val +root->right->val));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253905,
                "title": "c-super-ez-tree-prob",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        if(root == null)\\n            return true;\\n        if(root.left == null && root.right != null)\\n            return (root.val == root.right.val);\\n        else if(root.right == null && root.left != null)\\n            return (root.val == root.left.val);\\n        else\\n            return (root.val == (root.right.val + root.left.val));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        if(root == null)\\n            return true;\\n        if(root.left == null && root.right != null)\\n            return (root.val == root.right.val);\\n        else if(root.right == null && root.left != null)\\n            return (root.val == root.left.val);\\n        else\\n            return (root.val == (root.right.val + root.left.val));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206666,
                "title": "java-100-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.right.val + root.left.val == root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.right.val + root.left.val == root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200221,
                "title": "java-1-liner-approach-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169261,
                "title": "js",
                "content": "# Intuition\\nCheck if the sume of the left and right children is equal to the value of the node.\\n\\n# Complexity\\n- Time complexity: O(1): performs a constant amount of work\\n\\n- Space complexity: O(1): does not use any additional variables / data structures\\n\\n# Code\\n```\\nconst checkTree = (root) => {\\n    return root.val === (root.left.val) + (root.right.val)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst checkTree = (root) => {\\n    return root.val === (root.left.val) + (root.right.val)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2939455,
                "title": "c-2-liner-easy-solution-beat-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n        if(root->val==(root->right->val + root->left->val))\\n        return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n        if(root->val==(root->right->val + root->left->val))\\n        return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854093,
                "title": "pattern-matching",
                "content": "# Intuition\\nBeing passed in a struct was a little weird compared to the example passing in a list. \\n\\n# Approach\\nPattern match the different inputs to return false with the last pattern doing the summation. Might not be the most efficient but it does work.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n#\\n# defmodule TreeNode do\\n#   @type t :: %__MODULE__{\\n#           val: integer,\\n#           left: TreeNode.t() | nil,\\n#           right: TreeNode.t() | nil\\n#         }\\n#   defstruct val: 0, left: nil, right: nil\\n# end\\n\\ndefmodule Solution do\\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\\n  def check_tree(nil), do: false\\n  def check_tree(%TreeNode{left: nil}), do: false\\n  def check_tree(%TreeNode{right: nil}), do: false\\n  def check_tree(%TreeNode{val: total, left: left, right: right}) do\\n    left.val + right.val == total\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n#\\n# defmodule TreeNode do\\n#   @type t :: %__MODULE__{\\n#           val: integer,\\n#           left: TreeNode.t() | nil,\\n#           right: TreeNode.t() | nil\\n#         }\\n#   defstruct val: 0, left: nil, right: nil\\n# end\\n\\ndefmodule Solution do\\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\\n  def check_tree(nil), do: false\\n  def check_tree(%TreeNode{left: nil}), do: false\\n  def check_tree(%TreeNode{right: nil}), do: false\\n  def check_tree(%TreeNode{val: total, left: left, right: right}) do\\n    left.val + right.val == total\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2821687,
                "title": "java-detailed-explanation-o-1-time-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJava Solution to Root Equals Sum Of Children.\\n\\nDetailed explanation included in code comments.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ constant time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ no additional space is used, only constant needed for the boolean returned by the function.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * Checks A Binary Tree Root Node Consisting Of 3 Nodes (Root, Left Child, Right Child)\\n     * To See If Sum Of Children Node Values Equals Root Node Value.\\n     * @param TreeNode - Root node of a binary tree consisting of 3 nodes: root, left, and right children nodes.\\n     * @return boolean - True if sum of children node values equals root node value, false otherwise.\\n     */\\n    public boolean checkTree(TreeNode root) {\\n        // Sum of left and right children nodes of the root node equal root value\\n        if (root.left.val + root.right.val == root.val)\\n        {\\n            return true;\\n        }\\n\\n        // Return false when sum of right and left children nodes values not equal root node value\\n        return false;\\n\\n        // NOTE: Could also solve using one line shown below\\n        // return root.val == root.right.val + root.left.val; \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * Checks A Binary Tree Root Node Consisting Of 3 Nodes (Root, Left Child, Right Child)\\n     * To See If Sum Of Children Node Values Equals Root Node Value.\\n     * @param TreeNode - Root node of a binary tree consisting of 3 nodes: root, left, and right children nodes.\\n     * @return boolean - True if sum of children node values equals root node value, false otherwise.\\n     */\\n    public boolean checkTree(TreeNode root) {\\n        // Sum of left and right children nodes of the root node equal root value\\n        if (root.left.val + root.right.val == root.val)\\n        {\\n            return true;\\n        }\\n\\n        // Return false when sum of right and left children nodes values not equal root node value\\n        return false;\\n\\n        // NOTE: Could also solve using one line shown below\\n        // return root.val == root.right.val + root.left.val; \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744869,
                "title": "c-recursive-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL || (root->left==NULL && root->right==NULL)){return true;}\\n        int l, r;\\n        if(root->left!=NULL){l=root->left->val;}else{l=0;}\\n        if(root->right!=NULL){r=root->right->val;}else{r=0;}\\n        if(root->val!=(l+r)){return false;}\\n        return checkTree(root->left) && checkTree(root->right);\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL || (root->left==NULL && root->right==NULL)){return true;}",
                "codeTag": "Java"
            },
            {
                "id": 2661568,
                "title": "java-solution-recursive-0ms",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->Auxillary stack space.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left!=null && root.right!=null)\\n        {\\n        if(root.val==root.left.val+root.right.val)return true;}\\n        checkTree(root.left);\\n        checkTree(root.right);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left!=null && root.right!=null)\\n        {\\n        if(root.val==root.left.val+root.right.val)return true;}\\n        checkTree(root.left);\\n        checkTree(root.right);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641237,
                "title": "c-one-liner",
                "content": "```\\nbool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val + root->right->val));\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val + root->right->val));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2637705,
                "title": "java-easy-to-understand-not-one-liner",
                "content": "Runtime - 1ms\\nUsing a \\'temp\\' TreeNode to store \\'root\\'.\\n\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        TreeNode temp = root; //Creating temp TreeNode\\n        int sum=0;\\n        root = root.left; //Traversing to left node\\n        sum = sum + root.val; //Adding left node value\\n        root = temp; //Returning to Root Node\\n        root = root.right;  //Traversing to right node\\n        sum = sum + root.val; //Adding right node value\\n        if(sum == temp.val) return true; //Final condition\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        TreeNode temp = root; //Creating temp TreeNode\\n        int sum=0;\\n        root = root.left; //Traversing to left node\\n        sum = sum + root.val; //Adding left node value\\n        root = temp; //Returning to Root Node\\n        root = root.right;  //Traversing to right node\\n        sum = sum + root.val; //Adding right node value\\n        if(sum == temp.val) return true; //Final condition\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589206,
                "title": "single-line-code-javascript",
                "content": "```\\nvar checkTree = function(root) {    \\n    return root.val === root.left.val + root.right.val ? true : false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar checkTree = function(root) {    \\n    return root.val === root.left.val + root.right.val ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2579229,
                "title": "easy-one-liner-c",
                "content": "# One Line\\n\\n```\\nbool checkTree(TreeNode* root) {\\n        return (root->val) == (root->left)->val + (root->right)->val ? true : false;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkTree(TreeNode* root) {\\n        return (root->val) == (root->left)->val + (root->right)->val ? true : false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2552128,
                "title": "1-liner-java-c-very-easy",
                "content": "```\\n// Java Solution\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n\\n\\n\\n// C++ Solution\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n// Java Solution\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n\\n\\n\\n// C++ Solution\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506775,
                "title": "simplest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val + root->right->val));    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val + root->right->val));    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492642,
                "title": "java-5-lines-code-100-faster-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        int sum = 0;\\n        sum = root.left.val + root.right.val;\\n        if(root.val == sum){\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```\\n**Thanks for visiting :)**",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        int sum = 0;\\n        sum = root.left.val + root.right.val;\\n        if(root.val == sum){\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462159,
                "title": "python-simple-and-faster-solution",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        d=root.val\\n        self.res=0\\n        def dsf(root):\\n            if(root==None):\\n                return \\n            if(root.left==None and root.right==None):\\n                self.res+=root.val\\n            else:\\n                dsf(root.left)\\n                dsf(root.right)\\n        dsf(root)\\n        return self.res==d\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        d=root.val\\n        self.res=0\\n        def dsf(root):\\n            if(root==None):\\n                return \\n            if(root.left==None and root.right==None):\\n                self.res+=root.val\\n            else:\\n                dsf(root.left)\\n                dsf(root.right)\\n        dsf(root)\\n        return self.res==d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433136,
                "title": "root-equals-sum-of-children-solution-java",
                "content": "class Solution {\\n  public boolean checkTree(TreeNode root) {\\n    return root.val == root.left.val + root.right.val;\\n  }\\n}\\n",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n  public boolean checkTree(TreeNode root) {\\n    return root.val == root.left.val + root.right.val;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2342925,
                "title": "root-equals-sum-of-children",
                "content": "```\\nvar checkTree = function(root) {\\n    // let binary = (root[0] === root[1]+root[2])? true: false\\n    return root.val === root.left.val+root.right.val\\n    //return binary;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkTree = function(root) {\\n    // let binary = (root[0] === root[1]+root[2])? true: false\\n    return root.val === root.left.val+root.right.val\\n    //return binary;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329524,
                "title": "python-100-faster-one-line",
                "content": "return (root.left.val + root.right.val) == root.val",
                "solutionTags": [
                    "Python"
                ],
                "code": "return (root.left.val + root.right.val) == root.val",
                "codeTag": "Unknown"
            },
            {
                "id": 2312637,
                "title": "why-why-why-why-why-why",
                "content": "return (root->val == root->left->val + root->right->val);",
                "solutionTags": [],
                "code": "return (root->val == root->left->val + root->right->val);",
                "codeTag": "Unknown"
            },
            {
                "id": 2276459,
                "title": "c-easiest-solution-10-ms-runtime-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        if(root->left->val + root->right->val==root->val) return true ;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        if(root->left->val + root->right->val==root->val) return true ;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256250,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val+root.right.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val+root.right.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227427,
                "title": "simple-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196708,
                "title": "easy-one-liner-python-solution",
                "content": "Code: \\n```return root.val == (root.left.val + root.right.val)```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```return root.val == (root.left.val + root.right.val)```",
                "codeTag": "Unknown"
            },
            {
                "id": 2178290,
                "title": "one-line-killer-typescript-javascript",
                "content": "```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val === root.left.val + root.right.val\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val === root.left.val + root.right.val\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2156990,
                "title": "javascript-easy-solution",
                "content": "```\\nvar checkTree = function(root) {\\n    let value = root.left.val + root.right.val;\\n    value = value === root.val ? true : false;\\n    return value;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkTree = function(root) {\\n    let value = root.left.val + root.right.val;\\n    value = value === root.val ? true : false;\\n    return value;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2109950,
                "title": "easy-python-1-liner",
                "content": "```\\ndef checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2076045,
                "title": "php",
                "content": "```\\nfunction checkTree($root) {\\n        return $root->val === $root->left->val+$root->right->val;\\n        \\n    }\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nfunction checkTree($root) {\\n        return $root->val === $root->left->val+$root->right->val;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2028580,
                "title": "java-1-liner-short-simple-and-easy-using-shorthand-if-notation",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return ((root.left.val)+(root.right.val)==root.val)?true:false; // just used shorthand if notation in java - google it !\\n\\t\\t//root.right - > will get the right node & .val will get its value, similarly for others !\\n    }\\n}\\n```\\n\\n**Perform a dry run for better understanding !\\nHappy Coding !\\nDo upvote if it helped !**",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return ((root.left.val)+(root.right.val)==root.val)?true:false; // just used shorthand if notation in java - google it !\\n\\t\\t//root.right - > will get the right node & .val will get its value, similarly for others !\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010130,
                "title": "sharing-my-solution-in-11-languages",
                "content": "I cannot comprehend which company would ask this question and for which role ?\\nMaybe as an interviewer myself, if I ask a tree based question to a candidate, and the candidate is completely clueless - I would usually level-down the problem, but never ever to this type of level.\\n\\n@Leetcode please do not post such trivial problems on a site which is supposedly used by people preparing for coding contests/interviews.\\n\\nThis problem is good for Exercise in a textbook which has introductory chapter on Trees.\\n\\nEnough of ranting, let us discuss the solutions .....\\n\\n**C**\\n```\\nbool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```\\n\\n\\n**C#**\\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\n\\n**Go**\\n```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val;\\n}\\n```\\n\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\n\\n**Javascript**\\n```\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```\\n\\n**PHP**\\n```\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function checkTree($root) {\\n        return $root->val == $root->left->val + $root->right->val;\\n    }\\n}\\n```\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        \"\"\"\\n        :type root: Optional[TreeNode]\\n        :rtype: bool\\n        \"\"\"\\n        return root.val == root.left.val + root.right.val\\n```\\n\\n**Python3**\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n \\n```\\n\\n**Ruby**\\n```\\ndef check_tree(root)\\n    return root.val == root.left.val + root.right.val\\nend\\n```\\n\\n**TypeScript**\\n```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\n```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val;\\n}\\n```\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\n```\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```\n```\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function checkTree($root) {\\n        return $root->val == $root->left->val + $root->right->val;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        \"\"\"\\n        :type root: Optional[TreeNode]\\n        :rtype: bool\\n        \"\"\"\\n        return root.val == root.left.val + root.right.val\\n```\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n \\n```\n```\\ndef check_tree(root)\\n    return root.val == root.left.val + root.right.val\\nend\\n```\n```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1952848,
                "title": "hardest-question-needs-sophisticated-solution",
                "content": "```java\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n```\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1947025,
                "title": "every-programming-language-c-java-python-c-c-javascript-ruby-swift-go-scala-and-more",
                "content": "If you think this question is too easy, complete it in every programming language offered by LeetCode.\\n\\n**C++**:\\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```\\n\\n**Java**:\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.right.val + root.left.val;\\n    }\\n}\\n```\\n\\n**Python**:\\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        return root.val == root.right.val + root.left.val\\n```\\n\\n**Python 3**:\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.right.val + root.left.val\\n```\\n\\n**C**:\\n```\\nbool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}\\n```\\n\\n**C#**:\\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\n\\n**JavaScript**:\\n```\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```\\n\\n**Ruby**:\\n```\\ndef check_tree(root)\\n    return root.val == root.left.val + root.right.val\\nend\\n```\\n\\n**Swift**:\\n```\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        return root!.val == root!.left!.val + root!.right!.val\\n    }\\n}\\n```\\n\\n**Go**:\\n```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val;\\n}\\n```\\n\\n**Scala**:\\n```\\nobject Solution {\\n    def checkTree(root: TreeNode): Boolean = {\\n        return root.value == root.left.value + root.right.value\\n    }\\n}\\n```\\n\\n**Kotlin**:\\n```\\nclass Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return root!!.`val` == root!!.left!!.`val` + root!!.right!!.`val`\\n    }\\n}\\n```\\n\\n**Rust**:\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let root = root.as_ref().unwrap().borrow();    \\n        return root.val == root.left.as_ref().unwrap().borrow().val + root.right.as_ref().unwrap().borrow().val;\\n    }\\n}\\n```\\n\\n**PHP**:\\n```\\nclass Solution {\\n    function checkTree($root) {\\n        return $root->val == $root->left->val + $root->right->val;\\n    }\\n}\\n```\\n\\n**TypeScript**:\\n```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```\\n\\n**Racket**:\\n```\\n(define/contract (check-tree root)\\n  (-> (or/c tree-node? #f) boolean?)\\n    (eq? (tree-node-val root) (+ (tree-node-val (tree-node-left root)) (tree-node-val (tree-node-right root))))\\n  )\\n```\\n\\n**Erlang**:\\n```\\n-spec check_tree(Root :: #tree_node{} | null) -> boolean().\\ncheck_tree(Root) ->\\n  Root#tree_node.val == Root#tree_node.left#tree_node.val + Root#tree_node.right#tree_node.val.\\n```\\n\\n**Elixir**:\\n```\\ndefmodule Solution do\\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\\n  def check_tree(root) do\\n    root.val == root.left.val + root.right.val\\n  end\\nend\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Ruby",
                    "Swift",
                    "Scala",
                    "Rust"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.right.val + root.left.val;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        return root.val == root.right.val + root.left.val\\n```\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.right.val + root.left.val\\n```\n```\\nbool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}\\n```\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\n```\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```\n```\\ndef check_tree(root)\\n    return root.val == root.left.val + root.right.val\\nend\\n```\n```\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        return root!.val == root!.left!.val + root!.right!.val\\n    }\\n}\\n```\n```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val;\\n}\\n```\n```\\nobject Solution {\\n    def checkTree(root: TreeNode): Boolean = {\\n        return root.value == root.left.value + root.right.value\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return root!!.`val` == root!!.left!!.`val` + root!!.right!!.`val`\\n    }\\n}\\n```\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let root = root.as_ref().unwrap().borrow();    \\n        return root.val == root.left.as_ref().unwrap().borrow().val + root.right.as_ref().unwrap().borrow().val;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    function checkTree($root) {\\n        return $root->val == $root->left->val + $root->right->val;\\n    }\\n}\\n```\n```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```\n```\\n(define/contract (check-tree root)\\n  (-> (or/c tree-node? #f) boolean?)\\n    (eq? (tree-node-val root) (+ (tree-node-val (tree-node-left root)) (tree-node-val (tree-node-right root))))\\n  )\\n```\n```\\n-spec check_tree(Root :: #tree_node{} | null) -> boolean().\\ncheck_tree(Root) ->\\n  Root#tree_node.val == Root#tree_node.left#tree_node.val + Root#tree_node.right#tree_node.val.\\n```\n```\\ndefmodule Solution do\\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\\n  def check_tree(root) do\\n    root.val == root.left.val + root.right.val\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945881,
                "title": "c-solution",
                "content": "My little solution in C#\\n\\n\\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        \\n        int left = root.left.val;\\n        int right= root.right.val;\\n        \\n        return(left+right==root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        \\n        int left = root.left.val;\\n        int right= root.right.val;\\n        \\n        return(left+right==root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944211,
                "title": "javascript-js",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function (root) {\\n  return root.val === root.left.val + root.right.val;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function (root) {\\n  return root.val === root.left.val + root.right.val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1940061,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val == root->left->val + root->right->val)\\n            return true; \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val == root->left->val + root->right->val)\\n            return true; \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938760,
                "title": "rust-0ms-pattern-matching",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match root {\\n            Some(node) => match (node.borrow().left.as_ref(), node.borrow().right.as_ref()) {\\n                (Some(left), Some(right)) => {\\n                    left.borrow().val + right.borrow().val == node.borrow().val\\n                }\\n                _ => true,\\n            },\\n            None => true,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match root {\\n            Some(node) => match (node.borrow().left.as_ref(), node.borrow().right.as_ref()) {\\n                (Some(left), Some(right)) => {\\n                    left.borrow().val + right.borrow().val == node.borrow().val\\n                }\\n                _ => true,\\n            },\\n            None => true,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1938094,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935170,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode node) {\\n        if(node.left == null){\\n            return true;\\n        }\\n        if(node.right==null){\\n            return true;\\n        }\\n        checkTree(node.left);\\n        checkTree(node.right);\\n        if(node.val == node.left.val + node.right.val){\\n            return true;\\n            \\n        }\\n        else{\\n            return false;\\n        }\\n        \\n      \\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode node) {\\n        if(node.left == null){\\n            return true;\\n        }\\n        if(node.right==null){\\n            return true;\\n        }\\n        checkTree(node.left);\\n        checkTree(node.right);\\n        if(node.val == node.left.val + node.right.val){\\n            return true;\\n            \\n        }\\n        else{\\n            return false;\\n        }\\n        \\n      \\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934711,
                "title": "don-t-see-the-point-of-this-problem",
                "content": "```\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val+root.right.val\\n```",
                "solutionTags": [],
                "code": "```\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val+root.right.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4063581,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root.val==root.left.val+root.right.val) return true;\\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root.val==root.left.val+root.right.val) return true;\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964841,
                "title": "100-faster-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        int sum = root->left->val + root->right->val;\\n\\n        return root->val == sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        int sum = root->left->val + root->right->val;\\n\\n        return root->val == sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877448,
                "title": "2-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\n       if(root.val==root.left.val+root.right.val)return true;\\n       return false;\\n        \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\n       if(root.val==root.left.val+root.right.val)return true;\\n       return false;\\n        \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793957,
                "title": "root-equals-sum-of-children",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/d16f0b89-7c41-4ab2-8a87-436262395422_1689877762.281462.png)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val==root.left.val+root.right.val:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val==root.left.val+root.right.val:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757098,
                "title": "clean-and-easy-with-type-hinting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     public $val = null;\\n *     public $left = null;\\n *     public $right = null;\\n *     function __construct($val = 0, $left = null, $right = null) {\\n *         $this->val = $val;\\n *         $this->left = $left;\\n *         $this->right = $right;\\n *     }\\n * }\\n */\\nclass Solution\\n{\\n    function checkTree(TreeNode $root): bool\\n    {\\n        return $root->left->val + $root->right->val === $root->val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     public $val = null;\\n *     public $left = null;\\n *     public $right = null;\\n *     function __construct($val = 0, $left = null, $right = null) {\\n *         $this->val = $val;\\n *         $this->left = $left;\\n *         $this->right = $right;\\n *     }\\n * }\\n */\\nclass Solution\\n{\\n    function checkTree(TreeNode $root): bool\\n    {\\n        return $root->left->val + $root->right->val === $root->val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698924,
                "title": "2-line-sol-beats-100-c",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val==(root->left->val+root->right->val)) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val==(root->left->val+root->right->val)) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555807,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        int s=0;\\n        if(root.left!=null) s+=root.left.val;\\n        if(root.right!=null) s+=root.right.val;\\n        \\n        return (root.val==s && checkTree(root.left) && checkTree(root.right)) ;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        int s=0;\\n        if(root.left!=null) s+=root.left.val;\\n        if(root.right!=null) s+=root.right.val;\\n        \\n        return (root.val==s && checkTree(root.left) && checkTree(root.right)) ;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532202,
                "title": "swift-recursive-solution",
                "content": "Recursive solution:\\n```\\nclass Solution {\\n\\n    func sum(_ root: TreeNode?) -> Int {\\n        guard let root = root else {\\n            return 0\\n        }\\n\\n        return root.val + sum(root.left) + sum(root.right)\\n    }\\n\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n\\n        return root.val == sum(root.left) + sum(root.right)\\n    }\\n}\\n```\\n\\nOne liner:\\n\\n```\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        return (root?.val ?? -1) - (root?.left?.val ?? 0) - (root?.right?.val ?? 0) == 0\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    func sum(_ root: TreeNode?) -> Int {\\n        guard let root = root else {\\n            return 0\\n        }\\n\\n        return root.val + sum(root.left) + sum(root.right)\\n    }\\n\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n\\n        return root.val == sum(root.left) + sum(root.right)\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        return (root?.val ?? -1) - (root?.left?.val ?? 0) - (root?.right?.val ?? 0) == 0\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505689,
                "title": "easiest-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\n        TreeNode node1 =root.left;\\n        TreeNode node2 = root.right;\\n        if(root.val == (node1.val+node2.val)) return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\n        TreeNode node1 =root.left;\\n        TreeNode node2 = root.right;\\n        if(root.val == (node1.val+node2.val)) return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456779,
                "title": "0-ms-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root.val==root.left.val+root.right.val)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root.val==root.left.val+root.right.val)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355187,
                "title": "java-sol-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if((root.left.val+root.right.val) == root.val){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if((root.left.val+root.right.val) == root.val){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160860,
                "title": "c-and-c-one-line-solution",
                "content": "\\n# C++\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->right->val + root->left->val == root->val;\\n        \\n    }\\n    \\n};\\n```\\n\\n# C Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nbool checkTree(struct TreeNode* root){\\n    return root->right->val + root->left->val == root->val;\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->right->val + root->left->val == root->val;\\n        \\n    }\\n    \\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nbool checkTree(struct TreeNode* root){\\n    return root->right->val + root->left->val == root->val;\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103175,
                "title": "root-equals-sum-of-children-using-kotlin-best-complexity-o-1",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Author: Mohamed Shaban Ahmed\\n\\n/**\\n * Example:\\n * var ti = TreeNode(5)\\n * var v = ti.`val`\\n * Definition for a binary tree node.\\n * class TreeNode(var `val`: Int) {\\n *     var left: TreeNode? = null\\n *     var right: TreeNode? = null\\n * }\\n */\\nclass Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return root!!.`val` == (root!!.left!!.`val` + root!!.right!!.`val`)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Tree"
                ],
                "code": "```\\n//Author: Mohamed Shaban Ahmed\\n\\n/**\\n * Example:\\n * var ti = TreeNode(5)\\n * var v = ti.`val`\\n * Definition for a binary tree node.\\n * class TreeNode(var `val`: Int) {\\n *     var left: TreeNode? = null\\n *     var right: TreeNode? = null\\n * }\\n */\\nclass Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return root!!.`val` == (root!!.left!!.`val` + root!!.right!!.`val`)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101716,
                "title": "2236-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Runtime : 0 ms\\n- Beats : 100%\\n- Memory : 39.6 MB\\n- Beats : 97.64%\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode r) {\\n        return r.val == r.left.val + r.right.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode r) {\\n        return r.val == r.left.val + r.right.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075269,
                "title": "dart-null-safety-solution",
                "content": "# Code\\n```\\nclass Solution {\\n  bool checkTree(TreeNode? root) {\\n      if (root == null) return false;\\n\\n      final leftValue = root.left?.val ?? 0;\\n      final rightValue = root.right?.val ?? 0;\\n\\n      return root.val == leftValue + rightValue;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  bool checkTree(TreeNode? root) {\\n      if (root == null) return false;\\n\\n      final leftValue = root.left?.val ?? 0;\\n      final rightValue = root.right?.val ?? 0;\\n\\n      return root.val == leftValue + rightValue;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063740,
                "title": "recursive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc checkTree(root *TreeNode) bool {\\n\\n     if root==nil {\\n         return true\\n     }\\n     sum:=0\\n     if root.Left!= nil {\\n         sum+=root.Left.Val\\n     }\\n      if root.Right!=nil {\\n          sum+=root.Right.Val\\n      }\\n      if sum==root.Val {\\n          return true\\n      } else {\\n          return false\\n      }\\n      sum=0\\n    return checkTree(root.Left) && checkTree(root.Right)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc checkTree(root *TreeNode) bool {\\n\\n     if root==nil {\\n         return true\\n     }\\n     sum:=0\\n     if root.Left!= nil {\\n         sum+=root.Left.Val\\n     }\\n      if root.Right!=nil {\\n          sum+=root.Right.Val\\n      }\\n      if sum==root.Val {\\n          return true\\n      } else {\\n          return false\\n      }\\n      sum=0\\n    return checkTree(root.Left) && checkTree(root.Right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3031466,
                "title": "c-easy-2-lines-code-beats-100",
                "content": "# C++ Easy solution\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val == root->left->val + root->right->val) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val == root->left->val + root->right->val) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853865,
                "title": "go-one-line-solution",
                "content": "```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2839553,
                "title": "c-one-liner-beats-100-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->left->val+ root->right->val== root->val) ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->left->val+ root->right->val== root->val) ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784979,
                "title": "for-all-depths",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    \\n    void help(TreeNode* r, int &sum)\\n    {\\n        if(!r)\\n            return ;\\n        if(!r->left && !r->right)\\n            sum+=r->val;\\n        help(r->left,sum);\\n        help(r->right,sum);\\n        \\n        \\n    }\\n    bool checkTree(TreeNode* r) {\\n        \\n        if(!r)\\n            return true;\\n        \\n        int sum = 0;\\n        help(r,sum);\\n        return r->val == sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    \\n    void help(TreeNode* r, int &sum)\\n    {\\n        if(!r)\\n            return ;\\n        if(!r->left && !r->right)\\n            sum+=r->val;\\n        help(r->left,sum);\\n        help(r->right,sum);\\n        \\n        \\n    }\\n    bool checkTree(TreeNode* r) {\\n        \\n        if(!r)\\n            return true;\\n        \\n        int sum = 0;\\n        help(r,sum);\\n        return r->val == sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751619,
                "title": "one-line-solution-c",
                "content": "Assuming that in the constraints of the problem it is specified that each input has only 3 nodes including the root, and its two right and left nodes. We can simply return an equality check between the sum of the two nodes and the root.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    public:\\n        bool checkTree(TreeNode* root) {\\n            return (root->val == (root->left->val + root->right->val));\\n        }\\n};\\n```\\n\\n**If that helped, an upvote would be welcome.**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    public:\\n        bool checkTree(TreeNode* root) {\\n            return (root->val == (root->left->val + root->right->val));\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744252,
                "title": "ruby-five-different-ways",
                "content": "# Intuition\\nWe are given the root node that has access its left and right children. Simply call its left and right right children values and see if the add up to the root\\'s value. Keep in mind that each node in the tree has a val, left, and right attribute. \\n\\n##### Root:\\nroot => root\\n\\nroot value => root.val\\n\\n##### Root\\'s Left:\\nleft child => root.left\\n\\nleft child value => root.left.val\\n\\n\\n##### Root\\'s Right:\\nright child => root.right\\n\\nright child value => root.right.val\\n\\n# Complexity\\n- Time complexity: O(1)\\nGenerally speaking operations take O(1) time and accessing the immediate children of the root node is constant as well.   \\n\\n- Space complexity: O(1)\\nSince no additional data structures are created to perform the calculations. \\n\\n# Code\\n\\n### ternary operator\\n```\\n# ternary operator\\n# time: O(1) \\n# space: O(1)\\ndef check_tree(root)\\n    root.left.val + root.right.val == root.val ? true : false\\nend\\n```\\n\\n### implicit boolean return \\n```\\n# implicit boolean return \\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    root.val == root.left.val + root.right.val\\nend\\n```\\n\\n### complement\\n```\\n# complement\\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    root.left.val == root.val - root.right.val \\nend\\n```\\n\\n### conditional part 1\\n```\\n# conditional part 1\\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    if root.val == root.left.val + root.right.val\\n        return true\\n    else\\n        return false\\n    end\\nend\\n```\\nOne can omit the return statement\\n\\n### conditional part 2  \\n```\\n# conditional part 2 \\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    return true if root.val == root.left.val + root.right.val\\n    return false\\nend\\n```\\n\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# ternary operator\\n# time: O(1) \\n# space: O(1)\\ndef check_tree(root)\\n    root.left.val + root.right.val == root.val ? true : false\\nend\\n```\n```\\n# implicit boolean return \\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    root.val == root.left.val + root.right.val\\nend\\n```\n```\\n# complement\\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    root.left.val == root.val - root.right.val \\nend\\n```\n```\\n# conditional part 1\\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    if root.val == root.left.val + root.right.val\\n        return true\\n    else\\n        return false\\n    end\\nend\\n```\n```\\n# conditional part 2 \\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    return true if root.val == root.left.val + root.right.val\\n    return false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2739176,
                "title": "python3-single-liner-code",
                "content": "python3 solution in just one line\\n\\n```\\nreturn root.val == (root.right.val + root.left.val);\\n```",
                "solutionTags": [],
                "code": "```\\nreturn root.val == (root.right.val + root.left.val);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2693206,
                "title": "cpp-easy-to-understand",
                "content": "```\\nbool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n            return false;\\n        else if(root->val==(root->left->val+root->right->val))\\n            return true;\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "```\\nbool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n            return false;\\n        else if(root->val==(root->left->val+root->right->val))\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2655474,
                "title": "c-simple-recursive-solution",
                "content": "```\\n// Please, UpVote if you like it :)\\n// Runtime: 8 ms, faster than 25.96% of C++ online submissions for Root Equals Sum of Children.\\n// Memory Usage: 12.6 MB, less than 14.35% of C++ online submissions for Root Equals Sum of Children.\\nbool checkTree(TreeNode* root) {\\n\\tif (!root || !root->left && !root->right)\\n\\t\\treturn true;\\n\\treturn (root->val == ((root->left) ? root->left->val : 0) + ((root->right) ? root->right->val : 0)) &&\\n\\t\\tcheckTree(root->left) &&\\n\\t\\tcheckTree(root->right);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// Please, UpVote if you like it :)\\n// Runtime: 8 ms, faster than 25.96% of C++ online submissions for Root Equals Sum of Children.\\n// Memory Usage: 12.6 MB, less than 14.35% of C++ online submissions for Root Equals Sum of Children.\\nbool checkTree(TreeNode* root) {\\n\\tif (!root || !root->left && !root->right)\\n\\t\\treturn true;\\n\\treturn (root->val == ((root->left) ? root->left->val : 0) + ((root->right) ? root->right->val : 0)) &&\\n\\t\\tcheckTree(root->left) &&\\n\\t\\tcheckTree(root->right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2639773,
                "title": "go-simple-solution-in-go-golang",
                "content": "Hello Gophers!\\n\\n# Problem: Root Equals Sum of Children (Easy)\\n\\n## Solution 1: One Line Solution\\n\\n```go\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val\\n}\\n```\\n\\n## Solution 2: Best Practice\\n\\nLet\\'s say we are not sure if `root` is not nil or if it has children:\\n\\n```go\\nfunc checkTree(root *TreeNode) bool {\\n    if root == nil {\\n        return false\\n    }\\n    var sum int = 0\\n    if root.Left != nil {\\n        sum += root.Left.Val\\n    }\\n    if root.Right != nil {\\n        sum += root.Right.Val\\n    }\\n    return root.Val == sum\\n}\\n```\\n\\nI hope it helped! =)",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val\\n}\\n```\n```go\\nfunc checkTree(root *TreeNode) bool {\\n    if root == nil {\\n        return false\\n    }\\n    var sum int = 0\\n    if root.Left != nil {\\n        sum += root.Left.Val\\n    }\\n    if root.Right != nil {\\n        sum += root.Right.Val\\n    }\\n    return root.Val == sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2602398,
                "title": "c-starightforward",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593043,
                "title": "one-liner-pythonic-way",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2569744,
                "title": "java-one-liner",
                "content": "Please Upvote if Helpful\\n\\n***\\n\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\n\\n***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567885,
                "title": "python3-one-line-solution",
                "content": "```\\nreturn root.val == root.left.val + root.right.val\\n```",
                "solutionTags": [],
                "code": "```\\nreturn root.val == root.left.val + root.right.val\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2530043,
                "title": "c-solution-one-line-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == (root->left->val + root->right->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == (root->left->val + root->right->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529742,
                "title": "python-easy-solution",
                "content": "```python\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        def subtreeSum(node: Optional[TreeNode], value) -> int:\\n            if not node:\\n                return 0\\n\\n            return value + subtreeSum(node.left, node.val) + subtreeSum(node.right, node.val)\\n\\n        return root.val == (subtreeSum(root.left, root.left.val) + subtreeSum(root.right, root.right.val))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        def subtreeSum(node: Optional[TreeNode], value) -> int:\\n            if not node:\\n                return 0\\n\\n            return value + subtreeSum(node.left, node.val) + subtreeSum(node.right, node.val)\\n\\n        return root.val == (subtreeSum(root.left, root.left.val) + subtreeSum(root.right, root.right.val))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526561,
                "title": "java-simple-one-line-solution-the-most-minimalistic-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\t\\treturn root.val == root.left.val + root.right.val;\\n\\t}\\n}\\n```\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\t\\treturn root.val == root.left.val + root.right.val;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507139,
                "title": "java-solution-faster-than-100-00-of-submissions",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if (root == null) \\n            return false;\\n        else \\n            return (root.val == root.left.val + root.right.val); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if (root == null) \\n            return false;\\n        else \\n            return (root.val == root.left.val + root.right.val); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503005,
                "title": "javascript-sol",
                "content": "```\\nvar checkTree = function (root) {\\n    let node = root.val;\\n    let left = root.left.val;\\n    let right = root.right.val;\\n\\n    if (node == (left + right)) { return true }\\n    return false\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkTree = function (root) {\\n    let node = root.val;\\n    let left = root.left.val;\\n    let right = root.right.val;\\n\\n    if (node == (left + right)) { return true }\\n    return false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2495069,
                "title": "javascript",
                "content": "```\\nconst checkTree = (root) => root.val === (root.right.val + root.left.val)\\n```\\n\\nRuntime: 62 ms, faster than 96.61% of JavaScript online submissions for Root Equals Sum of Children.\\nMemory Usage: 42.2 MB, less than 98.62% of JavaScript online submissions for Root Equals Sum of Children.",
                "solutionTags": [],
                "code": "```\\nconst checkTree = (root) => root.val === (root.right.val + root.left.val)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2480656,
                "title": "c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val==root->left->val+root->right->val)\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val==root->left->val+root->right->val)\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2475103,
                "title": "2236-root-equals-sum-of-children",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        if(root->left->val + root->right->val == root->val)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        if(root->left->val + root->right->val == root->val)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465225,
                "title": "java-1-line-easy",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448051,
                "title": "single-line-solution-clean-c-code",
                "content": "# If you liked this solution then do upvote.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440740,
                "title": "java-1-liner-1ms",
                "content": "# Please Upvote\\n\\n```\\nreturn root.val == (root.right.val + root.left.val);\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nreturn root.val == (root.right.val + root.left.val);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420305,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val==(root.left).val+(root.right).val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val==(root.left).val+(root.right).val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1693829,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1564888,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1565649,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1735919,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1925445,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1570895,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1861691,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1726629,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1698119,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1576632,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1693829,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1564888,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1565649,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1735919,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1925445,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1570895,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1861691,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1726629,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1698119,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1576632,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 2047005,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 1945995,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 1737102,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2047791,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2001533,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 1998810,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2058053,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2051470,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2046940,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2046108,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 1997803,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1991957,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1990410,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1936881,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1926382,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1922463,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1903034,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1878259,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1853444,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1842313,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            }
        ]
    }
]