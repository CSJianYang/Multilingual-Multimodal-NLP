[
    {
        "title": "Count Good Triplets in an Array",
        "question_content": "You are given two 0-indexed arrays nums1 and nums2 of length n, both of which are permutations of [0, 1, ..., n - 1].\nA good triplet is a set of 3 distinct values which are present in increasing order by position both in nums1 and nums2. In other words, if we consider pos1v as the index of the value v in nums1 and pos2v as the index of the value v in nums2, then a good triplet will be a set (x, y, z) where 0 <= x, y, z <= n - 1, such that pos1x < pos1y < pos1z and pos2x < pos2y < pos2z.\nReturn the total number of good triplets.\n&nbsp;\nExample 1:\n\nInput: nums1 = [2,0,1,3], nums2 = [0,1,2,3]\nOutput: 1\nExplanation: \nThere are 4 triplets (x,y,z) such that pos1x < pos1y < pos1z. They are (2,0,1), (2,0,3), (2,1,3), and (0,1,3). \nOut of those triplets, only the triplet (0,1,3) satisfies pos2x < pos2y < pos2z. Hence, there is only 1 good triplet.\n\nExample 2:\n\nInput: nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]\nOutput: 4\nExplanation: The 4 good triplets are (4,0,3), (4,0,2), (4,1,3), and (4,1,2).\n\n&nbsp;\nConstraints:\n\n\tn == nums1.length == nums2.length\n\t3 <= n <= 105\n\t0 <= nums1[i], nums2[i] <= n - 1\n\tnums1 and nums2 are permutations of [0, 1, ..., n - 1].",
        "solutions": [
            {
                "id": 1783205,
                "title": "python-explanation-with-pictures-o-n-logn-time",
                "content": "We focus on the middle element of the triplet. \\n\\n> For an element a, how many triplets are centered at a?\\n\\nThis problem equals to:\\n\\n- How many elements on a\\'s left in both A and B;\\n- How many elements on a\\'s right in both A and B;\\n\\n\\nTake a look at the figure below.\\n\\nLet\\'s say we focus on the number **N** with index of 5 in A, suppose we find two numbers **s1, s2** which are on **N\\'s left** in both A and B, and two numbers **b1, b2** which are on **N\\'s right** in both A and B.\\nThen the number of unique triplets **centered at N** is 2 * 2.\\n\\n![image](https://assets.leetcode.com/users/images/a885bd96-5a34-4e56-8c9c-60bc08faaf85_1645286474.768027.png)\\n\\n\\nTherefore, for each element **a**, we could count how many elements on a\\'s left in both two arrays A and B.\\nSimilarly, count how many elements on a\\'s right in both two arrays A and B (and get their product).\\n\\n\\n\\n---\\n\\nStart with building `pre_a`.  \\nApparently, there is no element on A[0] left, thus `pre_a[0] = 0`.\\nSave the index of A[0] in B in `pos_in_b`, for future binary search. \\n\\n![image](https://assets.leetcode.com/users/images/34eb542f-4b18-4e75-a042-eabfeb2e96ee_1645286480.474593.png)\\n\\nNow we are visiting **A[1]**, it\\'s guaranteed that there is one element (A[0]) on **A[1]**\\'s left in A, but how about the case in B?\\n\\n> It can be calculated by binary searching the index of **1** in `pos_in_b`. \\n> The indexes on **1**\\'s left in `pos_in_b` stands for the elements on A[1]\\'s left in B.\\n\\n![image](https://assets.leetcode.com/users/images/718a8ad9-7c6d-46fd-a882-7eb9af41f014_1645286489.257238.png)\\n\\nSo on so forth, until we finish the iteration.\\n\\n> We can take adavantage of BST which allows binary search and insertion in logN time.\\n\\n![image](https://assets.leetcode.com/users/images/5deea4e0-2825-444d-9bce-532f8c09de66_1645286492.4814947.png)\\n\\nBuild `suf_a` in the similar way.\\n\\n![image](https://assets.leetcode.com/users/images/24b8be2d-499c-4749-8716-4d29f11c26ee_1645286495.6647327.png)\\n\\nFinally, iterate over `pre_a` and `suf_a` and sum up the number of triplets centered at each element.\\n\\n![image](https://assets.leetcode.com/users/images/98ab6b99-1e84-4a06-8554-22be6f3345a1_1645286499.2182465.png)\\n\\n**Python**\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def goodTriplets(self, A: List[int], B: List[int]) -> int:\\n        # Index of a (from A) in B.\\n        pos = [0] * len(A)               \\n        for idx, b in enumerate(B):\\n            pos[b] = idx\\n        \\n        # Build pre_a[i]: number of elements on a[i]\\'s left in both A and B.\\n        # pos_in_b: sorted indexes (in B) of all the visited elements in A.\\n        pos_in_b, pre_a = SortedList([pos[A[0]]]), [0]      \\n        for a in A[1:]:       \\n            pos_in_b.add(pos[a])\\n            pre_a.append(pos_in_b.bisect_left(pos[a]))\\n    \\n        # Build suf_a[i]: number of elements on a[i]\\'s right in both A and B.\\n        pos_in_b, suf_a = SortedList([pos[A[-1]]]), [0]\\n        for a in reversed(A[:len(A)-1]):\\n            idx = pos_in_b.bisect(pos[a])\\n            suf_a.append(len(pos_in_b) - idx)\\n            pos_in_b.add(pos[a])\\n        suf_a.reverse()\\n        \\n        # Sum up all unique triplets centered on A[i].\\n        ans = 0\\n        for x, y in zip(pre_a, suf_a):\\n            ans += x * y\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def goodTriplets(self, A: List[int], B: List[int]) -> int:\\n        # Index of a (from A) in B.\\n        pos = [0] * len(A)               \\n        for idx, b in enumerate(B):\\n            pos[b] = idx\\n        \\n        # Build pre_a[i]: number of elements on a[i]\\'s left in both A and B.\\n        # pos_in_b: sorted indexes (in B) of all the visited elements in A.\\n        pos_in_b, pre_a = SortedList([pos[A[0]]]), [0]      \\n        for a in A[1:]:       \\n            pos_in_b.add(pos[a])\\n            pre_a.append(pos_in_b.bisect_left(pos[a]))\\n    \\n        # Build suf_a[i]: number of elements on a[i]\\'s right in both A and B.\\n        pos_in_b, suf_a = SortedList([pos[A[-1]]]), [0]\\n        for a in reversed(A[:len(A)-1]):\\n            idx = pos_in_b.bisect(pos[a])\\n            suf_a.append(len(pos_in_b) - idx)\\n            pos_in_b.add(pos[a])\\n        suf_a.reverse()\\n        \\n        # Sum up all unique triplets centered on A[i].\\n        ans = 0\\n        for x, y in zip(pre_a, suf_a):\\n            ans += x * y\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783180,
                "title": "python-2-fenwick-trees-solution-explained",
                "content": "First of all notice, that if we change order of one permutation, say we sort it, then it is enough for the second permutation to look for number of increasing triplets. Let us consider example, where we have `arr = [9, 8, 4, 2, 5, 1, 6, 0, 3, 7]` and look what we have in our BITs after each iteration.\\n1. First element is `9`, so we update `BIT1` and have `[0, 0, 0, 0, 0, 0, 0, 0, 0, 1]` now, then we have `[0, 0, 0, 0, 0, 0, 0, 0, 1, 1]`, then we have `[0, 0, 0, 0, 1, 0, 0, 0, 1, 1]` and so on.\\n2. What is `BIT2` BIT used for? It is for each element to know how many element less than it we already met before. It will change like this `[0, 0, 0, 0, 0, 0, 0, 0, 0, 0] -> [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] -> [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] -> [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] -> [0, 0, 0, 0, 0, 2, 0, 0, 0, 0]` and so on. On the `5`-th step we get `2`, because when we add `5`, we already have `4` and `2` added before. After next iteration when we add `1`, nothing change and when we add `6`, we have `[0, 0, 0, 0, 0, 2, 4, 0, 0, 0]`, because we have `4` numbers less than `6` already.\\n3. Finally, when we add new number, how to calculate number of increasing triplets which end with this number? In fact this is sum of all elements before `i` in our `BIT2`! Why? Because what we keep in our `BIT2`: number of pairs which are increasing: to get increasing triple we need to have increasing pair and add one more element.\\n\\n#### Bonus\\nWhat if you asked to find number of increasing `4-tuples` or `5-tuples`, then you can easily extend it to this case!\\n\\n#### Complexity\\nIt is `O(n log n)` for time and space.\\n\\n#### Code\\n```python\\nclass BIT:\\n    def __init__(self, n):\\n        self.sums = [0] * (n+1)\\n    \\n    def update(self, i, delta):\\n        while i < len(self.sums):\\n            self.sums[i] += delta\\n            i += i & (-i)\\n    \\n    def query(self, i):\\n        res = 0\\n        while i > 0:\\n            res += self.sums[i]\\n            i -= i & (-i)\\n        return res\\n\\nclass Solution:\\n    def goodTriplets(self, A, B):\\n        d = {x: i for i, x in enumerate(A)}\\n        n = len(A)\\n        arr = [d[B[i]] for i in range(n)]\\n\\n        BIT1, BIT2, ans = BIT(n), BIT(n), 0\\n        for i in arr:\\n            ans += BIT2.query(i)\\n            BIT1.update(i + 1, 1)\\n            less = BIT1.query(i)\\n            BIT2.update(i + 1, less)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass BIT:\\n    def __init__(self, n):\\n        self.sums = [0] * (n+1)\\n    \\n    def update(self, i, delta):\\n        while i < len(self.sums):\\n            self.sums[i] += delta\\n            i += i & (-i)\\n    \\n    def query(self, i):\\n        res = 0\\n        while i > 0:\\n            res += self.sums[i]\\n            i -= i & (-i)\\n        return res\\n\\nclass Solution:\\n    def goodTriplets(self, A, B):\\n        d = {x: i for i, x in enumerate(A)}\\n        n = len(A)\\n        arr = [d[B[i]] for i in range(n)]\\n\\n        BIT1, BIT2, ans = BIT(n), BIT(n), 0\\n        for i in arr:\\n            ans += BIT2.query(i)\\n            BIT1.update(i + 1, 1)\\n            less = BIT1.query(i)\\n            BIT2.update(i + 1, less)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787085,
                "title": "bit",
                "content": "We first use two arrays to get a single array with indexes:\\n- A number in the first array is replaced with an index of that number in the second one.\\n\\nThen, we compute good triplets in that array, such as `i < j < k` and `nums1[i] < nums1[j] < nums1[k]`. This is similar to [1534. Count Good Triplets](https://leetcode.com/problems/count-good-triplets/). \\n\\nFor that, we go through each middle element, and count `smaller` elements on the left, and `greater` on the right. That middle element can form `smaller * greater` good triplets.\\n\\nWe can use BIT (AKA Fenwick Tree) to count elements smaller (`sm`) than the middle element in O(n log n). Because we have `n - 1` unique numbers, figuring out greater (`gr`) elements on the right is easy.\\n\\n![image](https://assets.leetcode.com/users/images/65fa535c-37d5-4cce-b5ce-9e525e50e8df_1645383957.253021.png)\\n\\n\\n**C++**\\n```cpp\\nconstexpr int static n = 100000;\\nint bt[n + 1] = {};\\nint prefix_sum(int i) {\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val) {\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nlong long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n    long long res = 0, sz = nums1.size();\\n    vector<int> ids(sz);\\n    for (int i = 0; i < sz; ++i)\\n        ids[nums2[i]] = i;\\n    for (int i = 0; i < sz - 1; ++i) {\\n        int mid = ids[nums1[i]], sm = prefix_sum(mid), gr = sz - 1 - mid - (i - sm);\\n        res += (long long)sm * gr;\\n        add(mid, 1);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nconstexpr int static n = 100000;\\nint bt[n + 1] = {};\\nint prefix_sum(int i) {\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val) {\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nlong long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n    long long res = 0, sz = nums1.size();\\n    vector<int> ids(sz);\\n    for (int i = 0; i < sz; ++i)\\n        ids[nums2[i]] = i;\\n    for (int i = 0; i < sz - 1; ++i) {\\n        int mid = ids[nums1[i]], sm = prefix_sum(mid), gr = sz - 1 - mid - (i - sm);\\n        res += (long long)sm * gr;\\n        add(mid, 1);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783199,
                "title": "python-balanced-bst-count-smaller-before-and-greater-after",
                "content": "* First, create an array that contains index of nums1[0], nums1[1] ..., nums1[N - 1] in nums2.\\n\\t* `nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3] -> nums = [0,2,1,4,3]`\\n* For each index in `nums`, count the number of smaller elements on the left and number of greater elements on the right. This problem can be solved similar to [LC315](https://leetcode.com/problems/count-of-smaller-numbers-after-self/), using Segment Tree, Binary Index Tree, or BST. \\n\\t* `smaller = [0,1,1,3,3]`\\n\\t* `greater = [4,2,2,0,0]`\\n* Output = sum(smaller[i] * greater[i])\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        N, output = len(nums2), 0\\n        idx_nums2 = {nums2[i]: i for i in range(N)}\\n        nums = []\\n        for i in range(N):\\n            nums.append(idx_nums2[nums1[i]])\\n\\n        smaller = self.countSmallerLeft(nums)\\n        greater = self.countGreaterRight(nums)\\n\\n        for i in range(1, N):\\n            output += smaller[i] * greater[i]\\n        return output\\n        \\n    def countSmallerLeft(self, nums: List[int]) -> List[int]:\\n        N, output, multiset = len(nums), [None] * len(nums), SortedList()\\n        for i in range(0, N):\\n            idx = multiset.bisect_left(nums[i])\\n            output[i] = idx\\n            multiset.add(nums[i])\\n        return output\\n\\n    def countGreaterRight(self, nums: List[int]) -> List[int]:\\n        N, output, multiset = len(nums), [None] * len(nums), SortedList()\\n        for i in range(N - 1, -1, -1):\\n            idx = multiset.bisect_left(nums[i])\\n            output[i] = len(multiset) - idx\\n            multiset.add(nums[i])\\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        N, output = len(nums2), 0\\n        idx_nums2 = {nums2[i]: i for i in range(N)}\\n        nums = []\\n        for i in range(N):\\n            nums.append(idx_nums2[nums1[i]])\\n\\n        smaller = self.countSmallerLeft(nums)\\n        greater = self.countGreaterRight(nums)\\n\\n        for i in range(1, N):\\n            output += smaller[i] * greater[i]\\n        return output\\n        \\n    def countSmallerLeft(self, nums: List[int]) -> List[int]:\\n        N, output, multiset = len(nums), [None] * len(nums), SortedList()\\n        for i in range(0, N):\\n            idx = multiset.bisect_left(nums[i])\\n            output[i] = idx\\n            multiset.add(nums[i])\\n        return output\\n\\n    def countGreaterRight(self, nums: List[int]) -> List[int]:\\n        N, output, multiset = len(nums), [None] * len(nums), SortedList()\\n        for i in range(N - 1, -1, -1):\\n            idx = multiset.bisect_left(nums[i])\\n            output[i] = len(multiset) - idx\\n            multiset.add(nums[i])\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783375,
                "title": "c-pbds-easiest-solution",
                "content": "Idea :- \\nWe iterate on every element of first array and find its occurance in the second array lets say that is j. now our answer contribute by this element would be :-\\nNumber of overlapping elements in n1 from 0 to i and in n2 from 0 to j. lets say this is pref[i] \\nand multiply this with number of overlapping elements in n1 from i + 1 to n and in n2 from j + 1 to n lets say this suff[i]\\n\\nnow answer is simply multiplication of these two.\\n\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n  \\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> pos(n); \\n        \\n        for(int i = 0; i < n; i++){\\n            pos[nums2[i]] = i;\\n        }\\n        vector<int> pref(n) , suff(n);\\n        ordered_set s,s2;\\n        for(int i = 0; i < n; i++){\\n            pref[i] = s.order_of_key(pos[nums1[i]]);\\n            s.insert(pos[nums1[i]]);\\n        }\\n       \\n        for(int i = n-1; i >= 0; i--){\\n            suff[i] = s2.order_of_key(-pos[nums1[i]]);\\n            s2.insert(-pos[nums1[i]]);\\n        }\\n        long long ans = 0;\\n        for(int i = 1; i < n-1; i++){\\n            ans = ans + pref[i]*1LL*suff[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\nThe reason why I used pbds instead of set or other similar container, because calling lower_bound many times give TLE. That\\'s why use pbds for calculating number of elements strictly smaller or larger than my current number.\\n\\nHow to get number of elements strictly greater ?\\nWell, there is a trick insert all elements as -ve now call order of key for negative it will automatically give number of elements greater than my current number. \\n",
                "solutionTags": [],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n  \\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> pos(n); \\n        \\n        for(int i = 0; i < n; i++){\\n            pos[nums2[i]] = i;\\n        }\\n        vector<int> pref(n) , suff(n);\\n        ordered_set s,s2;\\n        for(int i = 0; i < n; i++){\\n            pref[i] = s.order_of_key(pos[nums1[i]]);\\n            s.insert(pos[nums1[i]]);\\n        }\\n       \\n        for(int i = n-1; i >= 0; i--){\\n            suff[i] = s2.order_of_key(-pos[nums1[i]]);\\n            s2.insert(-pos[nums1[i]]);\\n        }\\n        long long ans = 0;\\n        for(int i = 1; i < n-1; i++){\\n            ans = ans + pref[i]*1LL*suff[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1783967,
                "title": "segment-tree-aprroach-full-explanation-c",
                "content": "1. Let us consider these two arrays [1,4,2,0,6,5,3,7]   [1,4,3,7,0,2,6,5]\\n2. Now the main observation of the question is-\\nLet\\'s say if i am currently at 5th index in first array then we will find it\\'s corresponding position in second array. In the above example it would be at second last position in second array.\\nNow for current index my answer would be (common elements in left part of first array and common elements in left part of second array) multiplied by (common elements in right part of first array and common elements in right part of second array).\\nIn above case for 5th index [1,4,2,0] is common in left part and [5] is common in right part.\\n3. So, by traversing in this manner we can get our answer but this approach is (O(n^2)) which would not pass the constraints.\\nSo now segment tree comes as our saviour here.\\nwhile traversing the array we can update the corresponding positions in segment tree of second array (Initially all nodes in segment tree has 0 value).\\nBy this we can get common elements in left part in O(log n) time using range sum query on segment tree.\\nAnd now we have number of common elements in left part, we can easily get common elements in right part using simple maths.\\n```\\n#define ll long long\\nvector<ll> seg;\\nvector<ll> v;\\nint n;\\nvoid build(ll l,ll r,ll c=1)\\n{\\n    if(l==r)\\n    {\\n        seg[c]=v[l];\\n        return;\\n    }\\n    ll mid=(l+r)/2;\\n    build(l,mid,2*c); build(mid+1,r,2*c+1);\\n    seg[c]=seg[2*c]+seg[2*c+1];\\n    return;\\n}\\nll query(ll l,ll r,ll a,ll b,ll c=1)\\n{\\n    if(l>b||r<a)\\n        return 0;\\n    if(l>=a&&r<=b)\\n        return seg[c];\\n    ll mid=(l+r)/2;\\n    return query(l,mid,a,b,2*c)+query(mid+1,r,a,b,2*c+1);\\n}\\nvoid update(ll l,ll r,ll ind,ll c=1)\\n{   \\n    if(ind<l||ind>r)\\n        return;\\n    if(l==r&&l==ind)\\n    {\\n        seg[c]=1;\\n        return;\\n    }\\n    ll mid=(l+r)/2;\\n    update(l,mid,ind,2*c);  update(mid+1,r,ind,2*c+1);\\n    seg[c]=seg[2*c]+seg[2*c+1];\\n}\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2)\\n    {\\n    int n=nums1.size();\\n    v.resize(n+1,0);\\n        ll ans=0;\\n    map<ll,ll> m;\\n        for(ll i=1;i<=n;i++)\\n        {\\n            m[nums2[i-1]+1]=i;\\n        }\\n        seg.clear();\\n        seg.resize(4*n+10,0);\\n        build(1,n);\\n        update(1,n,m[nums1[0]+1]);\\n        for(ll i=2;i<=n;i++)\\n        {\\n            ll r=m[nums1[i-1]+1];\\n            ll q=query(1,n,1,r);\\n            // cout<<q<<\"\\\\n\";\\n            ll d=i-q-1;\\n            ll loc=(n-r)-d;\\n            ans+=loc*q;\\n            update(1,n,r);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n#define ll long long\\nvector<ll> seg;\\nvector<ll> v;\\nint n;\\nvoid build(ll l,ll r,ll c=1)\\n{\\n    if(l==r)\\n    {\\n        seg[c]=v[l];\\n        return;\\n    }\\n    ll mid=(l+r)/2;\\n    build(l,mid,2*c); build(mid+1,r,2*c+1);\\n    seg[c]=seg[2*c]+seg[2*c+1];\\n    return;\\n}\\nll query(ll l,ll r,ll a,ll b,ll c=1)\\n{\\n    if(l>b||r<a)\\n        return 0;\\n    if(l>=a&&r<=b)\\n        return seg[c];\\n    ll mid=(l+r)/2;\\n    return query(l,mid,a,b,2*c)+query(mid+1,r,a,b,2*c+1);\\n}\\nvoid update(ll l,ll r,ll ind,ll c=1)\\n{   \\n    if(ind<l||ind>r)\\n        return;\\n    if(l==r&&l==ind)\\n    {\\n        seg[c]=1;\\n        return;\\n    }\\n    ll mid=(l+r)/2;\\n    update(l,mid,ind,2*c);  update(mid+1,r,ind,2*c+1);\\n    seg[c]=seg[2*c]+seg[2*c+1];\\n}\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2)\\n    {\\n    int n=nums1.size();\\n    v.resize(n+1,0);\\n        ll ans=0;\\n    map<ll,ll> m;\\n        for(ll i=1;i<=n;i++)\\n        {\\n            m[nums2[i-1]+1]=i;\\n        }\\n        seg.clear();\\n        seg.resize(4*n+10,0);\\n        build(1,n);\\n        update(1,n,m[nums1[0]+1]);\\n        for(ll i=2;i<=n;i++)\\n        {\\n            ll r=m[nums1[i-1]+1];\\n            ll q=query(1,n,1,r);\\n            // cout<<q<<\"\\\\n\";\\n            ll d=i-q-1;\\n            ll loc=(n-r)-d;\\n            ans+=loc*q;\\n            update(1,n,r);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1783185,
                "title": "python-o-nlogn-2-solutions-using-fenwick-tree",
                "content": "First of all, we can use the index of each number in `nums1` to re-index `nums2`. for example:\\n\\nif `nums1 = [2, 0, 3, 1]`\\n\\nwhich means: \\n\\n```\\n2 => index 0 \\n0 => index 1\\n3 => index 2\\n1 => index 3\\n```\\n\\nthen, if our `nums2 = [2, 3, 1, 0]`, we can re-index it by the the aboving rules as `[0, 2, 3, 1]`\\n\\nSo the question becomes **find count of different increasing triplet in the re-indexed nums2**\\n\\nWe can have two solutions using **Fenwich Tree**\\n\\n## Solution1\\n\\nIntuitively, for each number `n`, we want to count the number of increasing pairs with the second number smaller than `n` before. For example, if `n == 5`, we would like to know how many pairs like `(1,4), (1,3), (2,3), (0,3)`, ... before. All these pairs combined with this number `n` is an increasing triplet we want.\\n\\nwe can just open two of them called `fenwick1` and `fenwick2` with the following operations.\\n\\n1. `fenwick1.add(n, 1)`: add 1 to position n, which means the number `n` already shows up.\\n2. `fenwich1.prefixSum(n-1)`: sum of position `0 ~ n-1`, which means how many numbers smaller than `n` show up before.\\n3. `fenwich2.add(n, k)`: add k to position n, which means the count of increasing pairs end with `n`\\n4. `fenwich2.prefixSum(n-1)`: sum of the count of increasing pairs end with position x from `0 ~ n-1`\\n\\nEach of this operation take `O(logN)` time\\n\\n```\\nclass FenwickTree():\\n    def __init__(self, N):\\n        self.N = N\\n        self.bit = [0 for i in range(N+1)]\\n\\n    def add(self, index, value):\\n        index += 1\\n        while index <= self.N:\\n            self.bit[index] += value\\n            index += (index & -index)\\n\\n    def prefixSum(self, index):\\n        index += 1\\n        ans = 0\\n        while index != 0:\\n            ans += self.bit[index]\\n            index -= (index & -index)\\n        return ans\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        N = len(nums1)\\n        fenwick1 = FenwickTree(N)\\n        fenwick2 = FenwickTree(N)\\n        \\n        # re-index\\n        indexes = {n: i for i, n in enumerate(nums1)}\\n        nums2 = [indexes[n] for n in nums2]\\n\\n        # count increasing triplets\\n        ans = 0\\n        for n in nums2:\\n            if n > 0:\\n                # count of increasing pairs with second number smaller then n\\n                cnt = fenwick2.prefixSum(n-1)\\n                ans += cnt\\n                # fenwick1.prefixSum(n-1) give us count of numbers smaller than n before\\n                fenwick2.add(n, fenwick1.prefixSum(n-1)) \\n            # add 1 to number n\\n            fenwick1.add(n, 1)\\n        return ans\\n\\n```\\n\\n## Solution2\\n\\n(Inspired by @danghuybk)\\n\\nAnother way is that, for each number `n` in re-indexed `nums2`, we can count how many numbers on the left are smaller then `n` (recorded as `left_smaller`), and how many numbers on the right are larger then `n` (recorded as `right_larger`). Then the count of increasing triplet in this position is just `left_smaller * right_larger`.\\n\\nAgain, we use `fenwick tree` to get the value of `left_smaller` and `right_larger` efficiently. The `fenwick tree` recording the existence of each number (`1` means exist, `0` means absence).\\n\\n1. `fenwick1`: recording numbers on the left (initially empty)\\n2. `fenwick2`: recording numbers on the right (initially full)\\n\\n```\\nclass FenwickTree():\\n    def __init__(self, N):\\n        self.N = N\\n        self.bit = [0 for i in range(N+1)]\\n\\n    def add(self, index, value): # add `value` to self.data[index]\\n        index += 1\\n        while index <= self.N:\\n            self.bit[index] += value\\n            index += (index & -index)\\n\\n    def prefixSum(self, index):\\n        index += 1\\n        ans = 0\\n        while index != 0:\\n            ans += self.bit[index]\\n            index -= (index & -index)\\n        return ans\\n\\n    def query(self, left, right):\\n        return self.prefixSum(right) - self.prefixSum(left-1) if left > 0 else self.prefixSum(right)\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        N = len(nums1)\\n        fenwick1 = FenwickTree(N)\\n        fenwick2 = FenwickTree(N)\\n        for i in range(N):\\n            fenwick2.add(i, 1)\\n\\n        # re-index\\n        indexes = {n: i for i, n in enumerate(nums1)}\\n        nums2 = [indexes[n] for n in nums2]\\n\\n        # count increasing triplets\\n        ans = 0\\n        for n in nums2:\\n            if 0 < n < N-1:    \\n                left_smaller = fenwick1.query(0, n-1)\\n                right_larger = fenwick2.query(n+1, N-1)\\n                ans += left_smaller * right_larger\\n            fenwick1.add(n, 1)\\n            fenwick2.add(n, -1)\\n\\n        return ans\\n```\\n\\n\\n## Time Complexity\\n`O(NlogN)`\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n2 => index 0 \\n0 => index 1\\n3 => index 2\\n1 => index 3\\n```\n```\\nclass FenwickTree():\\n    def __init__(self, N):\\n        self.N = N\\n        self.bit = [0 for i in range(N+1)]\\n\\n    def add(self, index, value):\\n        index += 1\\n        while index <= self.N:\\n            self.bit[index] += value\\n            index += (index & -index)\\n\\n    def prefixSum(self, index):\\n        index += 1\\n        ans = 0\\n        while index != 0:\\n            ans += self.bit[index]\\n            index -= (index & -index)\\n        return ans\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        N = len(nums1)\\n        fenwick1 = FenwickTree(N)\\n        fenwick2 = FenwickTree(N)\\n        \\n        # re-index\\n        indexes = {n: i for i, n in enumerate(nums1)}\\n        nums2 = [indexes[n] for n in nums2]\\n\\n        # count increasing triplets\\n        ans = 0\\n        for n in nums2:\\n            if n > 0:\\n                # count of increasing pairs with second number smaller then n\\n                cnt = fenwick2.prefixSum(n-1)\\n                ans += cnt\\n                # fenwick1.prefixSum(n-1) give us count of numbers smaller than n before\\n                fenwick2.add(n, fenwick1.prefixSum(n-1)) \\n            # add 1 to number n\\n            fenwick1.add(n, 1)\\n        return ans\\n\\n```\n```\\nclass FenwickTree():\\n    def __init__(self, N):\\n        self.N = N\\n        self.bit = [0 for i in range(N+1)]\\n\\n    def add(self, index, value): # add `value` to self.data[index]\\n        index += 1\\n        while index <= self.N:\\n            self.bit[index] += value\\n            index += (index & -index)\\n\\n    def prefixSum(self, index):\\n        index += 1\\n        ans = 0\\n        while index != 0:\\n            ans += self.bit[index]\\n            index -= (index & -index)\\n        return ans\\n\\n    def query(self, left, right):\\n        return self.prefixSum(right) - self.prefixSum(left-1) if left > 0 else self.prefixSum(right)\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        N = len(nums1)\\n        fenwick1 = FenwickTree(N)\\n        fenwick2 = FenwickTree(N)\\n        for i in range(N):\\n            fenwick2.add(i, 1)\\n\\n        # re-index\\n        indexes = {n: i for i, n in enumerate(nums1)}\\n        nums2 = [indexes[n] for n in nums2]\\n\\n        # count increasing triplets\\n        ans = 0\\n        for n in nums2:\\n            if 0 < n < N-1:    \\n                left_smaller = fenwick1.query(0, n-1)\\n                right_larger = fenwick2.query(n+1, N-1)\\n                ans += left_smaller * right_larger\\n            fenwick1.add(n, 1)\\n            fenwick2.add(n, -1)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783361,
                "title": "python-3-sortedlist-solution-o-nlogn",
                "content": "According to the question, first we obtain an index array `indices`, where `indices[i]` is the index of `nums1[i]` in `num2`, this can be done using a hashmap in `O(N)` time. For example, given `nums1 = [2,0,1,3], nums2 = [0,1,2,3]`, then `indices = [2,0,1,3]`; given `nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]`, then `indices = [0,2,1,4,3]`.\\n\\nThen, the problem is essentially asking - find the total number of triplets `(x, y, z)` as a subsequence in `indices`, where `x < y < z`. To do this, we can scan through `indices` and locate the middle number `y`. Then, we count (1) how many numbers on the left of `y` in `indices` that are less than `y`; and (2) how many numbers on the right of `y` in `indices` that are greater than `y`. This can done using SortedList in Python or other data structures in `O(NlogN)` time.\\n\\nThe final step is to count the total number of **good triplets** as asked in the problem. This can be done by a linear scan in `O(N)` time.\\n\\nBelow is my in-contest solution, though I could have made it a bit neater. Please upvote if you find this solution helpful.\\n```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        hashmap2 = {}\\n        for i in range(n):\\n            hashmap2[nums2[i]] = i\\n        indices = []\\n        for num in nums1:\\n            indices.append(hashmap2[num])\\n        from sortedcontainers import SortedList\\n        left, right = SortedList(), SortedList()\\n        leftCount, rightCount = [], []\\n        for i in range(n):\\n            leftCount.append(left.bisect_left(indices[i]))\\n            left.add(indices[i])\\n        for i in range(n - 1, -1, -1):\\n            rightCount.append(len(right) - right.bisect_right(indices[i]))\\n            right.add(indices[i])\\n        count = 0\\n        for i in range(n):\\n            count += leftCount[i] * rightCount[n - 1 - i]\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        hashmap2 = {}\\n        for i in range(n):\\n            hashmap2[nums2[i]] = i\\n        indices = []\\n        for num in nums1:\\n            indices.append(hashmap2[num])\\n        from sortedcontainers import SortedList\\n        left, right = SortedList(), SortedList()\\n        leftCount, rightCount = [], []\\n        for i in range(n):\\n            leftCount.append(left.bisect_left(indices[i]))\\n            left.add(indices[i])\\n        for i in range(n - 1, -1, -1):\\n            rightCount.append(len(right) - right.bisect_right(indices[i]))\\n            right.add(indices[i])\\n        count = 0\\n        for i in range(n):\\n            count += leftCount[i] * rightCount[n - 1 - i]\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784036,
                "title": "java-solution-using-fenwick-tree",
                "content": "\\n    \\n```\\nclass Solution {\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        int []pos = new int[n];\\n        \\n        FenwickTree ft = new FenwickTree(n+1);\\n        \\n        for(int i=0;i<n;i++)\\n            pos[nums2[i]]=i;\\n        \\n        long []left=new long[n];\\n        long []right = new long[n];\\n        \\n        for(int i=0;i<n;i++){\\n            int idx = pos[nums1[i]];\\n            left[i] = ft.sum(idx-1);\\n            ft.update(idx,1);\\n        }\\n        \\n        ft=new FenwickTree(n+1);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int idx = pos[nums1[i]];\\n            right[i]= ft.sum(n+1)-ft.sum(idx);\\n            ft.update(idx,1);\\n        }\\n        \\n        long ans=0;\\n        \\n        for (int i=0;i<n;i++)\\n            ans+= left[i]*right[i];\\n        \\n        return ans;\\n    }\\n}\\n\\nclass FenwickTree {\\n    int[] bit;\\n    int n;\\n    \\n    FenwickTree(int n) {\\n        this.n = n;\\n        this.bit = new int[n + 2];\\n    }\\n    \\n    public void update(int i, int val) {\\n        i++;\\n        while (i < bit.length) {\\n            bit[i] += val;\\n            i += (i & (-i));\\n        }\\n    }\\n    \\n    public int sum(int i) {\\n        int sum = 0;\\n        i++;\\n        while (i > 0) {\\n            sum += bit[i];\\n            i -= (i & (-i));\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        int []pos = new int[n];\\n        \\n        FenwickTree ft = new FenwickTree(n+1);\\n        \\n        for(int i=0;i<n;i++)\\n            pos[nums2[i]]=i;\\n        \\n        long []left=new long[n];\\n        long []right = new long[n];\\n        \\n        for(int i=0;i<n;i++){\\n            int idx = pos[nums1[i]];\\n            left[i] = ft.sum(idx-1);\\n            ft.update(idx,1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1784221,
                "title": "truly-psychotic-solution-mergesorttree-on-the-dp-array-then-prefix-sum-at-each-segment-node-wtf",
                "content": "Read at your own risk. This is a really stupid and convoluted solution. \\nI\\'m sorry.\\n\\n(by the way, you can do this same idea A Lot Easier and A Lot Faster with 2 fenwick trees \\ninstead of this monstrosity, but i couldn\\'t think of anything else at the time)\\n\\nlet A = nums1, B = nums2\\nlet ll = long long;\\nlet pll = pair<ll, ll>;\\nidea: we want to count the number of valid pairs first. Then see what we can do with that\\nto make it work for triplets.\\n\\nFirst we create pairs of indices (i,j) such that A[i] == B[j]\\nThen we sort these indices by ascending i. Let\\'s call this sorted array of pairs `P`.\\nNow, the first sub-problem is reduced to finding pairs of strictly increasing pairs of (i,j), \\nmeaning a pair (i1, j1) can come before a pair (i2, j2) if and only if `(i1 < i2 && j1 < j2)`\\nWe want to find, for each pair (i2, j2) in `P`, how many possible pairs that came before it can be a valid (i1, j1) counterpart to it. \\n\\nLet us store these answers in an array of pairs `dp`.\\nHow can we compute dp? We build a `MergeSortTree seg1` over `P`, based on the j values. \\nSince we know that at any (i2, j2) in `P`, all of the elements to the left of it have a lower i value, (because `P` is sorted by increasing i value), then we just need to count the number of j values in the range [0, i-1] that are lower than j2. a basic MergeSortTree query accomplishes this.\\nLet i be the index of P. let `X = seg1.query(0, i-1)`\\nThen in our dp, we will store pairs in the form ( j2, X_(i2) ) \\nFormally: `dp[i] = ( P[i].second, seg1.query(0,i-1) )`\\n```\\nfor (int i2 = 1; i2 < N; ++i2) { \\n\\tint j2 = P[i2].second;\\n\\tint X = seg1.query(0, i-1);\\n\\tdp[i] = {j2, X};\\n}\\n```\\nWith dp built, we now want to loop over the pairs again. This time, we interpret each pair as (i3,j3).\\nWe want to find the number of valid triplets that can be created, with each (i3, j3) as the final pair.\\n\\nFor each (i3, j3) in P:\\nThe Number of valid PAIRS OF PAIRS [ (i1, j1), (i2, j2) ] that can come before the current (i3, j3) is:\\nthe SUM of all `dp[k].second`, for k in the RANGE [0,i3-1], such that `dp[k].first` is less than j3.\\nWhy is this? `dp[k].first` is a valid j2. since we only consider the range less than i3, we can be sure i2 < i3. `dp[k].second` is then the number of valid pairs of pairs ending in (i2, j2).  So we can simply add the answer  to this query, to our total count. \\nHow do we answer this query? We build a `MergeSortTree<pll> seg2` OVER `dp1`. We can then find the segments of j2 values that are good. Since internally, the segments are stored as SORTED arrays (in increasing order of j2) then whenever we answer a query, the section of VALID elements is always some PREFIX of the sorted elements in that segment. So, after building the tree, at each node, we compute a prefix sum over the `dp[k].second` values. Now at each node, we can find the section of the segment that is relevant to the query, and then take prefix sum value at that element. \\n\\nTime Complexity: \\n`N log N` to sort the pairs\\n`N log N` to build each merge sort tree. \\n`log^2(N)` per query.\\n`O(N)` queries.\\nOverall: `O(N log^2(N)`.. i think.\\n\\nsometimes it TLE\\'s. sometimes it doesn\\'t. Sorry\\n\\nSpace Complexity:\\n`O(N log N)` per segment tree\\nOverall: `O(N log N)`\\n\\n\\nif you want to understand the code below, you\\'re making a mistake\\ni keep a bool U in mergesorttree, which tells me whether to return the prefix sum or the count\\ni built dp using `vector<pll>`  because i was lazy to change the mergesorttree part. in seg1, the `second` values at each pair are meaningless.\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nusing ll = long long;\\nusing pll = pair<ll, ll>;\\n#define all(x) (x).begin(), (x).end()\\nclass Solution {\\npublic:\\n    struct MergeTree {\\n        int N;\\n        bool U = false;\\n        vector<pll> &A;\\n        vector<vector<pll>> T;\\n        void build(int v, int tl, int tr) {\\n            if (tl == tr) {\\n                if (U) T[v] = { {A[tl].second, 0} };\\n                else T[v] = {A[tl]};\\n            }\\n            else {\\n                int mid = (tl + tr) / 2;\\n                build(v*2, tl, mid);\\n                build(v*2+1, mid+1, tr);\\n                T[v].resize(tr-tl+1);\\n                auto &L = T[v*2], &R = T[v*2+1];\\n                merge(all(L), all(R), begin(T[v]));\\n            }\\n        }\\n        ll query(ll x, int L, int R) { return query(x, L, R, 1, 0, N-1); }\\n        ll query(ll x, int al, int ar, int v, int tl, int tr) {\\n            if (tr < al || ar < tl) return 0;\\n            if (al <= tl && tr <= ar) {\\n                pll tmp = {x, -1};\\n                auto it = lower_bound(all(T[v]), tmp);\\n                if (U) return it - begin(T[v]);\\n                if (it == begin(T[v])) return 0;\\n                return prev(it)->second;\\n            }\\n            int mid = (tl + tr) / 2;\\n            ll ql = query(x, al, ar, v*2, tl, mid);\\n            ll qr = query(x, al, ar, v*2+1, mid+1, tr);\\n            return ql + qr;\\n        }\\n        MergeTree(int n, vector<pll> &v, bool u) : N(n), A(v), T(4ul*n), U(u) {\\n            build(1, 0, N-1);\\n            for (auto &v : T) {\\n                int sz = v.size();\\n                for (int i = 1; i < sz; ++i)\\n                    v[i].second += v[i-1].second;\\n            }\\n        }\\n    };\\n\\n    ll goodTriplets(vector<int>& A, vector<int>& B) {\\n        int N = A.size();\\n        vector<int> pa(N), pb(N);\\n        for (int i = 0; i < N; ++i)\\n            pa[A[i]] = pb[B[i]] = i;\\n\\n        vector<pll> P;\\n        for (int x = 0; x < N; ++x)\\n            P.push_back( {pa[x], pb[x]} );\\n        sort(begin(P), end(P));\\n        vector<pll> dp1(N);\\n        MergeTree seg1(N, P, true);\\n        for (int i = 1; i < N; ++i) {\\n            int y = P[i].second;\\n            ll q = seg1.query(y, 0, i-1);\\n            dp1[i] = {y, q};\\n        }\\n        ll ans = 0;\\n        MergeTree seg2(N, dp1, false);\\n        for (int i = 2; i < N; ++i) {\\n            int y = P[i].second;\\n            ll q = seg2.query(y, 0, i-1);\\n            ans += q;\\n        }\\n        return ans;\\n    }\\n};\\nstatic auto _ = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}();\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfor (int i2 = 1; i2 < N; ++i2) { \\n\\tint j2 = P[i2].second;\\n\\tint X = seg1.query(0, i-1);\\n\\tdp[i] = {j2, X};\\n}\\n```\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nusing ll = long long;\\nusing pll = pair<ll, ll>;\\n#define all(x) (x).begin(), (x).end()\\nclass Solution {\\npublic:\\n    struct MergeTree {\\n        int N;\\n        bool U = false;\\n        vector<pll> &A;\\n        vector<vector<pll>> T;\\n        void build(int v, int tl, int tr) {\\n            if (tl == tr) {\\n                if (U) T[v] = { {A[tl].second, 0} };\\n                else T[v] = {A[tl]};\\n            }\\n            else {\\n                int mid = (tl + tr) / 2;\\n                build(v*2, tl, mid);\\n                build(v*2+1, mid+1, tr);\\n                T[v].resize(tr-tl+1);\\n                auto &L = T[v*2], &R = T[v*2+1];\\n                merge(all(L), all(R), begin(T[v]));\\n            }\\n        }\\n        ll query(ll x, int L, int R) { return query(x, L, R, 1, 0, N-1); }\\n        ll query(ll x, int al, int ar, int v, int tl, int tr) {\\n            if (tr < al || ar < tl) return 0;\\n            if (al <= tl && tr <= ar) {\\n                pll tmp = {x, -1};\\n                auto it = lower_bound(all(T[v]), tmp);\\n                if (U) return it - begin(T[v]);\\n                if (it == begin(T[v])) return 0;\\n                return prev(it)->second;\\n            }\\n            int mid = (tl + tr) / 2;\\n            ll ql = query(x, al, ar, v*2, tl, mid);\\n            ll qr = query(x, al, ar, v*2+1, mid+1, tr);\\n            return ql + qr;\\n        }\\n        MergeTree(int n, vector<pll> &v, bool u) : N(n), A(v), T(4ul*n), U(u) {\\n            build(1, 0, N-1);\\n            for (auto &v : T) {\\n                int sz = v.size();\\n                for (int i = 1; i < sz; ++i)\\n                    v[i].second += v[i-1].second;\\n            }\\n        }\\n    };\\n\\n    ll goodTriplets(vector<int>& A, vector<int>& B) {\\n        int N = A.size();\\n        vector<int> pa(N), pb(N);\\n        for (int i = 0; i < N; ++i)\\n            pa[A[i]] = pb[B[i]] = i;\\n\\n        vector<pll> P;\\n        for (int x = 0; x < N; ++x)\\n            P.push_back( {pa[x], pb[x]} );\\n        sort(begin(P), end(P));\\n        vector<pll> dp1(N);\\n        MergeTree seg1(N, P, true);\\n        for (int i = 1; i < N; ++i) {\\n            int y = P[i].second;\\n            ll q = seg1.query(y, 0, i-1);\\n            dp1[i] = {y, q};\\n        }\\n        ll ans = 0;\\n        MergeTree seg2(N, dp1, false);\\n        for (int i = 2; i < N; ++i) {\\n            int y = P[i].second;\\n            ll q = seg2.query(y, 0, i-1);\\n            ans += q;\\n        }\\n        return ans;\\n    }\\n};\\nstatic auto _ = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}();\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1783619,
                "title": "policy-based-data-structure-ordered-set-o-nlogn-c-code",
                "content": "I did mapping of first array to 1 2 3 4 ...\\nAccording to this mapping we change our second array.\\n\\nNow the problem is to count the number of increasing triplets in second array.\\n\\nI used ordered set, also known as policy based data structure, to find the number of elements smaller than nums2[i] in left side of i and the number of elements greater than nums2[i] in the right side of i. Multiplying both values will give count of increasing triplets having nums2[i] as its second element.\\n\\n```\\ntypedef long long ll;\\ntypedef long double ld;\\n#define mod 1000000007\\n#define all(x) begin(x),end(x)\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int, int> mapping;\\n        int no = 1;\\n        for (int x : nums1){\\n            mapping[x] = no;\\n            no++;\\n        }\\n        for (int i = 0; i < nums2.size(); ++i)\\n            nums2[i] = mapping[nums2[i]];\\n        int n = nums2.size();\\n        ordered_set st1;\\n        ordered_set st2;\\n        for (int x : nums2)\\n            st2.insert(x);\\n        ll ans = 0;\\n        st1.insert(nums2[0]);\\n        st2.erase(st2.find(nums2[0]));\\n        for (int i = 1; i < n - 1; ++i)\\n        {\\n            st2.erase(st2.find(nums2[i]));\\n            ll less = (ll)st1.order_of_key(nums2[i]);\\n            ll great = (ll) (((int)st2.size()) - st2.order_of_key(nums2[i]));\\n            ans += (less * great);\\n            st1.insert(nums2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTime Complexity: O(nlogn) (On average)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef long long ll;\\ntypedef long double ld;\\n#define mod 1000000007\\n#define all(x) begin(x),end(x)\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int, int> mapping;\\n        int no = 1;\\n        for (int x : nums1){\\n            mapping[x] = no;\\n            no++;\\n        }\\n        for (int i = 0; i < nums2.size(); ++i)\\n            nums2[i] = mapping[nums2[i]];\\n        int n = nums2.size();\\n        ordered_set st1;\\n        ordered_set st2;\\n        for (int x : nums2)\\n            st2.insert(x);\\n        ll ans = 0;\\n        st1.insert(nums2[0]);\\n        st2.erase(st2.find(nums2[0]));\\n        for (int i = 1; i < n - 1; ++i)\\n        {\\n            st2.erase(st2.find(nums2[i]));\\n            ll less = (ll)st1.order_of_key(nums2[i]);\\n            ll great = (ll) (((int)st2.size()) - st2.order_of_key(nums2[i]));\\n            ans += (less * great);\\n            st1.insert(nums2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1783467,
                "title": "c-solution-using-pbds-ordered-set",
                "content": "Logic - Find no. of values common in left side of particular value and no. of values common in right side of value, product of this two will give us no. of triplets having that value as middle of triplet.\\n\\nFor getting to result hash one of the array according to its indices(hash[arr1[i]]=i) and then traverse in other one and store there hashed value(of 1st array) in a ordered_set as we traverse. Now no. of values which are lesser than hash[arr[i]] in ordered_set will be no. of values common in left side. Similarly we can find no. of values common in right side.\\n\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n  \\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(),i;\\n        int a[n],b[n];\\n        for(i=0;i<n;i++){\\n            a[nums1[i]]=i;\\n        }\\n        ordered_set s;\\n        for(i=0;i<n;i++){\\n            int pos=a[nums2[i]];\\n            b[i]=s.order_of_key(pos+1);\\n            s.insert(pos);\\n        }\\n        ordered_set s2;\\n        s2.insert(a[nums2[n-1]]);\\n        long long ans=0;\\n        for(i=n-2;i;i--){\\n            int pos=a[nums2[i]];\\n            int x=(n-i-1)-s2.order_of_key(pos+1);\\n            ans+=((long long)x)*((long long)b[i]);\\n            s2.insert(pos);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n  \\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(),i;\\n        int a[n],b[n];\\n        for(i=0;i<n;i++){\\n            a[nums1[i]]=i;\\n        }\\n        ordered_set s;\\n        for(i=0;i<n;i++){\\n            int pos=a[nums2[i]];\\n            b[i]=s.order_of_key(pos+1);\\n            s.insert(pos);\\n        }\\n        ordered_set s2;\\n        s2.insert(a[nums2[n-1]]);\\n        long long ans=0;\\n        for(i=n-2;i;i--){\\n            int pos=a[nums2[i]];\\n            int x=(n-i-1)-s2.order_of_key(pos+1);\\n            ans+=((long long)x)*((long long)b[i]);\\n            s2.insert(pos);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1783419,
                "title": "python-merge-sort-solution-based-on-315",
                "content": "I was thinking to convert this problem to #315 which I previously solved with merge sort.\\n\\n1. Change nums2 each num to idx of nums1, say this new array called `mp_idx` (map num in nums2 to idx of nums1) , then we convert this problem to: find counts of (i, j, k), where mp_idx[i] < mp_idx[j] < mp_idx[k]. since the array `mp_idx` maintainces the order of number in nums2, so if we find such a (i, j, k), it means the order will also be persisted in nums1\\n2. Implement a \"count larger\" solution similar to 315 (https://leetcode.com/problems/count-of-smaller-numbers-after-self/solution/ Approach 3)\\n3. Using the reverse array to get the count of smaller number before each number\\n\\n\\n```Python\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        mp_idx = []\\n        mp = {}\\n        for i, n in enumerate(nums1):\\n            mp[n] = i\\n        \\n        for n in nums2:\\n            mp_idx.append(mp[n])\\n        \\n        def countLarger(nums: List[int]) -> List[int]:\\n            n = len(nums)\\n            arr = [[v, i] for i, v in enumerate(nums)]\\n            larger = [0] * n\\n\\n            def merge_sort(arr, l, r):\\n                if r - l <= 1:\\n                    return \\n                mid = (l + r) >> 1\\n                merge_sort(arr, l, mid)\\n                merge_sort(arr, mid, r)\\n                merge(arr, l, r, mid)\\n\\n            def merge(arr, l, r, mid):\\n                # [l, mid), [mid, r)\\n                i, j = l, mid\\n                tmp = []\\n                while i < mid and j < r:\\n                    if arr[i][0] >= arr[j][0]:\\n                        larger[arr[i][1]] += j - mid\\n                        tmp.append(arr[i])\\n                        i += 1\\n                    else:\\n                        tmp.append(arr[j])\\n                        j += 1\\n\\n                while i < mid:\\n                    larger[arr[i][1]] += j - mid\\n                    tmp.append(arr[i])\\n                    i += 1\\n\\n                while j < r:\\n                    tmp.append(arr[j])\\n                    j += 1\\n\\n                for i in range(l, r):\\n                    arr[i] = tmp[i - l]\\n\\n            merge_sort(arr, 0, n)\\n            return larger\\n        \\n        def count(arr):\\n            larger = countLarger(arr)\\n            smaller = countLarger([-x for x in reversed(arr)])[::-1]\\n            res = 0\\n            for i in range(len(arr)):\\n                res += smaller[i] * larger[i]\\n            return res\\n        \\n        return count(mp_idx)\\n        \\n\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        mp_idx = []\\n        mp = {}\\n        for i, n in enumerate(nums1):\\n            mp[n] = i\\n        \\n        for n in nums2:\\n            mp_idx.append(mp[n])\\n        \\n        def countLarger(nums: List[int]) -> List[int]:\\n            n = len(nums)\\n            arr = [[v, i] for i, v in enumerate(nums)]\\n            larger = [0] * n\\n\\n            def merge_sort(arr, l, r):\\n                if r - l <= 1:\\n                    return \\n                mid = (l + r) >> 1\\n                merge_sort(arr, l, mid)\\n                merge_sort(arr, mid, r)\\n                merge(arr, l, r, mid)\\n\\n            def merge(arr, l, r, mid):\\n                # [l, mid), [mid, r)\\n                i, j = l, mid\\n                tmp = []\\n                while i < mid and j < r:\\n                    if arr[i][0] >= arr[j][0]:\\n                        larger[arr[i][1]] += j - mid\\n                        tmp.append(arr[i])\\n                        i += 1\\n                    else:\\n                        tmp.append(arr[j])\\n                        j += 1\\n\\n                while i < mid:\\n                    larger[arr[i][1]] += j - mid\\n                    tmp.append(arr[i])\\n                    i += 1\\n\\n                while j < r:\\n                    tmp.append(arr[j])\\n                    j += 1\\n\\n                for i in range(l, r):\\n                    arr[i] = tmp[i - l]\\n\\n            merge_sort(arr, 0, n)\\n            return larger\\n        \\n        def count(arr):\\n            larger = countLarger(arr)\\n            smaller = countLarger([-x for x in reversed(arr)])[::-1]\\n            res = 0\\n            for i in range(len(arr)):\\n                res += smaller[i] * larger[i]\\n            return res\\n        \\n        return count(mp_idx)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783257,
                "title": "fenwick-tree-inversion-count-c",
                "content": "```\\n// Fenwick Tree Class\\nclass fwk{\\npublic:\\n   int fenwick[100005];\\n   int N;\\n   fwk(int n)\\n   {\\n      N = n;\\n      memset(fenwick,0,sizeof fenwick);\\n   }\\n\\n   void update(int index,int x)\\n   {\\n      for(int i=index;i<=N;i+=(i&-i))\\n      {\\n         fenwick[i]+=x;\\n      }\\n   }\\n   int sum(int index)\\n   {\\n      int ans = 0;\\n      for(int i=index;i>0;i-=(i&-i))\\n      {\\n         ans+=fenwick[i];\\n      }\\n      return ans;\\n   }\\n};\\n\\nclass Solution {\\npublic:\\n\\n   \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n = nums1.size();\\n\\n        map<int,int> indices;\\n        vector<int> B;\\n  \\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            indices[nums2[i]] = i;\\n        }\\n\\t\\t\\n\\t\\t// We know that indices in nums1 array are ordered - so we will do the same with elements of num2 by making seperate vector B which stores indices of element nums1[i] in num2 array \\n\\t\\t// push indices of elements of nums1  array which are in nums2 \\n        for(int i:nums1)\\n        {\\n            B.push_back(indices[i]);\\n        }\\n\\n        for(int i=0;i<B.size();i++)\\n        {\\n            B[i]++;\\n        }\\n        \\n        long long left[n+2];\\n        long long right[n+2];\\n        left[0] = 0;\\n        right[n+1] = 0;\\n\\n        fwk L(n);\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            int ele = B[i-1];\\n\\t\\t\\t// count of lesser element to left side\\n            left[i] = L.sum(ele - 1);\\n            L.update(ele,1);\\n        }\\n\\n        fwk R(n);\\n\\n        for(int i=n;i>=1;i--)\\n        {\\n            int ele = B[i-1];\\n\\t\\t\\t// count of greater elements to right\\n            right[i] = R.sum(n) - R.sum(ele);\\n            R.update(ele,1);\\n        }\\n\\t\\t\\n        long long ans = 0;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n\\t\\t    // all combinations\\n\\t\\t\\t// consider current element as middle and calculate all combinations that can be chosen\\n            ans = ans + (left[i] * right[i]);\\n          \\n        }\\n        return ans;\\n\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n   \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n = nums1.size();\\n\\n        map<int,int> indices;\\n        vector<int> B;\\n  \\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            indices[nums2[i]] = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1783231,
                "title": "c-o-n-log-n-sorting-and-binary-index-tree",
                "content": "The idea here is very simple, every number x in 0\\u2026n-1 has two positions, one in nums1 \\u2014 pos1x, the other in nums2 \\u2014 pos2x, so we can use a point (pos1, pos2) in X-Y plane to represent every number x.\\n\\nLet\\u2019s say (a,b) is smaller than (c, d) if and only a < c && b < d, then the goal is to find out how many triplets (p1, p2, p3) we have such that p1 < p2 < p3. We can sort all points first and then use binary index tree to track the number of p1 that is smaller than p2.\\n\\n```\\nclass Solution {\\npublic:\\n    struct BIT {\\n        vector<int> arr;\\n        \\n        int N;\\n        \\n        BIT(int n) {\\n            N = n + 1;\\n            arr = vector<int>(N, 0);\\n        }\\n        \\n        void add(int i) {\\n            i += 1;\\n            while(i < N) {\\n                arr[i] += 1;\\n                i += i & (-i);\\n            }\\n        }\\n        \\n        int query(int i) {\\n            int sum = 0;\\n            while(i > 0) {\\n                sum += arr[i];\\n                i = i & (i-1);\\n            }\\n            return sum;\\n        }\\n    };\\n    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        long n = nums1.size();\\n        vector<pair<int, int>> points(n);   // each number i in 0..n-1 can be represented by a point (pos1i, pos2i)\\n        for(long i=0; i<n; i++) points[nums1[i]].first = i;\\n        for(long i=0; i<n; i++) points[nums2[i]].second = i;\\n        sort(points.begin(), points.end());  // sort points based on pos1\\n        long ans = 0;\\n        long left, right;\\n        BIT bit(n);     // use binary index tree to find out how many points are smaller than current point\\n        bit.add(points[0].second);\\n        for(long i=1; i<n-1; i++) {\\n            left = bit.query(points[i].second);     // number of smaller points\\n            right = n - 1 - points[i].second - i + left;    // number of larger points\\n            ans += left * right;\\n            bit.add(points[i].second);  // update binary index tree\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct BIT {\\n        vector<int> arr;\\n        \\n        int N;\\n        \\n        BIT(int n) {\\n            N = n + 1;\\n            arr = vector<int>(N, 0);\\n        }\\n        \\n        void add(int i) {\\n            i += 1;\\n            while(i < N) {\\n                arr[i] += 1;\\n                i += i & (-i);\\n            }\\n        }\\n        \\n        int query(int i) {\\n            int sum = 0;\\n            while(i > 0) {\\n                sum += arr[i];\\n                i = i & (i-1);\\n            }\\n            return sum;\\n        }\\n    };\\n    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        long n = nums1.size();\\n        vector<pair<int, int>> points(n);   // each number i in 0..n-1 can be represented by a point (pos1i, pos2i)\\n        for(long i=0; i<n; i++) points[nums1[i]].first = i;\\n        for(long i=0; i<n; i++) points[nums2[i]].second = i;\\n        sort(points.begin(), points.end());  // sort points based on pos1\\n        long ans = 0;\\n        long left, right;\\n        BIT bit(n);     // use binary index tree to find out how many points are smaller than current point\\n        bit.add(points[0].second);\\n        for(long i=1; i<n-1; i++) {\\n            left = bit.query(points[i].second);     // number of smaller points\\n            right = n - 1 - points[i].second - i + left;    // number of larger points\\n            ans += left * right;\\n            bit.add(points[i].second);  // update binary index tree\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034851,
                "title": "well-explained-easy-to-understand",
                "content": "## If you found my answer helpful, please consider giving it an upvote\\uD83D\\uDE0A\\n**ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 2 : Goldman Sachs\\nQ7. Count Good Triplets in an Array** \\n\\n### Approach\\nThe code is solving a problem where it has to find the total number of good triplets, which are groups of 3 numbers from two different groups (nums1 and nums2). A good triplet is one where the first number is from nums1, the second number is from nums2, and is greater than the first number, and the third number is from nums2 and is smaller than the first number.\\nIt does this by first creating a list of index positions for the elements in nums1, and then uses this list to find the position of each element in nums2 in nums1. It then uses a Fenwick Tree data structure to efficiently count the number of elements in nums1 that are smaller than an element in nums2 and located either before or after that element in nums1. Finally, it uses these counts to calculate the number of good triplets that can be formed with each element in nums2. It keeps track of the total number of good triplets using a variable called \"goodTripletCount\".\\n\\n### Complexity\\n- The **time complexity is O(n log n)** because the algorithm loops through nums1 and nums2 twice, once in reverse and once forwards, and for each element in these loops, it updates and queries the Fenwick Tree. The Fenwick Tree data structure has a time complexity of O(log n) for both update and query operations, so the overall time complexity is O(n log n) due to the loops running n times.\\n\\n- The **space complexity is O(n)** because the algorithm creates several arrays and vectors with a total size of n. These include the \"indexPositions\" array, the \"fenwickTree\" vector, and the \"smallerElementsToRight\" vector, each one has a size of n.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // function to return the last bit set in the input number\\n    inline int lastOne(int x) {\\n        return x & (-x);\\n    }\\n    \\n    // function to update a Fenwick tree with delta at index i\\n    void updateFenwickTree(vector<int>& fenwickTree, int index, int delta) {\\n        for(;index < fenwickTree.size(); index += lastOne(index)) {\\n            fenwickTree[index] += delta; \\n        }\\n    }\\n    \\n    // function to get the prefix sum of the Fenwick tree up to index i\\n    int getPrefixSum(vector<int>& fenwickTree, int index) {\\n        int prefixSum = 0; \\n        for(;index;index -= lastOne(index)) {\\n            prefixSum += fenwickTree[index];\\n        }\\n        return prefixSum; \\n    }\\n    \\n    // function to get the range sum of the Fenwick tree between startIndex and endIndex\\n    int getRangeSum(vector<int>& fenwickTree, int startIndex, int endIndex) {\\n        return getPrefixSum(fenwickTree,endIndex) - (startIndex == 1?0:getPrefixSum(fenwickTree,startIndex-1));\\n    }\\n    \\n    // main function to find good triplets\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        // get the size of the input vectors\\n        const int vectorSize = nums1.size(); \\n        // create a vector to hold the index positions of nums1\\n        vector<int> indexPositions(vectorSize);\\n        for(int i = 0; i < vectorSize; i++) {\\n            indexPositions[nums1[i]] = i;\\n        }\\n        // variable to count the number of good triplets\\n        long long goodTripletCount = 0; \\n        // create a Fenwick tree with size n + 5\\n        vector<int> fenwickTree(vectorSize + 5);\\n        // create a vector to hold the number of elements smaller than nums2[i] in nums1 to the right of nums1[i]\\n        vector<int> smallerElementsToRight(vectorSize);\\n        // loop through nums2 backwards\\n        for(int i = vectorSize - 1; i >= 0; i--) {\\n            // get the index position of nums2[i] in nums1\\n            int index = indexPositions[nums2[i]];\\n            // store the number of elements smaller than nums2[i] in nums1 to the right of nums1[i]\\n            smallerElementsToRight[nums2[i]] = getRangeSum(fenwickTree,index + 1,vectorSize + 1);\\n            // update the Fenwick tree at index j + 1\\n            updateFenwickTree(fenwickTree,index + 1,1);\\n        }\\n        // reset the Fenwick tree\\n        fenwickTree.assign(vectorSize + 5,0);\\n        // loop through nums2 forwards\\n        for(int i = 0; i < vectorSize; i++) {\\n            // get the index position of nums2[i] in nums1\\n            int index = indexPositions[nums2[i]];\\n            // count the number of good triplets using the stored values\\n            long long smallerElementsBefore = getPrefixSum(fenwickTree,index);\\n            goodTripletCount += smallerElementsBefore * smallerElementsToRight[nums2[i]];\\n            // update the Fenwick tree at index j + 1\\n            updateFenwickTree(fenwickTree,index + 1,1);\\n        }\\n    return goodTripletCount;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // function to return the last bit set in the input number\\n    inline int lastOne(int x) {\\n        return x & (-x);\\n    }\\n    \\n    // function to update a Fenwick tree with delta at index i\\n    void updateFenwickTree(vector<int>& fenwickTree, int index, int delta) {\\n        for(;index < fenwickTree.size(); index += lastOne(index)) {\\n            fenwickTree[index] += delta; \\n        }\\n    }\\n    \\n    // function to get the prefix sum of the Fenwick tree up to index i\\n    int getPrefixSum(vector<int>& fenwickTree, int index) {\\n        int prefixSum = 0; \\n        for(;index;index -= lastOne(index)) {\\n            prefixSum += fenwickTree[index];\\n        }\\n        return prefixSum; \\n    }\\n    \\n    // function to get the range sum of the Fenwick tree between startIndex and endIndex\\n    int getRangeSum(vector<int>& fenwickTree, int startIndex, int endIndex) {\\n        return getPrefixSum(fenwickTree,endIndex) - (startIndex == 1?0:getPrefixSum(fenwickTree,startIndex-1));\\n    }\\n    \\n    // main function to find good triplets\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        // get the size of the input vectors\\n        const int vectorSize = nums1.size(); \\n        // create a vector to hold the index positions of nums1\\n        vector<int> indexPositions(vectorSize);\\n        for(int i = 0; i < vectorSize; i++) {\\n            indexPositions[nums1[i]] = i;\\n        }\\n        // variable to count the number of good triplets\\n        long long goodTripletCount = 0; \\n        // create a Fenwick tree with size n + 5\\n        vector<int> fenwickTree(vectorSize + 5);\\n        // create a vector to hold the number of elements smaller than nums2[i] in nums1 to the right of nums1[i]\\n        vector<int> smallerElementsToRight(vectorSize);\\n        // loop through nums2 backwards\\n        for(int i = vectorSize - 1; i >= 0; i--) {\\n            // get the index position of nums2[i] in nums1\\n            int index = indexPositions[nums2[i]];\\n            // store the number of elements smaller than nums2[i] in nums1 to the right of nums1[i]\\n            smallerElementsToRight[nums2[i]] = getRangeSum(fenwickTree,index + 1,vectorSize + 1);\\n            // update the Fenwick tree at index j + 1\\n            updateFenwickTree(fenwickTree,index + 1,1);\\n        }\\n        // reset the Fenwick tree\\n        fenwickTree.assign(vectorSize + 5,0);\\n        // loop through nums2 forwards\\n        for(int i = 0; i < vectorSize; i++) {\\n            // get the index position of nums2[i] in nums1\\n            int index = indexPositions[nums2[i]];\\n            // count the number of good triplets using the stored values\\n            long long smallerElementsBefore = getPrefixSum(fenwickTree,index);\\n            goodTripletCount += smallerElementsBefore * smallerElementsToRight[nums2[i]];\\n            // update the Fenwick tree at index j + 1\\n            updateFenwickTree(fenwickTree,index + 1,1);\\n        }\\n    return goodTripletCount;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783431,
                "title": "python3-sortedlist-fenwick-tree",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/97dff55b43563450a33c98f2a216954117100dfe) for solutions of weekly 72. \\n\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        mp = {x : i for i, x in enumerate(nums1)}\\n        sl = SortedList()\\n        ans = 0 \\n        for i, x in enumerate(nums2):\\n            x = mp[x]\\n            left = sl.bisect_left(x)\\n            right = (len(nums2)-1-x) - (len(sl)-left)\\n            ans += left * right\\n            sl.add(x)\\n        return ans\\n```\\n\\nAdded Fenwick tree solution\\n```\\nclass Fenwick: \\n    def __init__(self, n: int):\\n        self.nums = [0]*(n+1)\\n\\n    def update(self, k: int, x: int) -> None: \\n        k += 1\\n        while k < len(self.nums): \\n            self.nums[k] += x\\n            k += k & -k \\n\\n    def query(self, k: int) -> int: \\n        k += 1\\n        ans = 0\\n        while k:\\n            ans += self.nums[k]\\n            k -= k & -k\\n        return ans\\n\\n    \\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        mp = {x : i for i, x in enumerate(nums1)}\\n        fw = Fenwick(n)\\n        ans = 0 \\n        for i, x in enumerate(nums2):\\n            x = mp[x]\\n            left = fw.query(x)\\n            right = (n-1-x) - (fw.query(n-1)-left)\\n            ans += left * right\\n            fw.update(x, 1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        mp = {x : i for i, x in enumerate(nums1)}\\n        sl = SortedList()\\n        ans = 0 \\n        for i, x in enumerate(nums2):\\n            x = mp[x]\\n            left = sl.bisect_left(x)\\n            right = (len(nums2)-1-x) - (len(sl)-left)\\n            ans += left * right\\n            sl.add(x)\\n        return ans\\n```\n```\\nclass Fenwick: \\n    def __init__(self, n: int):\\n        self.nums = [0]*(n+1)\\n\\n    def update(self, k: int, x: int) -> None: \\n        k += 1\\n        while k < len(self.nums): \\n            self.nums[k] += x\\n            k += k & -k \\n\\n    def query(self, k: int) -> int: \\n        k += 1\\n        ans = 0\\n        while k:\\n            ans += self.nums[k]\\n            k -= k & -k\\n        return ans\\n\\n    \\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        mp = {x : i for i, x in enumerate(nums1)}\\n        fw = Fenwick(n)\\n        ans = 0 \\n        for i, x in enumerate(nums2):\\n            x = mp[x]\\n            left = fw.query(x)\\n            right = (n-1-x) - (fw.query(n-1)-left)\\n            ans += left * right\\n            fw.update(x, 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834039,
                "title": "c-merge-sort-easy-to-understand",
                "content": "1. firstly we reorder num1 to make it as 0,1,2... Then num2 is reordered. \\nFor example: \\noriginal: nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]\\nnew     :  nums1 = [0,1,2,3,4], nums2 = [0,2,1,4,3]\\nAs a result, we can only focus on num2 because any three number in num1 satisfying the condition (pos_x<pos_y<pos_z) is equivalent to (x<y<z). Then the problem turns out to be finding triplet in num2 with index i<j<k, where nums2[i]<nums2[j]<nums2[k]. To achieve this goal, we need to know(1. numbers smaller than nums[i] when index<i; 2. numbers larger than nums[i] when index>i). \\nIt is very similar to the question in (https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/1804856/c-easy-to-understand-merge-sort-even-though-slow)\\n2. We merge-sort num2. During the merge sort process, x[i] record numbers of value smaller than x[i] for index<i. y[i] stores numbers of value larger than x[i] for index>i;\\nThe rule is simple:\\n\\tDuring the merge sort, we have two sorted sub array [l,mid] and [mid+1,r]. Whenever we have decided the position of the number in [l,mid] in new position, say i, we can calculate the numbers larger than nums2[i] in [mid+1,r]. For example:\\n[l,mid] is [1,3,6,10]\\n[mid+1,r] is [2,4,5,8,9]\\nthe merged array should be [1,2,3 ... ]. Here when we choose 3 in [l,mid] in the merged array, we have already chosen 1 number in [mid+1,r], i.e. \"2\". The rest number in [mid+1,r] will be greater than chosen \"3\" and in total we have 5 numbers in [mid+1,r]. So we have (5-1)=4.\\nSimiliarily, when we have the merged array [1,2,3,4,...]. We have \"4\" in [mid+1,r], then we look for the number in [l,mid] smaller than \"4\". Since we already choose 2 numbers(1,3) and [l,mid] has 4 numbers. The number in [l,mid] smaller than \"4\" is 4-2=2;\\n\\nAt the same time, when we reorder the number, we need to keep the index of the array for the old array. That is the reason to introduce vector<int> record. For example, with:\\nnums2 : 1,7,5,6,3,9\\nrecord:   0,1,2,3,4,5\\n\\nduring the merge sort, the number in nums2 is changing:\\nnums2 [1,5,7] [3,6,9]\\nrecord [0,2,1] [4,3,5]\\nrecord<int> maintain the index of each number in nums2, which help us calculate the number smaller or larger than each number in nums2.\\n3. For each number in num2, we count how many pairs satisfy our condition with x[i]* y[i].\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<ll> x,y;\\n    vector<int> record;\\n    void merge(vector<int> &total, int l,int r)\\n    {\\n        if(l>=r) return ;\\n        int mid=l+(r-l)/2;\\n        merge(total,l,mid);\\n        merge(total,mid+1,r);\\n        \\n        vector<int> tempValue(r-l+1);\\n        vector<int> tempRecord(r-l+1);\\n        int i=l,j=mid+1;\\n        int t=0;\\n        while(i<=mid && j<=r)\\n        {\\n            if(total[i]<=total[j])\\n            {\\n                tempValue[t]=total[i];\\n                tempRecord[t]=record[i];\\n                y[record[i]]+=(r-j+1);\\n                t++;\\n                i++;\\n            }\\n            else\\n            {\\n                tempValue[t]=total[j];\\n                tempRecord[t]=record[j];\\n                x[record[j]]+=i-l;\\n                t++;\\n                j++;\\n            }\\n        }\\n        while(i<=mid)\\n        {\\n            tempValue[t]=total[i];\\n            tempRecord[t]=record[i];\\n            t++;\\n            i++;\\n        }\\n        while(j<=r)\\n        {\\n            tempValue[t]=total[j];\\n            tempRecord[t]=record[j];\\n            x[record[j]]+=(mid-l+1);\\n            t++;\\n            j++;\\n        }\\n        for(int i=l;i<=r;i++)\\n        {\\n            total[i]=tempValue[i-l];\\n            record[i]=tempRecord[i-l];\\n        }\\n    }\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n    int n=nums1.size();\\n    vector<int> ind(n);\\n    x.resize(n);y.resize(n);\\n    for(int i=0;i<n;i++)\\n    {\\n        ind[nums1[i]]=i;\\n    }\\n    vector<int> todo(n);\\n    for(int i=0;i<n;i++)\\n    {\\n        todo[i]=ind[nums2[i]];\\n        record.push_back(i);\\n    }\\n    merge(todo,0,n-1);\\n    ll res=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        res+=x[i]*y[i];\\n    }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<ll> x,y;\\n    vector<int> record;\\n    void merge(vector<int> &total, int l,int r)\\n    {\\n        if(l>=r) return ;\\n        int mid=l+(r-l)/2;\\n        merge(total,l,mid);\\n        merge(total,mid+1,r);\\n        \\n        vector<int> tempValue(r-l+1);\\n        vector<int> tempRecord(r-l+1);\\n        int i=l,j=mid+1;\\n        int t=0;\\n        while(i<=mid && j<=r)\\n        {\\n            if(total[i]<=total[j])\\n            {\\n                tempValue[t]=total[i];\\n                tempRecord[t]=record[i];\\n                y[record[i]]+=(r-j+1);\\n                t++;\\n                i++;\\n            }\\n            else\\n            {\\n                tempValue[t]=total[j];\\n                tempRecord[t]=record[j];\\n                x[record[j]]+=i-l;\\n                t++;\\n                j++;\\n            }\\n        }\\n        while(i<=mid)\\n        {\\n            tempValue[t]=total[i];\\n            tempRecord[t]=record[i];\\n            t++;\\n            i++;\\n        }\\n        while(j<=r)\\n        {\\n            tempValue[t]=total[j];\\n            tempRecord[t]=record[j];\\n            x[record[j]]+=(mid-l+1);\\n            t++;\\n            j++;\\n        }\\n        for(int i=l;i<=r;i++)\\n        {\\n            total[i]=tempValue[i-l];\\n            record[i]=tempRecord[i-l];\\n        }\\n    }\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n    int n=nums1.size();\\n    vector<int> ind(n);\\n    x.resize(n);y.resize(n);\\n    for(int i=0;i<n;i++)\\n    {\\n        ind[nums1[i]]=i;\\n    }\\n    vector<int> todo(n);\\n    for(int i=0;i<n;i++)\\n    {\\n        todo[i]=ind[nums2[i]];\\n        record.push_back(i);\\n    }\\n    merge(todo,0,n-1);\\n    ll res=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        res+=x[i]*y[i];\\n    }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365255,
                "title": "segment-tree-complete-explanation-with-intuition-multiple-languages",
                "content": "# Intuition & Approach\\nAll the numbers in both arrays are unique and in the range of `0 to n-1`. The objective is to find triplets `(x, y, z)` that satisfy the conditions `posAx < posAy < posAz` and `posBx < posBy < posBz`, where `posAx` indicates the index of `x` in `A`, and `posBz` indicates the index of `z` in `B`.\\n\\nIf we fix a middle element, say `y`, we can find all the common elements in both arrays before and after `y`. All these common elements are valid candidates for `x` and `z`, respectively. Therefore, `(commonLeft * commonRight)` gives the total number of good triplets for that `y`. We repeat this process for all possible values of `y` to find the count of good triplets.\\n\\nFor each element in `A`, we find its corresponding index in `B` and update the segment tree at that index. An element\\'s index in `B` is only updated in the segment tree if it has already been visited in `A`. In other words, if an element has not been visited in `A`, its corresponding index in `B` will not be updated in the segment tree.\\n\\nSo, when we pick up an element in `A`, we obtain its index in `B`, say `indexB`. Now, `segmentTree[0..indexB]` will only contain indexes in the range `0 to indexB`, since we only update the segment tree when we visit the element in `A`. Updated values in the segment tree indicate that those specific updated indexes have been visited in `A`. Thus, by considering `segmentTree[0..indexB]`, we can obtain all the elements common to both `A` and `B` before a specific element.\\n\\nNow, to calculate the common elements after a specific element, we can use mathematics. Let\\'s say there are `k` common elements before a specific element `y`. Then, there are `posAy-k` unique elements in `A` before `y` that are not present in `B`. If `By` is present at index `j` in `B`, then there are `(n-1-j)` elements after `y` in `B`. To get the count of common elements after `y`, we need to subtract the count of unique elements before `Ay`, i.e., `posAy-k`, from the count of elements in `B` after `By`.\\n\\n# Algorithm\\n```\\n1. Create a hash map to store the mapping of elements in nums2 to their indices.\\nInitialize a segment tree of size n * 4 + 1, where n is the length of nums1.\\n3. Initialize ans = 0.\\n4. Loop through nums2 and add their indices to the hash map.\\n5. Update the segment tree with the index of the first element in nums1.\\n6. Loop through nums1 starting from the second element.\\n    a. Get the index of the current element in nums1 from the hash map.\\n    b. Query the segment tree to get the number of common elements on the left of the current element in nums1 and nums2.\\n    c. Calculate the number of unique elements on the left of the current element in nums1 and the number of elements on the right of the current element in nums2.\\n    d. Calculate the number of common elements on the right of the current element in nums1 and nums2.\\n    e. Add the product of the number of common elements on the left and right to ans.\\n    f. Update the segment tree with the index of the current element in nums1.\\n7. Return ans.\\n```\\n\\n# Complexity\\n- **Time complexity:**\\nThe loop over `nums2` to create `elemToIndexMappingInB` takes `O(n)` time. The segment tree construction takes `O(n)` time. The loop over `nums1` takes `O(n log n)` time due to the segment tree query and update operations. Therefore, the overall time complexity is `O(n log n + n)` i.e `O(n log n)`.\\n\\n- **Space complexity:**\\nThe `elemToIndexMappingInB` map takes `O(n)` space. The segment tree takes `O(n)` space. Therefore, the overall space complexity is `O(2n)` = `O(n)`.\\n\\n# Code\\n```java []\\nclass Solution {\\n\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        Map<Integer, Integer> elemToIndexMappingInB = new HashMap<>();\\n        int n = nums1.length;\\n        long[] segmentTree = new long[n * 4 + 1];\\n        long ans = 0;\\n        for (int i = 0; i < nums2.length; i++) {\\n            elemToIndexMappingInB.put(nums2[i], i);\\n        }\\n        update(segmentTree, 1, 0, n - 1, elemToIndexMappingInB.get(nums1[0]));\\n        for (int i = 1; i < n; i++) {\\n            int indexInB = elemToIndexMappingInB.get(nums1[i]);\\n            long commonElementsOnLeft = query(segmentTree, 1, 0, n - 1, 0, indexInB);\\n            long uniqueElementsOnLeftInA = i - commonElementsOnLeft;\\n            long elementsAfterIndexInB = n - 1 - indexInB;\\n            long commonElementsOnRight = elementsAfterIndexInB - uniqueElementsOnLeftInA;\\n            ans += commonElementsOnLeft * commonElementsOnRight;\\n            update(segmentTree, 1, 0, n - 1, indexInB);\\n        }\\n        return ans;\\n    }\\n\\n    private void update(long[] st, int index, int start, int end, int updateIndex) {\\n        if (start == end) {\\n            st[index] += 1;\\n            return;\\n        }\\n        int mid = start + (end - start) / 2;\\n        if (updateIndex <= mid) update(st, index * 2, start, mid, updateIndex);\\n        else update(st, index * 2 + 1, mid + 1, end, updateIndex);\\n        st[index] = st[index * 2] + st[index * 2 + 1];\\n    }\\n\\n    private long query(long[] st, int index, int start, int end, int queryStart, int queryEnd) {\\n        if (end < queryStart || start > queryEnd) return 0;\\n        if (start >= queryStart && end <= queryEnd) return st[index];\\n        int mid = start + (end - start) / 2;\\n        long left = query(st, index * 2, start, mid, queryStart, queryEnd);\\n        long right = query(st, index * 2 + 1, mid + 1, end, queryStart, queryEnd);\\n        return left + right;\\n    }\\n}\\n```\\n```cpp []\\n#include <unordered_map>\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(std::vector<int>& nums1, std::vector<int>& nums2) {\\n        std::unordered_map<int, int> elemToIndexMappingInB;\\n        int n = nums1.size();\\n        std::vector<long long> segmentTree(n * 4 + 1);\\n        long long ans = 0;\\n        for (int i = 0; i < nums2.size(); i++) {\\n            elemToIndexMappingInB[nums2[i]] = i;\\n        }\\n        update(segmentTree, 1, 0, n - 1, elemToIndexMappingInB[nums1[0]]);\\n        for (int i = 1; i < n; i++) {\\n            int indexInB = elemToIndexMappingInB[nums1[i]];\\n            long long commonElementsOnLeft = query(segmentTree, 1, 0, n - 1, 0, indexInB);\\n            long long uniqueElementsOnLeftInA = i - commonElementsOnLeft;\\n            long long elementsAfterIndexInB = n - 1 - indexInB;\\n            long long commonElementsOnRight = elementsAfterIndexInB - uniqueElementsOnLeftInA;\\n            ans += commonElementsOnLeft * commonElementsOnRight;\\n            update(segmentTree, 1, 0, n - 1, indexInB);\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    void update(std::vector<long long>& st, int index, int start, int end, int updateIndex) {\\n        if (start == end) {\\n            st[index] += 1;\\n            return;\\n        }\\n        int mid = start + (end - start) / 2;\\n        if (updateIndex <= mid) update(st, index * 2, start, mid, updateIndex);\\n        else update(st, index * 2 + 1, mid + 1, end, updateIndex);\\n        st[index] = st[index * 2] + st[index * 2 + 1];\\n    }\\n\\n    long long query(std::vector<long long>& st, int index, int start, int end, int queryStart, int queryEnd) {\\n        if (end < queryStart || start > queryEnd) return 0;\\n        if (start >= queryStart && end <= queryEnd) return st[index];\\n        int mid = start + (end - start) / 2;\\n        long long left = query(st, index * 2, start, mid, queryStart, queryEnd);\\n        long long right = query(st, index * 2 + 1, mid + 1, end, queryStart, queryEnd);\\n        return left + right;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        elemToIndexMappingInB = {}\\n        n = len(nums1)\\n        segmentTree = [0] * (n * 4 + 1)\\n        ans = 0\\n        for i in range(len(nums2)):\\n            elemToIndexMappingInB[nums2[i]] = i\\n        self.update(segmentTree, 1, 0, n - 1, elemToIndexMappingInB[nums1[0]])\\n        for i in range(1, n):\\n            indexInB = elemToIndexMappingInB[nums1[i]]\\n            commonElementsOnLeft = self.query(segmentTree, 1, 0, n - 1, 0, indexInB)\\n            uniqueElementsOnLeftInA = i - commonElementsOnLeft\\n            elementsAfterIndexInB = n - 1 - indexInB\\n            commonElementsOnRight = elementsAfterIndexInB - uniqueElementsOnLeftInA\\n            ans += commonElementsOnLeft * commonElementsOnRight\\n            self.update(segmentTree, 1, 0, n - 1, indexInB)\\n        return ans\\n\\n    def update(self, st, index, start, end, updateIndex):\\n        if start == end:\\n            st[index] += 1\\n            return\\n        mid = start + (end - start) // 2\\n        if updateIndex <= mid:\\n            self.update(st, index * 2, start, mid, updateIndex)\\n        else:\\n            self.update(st, index * 2 + 1, mid + 1, end, updateIndex)\\n        st[index] = st[index * 2] + st[index * 2 + 1]\\n\\n    def query(self, st, index, start, end, queryStart, queryEnd):\\n        if end < queryStart or start > queryEnd:\\n            return 0\\n        if start >= queryStart and end <= queryEnd:\\n            return st[index]\\n        mid = start + (end - start) // 2\\n        left = self.query(st, index * 2, start, mid, queryStart, queryEnd)\\n        right = self.query(st, index * 2 + 1, mid + 1, end, queryStart, queryEnd)\\n        return left + right\\n```\\n```javascript []\\nfunction goodTriplets(nums1, nums2) {\\n  const elemToIndexMappingInB = new Map();\\n  const n = nums1.length;\\n  const segmentTree = new Array(n * 4 + 1).fill(0);\\n  let ans = 0;\\n  for (let i = 0; i < nums2.length; i++) {\\n    elemToIndexMappingInB.set(nums2[i], i);\\n  }\\n  update(segmentTree, 1, 0, n - 1, elemToIndexMappingInB.get(nums1[0]));\\n  for (let i = 1; i < n; i++) {\\n    const indexInB = elemToIndexMappingInB.get(nums1[i]);\\n    const commonElementsOnLeft = query(segmentTree, 1, 0, n - 1, 0, indexInB);\\n    const uniqueElementsOnLeftInA = i - commonElementsOnLeft;\\n    const elementsAfterIndexInB = n - 1 - indexInB;\\n    const commonElementsOnRight = elementsAfterIndexInB - uniqueElementsOnLeftInA;\\n    ans += commonElementsOnLeft * commonElementsOnRight;\\n    update(segmentTree, 1, 0, n - 1, indexInB);\\n  }\\n  return ans;\\n}\\n\\nfunction update(st, index, start, end, updateIndex) {\\n  if (start == end) {\\n    st[index] += 1;\\n    return;\\n  }\\n  const mid = start + Math.floor((end - start) / 2);\\n  if (updateIndex <= mid) update(st, index * 2, start, mid, updateIndex);\\n  else update(st, index * 2 + 1, mid + 1, end, updateIndex);\\n  st[index] = st[index * 2] + st[index * 2 + 1];\\n}\\n\\nfunction query(st, index, start, end, queryStart, queryEnd) {\\n  if (end < queryStart || start > queryEnd) return 0;\\n  if (start >= queryStart && end <= queryEnd) return st[index];\\n  const mid = start + Math.floor((end - start) / 2);\\n  const left = query(st, index * 2, start, mid, queryStart, queryEnd);\\n  const right = query(st, index * 2 + 1, mid + 1, end, queryStart, queryEnd);\\n  return left + right;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Segment Tree"
                ],
                "code": "```\\n1. Create a hash map to store the mapping of elements in nums2 to their indices.\\nInitialize a segment tree of size n * 4 + 1, where n is the length of nums1.\\n3. Initialize ans = 0.\\n4. Loop through nums2 and add their indices to the hash map.\\n5. Update the segment tree with the index of the first element in nums1.\\n6. Loop through nums1 starting from the second element.\\n    a. Get the index of the current element in nums1 from the hash map.\\n    b. Query the segment tree to get the number of common elements on the left of the current element in nums1 and nums2.\\n    c. Calculate the number of unique elements on the left of the current element in nums1 and the number of elements on the right of the current element in nums2.\\n    d. Calculate the number of common elements on the right of the current element in nums1 and nums2.\\n    e. Add the product of the number of common elements on the left and right to ans.\\n    f. Update the segment tree with the index of the current element in nums1.\\n7. Return ans.\\n```\n```java []\\nclass Solution {\\n\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        Map<Integer, Integer> elemToIndexMappingInB = new HashMap<>();\\n        int n = nums1.length;\\n        long[] segmentTree = new long[n * 4 + 1];\\n        long ans = 0;\\n        for (int i = 0; i < nums2.length; i++) {\\n            elemToIndexMappingInB.put(nums2[i], i);\\n        }\\n        update(segmentTree, 1, 0, n - 1, elemToIndexMappingInB.get(nums1[0]));\\n        for (int i = 1; i < n; i++) {\\n            int indexInB = elemToIndexMappingInB.get(nums1[i]);\\n            long commonElementsOnLeft = query(segmentTree, 1, 0, n - 1, 0, indexInB);\\n            long uniqueElementsOnLeftInA = i - commonElementsOnLeft;\\n            long elementsAfterIndexInB = n - 1 - indexInB;\\n            long commonElementsOnRight = elementsAfterIndexInB - uniqueElementsOnLeftInA;\\n            ans += commonElementsOnLeft * commonElementsOnRight;\\n            update(segmentTree, 1, 0, n - 1, indexInB);\\n        }\\n        return ans;\\n    }\\n\\n    private void update(long[] st, int index, int start, int end, int updateIndex) {\\n        if (start == end) {\\n            st[index] += 1;\\n            return;\\n        }\\n        int mid = start + (end - start) / 2;\\n        if (updateIndex <= mid) update(st, index * 2, start, mid, updateIndex);\\n        else update(st, index * 2 + 1, mid + 1, end, updateIndex);\\n        st[index] = st[index * 2] + st[index * 2 + 1];\\n    }\\n\\n    private long query(long[] st, int index, int start, int end, int queryStart, int queryEnd) {\\n        if (end < queryStart || start > queryEnd) return 0;\\n        if (start >= queryStart && end <= queryEnd) return st[index];\\n        int mid = start + (end - start) / 2;\\n        long left = query(st, index * 2, start, mid, queryStart, queryEnd);\\n        long right = query(st, index * 2 + 1, mid + 1, end, queryStart, queryEnd);\\n        return left + right;\\n    }\\n}\\n```\n```cpp []\\n#include <unordered_map>\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(std::vector<int>& nums1, std::vector<int>& nums2) {\\n        std::unordered_map<int, int> elemToIndexMappingInB;\\n        int n = nums1.size();\\n        std::vector<long long> segmentTree(n * 4 + 1);\\n        long long ans = 0;\\n        for (int i = 0; i < nums2.size(); i++) {\\n            elemToIndexMappingInB[nums2[i]] = i;\\n        }\\n        update(segmentTree, 1, 0, n - 1, elemToIndexMappingInB[nums1[0]]);\\n        for (int i = 1; i < n; i++) {\\n            int indexInB = elemToIndexMappingInB[nums1[i]];\\n            long long commonElementsOnLeft = query(segmentTree, 1, 0, n - 1, 0, indexInB);\\n            long long uniqueElementsOnLeftInA = i - commonElementsOnLeft;\\n            long long elementsAfterIndexInB = n - 1 - indexInB;\\n            long long commonElementsOnRight = elementsAfterIndexInB - uniqueElementsOnLeftInA;\\n            ans += commonElementsOnLeft * commonElementsOnRight;\\n            update(segmentTree, 1, 0, n - 1, indexInB);\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    void update(std::vector<long long>& st, int index, int start, int end, int updateIndex) {\\n        if (start == end) {\\n            st[index] += 1;\\n            return;\\n        }\\n        int mid = start + (end - start) / 2;\\n        if (updateIndex <= mid) update(st, index * 2, start, mid, updateIndex);\\n        else update(st, index * 2 + 1, mid + 1, end, updateIndex);\\n        st[index] = st[index * 2] + st[index * 2 + 1];\\n    }\\n\\n    long long query(std::vector<long long>& st, int index, int start, int end, int queryStart, int queryEnd) {\\n        if (end < queryStart || start > queryEnd) return 0;\\n        if (start >= queryStart && end <= queryEnd) return st[index];\\n        int mid = start + (end - start) / 2;\\n        long long left = query(st, index * 2, start, mid, queryStart, queryEnd);\\n        long long right = query(st, index * 2 + 1, mid + 1, end, queryStart, queryEnd);\\n        return left + right;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        elemToIndexMappingInB = {}\\n        n = len(nums1)\\n        segmentTree = [0] * (n * 4 + 1)\\n        ans = 0\\n        for i in range(len(nums2)):\\n            elemToIndexMappingInB[nums2[i]] = i\\n        self.update(segmentTree, 1, 0, n - 1, elemToIndexMappingInB[nums1[0]])\\n        for i in range(1, n):\\n            indexInB = elemToIndexMappingInB[nums1[i]]\\n            commonElementsOnLeft = self.query(segmentTree, 1, 0, n - 1, 0, indexInB)\\n            uniqueElementsOnLeftInA = i - commonElementsOnLeft\\n            elementsAfterIndexInB = n - 1 - indexInB\\n            commonElementsOnRight = elementsAfterIndexInB - uniqueElementsOnLeftInA\\n            ans += commonElementsOnLeft * commonElementsOnRight\\n            self.update(segmentTree, 1, 0, n - 1, indexInB)\\n        return ans\\n\\n    def update(self, st, index, start, end, updateIndex):\\n        if start == end:\\n            st[index] += 1\\n            return\\n        mid = start + (end - start) // 2\\n        if updateIndex <= mid:\\n            self.update(st, index * 2, start, mid, updateIndex)\\n        else:\\n            self.update(st, index * 2 + 1, mid + 1, end, updateIndex)\\n        st[index] = st[index * 2] + st[index * 2 + 1]\\n\\n    def query(self, st, index, start, end, queryStart, queryEnd):\\n        if end < queryStart or start > queryEnd:\\n            return 0\\n        if start >= queryStart and end <= queryEnd:\\n            return st[index]\\n        mid = start + (end - start) // 2\\n        left = self.query(st, index * 2, start, mid, queryStart, queryEnd)\\n        right = self.query(st, index * 2 + 1, mid + 1, end, queryStart, queryEnd)\\n        return left + right\\n```\n```javascript []\\nfunction goodTriplets(nums1, nums2) {\\n  const elemToIndexMappingInB = new Map();\\n  const n = nums1.length;\\n  const segmentTree = new Array(n * 4 + 1).fill(0);\\n  let ans = 0;\\n  for (let i = 0; i < nums2.length; i++) {\\n    elemToIndexMappingInB.set(nums2[i], i);\\n  }\\n  update(segmentTree, 1, 0, n - 1, elemToIndexMappingInB.get(nums1[0]));\\n  for (let i = 1; i < n; i++) {\\n    const indexInB = elemToIndexMappingInB.get(nums1[i]);\\n    const commonElementsOnLeft = query(segmentTree, 1, 0, n - 1, 0, indexInB);\\n    const uniqueElementsOnLeftInA = i - commonElementsOnLeft;\\n    const elementsAfterIndexInB = n - 1 - indexInB;\\n    const commonElementsOnRight = elementsAfterIndexInB - uniqueElementsOnLeftInA;\\n    ans += commonElementsOnLeft * commonElementsOnRight;\\n    update(segmentTree, 1, 0, n - 1, indexInB);\\n  }\\n  return ans;\\n}\\n\\nfunction update(st, index, start, end, updateIndex) {\\n  if (start == end) {\\n    st[index] += 1;\\n    return;\\n  }\\n  const mid = start + Math.floor((end - start) / 2);\\n  if (updateIndex <= mid) update(st, index * 2, start, mid, updateIndex);\\n  else update(st, index * 2 + 1, mid + 1, end, updateIndex);\\n  st[index] = st[index * 2] + st[index * 2 + 1];\\n}\\n\\nfunction query(st, index, start, end, queryStart, queryEnd) {\\n  if (end < queryStart || start > queryEnd) return 0;\\n  if (start >= queryStart && end <= queryEnd) return st[index];\\n  const mid = start + Math.floor((end - start) / 2);\\n  const left = query(st, index * 2, start, mid, queryStart, queryEnd);\\n  const right = query(st, index * 2 + 1, mid + 1, end, queryStart, queryEnd);\\n  return left + right;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3034852,
                "title": "well-explained-easy-to-understand",
                "content": "## If you found my answer helpful, please consider giving it an upvote\\uD83D\\uDE0A\\n**ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 2 : Goldman Sachs\\nQ7. Count Good Triplets in an Array** \\n\\n### Approach\\nThe code is solving a problem where it has to find the total number of good triplets, which are groups of 3 numbers from two different groups (nums1 and nums2). A good triplet is one where the first number is from nums1, the second number is from nums2, and is greater than the first number, and the third number is from nums2 and is smaller than the first number.\\nIt does this by first creating a list of index positions for the elements in nums1, and then uses this list to find the position of each element in nums2 in nums1. It then uses a Fenwick Tree data structure to efficiently count the number of elements in nums1 that are smaller than an element in nums2 and located either before or after that element in nums1. Finally, it uses these counts to calculate the number of good triplets that can be formed with each element in nums2. It keeps track of the total number of good triplets using a variable called \"goodTripletCount\".\\n\\n### Complexity\\n- The **time complexity is O(n log n)** because the algorithm loops through nums1 and nums2 twice, once in reverse and once forwards, and for each element in these loops, it updates and queries the Fenwick Tree. The Fenwick Tree data structure has a time complexity of O(log n) for both update and query operations, so the overall time complexity is O(n log n) due to the loops running n times.\\n\\n- The **space complexity is O(n)** because the algorithm creates several arrays and vectors with a total size of n. These include the \"indexPositions\" array, the \"fenwickTree\" vector, and the \"smallerElementsToRight\" vector, each one has a size of n.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // function to return the last bit set in the input number\\n    inline int lastOne(int x) {\\n        return x & (-x);\\n    }\\n    \\n    // function to update a Fenwick tree with delta at index i\\n    void updateFenwickTree(vector<int>& fenwickTree, int index, int delta) {\\n        for(;index < fenwickTree.size(); index += lastOne(index)) {\\n            fenwickTree[index] += delta; \\n        }\\n    }\\n    \\n    // function to get the prefix sum of the Fenwick tree up to index i\\n    int getPrefixSum(vector<int>& fenwickTree, int index) {\\n        int prefixSum = 0; \\n        for(;index;index -= lastOne(index)) {\\n            prefixSum += fenwickTree[index];\\n        }\\n        return prefixSum; \\n    }\\n    \\n    // function to get the range sum of the Fenwick tree between startIndex and endIndex\\n    int getRangeSum(vector<int>& fenwickTree, int startIndex, int endIndex) {\\n        return getPrefixSum(fenwickTree,endIndex) - (startIndex == 1?0:getPrefixSum(fenwickTree,startIndex-1));\\n    }\\n    \\n    // main function to find good triplets\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        // get the size of the input vectors\\n        const int vectorSize = nums1.size(); \\n        // create a vector to hold the index positions of nums1\\n        vector<int> indexPositions(vectorSize);\\n        for(int i = 0; i < vectorSize; i++) {\\n            indexPositions[nums1[i]] = i;\\n        }\\n        // variable to count the number of good triplets\\n        long long goodTripletCount = 0; \\n        // create a Fenwick tree with size n + 5\\n        vector<int> fenwickTree(vectorSize + 5);\\n        // create a vector to hold the number of elements smaller than nums2[i] in nums1 to the right of nums1[i]\\n        vector<int> smallerElementsToRight(vectorSize);\\n        // loop through nums2 backwards\\n        for(int i = vectorSize - 1; i >= 0; i--) {\\n            // get the index position of nums2[i] in nums1\\n            int index = indexPositions[nums2[i]];\\n            // store the number of elements smaller than nums2[i] in nums1 to the right of nums1[i]\\n            smallerElementsToRight[nums2[i]] = getRangeSum(fenwickTree,index + 1,vectorSize + 1);\\n            // update the Fenwick tree at index j + 1\\n            updateFenwickTree(fenwickTree,index + 1,1);\\n        }\\n        // reset the Fenwick tree\\n        fenwickTree.assign(vectorSize + 5,0);\\n        // loop through nums2 forwards\\n        for(int i = 0; i < vectorSize; i++) {\\n            // get the index position of nums2[i] in nums1\\n            int index = indexPositions[nums2[i]];\\n            // count the number of good triplets using the stored values\\n            long long smallerElementsBefore = getPrefixSum(fenwickTree,index);\\n            goodTripletCount += smallerElementsBefore * smallerElementsToRight[nums2[i]];\\n            // update the Fenwick tree at index j + 1\\n            updateFenwickTree(fenwickTree,index + 1,1);\\n        }\\n    return goodTripletCount;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // function to return the last bit set in the input number\\n    inline int lastOne(int x) {\\n        return x & (-x);\\n    }\\n    \\n    // function to update a Fenwick tree with delta at index i\\n    void updateFenwickTree(vector<int>& fenwickTree, int index, int delta) {\\n        for(;index < fenwickTree.size(); index += lastOne(index)) {\\n            fenwickTree[index] += delta; \\n        }\\n    }\\n    \\n    // function to get the prefix sum of the Fenwick tree up to index i\\n    int getPrefixSum(vector<int>& fenwickTree, int index) {\\n        int prefixSum = 0; \\n        for(;index;index -= lastOne(index)) {\\n            prefixSum += fenwickTree[index];\\n        }\\n        return prefixSum; \\n    }\\n    \\n    // function to get the range sum of the Fenwick tree between startIndex and endIndex\\n    int getRangeSum(vector<int>& fenwickTree, int startIndex, int endIndex) {\\n        return getPrefixSum(fenwickTree,endIndex) - (startIndex == 1?0:getPrefixSum(fenwickTree,startIndex-1));\\n    }\\n    \\n    // main function to find good triplets\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        // get the size of the input vectors\\n        const int vectorSize = nums1.size(); \\n        // create a vector to hold the index positions of nums1\\n        vector<int> indexPositions(vectorSize);\\n        for(int i = 0; i < vectorSize; i++) {\\n            indexPositions[nums1[i]] = i;\\n        }\\n        // variable to count the number of good triplets\\n        long long goodTripletCount = 0; \\n        // create a Fenwick tree with size n + 5\\n        vector<int> fenwickTree(vectorSize + 5);\\n        // create a vector to hold the number of elements smaller than nums2[i] in nums1 to the right of nums1[i]\\n        vector<int> smallerElementsToRight(vectorSize);\\n        // loop through nums2 backwards\\n        for(int i = vectorSize - 1; i >= 0; i--) {\\n            // get the index position of nums2[i] in nums1\\n            int index = indexPositions[nums2[i]];\\n            // store the number of elements smaller than nums2[i] in nums1 to the right of nums1[i]\\n            smallerElementsToRight[nums2[i]] = getRangeSum(fenwickTree,index + 1,vectorSize + 1);\\n            // update the Fenwick tree at index j + 1\\n            updateFenwickTree(fenwickTree,index + 1,1);\\n        }\\n        // reset the Fenwick tree\\n        fenwickTree.assign(vectorSize + 5,0);\\n        // loop through nums2 forwards\\n        for(int i = 0; i < vectorSize; i++) {\\n            // get the index position of nums2[i] in nums1\\n            int index = indexPositions[nums2[i]];\\n            // count the number of good triplets using the stored values\\n            long long smallerElementsBefore = getPrefixSum(fenwickTree,index);\\n            goodTripletCount += smallerElementsBefore * smallerElementsToRight[nums2[i]];\\n            // update the Fenwick tree at index j + 1\\n            updateFenwickTree(fenwickTree,index + 1,1);\\n        }\\n    return goodTripletCount;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794503,
                "title": "c-preprocess-and-segment-tree-solution",
                "content": "Since nums1 and nums2 are permutation of [0, 1, 2, ..., n-1], we can alway process the arrays to make nums1 in increasing order.\\n\\nfor example, nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3], we can modify nums1 into [0, 1, 2, 3, 4], and correspondingly change elements in nums2, and nums2 becomes [0, 2, 1, 4, 3].\\n\\nThe key idea of this solution is, given an array ```nums``` of size ```n```, for every element ```nums[i]``` in this array, count elements smaller than ```nums[i]``` in subarray ```nums[0: i-1]```, and count greater than in ```nums[i+1: n-1]```.\\n\\nwe use segment tree to maintain if we have seen an element, if so, change the value in tree to 1, and iteratively increase the parent node for range sum.\\n\\nTo get the number of elements smaller than the current one, sum up values in segment tree between range [0, num-1].\\nAnd the number of element greater than the current one appears after ```nums[i]``` can be obtained by calculation.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    class SegmentTree {\\n    public:\\n        int size;\\n        vector<int> values;\\n        \\n        SegmentTree(int s) : size(s) {\\n            values = vector<int>(s * 2);\\n        }\\n        \\n        void increase(int pos) {\\n            pos += size;\\n            \\n            while (pos > 0) {\\n                values[pos]++;\\n                pos /= 2;\\n            }\\n        }\\n        \\n        int sum(int l, int r) {\\n            l += size;\\n            r += size;\\n            \\n            int res = 0;\\n            while (l <= r) {\\n                if (l % 2 == 1) {\\n                    res += values[l];\\n                    l++;\\n                }\\n                if (r % 2 == 0) {\\n                    res += values[r];\\n                    r--;\\n                }\\n                \\n                r /= 2;\\n                l /= 2;\\n            }\\n            \\n            return res;\\n        }\\n    };\\n    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> indexMap(n, 0);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            indexMap[nums2[i]] = i;\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            nums2[indexMap[nums1[i]]] = i;\\n            nums1[i] = i;\\n        }\\n        \\n        SegmentTree st(n);\\n\\n        long long res = 0;\\n        \\n        st.increase(nums2[0]);\\n        \\n        for (int i = 1; i < n - 1; ++i) {\\n            int num = nums2[i];\\n            \\n            int l = st.sum(0, num-1);\\n            int r = n - num - i + l - 1;\\n            \\n            res += (long long)r*l;\\n            \\n            st.increase(num);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```nums```\n```n```\n```nums[i]```\n```nums[i]```\n```nums[0: i-1]```\n```nums[i+1: n-1]```\n```nums[i]```\n```\\nclass Solution {\\npublic:\\n    class SegmentTree {\\n    public:\\n        int size;\\n        vector<int> values;\\n        \\n        SegmentTree(int s) : size(s) {\\n            values = vector<int>(s * 2);\\n        }\\n        \\n        void increase(int pos) {\\n            pos += size;\\n            \\n            while (pos > 0) {\\n                values[pos]++;\\n                pos /= 2;\\n            }\\n        }\\n        \\n        int sum(int l, int r) {\\n            l += size;\\n            r += size;\\n            \\n            int res = 0;\\n            while (l <= r) {\\n                if (l % 2 == 1) {\\n                    res += values[l];\\n                    l++;\\n                }\\n                if (r % 2 == 0) {\\n                    res += values[r];\\n                    r--;\\n                }\\n                \\n                r /= 2;\\n                l /= 2;\\n            }\\n            \\n            return res;\\n        }\\n    };\\n    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> indexMap(n, 0);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            indexMap[nums2[i]] = i;\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            nums2[indexMap[nums1[i]]] = i;\\n            nums1[i] = i;\\n        }\\n        \\n        SegmentTree st(n);\\n\\n        long long res = 0;\\n        \\n        st.increase(nums2[0]);\\n        \\n        for (int i = 1; i < n - 1; ++i) {\\n            int num = nums2[i];\\n            \\n            int l = st.sum(0, num-1);\\n            int r = n - num - i + l - 1;\\n            \\n            res += (long long)r*l;\\n            \\n            st.increase(num);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790781,
                "title": "javascript-segment-tree",
                "content": "1. **Get the indices of nums1[i] in nums2.**\\n  e.g: nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]\\n  idxs = [0,2,1,4,3]\\n2. **For each i, get the number of indices to the left of i smaller than idxs[i] in both nums1 and nums2.**\\n3. **For each i, get the number of indices to the right of i bigger than idxs[i] in both nums1 and nums2.**\\n4. **Get the number of good triplets by using each i as the middle of the triplet -> smallerLeft[i] * biggerRight[i]**\\n  Formula explanation: Let\\'s say we have indices 0,1 on the left and indices 3,4 on the right.\\n  We have 2 * 2 = 4 pairs because for each left index, it can be paired with each right index (with i as the middle element).\\n  0,3  0,4 and 1,3  1,4\\n\\nSegment Tree explanation:\\n  Similar to 315. Count of Smaller Numbers After Self, we use each bucket to store the frequency of the number.\\n  Instead of counting smaller numbers on the right, we are counting smaller numbers on the left and bigger numbers on the right.\\n\\n-----\\n\\nTime Complexity: O(n log(n)) 359ms\\nSpace Complexity: O(n) 65.1MB\\n\\n-----\\n\\n```\\nvar goodTriplets = function(nums1, nums2) {\\n  let n = nums1.length, nums2_idx = Array(n);\\n  for (let i = 0; i < n; i++) nums2_idx[nums2[i]] = i;\\n  let idxs = Array(n);\\n  for (let i = 0; i < n; i++) idxs[i] = nums2_idx[nums1[i]];\\n  \\n  let smallerLeft = getSmallerLeft(idxs); // smallerLeft[i] = number of indices to the left of i smaller than idxs[i] in both nums1 and nums2\\n  let biggerRight = getBiggerRight(idxs); // biggerRight[i] = number of indices to the right of i bigger than idxs[i] in both nums1 and nums2\\n  let ans = 0;\\n  for (let i = 1; i < n - 1; i++) {\\n    ans += smallerLeft[i] * biggerRight[i];\\n  }\\n  return ans;\\n};\\n\\nfunction getSmallerLeft(idxs) {\\n  let n = idxs.length, res = Array(n).fill(0);\\n  let segTree = new SegmentTree(n);\\n  for (let i = 0; i < n; i++) {\\n    res[i] = segTree.getSum(0, idxs[i] - 1);\\n    segTree.update(idxs[i], 1);\\n  }\\n  return res;\\n}\\n\\nfunction getBiggerRight(idxs) {\\n  let n = idxs.length, res = Array(n).fill(0);\\n  let segTree = new SegmentTree(n);\\n  for (let i = n - 1; i >= 0; i--) {\\n    res[i] = segTree.getSum(idxs[i] + 1, n - 1);\\n    segTree.update(idxs[i], 1);\\n  }\\n  return res;\\n}\\n\\nclass SegmentTree {\\n  constructor(n) {\\n    this.size = n;\\n    this.segTree = Array(n * 2).fill(0);\\n  }\\n  update(index, val) {\\n    let n = this.size, idx = index + n;\\n    this.segTree[idx] += val;\\n    idx = Math.floor(idx / 2);\\n\\n    while (idx > 0) {\\n      this.segTree[idx] = this.segTree[idx * 2] + this.segTree[idx * 2 + 1];\\n      idx = Math.floor(idx / 2);\\n    }\\n  }\\n  getSum(left, right) {\\n    let n = this.size, sum = 0;\\n    let left_idx = left + n, right_idx = right + n;\\n    // left must be even, right must be odd\\n    while (left_idx <= right_idx) {\\n      if (left_idx % 2 === 1) sum += this.segTree[left_idx++];\\n      if (right_idx % 2 === 0) sum += this.segTree[right_idx--];\\n      left_idx = Math.floor(left_idx / 2);\\n      right_idx = Math.floor(right_idx / 2);\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nvar goodTriplets = function(nums1, nums2) {\\n  let n = nums1.length, nums2_idx = Array(n);\\n  for (let i = 0; i < n; i++) nums2_idx[nums2[i]] = i;\\n  let idxs = Array(n);\\n  for (let i = 0; i < n; i++) idxs[i] = nums2_idx[nums1[i]];\\n  \\n  let smallerLeft = getSmallerLeft(idxs); // smallerLeft[i] = number of indices to the left of i smaller than idxs[i] in both nums1 and nums2\\n  let biggerRight = getBiggerRight(idxs); // biggerRight[i] = number of indices to the right of i bigger than idxs[i] in both nums1 and nums2\\n  let ans = 0;\\n  for (let i = 1; i < n - 1; i++) {\\n    ans += smallerLeft[i] * biggerRight[i];\\n  }\\n  return ans;\\n};\\n\\nfunction getSmallerLeft(idxs) {\\n  let n = idxs.length, res = Array(n).fill(0);\\n  let segTree = new SegmentTree(n);\\n  for (let i = 0; i < n; i++) {\\n    res[i] = segTree.getSum(0, idxs[i] - 1);\\n    segTree.update(idxs[i], 1);\\n  }\\n  return res;\\n}\\n\\nfunction getBiggerRight(idxs) {\\n  let n = idxs.length, res = Array(n).fill(0);\\n  let segTree = new SegmentTree(n);\\n  for (let i = n - 1; i >= 0; i--) {\\n    res[i] = segTree.getSum(idxs[i] + 1, n - 1);\\n    segTree.update(idxs[i], 1);\\n  }\\n  return res;\\n}\\n\\nclass SegmentTree {\\n  constructor(n) {\\n    this.size = n;\\n    this.segTree = Array(n * 2).fill(0);\\n  }\\n  update(index, val) {\\n    let n = this.size, idx = index + n;\\n    this.segTree[idx] += val;\\n    idx = Math.floor(idx / 2);\\n\\n    while (idx > 0) {\\n      this.segTree[idx] = this.segTree[idx * 2] + this.segTree[idx * 2 + 1];\\n      idx = Math.floor(idx / 2);\\n    }\\n  }\\n  getSum(left, right) {\\n    let n = this.size, sum = 0;\\n    let left_idx = left + n, right_idx = right + n;\\n    // left must be even, right must be odd\\n    while (left_idx <= right_idx) {\\n      if (left_idx % 2 === 1) sum += this.segTree[left_idx++];\\n      if (right_idx % 2 === 0) sum += this.segTree[right_idx--];\\n      left_idx = Math.floor(left_idx / 2);\\n      right_idx = Math.floor(right_idx / 2);\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786270,
                "title": "python-segment-tree-o-nlogn-time",
                "content": "The following code can be changed to binary indexed tree easily. And binary indexed tree is much faster\\n\\n```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        d = { e: i for i, e in enumerate(nums1)}\\n        nums2 = [ d[e] for e in nums2]\\n        def getobj(tree,v,tl,tr,l,r):\\n            #no overlapping\\n            if r < tl or tr < l:\\n                return 0\\n            #query range contained\\n            elif l<=tl and tr<=r:\\n                return tree[v]\\n            else:\\n                m = (tl+tr)//2\\n                return getobj(tree,2*v+1,tl,m,l,r)+getobj(tree,2*v+2,m+1,tr,l,r)\\n            \\n        def update(tree,v,tl,tr,idx,val):\\n            if tl==idx==tr:\\n                tree[v]=val\\n                return val\\n            mid = (tl+tr)//2    \\n            if tl<=idx<=mid:\\n                tree[v]=update(tree,2*v+1,tl,mid,idx,val)+tree[2*v+2]\\n            else:\\n                tree[v]=tree[2*v+1]+update(tree,2*v+2,mid+1,tr,idx,val)\\n            return tree[v]\\n        \\n        n = len(nums2)\\n        tree = [0]*(4*n)\\n        res = 0\\n        for i in range(n-1):\\n            base = nums2[i]\\n            update(tree,0,0,n-1,base,1)\\n            tmp = getobj(tree,0,0,n-1,0,base-1)\\n            res += tmp*(n-1-base-i+tmp)\\n        return res\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        d = { e: i for i, e in enumerate(nums1)}\\n        nums2 = [ d[e] for e in nums2]\\n        def getobj(tree,v,tl,tr,l,r):\\n            #no overlapping\\n            if r < tl or tr < l:\\n                return 0\\n            #query range contained\\n            elif l<=tl and tr<=r:\\n                return tree[v]\\n            else:\\n                m = (tl+tr)//2\\n                return getobj(tree,2*v+1,tl,m,l,r)+getobj(tree,2*v+2,m+1,tr,l,r)\\n            \\n        def update(tree,v,tl,tr,idx,val):\\n            if tl==idx==tr:\\n                tree[v]=val\\n                return val\\n            mid = (tl+tr)//2    \\n            if tl<=idx<=mid:\\n                tree[v]=update(tree,2*v+1,tl,mid,idx,val)+tree[2*v+2]\\n            else:\\n                tree[v]=tree[2*v+1]+update(tree,2*v+2,mid+1,tr,idx,val)\\n            return tree[v]\\n        \\n        n = len(nums2)\\n        tree = [0]*(4*n)\\n        res = 0\\n        for i in range(n-1):\\n            base = nums2[i]\\n            update(tree,0,0,n-1,base,1)\\n            tmp = getobj(tree,0,0,n-1,0,base-1)\\n            res += tmp*(n-1-base-i+tmp)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785302,
                "title": "c-inversion-count-merge-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<ll>inv;\\n    vector<pair<int,int>>v;\\n    void merge(int l,int mid,int h)\\n    {\\n        int i=l,j=mid+1;\\n        while(i<=mid || j<=h)\\n        {\\n            if(i>mid)\\n                break;\\n            else if(j>h)\\n            {\\n                int ind=v[i].second;\\n                inv[ind]+=(j-mid-1);\\n                i++;\\n            }\\n            else if(v[i].first<v[j].first)\\n            {\\n                int ind=v[i].second;\\n                inv[ind]+=(j-mid-1);\\n                i++;\\n            }\\n            else\\n                j++;\\n        }\\n        sort(v.begin()+l,v.begin()+h+1);\\n    }\\n    void mergesort(int l,int h)\\n    {\\n        if(l<h)\\n        {\\n            int mid=(l+h)/2;\\n            mergesort(l,mid);\\n            mergesort(mid+1,h);\\n            merge(l,mid,h);\\n        }\\n    }\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        //Map each val in nums2 with corresponding index in nums1\\n        //Then find no. of pairs nums2[i]<nums2[j]<nums2[k] where i<j<k\\n        \\n        int n=nums1.size();\\n        vector<int>mp(n);\\n        for(int i=0;i<n;i++)\\n            mp[nums1[i]]=i;\\n        for(int i=0;i<n;i++)\\n        {\\n            nums2[i]=mp[nums2[i]];\\n            v.push_back({nums2[i],i});\\n        }\\n        \\n        //First count inversion for each element in nums2 after maping\\n        inv.resize(n,0);\\n        mergesort(0,n-1);\\n        \\n        //left[i] ->count of no. of elements less than nums2[i] in left\\n        //right[i] ->count of no. of elements greater than nums2[i] in right \\n        ll res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ll right=(n-i-1)-inv[i];\\n            ll left=nums2[i]-inv[i];\\n            res+=(left*right);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<ll>inv;\\n    vector<pair<int,int>>v;\\n    void merge(int l,int mid,int h)\\n    {\\n        int i=l,j=mid+1;\\n        while(i<=mid || j<=h)\\n        {\\n            if(i>mid)\\n                break;\\n            else if(j>h)\\n            {\\n                int ind=v[i].second;\\n                inv[ind]+=(j-mid-1);\\n                i++;\\n            }\\n            else if(v[i].first<v[j].first)\\n            {\\n                int ind=v[i].second;\\n                inv[ind]+=(j-mid-1);\\n                i++;\\n            }\\n            else\\n                j++;\\n        }\\n        sort(v.begin()+l,v.begin()+h+1);\\n    }\\n    void mergesort(int l,int h)\\n    {\\n        if(l<h)\\n        {\\n            int mid=(l+h)/2;\\n            mergesort(l,mid);\\n            mergesort(mid+1,h);\\n            merge(l,mid,h);\\n        }\\n    }\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        //Map each val in nums2 with corresponding index in nums1\\n        //Then find no. of pairs nums2[i]<nums2[j]<nums2[k] where i<j<k\\n        \\n        int n=nums1.size();\\n        vector<int>mp(n);\\n        for(int i=0;i<n;i++)\\n            mp[nums1[i]]=i;\\n        for(int i=0;i<n;i++)\\n        {\\n            nums2[i]=mp[nums2[i]];\\n            v.push_back({nums2[i],i});\\n        }\\n        \\n        //First count inversion for each element in nums2 after maping\\n        inv.resize(n,0);\\n        mergesort(0,n-1);\\n        \\n        //left[i] ->count of no. of elements less than nums2[i] in left\\n        //right[i] ->count of no. of elements greater than nums2[i] in right \\n        ll res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ll right=(n-i-1)-inv[i];\\n            ll left=nums2[i]-inv[i];\\n            res+=(left*right);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784262,
                "title": "python-simple-o-nlogn-solution-using-bisect",
                "content": "```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        res = 0\\n        m2 = [0] * n\\n        q = []\\n        \\n\\t\\t# Build index map of nums2\\n        for i in range(n):\\n            m2[nums2[i]] = i\\n            \\n        for p1 in range(n):\\n            p2 = m2[nums1[p1]] # Position of nums1[p1] in nums2\\n            idx = bisect.bisect(q, p2) # Position smaller than this one so far\\n            q.insert(idx, p2)\\n            before = idx\\n            after = n-1 - p1 - p2 + before # Based on number of unique values before and after are the same\\n            res += before * after\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        res = 0\\n        m2 = [0] * n\\n        q = []\\n        \\n\\t\\t# Build index map of nums2\\n        for i in range(n):\\n            m2[nums2[i]] = i\\n            \\n        for p1 in range(n):\\n            p2 = m2[nums1[p1]] # Position of nums1[p1] in nums2\\n            idx = bisect.bisect(q, p2) # Position smaller than this one so far\\n            q.insert(idx, p2)\\n            before = idx\\n            after = n-1 - p1 - p2 + before # Based on number of unique values before and after are the same\\n            res += before * after\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784023,
                "title": "java-solution-fenwick-tree-binary-index-tree",
                "content": "```\\nclass Solution {\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n= nums1.length;\\n        int indices[]= new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            indices[nums2[i]]=i;\\n        }\\n        int B[]= new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            B[i]=indices[nums1[i]];\\n            B[i]++;\\n        }\\n        Fenw L=new Fenw(n+1);\\n        long []left= new long[n+1];\\n        long []right= new long[n+1];\\n        for(int i=1;i<=n;i++)\\n        {\\n            left[i]=L.sum(B[i-1]-1);\\n            L.update(B[i-1],1);\\n        }\\n         Fenw R=new Fenw(n+1);\\n        for(int i=n;i>0;i--)\\n        {\\n            right[i]=R.sum(n)-R.sum(B[i-1]);\\n            R.update(B[i-1],1);\\n        }\\n        long ans=0l;\\n        for(int i=0;i<=n;i++)\\n        {\\n            ans+=left[i]*right[i];\\n        }\\n        return ans;\\n    }\\n}\\nclass Fenw\\n{\\n    long[]farr;\\n    int n;\\n    Fenw(int n)\\n    {\\n        this.n=n;\\n        farr=new long[n+1];\\n    }\\n    void update(int index, int val)\\n    {\\n        int c=0;\\n        for(int i=index;i<=n;i+=(i&-i))\\n        {\\n            c++;\\n            farr[i]+=val;\\n        }\\n    }\\n   \\n    long sum(int index)\\n    {\\n        long ans=0l;\\n        for(int i=index;i>0;i-=(i&-i))\\n        {\\n            ans+=farr[i];\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Indexed Tree"
                ],
                "code": "class Solution {\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n= nums1.length;\\n        int indices[]= new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            indices[nums2[i]]=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1783554,
                "title": "go-left-right-fenwick",
                "content": "For each number in `nums2`, find the index that number would have if it were in\\n`nums1`. Let\\'s call it n1Pos:\\n\\n```go\\nnums1 = [ 0, 5, 1, 4, 2, 3 ]\\nnums2 = [ 5, 1, 0, 4, 3, 2 ]\\nn1Pos = [ 1, 2, 0, 3, 5, 4 ]\\n```\\n\\nConsider the index `j` in `n1Pos` - let\\'s call it the pivot. \\n\\nAny pair `(i, j)` where `i < j` is valid IFF `n1Pos[i] < n1Pos[j]`.\\nAny pair `(j, k)` where `j < k` is valid IFF `n1Pos[j] < n1Pos[k]`.\\n\\nAny valid pair on the left can be combined with a valid pair on the right to\\nform a valid triplet. Forming n_left * n_right triplets.\\n\\nThe tricky part is that even calculating all possible 2-pairs is too slow, so we\\nneed some faster way of finding the number of values below / above a certain value.\\n\\nBy having a Fenwick tree for the left side, and one for the right side, we can\\nquickly calculate how many indices were above / below the pivot.\\n\\n# Solution\\n\\n```go\\nfunc goodTriplets(nums1 []int, nums2 []int) int64 {\\n\\tn := len(nums1)\\n\\n\\tidx := make([]int, n)\\n\\tfor i := range nums1 {\\n\\t\\tidx[nums1[i]] = i\\n\\t}\\n\\n\\tn1Pos := make([]int, n)\\n\\tfor i, n2 := range nums2 {\\n\\t\\tn1Pos[i] = idx[n2]\\n\\t}\\n\\n\\tright := NewFenwick(n)\\n\\tleft := NewFenwick(n)\\n\\n\\tvar count int64\\n\\tfor i := 2; i < n; i++ {\\n\\t\\tright.Add(n1Pos[i], 1)\\n\\t}\\n\\tleft.Add(n1Pos[0], 1)\\n\\n\\tfor i := 1; i < n-1; i++ {\\n\\t\\tbelow := left.Sum(n1Pos[i])\\n\\t\\tabove := right.Sum(n-1) - right.Sum(n1Pos[i])\\n\\t\\tcount += int64(below * above)\\n\\t\\tleft.Add(n1Pos[i], 1)\\n\\t\\tright.Add(n1Pos[i+1], -1)\\n\\t}\\n\\n\\treturn int64(count)\\n}\\n\\ntype Fenwick struct {\\n\\ttree []int\\n}\\n\\nfunc NewFenwick(n int) *Fenwick {\\n\\treturn &Fenwick{\\n\\t\\ttree: make([]int, n+1),\\n\\t}\\n}\\n\\nfunc (f *Fenwick) Init(vals []int) {\\n\\tn := len(vals)\\n\\tcopy(f.tree, vals)\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tp := i + (i & -i)\\n\\t\\tif p < n {\\n\\t\\t\\tf.tree[p] += f.tree[i]\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (f *Fenwick) Add(i int, k int) {\\n\\ti++\\n\\tfor i < len(f.tree) {\\n\\t\\tf.tree[i] += k\\n\\t\\ti += i & -i\\n\\t}\\n}\\n\\nfunc (f *Fenwick) Sum(i int) int {\\n\\ti++\\n\\tres := 0\\n\\tfor i > 0 {\\n\\t\\tres += f.tree[i]\\n\\t\\ti -= i & -i\\n\\t}\\n\\treturn res\\n\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nnums1 = [ 0, 5, 1, 4, 2, 3 ]\\nnums2 = [ 5, 1, 0, 4, 3, 2 ]\\nn1Pos = [ 1, 2, 0, 3, 5, 4 ]\\n```\n```go\\nfunc goodTriplets(nums1 []int, nums2 []int) int64 {\\n\\tn := len(nums1)\\n\\n\\tidx := make([]int, n)\\n\\tfor i := range nums1 {\\n\\t\\tidx[nums1[i]] = i\\n\\t}\\n\\n\\tn1Pos := make([]int, n)\\n\\tfor i, n2 := range nums2 {\\n\\t\\tn1Pos[i] = idx[n2]\\n\\t}\\n\\n\\tright := NewFenwick(n)\\n\\tleft := NewFenwick(n)\\n\\n\\tvar count int64\\n\\tfor i := 2; i < n; i++ {\\n\\t\\tright.Add(n1Pos[i], 1)\\n\\t}\\n\\tleft.Add(n1Pos[0], 1)\\n\\n\\tfor i := 1; i < n-1; i++ {\\n\\t\\tbelow := left.Sum(n1Pos[i])\\n\\t\\tabove := right.Sum(n-1) - right.Sum(n1Pos[i])\\n\\t\\tcount += int64(below * above)\\n\\t\\tleft.Add(n1Pos[i], 1)\\n\\t\\tright.Add(n1Pos[i+1], -1)\\n\\t}\\n\\n\\treturn int64(count)\\n}\\n\\ntype Fenwick struct {\\n\\ttree []int\\n}\\n\\nfunc NewFenwick(n int) *Fenwick {\\n\\treturn &Fenwick{\\n\\t\\ttree: make([]int, n+1),\\n\\t}\\n}\\n\\nfunc (f *Fenwick) Init(vals []int) {\\n\\tn := len(vals)\\n\\tcopy(f.tree, vals)\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tp := i + (i & -i)\\n\\t\\tif p < n {\\n\\t\\t\\tf.tree[p] += f.tree[i]\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (f *Fenwick) Add(i int, k int) {\\n\\ti++\\n\\tfor i < len(f.tree) {\\n\\t\\tf.tree[i] += k\\n\\t\\ti += i & -i\\n\\t}\\n}\\n\\nfunc (f *Fenwick) Sum(i int) int {\\n\\ti++\\n\\tres := 0\\n\\tfor i > 0 {\\n\\t\\tres += f.tree[i]\\n\\t\\ti -= i & -i\\n\\t}\\n\\treturn res\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783358,
                "title": "python-solution-with-bisect",
                "content": "First normalize the arrays, so that one is sorted and the other one not.\\n\\nThen go over the unsorted backwards and count for each position (using bisect) the number of elements that are behind and are higher and are before and are lower.\\n\\nTime complexity O(nlogn)\\n\\n```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        D = {}\\n        for i in range(len(nums1)):\\n            D[nums1[i]] = i\\n            \\n        ans = []\\n        for el in nums2:\\n            ans.append(D[el])\\n            \\n        a = 0\\n        kk = []\\n\\n        j = 0\\n        n = len(nums1)\\n        \\n        for el in ans[::-1]:\\n            index = bisect.bisect(kk, el)\\n            bisect.insort(kk, el)\\n            \\n            lower = el - index\\n            higher = j - index\\n            \\n            j += 1\\n            a += lower * higher\\n            \\n        return a\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        D = {}\\n        for i in range(len(nums1)):\\n            D[nums1[i]] = i\\n            \\n        ans = []\\n        for el in nums2:\\n            ans.append(D[el])\\n            \\n        a = 0\\n        kk = []\\n\\n        j = 0\\n        n = len(nums1)\\n        \\n        for el in ans[::-1]:\\n            index = bisect.bisect(kk, el)\\n            bisect.insort(kk, el)\\n            \\n            lower = el - index\\n            higher = j - index\\n            \\n            j += 1\\n            a += lower * higher\\n            \\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941845,
                "title": "2-approaches-cdq-divide-conquer-and-segment-tree",
                "content": "# CDQ Divide & Conquer algorithm\\nThis is inspired by the one that uses CDQ to solve LIS problem.\\n\\nThe main point is that we should traverse the D&C tree in ```inorder``` manner so that we can promise each node have correctly calculated ```prev[]``` in the left part.\\n\\nMaintain a global ```prev[]``` array to store how many \"smaller\" numbers for each entry in the left-hand side. Building this array is building the local answer. Do not mess this up. That\\'s why inorder is important.\\n\\n# Segment Tree\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe segtree method is not surprising. This problem is pretty suitable for that.\\n\\n# Comparison\\n<!-- Describe your approach to solving the problem. -->\\n\\nSegment tree method is much faster.\\nCDQ uses too many sort and recursive, and also have higher complextiy.\\n\\n\\n# Complexity\\n- Time complexity: ```O(n * logn * logn)``` for D&C\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nnlogn nodes of D&C tree, each node needs triple ```sort()``` to merge.\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nCDQ Divide & Conquer\\n```\\nclass Solution {\\npublic:\\n    int prev[100001] = {};\\n    array<int, 2> ARR[100001];  // num, index\\n\\n    #define BYIND [](auto const &a, auto const &b){return a[1] < b[1];}\\n    #define BYNUM [](auto const &a, auto const &b){return a[0] < b[0];}\\n\\n    long CDQ(array<int, 2> *arr, int n) {\\n        if(n <= 1) return 0;\\n        int mid = n / 2, m = n - mid;\\n        long ret = CDQ(arr, mid);  // to build the corrent \"prev\" array\\n        long sum = 0;\\n        \\n        sort(arr, arr + mid, BYNUM), sort(arr + mid, arr + n, BYNUM);\\n        for(int i = 0, j = mid; j < n; ++j) {\\n            int cur = arr[j][0], indj = arr[j][1];\\n            while(i < mid && arr[i][0] < cur) {\\n                sum += prev[arr[i][1]];\\n                ++i;\\n            }\\n            ret += sum;\\n            prev[indj] += i;  // update the #prevs for j\\n        }\\n        // restore the arr\\n        sort(arr, arr + n, BYIND);\\n        ret += CDQ(arr + mid, m);\\n        return ret;\\n    }\\n\\n    long long goodTriplets(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> M;\\n        for(int i = 0; i < B.size(); ++i) M[B[i]] = i;\\n\\n        for(int &i: A) i = M[i];\\n\\n        for(int i = 0; i < A.size(); ++i) ARR[i] = {A[i], i};\\n\\n        return CDQ(ARR, A.size());\\n    }\\n};\\n```\\n\\nSegment Tree\\n```\\nclass Solution {\\npublic:\\n    #define n 100005\\n\\n    class segtree {\\n        int tree[n * 2] = {};  // Need to init\\n        public:\\n\\n        int q(int l, int r) {\\n            l += n, r += n;\\n            int ret = 0;\\n            while(l <= r) {\\n                if(l % 2 == 1) ret += tree[l++];\\n                if(r % 2 == 0) ret += tree[r--];\\n                l /= 2, r /= 2;\\n            }\\n            return ret;\\n        }\\n\\n        void mod(int i, int k) {\\n            i += n;\\n            tree[i] += k;\\n            for(i /= 2; i >= 1; i /= 2)\\n                tree[i] = tree[i * 2] + tree[i * 2 + 1];\\n        }\\n    };\\n\\n    long long goodTriplets(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> M;\\n        for(int i = 0; i < B.size(); ++i) M[B[i]] = i;\\n\\n        for(int &i: A) i = M[i];\\n\\n        segtree l, r;\\n\\n        // build right\\n        for(int i = 0; i < A.size(); ++i) r.mod(A[i], 1);\\n\\n        long ret = 0;\\n        for(int i = 0; i < A.size(); ++i) {\\n            int cur = A[i];\\n            r.mod(cur, -1);\\n            long lsum = l.q(0, cur - 1);\\n            int rsum = r.q(cur + 1, A.size());\\n            ret += lsum * rsum;\\n            // update\\n            l.mod(cur, 1);\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree",
                    "Merge Sort"
                ],
                "code": "```inorder```\n```prev[]```\n```prev[]```\n```O(n * logn * logn)```\n```sort()```\n```\\nclass Solution {\\npublic:\\n    int prev[100001] = {};\\n    array<int, 2> ARR[100001];  // num, index\\n\\n    #define BYIND [](auto const &a, auto const &b){return a[1] < b[1];}\\n    #define BYNUM [](auto const &a, auto const &b){return a[0] < b[0];}\\n\\n    long CDQ(array<int, 2> *arr, int n) {\\n        if(n <= 1) return 0;\\n        int mid = n / 2, m = n - mid;\\n        long ret = CDQ(arr, mid);  // to build the corrent \"prev\" array\\n        long sum = 0;\\n        \\n        sort(arr, arr + mid, BYNUM), sort(arr + mid, arr + n, BYNUM);\\n        for(int i = 0, j = mid; j < n; ++j) {\\n            int cur = arr[j][0], indj = arr[j][1];\\n            while(i < mid && arr[i][0] < cur) {\\n                sum += prev[arr[i][1]];\\n                ++i;\\n            }\\n            ret += sum;\\n            prev[indj] += i;  // update the #prevs for j\\n        }\\n        // restore the arr\\n        sort(arr, arr + n, BYIND);\\n        ret += CDQ(arr + mid, m);\\n        return ret;\\n    }\\n\\n    long long goodTriplets(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> M;\\n        for(int i = 0; i < B.size(); ++i) M[B[i]] = i;\\n\\n        for(int &i: A) i = M[i];\\n\\n        for(int i = 0; i < A.size(); ++i) ARR[i] = {A[i], i};\\n\\n        return CDQ(ARR, A.size());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    #define n 100005\\n\\n    class segtree {\\n        int tree[n * 2] = {};  // Need to init\\n        public:\\n\\n        int q(int l, int r) {\\n            l += n, r += n;\\n            int ret = 0;\\n            while(l <= r) {\\n                if(l % 2 == 1) ret += tree[l++];\\n                if(r % 2 == 0) ret += tree[r--];\\n                l /= 2, r /= 2;\\n            }\\n            return ret;\\n        }\\n\\n        void mod(int i, int k) {\\n            i += n;\\n            tree[i] += k;\\n            for(i /= 2; i >= 1; i /= 2)\\n                tree[i] = tree[i * 2] + tree[i * 2 + 1];\\n        }\\n    };\\n\\n    long long goodTriplets(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> M;\\n        for(int i = 0; i < B.size(); ++i) M[B[i]] = i;\\n\\n        for(int &i: A) i = M[i];\\n\\n        segtree l, r;\\n\\n        // build right\\n        for(int i = 0; i < A.size(); ++i) r.mod(A[i], 1);\\n\\n        long ret = 0;\\n        for(int i = 0; i < A.size(); ++i) {\\n            int cur = A[i];\\n            r.mod(cur, -1);\\n            long lsum = l.q(0, cur - 1);\\n            int rsum = r.q(cur + 1, A.size());\\n            ret += lsum * rsum;\\n            // update\\n            l.mod(cur, 1);\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889161,
                "title": "two-steps-match-array-bit-fenwick-explained",
                "content": "# TLDR\\nStep 1. Generate a matching array `int[] match` (code: `idxMapping2to1`) based on `nums2` and `nums1`. \\n\\nImagine lines between same values of `nums1` and `nums2`. \\n\\n![image.png](https://assets.leetcode.com/users/images/7a39837b-54ad-473e-9171-700798c980ca_1670467266.0337.png)\\n\\nStep 2. Sub problem -> finding increasing triplets on `int[] match` using BIT/Fenwick.\\n\\n# Idea\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is from : a good triplet will be a set `(x, y, z)` where` 0 <= x, y, z <= n - 1`, such that `pos1x < pos1y < pos1z` and `pos2x < pos2y < pos2z`.\\n\\nIt\\'s abstract from words, but look at the example\\n\\n`nums1 = [2,0,1,3], nums2 = [0,1,2,3]`\\n\\n`(0, 1, 3)` is  a good triplets. Why? relative postions of `0, 1, 3` in 2 arrays are same `left, middle, right`.\\n\\nIf enum indices from left to right based on `nums2`, it is naturally increasing on `nums2`. Same if based on `nums1`.\\n\\n<br/>\\n\\nIf based on `nums2`, how should find its corresponding position on `nums1`? \\n\\nStraightforward, draw lines between same values of `nums1` and `nums2`. \\n\\nSuppose we use `(2Idx, 1Idx)` to represent the same relationship, i.e., `nums2[2Idx] == nums1[1Idx]`. We can generate the match array by using `2Idx` as `idx`, using `1Idx` as value.\\n\\n![image.png](https://assets.leetcode.com/users/images/7a39837b-54ad-473e-9171-700798c980ca_1670467266.0337.png)\\n\\n\\nIf describle in word, for each index `i` in `int[] match`, we have `nums2[i] == nums1[match[i]]`. A little bit abstract.\\n\\n\\n---\\nNow the problem becomes finding increasing triplets  `(x, y, z)` in `int[] match`.  Note `(x,y,z)` are values instead of indices since indices already increasing naturally. \\n\\n<br/>\\n\\nBefore jumping into BIT/Fenwick, the intuition is 3-layers nested for loop to find. But that is too naitive.\\n\\nHere is a possible way:\\n+ Enum `y`, then find left count `x` * right count `z`\\n\\nHere comes the idea of **rangeSum with frequencies**. When iterating from left to right, to efficiently get left count `x`, we could use **segment tree** or **BIT/Fenwick** to get `rangeSum(0, y - 1)`. \\n\\nSame idea from right to left to find right `z` but note `rangeSum(n) - rangeSum(y)` to get right `z` count.\\n\\n\\nThere is another way for BIT/Fenwick\\n+ Enum `z`, then find count of `(x, y)`. I am using this one, see [post](https://leetcode.com/problems/count-good-triplets-in-an-array/solutions/1783180/python-2-fenwick-trees-solution-explained/). It is an excellent idea and I spent 1 hour to undertand.\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    class BIT {\\n        long[] arr;\\n        public BIT(int n) {\\n            this.arr = new long[n + 1];\\n        }\\n\\n        public void update(int idx, long x) {\\n            idx++;\\n            while (idx < this.arr.length) {\\n                arr[idx] += x;\\n                idx += lowbit(idx);\\n            }\\n        }\\n        // get the prefix sum of [0, idx]\\n        public long query(int idx) {\\n            // idx++;\\n            long result = 0L;\\n            while (idx > 0) {\\n                result += arr[idx];\\n                idx -= lowbit(idx);\\n            }\\n            return result;\\n        }\\n\\n\\n        public int lowbit(int x) {\\n            return x & (-x);\\n        }\\n    }\\n\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        // use fenwick tree, the value is idx,traverse from smaller to larger, so we can find the small ones\\n        int n = nums1.length;\\n\\n        int[] valueToIdx1 = new int[n];\\n        for (int i = 0; i < n; i++) valueToIdx1[nums1[i]] = i;\\n        int[] idxMapping2to1 = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int v2 = nums2[i];\\n            int idx1 = valueToIdx1[v2];\\n            idxMapping2to1[i] = idx1;\\n        }\\n\\n        long ret = 0L;\\n        BIT B1 = new BIT(n); // B1[i] store that value appears or not\\n        BIT B2 = new BIT(n); // B2[i] store the number of values smaller than i appear\\n\\n        for (int idx : idxMapping2to1) {\\n            ret += B2.query(idx);\\n            B1.update(idx, 1);\\n            long lesserCnt = B1.query(idx);\\n            B2.update(idx, lesserCnt);\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution {\\n    class BIT {\\n        long[] arr;\\n        public BIT(int n) {\\n            this.arr = new long[n + 1];\\n        }\\n\\n        public void update(int idx, long x) {\\n            idx++;\\n            while (idx < this.arr.length) {\\n                arr[idx] += x;\\n                idx += lowbit(idx);\\n            }\\n        }\\n        // get the prefix sum of [0, idx]\\n        public long query(int idx) {\\n            // idx++;\\n            long result = 0L;\\n            while (idx > 0) {\\n                result += arr[idx];\\n                idx -= lowbit(idx);\\n            }\\n            return result;\\n        }\\n\\n\\n        public int lowbit(int x) {\\n            return x & (-x);\\n        }\\n    }\\n\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        // use fenwick tree, the value is idx,traverse from smaller to larger, so we can find the small ones\\n        int n = nums1.length;\\n\\n        int[] valueToIdx1 = new int[n];\\n        for (int i = 0; i < n; i++) valueToIdx1[nums1[i]] = i;\\n        int[] idxMapping2to1 = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int v2 = nums2[i];\\n            int idx1 = valueToIdx1[v2];\\n            idxMapping2to1[i] = idx1;\\n        }\\n\\n        long ret = 0L;\\n        BIT B1 = new BIT(n); // B1[i] store that value appears or not\\n        BIT B2 = new BIT(n); // B2[i] store the number of values smaller than i appear\\n\\n        for (int idx : idxMapping2to1) {\\n            ret += B2.query(idx);\\n            B1.update(idx, 1);\\n            long lesserCnt = B1.query(idx);\\n            B2.update(idx, lesserCnt);\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872551,
                "title": "c-bit-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    constexpr int static len = 100000;\\n    int bit[len+1]{};\\n\\n    int getSum(int i) {\\n        int res = 0;\\n        for(i = i+1; i > 0; i -= i&(-i)) res += bit[i];\\n        return res;\\n    }\\n\\n    void add(int i, int v) {\\n        for(i = i+1; i <= len; i += i&(-i)) bit[i] += v;\\n    }\\n\\n    ll goodTriplets(vector<int>& A, vector<int>& B) {\\n        ll res = 0, N = A.size();\\n        vector<int> idx_remap(N);\\n        for(int i = 0; i < N; i++) idx_remap[B[i]] = i;\\n        for(int i = 0; i < N; i++) {\\n            int idx = idx_remap[A[i]];\\n            ll left = getSum(idx), right = N-1-idx-(i-left);\\n            res += left*right;\\n            add(idx, 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    constexpr int static len = 100000;\\n    int bit[len+1]{};\\n\\n    int getSum(int i) {\\n        int res = 0;\\n        for(i = i+1; i > 0; i -= i&(-i)) res += bit[i];\\n        return res;\\n    }\\n\\n    void add(int i, int v) {\\n        for(i = i+1; i <= len; i += i&(-i)) bit[i] += v;\\n    }\\n\\n    ll goodTriplets(vector<int>& A, vector<int>& B) {\\n        ll res = 0, N = A.size();\\n        vector<int> idx_remap(N);\\n        for(int i = 0; i < N; i++) idx_remap[B[i]] = i;\\n        for(int i = 0; i < N; i++) {\\n            int idx = idx_remap[A[i]];\\n            ll left = getSum(idx), right = N-1-idx-(i-left);\\n            res += left*right;\\n            add(idx, 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363782,
                "title": "2-segment-tree-c",
                "content": "```\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    long long Q(vector<long long> &seg,int ind,int sl,int sr,int al,int ar){\\n        if(al>ar)return 0;\\n        if(al==sl and ar==sr)return seg[ind];\\n        int mid=(sl+sr)/2;\\n        long long left=Q(seg,2*ind,sl,mid,al,min(ar,mid));\\n        long long right=Q(seg,2*ind+1,mid+1,sr,max(al,mid+1),ar);\\n        return left+right;\\n    }\\n    \\n    void Update(vector<long long> &seg,int ind,int sl,int sr,int aind,int val){\\n        if(sl==sr){\\n            seg[ind]=val;\\n            return;\\n        }\\n        int mid=(sl+sr)/2;\\n        if(aind<=mid)Update(seg,2*ind,sl,mid,aind,val);\\n        else Update(seg,2*ind+1,mid+1,sr,aind,val);\\n        seg[ind]=seg[2*ind]+seg[2*ind+1];\\n    }\\n    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)mp[nums1[i]]=i;\\n        for(int i=0;i<n;i++)nums2[i]=mp[nums2[i]];\\n        long long ans=0;\\n        vector<long long> seg(4*n,0),pre(4*n,0);\\n        for(int i=n-1;i>=0;i--){\\n            int tot=Q(seg,1,0,n-1,nums2[i],n-1);\\n            ans+=Q(pre,1,0,n-1,nums2[i],n-1);\\n            Update(seg,1,0,n-1,nums2[i],1);\\n            Update(pre,1,0,n-1,nums2[i],tot);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    long long Q(vector<long long> &seg,int ind,int sl,int sr,int al,int ar){\\n        if(al>ar)return 0;\\n        if(al==sl and ar==sr)return seg[ind];\\n        int mid=(sl+sr)/2;\\n        long long left=Q(seg,2*ind,sl,mid,al,min(ar,mid));\\n        long long right=Q(seg,2*ind+1,mid+1,sr,max(al,mid+1),ar);\\n        return left+right;\\n    }\\n    \\n    void Update(vector<long long> &seg,int ind,int sl,int sr,int aind,int val){\\n        if(sl==sr){\\n            seg[ind]=val;\\n            return;\\n        }\\n        int mid=(sl+sr)/2;\\n        if(aind<=mid)Update(seg,2*ind,sl,mid,aind,val);\\n        else Update(seg,2*ind+1,mid+1,sr,aind,val);\\n        seg[ind]=seg[2*ind]+seg[2*ind+1];\\n    }\\n    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)mp[nums1[i]]=i;\\n        for(int i=0;i<n;i++)nums2[i]=mp[nums2[i]];\\n        long long ans=0;\\n        vector<long long> seg(4*n,0),pre(4*n,0);\\n        for(int i=n-1;i>=0;i--){\\n            int tot=Q(seg,1,0,n-1,nums2[i],n-1);\\n            ans+=Q(pre,1,0,n-1,nums2[i],n-1);\\n            Update(seg,1,0,n-1,nums2[i],1);\\n            Update(pre,1,0,n-1,nums2[i],tot);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075246,
                "title": "c-segment-tree-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>seg;\\n    \\n    void update(int ind, int low ,int high, int val)\\n    {\\n        if(low == high && low ==val)\\n        {\\n            seg[ind] = 1;\\n            return;\\n        }\\n        if(high<val || low> val)\\n        {\\n            return;\\n        }\\n        int mid = (low+high)/2;\\n        update(ind*2+1, low, mid, val);\\n        update(ind*2+2, mid+1, high, val);\\n        seg[ind] = seg[ind*2+1]+ seg[ind*2+2];\\n    }\\n    \\n    int query(int ind, int low, int high, int l, int r)\\n    {\\n        if(low>=l && high<=r)\\n        {\\n            return seg[ind];\\n        }\\n        if(high<l || low>r )\\n            return 0;\\n        int mid = (low+high)/2;\\n        return query(ind*2+1, low, mid, l, r) + query(ind*2+2, mid+1, high, l,r);\\n    }\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int  n = nums1.size();\\n         vector<int> map(n, 0);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            map[nums2[i]] = i;\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            nums2[map[nums1[i]]] = i;\\n            nums1[i] = i;\\n        }\\n          vector<int>b ;\\n        seg.resize(4*n,0);\\n        for(int i = 0;i<n;i++)\\n        {\\n           b.push_back(nums2[i]);\\n        }\\n        \\n        update(0,0,n-1, b[0]);\\n        long long ans  =0;\\n        for(int  i = 1;i<n-1;i++)\\n        {\\n            long long int small = query(0, 0, n-1, 0, b[i]-1);\\n            long long int bb = (n-1) - b[i];\\n            long long int bigg  = bb - (i - small);\\n            ans  += (small)*bigg;\\n            update(0,0, n-1, b[i]);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>seg;\\n    \\n    void update(int ind, int low ,int high, int val)\\n    {\\n        if(low == high && low ==val)\\n        {\\n            seg[ind] = 1;\\n            return;\\n        }\\n        if(high<val || low> val)\\n        {\\n            return;\\n        }\\n        int mid = (low+high)/2;\\n        update(ind*2+1, low, mid, val);\\n        update(ind*2+2, mid+1, high, val);\\n        seg[ind] = seg[ind*2+1]+ seg[ind*2+2];\\n    }\\n    \\n    int query(int ind, int low, int high, int l, int r)\\n    {\\n        if(low>=l && high<=r)\\n        {\\n            return seg[ind];\\n        }\\n        if(high<l || low>r )\\n            return 0;\\n        int mid = (low+high)/2;\\n        return query(ind*2+1, low, mid, l, r) + query(ind*2+2, mid+1, high, l,r);\\n    }\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int  n = nums1.size();\\n         vector<int> map(n, 0);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            map[nums2[i]] = i;\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            nums2[map[nums1[i]]] = i;\\n            nums1[i] = i;\\n        }\\n          vector<int>b ;\\n        seg.resize(4*n,0);\\n        for(int i = 0;i<n;i++)\\n        {\\n           b.push_back(nums2[i]);\\n        }\\n        \\n        update(0,0,n-1, b[0]);\\n        long long ans  =0;\\n        for(int  i = 1;i<n-1;i++)\\n        {\\n            long long int small = query(0, 0, n-1, 0, b[i]-1);\\n            long long int bb = (n-1) - b[i];\\n            long long int bigg  = bb - (i - small);\\n            ans  += (small)*bigg;\\n            update(0,0, n-1, b[i]);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843123,
                "title": "c-segment-tree-solution-with-detailed-explanation",
                "content": "We want to find the `x` as # of left elements of index both in and `nums1` and `nums2` come before `nums1[i]` and `y` as # of right elements of index both in `nums1` and `nums2` come after `nums1[i]`, so that # of good triplets of middle number is `nums1[i]` is `x*y`.\\n\\nWe first build `posIn2` as the index of `nums1[i]` in `nums2`. Then for computing each `x` for each `nums1[i]`, we can use segment tree. cuz its `update` and `query` are `O(logn)`.\\n* `query` can make us count # of elements that are before `nums1[i]` in `nums2` as `x` . Also, these elements come before `nums1[i]` in `nums1`. \\n* `update` is to record those elements that we have visited in `nums1` to `nums2`.\\n\\nWhen we traverse `nums1` from 0 to `n-1`, we compute # of elements that come before `nums1[i]` in `nums2` as `pre[i]`.\\nRight elenets of `nums1[i]` is in similar way: we traverse `nums1` from `n-1` to `0`, and counted as `suf[i]`.\\n\\nSo # of good triples of `nums1[i]` as middle elements are `pre[i]*suf[i]`.\\n \\n* time : `O(nlogn)`\\n* space: `O(n)`\\n```\\nclass TNode {\\npublic:\\n    TNode() {\\n        left = right = nullptr;\\n    }\\n    int start, end, val;\\n    TNode *left, *right;\\n};\\n\\nclass SegTree {\\npublic:\\n    TNode *root;\\n    SegTree(int start, int end) {\\n        root = buildTree(start, end);\\n    }\\n    TNode *buildTree(int start, int end) {\\n        TNode *now = new TNode();\\n        now->start = start, now->end = end;\\n        now->val = 0;\\n        if (start < end) {\\n            int mid = start + (end-start)/2;\\n            now->left = buildTree(start, mid);\\n            now->right = buildTree(mid+1, end);\\n        }\\n        return now;\\n    }\\n    int update(TNode *root, int idx, int val) {\\n        int diff;\\n        if (root->start == idx && root->end == idx) {\\n            diff = root->val-val;\\n            root->val = val;\\n        } else {\\n            int mid = root->start + (root->end-root->start)/2;\\n            if (mid < idx) {\\n                diff = update(root->right, idx, val);\\n            } else {\\n                diff = update(root->left, idx, val);\\n            }\\n            root->val -= diff;\\n        }\\n        return diff;\\n    }\\n    void update(int idx, int val) {\\n        update(root, idx, val);\\n    }\\n    int query(TNode *root, int start, int end) {\\n        if (root->start == start && root->end == end) {\\n            return root->val;\\n        } else {\\n            int mid = root->start + (root->end-root->start)/2;\\n            if (mid < start) {\\n                return query(root->right, start, end);\\n            } else if (end <= mid) {\\n                return query(root->left, start, end);\\n            } else {\\n                return query(root->left, start, mid) + query(root->right, mid+1, end);\\n            }\\n        }\\n    }\\n    int query(int start, int end) {\\n        return query(root, start, end);\\n    }\\n};\\n    \\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> posIn2(n);\\n        for (int i = 0; i < n; ++i) {\\n            posIn2[nums2[i]] = i;\\n        }\\n        SegTree *seg1 = new SegTree(0, n-1), *seg2 = new SegTree(0, n-1);\\n        vector<int> pre, suf;\\n        for (int i = 0; i < n; ++i) {\\n            int pos = posIn2[nums1[i]];\\n            pre.push_back(seg1->query(0, pos));  \\n            seg1->update(pos, 1);\\n        }\\n        for (int i = n-1; i >= 0; --i) {\\n            int pos = posIn2[nums1[i]];\\n            suf.push_back(seg2->query(pos, n-1));\\n            seg2->update(pos, 1);\\n        }\\n        reverse(suf.begin(), suf.end());\\n        ll res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            res += (ll)pre[i]*suf[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TNode {\\npublic:\\n    TNode() {\\n        left = right = nullptr;\\n    }\\n    int start, end, val;\\n    TNode *left, *right;\\n};\\n\\nclass SegTree {\\npublic:\\n    TNode *root;\\n    SegTree(int start, int end) {\\n        root = buildTree(start, end);\\n    }\\n    TNode *buildTree(int start, int end) {\\n        TNode *now = new TNode();\\n        now->start = start, now->end = end;\\n        now->val = 0;\\n        if (start < end) {\\n            int mid = start + (end-start)/2;\\n            now->left = buildTree(start, mid);\\n            now->right = buildTree(mid+1, end);\\n        }\\n        return now;\\n    }\\n    int update(TNode *root, int idx, int val) {\\n        int diff;\\n        if (root->start == idx && root->end == idx) {\\n            diff = root->val-val;\\n            root->val = val;\\n        } else {\\n            int mid = root->start + (root->end-root->start)/2;\\n            if (mid < idx) {\\n                diff = update(root->right, idx, val);\\n            } else {\\n                diff = update(root->left, idx, val);\\n            }\\n            root->val -= diff;\\n        }\\n        return diff;\\n    }\\n    void update(int idx, int val) {\\n        update(root, idx, val);\\n    }\\n    int query(TNode *root, int start, int end) {\\n        if (root->start == start && root->end == end) {\\n            return root->val;\\n        } else {\\n            int mid = root->start + (root->end-root->start)/2;\\n            if (mid < start) {\\n                return query(root->right, start, end);\\n            } else if (end <= mid) {\\n                return query(root->left, start, end);\\n            } else {\\n                return query(root->left, start, mid) + query(root->right, mid+1, end);\\n            }\\n        }\\n    }\\n    int query(int start, int end) {\\n        return query(root, start, end);\\n    }\\n};\\n    \\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> posIn2(n);\\n        for (int i = 0; i < n; ++i) {\\n            posIn2[nums2[i]] = i;\\n        }\\n        SegTree *seg1 = new SegTree(0, n-1), *seg2 = new SegTree(0, n-1);\\n        vector<int> pre, suf;\\n        for (int i = 0; i < n; ++i) {\\n            int pos = posIn2[nums1[i]];\\n            pre.push_back(seg1->query(0, pos));  \\n            seg1->update(pos, 1);\\n        }\\n        for (int i = n-1; i >= 0; --i) {\\n            int pos = posIn2[nums1[i]];\\n            suf.push_back(seg2->query(pos, n-1));\\n            seg2->update(pos, 1);\\n        }\\n        reverse(suf.begin(), suf.end());\\n        ll res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            res += (ll)pre[i]*suf[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816460,
                "title": "c-solution-using-fenwick-tree-similar-to-1395",
                "content": "```\\nclass Solution {\\npublic:\\n    int N=1e5+10;\\n    void update(int i,int val,vector<int>&bit)\\n    {\\n        while(i<N)\\n        {\\n            bit[i]+=val;\\n            i+=(i&-i);\\n        }\\n    }\\n    int find(int i,vector<int>&bit)\\n    {\\n        int sum=0;\\n        while(i>0)\\n        {\\n            sum+=bit[i];\\n            i-=(i&-i);\\n        }\\n        return sum;\\n    }\\n    int find_(int i,vector<int>&bit)\\n    {\\n        int sum=0;\\n        while(i>0)\\n        {\\n            sum+=bit[i];\\n            i-=(i&-i);\\n        }\\n        return sum;\\n    }\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int n=nums1.size();\\n        vector<int>bitl(N),bitr(N);\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums1[i]]=i+1;\\n        }\\n        vector<int>nums(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=mp[nums2[i]];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            update(nums[i],1,bitr);\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            update(nums[i],-1,bitr);\\n            int left=find(nums[i]-1,bitl);\\n            int right=find_(N-1,bitr)-find_(nums[i],bitr);\\n            ans+=(1ll*left*right);\\n            update(nums[i],1,bitl);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int N=1e5+10;\\n    void update(int i,int val,vector<int>&bit)\\n    {\\n        while(i<N)\\n        {\\n            bit[i]+=val;\\n            i+=(i&-i);\\n        }\\n    }\\n    int find(int i,vector<int>&bit)\\n    {\\n        int sum=0;\\n        while(i>0)\\n        {\\n            sum+=bit[i];\\n            i-=(i&-i);\\n        }\\n        return sum;\\n    }\\n    int find_(int i,vector<int>&bit)\\n    {\\n        int sum=0;\\n        while(i>0)\\n        {\\n            sum+=bit[i];\\n            i-=(i&-i);\\n        }\\n        return sum;\\n    }\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int n=nums1.size();\\n        vector<int>bitl(N),bitr(N);\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums1[i]]=i+1;\\n        }\\n        vector<int>nums(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=mp[nums2[i]];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            update(nums[i],1,bitr);\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            update(nums[i],-1,bitr);\\n            int left=find(nums[i]-1,bitl);\\n            int right=find_(N-1,bitr)-find_(nums[i],bitr);\\n            ans+=(1ll*left*right);\\n            update(nums[i],1,bitl);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809922,
                "title": "java-mergesort-and-counting-solution",
                "content": "**MergeSort and count solution**\\n\\nBasic idea is to apply standard merge sort algorithm.\\n\\nFirstly we build new array index which represents positions of values from nums1 array in the nums2 array.\\n\\nThen we apply mergesort to that array and whenever we move elements from right part to left and vice versa we keep counting how many elements are there to the left that are less than the element and to the right that are greater\\n\\n```\\nclass Solution {\\n    int[] less;\\n    int[] greater;\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int[] map = new int[n]; // map from nums2 to index\\n        for(int i = 0; i < n; i++) {\\n            map[nums2[i]] = i;\\n        }\\n        int[] index = new int[n]; // index array representing positions of nums1 values in nums2\\n        for(int i = 0; i < n; i++) {\\n            index[i] = map[nums1[i]];\\n        }        \\n        less = new int[n];\\n        greater = new int[n];\\n        mergesort(index, 0, index.length);\\n        long answer = 0L;\\n        for(int i = 0; i < n; i++) {            \\n            answer += 1L * less[i] * greater[i];\\n        }\\n        return answer;\\n    }\\n    void mergesort(int[] arr, int lo, int hi) {\\n        if(lo + 1 >= hi) {\\n            return;\\n        }\\n        int n = arr.length;\\n        int mid = lo + (hi - lo) / 2;\\n        mergesort(arr, lo, mid);\\n        mergesort(arr, mid, hi);\\n        merge(arr, lo, mid, hi);\\n    }\\n    void merge(int[] arr, int lo, int mid, int hi) {\\n        int n = hi - lo;\\n        int[] tmp = new int[n];\\n        int id = 0;\\n        int i = lo, j = mid;\\n        while(i < mid && j < hi) {\\n            if(arr[i] < arr[j]) {\\n                tmp[id] = arr[i];\\n                greater[arr[i]] += (hi - j);\\n                i++;\\n            } else if(arr[i] > arr[j]) {\\n                tmp[id] = arr[j];\\n                less[arr[j]] += (i - lo);\\n                j++;\\n            }\\n            id++;\\n        }\\n        while(i < mid) {\\n            tmp[id] = arr[i];\\n            i++;\\n            id++;\\n        }\\n        while(j < hi) {\\n            tmp[id] = arr[j];\\n            less[arr[j]] += (i - lo);\\n            j++;\\n            id++;\\n        }\\n        System.arraycopy(tmp, 0, arr, lo, n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    int[] less;\\n    int[] greater;\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int[] map = new int[n]; // map from nums2 to index\\n        for(int i = 0; i < n; i++) {\\n            map[nums2[i]] = i;\\n        }\\n        int[] index = new int[n]; // index array representing positions of nums1 values in nums2\\n        for(int i = 0; i < n; i++) {\\n            index[i] = map[nums1[i]];\\n        }        \\n        less = new int[n];\\n        greater = new int[n];\\n        mergesort(index, 0, index.length);\\n        long answer = 0L;\\n        for(int i = 0; i < n; i++) {            \\n            answer += 1L * less[i] * greater[i];\\n        }\\n        return answer;\\n    }\\n    void mergesort(int[] arr, int lo, int hi) {\\n        if(lo + 1 >= hi) {\\n            return;\\n        }\\n        int n = arr.length;\\n        int mid = lo + (hi - lo) / 2;\\n        mergesort(arr, lo, mid);\\n        mergesort(arr, mid, hi);\\n        merge(arr, lo, mid, hi);\\n    }\\n    void merge(int[] arr, int lo, int mid, int hi) {\\n        int n = hi - lo;\\n        int[] tmp = new int[n];\\n        int id = 0;\\n        int i = lo, j = mid;\\n        while(i < mid && j < hi) {\\n            if(arr[i] < arr[j]) {\\n                tmp[id] = arr[i];\\n                greater[arr[i]] += (hi - j);\\n                i++;\\n            } else if(arr[i] > arr[j]) {\\n                tmp[id] = arr[j];\\n                less[arr[j]] += (i - lo);\\n                j++;\\n            }\\n            id++;\\n        }\\n        while(i < mid) {\\n            tmp[id] = arr[i];\\n            i++;\\n            id++;\\n        }\\n        while(j < hi) {\\n            tmp[id] = arr[j];\\n            less[arr[j]] += (i - lo);\\n            j++;\\n            id++;\\n        }\\n        System.arraycopy(tmp, 0, arr, lo, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797170,
                "title": "segment-tree-vs-square-root-decomposition-vs-two-heaps-vs-square-root-decomposition-insert-sort",
                "content": "I tried variety of query data-structure.\\n\\nSegment-tree passed. (best)\\nSquare-root decomposition with insertion-sort passed.\\n\\nThe segment-tree structure has `append` of O(log N) while square-root decomposition excel there with O(1) cost.\\nOn the contrary `countSmaller` operation is O(log N) in case of segment-tree, while it is O( sqrt(N) ) in case of square-root decomposition . \\nAdding Insertion-sort to square-root decomposition is taking advantage of memory hierarchy and allowing the insertion-sort to happen in cache I guess. \\n\\n```python\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        N = len(nums1)\\n           \\n        loc1 = [0]*N\\n        for i,x in enumerate(nums1):\\n            loc1[x] = i\\n        \\n        result = 0\\n        #memo = SQRTDecomp(N)                    # TLE\\n        #memo = SQRTDecompPlusHeap(N)    # TLE\\n        #memo = SQRTDecompPlusInsort(N)    # pass\\n        #memo = TwoHeaps(N)                          # TLE\\n        memo = SegmentTree(N)                       # pass (best)\\n        for i,x in enumerate(nums2):\\n            j = loc1[x]\\n            # count number of elements appeared before i,j\\n            # there are i elements on the left\\n            # there are some elements that are skipped\\n            smaller = memo.countSmaller(j)\\n            skipped = i+j-2*smaller\\n            greater = N-skipped-1-smaller\\n            result += smaller*greater\\n            \\n            # update memo\\n            memo.append(j)\\n            \\n        return result\\n```\\n\\n#### Segment tree approach\\n\\nThis solution is accepted .\\n\\n```python\\nclass SegmentTree:\\n    \\'\\'\\'\\n    segment_tree.py file is part of Algosnippet.\\n    Algosnippet is a collection of practice data-structures and algorithms\\n    Copyright (C) 2020  Kamanashis Roy\\n    You should have received a copy of the GNU General Public License\\n    along with Algosnippet.  If not, see <https://www.gnu.org/licenses/>.\\n    \\'\\'\\'\\n       def __init__(self, N:int):\\n        depth = 0\\n        while (1<<depth) < N:\\n            depth += 1\\n\\n        N = 1<<depth\\n        self.nodes = [ 0 for _ in range((N<<1)+2)]\\n        self.N = N\\n        # N = 4\\n        # [ filler 0 ] [ root Node 1 ] 2 3 [ Internal nodes 4 5 6 7 ] [ Leaves 8 9 10 11 12 13 14 15 ]\\n\\n    def append(self, i:int) -> None:\\n        curr = self.N+i\\n        self.nodes[curr] += 1\\n        while curr > 1:\\n            # get parent\\n            parent = curr >> 1\\n            self.nodes[parent] += 1\\n            curr = parent\\n\\n    def countSmaller(self, limit:int) -> int:\\n        if 0 == limit:\\n            return 0\\n        curr = self.N+limit-1\\n        deduct = 0\\n        while curr > 1: # bottom up\\n            if curr&1 == 0: # in case even, deduct odd\\n                deduct += self.nodes[curr+1]\\n            parent = curr >> 1\\n            curr = parent\\n        return self.nodes[1] - deduct # deduct from root node\\n```\\n\\n#### Two heap approach\\n\\nGetting TLE. The insert is O(log N) , but counting is O(N log N) .\\n\\n```python\\nclass TwoHeaps:\\n    def __init__(self, N:int=0):\\n        # every element has K elements\\n        self.left = []\\n        self.right = []\\n \\n    def append(self, i:int) -> None:\\n        if self.left and -self.left[0] < i:\\n            heappush(self.left,-i)\\n        else:\\n            heappush(self.right,i)\\n        \\n    def countSmaller(self, limit:int) -> int:\\n        \\n        while self.right and self.right[0] < limit:\\n            x = heappop(self.right)\\n            heappush(self.left, -x)\\n        \\n        while self.left and -self.left[0] > limit:\\n            x = heappop(self.left)\\n            heappush(self.right, -x)\\n            \\n        return len(self.left)\\n    \\n    def __len__(self):\\n        return len(self.left) + len(self.right)\\n```\\n\\n#### Square Root Decomposition\\n\\nIt is getting TLE. Insert is O(1), but query is O(square-root(N)) .\\n\\n```python\\nclass SQRTDecomp:\\n    def __init__(self, N:int):\\n        RN = N>>1\\n        while RN*RN < N:\\n            RN += 1\\n        self.memo = [[] for _ in range(RN)]\\n        self.RN = RN\\n        \\n    def append(self, j:int) -> None:\\n        self.memo[j//self.RN].append(j)\\n        \\n    def countSmaller(self, limit:int) -> int:\\n        result = 0\\n        for k in range(limit//self.RN):\\n            result += len(self.memo[k])\\n\\n        for jj in self.memo[limit//self.RN]:\\n            if jj < limit:\\n                result += 1\\n        return result\\n```\\n\\n#### Square root decomposition Plus Insertion sort\\n\\nPass. We can insert in small bucket with reduced insertion cost and cache misses.\\n\\n```\\nclass SQRTDecompPlusInsort:\\n    def __init__(self, N:int):\\n        RN = N>>1\\n        while RN*RN < N:\\n            RN += 1\\n        self.memo = [[] for _ in range(RN)]\\n        self.RN = RN\\n        \\n    def append(self, j:int) -> None:\\n        insort(self.memo[j//self.RN],j)\\n        \\n    def countSmaller(self, limit:int) -> int:\\n        result = 0\\n        for k in range(limit//self.RN):\\n            result += len(self.memo[k])\\n            \\n        result += bisect_left(self.memo[limit//self.RN], limit)\\n        return result\\n```",
                "solutionTags": [
                    "Bucket Sort"
                ],
                "code": "```python\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        N = len(nums1)\\n           \\n        loc1 = [0]*N\\n        for i,x in enumerate(nums1):\\n            loc1[x] = i\\n        \\n        result = 0\\n        #memo = SQRTDecomp(N)                    # TLE\\n        #memo = SQRTDecompPlusHeap(N)    # TLE\\n        #memo = SQRTDecompPlusInsort(N)    # pass\\n        #memo = TwoHeaps(N)                          # TLE\\n        memo = SegmentTree(N)                       # pass (best)\\n        for i,x in enumerate(nums2):\\n            j = loc1[x]\\n            # count number of elements appeared before i,j\\n            # there are i elements on the left\\n            # there are some elements that are skipped\\n            smaller = memo.countSmaller(j)\\n            skipped = i+j-2*smaller\\n            greater = N-skipped-1-smaller\\n            result += smaller*greater\\n            \\n            # update memo\\n            memo.append(j)\\n            \\n        return result\\n```\n```python\\nclass SegmentTree:\\n    \\'\\'\\'\\n    segment_tree.py file is part of Algosnippet.\\n    Algosnippet is a collection of practice data-structures and algorithms\\n    Copyright (C) 2020  Kamanashis Roy\\n    You should have received a copy of the GNU General Public License\\n    along with Algosnippet.  If not, see <https://www.gnu.org/licenses/>.\\n    \\'\\'\\'\\n       def __init__(self, N:int):\\n        depth = 0\\n        while (1<<depth) < N:\\n            depth += 1\\n\\n        N = 1<<depth\\n        self.nodes = [ 0 for _ in range((N<<1)+2)]\\n        self.N = N\\n        # N = 4\\n        # [ filler 0 ] [ root Node 1 ] 2 3 [ Internal nodes 4 5 6 7 ] [ Leaves 8 9 10 11 12 13 14 15 ]\\n\\n    def append(self, i:int) -> None:\\n        curr = self.N+i\\n        self.nodes[curr] += 1\\n        while curr > 1:\\n            # get parent\\n            parent = curr >> 1\\n            self.nodes[parent] += 1\\n            curr = parent\\n\\n    def countSmaller(self, limit:int) -> int:\\n        if 0 == limit:\\n            return 0\\n        curr = self.N+limit-1\\n        deduct = 0\\n        while curr > 1: # bottom up\\n            if curr&1 == 0: # in case even, deduct odd\\n                deduct += self.nodes[curr+1]\\n            parent = curr >> 1\\n            curr = parent\\n        return self.nodes[1] - deduct # deduct from root node\\n```\n```python\\nclass TwoHeaps:\\n    def __init__(self, N:int=0):\\n        # every element has K elements\\n        self.left = []\\n        self.right = []\\n \\n    def append(self, i:int) -> None:\\n        if self.left and -self.left[0] < i:\\n            heappush(self.left,-i)\\n        else:\\n            heappush(self.right,i)\\n        \\n    def countSmaller(self, limit:int) -> int:\\n        \\n        while self.right and self.right[0] < limit:\\n            x = heappop(self.right)\\n            heappush(self.left, -x)\\n        \\n        while self.left and -self.left[0] > limit:\\n            x = heappop(self.left)\\n            heappush(self.right, -x)\\n            \\n        return len(self.left)\\n    \\n    def __len__(self):\\n        return len(self.left) + len(self.right)\\n```\n```python\\nclass SQRTDecomp:\\n    def __init__(self, N:int):\\n        RN = N>>1\\n        while RN*RN < N:\\n            RN += 1\\n        self.memo = [[] for _ in range(RN)]\\n        self.RN = RN\\n        \\n    def append(self, j:int) -> None:\\n        self.memo[j//self.RN].append(j)\\n        \\n    def countSmaller(self, limit:int) -> int:\\n        result = 0\\n        for k in range(limit//self.RN):\\n            result += len(self.memo[k])\\n\\n        for jj in self.memo[limit//self.RN]:\\n            if jj < limit:\\n                result += 1\\n        return result\\n```\n```\\nclass SQRTDecompPlusInsort:\\n    def __init__(self, N:int):\\n        RN = N>>1\\n        while RN*RN < N:\\n            RN += 1\\n        self.memo = [[] for _ in range(RN)]\\n        self.RN = RN\\n        \\n    def append(self, j:int) -> None:\\n        insort(self.memo[j//self.RN],j)\\n        \\n    def countSmaller(self, limit:int) -> int:\\n        result = 0\\n        for k in range(limit//self.RN):\\n            result += len(self.memo[k])\\n            \\n        result += bisect_left(self.memo[limit//self.RN], limit)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790646,
                "title": "how-does-sortedlist-really-work-is-it-really-a-balanced-bst",
                "content": "for a balanced BST, it has an additional property of max difference of any two leaves\\' depth are no greater than 1, in additiona to BST property itself, thus achieving range query in O(logn) and is mutable (allowing element add, del in O(logn) ).\\n\\nfrom [sortedcontainers.SortedList docs](https://grantjenks.com/docs/sortedcontainers/_modules/sortedcontainers/sortedlist.html#SortedList), it only says\\n```\\nSorted list is a sorted mutable sequence.\\n```\\n\\nIn the `add` function, it first find a sublist, then does `bisect.insort` on that sublist, which is claimed to be `O(logn)` in approx.  Correct me if wrong, it **seems** to me `SortedList` is more of an array of sorted sublists. It splits list into `n/(logn)` sublists, each of size `logn`. locating one sublist takes O(logn - loglogn). and insort on sublist takes O(logn), in total approx `O(logn)` as claimed.\\n\\ncould someone more knowledgable on this help explain how SortedList really works? and is it really a balanced BST or not? thanks.",
                "solutionTags": [],
                "code": "```\\nSorted list is a sorted mutable sequence.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1790600,
                "title": "pbds-ordered-set-explained-logic-why-actually-are-we-using-it",
                "content": "**How I reached at this Logic? :** Whenever problem statement states to find triplet, try to think using middle element (centre element). In most of the cases it works and same happened here. \\n**Logic  :**\\n* Fix middle element of the triplet. Let suppose if `ith` element of `nums1` is centre element of our required triplet(say` k`). \\n* Find the position of `k` in nums2. Say it is present on `jth` index. \\n* Number of common elements in `nums1`  from index `0 to i` and in nums2 from` 0 to j`. Store the count in `pref[i]`.\\n* Similarly number of common elements in nums1 from` i + 1` to` n `and in `nums2` from `j + 1` to `n`. Store the count in s`uff[i]`.\\n* Iterate over` i `and keep adding product of `pref[i] * suff[i] `into your `ans`.\\n\\n**Why Ordered Set? :** Now for finding common element if use `vector` or `set` we will end up doing this thing in `O(n)`. And doing this for each index will result in overall time complexity of `O(n^2)`.\\n\\n# *But how exactly?*\\n\\nSome might be thinking why can\\'t we use binary search `O(log n) `to find element smaller than `k`. Yes, you are thinking in right way but for doing so we need maintain sorted vector and it will take `O(n) `time (`Insert x in vector, keeping the vector sorted)` so for each index we will end up in `O(n)` complexity. As discussed it is not acceptable. \\n\\nSimilarly some will say we had problem keeping vector sorted,  we can use `set` it does that work in `O(log n)`. But but . . . we can\\'t use binary search in sets. Oopss. We will end up using `O(n)` for finding common elements.\\n\\nTo solve our problem we have with us Policy based data structure. That will do both of the required operations in `O(log n)` time.\\n\\n**Usage:**\\nAs `pbds` is not available in standard Library, we have to include it explicitly.\\n```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\n\\nusing namespace __gnu_pbds;\\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds; // find_by_order, order_of_key\\n```\\nExplaing this on array A = [3,5,2,1,1,2]\\n`less<int>` here specifies we need to keep our elements(`unique`) sorted in ascending order. `A = [1, 2, 3, 5]`\\n**Extra Stuff** \\n1. if we write `greater<int>` it will keep our  elements sorted(`unique`) in descending order. `A = [5, 3, 2, 1]`\\n2. if we write `less_equal<int>` it will keep our elements sorted in ascending order, only difference here is we can have same elements n number of times(`repetitive`). It will start acting like a `multiset`. `A = [1, 1, 2, 2, 3, 5]`\\n\\nYou can play along with this..\\n\\n\\n**Implementation**\\n```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\n\\nusing namespace __gnu_pbds;\\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds; // find_by_order, order_of_key\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        pbds s;//ordered set\\n        \\n        int n = nums1.size();\\n        vector<int> pos(n);\\n        for(int i=0;i<n;i++){\\n            pos[nums2[i]] = i;\\n        }\\n        \\n        vector<int> pref(n), suff(n);\\n        for(int i=0;i<n;i++){\\n            pref[i] = s.order_of_key(pos[nums1[i]]);\\n            s.insert(pos[nums1[i]]);\\n        }\\n        s.clear();\\n        for(int i=n-1;i>=0;i--){\\n            suff[i] = s.size() - s.order_of_key(pos[nums1[i]]);\\n            s.insert(pos[nums1[i]]);\\n        }\\n        \\n        long long ans = 0;\\n        for(int i=0;i<n;i++){\\n            ans += pref[i] * 1LL * suff[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Time Complexity** `O(nlogn)`\\n\\n**Hope it make sense! Do upvote if you find it useful**",
                "solutionTags": [],
                "code": "```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\n\\nusing namespace __gnu_pbds;\\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds; // find_by_order, order_of_key\\n```\n```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\n\\nusing namespace __gnu_pbds;\\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds; // find_by_order, order_of_key\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        pbds s;//ordered set\\n        \\n        int n = nums1.size();\\n        vector<int> pos(n);\\n        for(int i=0;i<n;i++){\\n            pos[nums2[i]] = i;\\n        }\\n        \\n        vector<int> pref(n), suff(n);\\n        for(int i=0;i<n;i++){\\n            pref[i] = s.order_of_key(pos[nums1[i]]);\\n            s.insert(pos[nums1[i]]);\\n        }\\n        s.clear();\\n        for(int i=n-1;i>=0;i--){\\n            suff[i] = s.size() - s.order_of_key(pos[nums1[i]]);\\n            s.insert(pos[nums1[i]]);\\n        }\\n        \\n        long long ans = 0;\\n        for(int i=0;i<n;i++){\\n            ans += pref[i] * 1LL * suff[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1788021,
                "title": "java-clean-solution-bit-fenwick-tree",
                "content": "First calculate the index of ```num1```\\'s element in ```num2``` array (Note num1 and num2 are interchangeable)\\n\\n```\\nnums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]\\n\\nidx = [2,1,3,4,0] //idx[nums2[i]] = i; map of element in num2 to its index in num2\\narr = [0,2,1,4,3] //arr[i] = idx[nums1[i]]; map of element in num1 to its index in num2\\n```\\nIn this way, for each element x in ```arr```, we just need to count the number of elements smaller than x and on its left, and the number of elements bigger than x on its right, and multiple them together to get the result.\\n\\n**Why?**\\neach element i on x\\'s left is a choice of the first element in our triplet (i, x, j)\\neach element j on x\\'s right is a choice of the last element in our triplet (i, x, j)\\n\\nand we need to ensure the its relative order using the ```arr```\\n\\n**To reduce time complexity:**\\nwe use BIT to calculate the number of elements on the left and right\\n\\nnumber of elements smaller than x and on its left -> ```tree.query(arr[i]);```\\nnumber of elements bigger than x on its right -> ```n - (1 + arr[i]) - (i - smaller);``` -> Total - (all left elements, including x itself) - (number of elements on x\\'s left that is actually bigger than x)\\n```\\nclass Solution {\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int[] idx = new int[n], arr = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            idx[nums2[i]] = i;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            arr[i] = idx[nums1[i]];\\n        }\\n        \\n        Tree tree = new Tree(n);\\n        long res = 0l;\\n        for (int i = 0; i < n; i++) {\\n            int smaller = tree.query(arr[i]);\\n            int bigger = n - (arr[i] + 1) - (i - smaller);\\n            res += 1l * smaller * bigger;\\n            tree.update(arr[i] + 1, 1);\\n        }\\n        return res;\\n    }\\n    \\n    private static class Tree {\\n        int[] BIT;\\n        int n;\\n\\n        public Tree(int n) {\\n            this.n = n;\\n            BIT = new int[n + 1]; \\n        }\\n\\n        int lowbit(int x) {\\n            return x & (-x);\\n        }\\n\\n        void update(int i, int delta) {\\n            while (i <= n) {\\n                BIT[i] += delta;\\n                i += lowbit(i);\\n            }\\n        }\\n\\n        int query(int k) {\\n            int ans = 0;\\n            while (k > 0) {\\n                ans += BIT[k];\\n                k -= lowbit(k);\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Indexed Tree"
                ],
                "code": "```num1```\n```num2```\n```\\nnums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]\\n\\nidx = [2,1,3,4,0] //idx[nums2[i]] = i; map of element in num2 to its index in num2\\narr = [0,2,1,4,3] //arr[i] = idx[nums1[i]]; map of element in num1 to its index in num2\\n```\n```arr```\n```arr```\n```tree.query(arr[i]);```\n```n - (1 + arr[i]) - (i - smaller);```\n```\\nclass Solution {\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int[] idx = new int[n], arr = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            idx[nums2[i]] = i;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            arr[i] = idx[nums1[i]];\\n        }\\n        \\n        Tree tree = new Tree(n);\\n        long res = 0l;\\n        for (int i = 0; i < n; i++) {\\n            int smaller = tree.query(arr[i]);\\n            int bigger = n - (arr[i] + 1) - (i - smaller);\\n            res += 1l * smaller * bigger;\\n            tree.update(arr[i] + 1, 1);\\n        }\\n        return res;\\n    }\\n    \\n    private static class Tree {\\n        int[] BIT;\\n        int n;\\n\\n        public Tree(int n) {\\n            this.n = n;\\n            BIT = new int[n + 1]; \\n        }\\n\\n        int lowbit(int x) {\\n            return x & (-x);\\n        }\\n\\n        void update(int i, int delta) {\\n            while (i <= n) {\\n                BIT[i] += delta;\\n                i += lowbit(i);\\n            }\\n        }\\n\\n        int query(int k) {\\n            int ans = 0;\\n            while (k > 0) {\\n                ans += BIT[k];\\n                k -= lowbit(k);\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787608,
                "title": "python-time-100-faster-easy-to-understand",
                "content": "The approach here is to find one list so that we avoid repeated comparisons on 2 lists at a same time. Instead we can compare just a single list. So, I have made the first list as reference list by assigning them numbers in the order they are arranged. Using the same assignment mapping, I have created a new list using the second given list.\\nFor example, [4,0,1,3,2] and [4,1,0,2,3]\\nTaking the first list of numbers and using this mapping given in following dictionary {4:0,0:1,1:2,3:3,2:4} to create the new list. The new list would look like [0,2,1,4,3] \\nNow the inputs looks like [0,1,2,3,4] and [0,2,1,4,3]. We only have to think about the second list and find prefixes and suffixes now.\\n\\nNow to calculate suffix and prefix, check the below explanation -\\n\\nTo find the prefix, we can use a sortedSet, it will keep all the elements that we add in sorted order, so the index at which the element is present in sortedSet would give the count of prefix.\\n\\nFor an array with n numbers from 0 to n-1, \\nTotal number of suffix for any element would be (n-1-element)\\nTotal number of prefix for any element would be (element)\\n\\nSay, an array [0,2,1,4,3]  is given, \\nThen total suffix for element 2 would be 3,4, i.e. total count is 2. Using the formula (n-1-element)=(5-1-2)=2, the result is same.\\nSimilarly prefix are 0 and 1 and using formula it should be equal to 2 which is correct.\\n\\nUsing the formulas for total suffix and total prefix, I have calculated a formula for all the suffixes that are present after the given element, so the formula should be (n-1-element-index_of_element_in_array+prefix_present_before_element)\\n\\nSo here in the above example, the prefix_present_before_element should be 1 for element 2, as only element 0 which is prefix of 2 is present before 2. Index of element 2 will be 1, so answer we get using these values is (5-1-2-1+1)=2. Thus this implies that only two suffixes,i.e., 3 and 4 are present after 2 in the list.\\n\\nAt last, total count of good triplets would be multiplication of prefix and suffix which is returned in a variable named result in the code.\\n\\n```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def goodTriplets(self, nums1, nums2):\\n        n=len(nums1)\\n        mainDict={}\\n        for i in range(n):\\n            mainDict[nums1[i]]=i\\n        lst=[]\\n        freqDict={}\\n        for i in range(n):\\n            lst.append(mainDict[nums2[i]])\\n            freqDict[mainDict[nums2[i]]]=i\\n        #print(freqDict)\\n        tempSet=SortedSet()\\n        result=0\\n        for i in range(n):\\n            tempSet.add(lst[i])\\n            pref=tempSet.index(lst[i])\\n            result+=(pref)*(n-1-freqDict[lst[i]]-lst[i]+pref)\\n        return result\\n```",
                "solutionTags": [
                    "Suffix Array"
                ],
                "code": "```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def goodTriplets(self, nums1, nums2):\\n        n=len(nums1)\\n        mainDict={}\\n        for i in range(n):\\n            mainDict[nums1[i]]=i\\n        lst=[]\\n        freqDict={}\\n        for i in range(n):\\n            lst.append(mainDict[nums2[i]])\\n            freqDict[mainDict[nums2[i]]]=i\\n        #print(freqDict)\\n        tempSet=SortedSet()\\n        result=0\\n        for i in range(n):\\n            tempSet.add(lst[i])\\n            pref=tempSet.index(lst[i])\\n            result+=(pref)*(n-1-freqDict[lst[i]]-lst[i]+pref)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785236,
                "title": "two-bisect-nlog-n-very-short-solution",
                "content": "```\\nimport bisect\\n\\ndef get(nums1, nums2, n):\\n    dic = {}\\n    for i in range(n):\\n        dic[nums2[i]] = i\\n    positions, s1 = [], []\\n    for i in range(n):\\n        # Find the position of nums1[i] in nums2, update the sorted positions\\n        s1.append(bisect.bisect_left(positions, dic[nums1[i]]))\\n        # Find the number of smaller index\\n        bisect.insort_right(positions, dic[nums1[i]])\\n    return s1\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1 = get(nums1, nums2, n = len(nums1)) # From start to the mid \\n        s2 = get(nums1[::-1], nums2[::-1], n = len(nums1))[::-1] # From end to the mid\\n        res = 0\\n        for i in range(len(s1)):\\n            res += s1[i] * s2[i]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect\\n\\ndef get(nums1, nums2, n):\\n    dic = {}\\n    for i in range(n):\\n        dic[nums2[i]] = i\\n    positions, s1 = [], []\\n    for i in range(n):\\n        # Find the position of nums1[i] in nums2, update the sorted positions\\n        s1.append(bisect.bisect_left(positions, dic[nums1[i]]))\\n        # Find the number of smaller index\\n        bisect.insort_right(positions, dic[nums1[i]])\\n    return s1\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1 = get(nums1, nums2, n = len(nums1)) # From start to the mid \\n        s2 = get(nums1[::-1], nums2[::-1], n = len(nums1))[::-1] # From end to the mid\\n        res = 0\\n        for i in range(len(s1)):\\n            res += s1[i] * s2[i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784246,
                "title": "java-one-fenwick-tree",
                "content": "To find all good triplets, for each number we need to find:\\n\\n   1. the count of numbers smaller than itself to the left of it in BOTH arrays\\n   2. the count of numbers larger than itself to the right of it in BOTH arrays\\n\\nWe know the numbers are unique and go from 0 to n-1, and can use that fact to remap the numbers in both arrays, so that one of the arrays is sorted 0, 1, ..., n-1 (we call it idx). It is then trivial to know for that array how many numbers are smaller (i) and greater (n-1-i) for each i.\\n\\nThe task becomes to count the numbers smaller than self and greater than self in the other, remapped array (we call it map).\\nThis reduces to a known problem: [Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/), which can be solved in various ways: using a merge sort or fenwick / segment / order statistic trees.\\n\\nFinally for each number from 0..n-1 we just need to use the smaller/greater counts found in the second array (map), as they will always be a subset of numbers from the fully ordered array (idx).\\n```\\nclass Solution {\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n= nums1.length;\\n        int[] idx= new int[n], map= new int[n];         // remap:\\n        for(int i=0; i<n; i++) idx[nums1[i]]= i;        // nums1 -> idx\\n        for(int i=0; i<n; i++) map[i]= idx[nums2[i]];   // nums2 -> map   -- could be combined with the loop below, but we keep it separate for clarity\\n        \\n        long ans= 0;\\n        FenwickTree bit= new FenwickTree(n);        \\n        for(int i=0; i<n; i++){\\n            int lSmaller= bit.ps(map[i]);     // nums < map[i] to the left of i\\n            int lLarger= i-lSmaller;            // nums > map[i] to the left of i\\n            int larger = n-1-map[i];            // all nums > map[i]\\n            int rLarger= larger - lLarger;      // nums > map[i] to the right of i\\n            ans+= (long) lSmaller * rLarger;\\n            bit.inc(map[i]);\\n        }\\n        return ans;\\n    }\\n    \\n    public class FenwickTree{\\n        // binary index tree, index 0 is not used, so we shift all calls by +1\\n        int[] bit;   \\n        int n;\\n        public FenwickTree(int range){\\n            this.n= range+1;\\n            this.bit= new int[this.n];\\n        }\\n\\t\\t// increment count of i\\n        public void inc(int i){\\n            for(i++; i<n; i+= Integer.lowestOneBit(i))\\n                bit[i]++;\\n        }\\n        // prefix sum query i.e. count of nums <= i added so far\\n        private int ps(int i){\\n            int ps= 0;\\n            for(i++; i!=0; i-= Integer.lowestOneBit(i))\\n                ps+= bit[i];\\n            return ps;\\n        }\\n    } \\n}",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n= nums1.length;\\n        int[] idx= new int[n], map= new int[n];         // remap:\\n        for(int i=0; i<n; i++) idx[nums1[i]]= i;        // nums1 -> idx\\n        for(int i=0; i<n; i++) map[i]= idx[nums2[i]];   // nums2 -> map   -- could be combined with the loop below, but we keep it separate for clarity\\n        \\n        long ans= 0;\\n        FenwickTree bit= new FenwickTree(n);        \\n        for(int i=0; i<n; i++){\\n            int lSmaller= bit.ps(map[i]);     // nums < map[i] to the left of i\\n            int lLarger= i-lSmaller;            // nums > map[i] to the left of i\\n            int larger = n-1-map[i];            // all nums > map[i]\\n            int rLarger= larger - lLarger;      // nums > map[i] to the right of i\\n            ans+= (long) lSmaller * rLarger;\\n            bit.inc(map[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1783996,
                "title": "java-solution",
                "content": "```\\npublic long goodTriplets(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int[] val1 = new int[n];\\n        for (int i = 0; i < n; i++) {\\n        \\tval1[nums1[i]] = i;\\n        }\\n        int[] pos = new int[n];\\n        for (int i = 0; i < n; i++) {\\n        \\tpos[val1[nums2[i]]] = i;\\n        }\\n        \\n        List<Integer> left = new ArrayList();\\n        List<Integer> right = new ArrayList();\\n        for (int i = 0; i < n; i++) \\n            right.add(i);\\n\\n        long count = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n        \\tint now = pos[i];\\n        \\tint rPos = Collections.binarySearch(right, now);\\n        \\tright.remove(rPos);\\n        \\tint g = right.size() - rPos;\\n        \\tint lPos = Collections.binarySearch(left, now);\\n        \\tif (lPos < 0) \\n        \\t\\tlPos = -1 - lPos;\\n        \\tleft.add(lPos, now);\\n        \\tint l = lPos;\\n        \\tcount += (long) g * l;\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic long goodTriplets(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int[] val1 = new int[n];\\n        for (int i = 0; i < n; i++) {\\n        \\tval1[nums1[i]] = i;\\n        }\\n        int[] pos = new int[n];\\n        for (int i = 0; i < n; i++) {\\n        \\tpos[val1[nums2[i]]] = i;\\n        }\\n        \\n        List<Integer> left = new ArrayList();\\n        List<Integer> right = new ArrayList();\\n        for (int i = 0; i < n; i++) \\n            right.add(i);\\n\\n        long count = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n        \\tint now = pos[i];\\n        \\tint rPos = Collections.binarySearch(right, now);\\n        \\tright.remove(rPos);\\n        \\tint g = right.size() - rPos;\\n        \\tint lPos = Collections.binarySearch(left, now);\\n        \\tif (lPos < 0) \\n        \\t\\tlPos = -1 - lPos;\\n        \\tleft.add(lPos, now);\\n        \\tint l = lPos;\\n        \\tcount += (long) g * l;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1783778,
                "title": "it-s-ain-t-much-but-it-s-honest-work",
                "content": "came up with approach after contest, but taking too much time. hope it\\'s helps to get intuition\\n\\nfor a given value get index in both nums1 and nums2 \\n\\nsort any of them and check for other how many pair is increasing or not \\n\\nhere arr[i][0] = position of i in nums1\\narr[i][1] = position of i in nums2\\n\\nsorted arr by 0th index and find how many triplet in 1th index is sorted\\n\\n```cpp\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\n\\nusing namespace __gnu_pbds; \\n\\ntypedef tree<\\nint,\\nnull_type,\\nless<int>,\\nrb_tree_tag,\\ntree_order_statistics_node_update>\\nordered_set;\\n\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        \\n        vector<array<int,2>>arr(n);\\n        \\n        vector<int>pos1(n),pos2(n);\\n        \\n        for(int i=0;i<n;i++){\\n            pos1[nums1[i]] = i;\\n            pos2[nums2[i]] = i;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            arr[i][0] = pos1[i];\\n            arr[i][1] = pos2[i];\\n        }\\n        \\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        vector<int>pre(n);\\n        \\n        \\n        ordered_set s;\\n        \\n        for(int i=0;i<n;i++){\\n            s.insert(arr[i][1]);\\n            pre[i] = s.order_of_key(arr[i][1]);\\n        }\\n        \\n        ordered_set rs;\\n        \\n        long long ans = 0;\\n        for(int i=n-1;i>=0;i--){\\n            rs.insert(-arr[i][1]);\\n            int v = rs.order_of_key(-arr[i][1]);\\n            ans += 1LL*pre[i]*v;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\n\\nusing namespace __gnu_pbds; \\n\\ntypedef tree<\\nint,\\nnull_type,\\nless<int>,\\nrb_tree_tag,\\ntree_order_statistics_node_update>\\nordered_set;\\n\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        \\n        vector<array<int,2>>arr(n);\\n        \\n        vector<int>pos1(n),pos2(n);\\n        \\n        for(int i=0;i<n;i++){\\n            pos1[nums1[i]] = i;\\n            pos2[nums2[i]] = i;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            arr[i][0] = pos1[i];\\n            arr[i][1] = pos2[i];\\n        }\\n        \\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        vector<int>pre(n);\\n        \\n        \\n        ordered_set s;\\n        \\n        for(int i=0;i<n;i++){\\n            s.insert(arr[i][1]);\\n            pre[i] = s.order_of_key(arr[i][1]);\\n        }\\n        \\n        ordered_set rs;\\n        \\n        long long ans = 0;\\n        for(int i=n-1;i>=0;i--){\\n            rs.insert(-arr[i][1]);\\n            int v = rs.order_of_key(-arr[i][1]);\\n            ans += 1LL*pre[i]*v;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1783658,
                "title": "share-my-code",
                "content": "```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        N = len(nums1)\\n        BIT = [0] * (N+1)\\n        nums = [0] * N\\n        num1 = [0] * N\\n        num2 = [0] * N\\n        for i, n in enumerate(nums1):\\n            num1[n]=i\\n        for i, n in enumerate(nums2):\\n            num2[n]=i\\n        for i, n in enumerate(num1):\\n            nums[n] = num2[i]\\n        def lowbit(i):\\n            return i&(-i)\\n        def add(i):\\n            i+=1\\n            while i <= N:\\n                BIT[i]+=1\\n                i+=lowbit(i)\\n        def query(i):\\n            i += 1\\n            re = 0\\n            while i:\\n                re += BIT[i]\\n                i -= lowbit(i)\\n            return re\\n        smaller = []\\n        bigger = []\\n        for i, n in enumerate(nums):\\n            smaller.append(query(n))\\n            bigger.append(N-1-i-n+smaller[-1])\\n            add(n)\\n        return sum(i*j for i, j in zip(smaller, bigger))\\n\\t\\t```",
                "solutionTags": [
                    "Python3",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        N = len(nums1)\\n        BIT = [0] * (N+1)\\n        nums = [0] * N\\n        num1 = [0] * N\\n        num2 = [0] * N\\n        for i, n in enumerate(nums1):\\n            num1[n]=i\\n        for i, n in enumerate(nums2):\\n            num2[n]=i\\n        for i, n in enumerate(num1):\\n            nums[n] = num2[i]\\n        def lowbit(i):\\n            return i&(-i)\\n        def add(i):\\n            i+=1\\n            while i <= N:\\n                BIT[i]+=1\\n                i+=lowbit(i)\\n        def query(i):\\n            i += 1\\n            re = 0\\n            while i:\\n                re += BIT[i]\\n                i -= lowbit(i)\\n            return re\\n        smaller = []\\n        bigger = []\\n        for i, n in enumerate(nums):\\n            smaller.append(query(n))\\n            bigger.append(N-1-i-n+smaller[-1])\\n            add(n)\\n        return sum(i*j for i, j in zip(smaller, bigger))\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1783636,
                "title": "javascript-fenwick-tree-bit-219ms",
                "content": "```\\nfunction Fenwick(n) {\\n    let tree = Array(n).fill(0);\\n    return { query, update }\\n    function query(i) {\\n        let sum = 0;\\n        i++;\\n        while (i > 0) {\\n            sum += tree[i];\\n            i -= i & -i;\\n        }\\n        return sum;\\n    }\\n    function update(i, v) {\\n        i++;\\n        while (i < n) {\\n            tree[i] += v;\\n            i += i & -i;\\n        }\\n    }\\n}\\n\\nconst goodTriplets = (a, b) => {\\n    let n = a.length, m = new Map(), res = 0;\\n    for (let i = 0; i < n; i++) m.set(b[i], i);\\n    let fen = new Fenwick(n + 3);\\n    for (let i = 0; i < n; i++) {\\n       let pos = m.get(a[i]);\\n       let l = fen.query(pos), r = (n - 1 - pos) - (fen.query(n - 1) - fen.query(pos));\\n       res += l * r; \\n       fen.update(pos, 1);\\n    }\\n    return res;\\n};\\n```\\nSegmentTreeRSQ solution: https://leetcode.com/problems/count-good-triplets-in-an-array/solutions/3066395/javascript-segmenttreersq-range-sum-query-305ms/",
                "solutionTags": [
                    "JavaScript",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nfunction Fenwick(n) {\\n    let tree = Array(n).fill(0);\\n    return { query, update }\\n    function query(i) {\\n        let sum = 0;\\n        i++;\\n        while (i > 0) {\\n            sum += tree[i];\\n            i -= i & -i;\\n        }\\n        return sum;\\n    }\\n    function update(i, v) {\\n        i++;\\n        while (i < n) {\\n            tree[i] += v;\\n            i += i & -i;\\n        }\\n    }\\n}\\n\\nconst goodTriplets = (a, b) => {\\n    let n = a.length, m = new Map(), res = 0;\\n    for (let i = 0; i < n; i++) m.set(b[i], i);\\n    let fen = new Fenwick(n + 3);\\n    for (let i = 0; i < n; i++) {\\n       let pos = m.get(a[i]);\\n       let l = fen.query(pos), r = (n - 1 - pos) - (fen.query(n - 1) - fen.query(pos));\\n       res += l * r; \\n       fen.update(pos, 1);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783472,
                "title": "cpp-solution-slow-but-accepted",
                "content": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n\\ntypedef tree<int,null_type,less<int>,\\n             rb_tree_tag,tree_order_statistics_node_update> statisticsTree;\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        vector<int> m(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            m[nums1[i]]=i;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            nums2[i]=m[nums2[i]];\\n        }\\n        statisticsTree bk,fr;\\n        for(int i=0;i<n;i++)\\n        {\\n            bk.insert(i);\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bk.erase(nums2[i]);\\n            int L=fr.order_of_key(nums2[i]);\\n            int R=n-i-1-(bk.order_of_key(nums2[i]));\\n            fr.insert(nums2[i]);\\n            ans+=(L*1LL*R);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n\\ntypedef tree<int,null_type,less<int>,\\n             rb_tree_tag,tree_order_statistics_node_update> statisticsTree;\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        vector<int> m(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            m[nums1[i]]=i;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            nums2[i]=m[nums2[i]];\\n        }\\n        statisticsTree bk,fr;\\n        for(int i=0;i<n;i++)\\n        {\\n            bk.insert(i);\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bk.erase(nums2[i]);\\n            int L=fr.order_of_key(nums2[i]);\\n            int R=n-i-1-(bk.order_of_key(nums2[i]));\\n            fr.insert(nums2[i]);\\n            ans+=(L*1LL*R);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1783338,
                "title": "why-this-solution-is-wrong-if-we-are-not-considering-time-complexity",
                "content": "```\\nn = len(arr1)\\nans = 0\\nfor i in range(n): \\n\\tfor j in range(n):\\n\\t\\tfor k in range(n):\\n\\t\\t\\tif(arr1[i] < arr1[j] < arr1[k] and arr2[i] < arr2[j] < arr2[k]):\\n\\t\\t\\t\\tans += 1\\nreturn ans\\n\\n```",
                "solutionTags": [],
                "code": "```\\nn = len(arr1)\\nans = 0\\nfor i in range(n): \\n\\tfor j in range(n):\\n\\t\\tfor k in range(n):\\n\\t\\t\\tif(arr1[i] < arr1[j] < arr1[k] and arr2[i] < arr2[j] < arr2[k]):\\n\\t\\t\\t\\tans += 1\\nreturn ans\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086117,
                "title": "bit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// class Solution {\\n// public:\\n//     long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n//         int n = nums2.size();\\n//         vector<int> nums2idx(n);\\n//         for (int i = 0; i < n; i++) {\\n//             nums2idx[nums2[i]] = i;\\n//         }\\n//         long long ans = 0;\\n//         set<int> seen;\\n//         seen.insert(nums2idx[nums1[0]]);\\n//         for (int i = 1; i < n; i++) {\\n//             auto temp = seen.insert(nums2idx[nums1[i]]);\\n//             // cout << distance(seen.begin(), temp.first) << endl;\\n//             long cnt1 = distance(seen.begin(), temp.first);\\n//             long cnt2 = n - 1 - nums2idx[nums1[i]] - (i - cnt1);\\n//             ans += (cnt1 * cnt2);\\n//         }\\n//         return ans;\\n//     }\\n// };\\n///////////////////////////////  TLE above  /////////////////////////////\\n\\nclass Solution {\\npublic:\\n    vector<int> nums2idx;\\n    vector<int> BIT;\\n    int n;\\n    int lowbit(int i) {\\n        return i & (-i);\\n    }\\n    void insert(int i) {\\n        // NOTE BIT is 1-indexed\\n        i++;\\n        while (i <= n) {\\n            BIT[i]++;\\n            i += lowbit(i);\\n        }\\n    }\\n    long getBIT(int i) {\\n        // NOTE BIT is 1-indexed\\n        i++;\\n        long ans = 0;\\n        while (i > 0) {\\n            ans += BIT[i];\\n            i -= lowbit(i);\\n        }\\n        return ans;\\n    }\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        long long ans = 0;\\n        n = nums2.size();\\n        nums2idx.resize(n);\\n        for (int i = 0; i < n; i++) {\\n            nums2idx[nums2[i]] = i;\\n        }\\n        BIT.resize(n + 1,0);\\n        for (int i = 1; i < n - 1; i++) {\\n            insert(nums2idx[nums1[i-1]]);;\\n            long val1 = getBIT(nums2idx[nums1[i]]);\\n            long val2 = n - 1 - nums2idx[nums1[i]] - (i - val1);\\n            ans += (val1 * val2);\\n            // cout << i << \"-->\" << nums2idx[nums1[i]] << \": \" << val1 << \", \" << val2 << endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Indexed Tree"
                ],
                "code": "```\\n// class Solution {\\n// public:\\n//     long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n//         int n = nums2.size();\\n//         vector<int> nums2idx(n);\\n//         for (int i = 0; i < n; i++) {\\n//             nums2idx[nums2[i]] = i;\\n//         }\\n//         long long ans = 0;\\n//         set<int> seen;\\n//         seen.insert(nums2idx[nums1[0]]);\\n//         for (int i = 1; i < n; i++) {\\n//             auto temp = seen.insert(nums2idx[nums1[i]]);\\n//             // cout << distance(seen.begin(), temp.first) << endl;\\n//             long cnt1 = distance(seen.begin(), temp.first);\\n//             long cnt2 = n - 1 - nums2idx[nums1[i]] - (i - cnt1);\\n//             ans += (cnt1 * cnt2);\\n//         }\\n//         return ans;\\n//     }\\n// };\\n///////////////////////////////  TLE above  /////////////////////////////\\n\\nclass Solution {\\npublic:\\n    vector<int> nums2idx;\\n    vector<int> BIT;\\n    int n;\\n    int lowbit(int i) {\\n        return i & (-i);\\n    }\\n    void insert(int i) {\\n        // NOTE BIT is 1-indexed\\n        i++;\\n        while (i <= n) {\\n            BIT[i]++;\\n            i += lowbit(i);\\n        }\\n    }\\n    long getBIT(int i) {\\n        // NOTE BIT is 1-indexed\\n        i++;\\n        long ans = 0;\\n        while (i > 0) {\\n            ans += BIT[i];\\n            i -= lowbit(i);\\n        }\\n        return ans;\\n    }\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        long long ans = 0;\\n        n = nums2.size();\\n        nums2idx.resize(n);\\n        for (int i = 0; i < n; i++) {\\n            nums2idx[nums2[i]] = i;\\n        }\\n        BIT.resize(n + 1,0);\\n        for (int i = 1; i < n - 1; i++) {\\n            insert(nums2idx[nums1[i-1]]);;\\n            long val1 = getBIT(nums2idx[nums1[i]]);\\n            long val2 = n - 1 - nums2idx[nums1[i]] - (i - val1);\\n            ans += (val1 * val2);\\n            // cout << i << \"-->\" << nums2idx[nums1[i]] << \": \" << val1 << \", \" << val2 << endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4032310,
                "title": "fenwick-tree-explanation-and-solution-c",
                "content": "****The first thing we notice about this problem is that this is counting the number of ways of 3 numbers.****\\n\\n+ Considering the conditions, how can we count them to satisfy them? Then we see that when choosing an index at nums1 to count, it must satisfy the index at nums2 as the number of ways that can count the elements that satisfy the left and right sides of nums1 and nums2.\\n+ This problem requires updating each element with a different index. So using Prefifx Sum is not feasible, so we will use (Segment Tree, Fenwick Tree, Ordered_set) here I use Fenwick Tree.\\n\\n**The way to count is to use Fenwick Tree twice, one to count prefixes and one to count suffixes.**\\n\\n****Vote if you think it\\'s good****\\n\\n****Here is my C++ code you can refer to****\\n```\\nclass FenwickTree {\\nprivate:\\n    vector<int> bit;\\n    int n;\\n    \\npublic:\\n    FenwickTree(int n = 0) {\\n        bit.resize(n + 1);\\n        this->n = n;\\n    }\\n    \\n    void update(int i, int v) {\\n        for (i = i + 1; i <= n; i += -i&i) {\\n            bit[i] += v;\\n        }\\n    }\\n    \\n    int count(int i) {\\n        int s = 0;\\n        for (i = i + 1; i > 0; i -= -i&i) {\\n            s += bit[i];\\n        }\\n        return s;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int, int> mapping;\\n        const int n = nums1.size();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            mapping[nums2[i]] = i; \\n        }\\n        \\n        vector<int> left_smaller(n), right_larger(n);\\n        \\n        FenwickTree ft[2];\\n        \\n        ft[0] = FenwickTree(n);\\n        ft[1] = FenwickTree(n);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            int j = mapping[nums1[i]];\\n            left_smaller[i] = ft[0].count(j - 1);\\n            ft[0].update(j, 1);\\n        }\\n        \\n        for (int i = n - 1; i >= 0; --i) {\\n            int j = mapping[nums1[i]];\\n            right_larger[i] = ft[1].count(n - 1) - ft[1].count(j);\\n            ft[1].update(j, 1);\\n        }\\n        \\n        long long ans = 0;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            ans += 1LL*left_smaller[i]*right_larger[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass FenwickTree {\\nprivate:\\n    vector<int> bit;\\n    int n;\\n    \\npublic:\\n    FenwickTree(int n = 0) {\\n        bit.resize(n + 1);\\n        this->n = n;\\n    }\\n    \\n    void update(int i, int v) {\\n        for (i = i + 1; i <= n; i += -i&i) {\\n            bit[i] += v;\\n        }\\n    }\\n    \\n    int count(int i) {\\n        int s = 0;\\n        for (i = i + 1; i > 0; i -= -i&i) {\\n            s += bit[i];\\n        }\\n        return s;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int, int> mapping;\\n        const int n = nums1.size();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            mapping[nums2[i]] = i; \\n        }\\n        \\n        vector<int> left_smaller(n), right_larger(n);\\n        \\n        FenwickTree ft[2];\\n        \\n        ft[0] = FenwickTree(n);\\n        ft[1] = FenwickTree(n);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            int j = mapping[nums1[i]];\\n            left_smaller[i] = ft[0].count(j - 1);\\n            ft[0].update(j, 1);\\n        }\\n        \\n        for (int i = n - 1; i >= 0; --i) {\\n            int j = mapping[nums1[i]];\\n            right_larger[i] = ft[1].count(n - 1) - ft[1].count(j);\\n            ft[1].update(j, 1);\\n        }\\n        \\n        long long ans = 0;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            ans += 1LL*left_smaller[i]*right_larger[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003790,
                "title": "heavily-commented-fenwick-tree-inversion-count-c",
                "content": "\\n\\n# Code\\n```\\n// Fenwick Tree Class\\nclass fwk {\\npublic:\\n   int fenwick[100005]; // Array to store Fenwick Tree values.\\n   int N; // Size of the Fenwick Tree.\\n\\n   // Constructor to initialize the Fenwick Tree.\\n   fwk(int n) {\\n      N = n;\\n      memset(fenwick, 0, sizeof fenwick); // Initialize the Fenwick Tree with zeros.\\n   }\\n\\n   // Function to update the Fenwick Tree at a specific index with a given value.\\n   void update(int index, int x) {\\n      for (int i = index; i <= N; i += (i & -i)) {\\n         fenwick[i] += x; // Update the Fenwick Tree at index \\'i\\'.\\n      }\\n   }\\n\\n   // Function to calculate the prefix sum up to a specific index.\\n   int sum(int index) {\\n      int ans = 0;\\n      for (int i = index; i > 0; i -= (i & -i)) {\\n         ans += fenwick[i]; // Calculate the prefix sum up to index \\'i\\'.\\n      }\\n      return ans;\\n   }\\n};\\n\\nclass Solution {\\npublic:\\n   long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n      int n = nums1.size();\\n\\n      map<int, int> indices; // A map to store indices of elements from nums2.\\n      vector<int> B; // A vector to store indices of elements from nums1 in nums2.\\n\\n      // Populate the \\'indices\\' map with indices of elements from nums2.\\n      for (int i = 0; i < nums2.size(); i++) {\\n         indices[nums2[i]] = i;\\n      }\\n\\n      // Build vector B by storing indices of elements from nums1 in nums2.Essentially, this block is creating a vector B where each element represents the position of an element from nums1 in the context of nums2. This is done to facilitate further calculations based on the positions of elements in both arrays.\\n      for (int i : nums1) {\\n         B.push_back(indices[i]);\\n      }\\n\\n      // Increment all elements in vector B by 1 to make them 1-based indices.\\n      for (int i = 0; i < B.size(); i++) {\\n         B[i]++;\\n      }\\n\\n     // Initialize arrays to store left and right counts.\\nlong long left[n + 2]; // An array to store the count of lesser elements to the left of each element.\\nlong long right[n + 2]; // An array to store the count of greater elements to the right of each element.\\nleft[0] = 0; // Initialize the left count for the first element (0 lesser elements to the left).\\nright[n + 1] = 0; // Initialize the right count for the last element (0 greater elements to the right).\\n\\nfwk L(n); // Create a Fenwick Tree for left counts.\\n\\n// Calculate left counts using Fenwick Tree.\\nfor (int i = 1; i <= n; i++) {\\n   int ele = B[i - 1]; // Get the index of the current element in vector B.\\n   // Count of lesser elements to the left side is calculated using a Fenwick Tree.\\n   left[i] = L.sum(ele - 1); // Use Fenwick Tree to find the sum of elements to the left (lesser elements).\\n   L.update(ele, 1); // Update the Fenwick Tree to mark the current element as visited (count it).\\n}\\n\\nfwk R(n); // Create a Fenwick Tree for right counts.\\n\\n// Calculate right counts using Fenwick Tree.\\nfor (int i = n; i >= 1; i--) {\\n   int ele = B[i - 1]; // Get the index of the current element in vector B.\\n   // Count of greater elements to the right side is calculated using a Fenwick Tree.\\n   right[i] = R.sum(n) - R.sum(ele); // Use Fenwick Tree to find the sum of elements to the right (greater elements).\\n   R.update(ele, 1); // Update the Fenwick Tree to mark the current element as visited (count it).\\n}\\n\\n\\n      long long ans = 0;\\n\\n      // Calculate the total count of good triplets using left and right counts.\\n      for (int i = 1; i <= n; i++) {\\n         // Consider the current element as the middle and calculate all combinations.\\n         ans = ans + (left[i] * right[i]);\\n      }\\n      return ans; // Return the final answer.\\n   }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Fenwick Tree Class\\nclass fwk {\\npublic:\\n   int fenwick[100005]; // Array to store Fenwick Tree values.\\n   int N; // Size of the Fenwick Tree.\\n\\n   // Constructor to initialize the Fenwick Tree.\\n   fwk(int n) {\\n      N = n;\\n      memset(fenwick, 0, sizeof fenwick); // Initialize the Fenwick Tree with zeros.\\n   }\\n\\n   // Function to update the Fenwick Tree at a specific index with a given value.\\n   void update(int index, int x) {\\n      for (int i = index; i <= N; i += (i & -i)) {\\n         fenwick[i] += x; // Update the Fenwick Tree at index \\'i\\'.\\n      }\\n   }\\n\\n   // Function to calculate the prefix sum up to a specific index.\\n   int sum(int index) {\\n      int ans = 0;\\n      for (int i = index; i > 0; i -= (i & -i)) {\\n         ans += fenwick[i]; // Calculate the prefix sum up to index \\'i\\'.\\n      }\\n      return ans;\\n   }\\n};\\n\\nclass Solution {\\npublic:\\n   long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n      int n = nums1.size();\\n\\n      map<int, int> indices; // A map to store indices of elements from nums2.\\n      vector<int> B; // A vector to store indices of elements from nums1 in nums2.\\n\\n      // Populate the \\'indices\\' map with indices of elements from nums2.\\n      for (int i = 0; i < nums2.size(); i++) {\\n         indices[nums2[i]] = i;\\n      }\\n\\n      // Build vector B by storing indices of elements from nums1 in nums2.Essentially, this block is creating a vector B where each element represents the position of an element from nums1 in the context of nums2. This is done to facilitate further calculations based on the positions of elements in both arrays.\\n      for (int i : nums1) {\\n         B.push_back(indices[i]);\\n      }\\n\\n      // Increment all elements in vector B by 1 to make them 1-based indices.\\n      for (int i = 0; i < B.size(); i++) {\\n         B[i]++;\\n      }\\n\\n     // Initialize arrays to store left and right counts.\\nlong long left[n + 2]; // An array to store the count of lesser elements to the left of each element.\\nlong long right[n + 2]; // An array to store the count of greater elements to the right of each element.\\nleft[0] = 0; // Initialize the left count for the first element (0 lesser elements to the left).\\nright[n + 1] = 0; // Initialize the right count for the last element (0 greater elements to the right).\\n\\nfwk L(n); // Create a Fenwick Tree for left counts.\\n\\n// Calculate left counts using Fenwick Tree.\\nfor (int i = 1; i <= n; i++) {\\n   int ele = B[i - 1]; // Get the index of the current element in vector B.\\n   // Count of lesser elements to the left side is calculated using a Fenwick Tree.\\n   left[i] = L.sum(ele - 1); // Use Fenwick Tree to find the sum of elements to the left (lesser elements).\\n   L.update(ele, 1); // Update the Fenwick Tree to mark the current element as visited (count it).\\n}\\n\\nfwk R(n); // Create a Fenwick Tree for right counts.\\n\\n// Calculate right counts using Fenwick Tree.\\nfor (int i = n; i >= 1; i--) {\\n   int ele = B[i - 1]; // Get the index of the current element in vector B.\\n   // Count of greater elements to the right side is calculated using a Fenwick Tree.\\n   right[i] = R.sum(n) - R.sum(ele); // Use Fenwick Tree to find the sum of elements to the right (greater elements).\\n   R.update(ele, 1); // Update the Fenwick Tree to mark the current element as visited (count it).\\n}\\n\\n\\n      long long ans = 0;\\n\\n      // Calculate the total count of good triplets using left and right counts.\\n      for (int i = 1; i <= n; i++) {\\n         // Consider the current element as the middle and calculate all combinations.\\n         ans = ans + (left[i] * right[i]);\\n      }\\n      return ans; // Return the final answer.\\n   }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960914,
                "title": "simple-segment-tree-code",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*log(n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void update(int ind, int l,int r,int val,vector<int> &tree,int par){\\n        if(l>val || r<val) return;\\n        if(l==r){\\n            if(par==0) tree[ind]++;\\n            else tree[ind]--;\\n            return;\\n        }\\n\\n        int mid=(l+r)/2;\\n        update(2*ind,l,mid,val,tree,par); \\n        update(2*ind+1,mid+1,r,val,tree,par); \\n\\n        tree[ind]=tree[2*ind]+tree[2*ind+1];\\n    }\\n\\n    int find(int ind, int l,int r,int val,vector<int> &tree,int par){\\n        if(l>val and par==0) return 0;\\n        if(r<val and par==1) return 0;\\n\\n        if(r<=val and par==0) return tree[ind];\\n        if(l>=val and par) return tree[ind];\\n\\n        int mid=(l+r)/2;\\n        int left=find(2*ind,l,mid,val,tree,par);\\n        int right=find(2*ind+1,mid+1,r,val,tree,par);\\n\\n        return left+right;\\n    }\\n\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        vector<int>pos(n);\\n        for(int i=0;i<n;i++) pos[nums2[i]]=i;\\n        vector<int>left(4*n+10,0),right(4*n+10,0);\\n        update(1,0,n-1,pos[nums1[0]],left,0);\\n        for(int i=2;i<n;i++) update(1,0,n-1,pos[nums1[i]],right,0);\\n\\n        long long ans=0;\\n        for(int i=1;i<n-1;i++){\\n            ans+=1LL*find(1,0,n-1,pos[nums1[i]],left,0)*find(1,0,n-1,pos[nums1[i]],right,1);\\n            update(1,0,n-1,pos[nums1[i]],left,0);\\n            update(1,0,n-1,pos[nums1[i+1]],right,1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void update(int ind, int l,int r,int val,vector<int> &tree,int par){\\n        if(l>val || r<val) return;\\n        if(l==r){\\n            if(par==0) tree[ind]++;\\n            else tree[ind]--;\\n            return;\\n        }\\n\\n        int mid=(l+r)/2;\\n        update(2*ind,l,mid,val,tree,par); \\n        update(2*ind+1,mid+1,r,val,tree,par); \\n\\n        tree[ind]=tree[2*ind]+tree[2*ind+1];\\n    }\\n\\n    int find(int ind, int l,int r,int val,vector<int> &tree,int par){\\n        if(l>val and par==0) return 0;\\n        if(r<val and par==1) return 0;\\n\\n        if(r<=val and par==0) return tree[ind];\\n        if(l>=val and par) return tree[ind];\\n\\n        int mid=(l+r)/2;\\n        int left=find(2*ind,l,mid,val,tree,par);\\n        int right=find(2*ind+1,mid+1,r,val,tree,par);\\n\\n        return left+right;\\n    }\\n\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        vector<int>pos(n);\\n        for(int i=0;i<n;i++) pos[nums2[i]]=i;\\n        vector<int>left(4*n+10,0),right(4*n+10,0);\\n        update(1,0,n-1,pos[nums1[0]],left,0);\\n        for(int i=2;i<n;i++) update(1,0,n-1,pos[nums1[i]],right,0);\\n\\n        long long ans=0;\\n        for(int i=1;i<n-1;i++){\\n            ans+=1LL*find(1,0,n-1,pos[nums1[i]],left,0)*find(1,0,n-1,pos[nums1[i]],right,1);\\n            update(1,0,n-1,pos[nums1[i]],left,0);\\n            update(1,0,n-1,pos[nums1[i+1]],right,1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942618,
                "title": "c-using-ordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>  \\nclass Solution {\\npublic:\\n    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        long long ans=0;\\n        unordered_map<int,int> mp;\\n         ordered_set mp1;\\n        int n=nums2.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums2[i]]=i;\\n            mp1.insert(i);\\n        }\\n         ordered_set mp2;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=mp[nums1[i]];\\n            mp2.insert(x);\\n            int count=0,count1=0;\\n            count=mp1.size()-mp1.order_of_key(x)-1;\\n            count1=mp2.order_of_key(x);\\n            // cout<<count1<<\" \"<<count<<endl;\\n            ans+=(long long)count*(long long)count1;\\n            mp1.erase(x);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>  \\nclass Solution {\\npublic:\\n    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        long long ans=0;\\n        unordered_map<int,int> mp;\\n         ordered_set mp1;\\n        int n=nums2.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums2[i]]=i;\\n            mp1.insert(i);\\n        }\\n         ordered_set mp2;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=mp[nums1[i]];\\n            mp2.insert(x);\\n            int count=0,count1=0;\\n            count=mp1.size()-mp1.order_of_key(x)-1;\\n            count1=mp2.order_of_key(x);\\n            // cout<<count1<<\" \"<<count<<endl;\\n            ans+=(long long)count*(long long)count1;\\n            mp1.erase(x);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3689020,
                "title": "fenwick-tree-on-co-ordinate-pairs",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s generalize the two arrays into co-ordinates. The co-ordinate pairs will be the index of the element from the first array and the index of the same element from the second array. \\nfor examples : Let the first array be [1, 2], and the second array be [2, 1] -> here, the coordinate of the value 1 is {1, 2} and the corrdinate of the value 2 is {2, 1}.\\nNow our questions is reduced to find the increasing triplest among the co-ordinates. The increasing triplets should be increasing in both x and y co-ordinate.\\nfor example : {1, 1}, {2, 4}, {3, 2}, {4, 3}\\nIn this case, we have only one increasing triplet, i.e, {1, 1}, {3, 2}, and {4, 3}.\\nBut the question arises how to find these triplets?\\nfirst, sort the pairs on the basis of x co-ordinates. Now we don\\'t care about x co-ordinates, so if we take any triplet, their x cordinates will always be in increasing order. But the same does not applies to the y co-ordinates.\\nBefore calculating the triplets, first calculate the increasing doublets. If we are at any index i, having co-ordinates {xi, yi}. all the pairs having indexes > i has x coordinate greater than xi. Among all these pairs we have to calculate yj > yi such that j > i. For this, we can build a fenwick tree and while iterating from the reverse order increment the count of yj by 1. for evey yi we can query fenwick tree for the count of numbers greater than yi. This same idea applies for calculating the triplets, the only difference is we will update yj by the doublets[yj] instead of 1. The doublets array will be filled while calculating the doublets.\\nInstead of fenwick tree, you can also use segment tree.\\n\\n# Complexity\\n- Time complexity:\\n- O(n log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- O(n)\\n\\n# Code\\n```\\ntemplate <typename T>\\nclass Fenwick {\\n\\n    public :\\n        vector<T> fenw;\\n        int n;\\n        \\n        Fenwick(int _n) : n(_n) {\\n            fenw.resize(n + 1);\\n        }\\n        \\n        void Modify(int x, T v) {\\n            while(x <= n) {\\n                fenw[x] += v;\\n                x += (x & (-x));\\n            }\\n        }\\n        \\n        T Get(int x) {\\n            T v{};\\n            while(x > 0) {\\n                v += fenw[x];\\n                x -= (x & (-x));\\n            }\\n            return v;\\n        }\\n        \\n};\\n\\nclass Solution {\\npublic:\\n    using i64 = long long;\\n    long long goodTriplets(vector<int>& a, vector<int>& b) {\\n        int n = a.size();\\n        Fenwick <i64> doublets(n);\\n        Fenwick <i64> triplets(n);\\n        vector <array<int, 2>> pairs;\\n        vector <int> apos(n + 1), bpos(n + 1);\\n        for(int i = 0; i < n; i ++) apos[a[i]] = i + 1, bpos[b[i]] = i + 1;\\n        for(int i = 0; i < n; i ++) pairs.push_back({apos[i], bpos[i]});\\n        sort(pairs.rbegin(), pairs.rend());\\n        vector <i64> cur(n + 1);\\n        for(auto &x : pairs) {\\n            cur[x[1]] = doublets.Get(n) - doublets.Get(x[1]);\\n            doublets.Modify(x[1], 1LL);\\n        }\\n        i64 ans = 0;\\n        for(auto &x : pairs) {\\n            ans += triplets.Get(n) - triplets.Get(x[1]);\\n            triplets.Modify(x[1], cur[x[1]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Indexed Tree",
                    "Segment Tree"
                ],
                "code": "```\\ntemplate <typename T>\\nclass Fenwick {\\n\\n    public :\\n        vector<T> fenw;\\n        int n;\\n        \\n        Fenwick(int _n) : n(_n) {\\n            fenw.resize(n + 1);\\n        }\\n        \\n        void Modify(int x, T v) {\\n            while(x <= n) {\\n                fenw[x] += v;\\n                x += (x & (-x));\\n            }\\n        }\\n        \\n        T Get(int x) {\\n            T v{};\\n            while(x > 0) {\\n                v += fenw[x];\\n                x -= (x & (-x));\\n            }\\n            return v;\\n        }\\n        \\n};\\n\\nclass Solution {\\npublic:\\n    using i64 = long long;\\n    long long goodTriplets(vector<int>& a, vector<int>& b) {\\n        int n = a.size();\\n        Fenwick <i64> doublets(n);\\n        Fenwick <i64> triplets(n);\\n        vector <array<int, 2>> pairs;\\n        vector <int> apos(n + 1), bpos(n + 1);\\n        for(int i = 0; i < n; i ++) apos[a[i]] = i + 1, bpos[b[i]] = i + 1;\\n        for(int i = 0; i < n; i ++) pairs.push_back({apos[i], bpos[i]});\\n        sort(pairs.rbegin(), pairs.rend());\\n        vector <i64> cur(n + 1);\\n        for(auto &x : pairs) {\\n            cur[x[1]] = doublets.Get(n) - doublets.Get(x[1]);\\n            doublets.Modify(x[1], 1LL);\\n        }\\n        i64 ans = 0;\\n        for(auto &x : pairs) {\\n            ans += triplets.Get(n) - triplets.Get(x[1]);\\n            triplets.Modify(x[1], cur[x[1]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555755,
                "title": "fenwick-tree-31ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor every index in nums1\\nwe have to find no of element \\nwhich occure below of i\\nand above of i in both array\\n(same element)\\n\\nfor eg\\nnums1 = [2,0,1,3], nums2 = [0,1,2,3]\\n\\nfor i => 1\\nbelow = (0) is appear  below the 1 in both array\\nabove = (3) is appear  above the 1 in both array\\n\\nans = below*above\\n\\ncompute this for every index\\n\\n# Approach\\nthis can be done by using fenwick tree\\n\\nft1 => is filled with one\\nft2 => is filled with zero\\n\\ntraverse from the back\\nremove index[e] in ft1\\ncombute result\\nadd index[e] in ft2\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        fenwick fn1 = new fenwick(n);\\n        fenwick fn2 = new fenwick(n);\\n        for(int i = 0 ; i < n ; i++)\\n        fn1.add(i,1);\\n        int index[] = new int[n];\\n        for(int i = 0 ; i < n ; i++)\\n        index[nums2[i]]=i;\\n\\n        long ans = 0;\\n        for(int i = n-1 ; i >= 0 ; i--){\\n            int e = nums1[i];\\n            fn1.add(index[e],-1);\\n            int left = fn1.range(0,index[e]-1);\\n            int right = fn2.range(index[e]+1,n-1);\\n            ans+=left*(long)right;\\n            fn2.add(index[e],1);\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass fenwick{\\n    int arr[];\\n    int n;\\n    fenwick(int n){\\n        this.n = n+1;\\n        this.arr = new int[n+1];\\n    }\\n\\n    void add(int i , int e){\\n        i++;\\n        while(i<n){\\n            arr[i]+=e;\\n            i+=(i&(-i));\\n        }\\n    }\\n\\n    int sum(int i){\\n        i++;\\n        int no = 0 ;\\n        while(i>0){\\n            no+=arr[i];\\n            i-=(i&(-i));\\n        }\\n        return no;\\n    }\\n\\n    int range(int l , int r){\\n        return sum(r)-sum(l-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        fenwick fn1 = new fenwick(n);\\n        fenwick fn2 = new fenwick(n);\\n        for(int i = 0 ; i < n ; i++)\\n        fn1.add(i,1);\\n        int index[] = new int[n];\\n        for(int i = 0 ; i < n ; i++)\\n        index[nums2[i]]=i;\\n\\n        long ans = 0;\\n        for(int i = n-1 ; i >= 0 ; i--){\\n            int e = nums1[i];\\n            fn1.add(index[e],-1);\\n            int left = fn1.range(0,index[e]-1);\\n            int right = fn2.range(index[e]+1,n-1);\\n            ans+=left*(long)right;\\n            fn2.add(index[e],1);\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass fenwick{\\n    int arr[];\\n    int n;\\n    fenwick(int n){\\n        this.n = n+1;\\n        this.arr = new int[n+1];\\n    }\\n\\n    void add(int i , int e){\\n        i++;\\n        while(i<n){\\n            arr[i]+=e;\\n            i+=(i&(-i));\\n        }\\n    }\\n\\n    int sum(int i){\\n        i++;\\n        int no = 0 ;\\n        while(i>0){\\n            no+=arr[i];\\n            i-=(i&(-i));\\n        }\\n        return no;\\n    }\\n\\n    int range(int l , int r){\\n        return sum(r)-sum(l-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546037,
                "title": "create-index-pairs-and-sort-and-query-using-fenwick-tree",
                "content": "```\\nclass FenwickTree:\\n    def __init__(self, x):\\n        self.bit = x\\n        for i in range(len(x)):\\n            j = i | (i + 1)\\n            if j < len(x):\\n                x[j] += x[i]\\n\\n    def update(self, idx, x):\\n        while idx < len(self.bit):\\n            self.bit[idx] += x\\n            idx |= idx + 1\\n\\n    def query(self, end):\\n        x = 0\\n        while end:\\n            x += self.bit[end - 1]\\n            end &= end - 1\\n        return x\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        pos = [[-1, -1, i] for i in range(n)]\\n        for i in range(n):\\n            pos[nums1[i]][0] = i\\n            pos[nums2[i]][1] = i\\n        pos.sort()\\n        ctr = [1] * n\\n        fw = FenwickTree([0] * n)\\n        for x, y, i in pos:\\n            ctr[i] *= fw.query(y)\\n            fw.update(y, 1)\\n        fw = FenwickTree([0] * n)\\n        for x, y, i in pos[::-1]:\\n            ctr[i] *= fw.query(n) - fw.query(y + 1)\\n            fw.update(y, 1)\\n        return sum(ctr)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass FenwickTree:\\n    def __init__(self, x):\\n        self.bit = x\\n        for i in range(len(x)):\\n            j = i | (i + 1)\\n            if j < len(x):\\n                x[j] += x[i]\\n\\n    def update(self, idx, x):\\n        while idx < len(self.bit):\\n            self.bit[idx] += x\\n            idx |= idx + 1\\n\\n    def query(self, end):\\n        x = 0\\n        while end:\\n            x += self.bit[end - 1]\\n            end &= end - 1\\n        return x\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        pos = [[-1, -1, i] for i in range(n)]\\n        for i in range(n):\\n            pos[nums1[i]][0] = i\\n            pos[nums2[i]][1] = i\\n        pos.sort()\\n        ctr = [1] * n\\n        fw = FenwickTree([0] * n)\\n        for x, y, i in pos:\\n            ctr[i] *= fw.query(y)\\n            fw.update(y, 1)\\n        fw = FenwickTree([0] * n)\\n        for x, y, i in pos[::-1]:\\n            ctr[i] *= fw.query(n) - fw.query(y + 1)\\n            fw.update(y, 1)\\n        return sum(ctr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493140,
                "title": "ordered-set-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. For some x (0 .. n ), how can you find the number of values(y) such that y appears before x in both of the arrays?\\n2. Do it above for greater elements . \\n3. then total += before[i] * after[i] ( ic[0 , n-1 ] )\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1 can be solved using divide and conquer , binary index tree , segment tree , ordered_set \\n\\n# Complexity\\n- Time complexity:\\no(n logn ) \\nordered_set tooks logn to find elements smaller than required .\\n\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int> mp ;\\n        int n = nums1.size() ;\\n        for(int i = 0 ; i< n ; ++i ){\\n            mp[nums2[i]] = i ;\\n        }\\n        vector<long long> pre(n , 0 ) , suff(n , 0 ) ;\\n        ordered_set st ; \\n        for(int i = 0 ; i< n ; ++i ){\\n            int ne = st.order_of_key(mp[nums1[i]]) ;\\n            pre[i] = ne ;\\n            st.insert(mp[nums1[i]]) ;\\n        }\\n        st.clear() ;\\n\\n        for(int i = n-1 ; i>=0 ; --i ){\\n            int ne = st.order_of_key(mp[nums1[i]] + 1) ;\\n            int te = n - i ; \\n            suff[i] = te - ne -1;\\n            st.insert(mp[nums1[i]]) ;\\n        }\\n\\n        long long ans = 0 ;\\n        for(int i = 0 ; i< n ; ++i ){\\n            ans += (pre[i]*suff[i]) ;\\n        }\\n        return ans ; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int> mp ;\\n        int n = nums1.size() ;\\n        for(int i = 0 ; i< n ; ++i ){\\n            mp[nums2[i]] = i ;\\n        }\\n        vector<long long> pre(n , 0 ) , suff(n , 0 ) ;\\n        ordered_set st ; \\n        for(int i = 0 ; i< n ; ++i ){\\n            int ne = st.order_of_key(mp[nums1[i]]) ;\\n            pre[i] = ne ;\\n            st.insert(mp[nums1[i]]) ;\\n        }\\n        st.clear() ;\\n\\n        for(int i = n-1 ; i>=0 ; --i ){\\n            int ne = st.order_of_key(mp[nums1[i]] + 1) ;\\n            int te = n - i ; \\n            suff[i] = te - ne -1;\\n            st.insert(mp[nums1[i]]) ;\\n        }\\n\\n        long long ans = 0 ;\\n        for(int i = 0 ; i< n ; ++i ){\\n            ans += (pre[i]*suff[i]) ;\\n        }\\n        return ans ; \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3465785,
                "title": "it-s-very-hard",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FenwickTree {\\n  public FenwickTree(int n) {\\n    sums = new int[n + 1];\\n  }\\n\\n  public void update(int i, int delta) {\\n    while (i < sums.length) {\\n      sums[i] += delta;\\n      i += lowbit(i);\\n    }\\n  }\\n\\n  public int get(int i) {\\n    int sum = 0;\\n    while (i > 0) {\\n      sum += sums[i];\\n      i -= lowbit(i);\\n    }\\n    return sum;\\n  }\\n\\n  private int[] sums;\\n\\n  private static int lowbit(int i) {\\n    return i & -i;\\n  }\\n}\\n\\nclass Solution {\\n  public long goodTriplets(int[] nums1, int[] nums2) {\\n    final int n = nums1.length;\\n    long ans = 0;\\n    Map<Integer, Integer> numToIndex = new HashMap<>();\\n    int[] A = new int[n];\\n    int[] leftSmaller = new int[n];\\n    int[] rightLarger = new int[n];\\n    FenwickTree tree1 = new FenwickTree(n);\\n    FenwickTree tree2 = new FenwickTree(n);\\n\\n    for (int i = 0; i < n; ++i)\\n      numToIndex.put(nums1[i], i);\\n\\n    for (int i = 0; i < n; ++i)\\n      A[i] = numToIndex.get(nums2[i]);\\n\\n    for (int i = 0; i < n; ++i) {\\n      leftSmaller[i] = tree1.get(A[i]);\\n      tree1.update(A[i] + 1, 1);\\n    }\\n\\n    for (int i = n - 1; i >= 0; --i) {\\n      rightLarger[i] = tree2.get(n) - tree2.get(A[i]);\\n      tree2.update(A[i] + 1, 1);\\n    }\\n\\n    for (int i = 0; i < n; ++i)\\n      ans += (long) leftSmaller[i] * rightLarger[i];\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FenwickTree {\\n  public FenwickTree(int n) {\\n    sums = new int[n + 1];\\n  }\\n\\n  public void update(int i, int delta) {\\n    while (i < sums.length) {\\n      sums[i] += delta;\\n      i += lowbit(i);\\n    }\\n  }\\n\\n  public int get(int i) {\\n    int sum = 0;\\n    while (i > 0) {\\n      sum += sums[i];\\n      i -= lowbit(i);\\n    }\\n    return sum;\\n  }\\n\\n  private int[] sums;\\n\\n  private static int lowbit(int i) {\\n    return i & -i;\\n  }\\n}\\n\\nclass Solution {\\n  public long goodTriplets(int[] nums1, int[] nums2) {\\n    final int n = nums1.length;\\n    long ans = 0;\\n    Map<Integer, Integer> numToIndex = new HashMap<>();\\n    int[] A = new int[n];\\n    int[] leftSmaller = new int[n];\\n    int[] rightLarger = new int[n];\\n    FenwickTree tree1 = new FenwickTree(n);\\n    FenwickTree tree2 = new FenwickTree(n);\\n\\n    for (int i = 0; i < n; ++i)\\n      numToIndex.put(nums1[i], i);\\n\\n    for (int i = 0; i < n; ++i)\\n      A[i] = numToIndex.get(nums2[i]);\\n\\n    for (int i = 0; i < n; ++i) {\\n      leftSmaller[i] = tree1.get(A[i]);\\n      tree1.update(A[i] + 1, 1);\\n    }\\n\\n    for (int i = n - 1; i >= 0; --i) {\\n      rightLarger[i] = tree2.get(n) - tree2.get(A[i]);\\n      tree2.update(A[i] + 1, 1);\\n    }\\n\\n    for (int i = 0; i < n; ++i)\\n      ans += (long) leftSmaller[i] * rightLarger[i];\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436239,
                "title": "python-straightforward-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor triplet requirement, consider the middle one in the triplet, count how many \"smaller\" options in front and how many \"bigger\" options behind\\n\\n\\n# Code\\n```\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        dic = {num: i for i, num in enumerate(nums2)}\\n        n = len(nums1)\\n        idx_f, idx_b = [0], [0]\\n        front, back = [dic[nums1[0]]], [dic[nums1[-1]]]\\n        for num in nums1[1:]:\\n            idx = bisect(front, dic[num])\\n            front.insert(idx, dic[num])\\n            idx_f.append(idx)\\n        \\n        for num in nums1[n-2::-1]:\\n            \\n            idx = bisect(back, dic[num])\\n            idx_b.append(len(back) - idx)\\n            back.insert(idx, dic[num])\\n                \\n            \\n        idx_b = idx_b[::-1]\\n        \\n        return sum(a*b for a, b in zip(idx_f, idx_b))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        dic = {num: i for i, num in enumerate(nums2)}\\n        n = len(nums1)\\n        idx_f, idx_b = [0], [0]\\n        front, back = [dic[nums1[0]]], [dic[nums1[-1]]]\\n        for num in nums1[1:]:\\n            idx = bisect(front, dic[num])\\n            front.insert(idx, dic[num])\\n            idx_f.append(idx)\\n        \\n        for num in nums1[n-2::-1]:\\n            \\n            idx = bisect(back, dic[num])\\n            idx_b.append(len(back) - idx)\\n            back.insert(idx, dic[num])\\n                \\n            \\n        idx_b = idx_b[::-1]\\n        \\n        return sum(a*b for a, b in zip(idx_f, idx_b))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433658,
                "title": "with-search-and-insert-implement-base-on-slice",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number of goodTriplets of i-th element of nums1 = the number of left elements in both slice and the number of right\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintenance a sorted slice to count the left and the right.\\n$$O(log(n))$$ for search and $$O(n)$$ for swap(insert).\\nUse slice that can grow on two directions to save time of the $$O(n)$$ swap.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nfunc goodTriplets(nums1 []int, nums2 []int) int64 {\\n    var result int64\\n    idx := make([]int,len(nums1))\\n    left := make([]int64,len(nums1))\\n    right := make([]int64,len(nums1))\\n    for i,v := range nums2{\\n        idx[v] = i\\n    }\\n    var a []int = make([]int,len(nums1)*2+1)\\n    from,to :=  len(nums1),len(nums1)\\n    for i,v := range nums1{\\n      left[i],from,to = add(a, idx[v], from, to)\\n      left[i] = left[i] - int64(from)\\n    }\\n    \\n    from,to =  len(nums1),len(nums1)\\n\\n    for i:=len(nums1)-1;i>-1;i--{\\n      right[i],from,to = add(a, idx[nums1[i]], from, to)\\n      right[i] = int64(to)-right[i] - 1\\n    }\\n    for i,_ := range nums1{\\n        result += left[i] * right[i]\\n    }\\n    return result\\n}\\n\\nfunc add(a []int, v int, from int, to int) (int64,int,int){\\n  pos := search(a, v, from, to)\\n  if pos - from < to - pos{\\n    from = from -1\\n    pos = pos -1\\n    for i:=from;i<pos;i++{\\n      a[i] = a[i+1]\\n    }\\n  }else{\\n    for i:=to;i>pos;i--{\\n      a[i] = a[i-1]\\n    }\\n    to = to + 1\\n  }\\n\\n  a[pos] = v\\n  return int64(pos),from,to\\n}\\n\\nfunc search(a []int, v int, i int, j int) int {\\n  from := i\\n  to := j\\n  if to == from {return from}\\n  var key int\\n  for(to - from > 1){\\n    key = (from + to) / 2\\n    if a[key] == v{\\n      return key\\n    }else if a[key] < v{\\n      from = key\\n    }else{\\n      to = key\\n    }\\n  }\\n  if a[from] < v{\\n    return from + 1\\n  }else{\\n    return from\\n  }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc goodTriplets(nums1 []int, nums2 []int) int64 {\\n    var result int64\\n    idx := make([]int,len(nums1))\\n    left := make([]int64,len(nums1))\\n    right := make([]int64,len(nums1))\\n    for i,v := range nums2{\\n        idx[v] = i\\n    }\\n    var a []int = make([]int,len(nums1)*2+1)\\n    from,to :=  len(nums1),len(nums1)\\n    for i,v := range nums1{\\n      left[i],from,to = add(a, idx[v], from, to)\\n      left[i] = left[i] - int64(from)\\n    }\\n    \\n    from,to =  len(nums1),len(nums1)\\n\\n    for i:=len(nums1)-1;i>-1;i--{\\n      right[i],from,to = add(a, idx[nums1[i]], from, to)\\n      right[i] = int64(to)-right[i] - 1\\n    }\\n    for i,_ := range nums1{\\n        result += left[i] * right[i]\\n    }\\n    return result\\n}\\n\\nfunc add(a []int, v int, from int, to int) (int64,int,int){\\n  pos := search(a, v, from, to)\\n  if pos - from < to - pos{\\n    from = from -1\\n    pos = pos -1\\n    for i:=from;i<pos;i++{\\n      a[i] = a[i+1]\\n    }\\n  }else{\\n    for i:=to;i>pos;i--{\\n      a[i] = a[i-1]\\n    }\\n    to = to + 1\\n  }\\n\\n  a[pos] = v\\n  return int64(pos),from,to\\n}\\n\\nfunc search(a []int, v int, i int, j int) int {\\n  from := i\\n  to := j\\n  if to == from {return from}\\n  var key int\\n  for(to - from > 1){\\n    key = (from + to) / 2\\n    if a[key] == v{\\n      return key\\n    }else if a[key] < v{\\n      from = key\\n    }else{\\n      to = key\\n    }\\n  }\\n  if a[from] < v{\\n    return from + 1\\n  }else{\\n    return from\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3386049,
                "title": "python-bit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT:\\n    def __init__(self,n):\\n        self.ans = [0]*(n+1)\\n\\n    def query(self,i):\\n        res = 0\\n        while i > 0:\\n            res += self.ans[i]\\n            i -= i&-i\\n        return res\\n\\n    def update(self,i,val):\\n        while i < len(self.ans):\\n            self.ans[i] += val\\n            i += i&-i\\n\\nclass Solution:\\n    def goodTriplets(self, nums1, nums2):\\n        dict1 = {x:i for i,x in enumerate(nums1)}\\n        n = len(nums1)\\n        arr = [dict1[nums2[i]] for i in range(n)]\\n\\n        BIT1, BIT2, total = BIT(n), BIT(n), 0\\n\\n        for i in arr:\\n            total += BIT2.query(i)\\n            BIT1.update(i+1,1)\\n            less = BIT1.query(i)\\n            BIT2.update(i+1,less)\\n\\n        return total\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass BIT:\\n    def __init__(self,n):\\n        self.ans = [0]*(n+1)\\n\\n    def query(self,i):\\n        res = 0\\n        while i > 0:\\n            res += self.ans[i]\\n            i -= i&-i\\n        return res\\n\\n    def update(self,i,val):\\n        while i < len(self.ans):\\n            self.ans[i] += val\\n            i += i&-i\\n\\nclass Solution:\\n    def goodTriplets(self, nums1, nums2):\\n        dict1 = {x:i for i,x in enumerate(nums1)}\\n        n = len(nums1)\\n        arr = [dict1[nums2[i]] for i in range(n)]\\n\\n        BIT1, BIT2, total = BIT(n), BIT(n), 0\\n\\n        for i in arr:\\n            total += BIT2.query(i)\\n            BIT1.update(i+1,1)\\n            less = BIT1.query(i)\\n            BIT2.update(i+1,less)\\n\\n        return total\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365123,
                "title": "c",
                "content": "```\\nclass BIT{\\n    public:\\n    int N;    \\n    vector<long long>bitArr; // Note: all arrays are 1-index\\n    long long M = 1e9+7;\\n    \\n    BIT(int n)\\n    {\\n        this->N = n;\\n        bitArr.resize(N+1);        \\n    }\\n\\n    void update(int i, int diff) {\\n        int idx = i;\\n        while (idx <= N)\\n        {\\n            bitArr[idx] += diff;\\n            bitArr[idx] %= M;\\n            idx += idx & -idx;\\n        }\\n    }\\n\\n    long long getPreSum(int idx){\\n        long long ret = 0;\\n        while (idx){\\n            ret += bitArr[idx];\\n            ret %= M;\\n            idx -=  idx & -idx;\\n        }\\n        return ret;\\n    }\\n\\n    long long sumRange(int i, int j) {    \\n        return getPreSum(j)-getPreSum(i-1);\\n    } \\n};\\n\\nclass Solution {\\npublic:    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int n = nums1.size();\\n        unordered_map<int,int>Map;\\n        for (int i=0; i<n; i++)\\n            Map[nums1[i]] = i;\\n        \\n        for (int i=0; i<n; i++)\\n            nums2[i] = Map[nums2[i]]+1;\\n        \\n        vector<int>smallerBefore(n);\\n        BIT prefixBIT(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            smallerBefore[i] = prefixBIT.sumRange(1,nums2[i]-1);\\n            prefixBIT.update(nums2[i], 1);\\n        }\\n        \\n        vector<int>largerAfter(n);\\n        BIT suffixBIT(n);\\n        for (int i = n-1; i >= 0; i--)\\n        {\\n            largerAfter[i] = suffixBIT.sumRange(nums2[i]+1, n);\\n            suffixBIT.update(nums2[i], 1);\\n        }\\n        \\n        long long ret = 0; \\n        for (int i=0; i < n; i++)\\n            ret += (long long)smallerBefore[i] * largerAfter[i];\\n        return ret;\\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass BIT{\\n    public:\\n    int N;    \\n    vector<long long>bitArr; // Note: all arrays are 1-index\\n    long long M = 1e9+7;\\n    \\n    BIT(int n)\\n    {\\n        this->N = n;\\n        bitArr.resize(N+1);        \\n    }\\n\\n    void update(int i, int diff) {\\n        int idx = i;\\n        while (idx <= N)\\n        {\\n            bitArr[idx] += diff;\\n            bitArr[idx] %= M;\\n            idx += idx & -idx;\\n        }\\n    }\\n\\n    long long getPreSum(int idx){\\n        long long ret = 0;\\n        while (idx){\\n            ret += bitArr[idx];\\n            ret %= M;\\n            idx -=  idx & -idx;\\n        }\\n        return ret;\\n    }\\n\\n    long long sumRange(int i, int j) {    \\n        return getPreSum(j)-getPreSum(i-1);\\n    } \\n};\\n\\nclass Solution {\\npublic:    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int n = nums1.size();\\n        unordered_map<int,int>Map;\\n        for (int i=0; i<n; i++)\\n            Map[nums1[i]] = i;\\n        \\n        for (int i=0; i<n; i++)\\n            nums2[i] = Map[nums2[i]]+1;\\n        \\n        vector<int>smallerBefore(n);\\n        BIT prefixBIT(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            smallerBefore[i] = prefixBIT.sumRange(1,nums2[i]-1);\\n            prefixBIT.update(nums2[i], 1);\\n        }\\n        \\n        vector<int>largerAfter(n);\\n        BIT suffixBIT(n);\\n        for (int i = n-1; i >= 0; i--)\\n        {\\n            largerAfter[i] = suffixBIT.sumRange(nums2[i]+1, n);\\n            suffixBIT.update(nums2[i], 1);\\n        }\\n        \\n        long long ret = 0; \\n        for (int i=0; i < n; i++)\\n            ret += (long long)smallerBefore[i] * largerAfter[i];\\n        return ret;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161420,
                "title": "merge-sort",
                "content": "\\nBuild array nums3 where nums3[i] = indexes[nums2[i]] and indexes[nums1[i]] = i. Then the problem looks like [https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/]. Solve it using merge sort.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void mergeSort(vector<int> &result, vector<int> &nums, vector<int>::iterator begin,vector<int>::iterator end) {\\n        if (end - begin <= 1)\\n            return;\\n        \\n        auto mid = begin + (end - begin)/2;\\n        mergeSort(result, nums, begin, mid);\\n        mergeSort(result, nums, mid, end);\\n        for (auto i = begin, j = mid; j != end; ++j) {\\n            while (i != mid && nums[*i] < nums[*j]) {\\n                ++i;\\n            }\\n            result[*j] += i - begin;\\n        }\\n\\n        std::inplace_merge(begin, mid, end, [&](auto i, auto j) {\\n            return nums[i] < nums[j];\\n        });\\n    }\\n\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        const int n = nums1.size();\\n        vector<int> indexes(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            indexes[nums1[i]] = i;\\n        }\\n        \\n        vector<int> nums3(n);\\n        for (int i = 0; i < n; ++i) {\\n            nums3[i] = indexes[nums2[i]];\\n        }\\n\\n        vector<int> smaller(n, 0);\\n        iota(indexes.begin(), indexes.end(), 0);\\n        mergeSort(smaller, nums3, indexes.begin(), indexes.end());\\n\\n        long long result = 0;\\n        for (int i = 1; i < n - 1; ++i) {\\n            long long left = smaller[i];\\n            long long right = n - nums3[i] - 1 - i + left;\\n            result += left * right;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void mergeSort(vector<int> &result, vector<int> &nums, vector<int>::iterator begin,vector<int>::iterator end) {\\n        if (end - begin <= 1)\\n            return;\\n        \\n        auto mid = begin + (end - begin)/2;\\n        mergeSort(result, nums, begin, mid);\\n        mergeSort(result, nums, mid, end);\\n        for (auto i = begin, j = mid; j != end; ++j) {\\n            while (i != mid && nums[*i] < nums[*j]) {\\n                ++i;\\n            }\\n            result[*j] += i - begin;\\n        }\\n\\n        std::inplace_merge(begin, mid, end, [&](auto i, auto j) {\\n            return nums[i] < nums[j];\\n        });\\n    }\\n\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        const int n = nums1.size();\\n        vector<int> indexes(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            indexes[nums1[i]] = i;\\n        }\\n        \\n        vector<int> nums3(n);\\n        for (int i = 0; i < n; ++i) {\\n            nums3[i] = indexes[nums2[i]];\\n        }\\n\\n        vector<int> smaller(n, 0);\\n        iota(indexes.begin(), indexes.end(), 0);\\n        mergeSort(smaller, nums3, indexes.begin(), indexes.end());\\n\\n        long long result = 0;\\n        for (int i = 1; i < n - 1; ++i) {\\n            long long left = smaller[i];\\n            long long right = n - nums3[i] - 1 - i + left;\\n            result += left * right;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153240,
                "title": "c-two-segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SegmentTree {\\n    long long* st;\\n\\npublic: \\n    SegmentTree(int size){\\n        st = (long long*)calloc(4*size, sizeof(long long));\\n    }\\n\\n    void pushUp(int node){\\n        st[node] = st[2*node+1] + st[2*node+2];\\n    }\\n\\n    void update(int index, long long value, int node, int l, int r){\\n        if( l == r ){\\n            st[node] += value;\\n            return;\\n        }\\n\\n        int mid = (l + r) / 2;\\n        if( index <= mid )\\n            update(index, value, 2*node+1, l, mid);\\n        else\\n            update(index, value, 2*node+2, mid+1, r);\\n\\n        pushUp(node);\\n    }\\n\\n    long long query(int qL, int qR, int node, int l, int r){\\n        if( qL <= l && r <= qR )\\n            return st[node];\\n\\n        int mid = (l + r) / 2;\\n        long long ans = 0;\\n        if( qL <= mid )\\n            ans += query(qL, qR, 2*node+1, l, mid);\\n        if( mid < qR )\\n            ans += query(qL, qR, 2*node+2, mid+1, r);\\n\\n        return ans;        \\n    }\\n\\n};\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int, int> val2_idx;\\n        for( int i = 0 ; i < nums2.size() ; i++ )\\n            val2_idx[nums2[i]] = i; // distinct\\n\\n        unordered_map<int, int> idx1_2;\\n        for( int i = 0 ; i < nums1.size() ; i++ )\\n            idx1_2[i] = val2_idx[nums1[i]];\\n        \\n        // O(NlogN), find ever smaller than me, first second: count\\n        SegmentTree* first = new SegmentTree(nums1.size());\\n        SegmentTree* second = new SegmentTree(nums1.size());\\n\\n        long long ans = 0;\\n        int l = 0, r = nums1.size();\\n        for( int i = 0 ; i < nums1.size() ; i++ ){\\n            // printf(\"i: %d, idx1_2: %d\\\\n\", i, idx1_2[i]);\\n            if( idx1_2[i] != 0 ){\\n                ans += second->query(0, idx1_2[i]-1, 0, l, r);\\n                long long can_be_i = first->query(0, idx1_2[i]-1, 0, l, r);\\n                second->update(idx1_2[i], can_be_i, 0, l, r);\\n            }\\n\\n            first->update(idx1_2[i], 1, 0, l, r);\\n        }\\n        return ans;\\n        \\n        // O(N^2)\\n        // vector<int> end_at(nums1.size(), 0);\\n        // for( int i = 0 ; i < nums1.size() ; i++ ){\\n        //     for( int j = i+1 ; j < nums1.size() ; j++ ){\\n        //         if( idx1_2[i] < idx1_2[j] )\\n        //             end_at[j]++;\\n        //     }\\n        // }\\n        // long long ans = 0;\\n        // for( int j = 0 ; j < nums1.size() ; j++ ){\\n        //     for( int k = j+1 ; k < nums1.size() ; k++ ){\\n        //         if( idx1_2[j] < idx1_2[k] )\\n        //             ans += end_at[j];\\n        //     }\\n        // }\\n\\n        // return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SegmentTree {\\n    long long* st;\\n\\npublic: \\n    SegmentTree(int size){\\n        st = (long long*)calloc(4*size, sizeof(long long));\\n    }\\n\\n    void pushUp(int node){\\n        st[node] = st[2*node+1] + st[2*node+2];\\n    }\\n\\n    void update(int index, long long value, int node, int l, int r){\\n        if( l == r ){\\n            st[node] += value;\\n            return;\\n        }\\n\\n        int mid = (l + r) / 2;\\n        if( index <= mid )\\n            update(index, value, 2*node+1, l, mid);\\n        else\\n            update(index, value, 2*node+2, mid+1, r);\\n\\n        pushUp(node);\\n    }\\n\\n    long long query(int qL, int qR, int node, int l, int r){\\n        if( qL <= l && r <= qR )\\n            return st[node];\\n\\n        int mid = (l + r) / 2;\\n        long long ans = 0;\\n        if( qL <= mid )\\n            ans += query(qL, qR, 2*node+1, l, mid);\\n        if( mid < qR )\\n            ans += query(qL, qR, 2*node+2, mid+1, r);\\n\\n        return ans;        \\n    }\\n\\n};\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int, int> val2_idx;\\n        for( int i = 0 ; i < nums2.size() ; i++ )\\n            val2_idx[nums2[i]] = i; // distinct\\n\\n        unordered_map<int, int> idx1_2;\\n        for( int i = 0 ; i < nums1.size() ; i++ )\\n            idx1_2[i] = val2_idx[nums1[i]];\\n        \\n        // O(NlogN), find ever smaller than me, first second: count\\n        SegmentTree* first = new SegmentTree(nums1.size());\\n        SegmentTree* second = new SegmentTree(nums1.size());\\n\\n        long long ans = 0;\\n        int l = 0, r = nums1.size();\\n        for( int i = 0 ; i < nums1.size() ; i++ ){\\n            // printf(\"i: %d, idx1_2: %d\\\\n\", i, idx1_2[i]);\\n            if( idx1_2[i] != 0 ){\\n                ans += second->query(0, idx1_2[i]-1, 0, l, r);\\n                long long can_be_i = first->query(0, idx1_2[i]-1, 0, l, r);\\n                second->update(idx1_2[i], can_be_i, 0, l, r);\\n            }\\n\\n            first->update(idx1_2[i], 1, 0, l, r);\\n        }\\n        return ans;\\n        \\n        // O(N^2)\\n        // vector<int> end_at(nums1.size(), 0);\\n        // for( int i = 0 ; i < nums1.size() ; i++ ){\\n        //     for( int j = i+1 ; j < nums1.size() ; j++ ){\\n        //         if( idx1_2[i] < idx1_2[j] )\\n        //             end_at[j]++;\\n        //     }\\n        // }\\n        // long long ans = 0;\\n        // for( int j = 0 ; j < nums1.size() ; j++ ){\\n        //     for( int k = j+1 ; k < nums1.size() ; k++ ){\\n        //         if( idx1_2[j] < idx1_2[k] )\\n        //             ans += end_at[j];\\n        //     }\\n        // }\\n\\n        // return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132181,
                "title": "c-ordered-set-solution",
                "content": "```\\n\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n \\n// Ordered Set Tree\\ntypedef tree<int, null_type, less<int>, rb_tree_tag,\\n             tree_order_statistics_node_update>\\n    ordered_set;\\n\\n// (long long int)\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int> mp;\\n        for(int i=0; i<nums2.size(); i++){\\n            mp[nums2[i]]=i;\\n        }\\n         \\n        ordered_set set1,set2;\\n        \\n        set1.insert(mp[nums1[0]]);\\n        \\n        for(int i=1; i<nums1.size(); i++){\\n            set2.insert(mp[nums1[i]]);\\n        }\\n        \\n        long long int ans = 0;\\n        \\n        for(int i=1; i<nums1.size()-1; i++){\\n            set2.erase(mp[nums1[i]]);\\n            set1.insert(mp[nums1[i]]);\\n            \\n            long long int left = (long long int)set1.order_of_key(mp[nums1[i]]);\\n            \\n            long long int right=0;\\n            \\n            if(set2.upper_bound(mp[nums1[i]])==set2.end())\\n                right=0;\\n            else right = (long long int)set2.size()-(long long int)set2.order_of_key(*set2.upper_bound(mp[nums1[i]]));\\n            // cout<<left<<\"-\"<<right<<endl;\\n            ans+=(left*right);\\n        }\\n        \\n        return ans;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n \\n// Ordered Set Tree\\ntypedef tree<int, null_type, less<int>, rb_tree_tag,\\n             tree_order_statistics_node_update>\\n    ordered_set;\\n\\n// (long long int)\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int> mp;\\n        for(int i=0; i<nums2.size(); i++){\\n            mp[nums2[i]]=i;\\n        }\\n         \\n        ordered_set set1,set2;\\n        \\n        set1.insert(mp[nums1[0]]);\\n        \\n        for(int i=1; i<nums1.size(); i++){\\n            set2.insert(mp[nums1[i]]);\\n        }\\n        \\n        long long int ans = 0;\\n        \\n        for(int i=1; i<nums1.size()-1; i++){\\n            set2.erase(mp[nums1[i]]);\\n            set1.insert(mp[nums1[i]]);\\n            \\n            long long int left = (long long int)set1.order_of_key(mp[nums1[i]]);\\n            \\n            long long int right=0;\\n            \\n            if(set2.upper_bound(mp[nums1[i]])==set2.end())\\n                right=0;\\n            else right = (long long int)set2.size()-(long long int)set2.order_of_key(*set2.upper_bound(mp[nums1[i]]));\\n            // cout<<left<<\"-\"<<right<<endl;\\n            ans+=(left*right);\\n        }\\n        \\n        return ans;\\n    }\\n}; \\n```",
                "codeTag": "C++"
            },
            {
                "id": 3073621,
                "title": "count-good-triplets-in-an-array",
                "content": "# Code\\n```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        N = len(nums1)\\n        BIT = [0] * (N+1)\\n        nums = [0] * N\\n        num1 = [0] * N\\n        num2 = [0] * N\\n        for i, n in enumerate(nums1):\\n            num1[n]=i\\n        for i, n in enumerate(nums2):\\n            num2[n]=i\\n        for i, n in enumerate(num1):\\n            nums[n] = num2[i]\\n        def lowbit(i):\\n            return i&(-i)\\n        def add(i):\\n            i+=1\\n            while i <= N:\\n                BIT[i]+=1\\n                i+=lowbit(i)\\n        def query(i):\\n            i += 1\\n            re = 0\\n            while i:\\n                re += BIT[i]\\n                i -= lowbit(i)\\n            return re\\n        smaller = []\\n        bigger = []\\n        for i, n in enumerate(nums):\\n            smaller.append(query(n))\\n            bigger.append(N-1-i-n+smaller[-1])\\n            add(n)\\n        return sum(i*j for i, j in zip(smaller, bigger))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        N = len(nums1)\\n        BIT = [0] * (N+1)\\n        nums = [0] * N\\n        num1 = [0] * N\\n        num2 = [0] * N\\n        for i, n in enumerate(nums1):\\n            num1[n]=i\\n        for i, n in enumerate(nums2):\\n            num2[n]=i\\n        for i, n in enumerate(num1):\\n            nums[n] = num2[i]\\n        def lowbit(i):\\n            return i&(-i)\\n        def add(i):\\n            i+=1\\n            while i <= N:\\n                BIT[i]+=1\\n                i+=lowbit(i)\\n        def query(i):\\n            i += 1\\n            re = 0\\n            while i:\\n                re += BIT[i]\\n                i -= lowbit(i)\\n            return re\\n        smaller = []\\n        bigger = []\\n        for i, n in enumerate(nums):\\n            smaller.append(query(n))\\n            bigger.append(N-1-i-n+smaller[-1])\\n            add(n)\\n        return sum(i*j for i, j in zip(smaller, bigger))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073570,
                "title": "pbds-easiest-and-smallest-solution-c",
                "content": "**Approach:**\\n1) First of all we will store index of elements of vector 1 in a map\\n2) Then we will traverse through each element of 2nd vector\\n3) And for every element we have to find number of indexes which are less than the index of current element in 1st vector.\\n4) For that purpose we will use PBDS which give rank of the ( present elements index in first vector )\\n5) First i tried using set and std::distance function it gives tle as std::distance takes o(n) time but PBDS just takes o(n) time making the whole algorithms o(n\\\\*logn)\\n6) using this we will get left side common elements.\\n7) to get right we can do this \\n\\t* \\ti-left[i] gives uncommon in left side\\n\\t* \\t(n-m[nums2[i]]-1)-d gives total in right - uncommon which occured in left (it gives common in right)\\n8) multiplying these both gives the answer for that element \\n9) in similar we will do for all elements by assuming its the center value;\\n\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n  \\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\ntypedef long long int lli;\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        \\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++){\\n            m[nums1[i]] = i;\\n        }\\n        \\n        vector<int> left(n,0);\\n        ordered_set s;\\n        long long int ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int val = s.order_of_key(m[nums2[i]]);\\n            left[i] = val;\\n            int d = i-left[i];\\n            int loc = (n-m[nums2[i]]-1)-d;\\n            ans += (lli)left[i]*loc;\\n            s.insert(m[nums2[i]]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nPlease UPVOTE  \\u2764\\uFE0F if it is helpful.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Indexed Tree"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n  \\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\ntypedef long long int lli;\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        \\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++){\\n            m[nums1[i]] = i;\\n        }\\n        \\n        vector<int> left(n,0);\\n        ordered_set s;\\n        long long int ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int val = s.order_of_key(m[nums2[i]]);\\n            left[i] = val;\\n            int d = i-left[i];\\n            int loc = (n-m[nums2[i]]-1)-d;\\n            ans += (lli)left[i]*loc;\\n            s.insert(m[nums2[i]]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3066395,
                "title": "javascript-segmenttreersq-range-sum-query-305ms",
                "content": "```\\nfunction SegmentTreeRSQ(n) {\\n    let h = Math.ceil(Math.log2(n)), len = 2 * 2 ** h, a = Array(len).fill(0);\\n    return { update, query, rangeSum, tree }\\n    function update(pos, v) {\\n        a[n + pos] = v;\\n        for (let i = parent(n + pos); i >= 1; i = parent(i)) pushup(i);\\n    }\\n    function pushup(i) {\\n        a[i] = a[left(i)] +  a[right(i)];\\n    }\\n    function query(l, r) { // [L, R)\\n        let sum = 0;\\n        if (l >= r) return 0;\\n        l += n;\\n        r += n;\\n        for (; l < r; l = parent(l), r = parent(r)) {\\n            if (l & 1) sum += a[l++];\\n            if (r & 1) sum += a[--r];\\n        }\\n        return sum;\\n    }\\n    function rangeSum(l, r) {\\n        let lsum = query(0, l), rsum = query(0, r + 1);\\n        return rsum - lsum;\\n    }\\n    function parent(i) {\\n        return i >> 1;\\n    }\\n    function left(i) {\\n        return 2 * i;\\n    }\\n    function right(i) {\\n        return 2 * i + 1;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nconst goodTriplets = (a, b) => {\\n    let n = a.length, m = new Map(), res = 0, st = new SegmentTreeRSQ(n + 3), f = Array(n + 1).fill(0);\\n    for (let i = 0; i < n; i++) m.set(b[i], i);\\n    for (let i = 0; i < n; i++) {\\n       let pos = m.get(a[i]);\\n       let l = st.rangeSum(0, pos), r = (n - 1 - pos) - st.rangeSum(pos, n - 1);\\n       res += l * r;\\n       st.update(pos, ++f[pos]);\\n    }\\n    return res;\\n};\\n\\n```\\nfenwick solution: https://leetcode.com/problems/count-good-triplets-in-an-array/solutions/1783636/javascript-fenwick-treeBIT-219ms/\\n",
                "solutionTags": [
                    "JavaScript",
                    "Segment Tree"
                ],
                "code": "```\\nfunction SegmentTreeRSQ(n) {\\n    let h = Math.ceil(Math.log2(n)), len = 2 * 2 ** h, a = Array(len).fill(0);\\n    return { update, query, rangeSum, tree }\\n    function update(pos, v) {\\n        a[n + pos] = v;\\n        for (let i = parent(n + pos); i >= 1; i = parent(i)) pushup(i);\\n    }\\n    function pushup(i) {\\n        a[i] = a[left(i)] +  a[right(i)];\\n    }\\n    function query(l, r) { // [L, R)\\n        let sum = 0;\\n        if (l >= r) return 0;\\n        l += n;\\n        r += n;\\n        for (; l < r; l = parent(l), r = parent(r)) {\\n            if (l & 1) sum += a[l++];\\n            if (r & 1) sum += a[--r];\\n        }\\n        return sum;\\n    }\\n    function rangeSum(l, r) {\\n        let lsum = query(0, l), rsum = query(0, r + 1);\\n        return rsum - lsum;\\n    }\\n    function parent(i) {\\n        return i >> 1;\\n    }\\n    function left(i) {\\n        return 2 * i;\\n    }\\n    function right(i) {\\n        return 2 * i + 1;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nconst goodTriplets = (a, b) => {\\n    let n = a.length, m = new Map(), res = 0, st = new SegmentTreeRSQ(n + 3), f = Array(n + 1).fill(0);\\n    for (let i = 0; i < n; i++) m.set(b[i], i);\\n    for (let i = 0; i < n; i++) {\\n       let pos = m.get(a[i]);\\n       let l = st.rangeSum(0, pos), r = (n - 1 - pos) - st.rangeSum(pos, n - 1);\\n       res += l * r;\\n       st.update(pos, ++f[pos]);\\n    }\\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3042382,
                "title": "ordered-set-c-simple-clean-short-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();ll answer=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++) mp[nums1[i]]=i;\\n        vector<int>nums(n);\\n        for(int i=0;i<n;i++) nums[i]=mp[nums2[i]];\\n        ordered_set ss;\\n        ss.insert(nums[0]);\\n        for(ll i=1;i<n;i++){\\n            ll count1=ss.order_of_key(nums[i]),count2=(n-i-1-(nums[i]-count1));\\n            answer+=(count1*count2);\\n            ss.insert(nums[i]);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();ll answer=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++) mp[nums1[i]]=i;\\n        vector<int>nums(n);\\n        for(int i=0;i<n;i++) nums[i]=mp[nums2[i]];\\n        ordered_set ss;\\n        ss.insert(nums[0]);\\n        for(ll i=1;i<n;i++){\\n            ll count1=ss.order_of_key(nums[i]),count2=(n-i-1-(nums[i]-count1));\\n            answer+=(count1*count2);\\n            ss.insert(nums[i]);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3026609,
                "title": "java-solution-segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SegmentTree{\\n    long[] seg;\\n    long[] arr;\\n    int n;\\n\\n    SegmentTree(int n){\\n        this.n=n;\\n        seg = new long[4*n+1];\\n        build(1, n, 1);\\n    }\\n\\n    void build(long l, long r, long c){\\n        if(l == r){\\n            seg[(int)c] = 0;\\n            return;\\n        }\\n        long mid = l+(r-l)/2;\\n        build(l,mid,2*c);\\n        build(mid+1,r,2*c+1);\\n        seg[(int)c] = seg[2*(int)c]+seg[2*(int)c+1];\\n    }\\n\\n    long query(long l,long r,long a,long b,long c){\\n        if(l>b || r<a){\\n            return 0;\\n        }\\n        if(l>=a && r<=b){\\n            return seg[(int)c];\\n        }\\n        long mid = l+(r-l)/2;\\n        return query(l,mid,a,b,2*c)+query(mid+1,r,a,b,2*c+1);\\n    }\\n\\n    void update(long l,long r, long ind, long c){\\n        if(ind<l || r<ind){\\n            return;\\n        }\\n        if(l == r && l == ind){\\n            seg[(int)c] = 1;\\n            return;\\n        }\\n        long mid = l+(r-l)/2;\\n        update(l,mid,ind,2*c);\\n        update(mid+1,r,ind,2*c+1);\\n        seg[(int)c] = seg[2*(int)c]+seg[2*(int)c+1];   \\n    }\\n}\\nclass Solution {\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        long ans = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            map.put(nums2[i]+1, i+1);\\n        }\\n        SegmentTree tree = new SegmentTree(n);\\n        for(int i=1;i<=n;i++){\\n            long r = map.get(nums1[i-1]+1);\\n            long q = tree.query(1,n,1,r,1);\\n            long d = i-q-1;\\n            long e = n-r-d;\\n            ans += e*q;\\n            tree.update(1,n,r,1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Segment Tree",
                    "Hash Function"
                ],
                "code": "```\\nclass SegmentTree{\\n    long[] seg;\\n    long[] arr;\\n    int n;\\n\\n    SegmentTree(int n){\\n        this.n=n;\\n        seg = new long[4*n+1];\\n        build(1, n, 1);\\n    }\\n\\n    void build(long l, long r, long c){\\n        if(l == r){\\n            seg[(int)c] = 0;\\n            return;\\n        }\\n        long mid = l+(r-l)/2;\\n        build(l,mid,2*c);\\n        build(mid+1,r,2*c+1);\\n        seg[(int)c] = seg[2*(int)c]+seg[2*(int)c+1];\\n    }\\n\\n    long query(long l,long r,long a,long b,long c){\\n        if(l>b || r<a){\\n            return 0;\\n        }\\n        if(l>=a && r<=b){\\n            return seg[(int)c];\\n        }\\n        long mid = l+(r-l)/2;\\n        return query(l,mid,a,b,2*c)+query(mid+1,r,a,b,2*c+1);\\n    }\\n\\n    void update(long l,long r, long ind, long c){\\n        if(ind<l || r<ind){\\n            return;\\n        }\\n        if(l == r && l == ind){\\n            seg[(int)c] = 1;\\n            return;\\n        }\\n        long mid = l+(r-l)/2;\\n        update(l,mid,ind,2*c);\\n        update(mid+1,r,ind,2*c+1);\\n        seg[(int)c] = seg[2*(int)c]+seg[2*(int)c+1];   \\n    }\\n}\\nclass Solution {\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        long ans = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            map.put(nums2[i]+1, i+1);\\n        }\\n        SegmentTree tree = new SegmentTree(n);\\n        for(int i=1;i<=n;i++){\\n            long r = map.get(nums1[i-1]+1);\\n            long q = tree.query(1,n,1,r,1);\\n            long d = i-q-1;\\n            long e = n-r-d;\\n            ans += e*q;\\n            tree.update(1,n,r,1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025377,
                "title": "2-solution-ordered-set-segment-tree-o-nlogn-c",
                "content": "\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code (ordered_set)\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n  \\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n\\n        ll n = nums1.size();\\n        vector<ll>pos(n);\\n        for(ll i=0;i<n;i++){\\n            pos[nums2[i]] = i;\\n        }\\n\\n        ordered_set s;\\n        ll ans = 0;\\n\\n        vector<ll>pref(n),suff(n);\\n\\n        for(ll i=0;i<n;i++){\\n            ll curr_pos = pos[nums1[i]];\\n\\n            pref[i] = s.order_of_key(curr_pos);\\n\\n            s.insert(pos[nums1[i]]);\\n        }\\n\\n        s.clear();\\n\\n        for(ll i=n-1;i>=0;i--){\\n            ll curr_pos = pos[nums1[i]];\\n            suff[i] = s.size() - s.order_of_key(curr_pos);\\n            s.insert(pos[nums1[i]]);\\n        }\\n\\n        for(ll i=1;i<n-1;i++){\\n            ans += pref[i]*suff[i];\\n        }\\n        return ans;       \\n    }\\n};\\n\\n```\\n\\n# Code (segment_tree)\\n```\\ntypedef long long ll;\\nvector<ll>seg;\\nvector<ll>v;\\nint n;\\n\\n\\nvoid build(ll l, ll r, ll c = 1){\\n    if(l == r){\\n        seg[c] = v[l];\\n        return;\\n    }\\n    ll mid = (l+r)/2;\\n    build(l,mid,2*c);\\n    build(mid+1,r,2*c+1);\\n    seg[c] = seg[2*c]+seg[2*c+1];\\n    return;\\n}\\n\\nll query(ll l,ll r,ll a,ll b,ll c = 1){\\n    if(l>b || r<a){\\n        return 0;\\n    }\\n    if(l>=a and r<=b){\\n        return seg[c];\\n    }\\n    ll mid = (l+r)/2;\\n    return query(l,mid,a,b,2*c)+query(mid+1,r,a,b,2*c+1);\\n}\\n\\nvoid update(ll l,ll r, ll ind, ll c=1){\\n    if(ind<l || r<ind){\\n        return;\\n    }\\n    if(l == r and l == ind){\\n        seg[c] = 1;\\n        return;\\n    }\\n    ll mid = (l+r)/2;\\n    update(l,mid,ind,2*c);\\n    update(mid+1,r,ind,2*c+1);\\n    seg[c] = seg[2*c]+seg[2*c+1];    \\n}\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        ll n = nums1.size();\\n        v.resize(n+1,0);\\n        ll ans = 0;\\n        map<ll,ll>mp;\\n        for(ll i=0;i<n;i++){\\n            mp[nums2[i]+1] = i+1;\\n        }\\n        seg.clear();\\n        seg.resize(4*n+1,0);\\n        build(1,n);\\n        for(int i=1;i<=n;i++){\\n            ll r = mp[nums1[i-1]+1];\\n            ll q = query(1,n,1,r);\\n            ll d = i-q-1;\\n            ll e = n-r-d;\\n            ans += e*q;\\n            update(1,n,r);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# upvote if it\\'s help you HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "Segment Tree",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n  \\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n\\n        ll n = nums1.size();\\n        vector<ll>pos(n);\\n        for(ll i=0;i<n;i++){\\n            pos[nums2[i]] = i;\\n        }\\n\\n        ordered_set s;\\n        ll ans = 0;\\n\\n        vector<ll>pref(n),suff(n);\\n\\n        for(ll i=0;i<n;i++){\\n            ll curr_pos = pos[nums1[i]];\\n\\n            pref[i] = s.order_of_key(curr_pos);\\n\\n            s.insert(pos[nums1[i]]);\\n        }\\n\\n        s.clear();\\n\\n        for(ll i=n-1;i>=0;i--){\\n            ll curr_pos = pos[nums1[i]];\\n            suff[i] = s.size() - s.order_of_key(curr_pos);\\n            s.insert(pos[nums1[i]]);\\n        }\\n\\n        for(ll i=1;i<n-1;i++){\\n            ans += pref[i]*suff[i];\\n        }\\n        return ans;       \\n    }\\n};\\n\\n```\n```\\ntypedef long long ll;\\nvector<ll>seg;\\nvector<ll>v;\\nint n;\\n\\n\\nvoid build(ll l, ll r, ll c = 1){\\n    if(l == r){\\n        seg[c] = v[l];\\n        return;\\n    }\\n    ll mid = (l+r)/2;\\n    build(l,mid,2*c);\\n    build(mid+1,r,2*c+1);\\n    seg[c] = seg[2*c]+seg[2*c+1];\\n    return;\\n}\\n\\nll query(ll l,ll r,ll a,ll b,ll c = 1){\\n    if(l>b || r<a){\\n        return 0;\\n    }\\n    if(l>=a and r<=b){\\n        return seg[c];\\n    }\\n    ll mid = (l+r)/2;\\n    return query(l,mid,a,b,2*c)+query(mid+1,r,a,b,2*c+1);\\n}\\n\\nvoid update(ll l,ll r, ll ind, ll c=1){\\n    if(ind<l || r<ind){\\n        return;\\n    }\\n    if(l == r and l == ind){\\n        seg[c] = 1;\\n        return;\\n    }\\n    ll mid = (l+r)/2;\\n    update(l,mid,ind,2*c);\\n    update(mid+1,r,ind,2*c+1);\\n    seg[c] = seg[2*c]+seg[2*c+1];    \\n}\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        ll n = nums1.size();\\n        v.resize(n+1,0);\\n        ll ans = 0;\\n        map<ll,ll>mp;\\n        for(ll i=0;i<n;i++){\\n            mp[nums2[i]+1] = i+1;\\n        }\\n        seg.clear();\\n        seg.resize(4*n+1,0);\\n        build(1,n);\\n        for(int i=1;i<=n;i++){\\n            ll r = mp[nums1[i-1]+1];\\n            ll q = query(1,n,1,r);\\n            ll d = i-q-1;\\n            ll e = n-r-d;\\n            ans += e*q;\\n            update(1,n,r);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2784139,
                "title": "segment-tree-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSegment Tree\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int M;\\n    vector<int> ST;\\n    void update(int i, int val = 1) {\\n        i += M;\\n        ST[i] += val;\\n        while(i > 1) {\\n            i /= 2;\\n            ST[i] = ST[2*i] + ST[2*i+1];\\n        }\\n    }\\n    int getSum(int l, int r) {\\n        int res = 0;\\n        for (l += M, r += M; l < r; l /= 2, r /= 2) {\\n            if (l % 2) {\\n                res += ST[l++];\\n            }\\n            if (r % 2) {\\n                res += ST[--r];\\n            }\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int N = nums1.size();\\n        vector<int> id(N);\\n        for (int i = 0; i < N; i++) {\\n            id[nums2[i]] = i;\\n        }\\n        \\n        M = N;\\n        ST.resize(2*M);\\n        \\n        long res = 0;\\n        for (int i = 0; i < N; i++) {\\n            // replace num as index in nums2\\n            int num = id[nums1[i]];\\n            \\n            long smaller = getSum(0, num); // smaller index on the left\\n            long bigger = N - 1 - num - (i - smaller); // bigger index on the right\\n            res += smaller * bigger; // monotonic increasing triplets \\n            \\n            update(num);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int M;\\n    vector<int> ST;\\n    void update(int i, int val = 1) {\\n        i += M;\\n        ST[i] += val;\\n        while(i > 1) {\\n            i /= 2;\\n            ST[i] = ST[2*i] + ST[2*i+1];\\n        }\\n    }\\n    int getSum(int l, int r) {\\n        int res = 0;\\n        for (l += M, r += M; l < r; l /= 2, r /= 2) {\\n            if (l % 2) {\\n                res += ST[l++];\\n            }\\n            if (r % 2) {\\n                res += ST[--r];\\n            }\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int N = nums1.size();\\n        vector<int> id(N);\\n        for (int i = 0; i < N; i++) {\\n            id[nums2[i]] = i;\\n        }\\n        \\n        M = N;\\n        ST.resize(2*M);\\n        \\n        long res = 0;\\n        for (int i = 0; i < N; i++) {\\n            // replace num as index in nums2\\n            int num = id[nums1[i]];\\n            \\n            long smaller = getSum(0, num); // smaller index on the left\\n            long bigger = N - 1 - num - (i - smaller); // bigger index on the right\\n            res += smaller * bigger; // monotonic increasing triplets \\n            \\n            update(num);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767275,
                "title": "faster-than-80",
                "content": "#define ll long long\\n\\nclass Solution \\n{\\n    \\n    vector<ll> bit1, bit2;\\n    \\n    void add(vector<ll>& bit, int i, int val)\\n    {\\n        i++;\\n        while( i<bit.size() )\\n        {\\n            bit[i]+=val;\\n            i+=i&(-i);\\n        }\\n    }\\n    \\n    ll get( vector<ll>& bit, int i)\\n    {\\n        i++;\\n        ll res=0;\\n        while(i>0)\\n        {\\n            res+=bit[i];\\n            i-=i&(-i);\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int n=nums1.size();\\n        vector<int> ind(n);\\n        bit1=vector<ll> (n+1);\\n        bit2=vector<ll> (n+1);\\n        for(int i=0;i<nums1.size();i++) ind[ nums1[i] ]=i;\\n        ll ans=0;\\n        for(int x: nums2  )\\n        {\\n            ans+=get( bit2, ind[x]-1 );\\n            ll cnt=get( bit1, ind[x]-1 );\\n            add( bit2, ind[x] , cnt );\\n            add( bit1, ind[x] , 1 );\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution \\n{\\n    \\n    vector<ll> bit1, bit2;\\n    \\n    void add(vector<ll>& bit, int i, int val)\\n    {\\n        i++;\\n        while( i<bit.size() )\\n        {\\n            bit[i]+=val;\\n            i+=i&(-i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2698598,
                "title": "java-3-solutions-binary-index-tree",
                "content": "# 3.Binary Index Tree\\n```\\n    //3.Binary Index Tree\\n    //Runtime: 16 ms, faster than 95.71% of Java online submissions for Count Good Triplets in an Array.\\n    //Memory Usage: 83.6 MB, less than 51.43% of Java online submissions for Count Good Triplets in an Array.\\n    //Time: O(N * LogN); Space: O(N)\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        long res = 0;\\n\\n        int[] pos = new int[nums1.length];\\n        for (int i = 0; i < nums1.length; i++) pos[nums2[i]] = i;\\n\\n        FenwickTree fenwickTree = new FenwickTree(nums1.length);\\n        for (int i = 0; i < nums1.length; i++){\\n            int idx = pos[nums1[i]];\\n            long left = fenwickTree.queryBIT(idx);\\n            long right = nums1.length - 1 - idx - (i - left);\\n            res += left * right;\\n\\n            fenwickTree.updateBIT(idx + 1, 1);\\n        }\\n\\n        return res;\\n    }\\n\\n    //Binary Index Tree / Fenwick Tree\\n    class FenwickTree {\\n\\n        private int[] tree;\\n        public FenwickTree(int n){\\n            tree = new int[n + 2];\\n        }\\n\\n        private int lsb(int i){\\n            return i &(-i);\\n        }\\n        public int queryBIT(int i){\\n            int sum = 0;\\n            for (; i > 0; i -= lsb(i)) sum += tree[i];\\n            return sum;\\n        }\\n        public void updateBIT(int i, int val){\\n            for (; i < tree.length; i += lsb(i)) tree[i] += val;\\n        }\\n    }\\n\\n```\\n# 2.Binary Index Tree X 2\\n```\\n    //2.Binary Index Tree X 2\\n    //Runtime: 22 ms, faster than 90.00% of Java online submissions for Count Good Triplets in an Array.\\n    //Memory Usage: 56.6 MB, less than 95.71% of Java online submissions for Count Good Triplets in an Array.\\n    //Time: O(N * LogN); Space: O(N)\\n    public long goodTriplets_2(int[] nums1, int[] nums2) {\\n        long res = 0;\\n        long[] left = new long[nums1.length];\\n        long[] right = new long[nums1.length];\\n\\n        int[] pos = new int[nums1.length];\\n        for (int i = 0; i < nums1.length; i++) pos[nums2[i]] = i;\\n\\n        FenwickTree fenwickTree = new FenwickTree(nums1.length);\\n        for (int i = 0; i < nums1.length; i++){\\n            int idx = pos[nums1[i]] + 1;\\n            left[i] = fenwickTree.queryBIT(idx - 1);\\n            fenwickTree.updateBIT(idx, 1);\\n        }\\n\\n        fenwickTree = new FenwickTree(nums1.length);\\n        for (int i = nums1.length - 1; i >= 0; i--){\\n            int idx = pos[nums1[i]] + 1;\\n            int currTotal = nums1.length - 1 - i;\\n            right[i] = currTotal - fenwickTree.queryBIT(idx);\\n            fenwickTree.updateBIT(idx, 1);\\n        }\\n\\n        for (int i = 0; i < nums1.length; i++)\\n            res += left[i] * right[i];\\n        return res;\\n    }\\n\\n\\t//Binary Index Tree / Fenwick Tree\\n    class FenwickTree {\\n\\n        private int[] tree;\\n        public FenwickTree(int n){\\n            tree = new int[n + 2];\\n        }\\n\\n        private int lsb(int i){\\n            return i &(-i);\\n        }\\n        public int queryBIT(int i){\\n            int sum = 0;\\n            for (; i > 0; i -= lsb(i)) sum += tree[i];\\n            return sum;\\n        }\\n        public void updateBIT(int i, int val){\\n            for (; i < tree.length; i += lsb(i)) tree[i] += val;\\n        }\\n    }\\n```\\n# 1.Brute Force\\n```\\n    //1.Brute Force\\n    //TLE\\n    //Time: O(N ^ 2); Space: O(N)\\n    public long goodTriplets_1(int[] nums1, int[] nums2) {\\n        long res = 0;\\n\\n        int[] pos = new int[nums1.length];\\n        for (int i = 0; i < nums2.length; i++) pos[nums2[i]] = i;\\n\\n        for (int i = 1; i < nums1.length - 1; i++) {\\n            int mid = pos[nums1[i]];\\n            int countLeft = 0, countRight = 0;\\n            for (int j = 0; j < i; j++) if (pos[nums1[j]] < mid) countLeft++;\\n            for (int j = i + 1; j < nums1.length; j++) if (pos[nums1[j]] > mid) countRight++;\\n\\n            res += countLeft * countRight;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Indexed Tree"
                ],
                "code": "```\\n    //3.Binary Index Tree\\n    //Runtime: 16 ms, faster than 95.71% of Java online submissions for Count Good Triplets in an Array.\\n    //Memory Usage: 83.6 MB, less than 51.43% of Java online submissions for Count Good Triplets in an Array.\\n    //Time: O(N * LogN); Space: O(N)\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        long res = 0;\\n\\n        int[] pos = new int[nums1.length];\\n        for (int i = 0; i < nums1.length; i++) pos[nums2[i]] = i;\\n\\n        FenwickTree fenwickTree = new FenwickTree(nums1.length);\\n        for (int i = 0; i < nums1.length; i++){\\n            int idx = pos[nums1[i]];\\n            long left = fenwickTree.queryBIT(idx);\\n            long right = nums1.length - 1 - idx - (i - left);\\n            res += left * right;\\n\\n            fenwickTree.updateBIT(idx + 1, 1);\\n        }\\n\\n        return res;\\n    }\\n\\n    //Binary Index Tree / Fenwick Tree\\n    class FenwickTree {\\n\\n        private int[] tree;\\n        public FenwickTree(int n){\\n            tree = new int[n + 2];\\n        }\\n\\n        private int lsb(int i){\\n            return i &(-i);\\n        }\\n        public int queryBIT(int i){\\n            int sum = 0;\\n            for (; i > 0; i -= lsb(i)) sum += tree[i];\\n            return sum;\\n        }\\n        public void updateBIT(int i, int val){\\n            for (; i < tree.length; i += lsb(i)) tree[i] += val;\\n        }\\n    }\\n\\n```\n```\\n    //2.Binary Index Tree X 2\\n    //Runtime: 22 ms, faster than 90.00% of Java online submissions for Count Good Triplets in an Array.\\n    //Memory Usage: 56.6 MB, less than 95.71% of Java online submissions for Count Good Triplets in an Array.\\n    //Time: O(N * LogN); Space: O(N)\\n    public long goodTriplets_2(int[] nums1, int[] nums2) {\\n        long res = 0;\\n        long[] left = new long[nums1.length];\\n        long[] right = new long[nums1.length];\\n\\n        int[] pos = new int[nums1.length];\\n        for (int i = 0; i < nums1.length; i++) pos[nums2[i]] = i;\\n\\n        FenwickTree fenwickTree = new FenwickTree(nums1.length);\\n        for (int i = 0; i < nums1.length; i++){\\n            int idx = pos[nums1[i]] + 1;\\n            left[i] = fenwickTree.queryBIT(idx - 1);\\n            fenwickTree.updateBIT(idx, 1);\\n        }\\n\\n        fenwickTree = new FenwickTree(nums1.length);\\n        for (int i = nums1.length - 1; i >= 0; i--){\\n            int idx = pos[nums1[i]] + 1;\\n            int currTotal = nums1.length - 1 - i;\\n            right[i] = currTotal - fenwickTree.queryBIT(idx);\\n            fenwickTree.updateBIT(idx, 1);\\n        }\\n\\n        for (int i = 0; i < nums1.length; i++)\\n            res += left[i] * right[i];\\n        return res;\\n    }\\n\\n\\t//Binary Index Tree / Fenwick Tree\\n    class FenwickTree {\\n\\n        private int[] tree;\\n        public FenwickTree(int n){\\n            tree = new int[n + 2];\\n        }\\n\\n        private int lsb(int i){\\n            return i &(-i);\\n        }\\n        public int queryBIT(int i){\\n            int sum = 0;\\n            for (; i > 0; i -= lsb(i)) sum += tree[i];\\n            return sum;\\n        }\\n        public void updateBIT(int i, int val){\\n            for (; i < tree.length; i += lsb(i)) tree[i] += val;\\n        }\\n    }\\n```\n```\\n    //1.Brute Force\\n    //TLE\\n    //Time: O(N ^ 2); Space: O(N)\\n    public long goodTriplets_1(int[] nums1, int[] nums2) {\\n        long res = 0;\\n\\n        int[] pos = new int[nums1.length];\\n        for (int i = 0; i < nums2.length; i++) pos[nums2[i]] = i;\\n\\n        for (int i = 1; i < nums1.length - 1; i++) {\\n            int mid = pos[nums1[i]];\\n            int countLeft = 0, countRight = 0;\\n            for (int j = 0; j < i; j++) if (pos[nums1[j]] < mid) countLeft++;\\n            for (int j = i + 1; j < nums1.length; j++) if (pos[nums1[j]] > mid) countRight++;\\n\\n            res += countLeft * countRight;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692452,
                "title": "ordered-set-c-accepted-solution",
                "content": "\\n```\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& a, vector<int>& b) {\\n       vector<int>m(a.size()+1);\\n       ordered_set o,after;\\n       vector<pair<int,int>>v;\\n       long long ans=0;\\n       for(int i=0;i<a.size();i++)m[a[i]]=i;\\n       for(int i=0;i<b.size();i++)v.push_back({m[b[i]],i});\\n        sort(v.begin(),v.end());\\n        long long c=0;\\n        for(auto &it:v)after.insert(it.second);\\n        for(int i=0;i<a.size();i++){\\n            after.erase(v[i].second);\\n            o.insert(v[i].second);\\n            long long inAfter = after.size() - after.order_of_key(v[i].second);\\n            long long inO=o.order_of_key(v[i].second);\\n            ans+=(inAfter*inO);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& a, vector<int>& b) {\\n       vector<int>m(a.size()+1);\\n       ordered_set o,after;\\n       vector<pair<int,int>>v;\\n       long long ans=0;\\n       for(int i=0;i<a.size();i++)m[a[i]]=i;\\n       for(int i=0;i<b.size();i++)v.push_back({m[b[i]],i});\\n        sort(v.begin(),v.end());\\n        long long c=0;\\n        for(auto &it:v)after.insert(it.second);\\n        for(int i=0;i<a.size();i++){\\n            after.erase(v[i].second);\\n            o.insert(v[i].second);\\n            long long inAfter = after.size() - after.order_of_key(v[i].second);\\n            long long inO=o.order_of_key(v[i].second);\\n            ans+=(inAfter*inO);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2691891,
                "title": "two-bits-for-1-digit-and-2-digit-subsequences-commented-python",
                "content": "Comments in the code.\\n\\n```\\nimport numpy as np\\n\\n# various ways of inverting a permutation. Best guess that the last one is the fastest.\\ndef invert_permutation_list_scan(p):\\n    return [p.index(l) for l in range(len(p))]\\n\\ndef invert_permutation_list_comp(permutation):\\n    return [i for i, j in sorted(enumerate(permutation), key=lambda i_j: i_j[1])]\\n\\ndef invert_permutation_numpy(permutation):\\n    return np.argsort(permutation)\\n\\ndef invert_permutation_numpy2(permutation):\\n    inv = np.empty_like(permutation)\\n    inv[permutation] = np.arange(len(inv), dtype=inv.dtype)\\n    return inv\\n\\n# A class defining Binary Indexed Tree:\\nclass BIT:\\n    def __init__(self, maxN):\\n        self.maxN = maxN\\n        self.bit = [0] * maxN\\n    def prefSum(self, n):\\n\\t\\'\\'\\' return prefix sum\\'\\'\\'\\n        ret = 0\\n        while n > 0:\\n            ret += self.bit[n]\\n            n -= n & (-n)\\n        return ret\\n    def insert(self, v, delta):\\n        while v < self.maxN:\\n            self.bit[v] += delta\\n            v += v & (-v)\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n\\t\\t# We have 3 permutations. The central one is the identity P_0 = [0, ..., n-1]. P_1 = nums1\\n\\t\\t# and P_2 = nums2 are remaining two permutations. Reverting the second permutation \\n\\t\\t# and chaining it with the first permutation P_1 * P^{-1}_0 = P\\'is the permutation we should\\n\\t\\t# study. We are asking how many triples (i, j, k indices) with growing values P\\' has.\\n        perm = invert_permutation_numpy2(nums2)[np.array(nums1)]\\n        ret = 0 # return value\\n        a = BIT(int(1e5+1))  # a BIT for 1-digit subsequences, storing their end values\\n        b = BIT(int(1e5+1))  # a Bit for 2-digit subsequences, storing values of second digits\\n        for v in perm:\\n\\t\\t\\t# finish 2-digit subsequences with this (v) last digit\\n            ret += b.prefSum(v)\\n\\t\\t\\t# count how many 1-digit subsequences it extends to two digit, v being the second digit\\n            cnt = a.prefSum(v)\\n\\t\\t\\t# update 2-digit number, v+1 because BIT stores only positive numbers. \\n\\t\\t\\t# Above v is also a short way of saying (v - 1) + 1, because the previous digit must be lower.\\n            b.insert(v+1, cnt)\\n\\t\\t\\t# update 1-digit number by inserting v in copy number 1.\\n            a.insert(v+1, 1)\\n        return ret\\n```",
                "solutionTags": [
                    "Binary Indexed Tree"
                ],
                "code": "```\\nimport numpy as np\\n\\n# various ways of inverting a permutation. Best guess that the last one is the fastest.\\ndef invert_permutation_list_scan(p):\\n    return [p.index(l) for l in range(len(p))]\\n\\ndef invert_permutation_list_comp(permutation):\\n    return [i for i, j in sorted(enumerate(permutation), key=lambda i_j: i_j[1])]\\n\\ndef invert_permutation_numpy(permutation):\\n    return np.argsort(permutation)\\n\\ndef invert_permutation_numpy2(permutation):\\n    inv = np.empty_like(permutation)\\n    inv[permutation] = np.arange(len(inv), dtype=inv.dtype)\\n    return inv\\n\\n# A class defining Binary Indexed Tree:\\nclass BIT:\\n    def __init__(self, maxN):\\n        self.maxN = maxN\\n        self.bit = [0] * maxN\\n    def prefSum(self, n):\\n\\t\\'\\'\\' return prefix sum\\'\\'\\'\\n        ret = 0\\n        while n > 0:\\n            ret += self.bit[n]\\n            n -= n & (-n)\\n        return ret\\n    def insert(self, v, delta):\\n        while v < self.maxN:\\n            self.bit[v] += delta\\n            v += v & (-v)\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n\\t\\t# We have 3 permutations. The central one is the identity P_0 = [0, ..., n-1]. P_1 = nums1\\n\\t\\t# and P_2 = nums2 are remaining two permutations. Reverting the second permutation \\n\\t\\t# and chaining it with the first permutation P_1 * P^{-1}_0 = P\\'is the permutation we should\\n\\t\\t# study. We are asking how many triples (i, j, k indices) with growing values P\\' has.\\n        perm = invert_permutation_numpy2(nums2)[np.array(nums1)]\\n        ret = 0 # return value\\n        a = BIT(int(1e5+1))  # a BIT for 1-digit subsequences, storing their end values\\n        b = BIT(int(1e5+1))  # a Bit for 2-digit subsequences, storing values of second digits\\n        for v in perm:\\n\\t\\t\\t# finish 2-digit subsequences with this (v) last digit\\n            ret += b.prefSum(v)\\n\\t\\t\\t# count how many 1-digit subsequences it extends to two digit, v being the second digit\\n            cnt = a.prefSum(v)\\n\\t\\t\\t# update 2-digit number, v+1 because BIT stores only positive numbers. \\n\\t\\t\\t# Above v is also a short way of saying (v - 1) + 1, because the previous digit must be lower.\\n            b.insert(v+1, cnt)\\n\\t\\t\\t# update 1-digit number by inserting v in copy number 1.\\n            a.insert(v+1, 1)\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690220,
                "title": "segment-trees",
                "content": "# Intuition\\nThe main catch to solve the problem was to think that for each triplet we will fix it\\'s middle element (we will find the position of the middle element in both the arrays) and then take the common elements in the right part and the common elements in the left part and multiply both and sum this for all the elements (taking each elemt of the array as the middle element)\\n\\n# Approach\\nI have used segment trees to calculate the number of common elements in the left and right part(pbds\\'s ordered set can also be used).\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct SegmentTree{\\n    vector <int> t;\\n\\n    void Initialize (int n){ t.assign(4*n + 1, 0); }\\n\\n    void Update (int i, int x, int v, int tl, int tr){\\n            if(tl == tr) t[v] += x;\\n            else{\\n                    int tm = (tl + tr) >> 1;\\n                    if(i <= tm) Update(i, x, 2*v + 1, tl, tm);\\n                    else Update(i, x, 2*v + 2, tm + 1, tr);\\n                    t[v] = t[2*v + 1] + t[2*v + 2];\\n            }\\n    }\\n\\n    int Sum (int l, int r, int v, int tl, int tr){\\n\\t    if(l > r) return 0;\\n            if(tl == l && tr == r) return t[v];\\n            else{\\n                    int tm = (tl + tr) >> 1;\\n                    if(r <= tm) return Sum(l, r, 2*v + 1, tl, tm);\\n                    else if(l > tm) return Sum(l, r, 2*v + 2, tm + 1, tr);\\n                    else return Sum(l, tm, 2*v + 1, tl, tm) + Sum(tm + 1, r, 2*v + 2, tm + 1, tr);\\n            }\\n    }\\n};\\n\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> pos_2(n);\\n\\n        //storing the position of each element of nums2\\n        for(int i = 0; i < n; ++i){\\n            pos_2[nums2[i]] = i;\\n        }\\n\\n        SegmentTree segT;\\n\\n        segT.Initialize(n);\\n        vector<int> pre(n), suff(n);\\n\\n        for(int i = 0; i < n; ++i){\\n            int curr_pos = pos_2[nums1[i]];\\n            pre[i] = segT.Sum(0, curr_pos-1, 0, 0, n-1);\\n            segT.Update(curr_pos, 1, 0, 0, n-1);\\n        }\\n\\n        segT.Initialize(n);\\n\\n        for(int i = n-1; i >= 0; --i){\\n            int curr_pos = pos_2[nums1[i]];\\n            suff[i] = segT.Sum(curr_pos+1, n-1, 0, 0, n-1);\\n            segT.Update(curr_pos, 1, 0, 0, n-1);\\n        }\\n\\n        long long ans = 0;\\n        for(int i = 0; i < n; ++i){\\n            ans += (pre[i]*1LL*suff[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct SegmentTree{\\n    vector <int> t;\\n\\n    void Initialize (int n){ t.assign(4*n + 1, 0); }\\n\\n    void Update (int i, int x, int v, int tl, int tr){\\n            if(tl == tr) t[v] += x;\\n            else{\\n                    int tm = (tl + tr) >> 1;\\n                    if(i <= tm) Update(i, x, 2*v + 1, tl, tm);\\n                    else Update(i, x, 2*v + 2, tm + 1, tr);\\n                    t[v] = t[2*v + 1] + t[2*v + 2];\\n            }\\n    }\\n\\n    int Sum (int l, int r, int v, int tl, int tr){\\n\\t    if(l > r) return 0;\\n            if(tl == l && tr == r) return t[v];\\n            else{\\n                    int tm = (tl + tr) >> 1;\\n                    if(r <= tm) return Sum(l, r, 2*v + 1, tl, tm);\\n                    else if(l > tm) return Sum(l, r, 2*v + 2, tm + 1, tr);\\n                    else return Sum(l, tm, 2*v + 1, tl, tm) + Sum(tm + 1, r, 2*v + 2, tm + 1, tr);\\n            }\\n    }\\n};\\n\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> pos_2(n);\\n\\n        //storing the position of each element of nums2\\n        for(int i = 0; i < n; ++i){\\n            pos_2[nums2[i]] = i;\\n        }\\n\\n        SegmentTree segT;\\n\\n        segT.Initialize(n);\\n        vector<int> pre(n), suff(n);\\n\\n        for(int i = 0; i < n; ++i){\\n            int curr_pos = pos_2[nums1[i]];\\n            pre[i] = segT.Sum(0, curr_pos-1, 0, 0, n-1);\\n            segT.Update(curr_pos, 1, 0, 0, n-1);\\n        }\\n\\n        segT.Initialize(n);\\n\\n        for(int i = n-1; i >= 0; --i){\\n            int curr_pos = pos_2[nums1[i]];\\n            suff[i] = segT.Sum(curr_pos+1, n-1, 0, 0, n-1);\\n            segT.Update(curr_pos, 1, 0, 0, n-1);\\n        }\\n\\n        long long ans = 0;\\n        for(int i = 0; i < n; ++i){\\n            ans += (pre[i]*1LL*suff[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638296,
                "title": "tc-100-simple-sortedlist-binarysearch-explained-python",
                "content": "![image](https://assets.leetcode.com/users/images/6fe33ff0-689b-4c05-9253-c31de96a7aef_1664449226.0956447.png)\\n\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def goodTriplets(self, n1: List[int], n2: List[int]) -> int:\\n        #we are basically looking for count of common subsequences of length 3\\n        #brute force would be check all len3 subsequences which is O(N^3) so not possible\\n        #n goes upto 10^5 so even n^2 is not possible\\n        \\n        #Greedy Approach: SortedList\\n        #focus on the middle element of the the triplet\\n        #for each middle element, subseq = no_of_common_elements_on_left * no_of_common_elements_on_right\\n        N = len(n1)\\n        b_pos = dict([(x, i) for i,x in enumerate(n2)])       \\n        visited_idx = SortedList([b_pos[n1[0]]])#stores the nums2_index of every element visited in nums1 so far\\n        res = 0\\n        for i in range(1, N-1):#firt and last element can never be a middle element of a triplet\\n            common_found = visited_idx.bisect_left(b_pos[n1[i]]) #number of common elements on the left\\n            visited_idx.add(b_pos[n1[i]])\\n            #number of common elements on the right can be calulcated using\\n            #(N - i - 1) - b_pos[nums1[i]] + no_of_common_elements_on_left\\n            res += common_found * (N - i - b_pos[n1[i]] + common_found - 1)\\n\\n        return res\\n    \\n        #Greedy Approach: Segment Tree but same logic as above solution\\n        N = len(n1)\\n        freq = [0]*(2*N)\\n        b_pos = dict([(x,i) for i,x in enumerate(n2)])\\n        \\n        def update(idx):\\n            idx += N\\n            freq[idx] += 1\\n            while idx > 1:\\n                idx >>= 1\\n                freq[idx] = freq[idx<<1] + freq[idx<<1 | 1]\\n        def getCount(left, right):\\n            left += N; right += N\\n            count = 0\\n            while left < right:\\n                if left & 1:\\n                    count += freq[left]\\n                    left += 1\\n                if right & 1:\\n                    right -= 1\\n                    count += freq[right]\\n                    pass\\n                left >>= 1; right >>= 1\\n            return count\\n        res = 0\\n        for i in range(N):\\n            common_left = getCount(0, b_pos[n1[i]])\\n            common_right = (N - i - 1) - b_pos[n1[i]] + common_left\\n            res += common_left*common_right\\n            update(b_pos[n1[i]])\\n        return res\\n    \\n        #Greedy Approach: Binary Index Tree\\n\\t\\t#TODO\\n            \\n        \\n        n = len(n1)\\n        #DP Approach\\n        #if common subsequnce (1,2,3,4) exists then common subsequence (2,3,4) must also exist\\n        #if common subsequence (2,3,4) exists then common subsequence (3,4) must also exist\\n        #and so on...\\n        #solution below is general for any size subsequence but O(n^2 * subseq_size)\\n        location = dict([(x, i) for i,x in enumerate(n2)])\\n        @lru_cache(None)\\n        def dp(j, size):\\n            nonlocal i\\n            \\n            if min(n - i, n - j) < size:\\n                return 0\\n            if size == 2:\\n                return len(set(n1[i:]).intersection(n2[j:])) - 1\\n            \\n            count = 0\\n            c_i = i\\n            for k in range(c_i+1, n):\\n                if location[n1[k]] > j:#dont choose element that has been skipped by j\\n                    i = k\\n                    c = dp(max(j+1, location[n1[k]]), size-1)\\n                    i = c_i\\n                    if c: count += c\\n            return count\\n        \\n        subseq_size = 3\\n        ans = 0\\n        for idx in range(n):\\n            i = idx\\n            ans += dp(location[n1[i]], subseq_size)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def goodTriplets(self, n1: List[int], n2: List[int]) -> int:\\n        #we are basically looking for count of common subsequences of length 3\\n        #brute force would be check all len3 subsequences which is O(N^3) so not possible\\n        #n goes upto 10^5 so even n^2 is not possible\\n        \\n        #Greedy Approach: SortedList\\n        #focus on the middle element of the the triplet\\n        #for each middle element, subseq = no_of_common_elements_on_left * no_of_common_elements_on_right\\n        N = len(n1)\\n        b_pos = dict([(x, i) for i,x in enumerate(n2)])       \\n        visited_idx = SortedList([b_pos[n1[0]]])#stores the nums2_index of every element visited in nums1 so far\\n        res = 0\\n        for i in range(1, N-1):#firt and last element can never be a middle element of a triplet\\n            common_found = visited_idx.bisect_left(b_pos[n1[i]]) #number of common elements on the left\\n            visited_idx.add(b_pos[n1[i]])\\n            #number of common elements on the right can be calulcated using\\n            #(N - i - 1) - b_pos[nums1[i]] + no_of_common_elements_on_left\\n            res += common_found * (N - i - b_pos[n1[i]] + common_found - 1)\\n\\n        return res\\n    \\n        #Greedy Approach: Segment Tree but same logic as above solution\\n        N = len(n1)\\n        freq = [0]*(2*N)\\n        b_pos = dict([(x,i) for i,x in enumerate(n2)])\\n        \\n        def update(idx):\\n            idx += N\\n            freq[idx] += 1\\n            while idx > 1:\\n                idx >>= 1\\n                freq[idx] = freq[idx<<1] + freq[idx<<1 | 1]\\n        def getCount(left, right):\\n            left += N; right += N\\n            count = 0\\n            while left < right:\\n                if left & 1:\\n                    count += freq[left]\\n                    left += 1\\n                if right & 1:\\n                    right -= 1\\n                    count += freq[right]\\n                    pass\\n                left >>= 1; right >>= 1\\n            return count\\n        res = 0\\n        for i in range(N):\\n            common_left = getCount(0, b_pos[n1[i]])\\n            common_right = (N - i - 1) - b_pos[n1[i]] + common_left\\n            res += common_left*common_right\\n            update(b_pos[n1[i]])\\n        return res\\n    \\n        #Greedy Approach: Binary Index Tree\\n\\t\\t#TODO\\n            \\n        \\n        n = len(n1)\\n        #DP Approach\\n        #if common subsequnce (1,2,3,4) exists then common subsequence (2,3,4) must also exist\\n        #if common subsequence (2,3,4) exists then common subsequence (3,4) must also exist\\n        #and so on...\\n        #solution below is general for any size subsequence but O(n^2 * subseq_size)\\n        location = dict([(x, i) for i,x in enumerate(n2)])\\n        @lru_cache(None)\\n        def dp(j, size):\\n            nonlocal i\\n            \\n            if min(n - i, n - j) < size:\\n                return 0\\n            if size == 2:\\n                return len(set(n1[i:]).intersection(n2[j:])) - 1\\n            \\n            count = 0\\n            c_i = i\\n            for k in range(c_i+1, n):\\n                if location[n1[k]] > j:#dont choose element that has been skipped by j\\n                    i = k\\n                    c = dp(max(j+1, location[n1[k]]), size-1)\\n                    i = c_i\\n                    if c: count += c\\n            return count\\n        \\n        subseq_size = 3\\n        ans = 0\\n        for idx in range(n):\\n            i = idx\\n            ans += dp(location[n1[i]], subseq_size)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578425,
                "title": "python-sorted-list",
                "content": "```\\nfrom sortedcontainers import SortedList\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        pre=[]\\n        indb=SortedList()\\n        n=len(nums1)\\n        pos=[]\\n        indbma=SortedList()\\n        \\n        dict2=defaultdict()\\n        dict1=defaultdict()\\n        for i in range(n):\\n            dict2[nums2[i]]=i\\n            dict1[nums1[i]]=i\\n        \\n        \\n        for i in range(len(nums1)):\\n            \\n            \\n            pp=dict2[nums1[i]]\\n            \\n            pre.append(indb.bisect_left(pp))\\n            \\n            indb.add(pp)\\n            \\n            # print(indb,pre)\\n            qq=dict2[nums1[n-1-i]]\\n            # qq=nums2.index()\\n            \\n            pos.append(len(indbma)-indbma.bisect_left(qq))\\n            indbma.add(qq)\\n            # pos.append(indbma.bisect_left(qq))\\n            \\n            \\n            \\n        # print(indb)\\n        # print(pre)\\n        # print(indbma)\\n        # print(pos)\\n        ans=0\\n        for i in range(n):\\n            ans+=pre[i]*pos[n-1-i]\\n            \\n        return ans\\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        pre=[]\\n        indb=SortedList()\\n        n=len(nums1)\\n        pos=[]\\n        indbma=SortedList()\\n        \\n        dict2=defaultdict()\\n        dict1=defaultdict()\\n        for i in range(n):\\n            dict2[nums2[i]]=i\\n            dict1[nums1[i]]=i\\n        \\n        \\n        for i in range(len(nums1)):\\n            \\n            \\n            pp=dict2[nums1[i]]\\n            \\n            pre.append(indb.bisect_left(pp))\\n            \\n            indb.add(pp)\\n            \\n            # print(indb,pre)\\n            qq=dict2[nums1[n-1-i]]\\n            # qq=nums2.index()\\n            \\n            pos.append(len(indbma)-indbma.bisect_left(qq))\\n            indbma.add(qq)\\n            # pos.append(indbma.bisect_left(qq))\\n            \\n            \\n            \\n        # print(indb)\\n        # print(pre)\\n        # print(indbma)\\n        # print(pos)\\n        ans=0\\n        for i in range(n):\\n            ans+=pre[i]*pos[n-1-i]\\n            \\n        return ans\\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520361,
                "title": "python-bit-solution-o-nlogn-time",
                "content": "```\\nclass BITtree:\\n    def __init__(self, k):\\n        self.tree = [0]*(k+1)\\n    def add(self, i):\\n        i += 1\\n        while(i<len(self.tree)):\\n            self.tree[i] += 1\\n            i += i&-i\\n    def psum(self, i):\\n        i += 1\\n        s = 0\\n        while i:\\n            s += self.tree[i]\\n            i -= i&-i\\n        return s\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums = {nums1[i]:i for i in range(len(nums1))}\\n        nums = [nums[n] for n in nums2]\\n        ans, m = 0, len(nums1)\\n        btree = BITtree(m)\\n        for n in nums:\\n            left = btree.psum(n)\\n            right = (m-1-n) - (btree.psum(m-1)-left)\\n            ans += left*right\\n            btree.add(n)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass BITtree:\\n    def __init__(self, k):\\n        self.tree = [0]*(k+1)\\n    def add(self, i):\\n        i += 1\\n        while(i<len(self.tree)):\\n            self.tree[i] += 1\\n            i += i&-i\\n    def psum(self, i):\\n        i += 1\\n        s = 0\\n        while i:\\n            s += self.tree[i]\\n            i -= i&-i\\n        return s\\n\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums = {nums1[i]:i for i in range(len(nums1))}\\n        nums = [nums[n] for n in nums2]\\n        ans, m = 0, len(nums1)\\n        btree = BITtree(m)\\n        for n in nums:\\n            left = btree.psum(n)\\n            right = (m-1-n) - (btree.psum(m-1)-left)\\n            ans += left*right\\n            btree.add(n)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520224,
                "title": "python-short-bisect-solution-o-n-2-time",
                "content": "```\\ndef goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\tnums = {nums1[i]:i for i in range(len(nums1))}\\n\\tnums = [nums[n] for n in nums2]\\n\\tarr, ans = [], 0\\n\\tfor n in nums[::-1]:\\n\\t\\ti = bisect.bisect(arr, n)\\n\\t\\tans += (len(arr)-i)*(n-i)\\n\\t\\tbisect.insort(arr, n)\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\tnums = {nums1[i]:i for i in range(len(nums1))}\\n\\tnums = [nums[n] for n in nums2]\\n\\tarr, ans = [], 0\\n\\tfor n in nums[::-1]:\\n\\t\\ti = bisect.bisect(arr, n)\\n\\t\\tans += (len(arr)-i)*(n-i)\\n\\t\\tbisect.insort(arr, n)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2491594,
                "title": "c-code-for-beginners-segment-tree",
                "content": "```\\nclass Solution {\\nprivate:\\n    int tree[400004];\\npublic:\\n    void update(int low, int high, int parent, int val){\\n        if(low>val || high<val){\\n            return;\\n        }\\n        if(low==val && high==val){\\n            tree[parent]=1;\\n            return;\\n        }\\n        int mid=(low+high)/2;\\n        update(low,mid,2*parent+1,val);\\n        update(mid+1,high,2*parent+2,val);\\n        tree[parent]=tree[2*parent+1]+tree[2*parent+2];\\n    }\\n    \\n    int findMinCount(int low, int high, int parent, int lowerR, int higherR){\\n        if(low>higherR || high<lowerR){\\n            return 0;\\n        }\\n        if(low>=lowerR && high<=higherR){\\n            return tree[parent];\\n        }\\n        int mid=(low+high)/2;\\n        return findMinCount(low,mid,2*parent+1,lowerR,higherR)+findMinCount(mid+1,high,2*parent+2,lowerR,higherR);\\n    }\\n    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        memset(tree,0,sizeof(tree));\\n        int n=nums1.size();\\n        unordered_map<int,int> mpp;\\n        for(int i=0;i<n;i++){\\n            mpp[nums1[i]]=i;\\n            nums1[i]=i;\\n        }\\n        for(int i=0;i<n;i++){\\n            nums2[i]=mpp[nums2[i]];  // by doing this we will just need to work on nums2 and ignore 1 as it is sorted. Remember, we are not considering elements, but the indexes anyways\\n        }\\n        update(0,n-1,0,nums2[0]); // because first and last cannot be considered as mid element of triplet\\n        long long res=0;\\n        for(int i=1;i<n-1;i++){\\n            long long int countLessThanE=findMinCount(0,n-1,0,0,nums2[i]-1); \\n            long long int biggerElements=(n-1)-nums2[i];  // this is the count of elements bigger than nums2[i] that are present, since nums1 is sorted, we can simply find this....\\n            int leftOutBiggerElements=i-countLessThanE;  \\n\\t\\t\\t/* this is the count of biggerElements which have fallen behind i, i.e. they are on the left of i\\n\\t\\t\\tand hence cannot be used as right side bigger elements, see, we know the index, and we also\\n\\t\\t\\tknow how many elemts are smaller than nums2[i] and are on the right, so if i-countLessThanE, \\n\\t\\t\\twe get the remaining elements on the left side which are just bigger elements that are on the \\n\\t\\t\\tleft side and cannot be used on the rightmost side, that is why we remove them from \\n\\t\\t\\tbiggerELEMENTS AND hence get the correct count of elements on the right side which are bigger \\n\\t\\t\\tthan nums2[i]. Inshort, to find the correct value of elements on the right side of i, that are bigger\\n\\t\\t\\tthan nums2[i]. Just get the count of values that are bigger than nums2[i], now subtract the count \\n\\t\\t\\tof elements that are bigger than nums2[i], but are on the left side of i, since they cannot be used \\n\\t\\t\\tin right side of i */\\n            long long int biggerElementOnRightSide=biggerElements-leftOutBiggerElements;\\n            res+=(countLessThanE*biggerElementOnRightSide);\\n            update(0,n-1,0,nums2[i]);  // updating this current number in segTree for furthur ops\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int tree[400004];\\npublic:\\n    void update(int low, int high, int parent, int val){\\n        if(low>val || high<val){\\n            return;\\n        }\\n        if(low==val && high==val){\\n            tree[parent]=1;\\n            return;\\n        }\\n        int mid=(low+high)/2;\\n        update(low,mid,2*parent+1,val);\\n        update(mid+1,high,2*parent+2,val);\\n        tree[parent]=tree[2*parent+1]+tree[2*parent+2];\\n    }\\n    \\n    int findMinCount(int low, int high, int parent, int lowerR, int higherR){\\n        if(low>higherR || high<lowerR){\\n            return 0;\\n        }\\n        if(low>=lowerR && high<=higherR){\\n            return tree[parent];\\n        }\\n        int mid=(low+high)/2;\\n        return findMinCount(low,mid,2*parent+1,lowerR,higherR)+findMinCount(mid+1,high,2*parent+2,lowerR,higherR);\\n    }\\n    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        memset(tree,0,sizeof(tree));\\n        int n=nums1.size();\\n        unordered_map<int,int> mpp;\\n        for(int i=0;i<n;i++){\\n            mpp[nums1[i]]=i;\\n            nums1[i]=i;\\n        }\\n        for(int i=0;i<n;i++){\\n            nums2[i]=mpp[nums2[i]];  // by doing this we will just need to work on nums2 and ignore 1 as it is sorted. Remember, we are not considering elements, but the indexes anyways\\n        }\\n        update(0,n-1,0,nums2[0]); // because first and last cannot be considered as mid element of triplet\\n        long long res=0;\\n        for(int i=1;i<n-1;i++){\\n            long long int countLessThanE=findMinCount(0,n-1,0,0,nums2[i]-1); \\n            long long int biggerElements=(n-1)-nums2[i];  // this is the count of elements bigger than nums2[i] that are present, since nums1 is sorted, we can simply find this....\\n            int leftOutBiggerElements=i-countLessThanE;  \\n\\t\\t\\t/* this is the count of biggerElements which have fallen behind i, i.e. they are on the left of i\\n\\t\\t\\tand hence cannot be used as right side bigger elements, see, we know the index, and we also\\n\\t\\t\\tknow how many elemts are smaller than nums2[i] and are on the right, so if i-countLessThanE, \\n\\t\\t\\twe get the remaining elements on the left side which are just bigger elements that are on the \\n\\t\\t\\tleft side and cannot be used on the rightmost side, that is why we remove them from \\n\\t\\t\\tbiggerELEMENTS AND hence get the correct count of elements on the right side which are bigger \\n\\t\\t\\tthan nums2[i]. Inshort, to find the correct value of elements on the right side of i, that are bigger\\n\\t\\t\\tthan nums2[i]. Just get the count of values that are bigger than nums2[i], now subtract the count \\n\\t\\t\\tof elements that are bigger than nums2[i], but are on the left side of i, since they cannot be used \\n\\t\\t\\tin right side of i */\\n            long long int biggerElementOnRightSide=biggerElements-leftOutBiggerElements;\\n            res+=(countLessThanE*biggerElementOnRightSide);\\n            update(0,n-1,0,nums2[i]);  // updating this current number in segTree for furthur ops\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380828,
                "title": "c-binary-index-tree",
                "content": "vector<long long> seg;\\n     vector<long long> ftree;\\n    void update1(int idx,int n){\\n        \\n        while(idx<=n){\\n            ftree[idx]++;\\n            idx+=(idx&-idx);\\n        }\\n    }\\n    \\n    long long lower(int idx){\\n        long long count=0;\\n        while(idx>0){\\n            count+=ftree[idx];\\n            idx-=(idx&-idx);\\n        }\\n        return count;\\n    }\\n    \\n     void update(int idx,long long val,int n){\\n        \\n        while(idx<=n){\\n            seg[idx]+=val;\\n            idx+=(idx&-idx);\\n        }\\n    }\\n    long long find(int idx){\\n        long long count=0;\\n        while(idx>0){\\n            count+=seg[idx];\\n            idx-=(idx&-idx);\\n        }\\n        return count;\\n    }\\n    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int> m2;\\n        seg.resize(100001);\\n        ftree.resize(100001);\\n        for(int i=0;i<nums2.size();i++){\\n            m2[nums2[i]]=i+1;\\n        }\\n        int n=nums1.size();\\n       \\n        long long ans=0;\\n        for(int i=0;i<nums1.size();i++){\\n            int idx=m2[nums1[i]];\\n            ans+=find(idx-1);\\n          long long x=lower(idx-1);\\n            // cout<<x;\\n             update1(idx,n);\\n            update(idx,x,n);\\n            \\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "Binary Indexed Tree"
                ],
                "code": "vector<long long> seg;\\n     vector<long long> ftree;\\n    void update1(int idx,int n){\\n        \\n        while(idx<=n){\\n            ftree[idx]++;\\n            idx+=(idx&-idx);\\n        }\\n    }\\n    \\n    long long lower(int idx){\\n        long long count=0;\\n        while(idx>0){\\n            count+=ftree[idx];\\n            idx-=(idx&-idx);\\n        }\\n        return count;\\n    }\\n    \\n     void update(int idx,long long val,int n){\\n        \\n        while(idx<=n){\\n            seg[idx]+=val;\\n            idx+=(idx&-idx);\\n        }\\n    }\\n    long long find(int idx){\\n        long long count=0;\\n        while(idx>0){\\n            count+=seg[idx];\\n            idx-=(idx&-idx);\\n        }\\n        return count;\\n    }\\n    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int> m2;\\n        seg.resize(100001);\\n        ftree.resize(100001);\\n        for(int i=0;i<nums2.size();i++){\\n            m2[nums2[i]]=i+1;\\n        }\\n        int n=nums1.size();\\n       \\n        long long ans=0;\\n        for(int i=0;i<nums1.size();i++){\\n            int idx=m2[nums1[i]];\\n            ans+=find(idx-1);\\n          long long x=lower(idx-1);\\n            // cout<<x;\\n             update1(idx,n);\\n            update(idx,x,n);\\n            \\n        }\\n        return ans;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2376218,
                "title": "c-segment-tree",
                "content": "```\\nclass Solution {\\n    struct tree{\\n        int *t;\\n        int c;\\n        int n;\\n        tree(int ni) \\n        {\\n            c = 1;\\n            while(c<ni)\\n                c<<=1;\\n            c<<=1;\\n            t = new int[c];\\n            memset(t, 0, sizeof(int) * c);\\n            n = ni;\\n        }\\n        \\n        void update(int ti, int ni, int til, int tih)\\n        {\\n            if (tih == til)\\n                t[ni]++;\\n            else\\n            {\\n                int tim = (til+tih)>>1;\\n                if (ti <= tim)\\n                    update(ti, ni*2+1, til, tim);\\n                else\\n                    update(ti, ni*2+2, tim+1, tih);\\n                t[ni] = t[ni*2+1] + t[ni*2+2];\\n            }\\n        }\\n        \\n        int query(int ti, int ni, int til, int tih)\\n        {\\n            if (tih == ti)\\n                return t[ni];\\n            int tim = (til+tih)>>1;\\n            int ans = query(min(ti, tim), ni*2+1, til, tim);\\n            if (ti >= tim + 1)\\n                ans += query(ti, ni*2+2, tim+1, tih);\\n            return ans;\\n        }\\n        \\n        int query(int ti)\\n        {\\n            return query(ti, 0, 0, n-1);\\n        }\\n        \\n        void update(int ti)\\n        {\\n            update(ti,  0,  0,  n-1);\\n        }\\n   };\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> indexnum2(n,0);\\n        for(int i=0; i<n; i++)\\n            indexnum2[nums2[i]] = i;\\n        tree t(n);\\n        t.update(indexnum2[nums1[0]]);\\n        long long ans = 0;\\n        for(int i=1; i<n-1; i++)\\n        {\\n            long long leftc = t.query(indexnum2[nums1[i]]);\\n\\t\\t\\t//don\\'t run another segment tree\\n            int rightc =  n -1 - (indexnum2[nums1[i]]) - (i - leftc);\\n            ans += leftc * rightc;\\n            t.update(indexnum2[nums1[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    struct tree{\\n        int *t;\\n        int c;\\n        int n;\\n        tree(int ni) \\n        {\\n            c = 1;\\n            while(c<ni)\\n                c<<=1;\\n            c<<=1;\\n            t = new int[c];\\n            memset(t, 0, sizeof(int) * c);\\n            n = ni;\\n        }\\n        \\n        void update(int ti, int ni, int til, int tih)\\n        {\\n            if (tih == til)\\n                t[ni]++;\\n            else\\n            {\\n                int tim = (til+tih)>>1;\\n                if (ti <= tim)\\n                    update(ti, ni*2+1, til, tim);\\n                else\\n                    update(ti, ni*2+2, tim+1, tih);\\n                t[ni] = t[ni*2+1] + t[ni*2+2];\\n            }\\n        }\\n        \\n        int query(int ti, int ni, int til, int tih)\\n        {\\n            if (tih == ti)\\n                return t[ni];\\n            int tim = (til+tih)>>1;\\n            int ans = query(min(ti, tim), ni*2+1, til, tim);\\n            if (ti >= tim + 1)\\n                ans += query(ti, ni*2+2, tim+1, tih);\\n            return ans;\\n        }\\n        \\n        int query(int ti)\\n        {\\n            return query(ti, 0, 0, n-1);\\n        }\\n        \\n        void update(int ti)\\n        {\\n            update(ti,  0,  0,  n-1);\\n        }\\n   };\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> indexnum2(n,0);\\n        for(int i=0; i<n; i++)\\n            indexnum2[nums2[i]] = i;\\n        tree t(n);\\n        t.update(indexnum2[nums1[0]]);\\n        long long ans = 0;\\n        for(int i=1; i<n-1; i++)\\n        {\\n            long long leftc = t.query(indexnum2[nums1[i]]);\\n\\t\\t\\t//don\\'t run another segment tree\\n            int rightc =  n -1 - (indexnum2[nums1[i]]) - (i - leftc);\\n            ans += leftc * rightc;\\n            t.update(indexnum2[nums1[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361347,
                "title": "can-someone-explain-to-me-why-this-works",
                "content": "\"A number in the first array is replaced with an index of that number in the second one.\"\\n\\nI have tried to understand it but I cannot.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2355381,
                "title": "rust-segment-tree-with-brief-comments",
                "content": "~~~\\n// https://cp-algorithms.com/data_structures/segment_tree.html\\n\\nimpl Solution {\\n    pub fn good_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i64 {\\n        let n = nums1.len();\\n        let mut nums2 = nums2;\\n        \\n\\t\\t// Sort nums2 relatively in the order of nums1. We only need to count those (i, j, k)\\n        // where 0 <= i < j < k < n & nums1[i] < nums2[j] < nums2[k], or\\n        // sum(for each i: # of smaller on the left * # of bigger on the right )\\n\\t\\tlet mut mp = vec![0i32; n];\\n        for i in 0..n { mp[nums1[i] as usize] = i as i32; }    \\n        for i in 0..n { nums2[i] = mp[nums2[i] as usize]; }\\n        \\n        let mut ret = 0i64; \\n        let mut tree = vec![0i32; 4 * n];\\n        \\n        for i in 0..n {\\n            if nums2[i] > 0 {\\n                // how many of values < *a have been updated in the segment tree?\\n                let smaller_counter = Self::count(1, 0, n - 1, 0, nums2[i] as usize - 1, &tree);\\n                let bigger_counter = n as i64 - 1 - nums2[i] as i64 - (i as i64 - smaller_counter);\\n                ret += smaller_counter * bigger_counter;\\n            }\\n            Self::update(1, 0, n - 1, nums2[i] as usize, &mut tree);\\n        }\\n        \\n        ret\\n    }\\n    \\n    // to enter a value i in the segment tree, we set the value at the leaf node to one\\n    fn update(u: usize, left: usize, right: usize, i: usize, tree: &mut Vec<i32>) {\\n        if left == right {\\n            tree[u] = 1;\\n            return;\\n        }\\n        \\n        let mid = left + (right - left) / 2;\\n        \\n        if i <= mid { Self::update(2 * u, left, mid, i, tree); }\\n        else { Self::update(2 * u + 1, mid + 1, right, i, tree); }\\n        \\n        tree[u] = tree[2 * u] + tree[2 * u + 1];\\n    }\\n    \\n    // to count the # of leaf nodes that have value set to 1 with index bounded by (l, r)\\n    fn count(u: usize, left: usize, right: usize, l: usize, r: usize, tree: &Vec<i32>) ->i64 {\\n        if left >= l && right <= r {\\n            return tree[u] as i64;\\n        }\\n        \\n        if left > r || right < l { return 0}\\n        \\n        let mid = left + (right - left) / 2;\\n        \\n        Self::count(2 * u, left, mid, l, r, tree) + Self::count(2 * u + 1, mid + 1, right, l, r, tree)\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust",
                    "Tree"
                ],
                "code": "~~~\\n// https://cp-algorithms.com/data_structures/segment_tree.html\\n\\nimpl Solution {\\n    pub fn good_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i64 {\\n        let n = nums1.len();\\n        let mut nums2 = nums2;\\n        \\n\\t\\t// Sort nums2 relatively in the order of nums1. We only need to count those (i, j, k)\\n        // where 0 <= i < j < k < n & nums1[i] < nums2[j] < nums2[k], or\\n        // sum(for each i: # of smaller on the left * # of bigger on the right )\\n\\t\\tlet mut mp = vec![0i32; n];\\n        for i in 0..n { mp[nums1[i] as usize] = i as i32; }    \\n        for i in 0..n { nums2[i] = mp[nums2[i] as usize]; }\\n        \\n        let mut ret = 0i64; \\n        let mut tree = vec![0i32; 4 * n];\\n        \\n        for i in 0..n {\\n            if nums2[i] > 0 {\\n                // how many of values < *a have been updated in the segment tree?\\n                let smaller_counter = Self::count(1, 0, n - 1, 0, nums2[i] as usize - 1, &tree);\\n                let bigger_counter = n as i64 - 1 - nums2[i] as i64 - (i as i64 - smaller_counter);\\n                ret += smaller_counter * bigger_counter;\\n            }\\n            Self::update(1, 0, n - 1, nums2[i] as usize, &mut tree);\\n        }\\n        \\n        ret\\n    }\\n    \\n    // to enter a value i in the segment tree, we set the value at the leaf node to one\\n    fn update(u: usize, left: usize, right: usize, i: usize, tree: &mut Vec<i32>) {\\n        if left == right {\\n            tree[u] = 1;\\n            return;\\n        }\\n        \\n        let mid = left + (right - left) / 2;\\n        \\n        if i <= mid { Self::update(2 * u, left, mid, i, tree); }\\n        else { Self::update(2 * u + 1, mid + 1, right, i, tree); }\\n        \\n        tree[u] = tree[2 * u] + tree[2 * u + 1];\\n    }\\n    \\n    // to count the # of leaf nodes that have value set to 1 with index bounded by (l, r)\\n    fn count(u: usize, left: usize, right: usize, l: usize, r: usize, tree: &Vec<i32>) ->i64 {\\n        if left >= l && right <= r {\\n            return tree[u] as i64;\\n        }\\n        \\n        if left > r || right < l { return 0}\\n        \\n        let mid = left + (right - left) / 2;\\n        \\n        Self::count(2 * u, left, mid, l, r, tree) + Self::count(2 * u + 1, mid + 1, right, l, r, tree)\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2347783,
                "title": "snapshot-array-bit-java",
                "content": "#### Update\\nI just realized the approach I had previously is way too overcomplicated. \\nWe can get the info while generating the BIT.\\n\\nThe idea is mapping elements of `A` to its index and update BIT, so that we can query `0 ... i-1` range for array `B` to determine how many elements both appear before `A[i]`. We can apply the same logic to those behind\\n\\n```Java\\nclass Solution {\\n    public long goodTriplets(int[] A, int[] B) {\\n        int n = A.length;\\n        int[] idx = new int[n];\\n        for(int i = 0; i < n; i++){\\n            idx[B[i]] = i;\\n        }\\n        int[] bit = new int[n+1];\\n        long ans = 0;\\n        for(int i = 0;i < n;i++){\\n            int pos = idx[A[i]];\\n            int l = query(bit, pos);\\n            int r = (n-1-pos) - (i - query(bit, pos));\\n            ans += 1L * l * r;\\n            update(bit, pos, 1);\\n        }\\n        return ans;\\n    }\\n\\n    public int query(int[] bit, int i)\\n    {\\n        int sum = 0;\\n        for(i++; i > 0;i -= i&-i){\\n            sum += bit[i];\\n        }\\n        return sum;\\n    }\\n\\n    public void update(int[] bit, int i, int v)\\n    {\\n        for(i++;i < bit.length;i += i&-i){\\n            bit[i] += v;\\n        } \\n    }\\n}\\n```\\n#### Outdated (Snapshot Array + BIT).\\nThe idea is mapping elements of `A` to its index and update BIT, so that we can query `0 ... i-1` range for array `B` to determine how many elements both appear before `A[i]`. We can apply the same logic to those behind, but there is one huge problem. When we are looking at the element `A[i]`, we don\\'t really know the info above\\n```text\\nnums1 = [4,0,1,3,2]\\nnums2 = [4,1,0,2,3]\\n```\\nTake the above for example, when we look at `A[4] = 2`, we query `[0, 4]`, but we have processed everything already for `B` inside the BIT, so it will return 4, instead of 3. This is incorrect. \\n\\n\\nOne easy way to fix this is implementing another dimension, let\\'s call it **time**, and we can binary search / treemap to match the time. This is identical to the idea in SnapShot Array, which is a LeetCode Medium Question, so if we put all that together. We have a working solution that runs in `O(N * logN * logN)`\\n\\nMy AC code is below. Note that I do have to a few optimization otherwise it will get TLE. A better, readable, version is included in the bottom:\\n#### Java\\n```Java\\nclass Solution {\\n    public long goodTriplets(int[] A, int[] B) {\\n        int n = A.length;\\n        int[] idx = new int[n];\\n        int[] time = new int[n];\\n        int[] last = new int[n+1];\\n        for (int i = 0; i < n; i++){\\n            idx[A[i]]=i;\\n        }\\n        TreeMap<Integer, Integer>[] pre = new TreeMap[n+1];\\n        Arrays.setAll(pre, o -> new TreeMap<>());\\n        for (int i = 0; i < n; i++){\\n            time[B[i]]=i;\\n            update(pre, 1, idx[B[i]], i, last);\\n        }\\n        long ans = 0;\\n        for (int i = 1; i < n-1; i++){\\n            int t = time[A[i]];\\n            int l = query(pre, i-1, t-1);\\n            int r = (n - query(pre, i, n-1)) - (query(pre, n-1, t) - query(pre, i, t));\\n            ans += 1L * l * r;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private void update(TreeMap<Integer, Integer>[] bit, int inc, int idx, int time, int[] last){\\n        ++idx;\\n        while(idx < bit.length){\\n            bit[idx].put(time, last[idx]+inc);\\n            last[idx] += inc;\\n            idx += idx & -idx;\\n        }\\n    }\\n\\n    private int query(TreeMap<Integer, Integer>[] bit, int idx, int time){\\n        ++idx;\\n        int ans = 0;\\n        while(idx > 0){\\n            Map.Entry<Integer, Integer> map = bit[idx].floorEntry(time);\\n            ans += map == null? 0 : map.getValue();\\n            idx -= idx & -idx;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n#### TLE, but here for readable purposes\\n```Java\\n// class Solution {\\n//     public long goodTriplets(int[] A, int[] B) {\\n//         int n = A.length;\\n//         int[] idx = new int[n];\\n//         for (int i = 0; i < n; i++){\\n//             idx[A[i]]=i;\\n//         }\\n//         TreeMap<Integer, Integer>[] pre = new TreeMap[n+1];\\n//         TreeMap<Integer, Integer>[] suf = new TreeMap[n+1];\\n//         Arrays.setAll(pre, o -> new TreeMap<>());\\n//         Arrays.setAll(suf, o -> new TreeMap<>());\\n//         Map<Integer, Integer> time = new HashMap<>();\\n//         for (int i = 0,j=n-1; i < n; i++, j--){\\n//             time.put(B[i], i);\\n//             update(pre, 1, idx[B[i]], i);\\n//             update(suf, 1, idx[B[j]], i);\\n//         }\\n//         long ans = 0;\\n//         for (int i = 1; i < n-1; i++){\\n//             int t = time.get(A[i]);\\n//             int l = query(pre, i-1, t-1);\\n//             int r = query(suf, n-1, n-2-t) - query(suf, i,n-2-t);\\n//             ans += 1L * l * r;\\n//         }\\n\\n//         return ans;\\n//     }\\n\\n//     private void update(TreeMap<Integer, Integer>[] bit, int inc, int idx, int time){\\n//         ++idx;\\n//         while(idx < bit.length){\\n//             Map.Entry<Integer, Integer> map = bit[idx].lastEntry();\\n//             int prev = map == null? 0 : map.getValue();\\n//             bit[idx].put(time, prev+inc);\\n//             idx += idx & -idx;\\n//         }\\n//     }\\n\\n//     private int query(TreeMap<Integer, Integer>[] bit, int idx, int time){\\n//         ++idx;\\n//         int ans = 0;\\n//         while(idx > 0){\\n//             Map.Entry<Integer, Integer> map = bit[idx].floorEntry(time);\\n//             ans += map == null? 0 : map.getValue();\\n//             idx -= idx & -idx;\\n//         }\\n//         return ans;\\n//     }\\n// }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public long goodTriplets(int[] A, int[] B) {\\n        int n = A.length;\\n        int[] idx = new int[n];\\n        for(int i = 0; i < n; i++){\\n            idx[B[i]] = i;\\n        }\\n        int[] bit = new int[n+1];\\n        long ans = 0;\\n        for(int i = 0;i < n;i++){\\n            int pos = idx[A[i]];\\n            int l = query(bit, pos);\\n            int r = (n-1-pos) - (i - query(bit, pos));\\n            ans += 1L * l * r;\\n            update(bit, pos, 1);\\n        }\\n        return ans;\\n    }\\n\\n    public int query(int[] bit, int i)\\n    {\\n        int sum = 0;\\n        for(i++; i > 0;i -= i&-i){\\n            sum += bit[i];\\n        }\\n        return sum;\\n    }\\n\\n    public void update(int[] bit, int i, int v)\\n    {\\n        for(i++;i < bit.length;i += i&-i){\\n            bit[i] += v;\\n        } \\n    }\\n}\\n```\n```text\\nnums1 = [4,0,1,3,2]\\nnums2 = [4,1,0,2,3]\\n```\n```Java\\nclass Solution {\\n    public long goodTriplets(int[] A, int[] B) {\\n        int n = A.length;\\n        int[] idx = new int[n];\\n        int[] time = new int[n];\\n        int[] last = new int[n+1];\\n        for (int i = 0; i < n; i++){\\n            idx[A[i]]=i;\\n        }\\n        TreeMap<Integer, Integer>[] pre = new TreeMap[n+1];\\n        Arrays.setAll(pre, o -> new TreeMap<>());\\n        for (int i = 0; i < n; i++){\\n            time[B[i]]=i;\\n            update(pre, 1, idx[B[i]], i, last);\\n        }\\n        long ans = 0;\\n        for (int i = 1; i < n-1; i++){\\n            int t = time[A[i]];\\n            int l = query(pre, i-1, t-1);\\n            int r = (n - query(pre, i, n-1)) - (query(pre, n-1, t) - query(pre, i, t));\\n            ans += 1L * l * r;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private void update(TreeMap<Integer, Integer>[] bit, int inc, int idx, int time, int[] last){\\n        ++idx;\\n        while(idx < bit.length){\\n            bit[idx].put(time, last[idx]+inc);\\n            last[idx] += inc;\\n            idx += idx & -idx;\\n        }\\n    }\\n\\n    private int query(TreeMap<Integer, Integer>[] bit, int idx, int time){\\n        ++idx;\\n        int ans = 0;\\n        while(idx > 0){\\n            Map.Entry<Integer, Integer> map = bit[idx].floorEntry(time);\\n            ans += map == null? 0 : map.getValue();\\n            idx -= idx & -idx;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```Java\\n// class Solution {\\n//     public long goodTriplets(int[] A, int[] B) {\\n//         int n = A.length;\\n//         int[] idx = new int[n];\\n//         for (int i = 0; i < n; i++){\\n//             idx[A[i]]=i;\\n//         }\\n//         TreeMap<Integer, Integer>[] pre = new TreeMap[n+1];\\n//         TreeMap<Integer, Integer>[] suf = new TreeMap[n+1];\\n//         Arrays.setAll(pre, o -> new TreeMap<>());\\n//         Arrays.setAll(suf, o -> new TreeMap<>());\\n//         Map<Integer, Integer> time = new HashMap<>();\\n//         for (int i = 0,j=n-1; i < n; i++, j--){\\n//             time.put(B[i], i);\\n//             update(pre, 1, idx[B[i]], i);\\n//             update(suf, 1, idx[B[j]], i);\\n//         }\\n//         long ans = 0;\\n//         for (int i = 1; i < n-1; i++){\\n//             int t = time.get(A[i]);\\n//             int l = query(pre, i-1, t-1);\\n//             int r = query(suf, n-1, n-2-t) - query(suf, i,n-2-t);\\n//             ans += 1L * l * r;\\n//         }\\n\\n//         return ans;\\n//     }\\n\\n//     private void update(TreeMap<Integer, Integer>[] bit, int inc, int idx, int time){\\n//         ++idx;\\n//         while(idx < bit.length){\\n//             Map.Entry<Integer, Integer> map = bit[idx].lastEntry();\\n//             int prev = map == null? 0 : map.getValue();\\n//             bit[idx].put(time, prev+inc);\\n//             idx += idx & -idx;\\n//         }\\n//     }\\n\\n//     private int query(TreeMap<Integer, Integer>[] bit, int idx, int time){\\n//         ++idx;\\n//         int ans = 0;\\n//         while(idx > 0){\\n//             Map.Entry<Integer, Integer> map = bit[idx].floorEntry(time);\\n//             ans += map == null? 0 : map.getValue();\\n//             idx -= idx & -idx;\\n//         }\\n//         return ans;\\n//     }\\n// }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323600,
                "title": "rust-merge-sort",
                "content": "~~~\\n// This solution directly uses the solution of problem #315\\n// \\nimpl Solution {\\n    pub fn good_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i64 {\\n        let n = nums1.len();\\n        let mut data = vec![0; n];\\n        for (i, a) in nums1.iter().enumerate() { \\n            data[*a as usize] = i;\\n        }\\n        \\n        // v1: sorting of index of nums2 based on the order nums1\\n        // therefore, the answer to find the # increasing sub-sequences of length 3\\n        let (mut v1, mut v2) = (vec![0i32; n], vec![0i32; n]);\\n        for (i, a) in nums2.iter().enumerate() { \\n            v1[i] = data[*a as usize] as i32;\\n            v2[i] = n as i32 - 1 - v1[i];\\n        }\\n        \\n        // ret1[i]: # of elements bigger than v[i] on the right of i\\n        // ret2[i]: # of elements smaller than v[i] on the left of i\\n        let (mut ret1, mut ret2) = (vec![0; n], vec![0; n]);\\n        Self::count_smaller(&v2, &mut ret1);\\n        v1.reverse();\\n        Self::count_smaller(&v1, &mut ret2);\\n        ret2.reverse();\\n        \\n        let mut ret = 0;\\n        for i in 1..n - 1 {\\n            ret += (ret1[i] as i64) * (ret2[i] as i64); \\n        }\\n        \\n        ret\\n    }\\n    \\n    // this is the solution to #315:\\n    // https://leetcode.com/problems/count-of-smaller-numbers-after-self/\\n    fn count_smaller(nums: &[i32], ret: &mut [i32]) {\\n        let n = nums.len();\\n        let mut indexes = (0..n).collect::<Vec<usize>>();\\n        \\n        Self::merge_sort(nums, &mut indexes, ret, 0, n - 1);\\n    }\\n    \\n    fn merge_sort(nums: &[i32], indexes: &mut [usize], ret: &mut [i32], left: usize, right: usize) {\\n        if left >= right { return }\\n        \\n        let mid = left + (right - left) / 2;\\n        Self::merge_sort(nums, indexes, ret, left, mid);\\n        Self::merge_sort(nums, indexes, ret, mid + 1, right);\\n        Self::merge(nums, indexes, ret, left, right, mid)\\n    }\\n    \\n    fn merge(nums: &[i32], indexes: &mut [usize], ret: &mut [i32], left: usize, right: usize, mid: usize) {\\n        let (mut i, mut j) = (left, mid + 1);\\n        let mut cnt = 0;\\n        let mut temp = vec![];\\n            \\n        while i <= mid && j <= right {\\n            if nums[indexes[j]] < nums[indexes[i]] {\\n                cnt += 1;\\n                temp.push(indexes[j]);\\n                j += 1;\\n            } else {\\n                temp.push(indexes[i]);\\n                ret[indexes[i]] += cnt;\\n                i += 1;\\n            }\\n        }\\n            \\n        while i <= mid {\\n            temp.push(indexes[i]);\\n            ret[indexes[i]] += cnt;\\n            i += 1;\\n        }\\n            \\n        while j <= right {\\n            temp.push(indexes[j]);\\n            j += 1;\\n        }\\n        \\n        for (it, a) in temp.iter().enumerate() {\\n            indexes[left + it] = *a;\\n        }\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust",
                    "Merge Sort"
                ],
                "code": "~~~\\n// This solution directly uses the solution of problem #315\\n// \\nimpl Solution {\\n    pub fn good_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i64 {\\n        let n = nums1.len();\\n        let mut data = vec![0; n];\\n        for (i, a) in nums1.iter().enumerate() { \\n            data[*a as usize] = i;\\n        }\\n        \\n        // v1: sorting of index of nums2 based on the order nums1\\n        // therefore, the answer to find the # increasing sub-sequences of length 3\\n        let (mut v1, mut v2) = (vec![0i32; n], vec![0i32; n]);\\n        for (i, a) in nums2.iter().enumerate() { \\n            v1[i] = data[*a as usize] as i32;\\n            v2[i] = n as i32 - 1 - v1[i];\\n        }\\n        \\n        // ret1[i]: # of elements bigger than v[i] on the right of i\\n        // ret2[i]: # of elements smaller than v[i] on the left of i\\n        let (mut ret1, mut ret2) = (vec![0; n], vec![0; n]);\\n        Self::count_smaller(&v2, &mut ret1);\\n        v1.reverse();\\n        Self::count_smaller(&v1, &mut ret2);\\n        ret2.reverse();\\n        \\n        let mut ret = 0;\\n        for i in 1..n - 1 {\\n            ret += (ret1[i] as i64) * (ret2[i] as i64); \\n        }\\n        \\n        ret\\n    }\\n    \\n    // this is the solution to #315:\\n    // https://leetcode.com/problems/count-of-smaller-numbers-after-self/\\n    fn count_smaller(nums: &[i32], ret: &mut [i32]) {\\n        let n = nums.len();\\n        let mut indexes = (0..n).collect::<Vec<usize>>();\\n        \\n        Self::merge_sort(nums, &mut indexes, ret, 0, n - 1);\\n    }\\n    \\n    fn merge_sort(nums: &[i32], indexes: &mut [usize], ret: &mut [i32], left: usize, right: usize) {\\n        if left >= right { return }\\n        \\n        let mid = left + (right - left) / 2;\\n        Self::merge_sort(nums, indexes, ret, left, mid);\\n        Self::merge_sort(nums, indexes, ret, mid + 1, right);\\n        Self::merge(nums, indexes, ret, left, right, mid)\\n    }\\n    \\n    fn merge(nums: &[i32], indexes: &mut [usize], ret: &mut [i32], left: usize, right: usize, mid: usize) {\\n        let (mut i, mut j) = (left, mid + 1);\\n        let mut cnt = 0;\\n        let mut temp = vec![];\\n            \\n        while i <= mid && j <= right {\\n            if nums[indexes[j]] < nums[indexes[i]] {\\n                cnt += 1;\\n                temp.push(indexes[j]);\\n                j += 1;\\n            } else {\\n                temp.push(indexes[i]);\\n                ret[indexes[i]] += cnt;\\n                i += 1;\\n            }\\n        }\\n            \\n        while i <= mid {\\n            temp.push(indexes[i]);\\n            ret[indexes[i]] += cnt;\\n            i += 1;\\n        }\\n            \\n        while j <= right {\\n            temp.push(indexes[j]);\\n            j += 1;\\n        }\\n        \\n        for (it, a) in temp.iter().enumerate() {\\n            indexes[left + it] = *a;\\n        }\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2322828,
                "title": "c-segment-tree-to-the-rescue",
                "content": "```\\nclass Solution {\\npublic:\\n    class node{\\n        public:\\n        long long start, end, mid, count;\\n        node *left, *right;\\n        node(long long x, long long y){\\n            start=x;\\n            end=y;\\n            mid=(x+1==y? x: (x+y)/2);\\n            count=0;\\n            left=NULL;\\n            right=NULL;\\n        }\\n    };\\n    \\n    void add(node *root, long long num){\\n        if(root->start>num || root->end<num)\\n            return;\\n        root->count++;\\n        if(root->start==root->end)\\n            return;\\n        if(root->left==NULL)\\n            root->left = new node(root->start, root->mid);\\n        if(root->right==NULL)\\n            root->right = new node(root->mid+1, root->end);\\n        if(root->mid>=num)\\n            add(root->left, num);\\n        else\\n            add(root->right, num);\\n    }\\n    \\n    long long count(node *root, long long num)\\n    {\\n        if(root==NULL || root->start>num)\\n            return 0;\\n        if(root->end<=num)\\n            return root->count;\\n        return count(root->left, num) + count(root->right, num);\\n    }\\n    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        node *root1 = new node(0, 100000);\\n        node *root2 = new node(0, 100000);\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums2.size(); i++)\\n            mp[nums2[i]]=i;\\n        vector<vector<long long>> res(nums1.size(), vector<long long>(2));\\n        for(int i=0; i<nums1.size(); i++)\\n        {   \\n            res[i][0] = count(root1, mp[nums1[i]]);\\n            add(root1, mp[nums1[i]]);\\n        }\\n        for(int i=nums1.size()-1; i>=0; i--)\\n        {\\n            res[i][1] = nums1.size() -1 -i - count(root2, mp[nums1[i]]);\\n            add(root2, mp[nums1[i]]);\\n        }\\n        long long ans=0;\\n        for(int i=0; i<res.size(); i++)\\n            ans+=res[i][0]*res[i][1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class node{\\n        public:\\n        long long start, end, mid, count;\\n        node *left, *right;\\n        node(long long x, long long y){\\n            start=x;\\n            end=y;\\n            mid=(x+1==y? x: (x+y)/2);\\n            count=0;\\n            left=NULL;\\n            right=NULL;\\n        }\\n    };\\n    \\n    void add(node *root, long long num){\\n        if(root->start>num || root->end<num)\\n            return;\\n        root->count++;\\n        if(root->start==root->end)\\n            return;\\n        if(root->left==NULL)\\n            root->left = new node(root->start, root->mid);\\n        if(root->right==NULL)\\n            root->right = new node(root->mid+1, root->end);\\n        if(root->mid>=num)\\n            add(root->left, num);\\n        else\\n            add(root->right, num);\\n    }\\n    \\n    long long count(node *root, long long num)\\n    {\\n        if(root==NULL || root->start>num)\\n            return 0;\\n        if(root->end<=num)\\n            return root->count;\\n        return count(root->left, num) + count(root->right, num);\\n    }\\n    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        node *root1 = new node(0, 100000);\\n        node *root2 = new node(0, 100000);\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums2.size(); i++)\\n            mp[nums2[i]]=i;\\n        vector<vector<long long>> res(nums1.size(), vector<long long>(2));\\n        for(int i=0; i<nums1.size(); i++)\\n        {   \\n            res[i][0] = count(root1, mp[nums1[i]]);\\n            add(root1, mp[nums1[i]]);\\n        }\\n        for(int i=nums1.size()-1; i>=0; i--)\\n        {\\n            res[i][1] = nums1.size() -1 -i - count(root2, mp[nums1[i]]);\\n            add(root2, mp[nums1[i]]);\\n        }\\n        long long ans=0;\\n        for(int i=0; i<res.size(); i++)\\n            ans+=res[i][0]*res[i][1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289811,
                "title": "bit-fenwick-tree-solution",
                "content": "**TLE:**\\nWe need to find triplets which are present in increasing order by index both in nums1 and nums2.\\nWe can reduce this problem by sorting index of nums1 using index of  of nums2.\\n&nbsp;&nbsp;nums1: [4,0,1,3,2]\\n&nbsp;&nbsp;nums2: [4,1,0,2,3]\\n**sortedArray: [0,2,1,4,3]**\\nSince index of nums1 are in increasing order, we just need to consider order in sortedArray. Now we need to find count of increasing triplets in sortedArray.\\n(0, 2, 4) (0, 2, 3) (0, 1, 3) (0, 1, 4)\\n```\\nclass Solution {    \\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int[] arr = new int[n];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            map.put(nums1[i], i);\\n        }\\n        for(int i = 0; i < n; i++){\\n            arr[i] = map.get(nums2[i]);\\n        }\\n        long ans = 0;\\n        long cnt = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                for(int k = j+1; k < n; k++){\\n                    if(arr[i] < arr[j] && arr[j] < arr[k]) ans++;\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nTo optimize this solution, \\nWe can calculate triplets by considering every element as mid (in triplet) element.\\n**Count of triplets that contains 1 as mid element =**&nbsp;&nbsp;**Count of Smaller elements on the left side of 1 x Count of Greater elements on the right side of 1** = &nbsp;&nbsp;1(0) * 2 (4, 3) =&nbsp;&nbsp;2\\n\\t\\n\\nFor any index i,\\n&nbsp;&nbsp;Find count of smaller numbers in 0...i-1 (say x)\\n&nbsp;&nbsp;Find count of greater numbers in i...n-1 (say y)\\n&nbsp;&nbsp;&nbsp;&nbsp;ans += (x*y)\\n\\nSo total complexity of this algorithm would be **O(n^2)**\\n\\nWe can use fenwick tree to find smaller and greater numbers in just LogN time.\\nComplexity would reduce to **O(n*logn)**\\n\\n```\\nclass Solution {    \\n    public long sum(int[] BIT, int idx){\\n        long ans = 0;\\n        idx += 1;\\n        for(; idx > 0; idx -= (idx & -idx)){\\n            ans += BIT[idx];\\n        }\\n        return ans;\\n    }\\n    \\n    public void update(int[] BIT, int idx, int val){\\n        idx += 1;\\n        for(; idx < BIT.length; idx += (idx & -idx)){\\n            BIT[idx] += val;\\n        }\\n    }\\n    \\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int[] arr = new int[n];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            map.put(nums1[i], i);\\n        }\\n        for(int i = 0; i < n; i++){\\n            arr[i] = map.get(nums2[i]);\\n        }\\n        System.out.println(Arrays.toString(arr));\\n        long ans = 0;\\n        int max = 0;\\n        for(int i : arr) if (max < i) max = i;\\n        int[] BIT = new int[max+2];\\n        HashMap<Integer, Long> lowLeft = new HashMap<>();\\n        HashMap<Integer, Long> highRight = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            // find smallest in left\\n            long low = sum(BIT, arr[i]-1);\\n            update(BIT, arr[i], 1);\\n            lowLeft.put(arr[i], low);\\n        }\\n        BIT = new int[max+2];\\n        for(int i = n-1; i >= 0; i--){\\n            // find biggest in right\\n            long high = sum(BIT, max) - sum(BIT, arr[i]);\\n            update(BIT, arr[i], 1);\\n            highRight.put(arr[i], high);\\n        }\\n        for(int i = 0; i < n; i++){\\n            ans += lowLeft.get(arr[i]) * highRight.get(arr[i]);\\n        }\\n        return ans;\\n    }\\n} \\n```\\nRef to implement Fenwick Tree: https://www.youtube.com/watch?v=NOykDuH1_OY&ab_channel=Luv",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {    \\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int[] arr = new int[n];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            map.put(nums1[i], i);\\n        }\\n        for(int i = 0; i < n; i++){\\n            arr[i] = map.get(nums2[i]);\\n        }\\n        long ans = 0;\\n        long cnt = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                for(int k = j+1; k < n; k++){\\n                    if(arr[i] < arr[j] && arr[j] < arr[k]) ans++;\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {    \\n    public long sum(int[] BIT, int idx){\\n        long ans = 0;\\n        idx += 1;\\n        for(; idx > 0; idx -= (idx & -idx)){\\n            ans += BIT[idx];\\n        }\\n        return ans;\\n    }\\n    \\n    public void update(int[] BIT, int idx, int val){\\n        idx += 1;\\n        for(; idx < BIT.length; idx += (idx & -idx)){\\n            BIT[idx] += val;\\n        }\\n    }\\n    \\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int[] arr = new int[n];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            map.put(nums1[i], i);\\n        }\\n        for(int i = 0; i < n; i++){\\n            arr[i] = map.get(nums2[i]);\\n        }\\n        System.out.println(Arrays.toString(arr));\\n        long ans = 0;\\n        int max = 0;\\n        for(int i : arr) if (max < i) max = i;\\n        int[] BIT = new int[max+2];\\n        HashMap<Integer, Long> lowLeft = new HashMap<>();\\n        HashMap<Integer, Long> highRight = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            // find smallest in left\\n            long low = sum(BIT, arr[i]-1);\\n            update(BIT, arr[i], 1);\\n            lowLeft.put(arr[i], low);\\n        }\\n        BIT = new int[max+2];\\n        for(int i = n-1; i >= 0; i--){\\n            // find biggest in right\\n            long high = sum(BIT, max) - sum(BIT, arr[i]);\\n            update(BIT, arr[i], 1);\\n            highRight.put(arr[i], high);\\n        }\\n        for(int i = 0; i < n; i++){\\n            ans += lowLeft.get(arr[i]) * highRight.get(arr[i]);\\n        }\\n        return ans;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276763,
                "title": "java-merge-sort-2-times",
                "content": "```\\nclass Solution {\\n    public void merge_1(long[]ans,int[]res,int i,int j){\\n        if(i==j)return;\\n        \\n        int mid=(i+j)/2;\\n        merge_1(ans,res,i,mid);\\n        merge_1(ans,res,mid+1,j);\\n        \\n        int[]tmp=new int[j-i+1];\\n        int k=0;\\n        int k1=i;\\n        int k2=mid+1;\\n        \\n        while(k1<=mid && k2<=j){\\n            if(res[k1] < res[k2])\\n                tmp[k++]=res[k1++];\\n            else{\\n                ans[res[k2]] +=k1-i;\\n                tmp[k++]=res[k2++];\\n            }\\n        }\\n        while(k1<=mid)\\n           tmp[k++]=res[k1++];\\n        while(k2<=j){\\n            ans[res[k2]] +=k1-i;\\n            tmp[k++]=res[k2++];\\n        }\\n        \\n        k=0;\\n        k1=i;\\n        while(k<tmp.length)\\n            res[k1++]=tmp[k++];\\n        \\n    }\\n    public void merge_2(long[]ans,int[]res,int i,int j){\\n        if(i==j)return;\\n        \\n        int mid=(i+j)/2;\\n         merge_2(ans,res,i,mid);\\n         merge_2(ans,res,mid+1,j);\\n        \\n        int[]tmp=new int[j-i+1];\\n        int k=0;\\n        int k1=i;\\n        int k2=mid+1;\\n        \\n        while(k1<=mid && k2<=j){\\n            if(res[k1] < res[k2]){\\n                ans[res[k1]] +=j-k2+1;\\n                tmp[k++]=res[k1++];}\\n            else{\\n                tmp[k++]=res[k2++];\\n            }\\n        }\\n        \\n        while(k1<=mid)\\n           tmp[k++]=res[k1++];\\n        while(k2<=j)\\n            tmp[k++]=res[k2++];\\n        \\n        k=0;\\n        k1=i;\\n        while(k<tmp.length)\\n            res[k1++]=tmp[k++];\\n        \\n    }\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        long[]left=new long[n];\\n        long[]right=new long[n];\\n        \\n        Map<Integer,Integer>map=new HashMap<>();\\n        for(int i=0;i<nums2.length;i++)\\n            map.put(nums2[i],i);\\n        \\n        int[]res1=new int[n];\\n        for(int i=0;i<nums1.length;i++)\\n            res1[i]=map.get(nums1[i]);\\n        \\n       \\n        int[]res2=Arrays.copyOf(res1,n);\\n        \\n        \\n        \\n        merge_1(left,res1,0,n-1);\\n        merge_2(right,res2,0,n-1);\\n        \\n        long ans=0;\\n        \\n        for(int i=0;i<n;i++){\\n             //System.out.println(i+\" \"+left[i]+\" \"+right[i]);\\n            ans +=(left[i]*right[i]);}\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void merge_1(long[]ans,int[]res,int i,int j){\\n        if(i==j)return;\\n        \\n        int mid=(i+j)/2;\\n        merge_1(ans,res,i,mid);\\n        merge_1(ans,res,mid+1,j);\\n        \\n        int[]tmp=new int[j-i+1];\\n        int k=0;\\n        int k1=i;\\n        int k2=mid+1;\\n        \\n        while(k1<=mid && k2<=j){\\n            if(res[k1] < res[k2])\\n                tmp[k++]=res[k1++];\\n            else{\\n                ans[res[k2]] +=k1-i;\\n                tmp[k++]=res[k2++];\\n            }\\n        }\\n        while(k1<=mid)\\n           tmp[k++]=res[k1++];\\n        while(k2<=j){\\n            ans[res[k2]] +=k1-i;\\n            tmp[k++]=res[k2++];\\n        }\\n        \\n        k=0;\\n        k1=i;\\n        while(k<tmp.length)\\n            res[k1++]=tmp[k++];\\n        \\n    }\\n    public void merge_2(long[]ans,int[]res,int i,int j){\\n        if(i==j)return;\\n        \\n        int mid=(i+j)/2;\\n         merge_2(ans,res,i,mid);\\n         merge_2(ans,res,mid+1,j);\\n        \\n        int[]tmp=new int[j-i+1];\\n        int k=0;\\n        int k1=i;\\n        int k2=mid+1;\\n        \\n        while(k1<=mid && k2<=j){\\n            if(res[k1] < res[k2]){\\n                ans[res[k1]] +=j-k2+1;\\n                tmp[k++]=res[k1++];}\\n            else{\\n                tmp[k++]=res[k2++];\\n            }\\n        }\\n        \\n        while(k1<=mid)\\n           tmp[k++]=res[k1++];\\n        while(k2<=j)\\n            tmp[k++]=res[k2++];\\n        \\n        k=0;\\n        k1=i;\\n        while(k<tmp.length)\\n            res[k1++]=tmp[k++];\\n        \\n    }\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        long[]left=new long[n];\\n        long[]right=new long[n];\\n        \\n        Map<Integer,Integer>map=new HashMap<>();\\n        for(int i=0;i<nums2.length;i++)\\n            map.put(nums2[i],i);\\n        \\n        int[]res1=new int[n];\\n        for(int i=0;i<nums1.length;i++)\\n            res1[i]=map.get(nums1[i]);\\n        \\n       \\n        int[]res2=Arrays.copyOf(res1,n);\\n        \\n        \\n        \\n        merge_1(left,res1,0,n-1);\\n        merge_2(right,res2,0,n-1);\\n        \\n        long ans=0;\\n        \\n        for(int i=0;i<n;i++){\\n             //System.out.println(i+\" \"+left[i]+\" \"+right[i]);\\n            ans +=(left[i]*right[i]);}\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228029,
                "title": "java-77-148-time-limit-exceeded",
                "content": "```\\nclass Solution {\\n    //Global Variable For Memoization\\n    HashSet<ArrayList<Integer>> memoSet = new HashSet<>();\\n    \\n    //GoodTriplets Method\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        //Data Declaration\\n        long goodTripletsCount = 0;\\n        \\n        //Sets To Store All SubArrays Possible\\n        HashSet<ArrayList<Integer>> setA = new HashSet<>();\\n        HashSet<ArrayList<Integer>> setB = new HashSet<>();\\n        \\n        //GetSubArray Call\\n        setA = getSubArray(nums1, 0, 1, 2, setA, memoSet);\\n        //Refresh MemoSet\\n        memoSet = new HashSet<>();\\n        //GetSubArray Call\\n        setB = getSubArray(nums2, 0, 1, 2, setB, memoSet);\\n        \\n        //Find The Count Of Similar SubArrays\\n        for(ArrayList<Integer> list : setA){\\n            goodTripletsCount += setB.remove(list) ? 1 : 0;\\n        }\\n        \\n        //Return\\n        return goodTripletsCount;\\n    }\\n    \\n    // GetSubArray Method\\n    // Divide And Conquer - Recursive Call\\n    public HashSet<ArrayList<Integer>> getSubArray(int[] arr, int index, int indexA, int indexB, HashSet<ArrayList<Integer>> set, HashSet<ArrayList<Integer>> memoSet){\\n        //Checking The Possibilities For Triplet Formation\\n        //Control Statement\\n        if(index > arr.length - 3 || indexA > arr.length - 2 || indexB > arr.length - 1)\\n            return set;\\n        \\n        //Memoization \\n        ArrayList<Integer> subProb = new ArrayList<>();\\n        for(int a : arr){\\n            subProb.add(a);\\n        }\\n        subProb.add(index); \\n        subProb.add(indexA); \\n        subProb.add(indexB);\\n        if(!memoSet.add(subProb))\\n            return set;\\n        \\n        //If No Other Formation Not Possible\\n        //Control Statement\\n        if(arr.length == 3){\\n            ArrayList<Integer> list = new ArrayList<>();\\n            for(int a : arr)\\n                list.add(a);\\n            set.add(list);\\n            return set;\\n        }\\n        \\n        //Basic Logic \\n        ArrayList<Integer> list = new ArrayList<>();\\n        list.add(arr[index]);\\n        list.add(arr[indexA]);\\n        list.add(arr[indexB]);\\n        set.add(list);\\n        \\n        //Divide And Conquer - SubProblems\\n        set = getSubArray(arr, index, indexA, indexB+1, set, memoSet);\\n        set = getSubArray(arr, index, indexA+1, indexB+1, set, memoSet);\\n        set = getSubArray(arr, index+1, indexA+1, indexB+1, set, memoSet);\\n        int temp[] = Arrays.copyOfRange(arr, index+1, arr.length);\\n        set = getSubArray(temp, 0, 1, 2, set, memoSet);\\n        \\n        //Return\\n        return set;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //Global Variable For Memoization\\n    HashSet<ArrayList<Integer>> memoSet = new HashSet<>();\\n    \\n    //GoodTriplets Method\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        //Data Declaration\\n        long goodTripletsCount = 0;\\n        \\n        //Sets To Store All SubArrays Possible\\n        HashSet<ArrayList<Integer>> setA = new HashSet<>();\\n        HashSet<ArrayList<Integer>> setB = new HashSet<>();\\n        \\n        //GetSubArray Call\\n        setA = getSubArray(nums1, 0, 1, 2, setA, memoSet);\\n        //Refresh MemoSet\\n        memoSet = new HashSet<>();\\n        //GetSubArray Call\\n        setB = getSubArray(nums2, 0, 1, 2, setB, memoSet);\\n        \\n        //Find The Count Of Similar SubArrays\\n        for(ArrayList<Integer> list : setA){\\n            goodTripletsCount += setB.remove(list) ? 1 : 0;\\n        }\\n        \\n        //Return\\n        return goodTripletsCount;\\n    }\\n    \\n    // GetSubArray Method\\n    // Divide And Conquer - Recursive Call\\n    public HashSet<ArrayList<Integer>> getSubArray(int[] arr, int index, int indexA, int indexB, HashSet<ArrayList<Integer>> set, HashSet<ArrayList<Integer>> memoSet){\\n        //Checking The Possibilities For Triplet Formation\\n        //Control Statement\\n        if(index > arr.length - 3 || indexA > arr.length - 2 || indexB > arr.length - 1)\\n            return set;\\n        \\n        //Memoization \\n        ArrayList<Integer> subProb = new ArrayList<>();\\n        for(int a : arr){\\n            subProb.add(a);\\n        }\\n        subProb.add(index); \\n        subProb.add(indexA); \\n        subProb.add(indexB);\\n        if(!memoSet.add(subProb))\\n            return set;\\n        \\n        //If No Other Formation Not Possible\\n        //Control Statement\\n        if(arr.length == 3){\\n            ArrayList<Integer> list = new ArrayList<>();\\n            for(int a : arr)\\n                list.add(a);\\n            set.add(list);\\n            return set;\\n        }\\n        \\n        //Basic Logic \\n        ArrayList<Integer> list = new ArrayList<>();\\n        list.add(arr[index]);\\n        list.add(arr[indexA]);\\n        list.add(arr[indexB]);\\n        set.add(list);\\n        \\n        //Divide And Conquer - SubProblems\\n        set = getSubArray(arr, index, indexA, indexB+1, set, memoSet);\\n        set = getSubArray(arr, index, indexA+1, indexB+1, set, memoSet);\\n        set = getSubArray(arr, index+1, indexA+1, indexB+1, set, memoSet);\\n        int temp[] = Arrays.copyOfRange(arr, index+1, arr.length);\\n        set = getSubArray(temp, 0, 1, 2, set, memoSet);\\n        \\n        //Return\\n        return set;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225770,
                "title": "javascript-128ms-w-some-explanation",
                "content": "I don\\'t take credit for this awesome solution.  I used the best of what I learned from others.  Didn\\'t know what a Fenwick Tree was until I encountered this problem, and now (after doing a few easier ones) I think I have my head around it.\\n\\nMost solutions use two `n*log(n)` scans using some sort of data structure to accumulate the number of values to the right and left of a given value, from its position in the second array.  One pass builds a list of \"left\" or \"small\" values, then the structure is reinitialized and rebuilt to obtain the \"right\" or \"larger\" values.\\n\\nThis one improves on it by eliminating the need to build the tree twice.\\n\\nThe number of items to the right of a given position in nums2 is given by:\\n\\n`(N - pos - 1) - (i - low)` where `pos` is the location in nums2, i is the number of items counted, and low is the calculated number of items to the left.\\n\\n![image](https://assets.leetcode.com/users/images/50626b1c-4ded-42cb-8c24-85774dc889e6_1656741473.290965.png)\\n\\n\\n```\\nfunction goodTriplets(nums1: number[], nums2: number[]): number {\\n    const N = nums1.length\\n    const B = N+1\\n    const newArray = () => new Array(N) as number[]\\n    const pos2 = nums2.reduce((arr, val, idx) => {arr[val] = idx; return arr} , newArray())\\n\\n    const BIT = new Array(N+1).fill(0) as number[]\\n    const add = (i:number, val=1) => {\\n        for(++i; i<B; i+=i&(-i)) {\\n            BIT[i] += val\\n        }\\n    }\\n    const query = (i:number) => {\\n        let res = 0\\n        for(++i; i>0; i-=i&(-i)) {\\n            res += BIT[i]\\n        }\\n        return res\\n    }\\n\\n    const tripletsForI = (acc: number, val: number, i: number) => {\\n        const pos = pos2[val],\\n            low = query(pos),\\n            high = (N-pos-1) - (i - low)\\n        add(pos)\\n        return acc + high * low\\n    }\\n\\n    return nums1.reduce(tripletsForI, 0)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nfunction goodTriplets(nums1: number[], nums2: number[]): number {\\n    const N = nums1.length\\n    const B = N+1\\n    const newArray = () => new Array(N) as number[]\\n    const pos2 = nums2.reduce((arr, val, idx) => {arr[val] = idx; return arr} , newArray())\\n\\n    const BIT = new Array(N+1).fill(0) as number[]\\n    const add = (i:number, val=1) => {\\n        for(++i; i<B; i+=i&(-i)) {\\n            BIT[i] += val\\n        }\\n    }\\n    const query = (i:number) => {\\n        let res = 0\\n        for(++i; i>0; i-=i&(-i)) {\\n            res += BIT[i]\\n        }\\n        return res\\n    }\\n\\n    const tripletsForI = (acc: number, val: number, i: number) => {\\n        const pos = pos2[val],\\n            low = query(pos),\\n            high = (N-pos-1) - (i - low)\\n        add(pos)\\n        return acc + high * low\\n    }\\n\\n    return nums1.reduce(tripletsForI, 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2190410,
                "title": "python-merge-sort-2-times",
                "content": "```\\nclass Solution:\\n    def goodTriplets(self, x: List[int], y: List[int]) -> int:\\n        l=len(x)\\n        f=[0 for i in range(l)]\\n        res=0\\n        def sort(i,j,ccc):\\n            nonlocal res\\n            m=(i+j)//2\\n            a=i\\n            b=m+1\\n            if ccc:\\n                su=sum(f[x[k]] for k in range(m+1,j+1))\\n            while a<=m and b<=j:\\n                if x[a]<x[b]:\\n                    if ccc==0:\\n                        f[x[a]]+=j-b+1\\n                    else:\\n                        res+=su\\n                    a+=1\\n                else:\\n                    if ccc:\\n                        su-=f[x[b]]\\n                    b+=1\\n            x[i:j+1]=sorted(x[i:j+1])\\n        def merge(i,j,ccc=0):\\n            if i>=j:return\\n            m=(i+j)//2\\n            merge(i,m,ccc)\\n            merge(m+1,j,ccc)\\n            sort(i,j,ccc)\\n        ind={}\\n        z=[0]*l\\n        for i in range(l):\\n            ind[y[i]]=i\\n        for i in range(l):\\n            x[i]=ind[x[i]]\\n        q=x.copy()\\n        merge(0,l-1,0)\\n        x=q\\n        merge(0,l-1,1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodTriplets(self, x: List[int], y: List[int]) -> int:\\n        l=len(x)\\n        f=[0 for i in range(l)]\\n        res=0\\n        def sort(i,j,ccc):\\n            nonlocal res\\n            m=(i+j)//2\\n            a=i\\n            b=m+1\\n            if ccc:\\n                su=sum(f[x[k]] for k in range(m+1,j+1))\\n            while a<=m and b<=j:\\n                if x[a]<x[b]:\\n                    if ccc==0:\\n                        f[x[a]]+=j-b+1\\n                    else:\\n                        res+=su\\n                    a+=1\\n                else:\\n                    if ccc:\\n                        su-=f[x[b]]\\n                    b+=1\\n            x[i:j+1]=sorted(x[i:j+1])\\n        def merge(i,j,ccc=0):\\n            if i>=j:return\\n            m=(i+j)//2\\n            merge(i,m,ccc)\\n            merge(m+1,j,ccc)\\n            sort(i,j,ccc)\\n        ind={}\\n        z=[0]*l\\n        for i in range(l):\\n            ind[y[i]]=i\\n        for i in range(l):\\n            x[i]=ind[x[i]]\\n        q=x.copy()\\n        merge(0,l-1,0)\\n        x=q\\n        merge(0,l-1,1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109710,
                "title": "use-2-times-fenwick-tree-bit-and-done",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    class fenwick\\n    {\\n        public :\\n        int nn;\\n        vector<ll> bit;\\n        fenwick(){}\\n        fenwick(int _n)\\n        { \\n            nn=_n;\\n            bit.resize(nn+1,0);\\n        }\\n\\n        void update(int id,int val)\\n        {\\n            while(id<=nn)\\n            {\\n                bit[id] += val; // bit[id]=max(bit[id], val); for max\\n                id+= id & -id;\\n            }\\n        }\\n\\n        ll pref(int id)\\n        {\\n            ll ans=0;\\n            while(id>0)\\n            {\\n                ans+=bit[id];   // ans=max(ans,bit[id]); for max\\n                id-= id & -id;\\n            }\\n            return ans;\\n        }\\n\\n        ll query(int l,int r) // for max l=1; [l,r]\\n        {\\n            return pref(r) - pref(l-1);\\n        }\\n    };\\n    \\n    long long goodTriplets(vector<int>& a, vector<int>& b) \\n    {\\n        int n=a.size();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n            mp[a[i]]=i+1;\\n        vector<int> v(n);\\n        for(int i=0;i<n;i++)\\n            v[i]=mp[b[i]];\\n        \\n        fenwick fn(1e5+50);\\n        vector<ll> val(n,0);\\n        for(int i=0;i<n;i++)\\n            val[i]=fn.query(1,v[i]-1),fn.update(v[i],1);\\n        for(int i=0;i<n;i++)\\n            fn.update(i+1,-1);\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n            ans+=fn.query(1,v[i]-1),fn.update(v[i],val[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    class fenwick\\n    {\\n        public :\\n        int nn;\\n        vector<ll> bit;\\n        fenwick(){}\\n        fenwick(int _n)\\n        { \\n            nn=_n;\\n            bit.resize(nn+1,0);\\n        }\\n\\n        void update(int id,int val)\\n        {\\n            while(id<=nn)\\n            {\\n                bit[id] += val; // bit[id]=max(bit[id], val); for max\\n                id+= id & -id;\\n            }\\n        }\\n\\n        ll pref(int id)\\n        {\\n            ll ans=0;\\n            while(id>0)\\n            {\\n                ans+=bit[id];   // ans=max(ans,bit[id]); for max\\n                id-= id & -id;\\n            }\\n            return ans;\\n        }\\n\\n        ll query(int l,int r) // for max l=1; [l,r]\\n        {\\n            return pref(r) - pref(l-1);\\n        }\\n    };\\n    \\n    long long goodTriplets(vector<int>& a, vector<int>& b) \\n    {\\n        int n=a.size();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n            mp[a[i]]=i+1;\\n        vector<int> v(n);\\n        for(int i=0;i<n;i++)\\n            v[i]=mp[b[i]];\\n        \\n        fenwick fn(1e5+50);\\n        vector<ll> val(n,0);\\n        for(int i=0;i<n;i++)\\n            val[i]=fn.query(1,v[i]-1),fn.update(v[i],1);\\n        for(int i=0;i<n;i++)\\n            fn.update(i+1,-1);\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n            ans+=fn.query(1,v[i]-1),fn.update(v[i],val[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092985,
                "title": "python-binary-index-tree-o-nlogn",
                "content": "```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        m = {}\\n        n = len(nums1)\\n        for i in range(n):\\n            m[nums2[i]] = i+1\\n        new = [m[i] for i in nums1]\\n        \\n        \\n        t = [0 for i in range(n+1)]\\n        def add(x,c):\\n            while x<=n:\\n                t[x] += c\\n                x += (x&(-x))\\n        def query(x):\\n            res = 0\\n            while x:\\n                res += t[x]\\n                x -= (x&(-x))\\n            return res\\n        p1 = []\\n        for i in range(n):\\n            cnt = query(new[i]-1)\\n            p1.append(cnt)\\n            add(new[i],1)\\n        t = [0 for i in range(n+1)]\\n        res = 0\\n        for i in range(n,0,-1):\\n            res += p1[i-1]*(query(n) - query(new[i-1]))\\n            add(new[i-1],1)\\n        return res\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        m = {}\\n        n = len(nums1)\\n        for i in range(n):\\n            m[nums2[i]] = i+1\\n        new = [m[i] for i in nums1]\\n        \\n        \\n        t = [0 for i in range(n+1)]\\n        def add(x,c):\\n            while x<=n:\\n                t[x] += c\\n                x += (x&(-x))\\n        def query(x):\\n            res = 0\\n            while x:\\n                res += t[x]\\n                x -= (x&(-x))\\n            return res\\n        p1 = []\\n        for i in range(n):\\n            cnt = query(new[i]-1)\\n            p1.append(cnt)\\n            add(new[i],1)\\n        t = [0 for i in range(n+1)]\\n        res = 0\\n        for i in range(n,0,-1):\\n            res += p1[i-1]*(query(n) - query(new[i-1]))\\n            add(new[i-1],1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966780,
                "title": "javascript-but-too-slow",
                "content": "Is there any possible way to optimize this solution? Or would a different approach in all be needed to improve this algo.\\n\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar goodTriplets = function(nums1, nums2) {\\n    if (nums1.length < 3 || nums2.length < 3) {\\n        return 0;\\n    }\\n    \\n    count = 0;\\n    \\n    // i will be the position of the middle term\\n    for (let i = 1; i < nums1.length - 1; i++) {\\n        let y = nums1[i];\\n        \\n        let lf1 = nums1.slice(0, i);\\n        let rt1 = nums1.slice(i + 1);\\n        \\n        let fixedIn2 = nums2.indexOf(y);\\n        let lf2 = nums2.slice(0, fixedIn2);\\n        let rt2 = nums2.slice(fixedIn2 + 1);\\n        \\n        let interL = lf1.filter(x => lf2.indexOf(x) !== -1).length;\\n        let interR = rt1.filter(x => rt2.indexOf(x) !== -1).length;\\n        \\n        count += interL * interR;\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar goodTriplets = function(nums1, nums2) {\\n    if (nums1.length < 3 || nums2.length < 3) {\\n        return 0;\\n    }\\n    \\n    count = 0;\\n    \\n    // i will be the position of the middle term\\n    for (let i = 1; i < nums1.length - 1; i++) {\\n        let y = nums1[i];\\n        \\n        let lf1 = nums1.slice(0, i);\\n        let rt1 = nums1.slice(i + 1);\\n        \\n        let fixedIn2 = nums2.indexOf(y);\\n        let lf2 = nums2.slice(0, fixedIn2);\\n        let rt2 = nums2.slice(fixedIn2 + 1);\\n        \\n        let interL = lf1.filter(x => lf2.indexOf(x) !== -1).length;\\n        let interR = rt1.filter(x => rt2.indexOf(x) !== -1).length;\\n        \\n        count += interL * interR;\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909806,
                "title": "python-merge-sort-o-n-logn",
                "content": "```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        n=len(nums1)\\n        mp={}\\n        new_nums2=[0]*n\\n\\t\\t# reorder nums2 into new_nums2 wrt nums1 in such a way that nums1 is considered in increasing order\\n\\t\\t# now find no of increasing triplets in new_nums2 using merge sort\\n        for i in range(n):\\n            mp[nums1[i]]=i\\n        for i in range(n):\\n            new_nums2[i]=mp[nums2[i]]\\n        smaller,greater=[0]*n,[0]*n\\n        def merge(arr):\\n            m=len(arr)\\n            if m<=1:\\n                return arr\\n            mid=m//2\\n            left_arr=merge(arr[0:mid])\\n            right_arr=merge(arr[mid:m])\\n            ll,hh=len(left_arr),len(right_arr)\\n            new_arr=[]\\n            i,j=0,0\\n            while i<ll and j<hh:\\n                if right_arr[j]<left_arr[i]:\\n                    y=right_arr[j]\\n                    idx=bisect.bisect_right(left_arr,y)\\n                    smaller[y]+=idx\\n                    new_arr.append(y)\\n                    j+=1\\n                else:\\n                    x=left_arr[i]\\n                    idx=bisect.bisect_right(right_arr,x)\\n                    greater[x]+=hh-idx\\n                    new_arr.append(x)\\n                    i+=1\\n            while i<ll:\\n                x=left_arr[i]\\n                idx=bisect.bisect_right(right_arr,x)\\n                greater[x]+=hh-idx\\n                new_arr.append(x)\\n                i+=1\\n            while j<hh:\\n                y=right_arr[j]\\n                idx=bisect.bisect_right(left_arr,y)\\n                smaller[y]+=idx\\n                new_arr.append(y)\\n                j+=1\\n            return new_arr\\n        merge(new_nums2)\\n        ans=0\\n        for i in range(n):\\n            ans+=smaller[i]*greater[i]\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        n=len(nums1)\\n        mp={}\\n        new_nums2=[0]*n\\n\\t\\t# reorder nums2 into new_nums2 wrt nums1 in such a way that nums1 is considered in increasing order\\n\\t\\t# now find no of increasing triplets in new_nums2 using merge sort\\n        for i in range(n):\\n            mp[nums1[i]]=i\\n        for i in range(n):\\n            new_nums2[i]=mp[nums2[i]]\\n        smaller,greater=[0]*n,[0]*n\\n        def merge(arr):\\n            m=len(arr)\\n            if m<=1:\\n                return arr\\n            mid=m//2\\n            left_arr=merge(arr[0:mid])\\n            right_arr=merge(arr[mid:m])\\n            ll,hh=len(left_arr),len(right_arr)\\n            new_arr=[]\\n            i,j=0,0\\n            while i<ll and j<hh:\\n                if right_arr[j]<left_arr[i]:\\n                    y=right_arr[j]\\n                    idx=bisect.bisect_right(left_arr,y)\\n                    smaller[y]+=idx\\n                    new_arr.append(y)\\n                    j+=1\\n                else:\\n                    x=left_arr[i]\\n                    idx=bisect.bisect_right(right_arr,x)\\n                    greater[x]+=hh-idx\\n                    new_arr.append(x)\\n                    i+=1\\n            while i<ll:\\n                x=left_arr[i]\\n                idx=bisect.bisect_right(right_arr,x)\\n                greater[x]+=hh-idx\\n                new_arr.append(x)\\n                i+=1\\n            while j<hh:\\n                y=right_arr[j]\\n                idx=bisect.bisect_right(left_arr,y)\\n                smaller[y]+=idx\\n                new_arr.append(y)\\n                j+=1\\n            return new_arr\\n        merge(new_nums2)\\n        ans=0\\n        for i in range(n):\\n            ans+=smaller[i]*greater[i]\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882767,
                "title": "java-0-nlogn",
                "content": "```\\nclass Solution {\\n    //Divide & conquer approach 0(nlogn)\\n    //no of indx which come before y in both array - X\\n    //no of indx which come after y in both array - Y\\n    //ans +=X*Y\\n    \\n    int[] nums1, nums2, indicies1;\\n    int[] left, right;\\n    \\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int len = nums1.length;\\n        this.nums1 = nums1;\\n        this.nums2 = nums2;\\n        \\n        indicies1 = new int[len];\\n        for (int i = 0; i < len; ++ i) {\\n            indicies1[nums1[i]] = i;\\n        }\\n        \\n        left = new int[len];\\n        right = new int[len];\\n        divideAndConquer(0, len - 1);\\n        \\n        long output = 0L;\\n        for (int i = 0; i < len; ++ i) {\\n            output += (long)left[i] * (long)right[i];\\n        }\\n        \\n        return output;\\n    }\\n    \\n    public void divideAndConquer(int l, int r) {\\n        if (l == r) {\\n            return;\\n        }\\n        \\n        // Divide\\n        int mid = l + (r - l) / 2;\\n        divideAndConquer(l, mid);\\n        divideAndConquer(mid + 1, r);\\n        \\n        // Conquer\\n        int i = 0, j = 0, k = 0;\\n        int[] temp1 = new int[mid - l + 1];\\n        int[] temp2 = new int[r - mid];\\n        \\n        System.arraycopy(nums2, l, temp1, 0, mid - l + 1);\\n        System.arraycopy(nums2, mid + 1, temp2, 0, r - mid);\\n        \\n        int[] temp = new int[r - l + 1];\\n        \\n        // populating left\\n        while (i < temp1.length && j < temp2.length) {\\n            if (indicies1[temp1[i]] < indicies1[temp2[j]]) {\\n                temp[k] = temp1[i];\\n                ++ i;\\n            } else {\\n                temp[k] = temp2[j];\\n                left[temp2[j]] += i;\\n                ++ j;\\n            }\\n            ++ k;\\n        }\\n        \\n        while (i < temp1.length) {\\n            temp[k] = temp1[i];\\n            ++ i;\\n            ++ k;\\n        }\\n        \\n        while (j < temp2.length) {\\n            temp[k] = temp2[j];\\n            left[temp2[j]] += i;\\n            ++ j;\\n            ++ k;\\n        }\\n        \\n        System.arraycopy(temp, 0, nums2, l, r - l + 1);\\n        \\n        // Populating right\\n        i = temp1.length - 1;\\n        j = temp2.length - 1;\\n        k = temp.length - 1;\\n        while (i >= 0 && j >= 0) {\\n            if (indicies1[temp1[i]] > indicies1[temp2[j]]) {\\n                right[temp1[i]] += temp2.length - j - 1;\\n                -- i;\\n            } else {\\n                -- j;\\n            }\\n        }\\n        \\n        while (i >= 0) {\\n            right[temp1[i]] += temp2.length - j - 1;\\n            -- i;\\n        }\\n    }\\n}``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //Divide & conquer approach 0(nlogn)\\n    //no of indx which come before y in both array - X\\n    //no of indx which come after y in both array - Y\\n    //ans +=X*Y\\n    \\n    int[] nums1, nums2, indicies1;\\n    int[] left, right;\\n    \\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int len = nums1.length;\\n        this.nums1 = nums1;\\n        this.nums2 = nums2;\\n        \\n        indicies1 = new int[len];\\n        for (int i = 0; i < len; ++ i) {\\n            indicies1[nums1[i]] = i;\\n        }\\n        \\n        left = new int[len];\\n        right = new int[len];\\n        divideAndConquer(0, len - 1);\\n        \\n        long output = 0L;\\n        for (int i = 0; i < len; ++ i) {\\n            output += (long)left[i] * (long)right[i];\\n        }\\n        \\n        return output;\\n    }\\n    \\n    public void divideAndConquer(int l, int r) {\\n        if (l == r) {\\n            return;\\n        }\\n        \\n        // Divide\\n        int mid = l + (r - l) / 2;\\n        divideAndConquer(l, mid);\\n        divideAndConquer(mid + 1, r);\\n        \\n        // Conquer\\n        int i = 0, j = 0, k = 0;\\n        int[] temp1 = new int[mid - l + 1];\\n        int[] temp2 = new int[r - mid];\\n        \\n        System.arraycopy(nums2, l, temp1, 0, mid - l + 1);\\n        System.arraycopy(nums2, mid + 1, temp2, 0, r - mid);\\n        \\n        int[] temp = new int[r - l + 1];\\n        \\n        // populating left\\n        while (i < temp1.length && j < temp2.length) {\\n            if (indicies1[temp1[i]] < indicies1[temp2[j]]) {\\n                temp[k] = temp1[i];\\n                ++ i;\\n            } else {\\n                temp[k] = temp2[j];\\n                left[temp2[j]] += i;\\n                ++ j;\\n            }\\n            ++ k;\\n        }\\n        \\n        while (i < temp1.length) {\\n            temp[k] = temp1[i];\\n            ++ i;\\n            ++ k;\\n        }\\n        \\n        while (j < temp2.length) {\\n            temp[k] = temp2[j];\\n            left[temp2[j]] += i;\\n            ++ j;\\n            ++ k;\\n        }\\n        \\n        System.arraycopy(temp, 0, nums2, l, r - l + 1);\\n        \\n        // Populating right\\n        i = temp1.length - 1;\\n        j = temp2.length - 1;\\n        k = temp.length - 1;\\n        while (i >= 0 && j >= 0) {\\n            if (indicies1[temp1[i]] > indicies1[temp2[j]]) {\\n                right[temp1[i]] += temp2.length - j - 1;\\n                -- i;\\n            } else {\\n                -- j;\\n            }\\n        }\\n        \\n        while (i >= 0) {\\n            right[temp1[i]] += temp2.length - j - 1;\\n            -- i;\\n        }\\n    }\\n}``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879558,
                "title": "js",
                "content": "```\\n\\nvar goodTriplets = function (nums1, nums2) {\\n\\tlet triplets = 0, sorted;\\n\\tconst pos = {}, pre = {}, post = {}, n = nums2.length,\\n\\t\\tpush = (num, isRev) => {\\n\\t\\t\\tlet low = 0,\\n\\t\\t\\t\\thigh = sorted.length,\\n\\t\\t\\t\\tmid;\\n\\t\\t\\twhile (low < high) {\\n\\t\\t\\t\\tmid = (low + high) >>> 1;\\n\\t\\t\\t\\tsorted[mid] < num ? (low = mid + 1) : (high = mid);\\n\\t\\t\\t}\\n\\t\\t\\tif (num > sorted[low]) low++;\\n\\t\\t\\tsorted.splice(low, 0, num);\\n\\t\\t\\treturn isRev ? sorted.length - low - 1 : low;\\n\\t\\t},\\n\\t\\tfillPrePost = (obj, isPost) => {\\n\\t\\t\\tsorted = [];\\n\\t\\t\\tfor (let i = 0; i < n; i++)\\n\\t\\t\\t\\tobj[isPost ? n - 1 - i : i] = push(\\n\\t\\t\\t\\t\\tpos[nums2[isPost ? n - 1 - i : i]],\\n\\t\\t\\t\\t\\tisPost\\n\\t\\t\\t\\t);\\n\\t\\t};\\n\\t\\t\\n\\tfor (let i = 0; i < nums1.length; i++) pos[nums1[i]] = i;\\n\\t\\n\\tfillPrePost(pre, false);\\n\\tfillPrePost(post, true);\\n\\n\\tfor (let i = 1; i < n; i++) triplets += pre[i] * post[i];\\n\\n\\treturn triplets;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar goodTriplets = function (nums1, nums2) {\\n\\tlet triplets = 0, sorted;\\n\\tconst pos = {}, pre = {}, post = {}, n = nums2.length,\\n\\t\\tpush = (num, isRev) => {\\n\\t\\t\\tlet low = 0,\\n\\t\\t\\t\\thigh = sorted.length,\\n\\t\\t\\t\\tmid;\\n\\t\\t\\twhile (low < high) {\\n\\t\\t\\t\\tmid = (low + high) >>> 1;\\n\\t\\t\\t\\tsorted[mid] < num ? (low = mid + 1) : (high = mid);\\n\\t\\t\\t}\\n\\t\\t\\tif (num > sorted[low]) low++;\\n\\t\\t\\tsorted.splice(low, 0, num);\\n\\t\\t\\treturn isRev ? sorted.length - low - 1 : low;\\n\\t\\t},\\n\\t\\tfillPrePost = (obj, isPost) => {\\n\\t\\t\\tsorted = [];\\n\\t\\t\\tfor (let i = 0; i < n; i++)\\n\\t\\t\\t\\tobj[isPost ? n - 1 - i : i] = push(\\n\\t\\t\\t\\t\\tpos[nums2[isPost ? n - 1 - i : i]],\\n\\t\\t\\t\\t\\tisPost\\n\\t\\t\\t\\t);\\n\\t\\t};\\n\\t\\t\\n\\tfor (let i = 0; i < nums1.length; i++) pos[nums1[i]] = i;\\n\\t\\n\\tfillPrePost(pre, false);\\n\\tfillPrePost(post, true);\\n\\n\\tfor (let i = 1; i < n; i++) triplets += pre[i] * post[i];\\n\\n\\treturn triplets;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1821147,
                "title": "fast-cpp-solution-using-a-single-fenwick-tree",
                "content": "Let the triplet be {x,y,z}. The idea is to fix the value of \\'y\\' [from 0 to n-1] and find all possible combinations for {x,z}, where x comes from the left portion, i.e., before \\'y\\' in both arrays and z comes from the right portion, i.e., after \\'y\\' in both arrays.\\nFor example, let the two arrays be \\n```\\n\\t\\t\\t\\t0 1 2 3 4 5\\n\\t\\t\\t\\t2 1 3 5 0 4\\n\\t\\t\\t\\tif y = 3 then the possible combinations for {x,z} are -> {1,4}, {1,5}, {2,4}, {2,5}\\n```\\n\\t\\t\\t\\t\\nStore the index corresponding to the value in array b. This information can be stored in either a map or an array(since values are from 0 to n-1).\\nNow let us iterate in array a and fix the value of y each time. Let the common values in left portion of both the arrays be lcommon and similarly for right portion rcommon. So `lcommon * rcommon` needs to be added to the answer everytime. \\nTo find lcommon we will use a fenwick tree and to find rcommon we will use a simple trick that uses lcommon.\\nInitialize the tree with zeros (size is n, same as the size of arrays). While iterating on array a, we update the tree at the index of the corresponding value in array b. Now to find lcommon we can simply make a `query(index_of_y_in_array_b - 1)` to the tree  which gives us the count of values that have already occured in array a and are on the left hand side of \\'y\\' in array b.\\nNow to find rcommon, we will make use of the value of lcommon. Let r2 be the number of elements on right hand side of \\'y\\' in array b and `luncommon` be the number of elements that are in the left portion of array a but not in the left portion of array b and l1 be the number of elements in the left portion of array a.\\n`luncommon = l1 - lcommon`\\n`r2 = luncommon + rcommon`\\n`rcommon = r2 - luncommon`\\n\\n```\\nclass Solution {\\n    #define ll long long\\n    #define rep(i,a,b)  for(ll i=a;i<=b;i++)\\n    \\n    \\npublic:\\n    \\n    vector<ll> bit;\\n\\nll query(ll i) {\\n\\tll res=0;\\n\\twhile(i>=0) {\\n\\t\\tres+=bit[i];\\n\\t\\ti= (i & (i+1)) -1;\\n\\t}\\n\\treturn res;\\n}\\n\\nvoid update(ll i, ll n, ll val) {\\n\\twhile(i<n) {\\n\\t\\tbit[i] += val;\\n\\t\\ti |=i+1;\\n\\t}\\n}\\n\\nll right_side_common(ll n, ll l1, ll l2, ll lcommon) {\\n\\tll r2 = n-(l2+1);\\n\\tll rcommon = max(0LL, r2 - (l1-lcommon));\\n\\treturn rcommon;\\n}\\n    long long goodTriplets(vector<int>& a, vector<int>& b) {\\n        ll i,n;\\n\\t\\tn = a.size();\\n\\t\\t\\n\\t\\tvector<ll> indexb(n,-1);\\n\\t\\trep(i,0,n-1) {\\n\\t\\t\\tindexb[b[i]] = i;\\n\\t\\t}\\n\\t\\tbit.resize(n,0);\\n\\t\\tupdate(indexb[a[0]], n, 1LL);\\n\\t\\tll ans =0;\\n\\t\\t// {x,y,z} iterate and fix y \\n\\t\\trep(i,1,n-2) {\\n\\t\\t\\tll common = indexb[a[i]]>0 ? query(indexb[a[i]]-1) : 0;\\n\\t\\t\\tll rcommon = right_side_common(n, i, indexb[a[i]], common);\\n\\t\\t\\tans +=common*rcommon;\\n\\t\\t\\tupdate(indexb[a[i]], n, 1LL);\\n\\t\\t}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Indexed Tree"
                ],
                "code": "```\\n\\t\\t\\t\\t0 1 2 3 4 5\\n\\t\\t\\t\\t2 1 3 5 0 4\\n\\t\\t\\t\\tif y = 3 then the possible combinations for {x,z} are -> {1,4}, {1,5}, {2,4}, {2,5}\\n```\n```\\nclass Solution {\\n    #define ll long long\\n    #define rep(i,a,b)  for(ll i=a;i<=b;i++)\\n    \\n    \\npublic:\\n    \\n    vector<ll> bit;\\n\\nll query(ll i) {\\n\\tll res=0;\\n\\twhile(i>=0) {\\n\\t\\tres+=bit[i];\\n\\t\\ti= (i & (i+1)) -1;\\n\\t}\\n\\treturn res;\\n}\\n\\nvoid update(ll i, ll n, ll val) {\\n\\twhile(i<n) {\\n\\t\\tbit[i] += val;\\n\\t\\ti |=i+1;\\n\\t}\\n}\\n\\nll right_side_common(ll n, ll l1, ll l2, ll lcommon) {\\n\\tll r2 = n-(l2+1);\\n\\tll rcommon = max(0LL, r2 - (l1-lcommon));\\n\\treturn rcommon;\\n}\\n    long long goodTriplets(vector<int>& a, vector<int>& b) {\\n        ll i,n;\\n\\t\\tn = a.size();\\n\\t\\t\\n\\t\\tvector<ll> indexb(n,-1);\\n\\t\\trep(i,0,n-1) {\\n\\t\\t\\tindexb[b[i]] = i;\\n\\t\\t}\\n\\t\\tbit.resize(n,0);\\n\\t\\tupdate(indexb[a[0]], n, 1LL);\\n\\t\\tll ans =0;\\n\\t\\t// {x,y,z} iterate and fix y \\n\\t\\trep(i,1,n-2) {\\n\\t\\t\\tll common = indexb[a[i]]>0 ? query(indexb[a[i]]-1) : 0;\\n\\t\\t\\tll rcommon = right_side_common(n, i, indexb[a[i]], common);\\n\\t\\t\\tans +=common*rcommon;\\n\\t\\t\\tupdate(indexb[a[i]], n, 1LL);\\n\\t\\t}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803021,
                "title": "c-solution-use-bit-twice",
                "content": "```\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> pos(nums1.size());\\n        vector<long long> presum(nums2.size() + 1, 0);\\n        vector<long long> before;\\n        \\n        for(int i = 0; i < nums1.size(); i++) {\\n            pos[nums1[i]] = i;\\n        }\\n        \\n        for(int i : nums2) {\\n            int j = pos[i] + 1;\\n            long long sum = 0;\\n            while(j) {\\n                sum += presum[j];\\n                j -= j & -j;\\n            }\\n            before.push_back(sum);\\n            j = pos[i] + 1;\\n            while(j < presum.size()) {\\n                presum[j]++;\\n                j += j & -j;\\n            }\\n        }\\n\\n        long long res = 0;\\n        presum.assign(nums2.size() + 1, 0);\\n        for(int k = 0; k < nums2.size(); k++) {\\n            int i = nums2[k];\\n            int j = pos[i] + 1;\\n            long long sum = 0;\\n            while(j) {\\n                sum += presum[j];\\n                j -= j & -j;\\n            }\\n            res += sum;\\n            j = pos[i] + 1;\\n            while(j < presum.size()) {\\n                presum[j] += before[k];\\n                j += j & -j;\\n            }\\n        }\\n        \\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> pos(nums1.size());\\n        vector<long long> presum(nums2.size() + 1, 0);\\n        vector<long long> before;\\n        \\n        for(int i = 0; i < nums1.size(); i++) {\\n            pos[nums1[i]] = i;\\n        }\\n        \\n        for(int i : nums2) {\\n            int j = pos[i] + 1;\\n            long long sum = 0;\\n            while(j) {\\n                sum += presum[j];\\n                j -= j & -j;\\n            }\\n            before.push_back(sum);\\n            j = pos[i] + 1;\\n            while(j < presum.size()) {\\n                presum[j]++;\\n                j += j & -j;\\n            }\\n        }\\n\\n        long long res = 0;\\n        presum.assign(nums2.size() + 1, 0);\\n        for(int k = 0; k < nums2.size(); k++) {\\n            int i = nums2[k];\\n            int j = pos[i] + 1;\\n            long long sum = 0;\\n            while(j) {\\n                sum += presum[j];\\n                j -= j & -j;\\n            }\\n            res += sum;\\n            j = pos[i] + 1;\\n            while(j < presum.size()) {\\n                presum[j] += before[k];\\n                j += j & -j;\\n            }\\n        }\\n        \\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801922,
                "title": "c-tle-but-interesting-solution-graph",
                "content": "This is a TLE case\\n```\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long, unordered_set<long long>> graph1, graph2;\\n        long long n=nums1.size();\\n        long long count=0;\\n        for(long long i=0; i<n; i++)\\n            for(long long j=i+1; j<n; j++){\\n                graph1[nums1[i]].insert(nums1[j]);\\n                graph2[nums2[i]].insert(nums2[j]);\\n            }\\n        \\n        for(long long i=0; i<n; i++){\\n            for(auto mid: graph1[i])\\n                if(graph2[i].count(mid))\\n                    for(auto last: graph1[mid])\\n                        if(graph2[mid].count(last))\\n                            count++;          \\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long, unordered_set<long long>> graph1, graph2;\\n        long long n=nums1.size();\\n        long long count=0;\\n        for(long long i=0; i<n; i++)\\n            for(long long j=i+1; j<n; j++){\\n                graph1[nums1[i]].insert(nums1[j]);\\n                graph2[nums2[i]].insert(nums2[j]);\\n            }\\n        \\n        for(long long i=0; i<n; i++){\\n            for(auto mid: graph1[i])\\n                if(graph2[i].count(mid))\\n                    for(auto last: graph1[mid])\\n                        if(graph2[mid].count(last))\\n                            count++;          \\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1796977,
                "title": "why-tle-here-what-is-the-tc-for-this-solution",
                "content": "```\\nclass Solution {\\n    // Author: Anand\\n    // TC = O(2n)\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        Map<Integer, Integer> map = new HashMap<>();// To look-up elements in nums2\\n        int idx = 0;\\n        for (int e : nums2) map.put(e, idx++);\\n        Map<String, Long> dp = new HashMap<>();// To look-up elements in nums2\\n\\n        return recurse(nums1, 0, 3, true, map, new ArrayList<>(), dp);\\n    }\\n\\n    private long recurse(int[] nums1, int idx, int t, boolean valid, Map<Integer, Integer> map, List<Integer> choices, Map<String, Long> dp) {\\n        // base case\\n        if (t == 0) {\\n            if (valid) return 1;\\n            return 0;\\n        }\\n        \\n        if (idx >= nums1.length) return 0;\\n        \\n        if (!valid) return 0;\\n        String key = idx + \"-\" + t;\\n        if (dp.containsKey(key)) dp.get(key);\\n\\n        long take = 0, nt = 0;\\n        // t\\n        if (choices.size() == 0 || map.get(nums1[idx]) > choices.get(choices.size() - 1)) {\\n            choices.add(map.get(nums1[idx]));\\n            take += recurse(nums1, idx + 1, t - 1, valid, map, choices, dp);\\n            choices.remove(choices.size() - 1); // remove at last index in O(1)\\n        }\\n\\n        // nt\\n        nt += recurse(nums1, idx + 1, t, valid, map, choices, dp);\\n        long ans = take + nt;\\n        dp.put(key, ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Author: Anand\\n    // TC = O(2n)\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        Map<Integer, Integer> map = new HashMap<>();// To look-up elements in nums2\\n        int idx = 0;\\n        for (int e : nums2) map.put(e, idx++);\\n        Map<String, Long> dp = new HashMap<>();// To look-up elements in nums2\\n\\n        return recurse(nums1, 0, 3, true, map, new ArrayList<>(), dp);\\n    }\\n\\n    private long recurse(int[] nums1, int idx, int t, boolean valid, Map<Integer, Integer> map, List<Integer> choices, Map<String, Long> dp) {\\n        // base case\\n        if (t == 0) {\\n            if (valid) return 1;\\n            return 0;\\n        }\\n        \\n        if (idx >= nums1.length) return 0;\\n        \\n        if (!valid) return 0;\\n        String key = idx + \"-\" + t;\\n        if (dp.containsKey(key)) dp.get(key);\\n\\n        long take = 0, nt = 0;\\n        // t\\n        if (choices.size() == 0 || map.get(nums1[idx]) > choices.get(choices.size() - 1)) {\\n            choices.add(map.get(nums1[idx]));\\n            take += recurse(nums1, idx + 1, t - 1, valid, map, choices, dp);\\n            choices.remove(choices.size() - 1); // remove at last index in O(1)\\n        }\\n\\n        // nt\\n        nt += recurse(nums1, idx + 1, t, valid, map, choices, dp);\\n        long ans = take + nt;\\n        dp.put(key, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796599,
                "title": "c-segment-tree-solution",
                "content": "```\\nclass segtree {\\n\\tint size;\\n\\tvector<long long> sums;\\npublic:\\n\\tsegtree(int n) {\\n\\t\\tsize = 1;\\n\\t\\twhile(size < n)\\n\\t\\t\\tsize *= 2;\\n\\t\\tsums = vector<long long>(2 * size - 1);\\n\\t}\\n\\tvoid set(int i, int val, int x, int l, int r) {\\n\\t\\tif(l == r) {\\n\\t\\t\\tsums[x] = val;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint mid = (l + r) / 2;\\n\\t\\tif(i <= mid)\\n\\t\\t\\tset(i, val, 2 * x + 1, l, mid);\\n\\t\\telse\\n\\t\\t\\tset(i, val, 2 * x + 2, mid + 1, r);\\n\\t\\tsums[x] = sums[2 * x + 1] + sums[2 * x + 2];\\n\\t}\\n\\tvoid set(int i, int val) {\\n\\t\\tset(i, val, 0, 0, size -1);\\n\\t}\\n\\tlong long  range_sum(int lx, int rx, int x, int l, int r) {\\n\\t\\tif(l > rx || lx > r)\\n\\t\\t\\treturn 0;\\n\\t\\tif(l >= lx && r <= rx)\\n\\t\\t\\treturn sums[x];\\n\\t\\tint mid = (l + r) / 2;\\n\\t\\treturn range_sum(lx, rx, 2 * x + 1, l, mid) + range_sum(lx, rx, 2 * x + 2, mid + 1, r);\\n\\t}\\n\\tlong long  range_sum(int lx, int rx) {\\n\\t\\treturn range_sum(lx, rx, 0, 0, size - 1);\\n\\t}\\n};\\n\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> pos1(n);\\n        vector<int> pos2(n);\\n        for (int i = 0; i < n; i++) {\\n            pos1[nums1[i]] = i;\\n            pos2[nums2[i]] = i;\\n        }\\n        vector<pair<int, int>> put;\\n        for (int i = 0; i < n; i++) {\\n            put.emplace_back(pos1[i], pos2[i]);\\n        }\\n        sort(put.begin(), put.end());\\n        vector<int> less(n);\\n        segtree st(n);\\n        for (int i = 0; i < n; i++) {\\n            less[i] = st.range_sum(0, put[i].second);\\n            st.set(put[i].second, 1);\\n        }\\n        segtree st1(n);\\n        long long sol = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            int v = st1.range_sum(put[i].second, n - 1);\\n            st1.set(put[i].second, 1);\\n            sol += (long long) less[i] * v;\\n        }\\n        return sol;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass segtree {\\n\\tint size;\\n\\tvector<long long> sums;\\npublic:\\n\\tsegtree(int n) {\\n\\t\\tsize = 1;\\n\\t\\twhile(size < n)\\n\\t\\t\\tsize *= 2;\\n\\t\\tsums = vector<long long>(2 * size - 1);\\n\\t}\\n\\tvoid set(int i, int val, int x, int l, int r) {\\n\\t\\tif(l == r) {\\n\\t\\t\\tsums[x] = val;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint mid = (l + r) / 2;\\n\\t\\tif(i <= mid)\\n\\t\\t\\tset(i, val, 2 * x + 1, l, mid);\\n\\t\\telse\\n\\t\\t\\tset(i, val, 2 * x + 2, mid + 1, r);\\n\\t\\tsums[x] = sums[2 * x + 1] + sums[2 * x + 2];\\n\\t}\\n\\tvoid set(int i, int val) {\\n\\t\\tset(i, val, 0, 0, size -1);\\n\\t}\\n\\tlong long  range_sum(int lx, int rx, int x, int l, int r) {\\n\\t\\tif(l > rx || lx > r)\\n\\t\\t\\treturn 0;\\n\\t\\tif(l >= lx && r <= rx)\\n\\t\\t\\treturn sums[x];\\n\\t\\tint mid = (l + r) / 2;\\n\\t\\treturn range_sum(lx, rx, 2 * x + 1, l, mid) + range_sum(lx, rx, 2 * x + 2, mid + 1, r);\\n\\t}\\n\\tlong long  range_sum(int lx, int rx) {\\n\\t\\treturn range_sum(lx, rx, 0, 0, size - 1);\\n\\t}\\n};\\n\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> pos1(n);\\n        vector<int> pos2(n);\\n        for (int i = 0; i < n; i++) {\\n            pos1[nums1[i]] = i;\\n            pos2[nums2[i]] = i;\\n        }\\n        vector<pair<int, int>> put;\\n        for (int i = 0; i < n; i++) {\\n            put.emplace_back(pos1[i], pos2[i]);\\n        }\\n        sort(put.begin(), put.end());\\n        vector<int> less(n);\\n        segtree st(n);\\n        for (int i = 0; i < n; i++) {\\n            less[i] = st.range_sum(0, put[i].second);\\n            st.set(put[i].second, 1);\\n        }\\n        segtree st1(n);\\n        long long sol = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            int v = st1.range_sum(put[i].second, n - 1);\\n            st1.set(put[i].second, 1);\\n            sol += (long long) less[i] * v;\\n        }\\n        return sol;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790586,
                "title": "sortedlist-vs-binary-indexed-tree-vs-segmented-tree",
                "content": "for each `nums2[i]`, \\n- find for `nums1.index(nums2[0]),..., nums1.index(nums2[i-1])`, how many are smaller than `nums1.index(nums2[i])`.\\n- find for `nums1.index(nums2[i+1]),..., nums1.index(nums2[n-1])`, how many are bigger than `nums1.index(nums2[i])`.\\n\\nuse a data structure that supports O(logn) element add, O(logn) range query to achieve O(nlogn) total run time. this can be\\n- balanced BST (e.g red-black tree, or `sortedcontainers.SortedList`?)\\n- segmented tree\\n- binary indexed tree\\n\\n1. SortedList\\n```python\\n   def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        from sortedcontainers import SortedList\\n        \\n        n = len(nums1)\\n        I1 = {v: i for i, v in enumerate(nums1)}\\n        \\n        L = [0] * n\\n        sl = SortedList()\\n        for i in range(n):\\n            j = sl.bisect_left(I1[nums2[i]])\\n            L[i] = j\\n            sl.add(I1[nums2[i]])\\n            \\n        R = [0] * n\\n        sl = SortedList()\\n        for i in range(n-1, -1, -1):\\n            j = sl.bisect_left(I1[nums2[i]])\\n            R[i] = n - 1 - i - j\\n            sl.add(I1[nums2[i]])\\n        \\n        return sum([l*r for l, r in zip(L, R)])\\n```\\n\\n2. Segmented Tree\\n```python\\n        def add(i):\\n            i += n\\n            while i:\\n                seg[i] += 1\\n                i >>= 1\\n\\n        def sumRange(l, r):\\n            l += n\\n            r += n\\n            res = 0\\n            while l <= r:\\n                if l & 1:\\n                    res += seg[l]\\n                    l += 1\\n                l >>= 1\\n                if not (r & 1):\\n                    res += seg[r]\\n                    r -= 1\\n                r >>= 1\\n            return res\\n        \\n        n = len(nums1)\\n        I1 = {v: i for i, v in enumerate(nums1)}\\n        \\n        seg = [0] * (2*n)\\n        L = [0] * n\\n        for i in range(n):\\n            L[i] = sumRange(0, I1[nums2[i]])\\n            add(I1[nums2[i]])\\n            \\n        seg = [0] * (2*n)\\n        R = [0] * n\\n        for i in range(n-1, -1, -1):\\n            R[i] = sumRange(I1[nums2[i]], n-1)\\n            add(I1[nums2[i]])\\n        \\n        return sum([l*r for l, r in zip(L, R)])\\n```\\n\\n3. Binary indexed tree\\n```python\\n        def add(i):  # i = 1,2,...,n\\n            while i <= n:\\n                bit[i] += 1\\n                i += i & -i\\n        \\n        def doSum(i):\\n            s = 0\\n            while i:\\n                s += bit[i]\\n                i -= i & -i\\n            return s\\n        \\n        n = len(nums1)\\n        I1 = {v: i+1 for i, v in enumerate(nums1)}\\n        \\n        bit = [0] * (n+1)\\n        L = [0] * n\\n        for i in range(n):\\n            L[i] = doSum(I1[nums2[i]])\\n            add(I1[nums2[i]])\\n            \\n        bit = [0] * (n+1)\\n        R = [0] * n\\n        for i in range(n-1, -1, -1):\\n            R[i] = doSum(n) - doSum(I1[nums2[i]])\\n            add(I1[nums2[i]])\\n        \\n        return sum([l*r for l, r in zip(L, R)])\\n```",
                "solutionTags": [],
                "code": "```python\\n   def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        from sortedcontainers import SortedList\\n        \\n        n = len(nums1)\\n        I1 = {v: i for i, v in enumerate(nums1)}\\n        \\n        L = [0] * n\\n        sl = SortedList()\\n        for i in range(n):\\n            j = sl.bisect_left(I1[nums2[i]])\\n            L[i] = j\\n            sl.add(I1[nums2[i]])\\n            \\n        R = [0] * n\\n        sl = SortedList()\\n        for i in range(n-1, -1, -1):\\n            j = sl.bisect_left(I1[nums2[i]])\\n            R[i] = n - 1 - i - j\\n            sl.add(I1[nums2[i]])\\n        \\n        return sum([l*r for l, r in zip(L, R)])\\n```\n```python\\n        def add(i):\\n            i += n\\n            while i:\\n                seg[i] += 1\\n                i >>= 1\\n\\n        def sumRange(l, r):\\n            l += n\\n            r += n\\n            res = 0\\n            while l <= r:\\n                if l & 1:\\n                    res += seg[l]\\n                    l += 1\\n                l >>= 1\\n                if not (r & 1):\\n                    res += seg[r]\\n                    r -= 1\\n                r >>= 1\\n            return res\\n        \\n        n = len(nums1)\\n        I1 = {v: i for i, v in enumerate(nums1)}\\n        \\n        seg = [0] * (2*n)\\n        L = [0] * n\\n        for i in range(n):\\n            L[i] = sumRange(0, I1[nums2[i]])\\n            add(I1[nums2[i]])\\n            \\n        seg = [0] * (2*n)\\n        R = [0] * n\\n        for i in range(n-1, -1, -1):\\n            R[i] = sumRange(I1[nums2[i]], n-1)\\n            add(I1[nums2[i]])\\n        \\n        return sum([l*r for l, r in zip(L, R)])\\n```\n```python\\n        def add(i):  # i = 1,2,...,n\\n            while i <= n:\\n                bit[i] += 1\\n                i += i & -i\\n        \\n        def doSum(i):\\n            s = 0\\n            while i:\\n                s += bit[i]\\n                i -= i & -i\\n            return s\\n        \\n        n = len(nums1)\\n        I1 = {v: i+1 for i, v in enumerate(nums1)}\\n        \\n        bit = [0] * (n+1)\\n        L = [0] * n\\n        for i in range(n):\\n            L[i] = doSum(I1[nums2[i]])\\n            add(I1[nums2[i]])\\n            \\n        bit = [0] * (n+1)\\n        R = [0] * n\\n        for i in range(n-1, -1, -1):\\n            R[i] = doSum(n) - doSum(I1[nums2[i]])\\n            add(I1[nums2[i]])\\n        \\n        return sum([l*r for l, r in zip(L, R)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1789647,
                "title": "c-very-strange-fact-2-solutions",
                "content": "Runtime: 1432 ms, faster than 17.57% of C++ online submissions for Count Good Triplets in an Array.\\nMemory Usage: 117 MB, less than 42.12% of C++ online submissions for Count Good Triplets in an Array.\\n```\\nclass Treap{\\n  static minstd_rand generator;\\n\\n  struct Node{\\n    int priority;\\n    int value, size = 1, add;\\n    Node *l, *r;\\n    Node(int value): add(0), value(value), priority(generator()), l(nullptr), r(nullptr){}\\n  }*root = nullptr;\\n\\n  static int getSize(Node *n){\\n    return n ? n->size : 0;\\n  }\\n\\n  static void push(Node *n){\\n    if(n){\\n      if(n->add){            //if we need add\\n        n->value += n->add;\\n\\n        if(n->l) n->l->add += n->add;\\n        if(n->r) n->r->add += n->add;\\n\\n        n->add = 0;\\n      }\\n    }\\n  }\\n\\n  static void update(Node *n){\\n    if(n){\\n      n->size = getSize(n->l) + 1 + getSize(n->r);\\n    }\\n  }\\n\\n  static Node* merge(Node *a, Node *b){\\n    push(a);\\n    push(b);\\n\\n    if(!a || !b) return a ? a : b;\\n\\n    if(a->priority > b->priority){\\n      a->r = merge(a->r, b);\\n      update(a);\\n      return a;\\n    }\\n    else{\\n      b->l = merge(a, b->l);\\n      update(b);\\n      return b;\\n    }\\n  }\\n\\n    static void split(Node *n, int k, Node *&a, Node*&b){\\n      push(n);\\n\\n      if(!n){a = b = nullptr; return;}\\n\\n      if(getSize(n->l) < k){\\n        split(n->r, k - getSize(n->l) - 1, n->r, b);\\n        a = n;\\n      }\\n      else{\\n        split(n->l, k, a, n->l);\\n        b = n;\\n      }\\n      update(a);\\n      update(b);\\n    }\\n\\npublic:\\n  int getValue(int index){\\n    Node *less, *equal, *greater;\\n    split(root, index, less, greater);\\n    split(greater, 1, equal, greater);\\n    int result = equal->value;\\n    root = merge(merge(less, equal), greater);\\n    return result;\\n  }\\n\\n  void pushBack(int value){\\n    root = merge(root, new Node(value));\\n  }\\n\\n  void addInRange(int indexL, int indexR, int val){\\n    Node *less, *equal, *greater;\\n    split(root, indexL, less, greater);\\n    split(greater,indexR - indexL + 1, equal, greater);\\n\\n    equal->add += val;\\n\\n    root = merge(merge(less, equal), greater);\\n  }\\n  \\n  void for_start(int n){      \\n  for (int i = 0; i != n; i++)\\n    root = merge(root, new Node(0));\\n  }\\n};\\n\\nminstd_rand Treap::generator;\\n\\nclass Solution {\\npublic:\\n  long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n    int n = nums2.size();\\n    vector<int> w(n);\\n    for(int i = 0; i != n; i++) w[nums1[i]] = i;\\n    \\n    vector<int> v(n);\\n    for(int i = 0; i != n; i++) v[i] = w[nums2[i]];\\n    \\n    Treap t;\\n    t.for_start(n);\\n    \\n    for(int i = 0; i != n; i++){\\n      if(v[i]) w[i] = t.getValue(v[i] - 1);\\n      else w[i] = 0;\\n      t.addInRange(v[i], n-1, 1);\\n    }\\n    \\n    Treap k;\\n    k.for_start(n);\\n    long ans = 0;\\n    k.addInRange(0, v.back(), 1);\\n    \\n    for(int i = n-2; i; i--){\\n      if(v[i] != n-1) ans += long(w[i]) * k.getValue(v[i] + 1); \\n      k.addInRange(0, v[i], 1);\\n    }\\n \\n    return ans;\\n  }\\n};\\n```\\n\\n**Very strange that first solution with time ONlogN have TLE so many times (above) \\nbut second solution with time ONsqrtN always have \"good\" runtime (below). INTERESTING , WHY ???**\\n![image](https://assets.leetcode.com/users/images/9ec33e73-b8de-4583-a6fd-dfa245a08ddb_1645469091.3930845.png)\\n\\n\\n**time ON(sqrtN)**\\nRuntime: 728 ms, faster than 40.96% of C++ online submissions for Count Good Triplets in an Array.\\nMemory Usage: 83.4 MB, less than 91.47% of C++ online submissions for Count Good Triplets in an Array.\\n```\\nclass Helper {\\n  public:\\n  vector<int> v;\\n  vector<int> vsum;\\n  int LIMIT, ADD;\\n  \\n  Helper (int n){\\n    ADD = sqrt(n);\\n    LIMIT = ADD + 1;\\n    replace(n);\\n  }\\n  \\n  void replace(int n){\\n    v.clear(), vsum.clear(); \\n    int id = (n+ADD)/LIMIT;\\n    v.resize(id * LIMIT,0), vsum.resize(id,0);\\n  }\\n  \\n  void update_for_l(int idx){\\n    int id = (idx+ADD)/LIMIT;\\n    int lim = id * LIMIT;\\n    while(idx != lim) v[idx++]++;\\n    while(id != vsum.size()) vsum[id++]++;\\n  }\\n  \\n  void update_for_r(int idx){\\n    int id = idx / LIMIT;\\n    int lim = id * LIMIT;            \\n    while(idx >= lim) v[idx--]++;\\n    while(--id != -1) vsum[id]++;\\n  }\\n  \\n  int get(int idx){\\n    return vsum[idx/LIMIT] + v[idx];\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n   ios::sync_with_stdio(0);\\n    cin.tie(0);\\n    cout.tie(0);\\n    \\n    int n = nums2.size();\\n    vector<int> w(n);\\n    for(int i = 0; i != n; i++) w[nums1[i]] = i;\\n    \\n    vector<int> v(n);\\n    for(int i = 0; i != n; i++) v[i] = w[nums2[i]];  \\n    \\n    Helper h(n);\\n    for(int i = 0; i != n; i++){\\n      if(v[i]) w[i] = h.get(v[i] - 1);\\n      else w[i] = 0;\\n      h.update_for_l(v[i]);\\n    }\\n    \\n    long ans = 0;\\n    h.replace(n); \\n    \\n    h.update_for_r(v.back());\\n    \\n    for(int i = n-2; i; i--){\\n      if(v[i] != n-1) ans += long(w[i]) * h.get(v[i] + 1);\\n      h.update_for_r(v[i]);\\n    }\\n \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Treap{\\n  static minstd_rand generator;\\n\\n  struct Node{\\n    int priority;\\n    int value, size = 1, add;\\n    Node *l, *r;\\n    Node(int value): add(0), value(value), priority(generator()), l(nullptr), r(nullptr){}\\n  }*root = nullptr;\\n\\n  static int getSize(Node *n){\\n    return n ? n->size : 0;\\n  }\\n\\n  static void push(Node *n){\\n    if(n){\\n      if(n->add){            //if we need add\\n        n->value += n->add;\\n\\n        if(n->l) n->l->add += n->add;\\n        if(n->r) n->r->add += n->add;\\n\\n        n->add = 0;\\n      }\\n    }\\n  }\\n\\n  static void update(Node *n){\\n    if(n){\\n      n->size = getSize(n->l) + 1 + getSize(n->r);\\n    }\\n  }\\n\\n  static Node* merge(Node *a, Node *b){\\n    push(a);\\n    push(b);\\n\\n    if(!a || !b) return a ? a : b;\\n\\n    if(a->priority > b->priority){\\n      a->r = merge(a->r, b);\\n      update(a);\\n      return a;\\n    }\\n    else{\\n      b->l = merge(a, b->l);\\n      update(b);\\n      return b;\\n    }\\n  }\\n\\n    static void split(Node *n, int k, Node *&a, Node*&b){\\n      push(n);\\n\\n      if(!n){a = b = nullptr; return;}\\n\\n      if(getSize(n->l) < k){\\n        split(n->r, k - getSize(n->l) - 1, n->r, b);\\n        a = n;\\n      }\\n      else{\\n        split(n->l, k, a, n->l);\\n        b = n;\\n      }\\n      update(a);\\n      update(b);\\n    }\\n\\npublic:\\n  int getValue(int index){\\n    Node *less, *equal, *greater;\\n    split(root, index, less, greater);\\n    split(greater, 1, equal, greater);\\n    int result = equal->value;\\n    root = merge(merge(less, equal), greater);\\n    return result;\\n  }\\n\\n  void pushBack(int value){\\n    root = merge(root, new Node(value));\\n  }\\n\\n  void addInRange(int indexL, int indexR, int val){\\n    Node *less, *equal, *greater;\\n    split(root, indexL, less, greater);\\n    split(greater,indexR - indexL + 1, equal, greater);\\n\\n    equal->add += val;\\n\\n    root = merge(merge(less, equal), greater);\\n  }\\n  \\n  void for_start(int n){      \\n  for (int i = 0; i != n; i++)\\n    root = merge(root, new Node(0));\\n  }\\n};\\n\\nminstd_rand Treap::generator;\\n\\nclass Solution {\\npublic:\\n  long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n    int n = nums2.size();\\n    vector<int> w(n);\\n    for(int i = 0; i != n; i++) w[nums1[i]] = i;\\n    \\n    vector<int> v(n);\\n    for(int i = 0; i != n; i++) v[i] = w[nums2[i]];\\n    \\n    Treap t;\\n    t.for_start(n);\\n    \\n    for(int i = 0; i != n; i++){\\n      if(v[i]) w[i] = t.getValue(v[i] - 1);\\n      else w[i] = 0;\\n      t.addInRange(v[i], n-1, 1);\\n    }\\n    \\n    Treap k;\\n    k.for_start(n);\\n    long ans = 0;\\n    k.addInRange(0, v.back(), 1);\\n    \\n    for(int i = n-2; i; i--){\\n      if(v[i] != n-1) ans += long(w[i]) * k.getValue(v[i] + 1); \\n      k.addInRange(0, v[i], 1);\\n    }\\n \\n    return ans;\\n  }\\n};\\n```\n```\\nclass Helper {\\n  public:\\n  vector<int> v;\\n  vector<int> vsum;\\n  int LIMIT, ADD;\\n  \\n  Helper (int n){\\n    ADD = sqrt(n);\\n    LIMIT = ADD + 1;\\n    replace(n);\\n  }\\n  \\n  void replace(int n){\\n    v.clear(), vsum.clear(); \\n    int id = (n+ADD)/LIMIT;\\n    v.resize(id * LIMIT,0), vsum.resize(id,0);\\n  }\\n  \\n  void update_for_l(int idx){\\n    int id = (idx+ADD)/LIMIT;\\n    int lim = id * LIMIT;\\n    while(idx != lim) v[idx++]++;\\n    while(id != vsum.size()) vsum[id++]++;\\n  }\\n  \\n  void update_for_r(int idx){\\n    int id = idx / LIMIT;\\n    int lim = id * LIMIT;            \\n    while(idx >= lim) v[idx--]++;\\n    while(--id != -1) vsum[id]++;\\n  }\\n  \\n  int get(int idx){\\n    return vsum[idx/LIMIT] + v[idx];\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n   ios::sync_with_stdio(0);\\n    cin.tie(0);\\n    cout.tie(0);\\n    \\n    int n = nums2.size();\\n    vector<int> w(n);\\n    for(int i = 0; i != n; i++) w[nums1[i]] = i;\\n    \\n    vector<int> v(n);\\n    for(int i = 0; i != n; i++) v[i] = w[nums2[i]];  \\n    \\n    Helper h(n);\\n    for(int i = 0; i != n; i++){\\n      if(v[i]) w[i] = h.get(v[i] - 1);\\n      else w[i] = 0;\\n      h.update_for_l(v[i]);\\n    }\\n    \\n    long ans = 0;\\n    h.replace(n); \\n    \\n    h.update_for_r(v.back());\\n    \\n    for(int i = n-2; i; i--){\\n      if(v[i] != n-1) ans += long(w[i]) * h.get(v[i] + 1);\\n      h.update_for_r(v[i]);\\n    }\\n \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1789529,
                "title": "c-bit-explained-soln",
                "content": "/*\\n        Note each element in array only belonges to [0.....n-1]\\n        or arr[i]>=0 && arr[i]<=n-1\\n         replace nums[i] by its index in nums[j] ,\\n        than x1,x2,x3  (x1<x2<x3)\\n         for each x2 , if no of x1 = smaller and no of x2=greater than \\n         ans(for x2)=smaller*greater\\n         we find smaller =(no of smaller element to left of x2) using BIT\\n          Than greater= no of greater element to right of x2=\\n         Total - (all left elements, including x2 itself) - (number of elements on left that is actually bigger than x2)\\n         = n-\\n          smaller on left+ greater on left +1 + smaller on right + greater on right=n\\n          greater on right=n-smaller on left-greater on left-smaller on right-1\\n                         = n-(smaller in left + greater in left)-smaller on right-1\\n                         = n-(total element in left)-(total smaller - smaller in right)-1\\n                         = n-(x2)-(i-smaller)-1\\n         nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]\\n          v1 = [2,1,3,4,0] \\n          v2 = [0,2,1,4,3] \\n          \\n */\\n\\n```\\n#define lln long long int\\nint n;\\nclass Solution {\\npublic:\\n    vector<int>BIT;\\n\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        n=nums1.size();\\n        \\n        BIT.resize(n+1,0);\\n        \\n        int i=0;\\n        \\n        vector<int>v1(n);\\n        \\n        for(int i=0;i<n;i++){\\n            v1[nums2[i]]=i;\\n        }\\n        \\n        vector<int>v2(n);\\n        \\n        for(int i=0;i<n;i++){\\n            int idx=v1[nums1[i]];\\n            v2[i]=idx;\\n        }\\n        \\n        lln ans=0;\\n        \\n        for(int i=0;i<n;i++){\\n            lln smaller=query((v2[i]+1)-1);\\n            lln greater=(n-v2[i]-(i-smaller)-1);\\n            ans+=(lln)(smaller*greater);\\n            \\n            update(v2[i]+1,1);\\n        }\\n        \\n        return ans;\\n      }\\n \\n int query(int x) {\\n// prefix sum from [1.....x]\\n\\n     int sum = 0;\\n     for(; x > 0; x -= x&-x)\\n        sum += BIT[x];\\n\\n     return sum;\\n  }\\n    \\n    \\nvoid update(int x, int delta) {  \\n// x=index(1 based indexing , delta = value at index x)\\n\\n      for(; x <= n; x += x&-x)\\n        BIT[x] += delta;\\n  }\\n \\n };",
                "solutionTags": [
                    "Binary Indexed Tree"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int>BIT;\\n\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        n=nums1.size();\\n        \\n        BIT.resize(n+1,0);\\n        \\n        int i=0;\\n        \\n        vector<int>v1(n);\\n        \\n        for(int i=0;i<n;i++){\\n            v1[nums2[i]]=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1788241,
                "title": "c-o-n-log-n-bit-tree-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    inline int lastOne(int x) {\\n        return x & (-x);\\n    }\\n    \\n    void update(vector<int>& a, int i, int delta) {\\n        for(;i<a.size();i+=lastOne(i)) {\\n            a[i] += delta; \\n        }\\n    }\\n    \\n    int req(vector<int>& a, int i) {\\n        int ret = 0; \\n        for(;i;i-=lastOne(i)) {\\n            ret += a[i];\\n        }\\n        return ret; \\n    }\\n    \\n    int rsq(vector<int>& a, int l, int r) {\\n        return req(a,r) - (l == 1?0:req(a,l-1));\\n    }\\n    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        const int n = nums1.size(); \\n        vector<int> m(n);\\n        for(int i=0;i<n;i++) {\\n            m[nums1[i]] = i;\\n        }\\n        long long ret = 0; \\n        vector<int> a(n+5);\\n        vector<int> r(n);\\n        for(int i = n-1;i>=0;i--) {\\n            int j = m[nums2[i]];\\n            r[nums2[i]] = rsq(a,j+1,n+1);\\n            update(a,j+1,1);\\n        }\\n        a.assign(n+5,0);\\n        for(int i = 0;i<n;i++) {\\n            int j = m[nums2[i]];\\n            long long t = req(a,j);\\n            ret += t * r[nums2[i]];\\n            update(a,j+1,1);\\n        }\\n        return ret; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    inline int lastOne(int x) {\\n        return x & (-x);\\n    }\\n    \\n    void update(vector<int>& a, int i, int delta) {\\n        for(;i<a.size();i+=lastOne(i)) {\\n            a[i] += delta; \\n        }\\n    }\\n    \\n    int req(vector<int>& a, int i) {\\n        int ret = 0; \\n        for(;i;i-=lastOne(i)) {\\n            ret += a[i];\\n        }\\n        return ret; \\n    }\\n    \\n    int rsq(vector<int>& a, int l, int r) {\\n        return req(a,r) - (l == 1?0:req(a,l-1));\\n    }\\n    \\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        const int n = nums1.size(); \\n        vector<int> m(n);\\n        for(int i=0;i<n;i++) {\\n            m[nums1[i]] = i;\\n        }\\n        long long ret = 0; \\n        vector<int> a(n+5);\\n        vector<int> r(n);\\n        for(int i = n-1;i>=0;i--) {\\n            int j = m[nums2[i]];\\n            r[nums2[i]] = rsq(a,j+1,n+1);\\n            update(a,j+1,1);\\n        }\\n        a.assign(n+5,0);\\n        for(int i = 0;i<n;i++) {\\n            int j = m[nums2[i]];\\n            long long t = req(a,j);\\n            ret += t * r[nums2[i]];\\n            update(a,j+1,1);\\n        }\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787992,
                "title": "java-divide-and-conquer-tc-n-log-n",
                "content": "**Solution:**\\n```\\nclass Solution {\\n    int[] nums1, nums2, indicies1;\\n    int[] left, right;\\n    \\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int len = nums1.length;\\n        this.nums1 = nums1;\\n        this.nums2 = nums2;\\n        \\n        indicies1 = new int[len];\\n        for (int i = 0; i < len; ++ i) {\\n            indicies1[nums1[i]] = i;\\n        }\\n        \\n        left = new int[len];\\n        right = new int[len];\\n        divideAndConquer(0, len - 1);\\n        \\n        long output = 0L;\\n        for (int i = 0; i < len; ++ i) {\\n            output += (long)left[i] * (long)right[i];\\n        }\\n        \\n        return output;\\n    }\\n    \\n    public void divideAndConquer(int l, int r) {\\n        if (l == r) {\\n            return;\\n        }\\n        \\n        // Divide\\n        int mid = l + (r - l) / 2;\\n        divideAndConquer(l, mid);\\n        divideAndConquer(mid + 1, r);\\n        \\n        // Conquer\\n        int i = 0, j = 0, k = 0;\\n        int[] temp1 = new int[mid - l + 1];\\n        int[] temp2 = new int[r - mid];\\n        \\n        System.arraycopy(nums2, l, temp1, 0, mid - l + 1);\\n        System.arraycopy(nums2, mid + 1, temp2, 0, r - mid);\\n        \\n        int[] temp = new int[r - l + 1];\\n        \\n        // populating left\\n        while (i < temp1.length && j < temp2.length) {\\n            if (indicies1[temp1[i]] < indicies1[temp2[j]]) {\\n                temp[k] = temp1[i];\\n                ++ i;\\n            } else {\\n                temp[k] = temp2[j];\\n                left[temp2[j]] += i;\\n                ++ j;\\n            }\\n            ++ k;\\n        }\\n        \\n        while (i < temp1.length) {\\n            temp[k] = temp1[i];\\n            ++ i;\\n            ++ k;\\n        }\\n        \\n        while (j < temp2.length) {\\n            temp[k] = temp2[j];\\n            left[temp2[j]] += i;\\n            ++ j;\\n            ++ k;\\n        }\\n        \\n        System.arraycopy(temp, 0, nums2, l, r - l + 1);\\n        \\n        // Populating right\\n        i = temp1.length - 1;\\n        j = temp2.length - 1;\\n        k = temp.length - 1;\\n        while (i >= 0 && j >= 0) {\\n            if (indicies1[temp1[i]] > indicies1[temp2[j]]) {\\n                right[temp1[i]] += temp2.length - j - 1;\\n                -- i;\\n            } else {\\n                -- j;\\n            }\\n        }\\n        \\n        while (i >= 0) {\\n            right[temp1[i]] += temp2.length - j - 1;\\n            -- i;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    int[] nums1, nums2, indicies1;\\n    int[] left, right;\\n    \\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        int len = nums1.length;\\n        this.nums1 = nums1;\\n        this.nums2 = nums2;\\n        \\n        indicies1 = new int[len];\\n        for (int i = 0; i < len; ++ i) {\\n            indicies1[nums1[i]] = i;\\n        }\\n        \\n        left = new int[len];\\n        right = new int[len];\\n        divideAndConquer(0, len - 1);\\n        \\n        long output = 0L;\\n        for (int i = 0; i < len; ++ i) {\\n            output += (long)left[i] * (long)right[i];\\n        }\\n        \\n        return output;\\n    }\\n    \\n    public void divideAndConquer(int l, int r) {\\n        if (l == r) {\\n            return;\\n        }\\n        \\n        // Divide\\n        int mid = l + (r - l) / 2;\\n        divideAndConquer(l, mid);\\n        divideAndConquer(mid + 1, r);\\n        \\n        // Conquer\\n        int i = 0, j = 0, k = 0;\\n        int[] temp1 = new int[mid - l + 1];\\n        int[] temp2 = new int[r - mid];\\n        \\n        System.arraycopy(nums2, l, temp1, 0, mid - l + 1);\\n        System.arraycopy(nums2, mid + 1, temp2, 0, r - mid);\\n        \\n        int[] temp = new int[r - l + 1];\\n        \\n        // populating left\\n        while (i < temp1.length && j < temp2.length) {\\n            if (indicies1[temp1[i]] < indicies1[temp2[j]]) {\\n                temp[k] = temp1[i];\\n                ++ i;\\n            } else {\\n                temp[k] = temp2[j];\\n                left[temp2[j]] += i;\\n                ++ j;\\n            }\\n            ++ k;\\n        }\\n        \\n        while (i < temp1.length) {\\n            temp[k] = temp1[i];\\n            ++ i;\\n            ++ k;\\n        }\\n        \\n        while (j < temp2.length) {\\n            temp[k] = temp2[j];\\n            left[temp2[j]] += i;\\n            ++ j;\\n            ++ k;\\n        }\\n        \\n        System.arraycopy(temp, 0, nums2, l, r - l + 1);\\n        \\n        // Populating right\\n        i = temp1.length - 1;\\n        j = temp2.length - 1;\\n        k = temp.length - 1;\\n        while (i >= 0 && j >= 0) {\\n            if (indicies1[temp1[i]] > indicies1[temp2[j]]) {\\n                right[temp1[i]] += temp2.length - j - 1;\\n                -- i;\\n            } else {\\n                -- j;\\n            }\\n        }\\n        \\n        while (i >= 0) {\\n            right[temp1[i]] += temp2.length - j - 1;\\n            -- i;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787369,
                "title": "python-3-o-nlogn-time",
                "content": "Explanation is in code comments.\\n```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        pos2 = [0] * len(nums2)\\n        for i, n in enumerate(nums2):\\n            pos2[n] = i\\n        \\n        # Binary seach to find the insert pos in an increasing array\\n        def findLeft(posList, target):\\n            l, r = 0, len(posList) - 1\\n            while l <= r:\\n                mid = (l + r) // 2\\n                if posList[mid] > target:\\n                    r = mid - 1\\n                elif posList[mid] < target:\\n                    l = mid + 1\\n            return l\\n        \\n        # Take nums1[i] as the middle element\\n        # there are left[i] valid elements to be the first one\\n        # Time complexity O(NlogN)\\n        left = [0] * len(nums1)\\n        curPosList = []\\n        for i in range(len(nums1)):\\n            pos = pos2[nums1[i]]\\n            left[i] = findLeft(curPosList, pos)\\n            curPosList.insert(left[i], pos)\\n            \\n        # Take nums1[i] as the middle element\\n        # there are right[i] valid elements to be the last one\\n        # Time complexity O(NlogN)\\n        right = [0] * len(nums1)\\n        curPosList = []\\n        for i in range(len(nums1)-1, -1, -1):\\n            pos = pos2[nums1[i]]\\n            insertPos = findLeft(curPosList, pos)\\n            right[i] = len(curPosList) - insertPos\\n            curPosList.insert(insertPos, pos)\\n        \\n        # Compute the result\\n        # Time complexity O(N)\\n        ret = 0\\n        for i in range(len(nums1)):\\n            ret += left[i] * right[i]\\n        return ret\\n            \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        pos2 = [0] * len(nums2)\\n        for i, n in enumerate(nums2):\\n            pos2[n] = i\\n        \\n        # Binary seach to find the insert pos in an increasing array\\n        def findLeft(posList, target):\\n            l, r = 0, len(posList) - 1\\n            while l <= r:\\n                mid = (l + r) // 2\\n                if posList[mid] > target:\\n                    r = mid - 1\\n                elif posList[mid] < target:\\n                    l = mid + 1\\n            return l\\n        \\n        # Take nums1[i] as the middle element\\n        # there are left[i] valid elements to be the first one\\n        # Time complexity O(NlogN)\\n        left = [0] * len(nums1)\\n        curPosList = []\\n        for i in range(len(nums1)):\\n            pos = pos2[nums1[i]]\\n            left[i] = findLeft(curPosList, pos)\\n            curPosList.insert(left[i], pos)\\n            \\n        # Take nums1[i] as the middle element\\n        # there are right[i] valid elements to be the last one\\n        # Time complexity O(NlogN)\\n        right = [0] * len(nums1)\\n        curPosList = []\\n        for i in range(len(nums1)-1, -1, -1):\\n            pos = pos2[nums1[i]]\\n            insertPos = findLeft(curPosList, pos)\\n            right[i] = len(curPosList) - insertPos\\n            curPosList.insert(insertPos, pos)\\n        \\n        # Compute the result\\n        # Time complexity O(N)\\n        ret = 0\\n        for i in range(len(nums1)):\\n            ret += left[i] * right[i]\\n        return ret\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786513,
                "title": "python-no-hack-two-fenwick-trees-easy-solution",
                "content": "```py\\nclass FenwickTree:\\n  def __init__(self, n: int):\\n    self.sums = [0] * (n + 1)\\n\\n  def update(self, i: int, delta: int) -> None:\\n    while i < len(self.sums):\\n      self.sums[i] += delta\\n      i += self._lowbit(i)\\n\\n  def get(self, i: int) -> int:\\n    sum = 0\\n    while i > 0:\\n      sum += self.sums[i]\\n      i -= self._lowbit(i)\\n    return sum\\n\\n  def _lowbit(self, i) -> int:\\n    return i & -i\\n\\n\\nclass Solution:\\n  def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n    n = len(nums1)\\n    numToIndex = {num: i for i, num in enumerate(nums1)}\\n    # Remap each num in nums2 to the according index in nums1 as A\\n    # Then, rephrase the problem as finding increasing tripets in A\\n    A = [numToIndex[num] for num in nums2]\\n    # leftSmaller[i] := # of A[j] < A[i], where 0 <= j < i\\n    leftSmaller = [0] * n\\n    # rightLarger[i] := # of A[j] > A[i], where i < j < n\\n    rightLarger = [0] * n\\n    tree1 = FenwickTree(n)  # to calculate leftSmaller\\n    tree2 = FenwickTree(n)  # to calculate rightLarger\\n\\n    for i, a in enumerate(A):\\n      leftSmaller[i] = tree1.get(a)\\n      tree1.update(a + 1, 1)\\n\\n    for i, a in reversed(list(enumerate(A))):\\n      rightLarger[i] = tree2.get(n) - tree2.get(a)\\n      tree2.update(a + 1, 1)\\n\\n    return sum(a * b for a, b in zip(leftSmaller, rightLarger))\\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Binary Indexed Tree"
                ],
                "code": "```py\\nclass FenwickTree:\\n  def __init__(self, n: int):\\n    self.sums = [0] * (n + 1)\\n\\n  def update(self, i: int, delta: int) -> None:\\n    while i < len(self.sums):\\n      self.sums[i] += delta\\n      i += self._lowbit(i)\\n\\n  def get(self, i: int) -> int:\\n    sum = 0\\n    while i > 0:\\n      sum += self.sums[i]\\n      i -= self._lowbit(i)\\n    return sum\\n\\n  def _lowbit(self, i) -> int:\\n    return i & -i\\n\\n\\nclass Solution:\\n  def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n    n = len(nums1)\\n    numToIndex = {num: i for i, num in enumerate(nums1)}\\n    # Remap each num in nums2 to the according index in nums1 as A\\n    # Then, rephrase the problem as finding increasing tripets in A\\n    A = [numToIndex[num] for num in nums2]\\n    # leftSmaller[i] := # of A[j] < A[i], where 0 <= j < i\\n    leftSmaller = [0] * n\\n    # rightLarger[i] := # of A[j] > A[i], where i < j < n\\n    rightLarger = [0] * n\\n    tree1 = FenwickTree(n)  # to calculate leftSmaller\\n    tree2 = FenwickTree(n)  # to calculate rightLarger\\n\\n    for i, a in enumerate(A):\\n      leftSmaller[i] = tree1.get(a)\\n      tree1.update(a + 1, 1)\\n\\n    for i, a in reversed(list(enumerate(A))):\\n      rightLarger[i] = tree2.get(n) - tree2.get(a)\\n      tree2.update(a + 1, 1)\\n\\n    return sum(a * b for a, b in zip(leftSmaller, rightLarger))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783970,
                "title": "simple-merge-sort-based-solution",
                "content": "class Solution {\\n    Pair<Integer , Integer>[] temp;\\n    void sort(Pair<Integer ,Integer>[] Arr , int[] arr , int[] brr , int low , int high){\\n        if(low>=high){\\n            return;\\n        }\\n        int mid = (low+high)/2;\\n        sort(Arr , arr , brr , low , mid);\\n        sort(Arr , arr , brr , mid+1 , high);\\n        \\n        int i = low;\\n        int j = mid+1;\\n        int k = low;\\n        while(i<=mid || j<=high){\\n            int left = (i==mid+1)?Integer.MAX_VALUE:Arr[i].getKey();\\n            int right = (j==high+1)?Integer.MAX_VALUE:Arr[j].getKey();\\n            if(left<right){\\n                temp[k++] = Arr[i];\\n                arr[Arr[i].getValue()] += (high-j+1);i++;\\n            }\\n            else{\\n                temp[k++] = Arr[j];\\n                brr[Arr[j].getValue()] += (i-low);j++;\\n            }\\n        }\\n        for(int p = low;p<=high;p++){\\n            Arr[p] = temp[p];\\n        }\\n    }\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        HashMap<Integer , Integer> map = new HashMap<>();\\n        for(int i=0;i<nums1.length;i++){\\n            map.put(nums1[i] , i);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            nums2[i] = map.get(nums2[i]);\\n        }\\n        int n = nums1.length;\\n        temp = new Pair[n];\\n        int[] arr = new int[n];\\n        int[] brr = new int[n];\\n        Pair<Integer , Integer>[] Arr = new Pair[n];\\n        for(int i= 0;i<n;i++){\\n            Arr[i] = new Pair(nums2[i] , i);\\n        }\\n        sort(Arr , arr , brr , 0 , n-1);        \\n        long res = 0L;\\n        for(int i=0;i<n;i++){\\n            res += (long)((long)arr[i]*(long)brr[i]);\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "class Solution {\\n    Pair<Integer , Integer>[] temp;\\n    void sort(Pair<Integer ,Integer>[] Arr , int[] arr , int[] brr , int low , int high){\\n        if(low>=high){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1783917,
                "title": "python-1-fenwick-tree-solution-explained",
                "content": "```\\nclass Fenwick:\\n    def __init__(self, N):\\n        self.fw = [0] * (N + 1)\\n        self.N = N + 1\\n    \\n    def update(self, i, delta):\\n        i += 1\\n        while i < self.N:\\n            self.fw[i] += delta\\n            i += i & -i\\n            \\n    def query(self, i):\\n        i += 1\\n        res = 0\\n        while i > 0:\\n            res += self.fw[i]\\n            i -= i & -i\\n        return res\\n    \\n\\nclass Solution(object):\\n    def goodTriplets(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        N = len(nums1)\\n        fw = Fenwick(N)\\n        pos = dict()\\n        for i, v in enumerate(nums2):\\n            pos[v] = i\\n        res = 0\\n        for i, v in enumerate(nums1):\\n            small = fw.query(pos[v])  # how many elements are smaller than pos[v]\\n            large = N - 1 - pos[v] - i + small # How many elements are larger than pos[v]\\n            res += small * large\\n            fw.update(pos[v], 1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Fenwick:\\n    def __init__(self, N):\\n        self.fw = [0] * (N + 1)\\n        self.N = N + 1\\n    \\n    def update(self, i, delta):\\n        i += 1\\n        while i < self.N:\\n            self.fw[i] += delta\\n            i += i & -i\\n            \\n    def query(self, i):\\n        i += 1\\n        res = 0\\n        while i > 0:\\n            res += self.fw[i]\\n            i -= i & -i\\n        return res\\n    \\n\\nclass Solution(object):\\n    def goodTriplets(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        N = len(nums1)\\n        fw = Fenwick(N)\\n        pos = dict()\\n        for i, v in enumerate(nums2):\\n            pos[v] = i\\n        res = 0\\n        for i, v in enumerate(nums1):\\n            small = fw.query(pos[v])  # how many elements are smaller than pos[v]\\n            large = N - 1 - pos[v] - i + small # How many elements are larger than pos[v]\\n            res += small * large\\n            fw.update(pos[v], 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783881,
                "title": "python-100-time-100-space-easy-solution",
                "content": "This solution uses sortesList. Idea is to iterate on the middle element and find the number of common elements on left side and right side of both the arrays. \\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        a = [0]*len(nums2)\\n        n=len(nums2)\\n        for i in range(n):\\n            a[nums2[i]]=i\\n        s = SortedList()\\n        b = [0]*(len(nums1))\\n        for i in range(len(nums1)):\\n            number = nums1[i]\\n            indInNums2 = a[number]\\n            b[i] = s.bisect_left(indInNums2+1)\\n            s.add(indInNums2)\\n        ans = 0\\n        s = SortedList()\\n        for i in range(n-1,-1,-1):\\n            number = nums1[i]\\n            indInNums2 = a[number]\\n            x = len(s)-s.bisect_left(indInNums2+1)\\n            ans += b[i]*x\\n            s.add(indInNums2)\\n        return ans     \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        a = [0]*len(nums2)\\n        n=len(nums2)\\n        for i in range(n):\\n            a[nums2[i]]=i\\n        s = SortedList()\\n        b = [0]*(len(nums1))\\n        for i in range(len(nums1)):\\n            number = nums1[i]\\n            indInNums2 = a[number]\\n            b[i] = s.bisect_left(indInNums2+1)\\n            s.add(indInNums2)\\n        ans = 0\\n        s = SortedList()\\n        for i in range(n-1,-1,-1):\\n            number = nums1[i]\\n            indInNums2 = a[number]\\n            x = len(s)-s.bisect_left(indInNums2+1)\\n            ans += b[i]*x\\n            s.add(indInNums2)\\n        return ans     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783825,
                "title": "c-2179-count-good-triplets-in-an-array",
                "content": "\\n```\\ntemplate<class T>\\nclass Fenwick {\\n    vector<T> nums; \\npublic: \\n    Fenwick(int n) {\\n        nums.resize(n+1); \\n    }\\n\\n    void update(int k, T x) {\\n        for (++k; k < nums.size(); k += k & -k) \\n            nums[k] += x; \\n    }\\n\\n    T query(int k) {\\n        T ans = 0; \\n        for (++k; k; k -= k & -k) \\n            ans += nums[k]; \\n        return ans; \\n    }\\n}; \\n\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(); \\n        unordered_map<int, int> mp; \\n        for (int i = 0; i < n; ++i) mp[nums1[i]] = i; \\n        long long ans = 0; \\n        Fenwick<int> *fw = new Fenwick<int>(n); \\n        for (auto& x : nums2) {\\n            x = mp[x]; \\n            int left = fw->query(x), right = (n-1-x) - (fw->query(n-1)-fw->query(x)); \\n            ans += (long long) left * right; \\n            fw->update(x, 1); \\n        }\\n        delete fw; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntemplate<class T>\\nclass Fenwick {\\n    vector<T> nums; \\npublic: \\n    Fenwick(int n) {\\n        nums.resize(n+1); \\n    }\\n\\n    void update(int k, T x) {\\n        for (++k; k < nums.size(); k += k & -k) \\n            nums[k] += x; \\n    }\\n\\n    T query(int k) {\\n        T ans = 0; \\n        for (++k; k; k -= k & -k) \\n            ans += nums[k]; \\n        return ans; \\n    }\\n}; \\n\\n\\nclass Solution {\\npublic:\\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(); \\n        unordered_map<int, int> mp; \\n        for (int i = 0; i < n; ++i) mp[nums1[i]] = i; \\n        long long ans = 0; \\n        Fenwick<int> *fw = new Fenwick<int>(n); \\n        for (auto& x : nums2) {\\n            x = mp[x]; \\n            int left = fw->query(x), right = (n-1-x) - (fw->query(n-1)-fw->query(x)); \\n            ans += (long long) left * right; \\n            fw->update(x, 1); \\n        }\\n        delete fw; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783732,
                "title": "c-o-nlogn-binary-indexed-tree",
                "content": "```\\npublic long GoodTriplets(int[] nums1, int[] nums2) {\\n\\tint n = nums1.Length;\\n\\tlong[,] dp = new long[n, 3];\\n\\tlong res = 0;\\n\\n\\tint[] mp2 = new int[n];\\n\\tfor(int i=0; i<nums2.Length; i++) {\\n\\t\\tdp[i, 0] = 1;\\n\\t\\tmp2[nums2[i]] = i;\\n\\t}\\n\\n\\tfor(int k=1; k<3; k++) {\\n\\t\\tlong[] bita = new long[n+1];\\n\\t\\tfor(int i=n-k; i>=0; i--) {\\n\\t\\t\\tint j = n - 1 - mp2[nums1[i]];                \\n\\t\\t\\tdp[i, k] = query(bita, j-1);\\n\\t\\t\\tupdate(bita, j, dp[i, k-1]);\\n\\t\\t\\tif (k==2) {\\n\\t\\t\\t\\tres += dp[i, k];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nlong query(long[] bita, int i) {\\n\\ti++;\\n\\tlong cur = 0;\\n\\twhile(i > 0) {\\n\\t\\tcur += bita[i];\\n\\t\\ti -= (i&-i);\\n\\t}\\n\\treturn cur;\\n}\\n\\nvoid update(long[] bita, int i, long v) {\\n\\ti++;\\n\\twhile(i < bita.Length) {\\n\\t\\tbita[i] += v;\\n\\t\\ti += (i&-i);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic long GoodTriplets(int[] nums1, int[] nums2) {\\n\\tint n = nums1.Length;\\n\\tlong[,] dp = new long[n, 3];\\n\\tlong res = 0;\\n\\n\\tint[] mp2 = new int[n];\\n\\tfor(int i=0; i<nums2.Length; i++) {\\n\\t\\tdp[i, 0] = 1;\\n\\t\\tmp2[nums2[i]] = i;\\n\\t}\\n\\n\\tfor(int k=1; k<3; k++) {\\n\\t\\tlong[] bita = new long[n+1];\\n\\t\\tfor(int i=n-k; i>=0; i--) {\\n\\t\\t\\tint j = n - 1 - mp2[nums1[i]];                \\n\\t\\t\\tdp[i, k] = query(bita, j-1);\\n\\t\\t\\tupdate(bita, j, dp[i, k-1]);\\n\\t\\t\\tif (k==2) {\\n\\t\\t\\t\\tres += dp[i, k];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nlong query(long[] bita, int i) {\\n\\ti++;\\n\\tlong cur = 0;\\n\\twhile(i > 0) {\\n\\t\\tcur += bita[i];\\n\\t\\ti -= (i&-i);\\n\\t}\\n\\treturn cur;\\n}\\n\\nvoid update(long[] bita, int i, long v) {\\n\\ti++;\\n\\twhile(i < bita.Length) {\\n\\t\\tbita[i] += v;\\n\\t\\ti += (i&-i);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783724,
                "title": "java-working-java-solution-but-time-limit-exceeded",
                "content": "Not sure how to improve further as all possible triplets need to be visited\\n\\n```\\nclass Solution {\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        Map<Integer, Integer> numIndexMap = getNumIndexMap(nums2);\\n        \\n        // Update nums1 to corrsponding index positions in nums2\\n        for (int i = 0; i < nums1.length; i++) {\\n            nums1[i] = numIndexMap.get(nums1[i]);\\n        }\\n        \\n        // For triplets to be valid, the order of indices must be in increasing order\\n        int validTriplets = 0;\\n        List<TripletTree> possibleTriplets = new ArrayList<>();\\n        \\n        for (int i = 0; i < nums1.length; i++) {\\n            int pos = nums1[i];\\n            for (TripletTree t: possibleTriplets) {\\n                validTriplets += t.addChild(pos);\\n            }\\n            \\n            possibleTriplets.add(new TripletTree(pos));\\n        }\\n        \\n        return validTriplets;\\n    }\\n    \\n    private Map<Integer, Integer> getNumIndexMap(int[] nums) {\\n        Map<Integer, Integer> result = new HashMap<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            result.put(nums[i], i);\\n        }\\n        return result;\\n    }\\n    \\n    // Tree in which all children are always greater than parent\\n    class TripletTree {\\n        int x;\\n        List<TripletTree> children = new ArrayList<>();\\n        \\n        public TripletTree(int x) {\\n            this.x = x;\\n        }\\n        \\n        // Adds the val to children of root or root, id it satisfies tree condition. \\n        // Checks only 1 level of children, as we need triplet size to be 3\\n        // Returns number of valid triplets added to the tree, i.e. val added to 2nd level\\n        public int addChild(int val) {\\n            int numPaths = 0;\\n            for (TripletTree t: this.children) {\\n                if (val > t.x) {\\n                    t.children.add(new TripletTree(val));\\n                    numPaths++;\\n                }\\n            }\\n            if (val > x) {\\n                this.children.add(new TripletTree(val));\\n            }\\n            return numPaths;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long goodTriplets(int[] nums1, int[] nums2) {\\n        Map<Integer, Integer> numIndexMap = getNumIndexMap(nums2);\\n        \\n        // Update nums1 to corrsponding index positions in nums2\\n        for (int i = 0; i < nums1.length; i++) {\\n            nums1[i] = numIndexMap.get(nums1[i]);\\n        }\\n        \\n        // For triplets to be valid, the order of indices must be in increasing order\\n        int validTriplets = 0;\\n        List<TripletTree> possibleTriplets = new ArrayList<>();\\n        \\n        for (int i = 0; i < nums1.length; i++) {\\n            int pos = nums1[i];\\n            for (TripletTree t: possibleTriplets) {\\n                validTriplets += t.addChild(pos);\\n            }\\n            \\n            possibleTriplets.add(new TripletTree(pos));\\n        }\\n        \\n        return validTriplets;\\n    }\\n    \\n    private Map<Integer, Integer> getNumIndexMap(int[] nums) {\\n        Map<Integer, Integer> result = new HashMap<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            result.put(nums[i], i);\\n        }\\n        return result;\\n    }\\n    \\n    // Tree in which all children are always greater than parent\\n    class TripletTree {\\n        int x;\\n        List<TripletTree> children = new ArrayList<>();\\n        \\n        public TripletTree(int x) {\\n            this.x = x;\\n        }\\n        \\n        // Adds the val to children of root or root, id it satisfies tree condition. \\n        // Checks only 1 level of children, as we need triplet size to be 3\\n        // Returns number of valid triplets added to the tree, i.e. val added to 2nd level\\n        public int addChild(int val) {\\n            int numPaths = 0;\\n            for (TripletTree t: this.children) {\\n                if (val > t.x) {\\n                    t.children.add(new TripletTree(val));\\n                    numPaths++;\\n                }\\n            }\\n            if (val > x) {\\n                this.children.add(new TripletTree(val));\\n            }\\n            return numPaths;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783678,
                "title": "dp-solution-tle",
                "content": "This is a DP solution which resulted in TLE.\\n\\nLet `dp(k - 1, i, j)` be the count of good \"k-plets\" obtianed from subarray `nums1[ : i] `and `nums2[ : j].`\\nConsider the last number in num1 and num2:\\n1.  Select both as the last element in the k-plet: `dp(k - 1, i - 1, j - 1)`\\n2.  Select the last number of num1 as the last element in the k-plet, and this value must appear in nums2 before index j - 1: : `dp(k - 1, i - 1, indexof(nums2[i - 1]) in nums2[ : j])`\\n3.   Select the last number of num2 as the last element in the k-plet, and this value must appear in nums1 before index i - 1: `dp(k - 1, indexof(nums2[j - 1]) in nums1[ : i], j - 1)`\\n4.   Select neither the last two elements in nums1 and nums2: `dp(k, i - 1, j -1)`\\n\\nThen if `nums1[i - 1] == nums2[j - 1]` add up 1 and 4. Otherwise, add up 2, 3 and 4.\\n\\n```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1);\\n        memo = [];\\n        for k in range(3):\\n            memo.append([]);\\n            for i in range(n + 1):\\n                memo[k].append([]);\\n                for j in range(n + 1):\\n                    memo[k][i].append(None);\\n        map1 = {};\\n        map2 = {};\\n        for i in range(n):\\n            map1[nums1[i]] = i;\\n            map2[nums2[i]] = i;\\n        \\n        def dp(k: int, i: int, j: int) -> int:\\n            if i < k + 1 or j < k + 1:\\n                return 0;\\n            if k < 0:\\n                return 1;\\n            if memo[k][i][j] != None:\\n                return memo[k][i][j];\\n            cur = dp(k, i - 1, j - 1);\\n            if nums1[i - 1] == nums2[j - 1]:\\n                cur += dp(k - 1, i - 1, j - 1);\\n            else:\\n                if map2[nums1[i - 1]] < j - 1:\\n                    cur += dp(k - 1, i - 1, map2[nums1[i - 1]]);\\n                if map1[nums2[j - 1]] < i - 1:\\n                    cur += dp(k - 1, map1[nums2[j - 1]], j - 1);\\n                    \\n            memo[k][i][j] = cur;\\n            return cur;\\n        \\n        return dp(2, n, n);\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1);\\n        memo = [];\\n        for k in range(3):\\n            memo.append([]);\\n            for i in range(n + 1):\\n                memo[k].append([]);\\n                for j in range(n + 1):\\n                    memo[k][i].append(None);\\n        map1 = {};\\n        map2 = {};\\n        for i in range(n):\\n            map1[nums1[i]] = i;\\n            map2[nums2[i]] = i;\\n        \\n        def dp(k: int, i: int, j: int) -> int:\\n            if i < k + 1 or j < k + 1:\\n                return 0;\\n            if k < 0:\\n                return 1;\\n            if memo[k][i][j] != None:\\n                return memo[k][i][j];\\n            cur = dp(k, i - 1, j - 1);\\n            if nums1[i - 1] == nums2[j - 1]:\\n                cur += dp(k - 1, i - 1, j - 1);\\n            else:\\n                if map2[nums1[i - 1]] < j - 1:\\n                    cur += dp(k - 1, i - 1, map2[nums1[i - 1]]);\\n                if map1[nums2[j - 1]] < i - 1:\\n                    cur += dp(k - 1, map1[nums2[j - 1]], j - 1);\\n                    \\n            memo[k][i][j] = cur;\\n            return cur;\\n        \\n        return dp(2, n, n);\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2025616,
                "content": [
                    {
                        "username": "vipul0092",
                        "content": "Very easy to confuse yourself between numbers and indices in this problem. It took me a good amount of time to get things right.\nSo before you start writing code, do some dry runs of your logic with pen and paper.\nOne small but good test case to get you started is:\n\nnums1 = [2,3,9,8,4,7,0,6,5,1]\nnums2 = [8,7,9,5,6,2,4,3,1,0]\n\nAnswer: 18\n\nThe sample test cases given in the problem are too small to be very useful."
                    },
                    {
                        "username": "litaotao",
                        "content": "test case seems not right.\\nnums1 = [13,14,10,2,12,3,9,11,15,8,4,7,0,6,5,1]\\nnums2 = [8,7,9,5,6,14,15,10,2,11,4,13,3,12,1,0]\\n\\ntest case says there are 77 triplets, my code says there are 87 as bellow, and I verified those are valid triplets, can anyone correct me please? thanks\\n\\n```\\n     x   y   z  nums1[x]  nums1[y]  nums1[z]  nums2[x]  nums2[y]  nums2[z]\\n0    3   2   7         2        10        11         5         9        10\\n1    3   4   0         2        12        13         5         6         8\\n2    3   4   1         2        12        14         5         6         7\\n3    3   5   6         2         3         9         5        14        15\\n4    3   9   6         2         8         9         5        11        15\\n5    3  11   6         2         7         9         5        13        15\\n6    3  13   6         2         6         9         5        12        15\\n7    3  13  11         2         6         7         5        12        13\\n8   10   2   7         4        10        11         4         9        10\\n9   10   4   0         4        12        13         4         6         8\\n10  10   4   1         4        12        14         4         6         7\\n11  10   9   6         4         8         9         4        11        15\\n12  10  11   6         4         7         9         4        13        15\\n13  10  13   6         4         6         9         4        12        15\\n14  10  13  11         4         6         7         4        12        13\\n15  12   2   7         0        10        11         3         9        10\\n16  12   3   0         0         2        13         3         5         8\\n17  12   3   1         0         2        14         3         5         7\\n18  12   3   2         0         2        10         3         5         9\\n19  12   3   4         0         2        12         3         5         6\\n20  12   3   5         0         2         3         3         5        14\\n21  12   3   6         0         2         9         3         5        15\\n22  12   3   7         0         2        11         3         5        10\\n23  12   3   9         0         2         8         3         5        11\\n24  12   3  11         0         2         7         3         5        13\\n25  12   3  13         0         2         6         3         5        12\\n26  12   4   0         0        12        13         3         6         8\\n27  12   4   1         0        12        14         3         6         7\\n28  12   5   6         0         3         9         3        14        15\\n29  12   9   6         0         8         9         3        11        15\\n30  12  10   0         0         4        13         3         4         8\\n31  12  10   1         0         4        14         3         4         7\\n32  12  10   2         0         4        10         3         4         9\\n33  12  10   4         0         4        12         3         4         6\\n34  12  10   6         0         4         9         3         4        15\\n35  12  10   7         0         4        11         3         4        10\\n36  12  10   9         0         4         8         3         4        11\\n37  12  10  11         0         4         7         3         4        13\\n38  12  10  13         0         4         6         3         4        12\\n39  12  11   6         0         7         9         3        13        15\\n40  12  13   6         0         6         9         3        12        15\\n41  12  13  11         0         6         7         3        12        13\\n42  13  11   6         6         7         9        12        13        15\\n43  14   2   7         5        10        11         1         9        10\\n44  14   4   0         5        12        13         1         6         8\\n45  14   4   1         5        12        14         1         6         7\\n46  14   9   6         5         8         9         1        11        15\\n47  14  11   6         5         7         9         1        13        15\\n48  14  13   6         5         6         9         1        12        15\\n49  14  13  11         5         6         7         1        12        13\\n50  15   2   7         1        10        11         0         9        10\\n51  15   3   0         1         2        13         0         5         8\\n52  15   3   1         1         2        14         0         5         7\\n53  15   3   2         1         2        10         0         5         9\\n54  15   3   4         1         2        12         0         5         6\\n55  15   3   5         1         2         3         0         5        14\\n56  15   3   6         1         2         9         0         5        15\\n57  15   3   7         1         2        11         0         5        10\\n58  15   3   9         1         2         8         0         5        11\\n59  15   3  11         1         2         7         0         5        13\\n60  15   3  13         1         2         6         0         5        12\\n61  15   4   0         1        12        13         0         6         8\\n62  15   4   1         1        12        14         0         6         7\\n63  15   5   6         1         3         9         0        14        15\\n64  15   9   6         1         8         9         0        11        15\\n65  15  10   0         1         4        13         0         4         8\\n66  15  10   1         1         4        14         0         4         7\\n67  15  10   2         1         4        10         0         4         9\\n68  15  10   4         1         4        12         0         4         6\\n69  15  10   6         1         4         9         0         4        15\\n70  15  10   7         1         4        11         0         4        10\\n71  15  10   9         1         4         8         0         4        11\\n72  15  10  11         1         4         7         0         4        13\\n73  15  10  13         1         4         6         0         4        12\\n74  15  11   6         1         7         9         0        13        15\\n75  15  13   6         1         6         9         0        12        15\\n76  15  13  11         1         6         7         0        12        13\\n77  15  14   0         1         5        13         0         1         8\\n78  15  14   1         1         5        14         0         1         7\\n79  15  14   2         1         5        10         0         1         9\\n80  15  14   4         1         5        12         0         1         6\\n81  15  14   6         1         5         9         0         1        15\\n82  15  14   7         1         5        11         0         1        10\\n83  15  14   8         1         5        15         0         1         2\\n84  15  14   9         1         5         8         0         1        11\\n85  15  14  11         1         5         7         0         1        13\\n86  15  14  13         1         5         6         0         1        12\\n```"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Tree Approach\\nLet us consider these two arrays [1,4,2,0,6,5,3,7] [1,4,3,7,0,2,6,5]\\nNow the main observation of the question is-\\nLet\\'s say if i am currently at 5th index in first array then we will find it\\'s corresponding position in second array. In the above example it would be at second last position in second array.\\nNow for current index my answer would be (common elements in left part of first array and common elements in left part of second array) multiplied by (common elements in right part of first array and common elements in right part of second array).\\nIn above case for 5th index [1,4,2,0] is common in left part and [5] is common in right part.\\nSo, by traversing in this manner we can get our answer but this approach is (O(n^2)) which would not pass the constraints.\\nSo now segment tree comes as our saviour here.\\nwhile traversing the array we can update the corresponding positions in segment tree of second array (Initially all nodes in segment tree has 0 value).\\nBy this we can get common elements in left part in O(log n) time using range sum query on segment tree.\\nAnd now we have number of common elements in left part, we can easily get common elements in right part using simple maths."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    }
                ]
            },
            {
                "id": 1996972,
                "content": [
                    {
                        "username": "vipul0092",
                        "content": "Very easy to confuse yourself between numbers and indices in this problem. It took me a good amount of time to get things right.\nSo before you start writing code, do some dry runs of your logic with pen and paper.\nOne small but good test case to get you started is:\n\nnums1 = [2,3,9,8,4,7,0,6,5,1]\nnums2 = [8,7,9,5,6,2,4,3,1,0]\n\nAnswer: 18\n\nThe sample test cases given in the problem are too small to be very useful."
                    },
                    {
                        "username": "litaotao",
                        "content": "test case seems not right.\\nnums1 = [13,14,10,2,12,3,9,11,15,8,4,7,0,6,5,1]\\nnums2 = [8,7,9,5,6,14,15,10,2,11,4,13,3,12,1,0]\\n\\ntest case says there are 77 triplets, my code says there are 87 as bellow, and I verified those are valid triplets, can anyone correct me please? thanks\\n\\n```\\n     x   y   z  nums1[x]  nums1[y]  nums1[z]  nums2[x]  nums2[y]  nums2[z]\\n0    3   2   7         2        10        11         5         9        10\\n1    3   4   0         2        12        13         5         6         8\\n2    3   4   1         2        12        14         5         6         7\\n3    3   5   6         2         3         9         5        14        15\\n4    3   9   6         2         8         9         5        11        15\\n5    3  11   6         2         7         9         5        13        15\\n6    3  13   6         2         6         9         5        12        15\\n7    3  13  11         2         6         7         5        12        13\\n8   10   2   7         4        10        11         4         9        10\\n9   10   4   0         4        12        13         4         6         8\\n10  10   4   1         4        12        14         4         6         7\\n11  10   9   6         4         8         9         4        11        15\\n12  10  11   6         4         7         9         4        13        15\\n13  10  13   6         4         6         9         4        12        15\\n14  10  13  11         4         6         7         4        12        13\\n15  12   2   7         0        10        11         3         9        10\\n16  12   3   0         0         2        13         3         5         8\\n17  12   3   1         0         2        14         3         5         7\\n18  12   3   2         0         2        10         3         5         9\\n19  12   3   4         0         2        12         3         5         6\\n20  12   3   5         0         2         3         3         5        14\\n21  12   3   6         0         2         9         3         5        15\\n22  12   3   7         0         2        11         3         5        10\\n23  12   3   9         0         2         8         3         5        11\\n24  12   3  11         0         2         7         3         5        13\\n25  12   3  13         0         2         6         3         5        12\\n26  12   4   0         0        12        13         3         6         8\\n27  12   4   1         0        12        14         3         6         7\\n28  12   5   6         0         3         9         3        14        15\\n29  12   9   6         0         8         9         3        11        15\\n30  12  10   0         0         4        13         3         4         8\\n31  12  10   1         0         4        14         3         4         7\\n32  12  10   2         0         4        10         3         4         9\\n33  12  10   4         0         4        12         3         4         6\\n34  12  10   6         0         4         9         3         4        15\\n35  12  10   7         0         4        11         3         4        10\\n36  12  10   9         0         4         8         3         4        11\\n37  12  10  11         0         4         7         3         4        13\\n38  12  10  13         0         4         6         3         4        12\\n39  12  11   6         0         7         9         3        13        15\\n40  12  13   6         0         6         9         3        12        15\\n41  12  13  11         0         6         7         3        12        13\\n42  13  11   6         6         7         9        12        13        15\\n43  14   2   7         5        10        11         1         9        10\\n44  14   4   0         5        12        13         1         6         8\\n45  14   4   1         5        12        14         1         6         7\\n46  14   9   6         5         8         9         1        11        15\\n47  14  11   6         5         7         9         1        13        15\\n48  14  13   6         5         6         9         1        12        15\\n49  14  13  11         5         6         7         1        12        13\\n50  15   2   7         1        10        11         0         9        10\\n51  15   3   0         1         2        13         0         5         8\\n52  15   3   1         1         2        14         0         5         7\\n53  15   3   2         1         2        10         0         5         9\\n54  15   3   4         1         2        12         0         5         6\\n55  15   3   5         1         2         3         0         5        14\\n56  15   3   6         1         2         9         0         5        15\\n57  15   3   7         1         2        11         0         5        10\\n58  15   3   9         1         2         8         0         5        11\\n59  15   3  11         1         2         7         0         5        13\\n60  15   3  13         1         2         6         0         5        12\\n61  15   4   0         1        12        13         0         6         8\\n62  15   4   1         1        12        14         0         6         7\\n63  15   5   6         1         3         9         0        14        15\\n64  15   9   6         1         8         9         0        11        15\\n65  15  10   0         1         4        13         0         4         8\\n66  15  10   1         1         4        14         0         4         7\\n67  15  10   2         1         4        10         0         4         9\\n68  15  10   4         1         4        12         0         4         6\\n69  15  10   6         1         4         9         0         4        15\\n70  15  10   7         1         4        11         0         4        10\\n71  15  10   9         1         4         8         0         4        11\\n72  15  10  11         1         4         7         0         4        13\\n73  15  10  13         1         4         6         0         4        12\\n74  15  11   6         1         7         9         0        13        15\\n75  15  13   6         1         6         9         0        12        15\\n76  15  13  11         1         6         7         0        12        13\\n77  15  14   0         1         5        13         0         1         8\\n78  15  14   1         1         5        14         0         1         7\\n79  15  14   2         1         5        10         0         1         9\\n80  15  14   4         1         5        12         0         1         6\\n81  15  14   6         1         5         9         0         1        15\\n82  15  14   7         1         5        11         0         1        10\\n83  15  14   8         1         5        15         0         1         2\\n84  15  14   9         1         5         8         0         1        11\\n85  15  14  11         1         5         7         0         1        13\\n86  15  14  13         1         5         6         0         1        12\\n```"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Tree Approach\\nLet us consider these two arrays [1,4,2,0,6,5,3,7] [1,4,3,7,0,2,6,5]\\nNow the main observation of the question is-\\nLet\\'s say if i am currently at 5th index in first array then we will find it\\'s corresponding position in second array. In the above example it would be at second last position in second array.\\nNow for current index my answer would be (common elements in left part of first array and common elements in left part of second array) multiplied by (common elements in right part of first array and common elements in right part of second array).\\nIn above case for 5th index [1,4,2,0] is common in left part and [5] is common in right part.\\nSo, by traversing in this manner we can get our answer but this approach is (O(n^2)) which would not pass the constraints.\\nSo now segment tree comes as our saviour here.\\nwhile traversing the array we can update the corresponding positions in segment tree of second array (Initially all nodes in segment tree has 0 value).\\nBy this we can get common elements in left part in O(log n) time using range sum query on segment tree.\\nAnd now we have number of common elements in left part, we can easily get common elements in right part using simple maths."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    }
                ]
            },
            {
                "id": 1692417,
                "content": [
                    {
                        "username": "vipul0092",
                        "content": "Very easy to confuse yourself between numbers and indices in this problem. It took me a good amount of time to get things right.\nSo before you start writing code, do some dry runs of your logic with pen and paper.\nOne small but good test case to get you started is:\n\nnums1 = [2,3,9,8,4,7,0,6,5,1]\nnums2 = [8,7,9,5,6,2,4,3,1,0]\n\nAnswer: 18\n\nThe sample test cases given in the problem are too small to be very useful."
                    },
                    {
                        "username": "litaotao",
                        "content": "test case seems not right.\\nnums1 = [13,14,10,2,12,3,9,11,15,8,4,7,0,6,5,1]\\nnums2 = [8,7,9,5,6,14,15,10,2,11,4,13,3,12,1,0]\\n\\ntest case says there are 77 triplets, my code says there are 87 as bellow, and I verified those are valid triplets, can anyone correct me please? thanks\\n\\n```\\n     x   y   z  nums1[x]  nums1[y]  nums1[z]  nums2[x]  nums2[y]  nums2[z]\\n0    3   2   7         2        10        11         5         9        10\\n1    3   4   0         2        12        13         5         6         8\\n2    3   4   1         2        12        14         5         6         7\\n3    3   5   6         2         3         9         5        14        15\\n4    3   9   6         2         8         9         5        11        15\\n5    3  11   6         2         7         9         5        13        15\\n6    3  13   6         2         6         9         5        12        15\\n7    3  13  11         2         6         7         5        12        13\\n8   10   2   7         4        10        11         4         9        10\\n9   10   4   0         4        12        13         4         6         8\\n10  10   4   1         4        12        14         4         6         7\\n11  10   9   6         4         8         9         4        11        15\\n12  10  11   6         4         7         9         4        13        15\\n13  10  13   6         4         6         9         4        12        15\\n14  10  13  11         4         6         7         4        12        13\\n15  12   2   7         0        10        11         3         9        10\\n16  12   3   0         0         2        13         3         5         8\\n17  12   3   1         0         2        14         3         5         7\\n18  12   3   2         0         2        10         3         5         9\\n19  12   3   4         0         2        12         3         5         6\\n20  12   3   5         0         2         3         3         5        14\\n21  12   3   6         0         2         9         3         5        15\\n22  12   3   7         0         2        11         3         5        10\\n23  12   3   9         0         2         8         3         5        11\\n24  12   3  11         0         2         7         3         5        13\\n25  12   3  13         0         2         6         3         5        12\\n26  12   4   0         0        12        13         3         6         8\\n27  12   4   1         0        12        14         3         6         7\\n28  12   5   6         0         3         9         3        14        15\\n29  12   9   6         0         8         9         3        11        15\\n30  12  10   0         0         4        13         3         4         8\\n31  12  10   1         0         4        14         3         4         7\\n32  12  10   2         0         4        10         3         4         9\\n33  12  10   4         0         4        12         3         4         6\\n34  12  10   6         0         4         9         3         4        15\\n35  12  10   7         0         4        11         3         4        10\\n36  12  10   9         0         4         8         3         4        11\\n37  12  10  11         0         4         7         3         4        13\\n38  12  10  13         0         4         6         3         4        12\\n39  12  11   6         0         7         9         3        13        15\\n40  12  13   6         0         6         9         3        12        15\\n41  12  13  11         0         6         7         3        12        13\\n42  13  11   6         6         7         9        12        13        15\\n43  14   2   7         5        10        11         1         9        10\\n44  14   4   0         5        12        13         1         6         8\\n45  14   4   1         5        12        14         1         6         7\\n46  14   9   6         5         8         9         1        11        15\\n47  14  11   6         5         7         9         1        13        15\\n48  14  13   6         5         6         9         1        12        15\\n49  14  13  11         5         6         7         1        12        13\\n50  15   2   7         1        10        11         0         9        10\\n51  15   3   0         1         2        13         0         5         8\\n52  15   3   1         1         2        14         0         5         7\\n53  15   3   2         1         2        10         0         5         9\\n54  15   3   4         1         2        12         0         5         6\\n55  15   3   5         1         2         3         0         5        14\\n56  15   3   6         1         2         9         0         5        15\\n57  15   3   7         1         2        11         0         5        10\\n58  15   3   9         1         2         8         0         5        11\\n59  15   3  11         1         2         7         0         5        13\\n60  15   3  13         1         2         6         0         5        12\\n61  15   4   0         1        12        13         0         6         8\\n62  15   4   1         1        12        14         0         6         7\\n63  15   5   6         1         3         9         0        14        15\\n64  15   9   6         1         8         9         0        11        15\\n65  15  10   0         1         4        13         0         4         8\\n66  15  10   1         1         4        14         0         4         7\\n67  15  10   2         1         4        10         0         4         9\\n68  15  10   4         1         4        12         0         4         6\\n69  15  10   6         1         4         9         0         4        15\\n70  15  10   7         1         4        11         0         4        10\\n71  15  10   9         1         4         8         0         4        11\\n72  15  10  11         1         4         7         0         4        13\\n73  15  10  13         1         4         6         0         4        12\\n74  15  11   6         1         7         9         0        13        15\\n75  15  13   6         1         6         9         0        12        15\\n76  15  13  11         1         6         7         0        12        13\\n77  15  14   0         1         5        13         0         1         8\\n78  15  14   1         1         5        14         0         1         7\\n79  15  14   2         1         5        10         0         1         9\\n80  15  14   4         1         5        12         0         1         6\\n81  15  14   6         1         5         9         0         1        15\\n82  15  14   7         1         5        11         0         1        10\\n83  15  14   8         1         5        15         0         1         2\\n84  15  14   9         1         5         8         0         1        11\\n85  15  14  11         1         5         7         0         1        13\\n86  15  14  13         1         5         6         0         1        12\\n```"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Tree Approach\\nLet us consider these two arrays [1,4,2,0,6,5,3,7] [1,4,3,7,0,2,6,5]\\nNow the main observation of the question is-\\nLet\\'s say if i am currently at 5th index in first array then we will find it\\'s corresponding position in second array. In the above example it would be at second last position in second array.\\nNow for current index my answer would be (common elements in left part of first array and common elements in left part of second array) multiplied by (common elements in right part of first array and common elements in right part of second array).\\nIn above case for 5th index [1,4,2,0] is common in left part and [5] is common in right part.\\nSo, by traversing in this manner we can get our answer but this approach is (O(n^2)) which would not pass the constraints.\\nSo now segment tree comes as our saviour here.\\nwhile traversing the array we can update the corresponding positions in segment tree of second array (Initially all nodes in segment tree has 0 value).\\nBy this we can get common elements in left part in O(log n) time using range sum query on segment tree.\\nAnd now we have number of common elements in left part, we can easily get common elements in right part using simple maths."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    }
                ]
            },
            {
                "id": 1742840,
                "content": [
                    {
                        "username": "vipul0092",
                        "content": "Very easy to confuse yourself between numbers and indices in this problem. It took me a good amount of time to get things right.\nSo before you start writing code, do some dry runs of your logic with pen and paper.\nOne small but good test case to get you started is:\n\nnums1 = [2,3,9,8,4,7,0,6,5,1]\nnums2 = [8,7,9,5,6,2,4,3,1,0]\n\nAnswer: 18\n\nThe sample test cases given in the problem are too small to be very useful."
                    },
                    {
                        "username": "litaotao",
                        "content": "test case seems not right.\\nnums1 = [13,14,10,2,12,3,9,11,15,8,4,7,0,6,5,1]\\nnums2 = [8,7,9,5,6,14,15,10,2,11,4,13,3,12,1,0]\\n\\ntest case says there are 77 triplets, my code says there are 87 as bellow, and I verified those are valid triplets, can anyone correct me please? thanks\\n\\n```\\n     x   y   z  nums1[x]  nums1[y]  nums1[z]  nums2[x]  nums2[y]  nums2[z]\\n0    3   2   7         2        10        11         5         9        10\\n1    3   4   0         2        12        13         5         6         8\\n2    3   4   1         2        12        14         5         6         7\\n3    3   5   6         2         3         9         5        14        15\\n4    3   9   6         2         8         9         5        11        15\\n5    3  11   6         2         7         9         5        13        15\\n6    3  13   6         2         6         9         5        12        15\\n7    3  13  11         2         6         7         5        12        13\\n8   10   2   7         4        10        11         4         9        10\\n9   10   4   0         4        12        13         4         6         8\\n10  10   4   1         4        12        14         4         6         7\\n11  10   9   6         4         8         9         4        11        15\\n12  10  11   6         4         7         9         4        13        15\\n13  10  13   6         4         6         9         4        12        15\\n14  10  13  11         4         6         7         4        12        13\\n15  12   2   7         0        10        11         3         9        10\\n16  12   3   0         0         2        13         3         5         8\\n17  12   3   1         0         2        14         3         5         7\\n18  12   3   2         0         2        10         3         5         9\\n19  12   3   4         0         2        12         3         5         6\\n20  12   3   5         0         2         3         3         5        14\\n21  12   3   6         0         2         9         3         5        15\\n22  12   3   7         0         2        11         3         5        10\\n23  12   3   9         0         2         8         3         5        11\\n24  12   3  11         0         2         7         3         5        13\\n25  12   3  13         0         2         6         3         5        12\\n26  12   4   0         0        12        13         3         6         8\\n27  12   4   1         0        12        14         3         6         7\\n28  12   5   6         0         3         9         3        14        15\\n29  12   9   6         0         8         9         3        11        15\\n30  12  10   0         0         4        13         3         4         8\\n31  12  10   1         0         4        14         3         4         7\\n32  12  10   2         0         4        10         3         4         9\\n33  12  10   4         0         4        12         3         4         6\\n34  12  10   6         0         4         9         3         4        15\\n35  12  10   7         0         4        11         3         4        10\\n36  12  10   9         0         4         8         3         4        11\\n37  12  10  11         0         4         7         3         4        13\\n38  12  10  13         0         4         6         3         4        12\\n39  12  11   6         0         7         9         3        13        15\\n40  12  13   6         0         6         9         3        12        15\\n41  12  13  11         0         6         7         3        12        13\\n42  13  11   6         6         7         9        12        13        15\\n43  14   2   7         5        10        11         1         9        10\\n44  14   4   0         5        12        13         1         6         8\\n45  14   4   1         5        12        14         1         6         7\\n46  14   9   6         5         8         9         1        11        15\\n47  14  11   6         5         7         9         1        13        15\\n48  14  13   6         5         6         9         1        12        15\\n49  14  13  11         5         6         7         1        12        13\\n50  15   2   7         1        10        11         0         9        10\\n51  15   3   0         1         2        13         0         5         8\\n52  15   3   1         1         2        14         0         5         7\\n53  15   3   2         1         2        10         0         5         9\\n54  15   3   4         1         2        12         0         5         6\\n55  15   3   5         1         2         3         0         5        14\\n56  15   3   6         1         2         9         0         5        15\\n57  15   3   7         1         2        11         0         5        10\\n58  15   3   9         1         2         8         0         5        11\\n59  15   3  11         1         2         7         0         5        13\\n60  15   3  13         1         2         6         0         5        12\\n61  15   4   0         1        12        13         0         6         8\\n62  15   4   1         1        12        14         0         6         7\\n63  15   5   6         1         3         9         0        14        15\\n64  15   9   6         1         8         9         0        11        15\\n65  15  10   0         1         4        13         0         4         8\\n66  15  10   1         1         4        14         0         4         7\\n67  15  10   2         1         4        10         0         4         9\\n68  15  10   4         1         4        12         0         4         6\\n69  15  10   6         1         4         9         0         4        15\\n70  15  10   7         1         4        11         0         4        10\\n71  15  10   9         1         4         8         0         4        11\\n72  15  10  11         1         4         7         0         4        13\\n73  15  10  13         1         4         6         0         4        12\\n74  15  11   6         1         7         9         0        13        15\\n75  15  13   6         1         6         9         0        12        15\\n76  15  13  11         1         6         7         0        12        13\\n77  15  14   0         1         5        13         0         1         8\\n78  15  14   1         1         5        14         0         1         7\\n79  15  14   2         1         5        10         0         1         9\\n80  15  14   4         1         5        12         0         1         6\\n81  15  14   6         1         5         9         0         1        15\\n82  15  14   7         1         5        11         0         1        10\\n83  15  14   8         1         5        15         0         1         2\\n84  15  14   9         1         5         8         0         1        11\\n85  15  14  11         1         5         7         0         1        13\\n86  15  14  13         1         5         6         0         1        12\\n```"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Tree Approach\\nLet us consider these two arrays [1,4,2,0,6,5,3,7] [1,4,3,7,0,2,6,5]\\nNow the main observation of the question is-\\nLet\\'s say if i am currently at 5th index in first array then we will find it\\'s corresponding position in second array. In the above example it would be at second last position in second array.\\nNow for current index my answer would be (common elements in left part of first array and common elements in left part of second array) multiplied by (common elements in right part of first array and common elements in right part of second array).\\nIn above case for 5th index [1,4,2,0] is common in left part and [5] is common in right part.\\nSo, by traversing in this manner we can get our answer but this approach is (O(n^2)) which would not pass the constraints.\\nSo now segment tree comes as our saviour here.\\nwhile traversing the array we can update the corresponding positions in segment tree of second array (Initially all nodes in segment tree has 0 value).\\nBy this we can get common elements in left part in O(log n) time using range sum query on segment tree.\\nAnd now we have number of common elements in left part, we can easily get common elements in right part using simple maths."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    }
                ]
            }
        ]
    }
]