[
    {
        "title": "Populating Next Right Pointers in Each Node II",
        "question_content": "Given a binary tree\n\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\n&nbsp;\nExample 1:\n\nInput: root = [1,2,3,4,5,null,7]\nOutput: [1,#,2,3,#,4,5,7,#]\nExplanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.\n\nExample 2:\n\nInput: root = []\nOutput: []\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [0, 6000].\n\t-100 <= Node.val <= 100\n\n&nbsp;\nFollow-up:\n\n\tYou may only use constant extra space.\n\tThe recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.",
        "solutions": [
            {
                "id": 37828,
                "title": "o-1-space-o-n-complexity-iterative-solution",
                "content": "Just share my iterative solution with O(1) space and O(n) Time complexity\\n\\n    public class Solution {\\n        \\n        //based on level order traversal\\n        public void connect(TreeLinkNode root) {\\n    \\n            TreeLinkNode head = null; //head of the next level\\n            TreeLinkNode prev = null; //the leading node on the next level\\n            TreeLinkNode cur = root;  //current node of current level\\n    \\n            while (cur != null) {\\n                \\n                while (cur != null) { //iterate on the current level\\n                    //left child\\n                    if (cur.left != null) {\\n                        if (prev != null) {\\n                            prev.next = cur.left;\\n                        } else {\\n                            head = cur.left;\\n                        }\\n                        prev = cur.left;\\n                    }\\n                    //right child\\n                    if (cur.right != null) {\\n                        if (prev != null) {\\n                            prev.next = cur.right;\\n                        } else {\\n                            head = cur.right;\\n                        }\\n                        prev = cur.right;\\n                    }\\n                    //move to next node\\n                    cur = cur.next;\\n                }\\n                \\n                //move to next level\\n                cur = head;\\n                head = null;\\n                prev = null;\\n            }\\n            \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        //based on level order traversal\\n        public void connect(TreeLinkNode root) {\\n    \\n            TreeLinkNode head = null; //head of the next level\\n            TreeLinkNode prev = null; //the leading node on the next level\\n            TreeLinkNode cur = root;  //current node of current level\\n    \\n            while (cur != null) {\\n                \\n                while (cur != null) { //iterate on the current level\\n                    //left child\\n                    if (cur.left != null) {\\n                        if (prev != null) {\\n                            prev.next = cur.left;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 37811,
                "title": "simple-solution-using-constant-space",
                "content": "The idea is simple: level-order traversal.\\nYou can see the following code:\\n\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            \\n            while(root != null){\\n                TreeLinkNode tempChild = new TreeLinkNode(0);\\n                TreeLinkNode currentChild = tempChild;\\n                while(root!=null){\\n                    if(root.left != null) { currentChild.next = root.left; currentChild = currentChild.next;}\\n                    if(root.right != null) { currentChild.next = root.right; currentChild = currentChild.next;}\\n                    root = root.next;\\n                }\\n                root = tempChild.next;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            \\n            while(root != null){\\n                TreeLinkNode tempChild = new TreeLinkNode(0);\\n                TreeLinkNode currentChild = tempChild;\\n                while(root!=null){\\n                    if(root.left != null) { currentChild.next = root.left; currentChild = currentChild.next;}",
                "codeTag": "Java"
            },
            {
                "id": 37813,
                "title": "java-solution-with-constant-space",
                "content": "    public void connect(TreeLinkNode root) {\\n\\t    TreeLinkNode dummyHead = new TreeLinkNode(0);\\n\\t    TreeLinkNode pre = dummyHead;\\n\\t    while (root != null) {\\n\\t\\t    if (root.left != null) {\\n\\t\\t\\t    pre.next = root.left;\\n\\t\\t\\t    pre = pre.next;\\n\\t\\t    }\\n\\t\\t    if (root.right != null) {\\n\\t\\t\\t    pre.next = root.right;\\n\\t\\t\\t    pre = pre.next;\\n\\t\\t    }\\n\\t\\t    root = root.next;\\n\\t\\t    if (root == null) {\\n\\t\\t\\t    pre = dummyHead;\\n\\t\\t\\t    root = dummyHead.next;\\n\\t\\t\\t    dummyHead.next = null;\\n\\t\\t    }\\n\\t    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void connect(TreeLinkNode root) {\\n\\t    TreeLinkNode dummyHead = new TreeLinkNode(0);\\n\\t    TreeLinkNode pre = dummyHead;\\n\\t    while (root != null) {\\n\\t\\t    if (root.left != null) {\\n\\t\\t\\t    pre.next = root.left;\\n\\t\\t\\t    pre = pre.next;\\n\\t\\t    }\\n\\t\\t    if (root.right != null) {\\n\\t\\t\\t    pre.next = root.right;\\n\\t\\t\\t    pre = pre.next;\\n\\t\\t    }\\n\\t\\t    root = root.next;\\n\\t\\t    if (root == null) {\\n\\t\\t\\t    pre = dummyHead;\\n\\t\\t\\t    root = dummyHead.next;\\n\\t\\t\\t    dummyHead.next = null;\\n\\t\\t    }\\n\\t    }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37824,
                "title": "ac-python-o-1-space-solution-12-lines-and-easy-to-understand",
                "content": "The algorithm is a BFS or level order traversal. We go through the tree level by level. node is the pointer in the parent level, tail is the tail pointer in the child level.\\nThe parent level can be view as a singly linked list or queue, which we can traversal easily with a pointer.\\nConnect the tail with every one of the possible nodes in child level, update it only if the connected node is not nil.\\nDo this one level by one level. The whole thing is quite straightforward.\\n\\n**Python**\\n\\n    def connect(self, node):\\n        tail = dummy = TreeLinkNode(0)\\n        while node:\\n            tail.next = node.left\\n            if tail.next:\\n                tail = tail.next\\n            tail.next = node.right\\n            if tail.next:\\n                tail = tail.next\\n            node = node.next\\n            if not node:\\n                tail = dummy\\n                node = dummy.next\\n\\n\\n    # 61 / 61 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 100 ms\\n    # 95.26%",
                "solutionTags": [
                    "Python"
                ],
                "code": "The algorithm is a BFS or level order traversal. We go through the tree level by level. node is the pointer in the parent level, tail is the tail pointer in the child level.\\nThe parent level can be view as a singly linked list or queue, which we can traversal easily with a pointer.\\nConnect the tail with every one of the possible nodes in child level, update it only if the connected node is not nil.\\nDo this one level by one level. The whole thing is quite straightforward.\\n\\n**Python**\\n\\n    def connect(self, node):\\n        tail = dummy = TreeLinkNode(0)\\n        while node:\\n            tail.next = node.left\\n            if tail.next:\\n                tail = tail.next\\n            tail.next = node.right\\n            if tail.next:\\n                tail = tail.next\\n            node = node.next\\n            if not node:\\n                tail = dummy\\n                node = dummy.next\\n\\n\\n    # 61 / 61 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 100 ms\\n    # 95.26%",
                "codeTag": "Python3"
            },
            {
                "id": 961868,
                "title": "python-o-n-solution-explained",
                "content": "I spend some time for this problem, because my solution for problem **116** is quite different and can not be applied here (https://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/934066/Python-O(n)-time-O(log-n)-space-recursion-explained). So, we need to think of something different here.\\n\\nThe main idea is to go level by level and use already existing `.next` connections: if you will not do it, problem will be quite painful. So, idea is the following:\\n1. We will keep two nodes: `node` and `curr`: first one is for parent level and `curr` for next level.\\n2. We check if we have `node.left` and if we have, we create connection `curr.next = node.left` and also move our `curr` to the right, so it always will be the rightest visited node in level.\\n3. In similar way we check if we have `node.right` and do the same for it.\\n4. When we finished with `node`, we move it to right: `node = node.next`.\\n5. Finally, we need to go to the next level: we update `node = dummy.next`.\\n\\nNote, that in this place we will have some extra connections from dummy variables to left side of our tree, but there is no way testing system can detect it, because it is one-way connections. If you want to be completely honest, you need to add just one more line `dummy.next = None` after the line `node = dummy.next`.\\n\\n**Complexity**: time complexity is `O(n)`: we visit each node of our tree only once. Space complexity is `O(1)`\\n\\n```\\nclass Solution:\\n    def connect(self, root):\\n        node = root\\n        while node:\\n            curr = dummy = Node(0)\\n            while node:\\n                if node.left:\\n                    curr.next = node.left\\n                    curr = curr.next\\n                if node.right:\\n                    curr.next = node.right\\n                    curr = curr.next\\n                node = node.next\\n            node = dummy.next\\n               \\n        return root\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connect(self, root):\\n        node = root\\n        while node:\\n            curr = dummy = Node(0)\\n            while node:\\n                if node.left:\\n                    curr.next = node.left\\n                    curr = curr.next\\n                if node.right:\\n                    curr.next = node.right\\n                    curr = curr.next\\n                node = node.next\\n            node = dummy.next\\n               \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472675,
                "title": "short-java-solution-with-explanation-100-runtime-and-100-memory",
                "content": "```\\npublic Node connect(Node root) {\\n        if (root == null) return null;\\n        \\n        if (root.left != null) { // update left next\\n            if (root.right != null) root.left.next = root.right; // if right child exists - simple connect left.next to right\\n            else root.left.next = findNext(root); // if not - scan parent next node until we find the first left or right child\\n        }\\n        if (root.right != null) { // update right next\\n            root.right.next = findNext(root);\\n        }\\n        \\n        connect(root.right); // update the right nodes first\\n        connect(root.left);\\n        return root;\\n    }\\n    \\n    private Node findNext(Node root) { // get parent node\\n        while (root.next != null) { // scan all next parent nodes until we find the first left or right child\\n            root = root.next;\\n            if (root.left != null) return root.left;\\n            if (root.right != null) return root.right;\\n        }\\n        return null;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic Node connect(Node root) {\\n        if (root == null) return null;\\n        \\n        if (root.left != null) { // update left next\\n            if (root.right != null) root.left.next = root.right; // if right child exists - simple connect left.next to right\\n            else root.left.next = findNext(root); // if not - scan parent next node until we find the first left or right child\\n        }\\n        if (root.right != null) { // update right next\\n            root.right.next = findNext(root);\\n        }\\n        \\n        connect(root.right); // update the right nodes first\\n        connect(root.left);\\n        return root;\\n    }\\n    \\n    private Node findNext(Node root) { // get parent node\\n        while (root.next != null) { // scan all next parent nodes until we find the first left or right child\\n            root = root.next;\\n            if (root.left != null) return root.left;\\n            if (root.right != null) return root.right;\\n        }\\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38015,
                "title": "simple-40ms-c-o-n-o-1-solution-with-only-one-while-loop",
                "content": "Thanks for liji94188 for adding the explanation:\\n\\nIt's a BFS traversal. now pointer is the current level traveler and head is the left most element at next level and the tail is the right most element at next level till now. We move now pointer at current level and populate the the next-link at its children level. (Here the gist is we can move now to its next because this relationship was already populated in the previous round).\\n\\n    void connect(TreeLinkNode *root) {\\n        TreeLinkNode *now, *tail, *head;\\n        \\n        now = root;\\n        head = tail = NULL;\\n        while(now)\\n        {\\n            if (now->left)\\n                if (tail) tail = tail->next =now->left;\\n                else head = tail = now->left;\\n            if (now->right)\\n                if (tail) tail = tail->next =now->right;\\n                else head = tail = now->right;\\n            if(!(now = now->next))\\n            {\\n                now = head;\\n                head = tail=NULL;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "Thanks for liji94188 for adding the explanation:\\n\\nIt's a BFS traversal. now pointer is the current level traveler and head is the left most element at next level and the tail is the right most element at next level till now. We move now pointer at current level and populate the the next-link at its children level. (Here the gist is we can move now to its next because this relationship was already populated in the previous round).\\n\\n    void connect(TreeLinkNode *root) {\\n        TreeLinkNode *now, *tail, *head;\\n        \\n        now = root;\\n        head = tail = NULL;\\n        while(now)\\n        {\\n            if (now->left)\\n                if (tail) tail = tail->next =now->left;\\n                else head = tail = now->left;\\n            if (now->right)\\n                if (tail) tail = tail->next =now->right;\\n                else head = tail = now->right;\\n            if(!(now = now->next))\\n            {\\n                now = head;\\n                head = tail=NULL;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 172861,
                "title": "mostly-recursive-solution-o-n-time-beats-99-32-and-o-1-space-without-considering-stack",
                "content": "This has a helper recursive function, so maybe it\\'s not purely recursive, but all functions are recursive.\\n\\nOne tricky part is that, we have to make sure the right part of the tree is complete before tackling the left part, as when middle nodes are missing, we need completed next information on the right part of the tree for correctness.\\n\\n```\\nTreeLinkNode* fnext(TreeLinkNode* root) {\\n        if (root == NULL) return NULL;\\n        if (root->left) return root->left;  \\n        if (root->right) return root->right;\\n        return fnext(root->next);\\n    }\\n    \\n    void connect(TreeLinkNode *root) {\\n        if (root == NULL) return;\\n        if (root->left) {\\n            if (root->right) {\\n                root->left->next = root->right;\\n            } else {\\n                root->left->next = fnext(root->next);\\n            }\\n        }\\n        \\n        if (root->right) {\\n            root->right->next = fnext(root->next);\\n        }\\n        \\n        connect(root->right);\\n        connect(root->left);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTreeLinkNode* fnext(TreeLinkNode* root) {\\n        if (root == NULL) return NULL;\\n        if (root->left) return root->left;  \\n        if (root->right) return root->right;\\n        return fnext(root->next);\\n    }\\n    \\n    void connect(TreeLinkNode *root) {\\n        if (root == NULL) return;\\n        if (root->left) {\\n            if (root->right) {\\n                root->left->next = root->right;\\n            } else {\\n                root->left->next = fnext(root->next);\\n            }\\n        }\\n        \\n        if (root->right) {\\n            root->right->next = fnext(root->next);\\n        }\\n        \\n        connect(root->right);\\n        connect(root->left);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37826,
                "title": "concise-python-solution-9-lines-space-o-1",
                "content": "level by level traversal with a dummy head `prekid`. <br>\\nroot is in the current level, and kid is in the next level. `prekid.next` is the head in the kid level<br>\\n`kid = kid.next or kid` :  Update kid ONLY when we actually find its next node\\n<br><br>\\nruntime is around 96ms with a best runtime 88ms.\\n\\n\\n    def connect(self, root):\\n        prekid = kid = TreeLinkNode(0)\\n        while root:\\n            while root:\\n                kid.next = root.left\\n                kid = kid.next or kid\\n                kid.next = root.right\\n                kid = kid.next or kid\\n                root = root.next\\n            root, kid = prekid.next, prekid",
                "solutionTags": [
                    "Python"
                ],
                "code": "level by level traversal with a dummy head `prekid`. <br>\\nroot is in the current level, and kid is in the next level. `prekid.next` is the head in the kid level<br>\\n`kid = kid.next or kid` :  Update kid ONLY when we actually find its next node\\n<br><br>\\nruntime is around 96ms with a best runtime 88ms.\\n\\n\\n    def connect(self, root):\\n        prekid = kid = TreeLinkNode(0)\\n        while root:\\n            while root:\\n                kid.next = root.left\\n                kid = kid.next or kid\\n                kid.next = root.right\\n                kid = kid.next or kid\\n                root = root.next\\n            root, kid = prekid.next, prekid",
                "codeTag": "Python3"
            },
            {
                "id": 2033286,
                "title": "python-easy-bfs-and-o-1-space-with-explanation",
                "content": "1. ##### **Level Order Traversal Approach**\\nAs the problem states that the output should return a tree with all the nodes in the same level connected, the problem can be solved using **Level Order Traversal**.\\nEach iteration of Queue traversal, the code would:\\n1. Find the length of the current level of the tree. \\n2. Iterate through all the nodes in the same level using the level length. \\n3. Find the siblings in the next level and connect them using next pointers. Enqueue all the nodes in the next level.\\n\\n\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return None\\n        q = deque()\\n        q.append(root)\\n        dummy=Node(-999) # to initialize with a not null prev\\n        while q:\\n            length=len(q) # find level length\\n            \\n            prev=dummy\\n            for _ in range(length): # iterate through all nodes in the same level\\n                popped=q.popleft()\\n                if popped.left:\\n                    q.append(popped.left)\\n                    prev.next=popped.left\\n                    prev=prev.next\\n                if popped.right:\\n                    q.append(popped.right)\\n                    prev.next=popped.right\\n                    prev=prev.next                \\n                 \\n        return root\\n```\\n\\n\\n\\n**Time = O(N)** - iterate through all the nodes\\n**Space=O(L)** - As the code is using level order traversal, the maximum size of Queue is maximum number of nodes at any level.\\n\\n\\n\\n---\\n2. ##### **O(1) Space Approach**\\n\\nIn addition to this, there is a **follow-up question** asking to solve this problem using constant extra space. There is an additional hint to maybe use recursion for this and the extra call stack is assumed to be `O(1)` space\\n\\nThe code will track the `head` at each level and use that not null `head` to define the next iteration. Following is my take on `O(1)` space solution:\\n\\n\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return None\\n        \\n        curr=root\\n        dummy=Node(-999)        \\n        head=root        \\n\\n\\t\\twhile head:\\n            curr=head # initialize current level\\'s head\\n            prev=dummy # init prev for next level linked list traversal\\n\\t\\t\\t# iterate through the linked-list of the current level and connect all the siblings in the next level\\n            while curr:  \\n                if curr.left:\\n                    prev.next=curr.left\\n                    prev=prev.next\\n                if curr.right:\\n                    prev.next=curr.right\\n                    prev=prev.next                                                \\n                curr=curr.next\\n            head=dummy.next # update head to the linked list of next level\\n            dummy.next=None # reset dummy node\\n        return root\\n            \\n```\\n\\n**Time = O(N)** - iterate through all the nodes\\n**Space = O(1)** - No additional space\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return None\\n        q = deque()\\n        q.append(root)\\n        dummy=Node(-999) # to initialize with a not null prev\\n        while q:\\n            length=len(q) # find level length\\n            \\n            prev=dummy\\n            for _ in range(length): # iterate through all nodes in the same level\\n                popped=q.popleft()\\n                if popped.left:\\n                    q.append(popped.left)\\n                    prev.next=popped.left\\n                    prev=prev.next\\n                if popped.right:\\n                    q.append(popped.right)\\n                    prev.next=popped.right\\n                    prev=prev.next                \\n                 \\n        return root\\n```\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return None\\n        \\n        curr=root\\n        dummy=Node(-999)        \\n        head=root        \\n\\n\\t\\twhile head:\\n            curr=head # initialize current level\\'s head\\n            prev=dummy # init prev for next level linked list traversal\\n\\t\\t\\t# iterate through the linked-list of the current level and connect all the siblings in the next level\\n            while curr:  \\n                if curr.left:\\n                    prev.next=curr.left\\n                    prev=prev.next\\n                if curr.right:\\n                    prev.next=curr.right\\n                    prev=prev.next                                                \\n                curr=curr.next\\n            head=dummy.next # update head to the linked list of next level\\n            dummy.next=None # reset dummy node\\n        return root\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 962162,
                "title": "c-iterative-constant-space-solution-explained-100-time-75-space",
                "content": "My core intuition here was too follow a BFS-like approach, but without the heavy overhead of a queue and, well, in constant space.\\n\\nAt each iteration, what I need to know was what I was going to store in my 4 support variables:\\n* the first valid parent, initialised to `root` and going into `currParent`;\\n* the first child node, going into `baseChild`;\\n* the current child node, going into `currChild`;\\n* the next child I am going to work on, going into `nextChild`.\\n\\nNow, time to go for a main loop that will run as long as we have a `currentParent` (so `0` times with an empty tree and that gets an edge case out of the too) in which we:\\n* reset `baseChild` to `NULL`;\\n* make sure that `currentParent` has at least a child, moving on until we either find it or we reach the last of the node on its very same level - note that since we are either having `currentParent == root` or proceeding so that we already connected all the nodes on the previous level, we can be sure our loop invariant of having each parent layer fully connected for it to work is safe and sound;\\n* we set both `currChild` and `baseChild` to be either `currentParent->left` (if it exist) or `currentParent->right` (in any case, we can accept it as `NULL` as well, since it would mean we reached the last node in the `currentParent` layer and they were all childless: bingo - our job is done in that case!);\\n* we will then loop as long as we have a `currChild` (so, `0` times if we just finished parsing the last layer with nodes, see the bullet point above) and:\\n\\t* look for `nextChild`:\\n\\t\\t* taking the right child of `currentParent`, assuming it has one and `currChild` is not already it;\\n\\t\\t* looking for the it like this:\\n\\t\\t\\t* increasing `currParent` by one step to the right (since we know that we already milked its previous value of all its children nodes by now);\\n\\t\\t\\t* looping in a manner similar to the previous loop to advance `currParent`, but this time not stopping at the last one and going all the way (the first condition of the loop being `currParent` instead of `currParent->next`);\\n\\t\\t\\t* finally taking as `nextChild` either `currParent->left` or `currParent->right` if they exist or `currParent` itself, when it is `NULL` (and thus again terminating our inner loop and scansion of the current layer with it);\\n\\t* set `currChild->next` to be `nextChild`;\\n\\t* set itself to be `currChild` to be `nextChild;\\n* finally, we ready ourselves for the next loop, setting `currParent = baseChild`.\\n\\nOnce we are done, we can return `root` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        // support variables\\n        Node *currParent = root, *baseChild, *currChild, *nextChild;\\n        while (currParent) {\\n            // skipping childless parents - get a family - up to the last node\\n            while (currParent->next && !currParent->left && !currParent->right) currParent = currParent->next;\\n            // setting the new basechild, provided we have one at all\\n            currChild = baseChild = currParent->left ? currParent->left : currParent->right;\\n            while (currChild) {\\n                // getting nextChild - either the right sibling of currChild or...\\n                if (currParent->right && currChild != currParent->right) nextChild = currParent->right;\\n                // the child of a following parent\\n                else {\\n                    // moving to the nextParent, if any\\n                    currParent = currParent->next;\\n                    // moving parents, if we have too\\n                    while (currParent && !currParent->left && !currParent->right) currParent = currParent->next;\\n                    // setting nextChild to be the next left/right child, if any; NULL otherwise\\n                    nextChild = currParent ? currParent->left ? currParent->left : currParent->right : currParent;\\n                }\\n                currChild->next = nextChild;\\n                currChild = nextChild;\\n            }\\n            // preparing for the next loop\\n            currParent = baseChild;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        // support variables\\n        Node *currParent = root, *baseChild, *currChild, *nextChild;\\n        while (currParent) {\\n            // skipping childless parents - get a family - up to the last node\\n            while (currParent->next && !currParent->left && !currParent->right) currParent = currParent->next;\\n            // setting the new basechild, provided we have one at all\\n            currChild = baseChild = currParent->left ? currParent->left : currParent->right;\\n            while (currChild) {\\n                // getting nextChild - either the right sibling of currChild or...\\n                if (currParent->right && currChild != currParent->right) nextChild = currParent->right;\\n                // the child of a following parent\\n                else {\\n                    // moving to the nextParent, if any\\n                    currParent = currParent->next;\\n                    // moving parents, if we have too\\n                    while (currParent && !currParent->left && !currParent->right) currParent = currParent->next;\\n                    // setting nextChild to be the next left/right child, if any; NULL otherwise\\n                    nextChild = currParent ? currParent->left ? currParent->left : currParent->right : currParent;\\n                }\\n                currChild->next = nextChild;\\n                currChild = nextChild;\\n            }\\n            // preparing for the next loop\\n            currParent = baseChild;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37979,
                "title": "o-1-concise-fast-what-s-so-hard",
                "content": "This is definitely medium, not hard. Took me about 5 minutes, and some medium problems took me a few hours! Since you have to walk the tree in BFS order and you\\'re given extra references to help you do just that, it\\'s intuitive, it\\'s simple and it\\'s fast. The first level (root) is connected already, so you connect the next level and then you just walk through the linked list you\\'ve just created and so on.\\n\\n    public void connect(TreeLinkNode root) {\\n        for (TreeLinkNode head = root; head != null; ) {\\n            TreeLinkNode nextHead = new TreeLinkNode(0), nextTail = nextHead;\\n            for (TreeLinkNode node = head; node != null; node = node.next) {\\n                if (node.left != null) {\\n                    nextTail.next = node.left;\\n                    nextTail = node.left;\\n                }\\n                if (node.right != null) {\\n                    nextTail.next = node.right;\\n                    nextTail = node.right;\\n                }\\n            }\\n            head = nextHead.next;\\n        }\\n    }\\n\\nP. S. As it was mentioned several times in the comments, I decided to show the improved version as well. There is no need to allocate the sentinel node every time:\\n\\n    public void connect(TreeLinkNode root) {\\n        for (TreeLinkNode head = root, nextHead = new TreeLinkNode(0), nextTail; head != null; ) {\\n            (nextTail = nextHead).next = null;\\n            for (; head != null; head = head.next) {\\n                if (head.left != null) {\\n                    nextTail.next = head.left;\\n                    nextTail = head.left;\\n                }\\n                if (head.right != null) {\\n                    nextTail.next = head.right;\\n                    nextTail = head.right;\\n                }\\n            }\\n            head = nextHead.next;\\n        }\\n    }\\n\\nIt doesn\\'t show much in the submission, but I put it to a simple test: create a 10 million node tall tree with only one node per level, then connect it the previous way and the improved way. Initial tree creation took about 550\\u2013570 MB of RAM on my PC (running under Java 1.8.0_172 x64). Then, the first version takes about 100 MB more and runs for about 2 seconds. The improved version runs for about 0.1 seconds and takes no additional RAM (no big surprise here). Looks I overestimated GC and memory allocation optimization. I was almost sure it would just reuse the same memory again and again.",
                "solutionTags": [
                    "Java"
                ],
                "code": "This is definitely medium, not hard. Took me about 5 minutes, and some medium problems took me a few hours! Since you have to walk the tree in BFS order and you\\'re given extra references to help you do just that, it\\'s intuitive, it\\'s simple and it\\'s fast. The first level (root) is connected already, so you connect the next level and then you just walk through the linked list you\\'ve just created and so on.\\n\\n    public void connect(TreeLinkNode root) {\\n        for (TreeLinkNode head = root; head != null; ) {\\n            TreeLinkNode nextHead = new TreeLinkNode(0), nextTail = nextHead;\\n            for (TreeLinkNode node = head; node != null; node = node.next) {\\n                if (node.left != null) {\\n                    nextTail.next = node.left;\\n                    nextTail = node.left;\\n                }\\n                if (node.right != null) {\\n                    nextTail.next = node.right;\\n                    nextTail = node.right;\\n                }\\n            }\\n            head = nextHead.next;\\n        }\\n    }\\n\\nP. S. As it was mentioned several times in the comments, I decided to show the improved version as well. There is no need to allocate the sentinel node every time:\\n\\n    public void connect(TreeLinkNode root) {\\n        for (TreeLinkNode head = root, nextHead = new TreeLinkNode(0), nextTail; head != null; ) {\\n            (nextTail = nextHead).next = null;\\n            for (; head != null; head = head.next) {\\n                if (head.left != null) {\\n                    nextTail.next = head.left;\\n                    nextTail = head.left;\\n                }\\n                if (head.right != null) {\\n                    nextTail.next = head.right;\\n                    nextTail = head.right;\\n                }\\n            }\\n            head = nextHead.next;\\n        }\\n    }\\n\\nIt doesn\\'t show much in the submission, but I put it to a simple test: create a 10 million node tall tree with only one node per level, then connect it the previous way and the improved way. Initial tree creation took about 550\\u2013570 MB of RAM on my PC (running under Java 1.8.0_172 x64). Then, the first version takes about 100 MB more and runs for about 2 seconds. The improved version runs for about 0.1 seconds and takes no additional RAM (no big surprise here). Looks I overestimated GC and memory allocation optimization. I was almost sure it would just reuse the same memory again and again.",
                "codeTag": "Unknown"
            },
            {
                "id": 516735,
                "title": "python-2-solutions-bfs-iterative-o-1-in-space-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: BFS**\\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return root\\n        q = deque([root])\\n        while q:\\n            prev = None\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                if prev != None:\\n                    prev.next = cur\\n                prev = cur\\n                if cur.left != None:\\n                    q.append(cur.left)\\n                if cur.right != None:\\n                    q.append(cur.right)\\n        return root\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 6000` is the number of nodes in the binary tree.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Iterative - Link Nodes on the Current Level based on the Above Level**\\n![image](https://assets.leetcode.com/users/images/5aa822a3-9048-432d-a49b-5a8ed7a01216_1632839097.918606.png)\\n\\n```python\\nclass Solution:\\n    def linkNode(self, node):\\n        if node == None: return\\n        if self.leftMost == None:\\n            self.leftMost = node\\n            \\n        if self.prev != None:\\n            self.prev.next = node\\n        self.prev = node\\n    \\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n        self.leftMost = root\\n        while self.leftMost:\\n            head = self.leftMost\\n            self.leftMost = self.prev = None\\n            while head != None:  # Base on the above level\\n                self.linkNode(head.left)  # Try to link nodes on the current level \\n                self.linkNode(head.right)  # Try to link nodes on the current level \\n                head = head.next\\n        return root\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 6000` is the number of nodes in the binary tree.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return root\\n        q = deque([root])\\n        while q:\\n            prev = None\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                if prev != None:\\n                    prev.next = cur\\n                prev = cur\\n                if cur.left != None:\\n                    q.append(cur.left)\\n                if cur.right != None:\\n                    q.append(cur.right)\\n        return root\\n```\n```python\\nclass Solution:\\n    def linkNode(self, node):\\n        if node == None: return\\n        if self.leftMost == None:\\n            self.leftMost = node\\n            \\n        if self.prev != None:\\n            self.prev.next = node\\n        self.prev = node\\n    \\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n        self.leftMost = root\\n        while self.leftMost:\\n            head = self.leftMost\\n            self.leftMost = self.prev = None\\n            while head != None:  # Base on the above level\\n                self.linkNode(head.left)  # Try to link nodes on the current level \\n                self.linkNode(head.right)  # Try to link nodes on the current level \\n                head = head.next\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033718,
                "title": "c-binary-tree-super-simple-100-faster",
                "content": "**BFS: LEVEL ORDER TRAVERSAL**\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) \\n    {\\n        if (!root)\\n            return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while (q.size() > 1)\\n        {\\n            Node* curr = q.front();\\n            q.pop();\\n            if (!curr)\\n            {\\n                q.push(NULL);\\n                continue;\\n            }\\n            curr->next = q.front();\\n            if (curr->left)\\n                q.push(curr->left);\\n            if (curr->right)\\n                q.push(curr->right);\\n        }\\n        return root;\\n    }\\n};\\n```\\nHope you like it.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) \\n    {\\n        if (!root)\\n            return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while (q.size() > 1)\\n        {\\n            Node* curr = q.front();\\n            q.pop();\\n            if (!curr)\\n            {\\n                q.push(NULL);\\n                continue;\\n            }\\n            curr->next = q.front();\\n            if (curr->left)\\n                q.push(curr->left);\\n            if (curr->right)\\n                q.push(curr->right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521193,
                "title": "python-o-1-aux-space-dfs-sol-with-diagram",
                "content": "Python O(1) aux space DFS sol.\\n\\n---\\n\\n**Hint**:\\n\\nThink of DFS traversal.\\n\\n---\\n\\n**Algorithm**:\\n\\nFor each current node,\\n\\nStep_#1:\\nUse **scanner** to **locate the left-most neighbor, on same level**, in right hand side.\\n\\nStep_#2-1:\\nWhen right child exists, update right child\\'next as scanner\\n\\nStep_#2-2:\\nWhen left child exists, update left child\\'next as either right child (if right child exists ),or scanner.\\n\\n---\\n\\n**Abstract Model**:\\n\\n**Before** connection of next pointer:\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1582707452.png)\\n\\n\\n---\\n\\n**After** connection of next pointer:\\nBoth left child and right child exist\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1582707480.png)\\n\\n---\\n\\nOnly right child exists\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1582707907.png)\\n\\n\\n---\\n\\nOnly left child exists\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1582707917.png)\\n\\n\\n---\\n\\n**Implementation**:\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \\n        def helper( node: \\'Node\\'):\\n            \\n            if not node:\\n                return None\\n            \\n            scanner = node.next\\n\\n            # Scanner finds left-most neighbor, on same level, in right hand side\\n            while scanner:\\n\\n                if scanner.left:\\n                    scanner = scanner.left\\n                    break\\n\\n                if scanner.right:\\n                    scanner = scanner.right\\n                    break\\n\\n                scanner = scanner.next\\n\\n\\n            # connect right child if right child exists\\n            if node.right:\\n                node.right.next = scanner \\n\\n            # connect left child if left child exists\\n            if node.left:\\n                node.left.next = node.right if node.right else scanner\\n\\n\\n            # DFS down to next level\\n            helper( node.right )  \\n            helper( node.left )  \\n                \\n            return node\\n        # -------------------------------\\n        \\n        return helper( root ) \\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n( a special case of current challenge )\\n[Leetcode #116 Populating Next Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \\n        def helper( node: \\'Node\\'):\\n            \\n            if not node:\\n                return None\\n            \\n            scanner = node.next\\n\\n            # Scanner finds left-most neighbor, on same level, in right hand side\\n            while scanner:\\n\\n                if scanner.left:\\n                    scanner = scanner.left\\n                    break\\n\\n                if scanner.right:\\n                    scanner = scanner.right\\n                    break\\n\\n                scanner = scanner.next\\n\\n\\n            # connect right child if right child exists\\n            if node.right:\\n                node.right.next = scanner \\n\\n            # connect left child if left child exists\\n            if node.left:\\n                node.left.next = node.right if node.right else scanner\\n\\n\\n            # DFS down to next level\\n            helper( node.right )  \\n            helper( node.left )  \\n                \\n            return node\\n        # -------------------------------\\n        \\n        return helper( root ) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 389389,
                "title": "simply-simple-python-solutions-level-order-traversal-and-o-1-space-both-approach",
                "content": "### BFS: Level Order Traversal - simple approach:\\n```\\ndef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\tif not root:\\n            return root\\n        q = []\\n        \\n        q.append(root)\\n        \\n        tail = root\\n        while len(q) > 0:\\n            node = q.pop(0)\\n            if node.left:\\n                q.append(node.left)\\n            if node.right:\\n                q.append(node.right)\\n                \\n            if node == tail:\\n                node.next = None\\n                tail = q[-1] if len(q) > 0 else None\\n            else:\\n                node.next = q[0]\\n                \\n        return root\\n```\\n### O(1) Space approach:\\n```\\ndef connect(self, root: \\'Node\\') -> \\'Node\\':\\n        dummy = Node(-1, None, None, None)\\n        tmp = dummy\\n        res = root\\n        while root:\\n            while root:\\n                if root.left:\\n                    tmp.next = root.left\\n                    tmp = tmp.next\\n                if root.right:\\n                    tmp.next = root.right\\n                    tmp = tmp.next\\n                root = root.next\\n            root = dummy.next\\n            tmp = dummy\\n            dummy.next = None\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\tif not root:\\n            return root\\n        q = []\\n        \\n        q.append(root)\\n        \\n        tail = root\\n        while len(q) > 0:\\n            node = q.pop(0)\\n            if node.left:\\n                q.append(node.left)\\n            if node.right:\\n                q.append(node.right)\\n                \\n            if node == tail:\\n                node.next = None\\n                tail = q[-1] if len(q) > 0 else None\\n            else:\\n                node.next = q[0]\\n                \\n        return root\\n```\n```\\ndef connect(self, root: \\'Node\\') -> \\'Node\\':\\n        dummy = Node(-1, None, None, None)\\n        tmp = dummy\\n        res = root\\n        while root:\\n            while root:\\n                if root.left:\\n                    tmp.next = root.left\\n                    tmp = tmp.next\\n                if root.right:\\n                    tmp.next = root.right\\n                    tmp = tmp.next\\n                root = root.next\\n            root = dummy.next\\n            tmp = dummy\\n            dummy.next = None\\n            \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2167737,
                "title": "javascript-test-case-typeerror",
                "content": "Is the JavaScript test case for this broken?  I continue to get a TypeError.  Have tried copy/pasting other\\'s BFS code into the editor, have tried returning the root node on the very first line, have tried returning a new Node() on the very first line.\\n\\nThe code is:\\n\\n```\\nvar connect = function(root) {\\n    if (!root) return root;\\n    \\n    let queue = [root];\\n    let tempQueue = [];\\n        \\n    while(queue.length){\\n        let curr = queue.splice(0, 1)[0];\\n        let {left, right} = curr;\\n                \\n        if (left) tempQueue.push(left);\\n        if (right) tempQueue.push(right);\\n        \\n        if (queue.length === 0){\\n            curr.next = null;\\n            queue = tempQueue;\\n            tempQueue = [];\\n        }else{\\n            curr.next = queue[0];\\n        }\\n    }\\n    \\n    return root;\\n};\\n```\\n\\nThe error is:\\n\\n```\\nLine 109 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node\\n    Line 109: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 41: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar connect = function(root) {\\n    if (!root) return root;\\n    \\n    let queue = [root];\\n    let tempQueue = [];\\n        \\n    while(queue.length){\\n        let curr = queue.splice(0, 1)[0];\\n        let {left, right} = curr;\\n                \\n        if (left) tempQueue.push(left);\\n        if (right) tempQueue.push(right);\\n        \\n        if (queue.length === 0){\\n            curr.next = null;\\n            queue = tempQueue;\\n            tempQueue = [];\\n        }else{\\n            curr.next = queue[0];\\n        }\\n    }\\n    \\n    return root;\\n};\\n```\n```\\nLine 109 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node\\n    Line 109: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 41: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1195119,
                "title": "bfs-c-iterative-level-order-traversal",
                "content": "\\nIf you have solved [https://leetcode.com/problems/populating-next-right-pointers-in-each-node/] this question this is exactly same as this one except for one change.\\n\\nBasically this is purely level order travsersal code with slight modification for the  root -> next value \\n\\nYou just have to think 2 things in this question.\\n\\n1.How to get the last val to NULL ?.\\n2.How to get connect with the current node to previous one ?.\\n\\nIf you are able to find the ans of these two questions mentioned above then you will reach the solution \\nalso if you are here to see the solution i would recommend you to pause for a while \\nand think about these questions i am sure you willl find the ans otherwise ans \\nis just right below you can see anytime you want just give it a though for a whlle.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n```\\nif(root == NULL) return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size(); // get size of queue \\n            for(int i=0 ; i < size ; i++){\\n                Node* item = q.front(); \\n                if(size - 1 == i) // checking the last value of the level\\n                     item -> next = NULL; \\n                \\n                q.pop();\\n                \\n                if(size - 1 != i) // if this is not the last value then previous value will point to next one\\n                     item -> next = q.front(); \\n                \\n                if(item -> left != NULL)\\n                    q.push(item -> left);\\n                if(item -> right != NULL)\\n                    q.push(item -> right);\\n            }\\n        } \\n        return root;\\n\\t\\t\\n\\t\\t\\n\\t***************DO UPVOTE IF YOU LIKED THE SOLUTION.\\t****************\\n\\t\\t",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "\\nIf you have solved [https://leetcode.com/problems/populating-next-right-pointers-in-each-node/] this question this is exactly same as this one except for one change.\\n\\nBasically this is purely level order travsersal code with slight modification for the  root -> next value \\n\\nYou just have to think 2 things in this question.\\n\\n1.How to get the last val to NULL ?.\\n2.How to get connect with the current node to previous one ?.\\n\\nIf you are able to find the ans of these two questions mentioned above then you will reach the solution \\nalso if you are here to see the solution i would recommend you to pause for a while \\nand think about these questions i am sure you willl find the ans otherwise ans \\nis just right below you can see anytime you want just give it a though for a whlle.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n```\\nif(root == NULL) return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size(); // get size of queue \\n            for(int i=0 ; i < size ; i++){\\n                Node* item = q.front(); \\n                if(size - 1 == i) // checking the last value of the level\\n                     item -> next = NULL; \\n                \\n                q.pop();\\n                \\n                if(size - 1 != i) // if this is not the last value then previous value will point to next one\\n                     item -> next = q.front(); \\n                \\n                if(item -> left != NULL)\\n                    q.push(item -> left);\\n                if(item -> right != NULL)\\n                    q.push(item -> right);\\n            }\\n        } \\n        return root;\\n\\t\\t\\n\\t\\t\\n\\t***************DO UPVOTE IF YOU LIKED THE SOLUTION.\\t****************\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 37953,
                "title": "c-recursive-solution-easy-understanding",
                "content": "     void connect(TreeLinkNode *root) {\\n       if (!root) return;\\n        TreeLinkNode dummy(INT_MIN);\\n        for (TreeLinkNode *cur = root, *pre = &dummy; cur; cur = cur->next) {\\n            if (cur->left) {\\n                pre->next = cur->left;\\n                pre = pre->next;\\n            }\\n            if (cur->right) {\\n                pre->next = cur->right;\\n                pre = pre->next;\\n            }\\n        }\\n        connect(dummy.next);\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "     void connect(TreeLinkNode *root) {\\n       if (!root) return;\\n        TreeLinkNode dummy(INT_MIN);\\n        for (TreeLinkNode *cur = root, *pre = &dummy; cur; cur = cur->next) {\\n            if (cur->left) {\\n                pre->next = cur->left;\\n                pre = pre->next;\\n            }\\n            if (cur->right) {\\n                pre->next = cur->right;\\n                pre = pre->next;\\n            }\\n        }\\n        connect(dummy.next);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 38035,
                "title": "just-convert-common-bfs-solution-to-o-1-space-a-simple-python-code",
                "content": "common BFS\\n\\n    class Solution:\\n    # @param root, a tree link node\\n    # @return nothing\\n    def connect(self, root):\\n        if not root:\\n            return\\n        queue, level = collections.deque([root]), collections.deque()\\n        while queue:\\n            node = queue.popleft()\\n            if node.left:\\n                level.append(node.left)\\n            if node.right:\\n                level.append(node.right)\\n            node.next = queue[0] if queue else None\\n            if not queue and level:\\n                queue, level = level, queue\\n\\nO(1) space\\n\\n    class Solution:\\n    # @param root, a tree link node\\n    # @return nothing\\n    def connect(self, root):\\n        queue, level, curr = root, None, None\\n        while queue:\\n            if queue.left:\\n                if not level:\\n                    level = curr = queue.left\\n                else:\\n                    curr.next = queue.left\\n                    curr = curr.next\\n            if queue.right:\\n                if not level:\\n                    level = curr = queue.right\\n                else:\\n                    curr.next = queue.right\\n                    curr = curr.next\\n            queue = queue.next\\n            if not queue and level:\\n                queue, level, curr = level, None, None\\n\\nUse a fake head can save a few lines",
                "solutionTags": [],
                "code": "common BFS\\n\\n    class Solution:\\n    # @param root, a tree link node\\n    # @return nothing\\n    def connect(self, root):\\n        if not root:\\n            return\\n        queue, level = collections.deque([root]), collections.deque()\\n        while queue:\\n            node = queue.popleft()\\n            if node.left:\\n                level.append(node.left)\\n            if node.right:\\n                level.append(node.right)\\n            node.next = queue[0] if queue else None\\n            if not queue and level:\\n                queue, level = level, queue\\n\\nO(1) space\\n\\n    class Solution:\\n    # @param root, a tree link node\\n    # @return nothing\\n    def connect(self, root):\\n        queue, level, curr = root, None, None\\n        while queue:\\n            if queue.left:\\n                if not level:\\n                    level = curr = queue.left\\n                else:\\n                    curr.next = queue.left\\n                    curr = curr.next\\n            if queue.right:\\n                if not level:\\n                    level = curr = queue.right\\n                else:\\n                    curr.next = queue.right\\n                    curr = curr.next\\n            queue = queue.next\\n            if not queue and level:\\n                queue, level, curr = level, None, None\\n\\nUse a fake head can save a few lines",
                "codeTag": "Java"
            },
            {
                "id": 37877,
                "title": "o-1-space-o-n-time-java-solution",
                "content": "    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if(root == null) return;\\n            \\n            TreeLinkNode cur = root;\\n            while(cur != null){\\n                if(cur.left != null){\\n                    cur.left.next = (cur.right != null) ? cur.right : getNext(cur);\\n                }\\n                \\n                if(cur.right != null){\\n                    cur.right.next = getNext(cur);\\n                }\\n                \\n                cur = cur.next;\\n            }\\n            \\n            connect(root.left);\\n            connect(root.right);\\n        }\\n        \\n        private TreeLinkNode getNext(TreeLinkNode root){\\n            TreeLinkNode temp = root.next;\\n            \\n            while(temp != null){\\n                if(temp.left != null) return temp.left;\\n                if(temp.right != null) return temp.right;\\n                \\n                temp = temp.next;\\n            }\\n            \\n            return null;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if(root == null) return;\\n            \\n            TreeLinkNode cur = root;\\n            while(cur != null){\\n                if(cur.left != null){\\n                    cur.left.next = (cur.right != null) ? cur.right : getNext(cur);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2033511,
                "title": "3-approaches-bfs-bfs-linkedlist-recursion-code-commented",
                "content": "[Leetcode](https://leetcode.com/) [117. Populating Next Right Pointers in Each Node II](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/).\\n\\nHere shows **3** Approaches to slove this problem: BFS, BFS + LinkedList, Recursion.\\n\\n\\n# BFS\\n\\nUse BFS to **level** traversal, a List to store the Nodes of each level.\\n\\n```java\\n    public Node connect_bfs(Node root) {\\n        if (root == null) {\\n            return root;\\n        }\\n\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Node> levelNodes = new ArrayList<>();\\n            for (int i = 0; i < size; i++) {\\n                Node curNode = queue.poll();\\n                levelNodes.add(curNode);\\n                if (curNode.left != null) {\\n                    queue.add(curNode.left);\\n                }\\n                if (curNode.right != null) {\\n                    queue.add(curNode.right);\\n                }\\n            }\\n\\n            for (int i = 0; i < levelNodes.size() - 1; i++) {\\n                Node node = levelNodes.get(i);\\n                node.next = levelNodes.get(i + 1);\\n            }\\n        }\\n\\n        return root;\\n    }\\n```\\n\\nIn fact, we just need a Node to store the **Previous Node**.\\n\\n```java\\n    public Node connect_bfs(Node root) {\\n        if (root == null) {\\n            return root;\\n        }\\n\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            int levelCount = queue.size();\\n            Node prev = null;\\n            for (int i = 0; i < levelCount; i++) {\\n                Node curNode = queue.poll();\\n\\n                if (prev != null) {\\n                    prev.next = curNode;\\n                }\\n\\n                prev = curNode;\\n\\n                if (curNode.left != null) {\\n                    queue.add(curNode.left);\\n                }\\n                if (curNode.right != null) {\\n                    queue.add(curNode.right);\\n                }\\n            }\\n        }\\n\\n        return root;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$.\\n- **Space Complexity**: $O(n)$.\\n\\n\\n# BFS + LinkedList\\n\\nEach level can be seem as a Linked List. \\n\\nFor example, the root node is a linked list with one node, and the second level is a linked list with two nodes and so on...\\n\\n```java\\n    public Node connect_linkedlist(Node root) {\\n        if (root == null) {\\n            return root;\\n        }\\n\\n        // the curNode as the linkedlist of each level\\n        Node curNode = root;\\n        while (curNode != null) {\\n            // a dummyNode to travesal current Level\\n            Node dummyNode = new Node(0);\\n\\n            // the prev Node of next level\\n            Node prevNode = dummyNode;\\n            while (curNode != null) {\\n                if (curNode.left != null) {\\n                    // linked the left child\\n                    prevNode.next = curNode.left;\\n                    // update prev as LinkedList\\n                    prevNode = curNode.left;\\n                }\\n\\n                if (curNode.right != null) {\\n                    prevNode.next = curNode.right;\\n                    prevNode = curNode.right;\\n                }\\n\\n                // the next node of current level\\n                curNode = curNode.next;\\n            }\\n\\n            // after process the next level, process \\n            curNode = dummyNode.next;\\n        }\\n\\n        return root;\\n\\t}\\n```\\n\\nIn fact, we just need a Node to store the **Previous Node**.\\n\\n```java\\n    public static Node connect_bfs(Node root) {\\n        if (root == null) {\\n            return root;\\n        }\\n\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            int levelCount = queue.size();\\n            Node prev = null;\\n            for (int i = 0; i < levelCount; i++) {\\n                Node curNode = queue.poll();\\n\\n                if (prev != null) {\\n                    prev.next = curNode;\\n                }\\n\\n                prev = curNode;\\n\\n                if (curNode.left != null) {\\n                    queue.add(curNode.left);\\n                }\\n                if (curNode.right != null) {\\n                    queue.add(curNode.right);\\n                }\\n            }\\n        }\\n\\n        return root;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**:  $O(n)$.\\n- **Space Complexity**:  $O(1)$.\\n\\n# Recursion\\n\\nIt\\'s a little difficult but easy to get it.\\n\\n```java\\n    public Node connect(Node root) {\\n        if (root == null || (root.left == null && root.right == null)) {\\n            return root;\\n        }\\n\\n        if (root.left != null && root.right != null) {\\n            root.left.next = root.right;\\n            root.right.next = getNextHasChildrenNode(root);\\n        }\\n\\n        if (root.left == null) {\\n            root.right.next = getNextHasChildrenNode(root);\\n        }\\n\\n        if (root.right == null) {\\n            root.left.next = getNextHasChildrenNode(root);\\n        }\\n\\n        // right should first\\n        root.right = connect(root.right);\\n        root.left = connect(root.left);\\n\\n        return root;\\n    }\\n\\n    public Node getNextHasChildrenNode(Node root) {\\n        while (root.next != null) {\\n            if (root.next.left != null) {\\n                return root.next.left;\\n            }\\n            if (root.next.right != null) {\\n                return root.next.right;\\n            }\\n\\n            root = root.next;\\n        }\\n\\n        return null;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$.\\n- **Space Complexity**: $O(1)$.\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```java\\n    public Node connect_bfs(Node root) {\\n        if (root == null) {\\n            return root;\\n        }\\n\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Node> levelNodes = new ArrayList<>();\\n            for (int i = 0; i < size; i++) {\\n                Node curNode = queue.poll();\\n                levelNodes.add(curNode);\\n                if (curNode.left != null) {\\n                    queue.add(curNode.left);\\n                }\\n                if (curNode.right != null) {\\n                    queue.add(curNode.right);\\n                }\\n            }\\n\\n            for (int i = 0; i < levelNodes.size() - 1; i++) {\\n                Node node = levelNodes.get(i);\\n                node.next = levelNodes.get(i + 1);\\n            }\\n        }\\n\\n        return root;\\n    }\\n```\n```java\\n    public Node connect_bfs(Node root) {\\n        if (root == null) {\\n            return root;\\n        }\\n\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            int levelCount = queue.size();\\n            Node prev = null;\\n            for (int i = 0; i < levelCount; i++) {\\n                Node curNode = queue.poll();\\n\\n                if (prev != null) {\\n                    prev.next = curNode;\\n                }\\n\\n                prev = curNode;\\n\\n                if (curNode.left != null) {\\n                    queue.add(curNode.left);\\n                }\\n                if (curNode.right != null) {\\n                    queue.add(curNode.right);\\n                }\\n            }\\n        }\\n\\n        return root;\\n    }\\n```\n```java\\n    public Node connect_linkedlist(Node root) {\\n        if (root == null) {\\n            return root;\\n        }\\n\\n        // the curNode as the linkedlist of each level\\n        Node curNode = root;\\n        while (curNode != null) {\\n            // a dummyNode to travesal current Level\\n            Node dummyNode = new Node(0);\\n\\n            // the prev Node of next level\\n            Node prevNode = dummyNode;\\n            while (curNode != null) {\\n                if (curNode.left != null) {\\n                    // linked the left child\\n                    prevNode.next = curNode.left;\\n                    // update prev as LinkedList\\n                    prevNode = curNode.left;\\n                }\\n\\n                if (curNode.right != null) {\\n                    prevNode.next = curNode.right;\\n                    prevNode = curNode.right;\\n                }\\n\\n                // the next node of current level\\n                curNode = curNode.next;\\n            }\\n\\n            // after process the next level, process \\n            curNode = dummyNode.next;\\n        }\\n\\n        return root;\\n\\t}\\n```\n```java\\n    public static Node connect_bfs(Node root) {\\n        if (root == null) {\\n            return root;\\n        }\\n\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            int levelCount = queue.size();\\n            Node prev = null;\\n            for (int i = 0; i < levelCount; i++) {\\n                Node curNode = queue.poll();\\n\\n                if (prev != null) {\\n                    prev.next = curNode;\\n                }\\n\\n                prev = curNode;\\n\\n                if (curNode.left != null) {\\n                    queue.add(curNode.left);\\n                }\\n                if (curNode.right != null) {\\n                    queue.add(curNode.right);\\n                }\\n            }\\n        }\\n\\n        return root;\\n    }\\n```\n```java\\n    public Node connect(Node root) {\\n        if (root == null || (root.left == null && root.right == null)) {\\n            return root;\\n        }\\n\\n        if (root.left != null && root.right != null) {\\n            root.left.next = root.right;\\n            root.right.next = getNextHasChildrenNode(root);\\n        }\\n\\n        if (root.left == null) {\\n            root.right.next = getNextHasChildrenNode(root);\\n        }\\n\\n        if (root.right == null) {\\n            root.left.next = getNextHasChildrenNode(root);\\n        }\\n\\n        // right should first\\n        root.right = connect(root.right);\\n        root.left = connect(root.left);\\n\\n        return root;\\n    }\\n\\n    public Node getNextHasChildrenNode(Node root) {\\n        while (root.next != null) {\\n            if (root.next.left != null) {\\n                return root.next.left;\\n            }\\n            if (root.next.right != null) {\\n                return root.next.right;\\n            }\\n\\n            root = root.next;\\n        }\\n\\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1656680,
                "title": "c-dfs-preorder-right-recursive-easy-understanding",
                "content": "Using a **preorder  recursive DFS** approach, you can easily solve this. The idea behind this recursive implementation is that at a given node, you have 3 possible situations:\\n\\n1. **Current node has 2 childs:**\\nset the next node of the left child to point to the right child and set right child next to point to the root\\u2014 i.e current \\u2014node next leftmost descendant.\\n\\n2. **Current node has right child:**\\nset right child next to point to the root\\u2014 i.e current \\u2014node next leftmost descendant.\\n\\n3. **Current node has left child:**\\nset left child next to point to the root\\u2014 i.e current \\u2014node next leftmost descendant.\\n\\nIn any of the cases, we don\\'t care if the next leftmost descendant is `NULL`.\\n\\nThe reason for the **right-recursive** and not **left-recursive** approach is that the right-recursive approach will fix the right sub-tree first as you may want to traverse the next pointers from left to right when doing left recursions. Given the following test case\\n\\n![image](https://assets.leetcode.com/users/images/70cb7826-baeb-49d8-9e2a-2c91826baa62_1640951563.0520065.png)\\n\\nYou can findout the reason the left-recursive approach fails to get the right answer when setting the next to node `0`. The next to `0` should be node `8` which is the next leftmost child to node `7`. Having the right sub-tree not fixed, it\\'s impossible to reach node `8` from node `7`. Hence, the next to node `0` will be `NULL`. If the righ sub-tree is already fixed and there is a next pointer from node `9 -> 1`, you can reach `8` with the path `7 -> 9 -> 1 -> 8` as shown here: \\n\\n![image](https://assets.leetcode.com/users/images/0c5d290c-ea56-48b0-b4d7-bb2d20bdd7da_1640951497.2875855.png)\\n\\n```\\n\\n    Node* get_next_leftmost(Node* node) {\\n        Node* next = node->next;\\n\\t\\t// If the next node have a left child return it,\\n\\t\\t// if no left child, check the right child\\n\\t\\t// otherwise, do the same for the next node until you find one or return NULL.\\n        while(next != NULL) {\\n            if (next->left != NULL) return next->left;\\n            if (next->right != NULL) return next->right;\\n            next = next->next;\\n        }\\n        return NULL;\\n    }\\n    \\n    Node* connect(Node* root) {\\n        if (root == NULL) return NULL;\\n        \\n\\t\\t// get the next leftmost child for the current node if any.\\n        Node* next_leftmost = get_next_leftmost(root);\\n\\t\\t\\n\\t\\t// if there is a left and right childs, set the left next to the right child\\n\\t\\t// if there is a left and no right child, set the left to the next_leftmost\\n        if (root->left) root->left->next = root->right ? root->right : next_leftmost;\\n\\t\\t\\n\\t\\t// if there is a right child, then set the right child next to the next_leftmost.\\n        if (root->right) root->right->next = next_leftmost;\\n\\n\\t\\t// Solve the right subtree first.\\n        connect(root->right);\\n\\t\\t\\n\\t\\t// Solve the left subtree next\\n        connect(root->left);\\n        \\n\\t\\t// not useful in this implementation\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n    Node* get_next_leftmost(Node* node) {\\n        Node* next = node->next;\\n\\t\\t// If the next node have a left child return it,\\n\\t\\t// if no left child, check the right child\\n\\t\\t// otherwise, do the same for the next node until you find one or return NULL.\\n        while(next != NULL) {\\n            if (next->left != NULL) return next->left;\\n            if (next->right != NULL) return next->right;\\n            next = next->next;\\n        }\\n        return NULL;\\n    }\\n    \\n    Node* connect(Node* root) {\\n        if (root == NULL) return NULL;\\n        \\n\\t\\t// get the next leftmost child for the current node if any.\\n        Node* next_leftmost = get_next_leftmost(root);\\n\\t\\t\\n\\t\\t// if there is a left and right childs, set the left next to the right child\\n\\t\\t// if there is a left and no right child, set the left to the next_leftmost\\n        if (root->left) root->left->next = root->right ? root->right : next_leftmost;\\n\\t\\t\\n\\t\\t// if there is a right child, then set the right child next to the next_leftmost.\\n        if (root->right) root->right->next = next_leftmost;\\n\\n\\t\\t// Solve the right subtree first.\\n        connect(root->right);\\n\\t\\t\\n\\t\\t// Solve the left subtree next\\n        connect(root->left);\\n        \\n\\t\\t// not useful in this implementation\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 182343,
                "title": "concise-14-line-of-c-using-bfs-and-constant-space",
                "content": "\\t// BFS. Use dummy head node.\\n\\tvoid connect(TreeLinkNode *root) {\\n\\t\\tTreeLinkNode *dummyHead = new TreeLinkNode(0);\\n\\t\\twhile (root) {\\n\\t\\t\\tTreeLinkNode *cur = dummyHead;\\n\\t\\t\\tdummyHead->next = nullptr;\\n\\t\\t\\twhile (root) {\\n\\t\\t\\t\\tif (root->left)\\n\\t\\t\\t\\t\\tcur = cur->next = root->left;\\n\\t\\t\\t\\tif (root->right)\\n\\t\\t\\t\\t\\tcur = cur->next = root->right;\\n\\t\\t\\t\\troot = root->next;\\n\\t\\t\\t}\\n\\t\\t\\troot = dummyHead->next;\\n\\t\\t}\\n\\t\\tdelete dummyHead;\\n\\t}",
                "solutionTags": [],
                "code": "\\t// BFS. Use dummy head node.\\n\\tvoid connect(TreeLinkNode *root) {\\n\\t\\tTreeLinkNode *dummyHead = new TreeLinkNode(0);\\n\\t\\twhile (root) {\\n\\t\\t\\tTreeLinkNode *cur = dummyHead;\\n\\t\\t\\tdummyHead->next = nullptr;\\n\\t\\t\\twhile (root) {\\n\\t\\t\\t\\tif (root->left)\\n\\t\\t\\t\\t\\tcur = cur->next = root->left;\\n\\t\\t\\t\\tif (root->right)\\n\\t\\t\\t\\t\\tcur = cur->next = root->right;\\n\\t\\t\\t\\troot = root->next;\\n\\t\\t\\t}\\n\\t\\t\\troot = dummyHead->next;\\n\\t\\t}\\n\\t\\tdelete dummyHead;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1734023,
                "title": "c-easy-and-clean-code-8ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root)return root;\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int x=q.size();\\n            while(x--){\\n                Node* s=q.front();\\n                q.pop();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t/* If s is the rightmost node of current level, set next pointer to NULL */\\n                if(x==0)s->next=NULL;\\n                else s->next=q.front();\\n\\t\\t\\t\\t\\n                if(s->left)q.push(s->left);\\n                if(s->right)q.push(s->right);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root)return root;\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int x=q.size();\\n            while(x--){\\n                Node* s=q.front();\\n                q.pop();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t/* If s is the rightmost node of current level, set next pointer to NULL */\\n                if(x==0)s->next=NULL;\\n                else s->next=q.front();\\n\\t\\t\\t\\t\\n                if(s->left)q.push(s->left);\\n                if(s->right)q.push(s->right);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962414,
                "title": "c-recursion-iteration-with-comments-and-figure-illustration",
                "content": "Idea:\\nI strongly recommend Solution 4, which is based on the classical pair operation between anchor point(fixed node) and cursor point(scan node).\\nI use Example 1 as illustration for their initilization\\n\\n![image](https://assets.leetcode.com/users/images/303151e8-c01e-48f1-b52b-bd7c6371ec30_1607286021.8233683.png)\\n\\n\\n\\n\\nSolution 1: DFS\\n```\\nclass Solution { // DFS: reversed pre-order: root, root->right, root->left\\npublic: // Time/Space: O(N); O(N)\\n    Node* connect(Node* root) {\\n        if (!root) return NULL;\\n        Node *p = root->next;\\n        while (p) { // find the left-most child of my first right-hand sibling\\n            if (p->left) {\\n                p = p->left;\\n                break;\\n            }\\n            if (p->right) {\\n                p = p->right;\\n                break;\\n            }            \\n            p = p->next;\\n        }\\n        if (root->right) root->right->next = p; \\n        if (root->left) root->left->next = root->right ? root->right : p; \\n        connect(root->right);\\n        connect(root->left);\\n        return root;\\n    }\\n};\\n```\\n\\n\\nSolution 2:\\n```\\nclass Solution { // BFS:\\npublic: // Time/Space: O(N); O(N)\\n    Node* connect(Node* root) {\\n        if(!root) return NULL;\\n        queue<Node* > q{{root}};\\n        while(!q.empty()){            \\n            for(int i = 0, n = q.size(); i < n; i++){ // scan tree topdown, level by level\\n                auto cur = q.front(); q.pop();\\n                if(i < n - 1) cur->next = q.front(); \\n                if(cur->left) q.push(cur->left);\\n                if(cur->right) q.push(cur->right);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\nSolution 3:  Iteration\\n```\\nclass Solution { // Iteration\\npublic: // Time/Space: O(N); O(1)\\n    Node* connect(Node* root) {\\n        Node *dummy = new Node(0, NULL, NULL, NULL), *cur = dummy, *head = root;\\n        while (root) {\\n            for (auto i: {root->left, root->right}) \\n                if(i){\\n                    cur->next = i;\\n                    cur = cur->next;\\n                }\\n            \\n            root = root->next;\\n            if (!root) {\\n                cur = dummy;\\n                root = dummy->next;\\n                dummy->next = NULL;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\nSoultion 4:  compact coding of Solution 3\\n(I tried my best to express the following idea with English by commenting the code)\\n\\u8FD9\\u4E2A\\u89E3\\u6CD5\\u4E5F\\u662F\\u7528\\u7684\\u5C42\\u5E8F\\u904D\\u5386\\uFF0C\\u53EA\\u4E0D\\u8FC7\\u6CA1\\u6709\\u4F7F\\u7528queue\\u4E86\\uFF0C\\u6211\\u4EEC\\u5EFA\\u7ACB\\u4E00\\u4E2Adummy\\u7ED3\\u70B9\\u6765\\u6307\\u5411\\u6BCF\\u5C42\\u7684\\u9996\\u7ED3\\u70B9\\u7684\\u524D\\u4E00\\u4E2A\\u7ED3\\u70B9\\uFF0C\\u7136\\u540E\\u6307\\u9488cur\\u7528\\u6765\\u904D\\u5386\\u8FD9\\u4E00\\u5C42\\uFF0C\\u6211\\u4EEC\\u5B9E\\u9645\\u4E0A\\u662F\\u904D\\u5386\\u4E00\\u5C42\\uFF0C\\u7136\\u540E\\u8FDE\\u4E0B\\u4E00\\u5C42\\u7684next\\uFF0C\\u9996\\u5148\\u4ECE\\u6839\\u7ED3\\u70B9\\u5F00\\u59CB\\uFF0C\\u5982\\u679C\\u5DE6\\u5B50\\u7ED3\\u70B9\\u5B58\\u5728\\uFF0C\\u90A3\\u4E48cur\\u7684next\\u8FDE\\u4E0A\\u5DE6\\u5B50\\u7ED3\\u70B9\\uFF0C\\u7136\\u540Ecur\\u6307\\u5411\\u5176next\\u6307\\u9488\\uFF1B\\u5982\\u679Croot\\u7684\\u53F3\\u5B50\\u7ED3\\u70B9\\u5B58\\u5728\\uFF0C\\u90A3\\u4E48cur\\u7684next\\u8FDE\\u4E0A\\u53F3\\u5B50\\u7ED3\\u70B9\\uFF0C\\u7136\\u540Ecur\\u6307\\u5411\\u5176next\\u6307\\u9488\\u3002\\u6B64\\u65F6root\\u7684\\u5DE6\\u53F3\\u5B50\\u7ED3\\u70B9\\u90FD\\u8FDE\\u4E0A\\u4E86\\uFF0C\\u6B64\\u65F6root\\u5411\\u53F3\\u5E73\\u79FB\\u4E00\\u4F4D\\uFF0C\\u6307\\u5411\\u5176next\\u6307\\u9488\\uFF0C\\u5982\\u679C\\u6B64\\u65F6root\\u4E0D\\u5B58\\u5728\\u4E86\\uFF0C\\u8BF4\\u660E\\u5F53\\u524D\\u5C42\\u5DF2\\u7ECF\\u904D\\u5386\\u5B8C\\u4E86\\uFF0C\\u6211\\u4EEC\\u91CD\\u7F6Ecur\\u4E3Adummy\\u7ED3\\u70B9\\uFF0Croot\\u6B64\\u65F6\\u4E3Adummy->next\\uFF0C\\u5373\\u4E0B\\u4E00\\u5C42\\u7684\\u9996\\u7ED3\\u70B9\\uFF0C\\u7136\\u540Edummy\\u7684next\\u6307\\u9488\\u6E05\\u7A7A\\uFF0C\\u6216\\u8005\\u4E5F\\u53EF\\u4EE5\\u5C06cur\\u7684next\\u6307\\u9488\\u6E05\\u7A7A\\uFF0C\\u56E0\\u4E3A\\u524D\\u9762\\u5DF2\\u7ECF\\u5C06cur\\u8D4B\\u503C\\u4E3Adummy\\u4E86\\u3002\\u90A3\\u4E48\\u73B0\\u5728\\u60F3\\u4E00\\u60F3\\uFF0C\\u4E3A\\u4EC0\\u4E48\\u8981\\u6E05\\u7A7A\\uFF1F\\u56E0\\u4E3A\\u6211\\u4EEC\\u7528dummy\\u7684\\u76EE\\u7684\\u5C31\\u662F\\u8981\\u6307\\u5230\\u4E0B\\u4E00\\u884C\\u7684\\u9996\\u7ED3\\u70B9\\u7684\\u4F4D\\u7F6E\\u5373dummy->next\\uFF0C\\u800C\\u4E00\\u65E6\\u5C06root\\u8D4B\\u503C\\u4E3Adummy->next\\u4E86\\u4E4B\\u540E\\uFF0C\\u8FD9\\u4E2Adummy\\u7684\\u4F7F\\u547D\\u5C31\\u5DF2\\u7ECF\\u5B8C\\u6210\\u4E86\\uFF0C\\u5FC5\\u987B\\u8981\\u65AD\\u5F00\\uFF0C\\u5982\\u679C\\u4E0D\\u65AD\\u5F00\\u7684\\u8BDD\\uFF0C\\u90A3\\u4E48\\u5047\\u8BBE\\u73B0\\u5728root\\u662F\\u53F6\\u7ED3\\u70B9\\u4E86\\uFF0C\\u90A3\\u4E48while\\u5FAA\\u73AF\\u8FD8\\u4F1A\\u6267\\u884C\\uFF0C\\u4E0D\\u4F1A\\u8FDB\\u5165\\u524D\\u4E24\\u4E2Aif\\uFF0C\\u7136\\u540Eroot\\u53F3\\u79FB\\u8D4B\\u7A7A\\u4E4B\\u540E\\uFF0C\\u4F1A\\u8FDB\\u5165\\u6700\\u540E\\u4E00\\u4E2Aif\\uFF0C\\u4E4B\\u524D\\u6CA1\\u6709\\u65AD\\u5F00dummy->next\\u7684\\u8BDD\\uFF0C\\u90A3\\u4E48root\\u53C8\\u6307\\u5411\\u4E4B\\u524D\\u7684\\u53F6\\u7ED3\\u70B9\\u4E86\\uFF0C\\u6B7B\\u5FAA\\u73AF\\u8BDE\\u751F\\u4E86\\uFF0C\\u8DEA\\u4E86\\u3002\\u6240\\u4EE5\\u4E00\\u5B9A\\u8981\\u8BB0\\u5F97\\u6E05\\u7A7A\\u54E6\\uFF0C\\u5475\\u5475\\u54D2\\uFF5E\\n\\n\\u8FD9\\u91CC\\u518D\\u6765\\u8BF4\\u4E0Bdummy\\u7ED3\\u70B9\\u662F\\u600E\\u6837\\u6307\\u5411\\u6BCF\\u5C42\\u7684\\u9996\\u7ED3\\u70B9\\u7684\\u524D\\u4E00\\u4E2A\\u7ED3\\u70B9\\u7684\\uFF0C\\u8FC7\\u7A0B\\u662F\\u8FD9\\u6837\\u7684\\uFF0Cdummy\\u662F\\u521B\\u5EFA\\u51FA\\u6765\\u7684\\u4E00\\u4E2A\\u65B0\\u7684\\u7ED3\\u70B9\\uFF0C\\u5176\\u76EE\\u7684\\u662F\\u4E3A\\u4E86\\u6307\\u5411root\\u7ED3\\u70B9\\u7684\\u4E0B\\u4E00\\u5C42\\u7684\\u9996\\u7ED3\\u70B9\\u7684\\u524D\\u4E00\\u4E2A\\uFF0C\\u5177\\u4F53\\u662F\\u8FD9\\u4E48\\u505A\\u5230\\u7684\\u5462\\uFF0C\\u4E3B\\u8981\\u662F\\u9760cur\\u6307\\u9488\\uFF0C\\u9996\\u5148cur\\u6307\\u5411dummy\\uFF0C\\u7136\\u540Ecur\\u518D\\u8FDE\\u4E0Aroot\\u4E0B\\u4E00\\u5C42\\u7684\\u9996\\u7ED3\\u70B9\\uFF0C\\u8FD9\\u6837dummy\\u4E5F\\u5C31\\u8FDE\\u4E0A\\u4E86\\u3002\\u7136\\u540E\\u5F53root\\u5C42\\u904D\\u5386\\u5B8C\\u4E86\\u4E4B\\u540E\\uFF0Croot\\u9700\\u8981\\u5F80\\u4E0B\\u79FB\\u52A8\\u4E00\\u5C42\\uFF0C\\u8FD9\\u6837dummy\\u7ED3\\u70B9\\u4E4B\\u540E\\u8FDE\\u63A5\\u7684\\u4F4D\\u7F6E\\u5C31\\u6B63\\u597D\\u8D4B\\u503C\\u7ED9root\\uFF0C\\u7136\\u540Ecur\\u518D\\u6307\\u5411dummy\\uFF0Cdummy\\u4E4B\\u540E\\u65AD\\u5F00\\uFF0C\\u8FD9\\u6837\\u53C8\\u56DE\\u5230\\u4E86\\u521D\\u59CB\\u72B6\\u6001\\uFF0C\\u4EE5\\u6B64\\u5F80\\u590D\\u5C31\\u53EF\\u4EE5\\u90FD\\u8FDE\\u4E0A\\u4E86\\uFF0C\\u4EE3\\u7801\\u5982\\u4E0B\\uFF1A\\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node *dummy = new Node(0, NULL, NULL, NULL), *cur = dummy, *head = root;\\n        while (root) {\\n            for (auto i: {root->left, root->right}) // handel left, rigt child in order by moving cur cursor.\\n                if(i) cur = cur->next = i;            \\n            \\n            root = root->next;\\n            if (!root) {//NULL value means scannning of current level is done. \\n                        //Reset cur as dummy\\uFF0Croot as dummy->next\\uFF0Cwhich is first node of next level\\n                cur = dummy;\\n                root = dummy->next;\\n                //if(dummy->next) cout<< dummy->next->val << endl; // this will print first node of each coming level\\n                dummy->next = NULL; // delink dummy since its duty of marking position is accomplished. Plus, it is also a must to avoid dead-loop\\n            }\\n        }\\n        return head;\\n    }\\n};\\n\\n```\\n\\u5F3A\\u70C8\\u5EFA\\u8BAE\\u5927\\u5BB6\\u638C\\u63E1\\u8FD9\\u4E2Afollow-up\\u7684\\u89E3\\u6CD5\\u3002 \\u6D89\\u53CA\\uFF1A \\u6307\\u9488\\u904D\\u5386\\u91CC\\u9762\\u7684 \\u201C\\u6210\\u5BF9\\u64CD\\u4F5C\\u201D\\uFF1A \\u951A\\u5B9A/\\u8D77\\u70B9(dummy)    +    \\u968F\\u6CE2\\u9010\\u6D41/\\u6307\\u9488\\u626B\\u63CF(cur)  \\u57FA\\u672C\\u64CD\\u4F5C\\u3002\\nReference:\\nhttps://www.cnblogs.com/grandyang/p/4290148.html\\n",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution { // DFS: reversed pre-order: root, root->right, root->left\\npublic: // Time/Space: O(N); O(N)\\n    Node* connect(Node* root) {\\n        if (!root) return NULL;\\n        Node *p = root->next;\\n        while (p) { // find the left-most child of my first right-hand sibling\\n            if (p->left) {\\n                p = p->left;\\n                break;\\n            }\\n            if (p->right) {\\n                p = p->right;\\n                break;\\n            }            \\n            p = p->next;\\n        }\\n        if (root->right) root->right->next = p; \\n        if (root->left) root->left->next = root->right ? root->right : p; \\n        connect(root->right);\\n        connect(root->left);\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution { // BFS:\\npublic: // Time/Space: O(N); O(N)\\n    Node* connect(Node* root) {\\n        if(!root) return NULL;\\n        queue<Node* > q{{root}};\\n        while(!q.empty()){            \\n            for(int i = 0, n = q.size(); i < n; i++){ // scan tree topdown, level by level\\n                auto cur = q.front(); q.pop();\\n                if(i < n - 1) cur->next = q.front(); \\n                if(cur->left) q.push(cur->left);\\n                if(cur->right) q.push(cur->right);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution { // Iteration\\npublic: // Time/Space: O(N); O(1)\\n    Node* connect(Node* root) {\\n        Node *dummy = new Node(0, NULL, NULL, NULL), *cur = dummy, *head = root;\\n        while (root) {\\n            for (auto i: {root->left, root->right}) \\n                if(i){\\n                    cur->next = i;\\n                    cur = cur->next;\\n                }\\n            \\n            root = root->next;\\n            if (!root) {\\n                cur = dummy;\\n                root = dummy->next;\\n                dummy->next = NULL;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node *dummy = new Node(0, NULL, NULL, NULL), *cur = dummy, *head = root;\\n        while (root) {\\n            for (auto i: {root->left, root->right}) // handel left, rigt child in order by moving cur cursor.\\n                if(i) cur = cur->next = i;            \\n            \\n            root = root->next;\\n            if (!root) {//NULL value means scannning of current level is done. \\n                        //Reset cur as dummy\\uFF0Croot as dummy->next\\uFF0Cwhich is first node of next level\\n                cur = dummy;\\n                root = dummy->next;\\n                //if(dummy->next) cout<< dummy->next->val << endl; // this will print first node of each coming level\\n                dummy->next = NULL; // delink dummy since its duty of marking position is accomplished. Plus, it is also a must to avoid dead-loop\\n            }\\n        }\\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 170523,
                "title": "simple-c-level-order-traversal",
                "content": "Traverse Tree in level order and set  next pointer for node which is popped as the front node of the queue or NULL if it is last node.\\n\\n```\\nvoid connect(TreeLinkNode *root) {\\n        if (!root)\\n            return;\\n        queue<TreeLinkNode*> q;\\n        q.push(root);\\n        TreeLinkNode *lastNode = root;\\n        while (!q.empty()) {\\n            TreeLinkNode *tmp = q.front();\\n            q.pop();\\n            if (tmp -> left)\\n                q.push(tmp -> left);\\n            if (tmp -> right)\\n                q.push(tmp -> right);\\n            if (tmp == lastNode) {\\n                tmp -> next = NULL;\\n                lastNode = q.back();\\n            } else {\\n                tmp -> next = q.front();\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid connect(TreeLinkNode *root) {\\n        if (!root)\\n            return;\\n        queue<TreeLinkNode*> q;\\n        q.push(root);\\n        TreeLinkNode *lastNode = root;\\n        while (!q.empty()) {\\n            TreeLinkNode *tmp = q.front();\\n            q.pop();\\n            if (tmp -> left)\\n                q.push(tmp -> left);\\n            if (tmp -> right)\\n                q.push(tmp -> right);\\n            if (tmp == lastNode) {\\n                tmp -> next = NULL;\\n                lastNode = q.back();\\n            } else {\\n                tmp -> next = q.front();\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38013,
                "title": "python-easy-to-understand-solution-similar-to-level-order-traversal",
                "content": "```\\nclass Solution(object):\\n    def connect(self, root):\\n        deque = collections.deque()\\n        if root:\\n            deque.append(root)\\n        while deque:\\n            size = len(deque)\\n            for i in range(size):\\n                l = deque.popleft()\\n                if i != size-1: # last node in each level has no next\\n                    l.next = deque[0]\\n                if l.left:\\n                    deque.append(l.left)\\n                if l.right:\\n                    deque.append(l.right)\\n        return root\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def connect(self, root):\\n        deque = collections.deque()\\n        if root:\\n            deque.append(root)\\n        while deque:\\n            size = len(deque)\\n            for i in range(size):\\n                l = deque.popleft()\\n                if i != size-1: # last node in each level has no next\\n                    l.next = deque[0]\\n                if l.left:\\n                    deque.append(l.left)\\n                if l.right:\\n                    deque.append(l.right)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707901,
                "title": "easy-to-understand-with-explanation-o-1-space-solution-cpp",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Explanation\\n\\n**Dummy *--next->*   root->left   ***--next->*** root->right->null**\\n\\nConsider the following binary tree:\\n\\n```\\n        1\\n       / \\\\\\n      2   3\\n     / \\\\   \\\\\\n    4   5   7\\n```\\n We start with the root node 1 as the levelStart.\\n\\n In the first iteration, we process Level 1. The curr pointer starts at the levelStart node, which is 1. We create a dummy node to represent the start of Level 2.\\n\\n```\\nLevel 1:\\n   1 -> NULL\\nDummy: [ ]\\n```\\nWe move curr from left to right, and for each node, we check if it has left and right children. If it does, we update the prev->next pointer accordingly.\\n\\n```\\nLevel 1:\\n   1 -> NULL\\n\\nDummy: [ ]\\n\\nLevel 2:\\n   2 -> 3 -> NULL\\n```\\nAfter processing all nodes at Level 1, we set levelStart to the next pointer of the dummy node, which is 2.\\n\\nIn the next iteration, we process Level 2. The curr pointer starts at the levelStart node, which is 2. We create a new dummy node to represent the start of Level 3.\\n\\n```\\nLevel 1:\\n   1 -> NULL\\n\\nDummy: [ ]\\n\\nLevel 2:\\n   2 -> 3 -> NULL\\n\\nDummy: [ ]\\n```\\nSimilar to before, we move curr from left to right, updating prev->next pointers as needed.\\n```\\n\\nLevel 1:\\n   1 -> NULL\\n\\nDummy: [ ]\\n\\nLevel 2:\\n   2 -> 3 -> NULL\\n\\nDummy: [ ]\\n\\nLevel 3:\\n   4 -> 5 -> 7 -> NULL\\n```\\nAfter processing all nodes at Level 2, we set levelStart to the next pointer of the dummy node, which is 4.\\n\\nIn the next iteration, we process Level 3. The curr pointer starts at the levelStart node, which is 4. We create a new dummy node to represent the start of the next level, but since there are no more levels, this dummy node will be discarded.\\n\\n```\\nLevel 1:\\n   1 -> NULL\\n\\nDummy: [ ]\\n\\nLevel 2:\\n   2 -> 3 -> NULL\\n\\nDummy: [ ]\\n\\nLevel 3:\\n   4 -> 5 -> 7 -> NULL\\n\\nDummy: [ ]\\n```\\nWe move curr from left to right, but since there are no more levels, we don\\'t update any prev->next pointers.\\n\\nAfter processing all nodes at Level 3, we set levelStart to NULL, indicating that we have processed all levels.\\n\\nThe final tree is returned.\\n\\n![Screenshot 2023-07-02 151428.png](https://assets.leetcode.com/users/images/8874bb83-edb0-4ecf-9554-f2566ffe70a8_1688291107.2480955.png)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (root == nullptr) {\\n            return nullptr;\\n        }\\n\\n        Node* levelStart = root;\\n\\n        while (levelStart != nullptr) {\\n            Node* curr = levelStart;\\n            Node* dummy = new Node(0); // Dummy node to represent the start of the next level\\n            Node* prev = dummy;\\n\\n            while (curr != nullptr) {\\n                if (curr->left != nullptr) {\\n                    prev->next = curr->left;\\n                    prev = prev->next;\\n                }\\n\\n                if (curr->right != nullptr) {\\n                    prev->next = curr->right;\\n                    prev = prev->next;\\n                }\\n\\n                curr = curr->next;\\n            }\\n\\n            levelStart = dummy->next; // Move to the next level\\n            delete dummy; // Free the dummy node\\n        }\\n\\n        return root;\\n    }\\n};\\n\\n\\n```\\nbetter upvote if this helped\\n\\n![ED21zjgXsAgW4ee.jpg](https://assets.leetcode.com/users/images/80eb3bf0-6afe-40b9-9b80-e115b8e63ebe_1688291556.10529.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n        1\\n       / \\\\\\n      2   3\\n     / \\\\   \\\\\\n    4   5   7\\n```\n```\\nLevel 1:\\n   1 -> NULL\\nDummy: [ ]\\n```\n```\\nLevel 1:\\n   1 -> NULL\\n\\nDummy: [ ]\\n\\nLevel 2:\\n   2 -> 3 -> NULL\\n```\n```\\nLevel 1:\\n   1 -> NULL\\n\\nDummy: [ ]\\n\\nLevel 2:\\n   2 -> 3 -> NULL\\n\\nDummy: [ ]\\n```\n```\\n\\nLevel 1:\\n   1 -> NULL\\n\\nDummy: [ ]\\n\\nLevel 2:\\n   2 -> 3 -> NULL\\n\\nDummy: [ ]\\n\\nLevel 3:\\n   4 -> 5 -> 7 -> NULL\\n```\n```\\nLevel 1:\\n   1 -> NULL\\n\\nDummy: [ ]\\n\\nLevel 2:\\n   2 -> 3 -> NULL\\n\\nDummy: [ ]\\n\\nLevel 3:\\n   4 -> 5 -> 7 -> NULL\\n\\nDummy: [ ]\\n```\n```\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (root == nullptr) {\\n            return nullptr;\\n        }\\n\\n        Node* levelStart = root;\\n\\n        while (levelStart != nullptr) {\\n            Node* curr = levelStart;\\n            Node* dummy = new Node(0); // Dummy node to represent the start of the next level\\n            Node* prev = dummy;\\n\\n            while (curr != nullptr) {\\n                if (curr->left != nullptr) {\\n                    prev->next = curr->left;\\n                    prev = prev->next;\\n                }\\n\\n                if (curr->right != nullptr) {\\n                    prev->next = curr->right;\\n                    prev = prev->next;\\n                }\\n\\n                curr = curr->next;\\n            }\\n\\n            levelStart = dummy->next; // Move to the next level\\n            delete dummy; // Free the dummy node\\n        }\\n\\n        return root;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035109,
                "title": "java-solution-using-bfs-with-comments",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        //check for null input \\n        if(root == null)return root;\\n        //make a queue for bfs\\n        Queue<Node> queue = new ArrayDeque<>();\\n        queue.add(root);\\n        //going through the nodes in the queue\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0; i< size; i++){\\n                Node curr = queue.poll();\\n                //if the node is not the last node in its level\\n                if(i<size-1) curr.next = queue.peek();\\n                //add the left and right child to the queue\\n                if(curr.left != null) queue.add(curr.left);\\n                if(curr.right != null) queue.add(curr.right);\\n            }\\n        }\\n        return root;\\n    }\\n}\\n\\n//Time and space complexity of O(n) where n is the number of nodes in the tree, \\n//we need to check all the nodes at least once and we store them in a queue of size of n. \\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        //check for null input \\n        if(root == null)return root;\\n        //make a queue for bfs\\n        Queue<Node> queue = new ArrayDeque<>();\\n        queue.add(root);\\n        //going through the nodes in the queue\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0; i< size; i++){\\n                Node curr = queue.poll();\\n                //if the node is not the last node in its level\\n                if(i<size-1) curr.next = queue.peek();\\n                //add the left and right child to the queue\\n                if(curr.left != null) queue.add(curr.left);\\n                if(curr.right != null) queue.add(curr.right);\\n            }\\n        }\\n        return root;\\n    }\\n}\\n\\n//Time and space complexity of O(n) where n is the number of nodes in the tree, \\n//we need to check all the nodes at least once and we store them in a queue of size of n. \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932097,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var left: Node?\\n *     public var right: Node?\\n *\\t   public var next: Node?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.left = nil\\n *         self.right = nil\\n *         self.next = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(1), only constant space is used.\\n\\n    func connect(_ root: Node?) -> Node? {\\n        guard let root = root else { return nil }\\n        \\n        var queue: [Node] = [root]\\n        while queue.count > 0 {\\n            var level: [Node] = []\\n            var prev: Node?\\n            \\n            for node in queue {\\n                if let left = node.left { level.append(left) }\\n                if let right = node.right { level.append(right) }\\n                if prev != nil { prev?.next = node }\\n                prev = node\\n            }\\n            \\n            queue = level\\n        }\\n        \\n        return root\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var left: Node?\\n *     public var right: Node?\\n *\\t   public var next: Node?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.left = nil\\n *         self.right = nil\\n *         self.next = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(1), only constant space is used.\\n\\n    func connect(_ root: Node?) -> Node? {\\n        guard let root = root else { return nil }\\n        \\n        var queue: [Node] = [root]\\n        while queue.count > 0 {\\n            var level: [Node] = []\\n            var prev: Node?\\n            \\n            for node in queue {\\n                if let left = node.left { level.append(left) }\\n                if let right = node.right { level.append(right) }\\n                if prev != nil { prev?.next = node }\\n                prev = node\\n            }\\n            \\n            queue = level\\n        }\\n        \\n        return root\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962448,
                "title": "python-clean-level-order-traversal",
                "content": "```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root: return\\n        queue = [root]\\n        \\n        while queue:\\n            newQueue = []\\n            while queue:\\n                node = queue.pop(0)\\n                if queue: node.next = queue[0]\\n                if node.left: newQueue.append(node.left)\\n                if node.right: newQueue.append(node.right)\\n            queue = newQueue\\n            \\n        return root\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root: return\\n        queue = [root]\\n        \\n        while queue:\\n            newQueue = []\\n            while queue:\\n                node = queue.pop(0)\\n                if queue: node.next = queue[0]\\n                if node.left: newQueue.append(node.left)\\n                if node.right: newQueue.append(node.right)\\n            queue = newQueue\\n            \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669795,
                "title": "java-100-neat-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic Node connect(Node root) {\\n\\t\\t\\tif(null == root) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (root.left != null && root.right != null) {\\n\\t\\t\\t\\troot.left.next = root.right;\\n\\t\\t\\t\\troot.right.next = findNext(root.next);\\n\\t\\t\\t} else if (root.left != null) {\\n\\t\\t\\t\\troot.left.next = findNext(root.next);\\n\\t\\t\\t} else if (root.right != null) {\\n\\t\\t\\t\\troot.right.next = findNext(root.next);\\n\\t\\t\\t}\\n\\n\\t\\t\\t/**right first*/\\n\\t\\t\\tconnect(root.right);\\n\\t\\t\\tconnect(root.left);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\n\\t\\tprivate Node findNext(Node root) {\\n\\t\\t\\tif (null == root) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t} else if (null != root.left) {\\n\\t\\t\\t\\treturn root.left;\\n\\t\\t\\t} else if (null != root.right) {\\n\\t\\t\\t\\treturn root.right;\\n\\t\\t\\t}\\n\\t\\t\\treturn findNext(root.next);\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic Node connect(Node root) {\\n\\t\\t\\tif(null == root) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2035129,
                "title": "c-east-bfs-comments-explanation-daily-leetcoding-challenge-may-day-13",
                "content": "**Please Upvote If It Helps**\\n\\n* as we know this question is just like level order traversal\\n\\n       * level 1 = 1\\n       * level 2 = 2 3\\n       * level 3 = 4 5 7\\n       \\n* now we just need to make connections from left to right and put null after the end element of each level\\n       \\n        * level 1 = 1->NULL\\n        * level 2 = 2->3->NULL\\n        * level 3 = 4->5->7->NULL\\n\\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) \\n    { \\n        // just created a queue because we are going to follow level order traversal and push our root into that initially\\n        queue<Node*> q;\\n        if(root)\\n            q.push(root);\\n        \\n        // BFS(Level) Traversal\\n        while(!q.empty())\\n        {\\n            // extracting the current queue size and make a next pointer with value NULL\\n            // because we pushing the elments in our queue -> right then left (and right next will always be NULL)\\n            int size = q.size();\\n            Node* nxt = nullptr;\\n            \\n            // do the traversal over current queue size\\n            for(int i=0;i<size;i++)\\n            {\\n                // extractong the queue front and pop that from our queue\\n                auto top = q.front();\\n                q.pop();\\n                \\n                // now according to need assign top next NULL\\n                // and make current top as next for the left element\\n                top->next = nxt;\\n                nxt = top;\\n                \\n                // push left and right nodes if they are available\\n                if(top->right)\\n                    q.push(top->right);\\n                if(top->left)\\n                    q.push(top->left);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) \\n    { \\n        // just created a queue because we are going to follow level order traversal and push our root into that initially\\n        queue<Node*> q;\\n        if(root)\\n            q.push(root);\\n        \\n        // BFS(Level) Traversal\\n        while(!q.empty())\\n        {\\n            // extracting the current queue size and make a next pointer with value NULL\\n            // because we pushing the elments in our queue -> right then left (and right next will always be NULL)\\n            int size = q.size();\\n            Node* nxt = nullptr;\\n            \\n            // do the traversal over current queue size\\n            for(int i=0;i<size;i++)\\n            {\\n                // extractong the queue front and pop that from our queue\\n                auto top = q.front();\\n                q.pop();\\n                \\n                // now according to need assign top next NULL\\n                // and make current top as next for the left element\\n                top->next = nxt;\\n                nxt = top;\\n                \\n                // push left and right nodes if they are available\\n                if(top->right)\\n                    q.push(top->right);\\n                if(top->left)\\n                    q.push(top->left);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033345,
                "title": "c-bfs-right-to-left-level-order-traversal",
                "content": "Use a queue\\nLevel order traverse from right to left\\nkeep track of previous node\\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node*> q;\\n        if(root) q.push(root);\\n        while(!q.empty()) {\\n            int qSize = q.size();\\n            Node* prev = nullptr;\\n            for(int i = 0; i < qSize; i++) {\\n                auto top = q.front();\\n                q.pop();\\n                top->next = prev;\\n                prev = top;\\n                if(top->right) q.push(top->right);\\n                if(top->left) q.push(top->left);\\n            }\\n        }\\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node*> q;\\n        if(root) q.push(root);\\n        while(!q.empty()) {\\n            int qSize = q.size();\\n            Node* prev = nullptr;\\n            for(int i = 0; i < qSize; i++) {\\n                auto top = q.front();\\n                q.pop();\\n                top->next = prev;\\n                prev = top;\\n                if(top->right) q.push(top->right);\\n                if(top->left) q.push(top->left);\\n            }\\n        }\\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849887,
                "title": "javascript-solution-iterative-approach",
                "content": "```\\nvar connect = function(root) {\\n    let curr = root;\\n    \\n    while (curr != null) {\\n        let start = null; // (1)\\n        let prev = null;\\n    \\n        while (curr != null) { // (2)\\n            if (start == null) { // (3)\\n                if (curr.left) start = curr.left;\\n                else if (curr.right) start = curr.right;\\n                \\n                prev = start; // (4)\\n            }\\n            \\n            if (prev != null) {\\n                if (curr.left && prev != curr.left) {\\n                    prev = prev.next = curr.left; // (5)\\n                }\\n                if (curr.right && prev != curr.right) {\\n                    prev = prev.next = curr.right;\\n                }\\n            }\\n\\n            curr = curr.next; // (6)\\n        }\\n\\t\\t\\n        curr = start; // (7)\\n    }\\n    \\n    return root;\\n};\\n\\n/*\\nAdditional Comments:\\n\\n(1) Used as a marker for the beginning of the next level\\n\\n(2) Traverse nodes left to right at current level until there are no more nodes to traverse\\n\\n(3) We have not found the beginning of the next level\\n\\n(4) If both curr.left and curr.right are null, then start will stay null and prev will also stay null\\n\\n(5) JavaScript operator associativity for the equal sign (=) is right to left. \\n\\tSo first we set prev.next to curr.left and then re-assign prev to prev.next which is curr.left\\n\\n(6) Move to the next node\\n\\n(7) Traverse down to the next level\\n\\t\\n*/\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar connect = function(root) {\\n    let curr = root;\\n    \\n    while (curr != null) {\\n        let start = null; // (1)\\n        let prev = null;\\n    \\n        while (curr != null) { // (2)\\n            if (start == null) { // (3)\\n                if (curr.left) start = curr.left;\\n                else if (curr.right) start = curr.right;\\n                \\n                prev = start; // (4)\\n            }\\n            \\n            if (prev != null) {\\n                if (curr.left && prev != curr.left) {\\n                    prev = prev.next = curr.left; // (5)\\n                }\\n                if (curr.right && prev != curr.right) {\\n                    prev = prev.next = curr.right;\\n                }\\n            }\\n\\n            curr = curr.next; // (6)\\n        }\\n\\t\\t\\n        curr = start; // (7)\\n    }\\n    \\n    return root;\\n};\\n\\n/*\\nAdditional Comments:\\n\\n(1) Used as a marker for the beginning of the next level\\n\\n(2) Traverse nodes left to right at current level until there are no more nodes to traverse\\n\\n(3) We have not found the beginning of the next level\\n\\n(4) If both curr.left and curr.right are null, then start will stay null and prev will also stay null\\n\\n(5) JavaScript operator associativity for the equal sign (=) is right to left. \\n\\tSo first we set prev.next to curr.left and then re-assign prev to prev.next which is curr.left\\n\\n(6) Move to the next node\\n\\n(7) Traverse down to the next level\\n\\t\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 411064,
                "title": "javascript-recursive-solution-no-loops",
                "content": "\\n```\\nvar getNextMost = function(root) {\\n  if (!root) return null;\\n  if (root.left) return root.left; // check left leg\\n  if (root.right) return root.right; // check right leg\\n  return getNextMost(root.next); // check nexts\\n}\\n\\nvar connect = function(root) {\\n  if (!root) {\\n    return root;\\n  }\\n  if (root.right) {\\n    root.right.next = getNextMost(root.next);\\n  }\\n  if (root.left) {\\n    root.left.next = root.right ? root.right : getNextMost(root.next);\\n  }\\n  connect(root.right);\\n  connect(root.left);\\n  return root;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar getNextMost = function(root) {\\n  if (!root) return null;\\n  if (root.left) return root.left; // check left leg\\n  if (root.right) return root.right; // check right leg\\n  return getNextMost(root.next); // check nexts\\n}\\n\\nvar connect = function(root) {\\n  if (!root) {\\n    return root;\\n  }\\n  if (root.right) {\\n    root.right.next = getNextMost(root.next);\\n  }\\n  if (root.left) {\\n    root.left.next = root.right ? root.right : getNextMost(root.next);\\n  }\\n  connect(root.right);\\n  connect(root.left);\\n  return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37947,
                "title": "very-simple-iterative-and-recursive-solutions-yet-still-accepted-as-best-in-cpp",
                "content": "    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            TreeLinkNode *cur, head(0);\\n            while(root)\\n            {\\n                head.next = NULL;\\n                cur = &head;\\n                while(root)\\n                {\\n                    if(root->left)\\n                    {\\n                        cur->next = root->left;\\n                        cur = cur->next;\\n                    }\\n                    if(root->right)\\n                    {\\n                        cur->next = root->right;\\n                        cur = cur->next;\\n                    }\\n                    root = root->next;\\n                }\\n                root = head.next;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            TreeLinkNode *cur, head(0);\\n            while(root)\\n            {\\n                head.next = NULL;\\n                cur = &head;\\n                while(root)\\n                {\\n                    if(root->left)\\n                    {\\n                        cur->next = root->left;\\n                        cur = cur->next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 37967,
                "title": "easy-understand-and-precise-java-code",
                "content": "   Use dummy node to avoid unneccesary if sentense:\\n\\n     public void connect(TreeLinkNode root) {\\n            while(root != null){\\n                TreeLinkNode firstNode = new TreeLinkNode(0); //Dummy head\\n                TreeLinkNode pre = firstNode;\\n                for(TreeLinkNode cur = root; cur != null; cur = cur.next){\\n                    if(cur.left != null){\\n                        pre.next = cur.left;\\n                        pre = cur.left;\\n                    }\\n                    if(cur.right != null){\\n                        pre.next = cur.right;\\n                        pre = cur.right;\\n                    }\\n                }\\n                root = firstNode.next;\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "   Use dummy node to avoid unneccesary if sentense:\\n\\n     public void connect(TreeLinkNode root) {\\n            while(root != null){\\n                TreeLinkNode firstNode = new TreeLinkNode(0); //Dummy head\\n                TreeLinkNode pre = firstNode;\\n                for(TreeLinkNode cur = root; cur != null; cur = cur.next){\\n                    if(cur.left != null){\\n                        pre.next = cur.left;\\n                        pre = cur.left;\\n                    }\\n                    if(cur.right != null){\\n                        pre.next = cur.right;\\n                        pre = cur.right;\\n                    }\\n                }\\n                root = firstNode.next;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 38024,
                "title": "a-simple-and-clear-bfs-solution-in-20-lines",
                "content": "    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n             if( root == NULL )\\n                 return;\\n             root->next = NULL;\\n             TreeLinkNode *pre = root;\\n             TreeLinkNode *tmphead = new TreeLinkNode(0);\\n             TreeLinkNode *p = NULL;\\n             while(pre != NULL){\\n                 p = tmphead;\\n                 while( pre != NULL ){\\n                     if(pre->left != NULL) p = p->next = pre->left;\\n                     if(pre->right != NULL) p = p->next = pre->right;\\n                     pre = pre->next;\\n                 }\\n                 p->next = NULL;\\n                 pre = tmphead->next;\\n             }\\n             tmphead->next = NULL;\\n             delete tmphead;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n             if( root == NULL )\\n                 return;\\n             root->next = NULL;\\n             TreeLinkNode *pre = root;\\n             TreeLinkNode *tmphead = new TreeLinkNode(0);\\n             TreeLinkNode *p = NULL;\\n             while(pre != NULL){\\n                 p = tmphead;\\n                 while( pre != NULL ){\\n                     if(pre->left != NULL) p = p->next = pre->left;\\n                     if(pre->right != NULL) p = p->next = pre->right;\\n                     pre = pre->next;\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 2779805,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) \\n    {\\n        if (!root)\\n            return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while (q.size() > 1)\\n        {\\n            Node* curr = q.front();\\n            q.pop();\\n            if (!curr)\\n            {\\n                q.push(NULL);\\n                continue;\\n            }\\n            curr->next = q.front();\\n            if (curr->left)\\n                q.push(curr->left);\\n            if (curr->right)\\n                q.push(curr->right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) \\n    {\\n        if (!root)\\n            return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while (q.size() > 1)\\n        {\\n            Node* curr = q.front();\\n            q.pop();\\n            if (!curr)\\n            {\\n                q.push(NULL);\\n                continue;\\n            }\\n            curr->next = q.front();\\n            if (curr->left)\\n                q.push(curr->left);\\n            if (curr->right)\\n                q.push(curr->right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253402,
                "title": "c-simple-dfs-solution-without-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* search(Node* root) { \\n        while(root) {\\n            if(root->left) return root->left;\\n            else if(root->right) return root->right;   \\n            root = root->next;\\n        }\\n        return NULL;\\n    }\\n    \\n    Node* connect(Node* root) {\\n        if(!root) return NULL;\\n        if(root->left) root->left->next = root->right ? root->right : search(root->next);\\n        if(root->right) root->right->next = search(root->next);\\n   \\n        connect(root->right);\\n        connect(root->left);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* search(Node* root) { \\n        while(root) {\\n            if(root->left) return root->left;\\n            else if(root->right) return root->right;   \\n            root = root->next;\\n        }\\n        return NULL;\\n    }\\n    \\n    Node* connect(Node* root) {\\n        if(!root) return NULL;\\n        if(root->left) root->left->next = root->right ? root->right : search(root->next);\\n        if(root->right) root->right->next = search(root->next);\\n   \\n        connect(root->right);\\n        connect(root->left);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963539,
                "title": "c-constant-space-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return root;\\n        Node *head=NULL,*tail=NULL;\\n        Node *curr=root;\\n        curr->next=NULL; //Make right of root as NULL\\n        \\n        //For each level, we will update the next pointers of next level\\n        while(curr){\\n            if(curr->left){ //only if left child exists\\n                if(head==NULL){\\n                    head=tail=curr->left;\\n                    tail->next=NULL;\\n                }\\n                else{\\n                    tail->next=curr->left;\\n                    tail=tail->next;\\n                }\\n            }\\n            if(curr->right){ //only if right child exists\\n                if(head==NULL){\\n                    head=tail=curr->right;\\n                    tail->next=NULL;\\n                }\\n                else{\\n                    tail->next=curr->right;\\n                    tail=tail->next;\\n                }\\n            }\\n            curr=curr->next; //Going to next node at same level.\\n            if(NULL == curr && head){ //Level completed now, update curr to next level head.\\n                tail->next=NULL;\\n                curr=head; //update root \\n                head=tail=NULL;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return root;\\n        Node *head=NULL,*tail=NULL;\\n        Node *curr=root;\\n        curr->next=NULL; //Make right of root as NULL\\n        \\n        //For each level, we will update the next pointers of next level\\n        while(curr){\\n            if(curr->left){ //only if left child exists\\n                if(head==NULL){\\n                    head=tail=curr->left;\\n                    tail->next=NULL;\\n                }\\n                else{\\n                    tail->next=curr->left;\\n                    tail=tail->next;\\n                }\\n            }\\n            if(curr->right){ //only if right child exists\\n                if(head==NULL){\\n                    head=tail=curr->right;\\n                    tail->next=NULL;\\n                }\\n                else{\\n                    tail->next=curr->right;\\n                    tail=tail->next;\\n                }\\n            }\\n            curr=curr->next; //Going to next node at same level.\\n            if(NULL == curr && head){ //Level completed now, update curr to next level head.\\n                tail->next=NULL;\\n                curr=head; //update root \\n                head=tail=NULL;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961938,
                "title": "java-bfs-solution-1ms",
                "content": "public Node connect(Node root) {\\n        if(root==null || (root.left==null && root.right==null))\\n            return root;\\n        \\n        LinkedList<Node> q = new LinkedList<>();\\n        \\n        q.offer(root);\\n        \\n        Node ans=root;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            Node curr=q.peek();\\n            for(int i=0;i<size;i++){\\n                curr=q.poll();\\n                curr.next=q.peek();\\n                if(curr.left!=null)\\n                    q.offer(curr.left);\\n                if(curr.right!=null)\\n                    q.offer(curr.right);\\n            }\\n            curr.next=null;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "public Node connect(Node root) {\\n        if(root==null || (root.left==null && root.right==null))\\n            return root;\\n        \\n        LinkedList<Node> q = new LinkedList<>();\\n        \\n        q.offer(root);\\n        \\n        Node ans=root;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            Node curr=q.peek();\\n            for(int i=0;i<size;i++){\\n                curr=q.poll();\\n                curr.next=q.peek();\\n                if(curr.left!=null)\\n                    q.offer(curr.left);\\n                if(curr.right!=null)\\n                    q.offer(curr.right);\\n            }\\n            curr.next=null;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2474554,
                "title": "javascript-result-serialization-broken",
                "content": "Result serializer throw erorr on the corrent output.\\nAlso tried with right JS solutions - same result.\\n\\nExample:\\n```\\nvar connect = function(root) {\\n\\treturn root; // serializer throw error on this line\\n}\\n```\\n\\n\\nAdded image with console output:\\n\\n![image](https://assets.leetcode.com/users/images/159b4bb1-7202-4b7f-a3ed-4be9b7ed97d2_1661362725.3510761.png)\\n",
                "solutionTags": [],
                "code": "```\\nvar connect = function(root) {\\n\\treturn root; // serializer throw error on this line\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2034966,
                "title": "java-bfs-o-1-space-easy-to-understand",
                "content": "##### Steps\\nuse BFS\\n1. traverse every level\\n1. use `head` to track the start of next level\\n1. traverse each node in the same level via `cur = cur.next`\\n1. connect the nodes of the next level\\n1. when the `cur` node is null, go to next level by `cur = head.next`\\n1. until all nodes are visited\\n\\n##### Solution\\n```java\\npublic Node connect(Node root) {\\n    Node cur = root;\\n    while (cur != null) {\\n        Node head = new Node();\\n        Node child = head;\\n        while (cur != null) {\\n            if (cur.left != null) {\\n                child.next = cur.left;\\n                child = child.next;\\n            }\\n            if (cur.right != null) {\\n                child.next = cur.right;\\n                child = child.next;\\n            }\\n            cur = cur.next;\\n        }\\n        cur = head.next;\\n    }\\n    return root;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic Node connect(Node root) {\\n    Node cur = root;\\n    while (cur != null) {\\n        Node head = new Node();\\n        Node child = head;\\n        while (cur != null) {\\n            if (cur.left != null) {\\n                child.next = cur.left;\\n                child = child.next;\\n            }\\n            if (cur.right != null) {\\n                child.next = cur.right;\\n                child = child.next;\\n            }\\n            cur = cur.next;\\n        }\\n        cur = head.next;\\n    }\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1543279,
                "title": "recursive-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    Node *findNext(Node *root)\\n    {\\n        if(!root) return NULL;\\n        \\n        if(root -> left) return root -> left;\\n        if(root -> right) return root -> right;\\n        \\n        return findNext(root->next);\\n    }\\n    \\n    void populateRight(Node* root)\\n    {\\n        if(!root) return;\\n        \\n        \\n        if(root -> left)\\n        {\\n            root -> left -> next = root -> right ? root -> right : findNext (root -> next);\\n        }\\n        \\n        if(root -> right)\\n        {\\n           root -> right -> next = findNext(root -> next);           \\n        }\\n        \\n        /*\\n        if we are doing left recur first, then right recur \\n        If we have more than 4 levels, we may miss at some point to link next for right pointer \\n        for eg :\\n                      1                          \\n                   2      3                           \\n                 4   5   6   7                       \\n                8 N 1 0 N N 5 5                       \\n                \\n          so we are doing preorder, root -> left -> right\\n          1, 2, 4, 8, 5, 1, 0, 6, 7, 5, 5\\n          \\n          at 1st time, we link 1\\'s child 2 -> 3 , 3 -> null\\n          at 2nd time, we link 2\\'s child 4 -> 5 , 5 -> 6\\n          at 3rd time, we link 8 with 5\\'s left child 1 so, 8 -> 1 (because we already linked 4->5)\\n          at 4th time, we link 5\\'s child 1 -> 0, but to link 0 -> 5 (7th left child, we don\\'t have link with 6 -> 7, so we can\\'t reach 7) \\n          \\n          so only we are doing recursion for right first and then left\\n             \\n        */\\n        \\n        populateRight(root -> right);\\n        populateRight(root -> left);\\n       \\n    }\\n   \\n    \\n    Node* connect(Node* root) {\\n        if(!root) return NULL;\\n        \\n        populateRight(root);\\n        \\n        return root;\\n    }\\n};`\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node *findNext(Node *root)\\n    {\\n        if(!root) return NULL;\\n        \\n        if(root -> left) return root -> left;\\n        if(root -> right) return root -> right;\\n        \\n        return findNext(root->next);\\n    }\\n    \\n    void populateRight(Node* root)\\n    {\\n        if(!root) return;\\n        \\n        \\n        if(root -> left)\\n        {\\n            root -> left -> next = root -> right ? root -> right : findNext (root -> next);\\n        }\\n        \\n        if(root -> right)\\n        {\\n           root -> right -> next = findNext(root -> next);           \\n        }\\n        \\n        /*\\n        if we are doing left recur first, then right recur \\n        If we have more than 4 levels, we may miss at some point to link next for right pointer \\n        for eg :\\n                      1                          \\n                   2      3                           \\n                 4   5   6   7                       \\n                8 N 1 0 N N 5 5                       \\n                \\n          so we are doing preorder, root -> left -> right\\n          1, 2, 4, 8, 5, 1, 0, 6, 7, 5, 5\\n          \\n          at 1st time, we link 1\\'s child 2 -> 3 , 3 -> null\\n          at 2nd time, we link 2\\'s child 4 -> 5 , 5 -> 6\\n          at 3rd time, we link 8 with 5\\'s left child 1 so, 8 -> 1 (because we already linked 4->5)\\n          at 4th time, we link 5\\'s child 1 -> 0, but to link 0 -> 5 (7th left child, we don\\'t have link with 6 -> 7, so we can\\'t reach 7) \\n          \\n          so only we are doing recursion for right first and then left\\n             \\n        */\\n        \\n        populateRight(root -> right);\\n        populateRight(root -> left);\\n       \\n    }\\n   \\n    \\n    Node* connect(Node* root) {\\n        if(!root) return NULL;\\n        \\n        populateRight(root);\\n        \\n        return root;\\n    }\\n};`\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37859,
                "title": "share-my-concise-dfs-solution",
                "content": "    /**\\n     * Definition for binary tree with next pointer.\\n     * struct TreeLinkNode {\\n     *  int val;\\n     *  TreeLinkNode *left, *right, *next;\\n     *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        map<int, TreeLinkNode*> rec;\\n        void dfs(TreeLinkNode *root, int dep) {\\n            if (!root) return;\\n            if (rec[dep]) {\\n                rec[dep]->next = root;\\n            }\\n            rec[dep] = root;        \\n            dfs(root->left, dep + 1);\\n            dfs(root->right, dep + 1);\\n        }\\n    \\n        void connect(TreeLinkNode *root) {\\n            dfs(root, 0);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        map<int, TreeLinkNode*> rec;\\n        void dfs(TreeLinkNode *root, int dep) {\\n            if (!root) return;\\n            if (rec[dep]) {\\n                rec[dep]->next = root;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2034895,
                "title": "python-explained-simple-bfs-approach-with-time-and-space-complexity",
                "content": "As soon as we see this problem, we think of a **level order traversal**, that traverses through the tree level by level. This level order traversal can be achieved using **Breadth First Search** that uses queue data structure to store and retrieve data.\\n\\nFirstly, queue in python can be easily implemented using deque (it has a few advantages over lists).\\n\\nNow coming to the BFS algo:\\n1. **If no root**, then no next pointer population so **simply return**.\\n2. **Create a queue**, that stores the tree Node element along with its level. The **level** simply **means depth**, where *depth of root = 0*.\\n3. Deque the first element from the Queue and Enqueue its immediate successors/children, and *keep this deque and enqueue opeations on, till no more successors are found*. Just like Normal **BFS**.\\n4. Now, During this BFS, we want that the current element should point to the next element in the same level.\\n\\nThere is no way to know the next element ahead of time always, but we always know what we have encountered earlier (the previous node). \\n\\nSo, what we did here was, **update the previous node\\'s next pointer value to current node pointer**, *if both the current and previous node are at the same level*.\\n\\n```\\nclass Solution:\\n    from collections import deque\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return \\n        queue = deque()\\n        queue.append([root, 0])\\n        prev, lvl = None, -1\\n        while queue:\\n            current, level = queue.popleft()\\n            if current.left:\\n                queue.append([current.left, level + 1])\\n            if current.right:\\n                queue.append([current.right, level + 1])\\n            if prev and level == lvl:\\n                prev.next = current\\n            prev, lvl = current, level\\n        return root  \\n```\\n**Time Complexity analysis:**\\nWe are traversing through each element exactly once.\\nHence, **time complexity  = O(n)**.\\n\\n**Space Complexity Analysis:**\\nThere are 2^h number of nodes in the last level of a full Binary Tree (worst case) with height h. \\nAlso, for a full Binary Tree, height of the tree = (log2n) nearly.\\nAt max we will be storing one complete level at a time in our queue, and max number of elements (in the worst case) are present in the last level.\\nSo, max size of queue = 2 ^ (log2n) = **O(n) = Space Complexity**.\\n\\nUpvote, if helpful.",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    from collections import deque\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return \\n        queue = deque()\\n        queue.append([root, 0])\\n        prev, lvl = None, -1\\n        while queue:\\n            current, level = queue.popleft()\\n            if current.left:\\n                queue.append([current.left, level + 1])\\n            if current.right:\\n                queue.append([current.right, level + 1])\\n            if prev and level == lvl:\\n                prev.next = current\\n            prev, lvl = current, level\\n        return root  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033926,
                "title": "c-iterative-o-n-complexity-level-order-traversal-solution-explained",
                "content": "**Steps **\\n1. First step is to check whether there is empty tree or not.\\n2. Level by level we go on pushing the nodes present on current level into the queue.\\n3. Then we store every vector of nodes of particular level in 2d vector which is defined.\\n4. At last we iterate over every vector and make the next pointer of node to point towards the exactly next right node.\\n5. Finally we return root of tree. \\n\\n\\'\\'\\'\\n\\t\\t\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\n\\t\\tNode* connect(Node* root) {\\n        \\n\\t\\t\\t// First checking the condition for empty tree.\\n\\t\\t\\tif(!root) return NULL;\\n\\n\\t\\t\\t// Initialising a queue data structure\\n\\t\\t\\tqueue<Node *> q;\\n\\t\\t\\tq.push(root);\\n\\n\\t\\t\\t// Defining 2d vector for storing nodes level by level\\n\\t\\t\\tvector<vector<Node*>> ans;\\n\\n\\t\\t\\t// Iterating the queue till it not becomes NULL\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<Node*> sam;\\n\\t\\t\\t\\t// Defining size of current level\\n\\t\\t\\t\\tint size=q.size();\\n\\t\\t\\t\\twhile(size--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tNode* node=q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tsam.push_back(node);\\n\\t\\t\\t\\t\\t/*If left node exist and right node exist then simply push in the queue.           \\n\\t\\t\\t\\t\\tif(node->left)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tq.push(node->left);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(node->right)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tq.push(node->right);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans.push_back(sam);\\n            \\n        }\\n        \\n        /* Iterating through all the vectors and making left node\\'s next pointer to point at\\n          next right node */\\n         \\n        for(auto it : ans)\\n        {\\n            for(int i=0;i<it.size()-1;i++)\\n            {\\n                it[i]->next=it[i+1];\\n            }\\n            \\n        }\\n        \\n        return root;\\n      }\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\n\\t\\tNode* connect(Node* root) {\\n        \\n\\t\\t\\t// First checking the condition for empty tree.\\n\\t\\t\\tif(!root) return NULL;\\n\\n\\t\\t\\t// Initialising a queue data structure\\n\\t\\t\\tqueue<Node *> q;\\n\\t\\t\\tq.push(root);\\n\\n\\t\\t\\t// Defining 2d vector for storing nodes level by level\\n\\t\\t\\tvector<vector<Node*>> ans;\\n\\n\\t\\t\\t// Iterating the queue till it not becomes NULL\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<Node*> sam;\\n\\t\\t\\t\\t// Defining size of current level\\n\\t\\t\\t\\tint size=q.size();\\n\\t\\t\\t\\twhile(size--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tNode* node=q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tsam.push_back(node);\\n\\t\\t\\t\\t\\t/*If left node exist and right node exist then simply push in the queue.           \\n\\t\\t\\t\\t\\tif(node->left)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tq.push(node->left);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1628299,
                "title": "c-solution-with-documentation-for-clear-and-crisp-understanding",
                "content": "# Please appreciate the beauty of recursion.\\n*The beauty of recursion is under-rated. *\\nIn this demonstration, you will understand how we return the root node, after modyfying all the pointers in the entire tree.\\nOne thing before seeing this code, you must ask yourself that how strong you are in terms on identifying the solution to this problem.\\n\\nIf on your own, you are able to see that if we need to find the next pointer of a node, if it is a left node, it will always be the right node if the right node exists.\\nIn the case of perfect binary tree, the right node always existed.\\nAlso, if you are right child of the parent, then in that case the next of you will be the left of the parent\\'s next if the left exist, or if the left does not exist, then the next of you will be the rifht child of your parent\\'s next. and suppose if both the left and right child of your parent do not exist, then whatever be the next of your parent\\'s next we will call the same function rersively on your parents\\' next \\'s next and so on.\\n\\nBut this tree is any binary tree, still we should be able to figure out the next pointer for each node and then return.\\n\\nRecursion is pretty beautiful and you will appreciate the beauty of it once you go through this below mentioned snippet.\\n```\\nclass Solution {\\npublic:\\n    //function returning node and take input as node, \\n    //finds the next node for each node.\\n    Node* findNext(Node* root)\\n    {\\n        //simple if root is null, next node will also be null.\\n        if(!root) return nullptr;\\n        //if node\\'s left exist, then we will return node\\'s left.\\n        if(root->left) return root->left;\\n        //if this if condition fails to execute, this means, there is no left\\n        //so we will simply return node\\'s right if it exist.\\n        if(root->right) return root->right;\\n        \\n        //suppose neither node left exist nor right,\\n        //then we will findnext on root\\'s next.\\n        //recusion fairy.\\n        return findNext(root->next);\\n    }\\n    //dfs function \\n    void dfs(Node* root)\\n    {\\n        if(!root) return ; //return if root is null\\n        if(root->left) //if root\\'s left exist\\n            //assign it\\'s next based on weather root\\'s right exist or not.\\n            root->left->next = root->right ? root->right : findNext(root->next); \\n        //if root\\'s right exist, no issue, make it the next of root\\'s left\\n        //else whatever findnext(root->next) return, make that the next of \\n        //root\\'s left.\\n        //and if root\\'s right exists\\n        if(root->right)\\n        //root\\'s right next eill simply be whatever findnext returns on root->next\\n            root->right->next = findNext(root->next);\\n        \\n        //now recursivly call dfs on root\\'s right as well as root\\'s left.\\n        // calling dfs on root right first will help us to HAVE ample information \\n        //for next of left node.\\n        //hence calling in this order is recommended.\\n        dfs(root->right);\\n        dfs(root->left);\\n    }\\n    \\n    Node* connect(Node* root) \\n    {\\n       if(!root) return nullptr;\\n       root->next = nullptr;\\n       dfs(root);\\n       return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //function returning node and take input as node, \\n    //finds the next node for each node.\\n    Node* findNext(Node* root)\\n    {\\n        //simple if root is null, next node will also be null.\\n        if(!root) return nullptr;\\n        //if node\\'s left exist, then we will return node\\'s left.\\n        if(root->left) return root->left;\\n        //if this if condition fails to execute, this means, there is no left\\n        //so we will simply return node\\'s right if it exist.\\n        if(root->right) return root->right;\\n        \\n        //suppose neither node left exist nor right,\\n        //then we will findnext on root\\'s next.\\n        //recusion fairy.\\n        return findNext(root->next);\\n    }\\n    //dfs function \\n    void dfs(Node* root)\\n    {\\n        if(!root) return ; //return if root is null\\n        if(root->left) //if root\\'s left exist\\n            //assign it\\'s next based on weather root\\'s right exist or not.\\n            root->left->next = root->right ? root->right : findNext(root->next); \\n        //if root\\'s right exist, no issue, make it the next of root\\'s left\\n        //else whatever findnext(root->next) return, make that the next of \\n        //root\\'s left.\\n        //and if root\\'s right exists\\n        if(root->right)\\n        //root\\'s right next eill simply be whatever findnext returns on root->next\\n            root->right->next = findNext(root->next);\\n        \\n        //now recursivly call dfs on root\\'s right as well as root\\'s left.\\n        // calling dfs on root right first will help us to HAVE ample information \\n        //for next of left node.\\n        //hence calling in this order is recommended.\\n        dfs(root->right);\\n        dfs(root->left);\\n    }\\n    \\n    Node* connect(Node* root) \\n    {\\n       if(!root) return nullptr;\\n       root->next = nullptr;\\n       dfs(root);\\n       return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581297,
                "title": "java-easy-tree-level-order-traversal-o-n",
                "content": "```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n\\t\\t// We will add nodes layer by layer into the queue\\n        Queue<Node> queue = new LinkedList<>();\\n\\t\\t// Start from the root\\n        queue.offer(root);\\n\\t\\t// While there are nodes in the queue, we will process them and add their children to the queue\\n        while (queue.size() > 0) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                Node node = queue.poll();\\n                if (i == size - 1) {\\n                    node.next = null;\\n                } else {\\n                    node.next = queue.peek();\\n                }\\n                if (node.left != null) queue.offer(node.left);\\n                if (node.right != null) queue.offer(node.right);\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n\\t\\t// We will add nodes layer by layer into the queue\\n        Queue<Node> queue = new LinkedList<>();\\n\\t\\t// Start from the root\\n        queue.offer(root);\\n\\t\\t// While there are nodes in the queue, we will process them and add their children to the queue\\n        while (queue.size() > 0) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                Node node = queue.poll();\\n                if (i == size - 1) {\\n                    node.next = null;\\n                } else {\\n                    node.next = queue.peek();\\n                }\\n                if (node.left != null) queue.offer(node.left);\\n                if (node.right != null) queue.offer(node.right);\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028427,
                "title": "java-recursion-with-detailed-explanation",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        if (root.left != null) {\\n            if (root.right != null) {\\n                root.left.next = root.right;\\n            } else {\\n                Node nxt = findNext(root.next);\\n                root.left.next = nxt;\\n            }\\n        }\\n        if (root.right != null) {\\n            Node nxt = findNext(root.next);\\n            root.right.next = nxt;\\n        }\\n\\t\\t// this is a key: build the connection from right to left.\\n\\t\\t// you can change it from left to right, see what will happend. lol \\n        connect(root.right);\\n        connect(root.left);\\n        return root;\\n    }\\n    \\n\\t//this helper function likes to operate a linkedlist\\n    private Node findNext(Node root) {\\n        while (root != null) {\\n            if (root.left != null) {\\n                return root.left;\\n            }\\n            if (root.right != null) {\\n                return root.right;\\n            }\\n            root = root.next;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        if (root.left != null) {\\n            if (root.right != null) {\\n                root.left.next = root.right;\\n            } else {\\n                Node nxt = findNext(root.next);\\n                root.left.next = nxt;\\n            }\\n        }\\n        if (root.right != null) {\\n            Node nxt = findNext(root.next);\\n            root.right.next = nxt;\\n        }\\n\\t\\t// this is a key: build the connection from right to left.\\n\\t\\t// you can change it from left to right, see what will happend. lol \\n        connect(root.right);\\n        connect(root.left);\\n        return root;\\n    }\\n    \\n\\t//this helper function likes to operate a linkedlist\\n    private Node findNext(Node root) {\\n        while (root != null) {\\n            if (root.left != null) {\\n                return root.left;\\n            }\\n            if (root.right != null) {\\n                return root.right;\\n            }\\n            root = root.next;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767806,
                "title": "swift-best-solution-easy-to-understand",
                "content": "```\\n\\n//upvote if you like my solution. Thanks :)\\n\\n//Depth-First-Search \\n\\nfunc connect(_ root: Node?) -> Node? {\\n    dfs(root)\\n    return root\\n}\\n\\nfunc dfs(_ root: Node?) {\\n    guard let root = root else {\\n        return\\n    }\\n    \\n\\t//traversing right side of the tree is the key, because if we traverse through left side first, \\n    //then its possible that parents\\'s next value be nil as this is not the perfect balanced binary tree that we are dealing with, \\n    //and we did not meet its next value which is on same level to the right side.\\n    if let right = root.right {\\n        right.next = getNext(root)\\n        dfs(right)\\n    }\\n    \\n    if let left = root.left {\\n        left.next = root.right ?? getNext(root)\\n        dfs(left)\\n    }\\n}\\n\\n// logic is simple, this is essentially returning next value for  \"right child\" only\\nfunc getNext(_ root: Node?) -> Node? {\\n    var parent = root\\n    \\n    while parent?.next != nil {\\n        if let left = parent?.next?.left {\\n            return left\\n        } else if let right = parent?.next?.right {\\n            return right\\n        } else {\\n            parent = parent?.next\\n        }\\n    }\\n    return nil\\n}\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n\\n//upvote if you like my solution. Thanks :)\\n\\n//Depth-First-Search \\n\\nfunc connect(_ root: Node?) -> Node? {\\n    dfs(root)\\n    return root\\n}\\n\\nfunc dfs(_ root: Node?) {\\n    guard let root = root else {\\n        return\\n    }\\n    \\n\\t//traversing right side of the tree is the key, because if we traverse through left side first, \\n    //then its possible that parents\\'s next value be nil as this is not the perfect balanced binary tree that we are dealing with, \\n    //and we did not meet its next value which is on same level to the right side.\\n    if let right = root.right {\\n        right.next = getNext(root)\\n        dfs(right)\\n    }\\n    \\n    if let left = root.left {\\n        left.next = root.right ?? getNext(root)\\n        dfs(left)\\n    }\\n}\\n\\n// logic is simple, this is essentially returning next value for  \"right child\" only\\nfunc getNext(_ root: Node?) -> Node? {\\n    var parent = root\\n    \\n    while parent?.next != nil {\\n        if let left = parent?.next?.left {\\n            return left\\n        } else if let right = parent?.next?.right {\\n            return right\\n        } else {\\n            parent = parent?.next\\n        }\\n    }\\n    return nil\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 364902,
                "title": "simple-java-o-1-space-and-o-n-time-with-return-type-node",
                "content": "I tried to write a very simple code that only delcares a dummy node once and then keeps reassinging them.\\n\\nI have used 2 loops. The inner while loops interates throgh nodes at a level. And the outer loop is triggerd when all the nodes at a level is exhausted.\\n\\nA similar question was asked during a microsoft interview.\\nQ. How would you find out all the nodes at a given level. \\nAns. You modify the tree to be like this question. So the cost of subsequant operations are cheap. I understand that while changing the tree you would have to travel through the whole tree.\\n\\nThere can be other ways but this would be the most efficient if you have multiple requests.\\n\\n```\\npublic Node connect(Node root) {\\n        if (root == null)\\n            return root;\\n        \\n        Node t = root;\\n        Node dummy = new Node();\\n        \\n        while (t != null) {\\n            Node current = dummy;\\n            while (t != null) {\\n                if (t.left != null) {\\n                    current.next = t.left;\\n                    current = current.next;\\n                }\\n                if (t.right != null) {\\n                    current.next = t.right;\\n                    current = current.next;\\n                }\\n                t = t.next;\\n            }\\n            t = dummy.next;\\n            dummy.next = null;\\n        }\\n        \\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\npublic Node connect(Node root) {\\n        if (root == null)\\n            return root;\\n        \\n        Node t = root;\\n        Node dummy = new Node();\\n        \\n        while (t != null) {\\n            Node current = dummy;\\n            while (t != null) {\\n                if (t.left != null) {\\n                    current.next = t.left;\\n                    current = current.next;\\n                }\\n                if (t.right != null) {\\n                    current.next = t.right;\\n                    current = current.next;\\n                }\\n                t = t.next;\\n            }\\n            t = dummy.next;\\n            dummy.next = null;\\n        }\\n        \\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37911,
                "title": "c-recursive-o-1-space",
                "content": "First solving this problem for an easier use case helps. So the solution posted right below is for a balanced binary tree. \\n```\\nvoid connect(struct TreeLinkNode *root)\\n{\\n    /* Validate node */\\n    if (!root) return;\\n\\n    /* Point left child to right : Best case */\\n    if (root->left)\\n        root->left->next = root->right;\\n            \\n    /* If right child is valid, then traverse parent's siblings to \\n    find the next pointer */\\n    if (root->right && root->next)\\n        root->right->next = root->next->left;\\n    \\n    /* First going right will populate \"next\" pointers, then left */\\n    connect(root->right);\\n    connect(root->left);\\n}\\n```\\nThe problem is essentially about locating the next sibling. To find that sibling of a node we need the next sibling of its parent. So the idea is to do a DFS while furnishing the *root->next* pointers and then we can use those links to locate the siblings for its children.\\n\\nAs you can see above, we do a DFS traversal from right to the left. Why right to left? Simply because the pointers are from left to right, the idea is to have these *next* pointers ready and then use them during subsequent traversals.\\n\\nBelow we have the full solution:\\n\\n```\\nstruct TreeLinkNode *GetNext(struct TreeLinkNode *root)\\n{\\n    if (!root) return NULL; // validate\\n    \\n    /* Find the next parent with a child */\\n    while (root && !root->left && !root->right) root = root->next;\\n    return root ? (root->left ? root->left : root->right) : NULL;\\n}\\nvoid connect(struct TreeLinkNode *root)\\n{\\n    /* Validate node */\\n    if (!root) return;\\n\\n    /* Point left child to right : Best case */\\n    if (root->left && root->right)\\n        root->left->next = root->right;\\n\\n    /* If find the next node by traversing the siblings of the parent. */\\n    else if (root->left)\\n        root->left->next = GetNext(root->next);\\n            \\n    /* If right child is valid, then traverse parent's siblings to \\n    find the next pointer */\\n    if (root->right)\\n        root->right->next = GetNext(root->next);\\n    \\n    /* First going right will populate \"next\" pointers */\\n    connect(root->right);\\n    connect(root->left);\\n}\\n```\\nNow if the tree is not balanced, then we cannot rely on *root->next->left* pointer to be valid. So we generalize this indirection by using a helper function GetNext. The basic DFS approach remains the same, but now we handle additional cases where siblings might be missing. \\n\\nIf visualization helps, then imagine this algorithm as working up a swarm -- top to bottom and in right to left direction.",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid connect(struct TreeLinkNode *root)\\n{\\n    /* Validate node */\\n    if (!root) return;\\n\\n    /* Point left child to right : Best case */\\n    if (root->left)\\n        root->left->next = root->right;\\n            \\n    /* If right child is valid, then traverse parent's siblings to \\n    find the next pointer */\\n    if (root->right && root->next)\\n        root->right->next = root->next->left;\\n    \\n    /* First going right will populate \"next\" pointers, then left */\\n    connect(root->right);\\n    connect(root->left);\\n}\\n```\n```\\nstruct TreeLinkNode *GetNext(struct TreeLinkNode *root)\\n{\\n    if (!root) return NULL; // validate\\n    \\n    /* Find the next parent with a child */\\n    while (root && !root->left && !root->right) root = root->next;\\n    return root ? (root->left ? root->left : root->right) : NULL;\\n}\\nvoid connect(struct TreeLinkNode *root)\\n{\\n    /* Validate node */\\n    if (!root) return;\\n\\n    /* Point left child to right : Best case */\\n    if (root->left && root->right)\\n        root->left->next = root->right;\\n\\n    /* If find the next node by traversing the siblings of the parent. */\\n    else if (root->left)\\n        root->left->next = GetNext(root->next);\\n            \\n    /* If right child is valid, then traverse parent's siblings to \\n    find the next pointer */\\n    if (root->right)\\n        root->right->next = GetNext(root->next);\\n    \\n    /* First going right will populate \"next\" pointers */\\n    connect(root->right);\\n    connect(root->left);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37955,
                "title": "java-iterative-solution-with-explanations",
                "content": "Suppose we have already constructed the next pointer for the current layer (call it L1), and we need to construct for the layer below (call it L2), something like this:\\n\\n         1 -> NULL\\n       /  \\\\\\n      2 -> 3 -> NULL  // current layer, L1\\n     / \\\\    \\\\  \\n    4   5    7       // layer below, L2\\n\\nFirst, it is obvious that we need to track the `first` node of L2.\\n\\nSecond, for every node, it can have either 0, 1, or 2 children.\\n\\n - If it has 0 children, we don't need anything\\n - If it has 1 child, no matter it is a left or right child, we connect the child with a node to its left, calling it a `prev` node (when it is the `first` node, we don't have a `prev` node). The `prev` node needs to be moved to the child afterwards\\n - If it has 2 children, we first need to connect `prev` to the left child, and connect left with the right. The `prev` node needs to be moved to the right child afterwards\\n\\nIt might seem that we need to consider three cases. After some thought, we can actually achieve it in two `if` blocks:\\n\\n - if has left child: connect prev with left child and move prev to left child\\n - if has right child: connect prev with right child and move prev to right child (This is not an `else if`!)\\n\\nThe code is as follows:\\n\\n    public void connect(TreeLinkNode root) {\\n        TreeLinkNode first = null, prev = null, child = null, current = root;\\n        while(current != null) {\\n            if((child = current.left) != null) {\\n                if(first == null) first = child;\\n                else prev.next = child;\\n                prev = child;\\n            }\\n            if((child = current.right) != null) {\\n                if(first == null) first = child;\\n                else prev.next = child;\\n                prev = child;\\n            }\\n            \\n            if(current.next != null) {\\n                current = current.next;\\n            } else {\\n                current = first;\\n                first = null;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "Suppose we have already constructed the next pointer for the current layer (call it L1), and we need to construct for the layer below (call it L2), something like this:\\n\\n         1 -> NULL\\n       /  \\\\\\n      2 -> 3 -> NULL  // current layer, L1\\n     / \\\\    \\\\  \\n    4   5    7       // layer below, L2\\n\\nFirst, it is obvious that we need to track the `first` node of L2.\\n\\nSecond, for every node, it can have either 0, 1, or 2 children.\\n\\n - If it has 0 children, we don't need anything\\n - If it has 1 child, no matter it is a left or right child, we connect the child with a node to its left, calling it a `prev` node (when it is the `first` node, we don't have a `prev` node). The `prev` node needs to be moved to the child afterwards\\n - If it has 2 children, we first need to connect `prev` to the left child, and connect left with the right. The `prev` node needs to be moved to the right child afterwards\\n\\nIt might seem that we need to consider three cases. After some thought, we can actually achieve it in two `if` blocks:\\n\\n - if has left child: connect prev with left child and move prev to left child\\n - if has right child: connect prev with right child and move prev to right child (This is not an `else if`!)\\n\\nThe code is as follows:\\n\\n    public void connect(TreeLinkNode root) {\\n        TreeLinkNode first = null, prev = null, child = null, current = root;\\n        while(current != null) {\\n            if((child = current.left) != null) {\\n                if(first == null) first = child;\\n                else prev.next = child;\\n                prev = child;\\n            }\\n            if((child = current.right) != null) {\\n                if(first == null) first = child;\\n                else prev.next = child;\\n                prev = child;\\n            }\\n            \\n            if(current.next != null) {\\n                current = current.next;\\n            } else {\\n                current = first;\\n                first = null;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37977,
                "title": "1ms-java-solution",
                "content": "    public class Solution {\\n        int max = 0;\\n        \\n        TreeLinkNode findNext(TreeLinkNode node) {\\n            if(node==null) return null;\\n            if(node.left != null) return node.left;\\n            if(node.right != null) return node.right;\\n            return findNext(node.next);\\n        }\\n        \\n        public void connect(TreeLinkNode root) {\\n            max = -1;\\n            connect(root, 0);\\n        }\\n        \\n        public void connect(TreeLinkNode node, int level) {\\n            \\n            //base case\\n            if(node==null) return;\\n            \\n            if(level > max) {\\n                //connect the child nodes at this level\\n                TreeLinkNode n = node;\\n                while(n != null) {\\n                    if(n.left != null) {\\n                        n.left.next = n.right != null ? n.right : findNext(n.next);\\n                    }\\n                    if(n.right != null) {\\n                        n.right.next = findNext(n.next);\\n                    }\\n                    n = n.next;\\n                }\\n                max = level;\\n            }\\n            \\n            connect(node.left, level+1);\\n            connect(node.right, level+1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        int max = 0;\\n        \\n        TreeLinkNode findNext(TreeLinkNode node) {\\n            if(node==null) return null;\\n            if(node.left != null) return node.left;\\n            if(node.right != null) return node.right;\\n            return findNext(node.next);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 38030,
                "title": "accepted-java-recursive-solution",
                "content": "The idea is to make sure we connect all the nodes in current level before recurse to the next level.\\n\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) return;\\n            \\n            // link root's child nodes\\n            link(root);\\n            \\n            // before we recurse to the next level\\n            // make sure all the child nodes of the nodes at current level are linked\\n            TreeLinkNode curr = root.next;\\n            while (curr != null) {\\n                link(curr);\\n                curr = curr.next;\\n            }\\n            \\n            connect(root.left);\\n            connect(root.right);\\n        }\\n        \\n        // helper function\\n        // link root node's left and right nodes\\n        void link(TreeLinkNode root) {\\n            if (root == null) return;\\n            \\n            if (root.left != null) {\\n                root.left.next = root.right != null ? root.right : getNext(root);\\n            } \\n            \\n            if (root.right != null) {\\n                root.right.next = getNext(root);\\n            }\\n        }\\n        \\n        // get the left most node at the next level\\n        TreeLinkNode getNext(TreeLinkNode node) {\\n            TreeLinkNode next = node.next;\\n            \\n            while (next != null) {\\n                if (next.left != null) return next.left;\\n                if (next.right != null) return next.right;\\n                next = next.next;\\n            }\\n            \\n            return null;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) return;\\n            \\n            // link root's child nodes\\n            link(root);\\n            \\n            // before we recurse to the next level\\n            // make sure all the child nodes of the nodes at current level are linked\\n            TreeLinkNode curr = root.next;\\n            while (curr != null) {\\n                link(curr);\\n                curr = curr.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 38037,
                "title": "short-java-bfs-solution",
                "content": "    public void connect(TreeLinkNode root) {\\n        TreeLinkNode queue = root;\\n        while (queue != null) {\\n            TreeLinkNode level = new TreeLinkNode(0);\\n            TreeLinkNode current = level;\\n            while (queue != null) {\\n                if (queue.left != null) {\\n                    current.next = queue.left;\\n                    current = current.next;\\n                }\\n                if (queue.right != null) {\\n                    current.next = queue.right;\\n                    current = current.next;\\n                }\\n                queue = queue.next;\\n            }\\n            queue = level.next;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public void connect(TreeLinkNode root) {\\n        TreeLinkNode queue = root;\\n        while (queue != null) {\\n            TreeLinkNode level = new TreeLinkNode(0);\\n            TreeLinkNode current = level;\\n            while (queue != null) {\\n                if (queue.left != null) {\\n                    current.next = queue.left;\\n                    current = current.next;\\n                }\\n                if (queue.right != null) {\\n                    current.next = queue.right;\\n                    current = current.next;\\n                }\\n                queue = queue.next;\\n            }\\n            queue = level.next;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2956328,
                "title": "c-beats-97-explained-using-level-order-traversal",
                "content": "# Best Solution for Beginners\\nWe can solve this using Level order Traversal.\\n\\n    Runtime - 97.14%\\uD83D\\uDD25 \\n\\n# Approach\\n1. Firstly We will do Level Order Travesal.\\n2. Then at Each Level we will join all nodes present at that Level.\\n\\n#  If you like the solution and understand it then Please Upvote.\\u2B06\\uFE0F\\u2764\\uFE0F \\n\\t* PEACE OUT LUV\\u270C\\uFE0F*\\n\\n# Code\\n```\\n/*\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL){\\n            return root;\\n        }\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<Node*>ans;\\n            for(int i=0; i<size; i++){\\n                Node* node = q.front();\\n                q.pop();\\n                if(node ->left)q.push(node ->left);\\n                if(node ->right)q.push(node ->right);\\n                ans.push_back(node);\\n            }\\n            for(int i=1; i<ans.size(); i++){\\n                ans[i-1] ->next = ans[i];\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL){\\n            return root;\\n        }\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<Node*>ans;\\n            for(int i=0; i<size; i++){\\n                Node* node = q.front();\\n                q.pop();\\n                if(node ->left)q.push(node ->left);\\n                if(node ->right)q.push(node ->right);\\n                ans.push_back(node);\\n            }\\n            for(int i=1; i<ans.size(); i++){\\n                ans[i-1] ->next = ans[i];\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301730,
                "title": "simple-c-recursion-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* find_next(Node* cur){\\n        while(cur){\\n            if(cur->left){\\n                \\n                return cur->left;\\n            }\\n             else if(cur->right){\\n                return cur->right;\\n            }\\n            cur=cur->next;\\n        }\\n        return NULL;\\n    }\\n    Node* connect(Node* root) {\\n        if(!root)\\n            return root;\\n        \\n        if(root->left){\\n            if(root->right)\\n                root->left->next = root->right;\\n            else\\n            {\\n                Node* cur = root->next;\\n                root->left->next = find_next(cur);\\n            }\\n        }\\n        if(root->next){\\n            if(root->right){    \\n                Node* cur = root->next;\\n                 root->right->next = find_next(cur);       \\n            }\\n        }\\n        connect(root->right);\\n        connect(root->left);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* find_next(Node* cur){\\n        while(cur){\\n            if(cur->left){\\n                \\n                return cur->left;\\n            }\\n             else if(cur->right){\\n                return cur->right;\\n            }\\n            cur=cur->next;\\n        }\\n        return NULL;\\n    }\\n    Node* connect(Node* root) {\\n        if(!root)\\n            return root;\\n        \\n        if(root->left){\\n            if(root->right)\\n                root->left->next = root->right;\\n            else\\n            {\\n                Node* cur = root->next;\\n                root->left->next = find_next(cur);\\n            }\\n        }\\n        if(root->next){\\n            if(root->right){    \\n                Node* cur = root->next;\\n                 root->right->next = find_next(cur);       \\n            }\\n        }\\n        connect(root->right);\\n        connect(root->left);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595021,
                "title": "solve-two-problems-at-once-116-117-level-iterate-optimization-using-next-pointer",
                "content": "116 && 117 universal solving methods: level-iteration\\n```\\n    public Node connect(Node root) {\\n        if(root == null)return null;\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty()){\\n            int n = queue.size();\\n            while(n-- != 0){\\n                Node cur = queue.poll();\\n                if(cur.left != null){\\n                    queue.add(cur.left);                    \\n                }\\n                if(cur.right != null){\\n                    queue.add(cur.right);   \\n                }\\n                if(n == 0){\\n                    continue;\\n                }\\n                Node next = queue.peek();\\n                cur.next = next; \\n            }\\n        }\\n        return root;\\n    }\\n```\\n\\n\\n117 \\nThought: when iterate one level and then we need to connect the next level.\\nAnd this is really intereating part. Hope you can get it. Happy coding!!!\\n\\nusing the next pointer version\\n```\\n    Node last = null, nextStart = null;\\n    public Node connect(Node root) {\\n        if(root == null)return null;\\n        Node start = root;\\n        while(start != null){\\n            //everytime when start begins, the next new line will be connected.\\n            last = null;\\n            nextStart = null;\\n            while(start != null){\\n                if(start.left != null){\\n                    connectNextLine(start.left);\\n                }\\n                if(start.right != null){\\n                    connectNextLine(start.right);\\n                }\\n                start = start.next;\\n            }\\n            start = nextStart;\\n        }\\n        return root;\\n    }\\n    public void connectNextLine(Node start){\\n        if(nextStart == null){\\n            nextStart = start;\\n        }\\n        if(last != null){\\n            last.next = start;\\n        }\\n        last = start;\\n    }\\n```\\n\\nIf you thing this is helpful to you. Please vote me, your vote is my best encouragement to try to make more discussions. Haha~.",
                "solutionTags": [],
                "code": "```\\n    public Node connect(Node root) {\\n        if(root == null)return null;\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty()){\\n            int n = queue.size();\\n            while(n-- != 0){\\n                Node cur = queue.poll();\\n                if(cur.left != null){\\n                    queue.add(cur.left);                    \\n                }\\n                if(cur.right != null){\\n                    queue.add(cur.right);   \\n                }\\n                if(n == 0){\\n                    continue;\\n                }\\n                Node next = queue.peek();\\n                cur.next = next; \\n            }\\n        }\\n        return root;\\n    }\\n```\n```\\n    Node last = null, nextStart = null;\\n    public Node connect(Node root) {\\n        if(root == null)return null;\\n        Node start = root;\\n        while(start != null){\\n            //everytime when start begins, the next new line will be connected.\\n            last = null;\\n            nextStart = null;\\n            while(start != null){\\n                if(start.left != null){\\n                    connectNextLine(start.left);\\n                }\\n                if(start.right != null){\\n                    connectNextLine(start.right);\\n                }\\n                start = start.next;\\n            }\\n            start = nextStart;\\n        }\\n        return root;\\n    }\\n    public void connectNextLine(Node start){\\n        if(nextStart == null){\\n            nextStart = start;\\n        }\\n        if(last != null){\\n            last.next = start;\\n        }\\n        last = start;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1438811,
                "title": "c-easy-bfs",
                "content": "The ideea is that to traverse the tree level by level storing the nodes that are on the same level in a queue. The next node to the right is always the next node in the queue. \\n\\nIf you found this helpful please consider leaving an upvote.\\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node*>q;\\n        if(root)\\n        {\\n            q.push(root);\\n        }\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                Node*curr=q.front();\\n                q.pop();\\n                if(i<n-1)\\n                {\\n                    curr->next=q.front();\\n                }\\n                if(curr->left)q.push(curr->left);\\n                if(curr->right)q.push(curr->right);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node*>q;\\n        if(root)\\n        {\\n            q.push(root);\\n        }\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                Node*curr=q.front();\\n                q.pop();\\n                if(i<n-1)\\n                {\\n                    curr->next=q.front();\\n                }\\n                if(curr->left)q.push(curr->left);\\n                if(curr->right)q.push(curr->right);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060083,
                "title": "c-linear-time-no-extra-space-required-with-explanation",
                "content": "Key point:\\n* No need for extra space. Use parent->next to get right child or only child to connect to neighbor on right.\\n* The tricky point is parent\\'s next neighbor may not have kids but the neighbor\\'s next neighbor may have kids.\\n* In that case, we need to keep going toward right down the street until we find a neighbor who got a kid.\\n* In the picture below, parent 4 need to find 5 and from 5 find 7 in order to let kid 8 and kid 9 have a playdate. Parenting is not easy, no kidding :)\\n* In order to be able to keep going right, you got to process right side child first so that your right side neighbor already next link set.\\n```\\n      1\\n    2--->3\\n  4->5---->7\\n8---------->9\\n```\\n```\\n  Node* connect(Node* root) {\\n    if (root) {\\n      if (root->left && root->right)\\n        root->left->next = root->right;\\n      \\n      Node * edge = root->right;\\n      if (!edge)\\n        edge = root->left;\\n      if (edge) {\\n        Node * next = root->next;\\n        while (next) {\\n          if (next->left) {\\n            edge->next = next->left;\\n            break;\\n          }\\n          else if (next->right) {\\n            edge->next = next->right;\\n            break;\\n          }\\n          else\\n            next = next->next;\\n        }\\n      }\\n      connect(root->right);\\n      connect(root->left);\\n    }\\n    return root;\\n  }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n      1\\n    2--->3\\n  4->5---->7\\n8---------->9\\n```\n```\\n  Node* connect(Node* root) {\\n    if (root) {\\n      if (root->left && root->right)\\n        root->left->next = root->right;\\n      \\n      Node * edge = root->right;\\n      if (!edge)\\n        edge = root->left;\\n      if (edge) {\\n        Node * next = root->next;\\n        while (next) {\\n          if (next->left) {\\n            edge->next = next->left;\\n            break;\\n          }\\n          else if (next->right) {\\n            edge->next = next->right;\\n            break;\\n          }\\n          else\\n            next = next->next;\\n        }\\n      }\\n      connect(root->right);\\n      connect(root->left);\\n    }\\n    return root;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 932947,
                "title": "golang-bfs-easy-to-understand-double-100-solution",
                "content": "```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Left *Node\\n *     Right *Node\\n *     Next *Node\\n * }\\n */\\n\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    queue := make([]*Node, 0) //BFS queue\\n    queue = append(queue, root)\\n    \\n    for len(queue) > 0 {\\n        l := len(queue) \\n        for i := 0; i < l; i++ {  //iterate the length of queue only\\n            node := queue[0]\\n            queue = queue[1:]\\n            if i < l - 1 {\\n                node.Next = queue[0] //not the last node in this layer\\n            } else if i == l - 1 {\\n                node.Next = nil //the last node in this layer\\n            }\\n            \\n            if node.Left != nil {\\n                queue = append(queue, node.Left)\\n            }\\n            if node.Right != nil {\\n                queue = append(queue, node.Right)\\n            }\\n        }\\n    }\\n    return root\\n} \\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Left *Node\\n *     Right *Node\\n *     Next *Node\\n * }\\n */\\n\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    queue := make([]*Node, 0) //BFS queue\\n    queue = append(queue, root)\\n    \\n    for len(queue) > 0 {\\n        l := len(queue) \\n        for i := 0; i < l; i++ {  //iterate the length of queue only\\n            node := queue[0]\\n            queue = queue[1:]\\n            if i < l - 1 {\\n                node.Next = queue[0] //not the last node in this layer\\n            } else if i == l - 1 {\\n                node.Next = nil //the last node in this layer\\n            }\\n            \\n            if node.Left != nil {\\n                queue = append(queue, node.Left)\\n            }\\n            if node.Right != nil {\\n                queue = append(queue, node.Right)\\n            }\\n        }\\n    }\\n    return root\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 772944,
                "title": "python-solution-o-n-time-complexity-and-o-1-space",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val: int = 0, left: \\'Node\\' = None, right: \\'Node\\' = None, next: \\'Node\\' = None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\"\"\"\\n\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        prev = tail = None\\n        node = root\\n        \\n        while node:\\n            if node.left:\\n                if prev:\\n                    prev.next = node.left\\n                prev = node.left\\n                if not(tail):\\n                    tail = prev\\n                \\n            if node.right:\\n                if prev:\\n                    prev.next = node.right\\n                prev = node.right\\n                if not(tail):\\n                    tail = prev\\n                \\n            node = node.next\\n            if not node:\\n                node = tail\\n                prev = tail = None\\n                \\n        return root\\n                    \\n```\\n**Please upvote the solution if helpful and feel free to suggest any changes.**",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val: int = 0, left: \\'Node\\' = None, right: \\'Node\\' = None, next: \\'Node\\' = None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\"\"\"\\n\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        prev = tail = None\\n        node = root\\n        \\n        while node:\\n            if node.left:\\n                if prev:\\n                    prev.next = node.left\\n                prev = node.left\\n                if not(tail):\\n                    tail = prev\\n                \\n            if node.right:\\n                if prev:\\n                    prev.next = node.right\\n                prev = node.right\\n                if not(tail):\\n                    tail = prev\\n                \\n            node = node.next\\n            if not node:\\n                node = tail\\n                prev = tail = None\\n                \\n        return root\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 690523,
                "title": "python-iterative-o-1-solution",
                "content": "```\\ncredits to @cmc: Leetcode discussions\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        ## RC ##\\n        ## APPROACH : RECURSION ##\\n        ## Similar to Leetcode 116. Populating Next Right Pointers in Each Node ##    \\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        ## EXAMPLE ##\\n        #                  1\\n        #                 / \\\\\\n        #       root --> 2   3\\n        #               / \\\\   \\\\\\n        # kid -->  (0) 4   5   7    temp = reference to start of this level\\n        # Now dry run the code, you will understand.\\n        \\n        self.root_node = root       # make a copy to return the result\\n        kid = temp = Node(0)        # kid is ptr for traversing the child level, temp is dummy ptr to just store kid starting position\\n        while root:\\n            while root:\\n                if root.left:\\n                    kid.next = root.left\\n                    kid = kid.next\\n                if root.right:\\n                    kid.next = root.right\\n                    kid = kid.next\\n                root = root.next\\n            root, kid = temp.next, temp\\n            kid.next = None         # Reset the chain for temp\\n        return self.root_node\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ncredits to @cmc: Leetcode discussions\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        ## RC ##\\n        ## APPROACH : RECURSION ##\\n        ## Similar to Leetcode 116. Populating Next Right Pointers in Each Node ##    \\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        ## EXAMPLE ##\\n        #                  1\\n        #                 / \\\\\\n        #       root --> 2   3\\n        #               / \\\\   \\\\\\n        # kid -->  (0) 4   5   7    temp = reference to start of this level\\n        # Now dry run the code, you will understand.\\n        \\n        self.root_node = root       # make a copy to return the result\\n        kid = temp = Node(0)        # kid is ptr for traversing the child level, temp is dummy ptr to just store kid starting position\\n        while root:\\n            while root:\\n                if root.left:\\n                    kid.next = root.left\\n                    kid = kid.next\\n                if root.right:\\n                    kid.next = root.right\\n                    kid = kid.next\\n                root = root.next\\n            root, kid = temp.next, temp\\n            kid.next = None         # Reset the chain for temp\\n        return self.root_node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307178,
                "title": "c-iterative-o-1-space-complexity-clear-explanation-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // finds the next node to be connected in the same level\\n    Node* getNextRight(Node* q)\\n    {\\n        Node* temp = q->next;\\n        while(temp!=NULL)\\n        {\\n            if(temp->left)\\n                return temp->left;\\n            if(temp->right)\\n                return temp->right;\\n            temp=temp->next;\\n        }\\n        return NULL;\\n    }\\n    \\n    Node* connect(Node* root) {\\n        if(!root) return NULL;\\n        \\n        //p is for top level, q : for each node in level of p\\n        Node* p = root;\\n        p->next = NULL;\\n        \\n        while(p!=NULL)\\n        {\\n            Node* q = p;\\n            while(q!=NULL)\\n            {\\n                // connect left child\\n                if(q->left)\\n                {\\n                    if(q->right)\\n                        q->left->next = q->right;\\n                    else\\n                        q->left->next = getNextRight(q);                \\n                }\\n                \\n                // connect right child\\n                if(q->right)\\n                    q->right->next = getNextRight(q);\\n                \\n                q = q->next;\\n            }\\n            \\n            // move ahead by one for next level and do the same operations\\n            if(p->left)\\n                p = p->left;\\n            else if(p->right)\\n                p = p->right;\\n            else\\n                p = getNextRight(p);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // finds the next node to be connected in the same level\\n    Node* getNextRight(Node* q)\\n    {\\n        Node* temp = q->next;\\n        while(temp!=NULL)\\n        {\\n            if(temp->left)\\n                return temp->left;\\n            if(temp->right)\\n                return temp->right;\\n            temp=temp->next;\\n        }\\n        return NULL;\\n    }\\n    \\n    Node* connect(Node* root) {\\n        if(!root) return NULL;\\n        \\n        //p is for top level, q : for each node in level of p\\n        Node* p = root;\\n        p->next = NULL;\\n        \\n        while(p!=NULL)\\n        {\\n            Node* q = p;\\n            while(q!=NULL)\\n            {\\n                // connect left child\\n                if(q->left)\\n                {\\n                    if(q->right)\\n                        q->left->next = q->right;\\n                    else\\n                        q->left->next = getNextRight(q);                \\n                }\\n                \\n                // connect right child\\n                if(q->right)\\n                    q->right->next = getNextRight(q);\\n                \\n                q = q->next;\\n            }\\n            \\n            // move ahead by one for next level and do the same operations\\n            if(p->left)\\n                p = p->left;\\n            else if(p->right)\\n                p = p->right;\\n            else\\n                p = getNextRight(p);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37879,
                "title": "simple-c-recursion-with-comments",
                "content": "```\\n    void connect(TreeLinkNode *root) {\\n        if (!root) return;\\n        if (root->left) {\\n            if (root->right) root->left->next = root->right;    // if root has right, then that will be left's next\\n            else root->left->next = find_next(root->next);      // else, walk the root level's next chain\\n        }\\n        if (root->right) root->right->next = find_next(root->next); // walk the root level's next chain\\n        // note that we need to recurse on right first\\n        if (root->right) connect(root->right);\\n        if (root->left) connect(root->left);\\n    }\\n\\n    TreeLinkNode* find_next(TreeLinkNode *root) {\\n        // walk the root level's next chain until the end or we find such a node that has at least one child\\n        while (root && !root->left && !root->right) {\\n            root = root->next;\\n        }\\n        if (root) return root->left ? root->left : root->right;\\n        else return NULL;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void connect(TreeLinkNode *root) {\\n        if (!root) return;\\n        if (root->left) {\\n            if (root->right) root->left->next = root->right;    // if root has right, then that will be left's next\\n            else root->left->next = find_next(root->next);      // else, walk the root level's next chain\\n        }\\n        if (root->right) root->right->next = find_next(root->next); // walk the root level's next chain\\n        // note that we need to recurse on right first\\n        if (root->right) connect(root->right);\\n        if (root->left) connect(root->left);\\n    }\\n\\n    TreeLinkNode* find_next(TreeLinkNode *root) {\\n        // walk the root level's next chain until the end or we find such a node that has at least one child\\n        while (root && !root->left && !root->right) {\\n            root = root->next;\\n        }\\n        if (root) return root->left ? root->left : root->right;\\n        else return NULL;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37902,
                "title": "javascript-real-o-1-solution",
                "content": "```\\nfunction connect(root) {\\n\\tvar prev_to_link = null;\\n\\tvar next_level_head = null;\\n\\tvar curr = root;\\n\\t\\n\\twhile (!!curr) {\\n\\t\\tif (!!curr.left) {\\n\\t\\t\\tif (!!prev_to_link) {\\n\\t\\t\\t\\tprev_to_link.next = curr.left;\\n\\t\\t\\t}\\n\\t\\t\\tprev_to_link = curr.left;\\n\\t\\t\\t\\n\\t\\t\\tif (!next_level_head) {\\n\\t\\t\\t\\tnext_level_head = curr.left;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!!curr.right) {\\n\\t\\t\\tif (!!prev_to_link) {\\n\\t\\t\\t\\tprev_to_link.next = curr.right;\\n\\t\\t\\t}\\n\\t\\t\\tprev_to_link = curr.right;\\n\\t\\t\\t\\n\\t\\t\\tif (!next_level_head) {\\n\\t\\t\\t\\tnext_level_head = curr.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (!!curr.next) {\\n\\t\\t\\tcurr = curr.next;\\n\\t\\t}else {\\n\\t\\t\\tcurr = next_level_head;\\n\\t\\t\\tnext_level_head = null;\\n\\t\\t\\tprev_to_link = null;\\n\\t\\t}\\n\\t}\\n}",
                "solutionTags": [],
                "code": "```\\nfunction connect(root) {\\n\\tvar prev_to_link = null;\\n\\tvar next_level_head = null;\\n\\tvar curr = root;\\n\\t\\n\\twhile (!!curr) {\\n\\t\\tif (!!curr.left) {\\n\\t\\t\\tif (!!prev_to_link) {\\n\\t\\t\\t\\tprev_to_link.next = curr.left;\\n\\t\\t\\t}\\n\\t\\t\\tprev_to_link = curr.left;\\n\\t\\t\\t\\n\\t\\t\\tif (!next_level_head) {\\n\\t\\t\\t\\tnext_level_head = curr.left;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!!curr.right) {\\n\\t\\t\\tif (!!prev_to_link) {\\n\\t\\t\\t\\tprev_to_link.next = curr.right;\\n\\t\\t\\t}\\n\\t\\t\\tprev_to_link = curr.right;\\n\\t\\t\\t\\n\\t\\t\\tif (!next_level_head) {\\n\\t\\t\\t\\tnext_level_head = curr.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (!!curr.next) {\\n\\t\\t\\tcurr = curr.next;\\n\\t\\t}else {\\n\\t\\t\\tcurr = next_level_head;\\n\\t\\t\\tnext_level_head = null;\\n\\t\\t\\tprev_to_link = null;\\n\\t\\t}\\n\\t}\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 37999,
                "title": "clear-c-o-1-space",
                "content": "    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) { //O(1) space\\n            while (root)\\n            {\\n                TreeLinkNode * pre = nullptr;\\n                 for (auto cur = root; cur; cur=cur->next)\\n                 {\\n                     if (cur->left)\\n                     {\\n                         if (pre == nullptr)\\n                             root = cur->left;\\n                         else\\n                             pre->next = cur->left;\\n                         pre = cur->left;\\n                     }\\n                     if (cur->right)\\n                     {\\n                         if (pre == nullptr)\\n                             root = cur->right;\\n                         else\\n                             pre->next = cur->right;\\n                         pre = cur->right;\\n                     }\\n                 }\\n                 if (pre == nullptr) //No next root found.\\n                    break;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) { //O(1) space\\n            while (root)\\n            {\\n                TreeLinkNode * pre = nullptr;\\n                 for (auto cur = root; cur; cur=cur->next)\\n                 {\\n                     if (cur->left)\\n                     {\\n                         if (pre == nullptr)\\n                             root = cur->left;\\n                         else\\n                             pre->next = cur->left;\\n                         pre = cur->left;\\n                     }",
                "codeTag": "Java"
            },
            {
                "id": 3802406,
                "title": "simple-c-solution-using-bfs",
                "content": "### Please upvote if you liked it\\n\\n```\\n    Node* connect(Node* root) {\\n        if(!root){return NULL;}\\n        queue<Node *> q;\\n        root->next=NULL;\\n        q.push(root);\\n        while(!q.empty()){\\n            vector<Node*> v;\\n            int j = 0;\\n            int s=q.size();\\n            for(int i=0;i<s;++i){\\n                Node * temp = q.front();\\n                q.pop();\\n                v.push_back(temp);\\n                if(temp->left){q.push(temp->left);}\\n                if(temp->right){q.push(temp->right);}\\n            }\\n            for(j=0;j<v.size()-1;++j){\\n                v[j]->next = v[j+1];\\n            }\\n            v[j]=NULL;\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n    Node* connect(Node* root) {\\n        if(!root){return NULL;}\\n        queue<Node *> q;\\n        root->next=NULL;\\n        q.push(root);\\n        while(!q.empty()){\\n            vector<Node*> v;\\n            int j = 0;\\n            int s=q.size();\\n            for(int i=0;i<s;++i){\\n                Node * temp = q.front();\\n                q.pop();\\n                v.push_back(temp);\\n                if(temp->left){q.push(temp->left);}\\n                if(temp->right){q.push(temp->right);}\\n            }\\n            for(j=0;j<v.size()-1;++j){\\n                v[j]->next = v[j+1];\\n            }\\n            v[j]=NULL;\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2991123,
                "title": "c-with-logic-bfs-traversal-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/432cfad1-753b-4e75-b6b3-ca008d08ba4f_1672732517.5133998.png)\\n\\n**n==Number of Nodes\\nT->O(n) && S->O(n) [For storing all the Nodes after BFS] + O(n/2) [For queue, worst Case as it\\'s a Perfect Binary Tree]**\\n\\n***Logic -> Level Order Traversal and connect adjacent Nodes!***\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tNode* connect(Node* root) {\\n\\t\\t\\t\\tif(!root) return NULL;\\n\\n\\t\\t\\t\\tvector<vector<Node*>> lvl;\\n\\t\\t\\t\\tqueue <Node*> q;\\n\\t\\t\\t\\tq.push(root);\\n\\n\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\t\\tvector <Node*> temp;\\n\\n\\t\\t\\t\\t\\tfor(int i = 0 ; i < size ; i++){\\n\\t\\t\\t\\t\\t\\tNode* node = q.front();\\n\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\tif(node -> left) q.push(node -> left);\\n\\t\\t\\t\\t\\t\\tif(node -> right) q.push(node -> right);\\n\\t\\t\\t\\t\\t\\ttemp.push_back(node);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttemp.push_back(NULL);\\n\\t\\t\\t\\t\\tlvl.push_back(temp);\\n\\t\\t\\t\\t} \\n\\n\\t\\t\\t\\tfor(int i = 0 ; i < lvl.size() ; i++){\\n\\t\\t\\t\\t\\tfor(int j = 0 ; j < lvl[i].size() - 1 ; j++) lvl[i][j] -> next = lvl[i][j + 1];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tNode* connect(Node* root) {\\n\\t\\t\\t\\tif(!root) return NULL;\\n\\n\\t\\t\\t\\tvector<vector<Node*>> lvl;\\n\\t\\t\\t\\tqueue <Node*> q;\\n\\t\\t\\t\\tq.push(root);\\n\\n\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\t\\tvector <Node*> temp;\\n\\n\\t\\t\\t\\t\\tfor(int i = 0 ; i < size ; i++){\\n\\t\\t\\t\\t\\t\\tNode* node = q.front();\\n\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\tif(node -> left) q.push(node -> left);\\n\\t\\t\\t\\t\\t\\tif(node -> right) q.push(node -> right);\\n\\t\\t\\t\\t\\t\\ttemp.push_back(node);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2531405,
                "title": "python-recursive-solution-using-generators",
                "content": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        def nextChild(root):\\n            if root.left: yield root.left\\n            if root.right: yield root.right\\n            if root.next: yield from nextChild(root.next)\\n            return None\\n            \\n        def connectRec(root):\\n            if not root: return None\\n            prev = None\\n            for child in nextChild(root):\\n                if prev: prev.next = child\\n                prev = child\\n                \\n            connectRec(root.left)\\n            connectRec(root.right)\\n\\n        connectRec(root)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        def nextChild(root):\\n            if root.left: yield root.left\\n            if root.right: yield root.right\\n            if root.next: yield from nextChild(root.next)\\n            return None\\n            \\n        def connectRec(root):\\n            if not root: return None\\n            prev = None\\n            for child in nextChild(root):\\n                if prev: prev.next = child\\n                prev = child\\n                \\n            connectRec(root.left)\\n            connectRec(root.right)\\n\\n        connectRec(root)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979052,
                "title": "c-using-a-dummy-node-bfs",
                "content": "\\n\\n    Node* connect(Node* root) {\\n        if(!root) return NULL;\\n        \\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            Node *prev=new Node();\\n            while(s)\\n            {\\n                Node*cur=q.front();\\n                q.pop();\\n                if(cur->left) q.push(cur->left);\\n                if(cur->right) q.push(cur->right);\\n                if(s==1)\\n                {\\n                    prev->next=cur;\\n                    prev=cur;\\n                    cur->next=NULL;\\n                    break;\\n                }\\n                prev->next=cur;\\n                prev=cur;\\n                \\n                \\n                --s;\\n            }\\n        }\\n        return root;\\n    }\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "\\n\\n    Node* connect(Node* root) {\\n        if(!root) return NULL;\\n        \\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            Node *prev=new Node();\\n            while(s)\\n            {\\n                Node*cur=q.front();\\n                q.pop();\\n                if(cur->left) q.push(cur->left);\\n                if(cur->right) q.push(cur->right);\\n                if(s==1)\\n                {\\n                    prev->next=cur;\\n                    prev=cur;\\n                    cur->next=NULL;\\n                    break;\\n                }\\n                prev->next=cur;\\n                prev=cur;\\n                \\n                \\n                --s;\\n            }\\n        }\\n        return root;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1791031,
                "title": "c-solution-using-level-order-traversal",
                "content": "We can solve both the problems\\n116. Populating Next Right Pointers in Each Node\\n117. Populating Next Right Pointers in Each Node II\\nwith this approach.....\\nHope it helps\\n```\\nNode* connect(Node* root) {\\n        \\n        if(root == NULL) return root;\\n        \\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        \\n        while(!q.empty()){\\n            Node* temp = q.front();\\n            q.pop();\\n            \\n            if(temp == NULL){\\n                if(!q.empty()) q.push(NULL);\\n            }\\n            else{\\n                temp->next = q.front();\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n        }\\n        \\n        return root;\\n        \\n    }\\n\\t```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nNode* connect(Node* root) {\\n        \\n        if(root == NULL) return root;\\n        \\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        \\n        while(!q.empty()){\\n            Node* temp = q.front();\\n            q.pop();\\n            \\n            if(temp == NULL){\\n                if(!q.empty()) q.push(NULL);\\n            }\\n            else{\\n                temp->next = q.front();\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n        }\\n        \\n        return root;\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1492001,
                "title": "beats-100-java-recursive-solution",
                "content": "upvote if you like :)\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n      if(root == null)\\n          return null;\\n       if(root.left == null && root.right == null)\\n           return root;\\n               \\n        if(root.left != null) {\\n            if(root.right != null) {\\n               root.left.next = root.right;  \\n            }             \\n            else {\\n                if(root.next != null) {\\n                    root.left.next = adjacentRightNode(root.next);\\n                }\\n            }\\n        }\\n        \\n        if(root.right != null) {\\n            root.right.next = adjacentRightNode(root.next);\\n        }\\n        \\n       \\n      connect(root.right);\\n      connect(root.left);\\n       return root; \\n    }\\n    \\n    public Node adjacentRightNode(Node root) {\\n        Node temp = root;\\n        while(temp != null) {\\n            if(temp.left == null && temp.right == null) {\\n                temp = temp.next;\\n            }\\n            else{\\n                if(temp.left != null) return temp.left;\\n                if(temp.right != null) return temp.right;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n      if(root == null)\\n          return null;\\n       if(root.left == null && root.right == null)\\n           return root;\\n               \\n        if(root.left != null) {\\n            if(root.right != null) {\\n               root.left.next = root.right;  \\n            }             \\n            else {\\n                if(root.next != null) {\\n                    root.left.next = adjacentRightNode(root.next);\\n                }\\n            }\\n        }\\n        \\n        if(root.right != null) {\\n            root.right.next = adjacentRightNode(root.next);\\n        }\\n        \\n       \\n      connect(root.right);\\n      connect(root.left);\\n       return root; \\n    }\\n    \\n    public Node adjacentRightNode(Node root) {\\n        Node temp = root;\\n        while(temp != null) {\\n            if(temp.left == null && temp.right == null) {\\n                temp = temp.next;\\n            }\\n            else{\\n                if(temp.left != null) return temp.left;\\n                if(temp.right != null) return temp.right;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448257,
                "title": "python3-in-place-bfs-solution-faster-than-97",
                "content": "- We handle this problem with BFS.\\n- Our objective is to change each node\\'s \\'next\\' attribute, and point to the next sibling. (if exists)\\n- We also use an extra pointer to record the previous node.\\n- If there is no previous node, the current node will be the head among the siblings.\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        parents = [root] \\n        kids = []\\n        prev = None\\n        while len(parents) > 0:\\n            p = parents.pop(0)\\n            if prev:\\n                prev.next = p\\n            prev = p\\n            if p:\\n                if p.left:\\n                    kids.append(p.left)\\n                if p.right:\\n                    kids.append(p.right)\\n            if len(parents) == 0:\\n                parents = kids\\n                kids = []\\n                prev = None\\n        return root\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        parents = [root] \\n        kids = []\\n        prev = None\\n        while len(parents) > 0:\\n            p = parents.pop(0)\\n            if prev:\\n                prev.next = p\\n            prev = p\\n            if p:\\n                if p.left:\\n                    kids.append(p.left)\\n                if p.right:\\n                    kids.append(p.right)\\n            if len(parents) == 0:\\n                parents = kids\\n                kids = []\\n                prev = None\\n        return root\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426479,
                "title": "javascript-easy-solution-using-bfs",
                "content": "```\\nvar connect = function (root) {\\n    if (root === null) return root;\\n    \\n    const level = 0;\\n    const queue = [[root, level]];\\n    \\n    while (queue.length) {\\n        const [current, level] = queue.shift();\\n        \\n        if (queue.length) {\\n            const [next, nextLevel] = queue[0];\\n            if (level === nextLevel) {\\n                current.next = next;\\n            }\\n        }\\n        if (current.left) queue.push([current.left, level+1]);\\n        if (current.right) queue.push([current.right, level+1]); \\n    }\\n    \\n    \\n    \\n    return root;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar connect = function (root) {\\n    if (root === null) return root;\\n    \\n    const level = 0;\\n    const queue = [[root, level]];\\n    \\n    while (queue.length) {\\n        const [current, level] = queue.shift();\\n        \\n        if (queue.length) {\\n            const [next, nextLevel] = queue[0];\\n            if (level === nextLevel) {\\n                current.next = next;\\n            }\\n        }\\n        if (current.left) queue.push([current.left, level+1]);\\n        if (current.right) queue.push([current.right, level+1]); \\n    }\\n    \\n    \\n    \\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1331987,
                "title": "javascript-dfs-simple-solution",
                "content": "**Solution**\\n- uses nearly identical code as [populating-next-right-pointers-in-each-node-ii](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/1331976/Javascript-DFS-readable-solution)\\n\\n\\n```\\nvar connect = function (root) {\\n    if (!root) return root;\\n    let queue = [root];\\n    \\n    while (queue.length) {\\n        let current_level_length = queue.length;\\n        let next_level_nodes = [];\\n\\n        for(let i=0; i < current_level_length; i++){\\n            let node = queue.shift();\\n            node.next = queue[0] || null;\\n            \\n            if(node.left)  next_level_nodes.push(node.left)\\n            if(node.right) next_level_nodes.push(node.right)\\n        }\\n        queue = next_level_nodes;\\n    }\\n    return root;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar connect = function (root) {\\n    if (!root) return root;\\n    let queue = [root];\\n    \\n    while (queue.length) {\\n        let current_level_length = queue.length;\\n        let next_level_nodes = [];\\n\\n        for(let i=0; i < current_level_length; i++){\\n            let node = queue.shift();\\n            node.next = queue[0] || null;\\n            \\n            if(node.left)  next_level_nodes.push(node.left)\\n            if(node.right) next_level_nodes.push(node.right)\\n        }\\n        queue = next_level_nodes;\\n    }\\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961972,
                "title": "a-c-solution-which-ticks-the-follow-up-boxes",
                "content": "```\\nNode* connect(Node* root, Node* parent = nullptr) {\\n  if (!root) return nullptr;\\n\\n \\xA0// We assume that parent\\'s level is finished on the right, and try to connect\\n  // root.\\n  //\\n  // First, if root is parent\\'s left child and parent\\'s right child exists, that\\'s\\n  // the obvious root->next.\\n  if (parent && parent->left == root && parent->right) {\\n    root->next = parent->right;\\n  }\\n  // Otherwise, let\\'s traverse parent\\'s next chain and look for children of\\n  // those nodes.\\n  if (parent && !root->next) {\\n    for (auto pp = parent->next; pp; pp=pp->next) {\\n      if (pp->left) {\\n        root->next = pp->left;\\n        break;\\n      }\\n      if (pp->right) {\\n        root->next = pp->right;\\n        break;\\n      }\\n    }\\n  }\\n\\n  // Right first is what justifies the assumption above.\\n  connect(root->right, root);\\n  connect(root->left, root);\\n\\n  return root;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nNode* connect(Node* root, Node* parent = nullptr) {\\n  if (!root) return nullptr;\\n\\n \\xA0// We assume that parent\\'s level is finished on the right, and try to connect\\n  // root.\\n  //\\n  // First, if root is parent\\'s left child and parent\\'s right child exists, that\\'s\\n  // the obvious root->next.\\n  if (parent && parent->left == root && parent->right) {\\n    root->next = parent->right;\\n  }\\n  // Otherwise, let\\'s traverse parent\\'s next chain and look for children of\\n  // those nodes.\\n  if (parent && !root->next) {\\n    for (auto pp = parent->next; pp; pp=pp->next) {\\n      if (pp->left) {\\n        root->next = pp->left;\\n        break;\\n      }\\n      if (pp->right) {\\n        root->next = pp->right;\\n        break;\\n      }\\n    }\\n  }\\n\\n  // Right first is what justifies the assumption above.\\n  connect(root->right, root);\\n  connect(root->left, root);\\n\\n  return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942181,
                "title": "recursive-solution-java",
                "content": "I was reading an interview experience, in which the interviewer specifically asked the candidate to solve this problem using a recursive approach. \\n\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        connectRecur(root);\\n        return root;\\n    }\\n    public void connectRecur(Node root){\\n        if(root == null || root.left == null && root.right==null){\\n            return;\\n        }\\n        if(root.right!=null){\\n            root.right.next = getNext(root.next);\\n        }\\n        if(root.left!=null){\\n            if(root.right!=null){\\n                root.left.next = root.right;\\n            }else{\\n                root.left.next = getNext(root.next);\\n            }\\n        }\\n        \\n        connectRecur(root.right);\\n        connectRecur(root.left);\\n    }\\n    public Node getNext(Node node){\\n        while(node!=null){\\n            if(node.left!=null){\\n                return node.left;\\n            }\\n            if(node.right!=null){\\n                return node.right;\\n            }\\n            node = node.next;\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        connectRecur(root);\\n        return root;\\n    }\\n    public void connectRecur(Node root){\\n        if(root == null || root.left == null && root.right==null){\\n            return;\\n        }\\n        if(root.right!=null){\\n            root.right.next = getNext(root.next);\\n        }\\n        if(root.left!=null){\\n            if(root.right!=null){\\n                root.left.next = root.right;\\n            }else{\\n                root.left.next = getNext(root.next);\\n            }\\n        }\\n        \\n        connectRecur(root.right);\\n        connectRecur(root.left);\\n    }\\n    public Node getNext(Node node){\\n        while(node!=null){\\n            if(node.left!=null){\\n                return node.left;\\n            }\\n            if(node.right!=null){\\n                return node.right;\\n            }\\n            node = node.next;\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916769,
                "title": "easiest-approach-level-order-traversal",
                "content": "**Store all nodes in queue at specific level and Just use stack  for pointing next element**\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n\\t\\t  if(root==NULL)\\n\\t\\t\\t\\treturn NULL;\\n         queue<Node*>qe;\\n         qe.push(root);\\n         stack<Node*>st; \\n         while(!qe.empty())\\n         {\\n            Node *pre=NULL;\\n            int n=qe.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                Node* r=qe.front();\\n                qe.pop();       st.push(r);\\n               if(r->left!=NULL)\\n\\t\\t\\t\\t\\tqe.push(r->left);\\n               if(r->right!=NULL)\\n\\t\\t\\t\\t\\tqe.push(r->right);   \\n         }\\n            while(!st.empty())\\n            {\\n                Node* r=st.top();\\n                st.pop();\\n                r->next=pre;\\n                pre=r;\\n            } \\n        } \\n\\t\\t\\treturn root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n\\t\\t  if(root==NULL)\\n\\t\\t\\t\\treturn NULL;\\n         queue<Node*>qe;\\n         qe.push(root);\\n         stack<Node*>st; \\n         while(!qe.empty())\\n         {\\n            Node *pre=NULL;\\n            int n=qe.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                Node* r=qe.front();\\n                qe.pop();       st.push(r);\\n               if(r->left!=NULL)\\n\\t\\t\\t\\t\\tqe.push(r->left);\\n               if(r->right!=NULL)\\n\\t\\t\\t\\t\\tqe.push(r->right);   \\n         }\\n            while(!st.empty())\\n            {\\n                Node* r=st.top();\\n                st.pop();\\n                r->next=pre;\\n                pre=r;\\n            } \\n        } \\n\\t\\t\\treturn root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513812,
                "title": "dfs-solution",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        dfs(root);\\n        return root;\\n    }\\n    \\n    public void dfs(Node root){\\n        if(root == null) return;\\n        if(root.right != null){\\n            if(root.left != null) root.left.next = root.right;\\n            root.right.next = find_next(root.next);\\n        }else if(root.left != null) root.left.next = find_next(root.next);\\n        \\n        dfs(root.right); // right side first\\n        dfs(root.left);\\n        \\n    }\\n\\n    \\n    public Node find_next(Node next){\\n        while(next != null){\\n            if(next.left != null) return next.left;\\n            if(next.right != null) return next.right;\\n            next = next.next;\\n        }\\n        return null;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        dfs(root);\\n        return root;\\n    }\\n    \\n    public void dfs(Node root){\\n        if(root == null) return;\\n        if(root.right != null){\\n            if(root.left != null) root.left.next = root.right;\\n            root.right.next = find_next(root.next);\\n        }else if(root.left != null) root.left.next = find_next(root.next);\\n        \\n        dfs(root.right); // right side first\\n        dfs(root.left);\\n        \\n    }\\n\\n    \\n    public Node find_next(Node next){\\n        while(next != null){\\n            if(next.left != null) return next.left;\\n            if(next.right != null) return next.right;\\n            next = next.next;\\n        }\\n        return null;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369641,
                "title": "clean-python-o-1-space-pass-the-updated-test-cases-55-55",
                "content": "```\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        cur = dummy = Node()\\n        node = root\\n        while node:\\n            if node.left:\\n                cur.next = node.left\\n                cur = node.left\\n            if node.right:\\n                cur.next = node.right\\n                cur = node.right\\n            node = node.next\\n            if not node:\\n                node = dummy.next\\n                dummy.next = None # This is very important!!!\\n                cur = dummy # This is very important!!!\\n        return root\\n```\\nReset \"cur\" and \"dummy\" is very important.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        cur = dummy = Node()\\n        node = root\\n        while node:\\n            if node.left:\\n                cur.next = node.left\\n                cur = node.left\\n            if node.right:\\n                cur.next = node.right\\n                cur = node.right\\n            node = node.next\\n            if not node:\\n                node = dummy.next\\n                dummy.next = None # This is very important!!!\\n                cur = dummy # This is very important!!!\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305061,
                "title": "easy-to-understand-bfs-solution-using-java",
                "content": "Straightforward and self explaining Java using BFS. We modify BFS just enough to accomplish the task. The same concept of queue/linkedlist is used to enque the current level\\'s children into the q. The use of size of q to restrict the loop is typical level order. Within each level, we just keep a prev pointer that links the node to its right using the level order traversal. The prev pointer is initially null for each level and is set to the current after seeing the first node for that level. From the next node onwards, prev.next = curr - causing it to set the next pointers without much difficulty - using level order traversal. finally for the last one in level order for each level - the right pointer is null.\\nIf you like it, please up vote!\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n\\n    public Node(int _val,Node _left,Node _right,Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return root;\\n        \\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(root);\\n        while (!q.isEmpty()){\\n            int sz = q.size();\\n            Node prev = null;\\n            for(int i = 0; i < sz;i++){\\n                Node curr = q.poll();\\n                if (prev != null){\\n                    prev.next = curr; \\n                }\\n                prev = curr;\\n                if (curr.left != null)\\n                    q.offer(curr.left);\\n                if (curr.right != null)\\n                    q.offer(curr.right);\\n            }\\n            prev.next = null;\\n        }\\n        return root;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n\\n    public Node(int _val,Node _left,Node _right,Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return root;\\n        \\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(root);\\n        while (!q.isEmpty()){\\n            int sz = q.size();\\n            Node prev = null;\\n            for(int i = 0; i < sz;i++){\\n                Node curr = q.poll();\\n                if (prev != null){\\n                    prev.next = curr; \\n                }\\n                prev = curr;\\n                if (curr.left != null)\\n                    q.offer(curr.left);\\n                if (curr.right != null)\\n                    q.offer(curr.right);\\n            }\\n            prev.next = null;\\n        }\\n        return root;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304245,
                "title": "o-3-space-solution-beats-100-with-comments",
                "content": "```\\n/**\\n    Steps include. \\n    1. When you are at current level, connect all nodes of the children level \\n    with the next pointer. \\n    2. To traverse to the next node use the information of next node and perform the same above operation. \\n    3. To traverse across different level , keep track of the pointer information of the first node \\n       to continue. \\n       \\n    In simple terms, this is a level order traversal without using a queue for storage. \\n    Instead using the next data information of the nodes. \\n    **/\\n\\t\\nclass Solution {\\n    \\n    public Node connect(Node root) {\\n        if(root == null) {\\n            return root;\\n        }\\n        Node cur = root;\\n        Node prev = null;\\n        Node first = null;\\n        while(cur != null) {\\n            Node left = cur.left;\\n            Node right = cur.right;\\n            if(left != null) {\\n                if(prev == null) {\\n                    prev = left;\\n                    first = prev;\\n                } else {\\n                    prev.next = left;\\n                    prev = left;    \\n                }\\n            } \\n            if(right != null) {\\n                if(prev == null) {\\n                    prev = right;\\n                    first = prev;\\n                } else {\\n                    prev.next = right;\\n                    prev = right;\\n                }\\n            }\\n\\n            cur = cur.next;\\n            if(cur == null) {\\n                cur = first;\\n                prev = null;\\n                first = null;\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n    Steps include. \\n    1. When you are at current level, connect all nodes of the children level \\n    with the next pointer. \\n    2. To traverse to the next node use the information of next node and perform the same above operation. \\n    3. To traverse across different level , keep track of the pointer information of the first node \\n       to continue. \\n       \\n    In simple terms, this is a level order traversal without using a queue for storage. \\n    Instead using the next data information of the nodes. \\n    **/\\n\\t\\nclass Solution {\\n    \\n    public Node connect(Node root) {\\n        if(root == null) {\\n            return root;\\n        }\\n        Node cur = root;\\n        Node prev = null;\\n        Node first = null;\\n        while(cur != null) {\\n            Node left = cur.left;\\n            Node right = cur.right;\\n            if(left != null) {\\n                if(prev == null) {\\n                    prev = left;\\n                    first = prev;\\n                } else {\\n                    prev.next = left;\\n                    prev = left;    \\n                }\\n            } \\n            if(right != null) {\\n                if(prev == null) {\\n                    prev = right;\\n                    first = prev;\\n                } else {\\n                    prev.next = right;\\n                    prev = right;\\n                }\\n            }\\n\\n            cur = cur.next;\\n            if(cur == null) {\\n                cur = first;\\n                prev = null;\\n                first = null;\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279993,
                "title": "simple-recursive-java-pre-order-traversal-solution-that-beats-100-and-is-easy-to-understand",
                "content": "```java\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n\\n    public Node(int _val,Node _left,Node _right,Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\nclass Solution {\\n    public Node connect(Node root) {\\n        dfs(root, null);\\n        return root;\\n    }\\n    \\n    private void dfs(Node root, Node next) {\\n        if (root == null) return;\\n        \\n        root.next = next;\\n        \\n        while (next != null) {\\n            if (next.left != null || next.right != null) break;\\n            else next = next.next;\\n        }\\n        \\n        if (root.right != null) {\\n            dfs(root.right, next == null ? null : next.left != null ? next.left : next.right);\\n            dfs(root.left, root.right);\\n        } else {\\n            dfs(root.left, next == null ? null : next.left != null ? next.left : next.right);\\n        }\\n    }\\n}\\n```\\nHappy Coding\\uFF5E",
                "solutionTags": [],
                "code": "```java\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n\\n    public Node(int _val,Node _left,Node _right,Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\nclass Solution {\\n    public Node connect(Node root) {\\n        dfs(root, null);\\n        return root;\\n    }\\n    \\n    private void dfs(Node root, Node next) {\\n        if (root == null) return;\\n        \\n        root.next = next;\\n        \\n        while (next != null) {\\n            if (next.left != null || next.right != null) break;\\n            else next = next.next;\\n        }\\n        \\n        if (root.right != null) {\\n            dfs(root.right, next == null ? null : next.left != null ? next.left : next.right);\\n            dfs(root.left, root.right);\\n        } else {\\n            dfs(root.left, next == null ? null : next.left != null ? next.left : next.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37833,
                "title": "python-o-1-space-solution-with-generator",
                "content": "It is common BSF but I use a generator `getLinkedList` to mock a linked list. \\n\\nWith `getLinkedList`, we can treat the current level as a linked list although it is not linked yet. We only have to traverse the current level and link all the nodes in it.\\n\\n**Python**\\n```\\nclass Solution:\\n    # @param root, a tree link node\\n    # @return nothing\\n    def connect(self, root):\\n        head = root\\n        \\n        while head:\\n            next_head = None\\n            for node in Solution.getLinkedList(head):\\n                if not next_head:\\n                    next_head = cur = node\\n                else:\\n                    cur.next = cur = node\\n            head = next_head\\n            \\n    \\n    @staticmethod\\n    def getLinkedList(head):\\n        while head:\\n            for node in head.left, head.right:\\n                if node:\\n                    yield node\\n            head = head.next\\n\\n# 61 / 61 test cases passed.\\n# Status: Accepted\\n# Runtime: 88 ms\\n# 90.53%\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    # @param root, a tree link node\\n    # @return nothing\\n    def connect(self, root):\\n        head = root\\n        \\n        while head:\\n            next_head = None\\n            for node in Solution.getLinkedList(head):\\n                if not next_head:\\n                    next_head = cur = node\\n                else:\\n                    cur.next = cur = node\\n            head = next_head\\n            \\n    \\n    @staticmethod\\n    def getLinkedList(head):\\n        while head:\\n            for node in head.left, head.right:\\n                if node:\\n                    yield node\\n            head = head.next\\n\\n# 61 / 61 test cases passed.\\n# Status: Accepted\\n# Runtime: 88 ms\\n# 90.53%\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37868,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Populating Next Right Pointers in Each Node II** https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\n**Algorithm to connect node **\\n*  Given level x is connected, just connect level x+1.\\n*  Use the concept of sentinel node - just like in a link list\\n\\n```\\nclass Solution(object):\\n    def connect(self, root):\\n        while root:\\n            root = self.connect_children(root)\\n        return\\n    \\n    def connect_children(self, root):\\n        temp = TreeLinkNode(-1)\\n        curr = temp\\n        while root:\\n            if root.left:\\n                curr.next = root.left\\n                curr = curr.next\\n            if root.right:\\n                curr.next = root.right\\n                curr = curr.next\\n            root = root.next\\n        return temp.next\\n```\\n\\n**Pre-order Algorithm**\\n1. Use pre-order traversal with a twist. First connect the left and right children. Then use neighbor chain of current level to connect the node to next sibling.\\n2. connect - node.right\\n3. connect - node.left\\n4. You need to connect node.right first - why? iDeserve video has a good example. The idea is that the chain at current level must be complete before we can connect the level below.\\n\\n```\\nclass Solution(object):\\n    def connect(self, root):\\n        while root:\\n            root = self.connect_preorder(root)\\n        return\\n\\n    def connect_preorder(self, root):\\n        \"\"\"\\n        :type root: TreeLinkNode\\n        :rtype: nothing\\n        \"\"\"\\n        if root == None or (root.left == None and root.right == None): # root is none or a leaf\\n            return\\n        if root.left and root.right: # Both children present\\n            root.left.next = root.right\\n            prev = root.right\\n        else:\\n            prev = root.right if root.right else root.left\\n        cur = root.next\\n        while cur:\\n            if cur.left:\\n                prev.next = cur.left\\n                break\\n            elif cur.right:\\n                prev.next = cur.right\\n                break\\n            else:\\n                cur = cur.next\\n        self.connect(root.right)\\n        self.connect(root.left)        \\n        return\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def connect(self, root):\\n        while root:\\n            root = self.connect_children(root)\\n        return\\n    \\n    def connect_children(self, root):\\n        temp = TreeLinkNode(-1)\\n        curr = temp\\n        while root:\\n            if root.left:\\n                curr.next = root.left\\n                curr = curr.next\\n            if root.right:\\n                curr.next = root.right\\n                curr = curr.next\\n            root = root.next\\n        return temp.next\\n```\n```\\nclass Solution(object):\\n    def connect(self, root):\\n        while root:\\n            root = self.connect_preorder(root)\\n        return\\n\\n    def connect_preorder(self, root):\\n        \"\"\"\\n        :type root: TreeLinkNode\\n        :rtype: nothing\\n        \"\"\"\\n        if root == None or (root.left == None and root.right == None): # root is none or a leaf\\n            return\\n        if root.left and root.right: # Both children present\\n            root.left.next = root.right\\n            prev = root.right\\n        else:\\n            prev = root.right if root.right else root.left\\n        cur = root.next\\n        while cur:\\n            if cur.left:\\n                prev.next = cur.left\\n                break\\n            elif cur.right:\\n                prev.next = cur.right\\n                break\\n            else:\\n                cur = cur.next\\n        self.connect(root.right)\\n        self.connect(root.left)        \\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37884,
                "title": "c-solution-9ms",
                "content": "We do a level-by-level traversal. On each level, the parent pointer walks from left to right. On each walk, the parent points the previous child's next pointer to its children (if any, i.e left and/or right child). Initially the previous child pointer is set to a dummy node. This makes sure that the dummy node always points to the left most child in the level right below the parent.\\n\\nWhen we're done traversing the current level (i.e the inner while loop), we want to point our parent (left most) pointer to the leftmost child, in order to process the level below. This is achieved by resetting the left most parent pointer to the dummy node.  \\n```c\\nvoid connect(struct TreeLinkNode *root) {\\n    if (!root) return;\\n    struct TreeLinkNode *parent, *child, *leftMostParent = root, dummy = {0};\\n    while (leftMostParent) {\\n        parent = leftMostParent;\\n        child = &dummy;\\n        while (parent) {\\n            if (parent->left) {\\n                child->next = parent->left;\\n                child = child->next;\\n            }\\n            if (parent->right) {\\n                child->next = parent->right;\\n                child = child->next;\\n            }\\n            parent = parent->next;\\n        }\\n        leftMostParent = dummy.next;\\n        dummy.next = NULL;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```c\\nvoid connect(struct TreeLinkNode *root) {\\n    if (!root) return;\\n    struct TreeLinkNode *parent, *child, *leftMostParent = root, dummy = {0};\\n    while (leftMostParent) {\\n        parent = leftMostParent;\\n        child = &dummy;\\n        while (parent) {\\n            if (parent->left) {\\n                child->next = parent->left;\\n                child = child->next;\\n            }\\n            if (parent->right) {\\n                child->next = parent->right;\\n                child = child->next;\\n            }\\n            parent = parent->next;\\n        }\\n        leftMostParent = dummy.next;\\n        dummy.next = NULL;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38057,
                "title": "where-did-i-get-wrong-java",
                "content": "I understand the code doesn't look concise or pretty. However, it pases 34/61 cases. And I'm not sure where is the problem. Since there are cases before No.34 that has several nodes.next() has no child, and the code passed those cases. I don't know how could it miss those two 8s in this case.\\n\\nAny help would be appreciated.\\n\\n\\n34 / 61 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 14 minutes ago\\nInput:\\t{2,1,3,0,7,9,1,2,#,1,0,#,#,8,8,#,#,#,#,7}\\nOutput:\\t{2,#,1,3,#,0,7,9,1,#,2,1,0,#,7,#}\\nExpected:\\t{2,#,1,3,#,0,7,9,1,#,2,1,0,8,8,#,7,#}\\n\\n \\n\\n       /**\\n     * Definition for binary tree with next pointer.\\n     * public class TreeLinkNode {\\n     *     int val;\\n     *     TreeLinkNode left, right, next;\\n     *     TreeLinkNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if(root==null||(root.left==null&&root.right==null)) return;\\n            \\n            if(root.left!=null){                                                            //root.left!=null\\n                if(root.right!=null){                                                           //root.left&right!=null     left->right\\n                root.left.next=root.right;\\n                if(root.next==null) root.right.next=null;\\n                else{                                                                           //root.left!=null,right==null left->next.left/right\\n                    TreeLinkNode temp=root;\\n                    while(temp.next.next!=null) {                                               //while loop to skip the next() that has no child\\n                        if(temp.next.left==null&&temp.next.right==null) temp=temp.next;\\n                        else break;\\n                    }\\n                        if(temp.next.left==null&&temp.next.right==null) root.right.next=null;\\n                        else{\\n                            if(temp.next.left!=null) root.right.next=temp.next.left;\\n                            else root.right.next=temp.next.right;\\n                        }\\n                }\\n                }else{                                                                      //Same for root.left!=null + root.right==null\\n                    if(root.next==null) root.left.next=null;\\n                    else{\\n                        TreeLinkNode temp=root;\\n                        while(temp.next.next!=null) {if(temp.next.left==null&&temp.next.right==null) temp=temp.next; else break;}\\n                        if(temp.next.left==null&&temp.next.right==null) root.left.next=null;\\n                        else{\\n                            if(temp.next.left!=null) root.left.next=temp.next.left;\\n                            else root.left.next=temp.next.right;\\n                        }\\n                    }\\n                }\\n            }else{                                                                          //Same procedure for root.left==null, root.right!=null\\n                if(root.next==null) root.right.next=null;\\n                else{\\n                    TreeLinkNode temp=root;\\n                    while(temp.next.next!=null) {if(temp.next.left==null&&temp.next.right==null) temp=temp.next; else break;}\\n                        if(temp.next.left==null&&temp.next.right==null) root.right.next=null;\\n                        else{\\n                            if(temp.next.left!=null) root.right.next=temp.next.left;\\n                            else root.right.next=temp.next.right;\\n                        }\\n                }\\n            }\\n            connect(root.left);                                                             //Continue moving nodes downward.\\n            connect(root.right);\\n            return;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if(root==null||(root.left==null&&root.right==null)) return;\\n            \\n            if(root.left!=null){                                                            //root.left!=null\\n                if(root.right!=null){                                                           //root.left&right!=null     left->right\\n                root.left.next=root.right;\\n                if(root.next==null) root.right.next=null;\\n                else{                                                                           //root.left!=null,right==null left->next.left/right\\n                    TreeLinkNode temp=root;\\n                    while(temp.next.next!=null) {                                               //while loop to skip the next() that has no child\\n                        if(temp.next.left==null&&temp.next.right==null) temp=temp.next;\\n                        else break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3771036,
                "title": "java-the-simplest-solution-bfs",
                "content": "# Complexity\\n- Time complexity:\\nO(V+E)\\n\\n- Space complexity:\\nO(V)\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        bfs(root);\\n        return root;\\n    }\\n\\n    private void bfs(Node root) {\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            Node previousRight = null;\\n            for (int i = 0; i < size; i++) {\\n                Node node = queue.poll();\\n                \\n                node.next = previousRight;\\n                previousRight = node;\\n                \\n                if (node.right != null) {\\n                    queue.add(node.right);\\n                }\\n                if (node.left != null) {\\n                    queue.add(node.left);\\n                }\\n            }\\n            previousRight = null;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        bfs(root);\\n        return root;\\n    }\\n\\n    private void bfs(Node root) {\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            Node previousRight = null;\\n            for (int i = 0; i < size; i++) {\\n                Node node = queue.poll();\\n                \\n                node.next = previousRight;\\n                previousRight = node;\\n                \\n                if (node.right != null) {\\n                    queue.add(node.right);\\n                }\\n                if (node.left != null) {\\n                    queue.add(node.left);\\n                }\\n            }\\n            previousRight = null;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541960,
                "title": "117-populating-next-right-pointers-in-each-node-ii",
                "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root)   return NULL;\\n        queue<Node*> p;\\n        p.push(root);\\n        p.push(NULL);\\n        while(!p.empty()){\\n            Node* front = p.front();\\n            p.pop();\\n            if(front){\\n                front -> next = p.front();\\n                if(front -> left)   p.push(front -> left);\\n                if(front -> right)  p.push(front -> right);\\n            }else{\\n                if(p.empty())   break;\\n                p.push(NULL);\\n            }            \\n        }return root;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root)   return NULL;\\n        queue<Node*> p;\\n        p.push(root);\\n        p.push(NULL);\\n        while(!p.empty()){\\n            Node* front = p.front();\\n            p.pop();\\n            if(front){\\n                front -> next = p.front();\\n                if(front -> left)   p.push(front -> left);\\n                if(front -> right)  p.push(front -> right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3298243,
                "title": "easy-c-solution-level-order-traversal-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter reading this question, we should get the intuition that we need to apply level order traversal along with some update in the algo.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf we observe the output we can observe below points\\n1. If the root exists we need to add root->next to nullptr.\\n2. If we have left and right child for the specific node, then rightmost child next should be nullptr.\\n3. If we have left and right child for any specific node, and it is not the rightmost child then update left child next with right child.\\n4. For getting the right most child we can apply the technique\\n (i == n-1) since we are using queue and the last element in the queue should be rightmost element. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return nullptr;\\n        queue<Node*> q;\\n\\n        q.push(root);\\n        while(q.size()>0)\\n        {\\n            int n = q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                Node* temp = q.front();\\n                q.pop();\\n                if(i==n-1) temp->next = nullptr;\\n                else\\n                {\\n                    temp->next = q.front();\\n                }\\n                if(temp->left!=nullptr) q.push(temp->left);\\n                if(temp->right!=nullptr) q.push(temp->right);\\n\\n\\n            }\\n        }\\n        return root;\\n\\n        \\n    }\\n};\\n```\\n# IF THIS CODE  IS HELPFUL,  THEN  PLEASE UPVOTE!!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return nullptr;\\n        queue<Node*> q;\\n\\n        q.push(root);\\n        while(q.size()>0)\\n        {\\n            int n = q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                Node* temp = q.front();\\n                q.pop();\\n                if(i==n-1) temp->next = nullptr;\\n                else\\n                {\\n                    temp->next = q.front();\\n                }\\n                if(temp->left!=nullptr) q.push(temp->left);\\n                if(temp->right!=nullptr) q.push(temp->right);\\n\\n\\n            }\\n        }\\n        return root;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791318,
                "title": "c-level-order-traversal",
                "content": "# Intuition\\nNodes of a level are connected so level order traversal\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- Level order traversal\\n- keep connecting nodes of a level with next ptr\\n- at the end of each level do null\\n- keft and right child in q\\n\\n# Complexity\\n- Time complexity: \\nTC : O(N) \\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nSC : O(N)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\n/*\\n\\n- Level order traversal\\n- keep connecting nodes of a level with next ptr\\n- at the end of each level do null\\nTC : O(N) \\nSC : O(N)\\n\\n*/\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        queue<Node*> q;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                auto p = q.front();\\n                q.pop();\\n\\n                // if its the last node of level\\n                if(s==0)\\n                p->next = NULL; // its next is null\\n                else \\n                p->next = q.front(); // else its next is front of q\\n                \\n                if(p->left) q.push(p->left);\\n                if(p->right) q.push(p->right);\\n\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\n/*\\n\\n- Level order traversal\\n- keep connecting nodes of a level with next ptr\\n- at the end of each level do null\\nTC : O(N) \\nSC : O(N)\\n\\n*/\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        queue<Node*> q;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                auto p = q.front();\\n                q.pop();\\n\\n                // if its the last node of level\\n                if(s==0)\\n                p->next = NULL; // its next is null\\n                else \\n                p->next = q.front(); // else its next is front of q\\n                \\n                if(p->left) q.push(p->left);\\n                if(p->right) q.push(p->right);\\n\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584507,
                "title": "java-easy-solution",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root==null){\\n            return root;\\n        }\\n        Queue<Node> q = new LinkedList<Node>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            List<Node> cur = new ArrayList<Node>();\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                Node temp = q.poll();\\n                cur.add(temp);\\n                if(i>0){\\n                    Node node = cur.get(i-1);\\n                    node.next=temp;\\n                }\\n                if(temp.left!=null){\\n                    q.add(temp.left);\\n                }\\n                if(temp.right!=null){\\n                    q.add(temp.right);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\\n# upvote if u found it useful",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root==null){\\n            return root;\\n        }\\n        Queue<Node> q = new LinkedList<Node>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            List<Node> cur = new ArrayList<Node>();\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                Node temp = q.poll();\\n                cur.add(temp);\\n                if(i>0){\\n                    Node node = cur.get(i-1);\\n                    node.next=temp;\\n                }\\n                if(temp.left!=null){\\n                    q.add(temp.left);\\n                }\\n                if(temp.right!=null){\\n                    q.add(temp.right);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151085,
                "title": "unable-to-run-test",
                "content": "Hello everyone. I am receiving and error while running very simple code. How can I fix it?\\n```\\n/**\\n * // Definition for a Node.\\n * function Node(val, left, right, next) {\\n *    this.val = val === undefined ? null : val;\\n *    this.left = left === undefined ? null : left;\\n *    this.right = right === undefined ? null : right;\\n *    this.next = next === undefined ? null : next;\\n * };\\n */\\n\\n/**\\n * @param {Node} root\\n * @return {Node}\\n */\\nvar connect = function(root) {\\n    return root\\n};\\n```\\n[image](https://assets.leetcode.com/users/images/212c9dfa-df75-4432-a28f-c5f74d57f56c_1655207745.4077964.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val, left, right, next) {\\n *    this.val = val === undefined ? null : val;\\n *    this.left = left === undefined ? null : left;\\n *    this.right = right === undefined ? null : right;\\n *    this.next = next === undefined ? null : next;\\n * };\\n */\\n\\n/**\\n * @param {Node} root\\n * @return {Node}\\n */\\nvar connect = function(root) {\\n    return root\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2129950,
                "title": "simplest-solution-o-1-space",
                "content": "**Please upvote if this helps :)**\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node* head=root;\\n         while(head!=NULL){\\n          Node* temp=new Node(0);   Node* curr=temp;\\n        \\n         while(head!=NULL){\\n            if(head->left!=NULL) { curr->next=head->left;  curr=curr->next;}\\n            if(head->right!=NULL){ curr->next=head->right; curr=curr->next;}\\n            head=head->next;\\n        }\\n         head=temp->next; }\\n      return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node* head=root;\\n         while(head!=NULL){\\n          Node* temp=new Node(0);   Node* curr=temp;\\n        \\n         while(head!=NULL){\\n            if(head->left!=NULL) { curr->next=head->left;  curr=curr->next;}\\n            if(head->right!=NULL){ curr->next=head->right; curr=curr->next;}\\n            head=head->next;\\n        }\\n         head=temp->next; }\\n      return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035962,
                "title": "c-bfs-level-order-traversal-easy-o-n-solution",
                "content": "**Please upvote if you find this solution helpful :)**\\n\\n**TC: O(N) and SC: O(N)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    //Use BFS or Level order traversal for pointing next right node of current next\\n    Node* connect(Node* root) \\n    {\\n        queue<Node*> q;\\n        if(root)\\n            q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            Node* node = NULL;\\n            for(int i=0; i<size; i++)\\n            {\\n                Node* cur = q.front(); q.pop();\\n                \\n                //when i==0 it means we are at left most node of the level\\n                //so we assign node = cur\\n                if(i==0) \\n                    node = cur;\\n                \\n                //but for i>=1 we assign current as node\\'s next and move node to current\\n                else\\n                {\\n                    node->next = cur;\\n                    node = node->next;\\n                }\\n                \\n                if(cur->left) q.push(cur->left);\\n                if(cur->right) q.push(cur->right);\\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Use BFS or Level order traversal for pointing next right node of current next\\n    Node* connect(Node* root) \\n    {\\n        queue<Node*> q;\\n        if(root)\\n            q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            Node* node = NULL;\\n            for(int i=0; i<size; i++)\\n            {\\n                Node* cur = q.front(); q.pop();\\n                \\n                //when i==0 it means we are at left most node of the level\\n                //so we assign node = cur\\n                if(i==0) \\n                    node = cur;\\n                \\n                //but for i>=1 we assign current as node\\'s next and move node to current\\n                else\\n                {\\n                    node->next = cur;\\n                    node = node->next;\\n                }\\n                \\n                if(cur->left) q.push(cur->left);\\n                if(cur->right) q.push(cur->right);\\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035917,
                "title": "cleanest-code-simple-awesome-logic-bfs-simple-previous-pointer-approach",
                "content": "**Approach 1 **\\n\\nAs we can see this is simple level order travalsal. So during the traversal we are simple setting next of previous node to current poped element from the queue.\\n\\nO(n) Time\\nO(n) Space:\\n\\n\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null)\\n            return root;\\n        else {\\n            Queue<Node> queue = new LinkedList<>();\\n            queue.add(root);\\n            \\n            while(!queue.isEmpty()) {\\n\\t\\t\\t   \\n\\t\\t\\t   \\n\\t\\t\\t   //We have created a dummy sentinal node. To simply the case when we are processing first element of the level. Beacuse in that case previous element will be null.\\n\\t\\t\\t   \\n                Node dummy=new Node();\\n                Node prev=dummy;\\n                int size = queue.size();\\n                \\n                for(int i=0;i<size;i++) {\\n                    Node current = queue.remove();\\n                    prev.next=current;\\n                    prev=current;\\n                \\n                    if(current.left!=null)\\n                        queue.add(current.left);\\n                    if(current.right!=null)\\n                        queue.add(current.right);\\n                }\\n                \\n            }\\n         return root;   \\n        }\\n        \\n        \\n    }\\n}\\n```\\n\\n\\n**Approach 2 **\\n\\nSo problem with above approach is it is consuming O(n) space.  Intution of the appraoch is to traverse nth level and n+1th level togather and move from nth level to n+1th level when you reach at the end of nodes of level nth level. We will also made use of fact that nth level will always have its next points connected. And whenever we are moving from nth level to n+1th level. It is guraented that next points in all nodes of n+1th level is populated.\\n\\nlets understand this by example. Let say we have following nodes.\\n\\n\\t\\t\\t\\t      A   Since A is the root the nodes in the 0th level already have its next pointer inplace*\\n\\t\\t  B                    C\\n         \\n    D\\t\\t E          F               G\\n\\n\\nSimilar to our previous approach while assigning right pointer at n +1th level we need some previous pointer and even in this case we will have one sentinal node. But in this case other then making the null handling easier this sentinal node will be used to move from 1 level to another.\\n\\n.....\\nNode dummy = new Node();\\nNode prev = dummy;\\nwhile(nodes at nth level are reaminging)\\n\\t    if current node at nth level have left pointer\\n            prev.next=current.left;\\n\\t\\t\\tprev=prev.next\\n\\t    if current node at nth level have right pointer\\n\\t\\t            prev.next=current.right;\\n   \\t\\t\\t        prev=prev.next\\n         //move to next node at nth level.\\n\\n\\nAt the end of above while loop we need to move from nth level to n+1 level.\\nNode head = dummy.next;\\n\\n\\nThis is the core intution behind this logic, we are benfiting from the fact that nodes at 0th level is already in correct arrangement. i.e. its next pointer is already assigned.\\n\\nPlease have a look at the code below. Please upvote if it helps.\\n\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null)\\n            return root;\\n        else {\\n          \\n          Node head = root;\\n          \\n          while(head!=null) {\\n              \\n              Node dummy = new Node(0);\\n              Node temp = dummy;\\n              \\n              while(head!=null) {\\n                  \\n                  if(head.left!=null) {\\n                      temp.next = head.left;\\n                      temp=temp.next;\\n                  }\\n                  if(head.right!=null) {\\n                      temp.next = head.right;\\n                      temp = temp.next;\\n                  }\\n                  head=head.next;\\n              }\\n              head = dummy.next;\\n              \\n          }\\n            \\n         return root;   \\n        }\\n        \\n        \\n    }\\n}\\n```\\n\\nT(n) : O(n)\\nS(n) : O(1)\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null)\\n            return root;\\n        else {\\n            Queue<Node> queue = new LinkedList<>();\\n            queue.add(root);\\n            \\n            while(!queue.isEmpty()) {\\n\\t\\t\\t   \\n\\t\\t\\t   \\n\\t\\t\\t   //We have created a dummy sentinal node. To simply the case when we are processing first element of the level. Beacuse in that case previous element will be null.\\n\\t\\t\\t   \\n                Node dummy=new Node();\\n                Node prev=dummy;\\n                int size = queue.size();\\n                \\n                for(int i=0;i<size;i++) {\\n                    Node current = queue.remove();\\n                    prev.next=current;\\n                    prev=current;\\n                \\n                    if(current.left!=null)\\n                        queue.add(current.left);\\n                    if(current.right!=null)\\n                        queue.add(current.right);\\n                }\\n                \\n            }\\n         return root;   \\n        }\\n        \\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null)\\n            return root;\\n        else {\\n          \\n          Node head = root;\\n          \\n          while(head!=null) {\\n              \\n              Node dummy = new Node(0);\\n              Node temp = dummy;\\n              \\n              while(head!=null) {\\n                  \\n                  if(head.left!=null) {\\n                      temp.next = head.left;\\n                      temp=temp.next;\\n                  }\\n                  if(head.right!=null) {\\n                      temp.next = head.right;\\n                      temp = temp.next;\\n                  }\\n                  head=head.next;\\n              }\\n              head = dummy.next;\\n              \\n          }\\n            \\n         return root;   \\n        }\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035000,
                "title": "properly-explained-c-100-faster-explaination",
                "content": "**Level Order Traversal** \\n```\\nlevel 1 :  1 \\nlevel 2 :  2  3 \\nlevel 3 :  4  5  6 \\n```\\n\\n**We only need to make an connextion in this pattern. \\nNow Level Order Traversal with connections :** \\n```\\nlevel 1 :  1 -> NULL \\nlevel 2 :  2  ->  3  -> NULL  \\nlevel 3 :  4  ->  5  ->  6  ->  NULL  \\n```\\t\\t\\n\\n**Code With Explaination** \\n```\\n// Level Order Traversal \\nvoid levelOrder( Node* root ){\\n\\n\\tqueue<Node*> q ;\\n\\tq.push( root );      // Push the root node along with NULL \\n\\tq.push( NULL );\\n\\n\\twhile( q.size() > 1 ){      // Now queue size will always remain more than 1\\n\\n\\t\\tint size = q.size();\\n\\t\\tfor( int i=0 ; i<size ; i++ ){    // Iterate over every node inside queue\\n\\n\\t\\t\\tNode* node = q.front() ;      // Now node contains 1 \\n\\t\\t\\tq.pop() ;\\n\\n\\t\\t\\tif( node == NULL ) {       // Consider a case in queue :  NULL  2  3 \\n\\t\\t\\t\\tq.push( NULL );        // Hence we need to push NULL in the last according to our pattern : 2  ->  3  -> NULL \\n\\t\\t\\t\\tcontinue ;\\n\\t\\t\\t}\\n\\t\\t\\telse node -> next = q.front() ;     // establish a connection : 1 -> NULL \\n\\n\\t\\t\\tif( node -> left ) q.push( node -> left );     // Push the left of node if exist \\n\\t\\t\\tif( node -> right ) q.push( node -> right );   // Push the right of node if exist \\n\\t\\t}\\n\\t}\\n}\\n\\nNode* connect(Node* root) {\\n\\n\\tif( root == NULL ) return NULL ;\\n\\n\\tlevelOrder( root );\\n\\treturn root ;\\n}\\n```\\n**T.C -> O(n) (If not skew Tree)\\nS.C -> O(n) (BFS - Queue)** \\n**Upvote for Exaplaination :D**",
                "solutionTags": [],
                "code": "```\\nlevel 1 :  1 \\nlevel 2 :  2  3 \\nlevel 3 :  4  5  6 \\n```\n```\\nlevel 1 :  1 -> NULL \\nlevel 2 :  2  ->  3  -> NULL  \\nlevel 3 :  4  ->  5  ->  6  ->  NULL  \\n```\n```\\n// Level Order Traversal \\nvoid levelOrder( Node* root ){\\n\\n\\tqueue<Node*> q ;\\n\\tq.push( root );      // Push the root node along with NULL \\n\\tq.push( NULL );\\n\\n\\twhile( q.size() > 1 ){      // Now queue size will always remain more than 1\\n\\n\\t\\tint size = q.size();\\n\\t\\tfor( int i=0 ; i<size ; i++ ){    // Iterate over every node inside queue\\n\\n\\t\\t\\tNode* node = q.front() ;      // Now node contains 1 \\n\\t\\t\\tq.pop() ;\\n\\n\\t\\t\\tif( node == NULL ) {       // Consider a case in queue :  NULL  2  3 \\n\\t\\t\\t\\tq.push( NULL );        // Hence we need to push NULL in the last according to our pattern : 2  ->  3  -> NULL \\n\\t\\t\\t\\tcontinue ;\\n\\t\\t\\t}\\n\\t\\t\\telse node -> next = q.front() ;     // establish a connection : 1 -> NULL \\n\\n\\t\\t\\tif( node -> left ) q.push( node -> left );     // Push the left of node if exist \\n\\t\\t\\tif( node -> right ) q.push( node -> right );   // Push the right of node if exist \\n\\t\\t}\\n\\t}\\n}\\n\\nNode* connect(Node* root) {\\n\\n\\tif( root == NULL ) return NULL ;\\n\\n\\tlevelOrder( root );\\n\\treturn root ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2034968,
                "title": "python-populating-next-right-pointers-in-each-node-ii",
                "content": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # Empty tree\\n        if root == None:\\n            return root\\n        # Level order traversal keeping the track of next node in prev\\n        queue = [root]\\n        while len(queue) > 0:\\n            size = len(queue)\\n            prev = None\\n            while size > 0:\\n                node = queue.pop(0)\\n                size = size - 1\\n                node.next = prev\\n                prev = node\\n                if node.right:\\n                    queue.append(node.right)\\n                if node.left:\\n                    queue.append(node.left)\\n        return root\\n```\\n\\nNote that we are first appending the right node and then the left node in the queue.\\nThis is because we need the right node\\'s information beforehand accessing left node, for the assignment of next pointer.",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # Empty tree\\n        if root == None:\\n            return root\\n        # Level order traversal keeping the track of next node in prev\\n        queue = [root]\\n        while len(queue) > 0:\\n            size = len(queue)\\n            prev = None\\n            while size > 0:\\n                node = queue.pop(0)\\n                size = size - 1\\n                node.next = prev\\n                prev = node\\n                if node.right:\\n                    queue.append(node.right)\\n                if node.left:\\n                    queue.append(node.left)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034774,
                "title": "c-solution-level-order-traversal-tc-o-n-easy-to-understand",
                "content": "**Level Order Traversal :**\\n\\nVisit every node on a level before going to a lower level. This search is referred to as level order traversal or Breadth\\u2013first search (BFS).\\n\\n**Algorithm :**\\n\\n1.  if root is NULL then simply return NULL.\\n2.  else....Create a Queue and push root node into it.\\n3.  Inside the loop store the current size of the queue. (Currrent queue size will help us to know the number of node(s) in current level)\\n4.  Take the front node from the queue and assign next front node to node->next if queue is not empty.\\n5.  Insert the node->left and node->right child respectively into the queue if they exists.\\n6.  Go to step 3 until queue is not empty.\\n\\n**C++ Code :**\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n\\t\\t// If root is null then just return null\\n        if(root == nullptr)\\n            return nullptr;\\n        \\n\\t\\t// Creat a queue to store nodes level wise\\n        queue<Node*> q;\\n\\t\\t// Insert root node into the queue\\n        q.push(root);\\n        \\n        while(!q.empty()) {\\n\\t\\t\\t// here sz is size of queue which indicate the number of nodes at the current level\\n            int sz = q.size();\\n            while(sz--) {\\n                Node* node = q.front();\\n                q.pop();\\n                \\n\\t\\t\\t\\t// Link the current node to the next node of the same level if it exists\\n                if(sz and !q.empty())\\n                    node->next = q.front();\\n                \\n\\t\\t\\t\\t// adding next level child nodes into the queue\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n\\t\\t// If root is null then just return null\\n        if(root == nullptr)\\n            return nullptr;\\n        \\n\\t\\t// Creat a queue to store nodes level wise\\n        queue<Node*> q;\\n\\t\\t// Insert root node into the queue\\n        q.push(root);\\n        \\n        while(!q.empty()) {\\n\\t\\t\\t// here sz is size of queue which indicate the number of nodes at the current level\\n            int sz = q.size();\\n            while(sz--) {\\n                Node* node = q.front();\\n                q.pop();\\n                \\n\\t\\t\\t\\t// Link the current node to the next node of the same level if it exists\\n                if(sz and !q.empty())\\n                    node->next = q.front();\\n                \\n\\t\\t\\t\\t// adding next level child nodes into the queue\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034521,
                "title": "c-2-solutions-bfs-recursion-easy-clean-code",
                "content": "**1. BFS**\\nTime - O(n)\\nSpace - O(n)\\n```\\n\\tNode* connect(Node* root) {\\n        queue<Node*> q;\\n        \\n        if(root)\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            \\n            while(s--)\\n            {\\n                Node *t=q.front();\\n                q.pop();\\n                \\n                if(s>0)\\n                    t->next=q.front();\\n                \\n                if(t->left)\\n                    q.push(t->left);\\n                \\n                if(t->right)\\n                    q.push(t->right);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n```\\n\\n**2. Recursion**\\nTime - O(n)\\nSpace - O(1) (excluding recursion stack)\\n```\\n\\tNode *getnext(Node* root)\\n    {\\n        while(root)\\n        {\\n            if(root->left)\\n                return root->left;\\n            \\n            if(root->right)\\n                return root->right;\\n            \\n            root=root->next;\\n        }\\n        \\n        return root;\\n    }\\n    \\n    Node* connect(Node* root)\\n    {\\n        if(!root)\\n            return root;\\n        \\n        Node *nextnode=getnext(root->next);\\n        \\n        if(root->left)\\n        {\\n            if(root->right)\\n                root->left->next=root->right;\\n            else\\n                root->left->next=nextnode;\\n        }\\n        \\n        if(root->right)\\n            root->right->next=nextnode;\\n        \\n        root->right=connect(root->right);\\n        root->left=connect(root->left);\\n        \\n        \\n        return root;\\n    }\\n```\\n\\n**Do share your views & upvote if you like !!!**  \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n\\tNode* connect(Node* root) {\\n        queue<Node*> q;\\n        \\n        if(root)\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            \\n            while(s--)\\n            {\\n                Node *t=q.front();\\n                q.pop();\\n                \\n                if(s>0)\\n                    t->next=q.front();\\n                \\n                if(t->left)\\n                    q.push(t->left);\\n                \\n                if(t->right)\\n                    q.push(t->right);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n```\n```\\n\\tNode *getnext(Node* root)\\n    {\\n        while(root)\\n        {\\n            if(root->left)\\n                return root->left;\\n            \\n            if(root->right)\\n                return root->right;\\n            \\n            root=root->next;\\n        }\\n        \\n        return root;\\n    }\\n    \\n    Node* connect(Node* root)\\n    {\\n        if(!root)\\n            return root;\\n        \\n        Node *nextnode=getnext(root->next);\\n        \\n        if(root->left)\\n        {\\n            if(root->right)\\n                root->left->next=root->right;\\n            else\\n                root->left->next=nextnode;\\n        }\\n        \\n        if(root->right)\\n            root->right->next=nextnode;\\n        \\n        root->right=connect(root->right);\\n        root->left=connect(root->left);\\n        \\n        \\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2033411,
                "title": "two-iterative-approaches-o-1-o-n-space-c",
                "content": "**Approach 1 :\\nTime Complexity : O(n)\\nSpace Complexity: O(n)**\\nThe problem is very simple if we do it by iterative level order traversal from left to right .\\n\\nThe queue is filled left to right separated by NULL for each level \\n The code is self explanatory ! have a look :)\\n\\n```\\n     queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        \\n        while(q.size()!=0){\\n            \\n            Node * cur = q.front();\\n            q.pop();\\n            \\n            if(!cur){\\n               q.push(NULL);\\n                if(q.front()==NULL)break;\\n                \\n                continue;\\n            }\\n            \\n            \\n            cur->next = q.front();   // Assigning the next ptr\\n            \\n            if(cur->left!=NULL)q.push(cur->left);\\n            if(cur->right!=NULL)q.push(cur->right);\\n            \\n            \\n        }\\n        \\n        \\n        return root;\\n        \\n```\\n\\n**Approach 2 :\\nTime Complexity : O(n)\\nSpace Complexity: O(1)**\\nIn this approach we observe that nodes in each level is linked by next pointer , so traversing using next pointer will keep us in same level .\\n\\n```\\n        \\n        Node *cur = NULL ; \\n        Node *head = root ; // *** head of level \\n        \\n        // Nodes in each level are linked with next pointer;\\n        \\n        while(head!=NULL){\\n            Node *temp = head;  // temp goes in a particular level using next ptr\\n            head = NULL; \\n            Node *prev = NULL;  // node previous to current node\\n            \\n            while(temp!=NULL){\\n                \\n            if(temp -> left!=NULL){\\n                \\n                if(head == NULL){\\n                    head = temp -> left;\\n                }\\n                \\n                if(prev != NULL){\\n                    prev -> next = temp -> left;\\n                    prev = temp->left;\\n                }\\n                else{\\n                    prev = temp->left;\\n                }\\n                \\n                \\n                \\n            }\\n              if(temp -> right!=NULL){\\n                \\n                if(head == NULL){\\n                    head = temp -> right;\\n                }\\n                \\n                if(prev != NULL){\\n                    prev -> next = temp ->right;\\n                    prev = temp->right;\\n                }\\n                else{\\n                    prev = temp->right;\\n                }\\n                \\n                \\n                \\n            }\\n            \\n            temp = temp -> next;\\n            }\\n            \\n            \\n        }\\n        \\n        \\n        \\n        \\n        return root;\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n     queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        \\n        while(q.size()!=0){\\n            \\n            Node * cur = q.front();\\n            q.pop();\\n            \\n            if(!cur){\\n               q.push(NULL);\\n                if(q.front()==NULL)break;\\n                \\n                continue;\\n            }\\n            \\n            \\n            cur->next = q.front();   // Assigning the next ptr\\n            \\n            if(cur->left!=NULL)q.push(cur->left);\\n            if(cur->right!=NULL)q.push(cur->right);\\n            \\n            \\n        }\\n        \\n        \\n        return root;\\n        \\n```\n```\\n        \\n        Node *cur = NULL ; \\n        Node *head = root ; // *** head of level \\n        \\n        // Nodes in each level are linked with next pointer;\\n        \\n        while(head!=NULL){\\n            Node *temp = head;  // temp goes in a particular level using next ptr\\n            head = NULL; \\n            Node *prev = NULL;  // node previous to current node\\n            \\n            while(temp!=NULL){\\n                \\n            if(temp -> left!=NULL){\\n                \\n                if(head == NULL){\\n                    head = temp -> left;\\n                }\\n                \\n                if(prev != NULL){\\n                    prev -> next = temp -> left;\\n                    prev = temp->left;\\n                }\\n                else{\\n                    prev = temp->left;\\n                }\\n                \\n                \\n                \\n            }\\n              if(temp -> right!=NULL){\\n                \\n                if(head == NULL){\\n                    head = temp -> right;\\n                }\\n                \\n                if(prev != NULL){\\n                    prev -> next = temp ->right;\\n                    prev = temp->right;\\n                }\\n                else{\\n                    prev = temp->right;\\n                }\\n                \\n                \\n                \\n            }\\n            \\n            temp = temp -> next;\\n            }\\n            \\n            \\n        }\\n        \\n        \\n        \\n        \\n        return root;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2033255,
                "title": "python-preorder-traversal-dictionary-hashmap-easy",
                "content": "```\\ndef connect(self, root: \\'Node\\') -> \\'Node\\':\\n        def preOrder(node, depth, dic):\\n            if not node:\\n                return\\n            if depth not in dic:\\n                dic[depth] = node\\n            else:\\n                dic[depth].next = node\\n                dic[depth] = node\\n            preOrder(node.left, depth + 1, dic)\\n            preOrder(node.right, depth + 1, dic)\\n        preOrder(root, 1, {})\\n        return root\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef connect(self, root: \\'Node\\') -> \\'Node\\':\\n        def preOrder(node, depth, dic):\\n            if not node:\\n                return\\n            if depth not in dic:\\n                dic[depth] = node\\n            else:\\n                dic[depth].next = node\\n                dic[depth] = node\\n            preOrder(node.left, depth + 1, dic)\\n            preOrder(node.right, depth + 1, dic)\\n        preOrder(root, 1, {})\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1861204,
                "title": "c-easy-bfs-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid helper(Node *root){\\n\\t\\t\\tqueue<Node*> q;\\n\\t\\t\\tq.push(root);\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint n=q.size();\\n\\t\\t\\t\\tNode *prev;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\t\\t\\tNode *r=q.front();\\n\\t\\t\\t\\t\\t\\tprev=r;\\n\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\tif(r->left) q.push(r->left);\\n\\t\\t\\t\\t\\t\\tif(r->right) q.push(r->right);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\tNode *r=q.front();\\n\\t\\t\\t\\t\\t\\tprev->next=r;\\n\\t\\t\\t\\t\\t\\tprev=r;\\n\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\tif(r->left) q.push(r->left);\\n\\t\\t\\t\\t\\t\\tif(r->right) q.push(r->right);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev->next=nullptr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tNode* connect(Node* root) {\\n\\t\\t\\tif(!root) return root;\\n\\t\\t\\thelper(root);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};\\n\\n**DO UPVOTE IF IT WAS HELPFUL !!** \\u2B06\\uFE0F\\u2B06\\uFE0F",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid helper(Node *root){\\n\\t\\t\\tqueue<Node*> q;\\n\\t\\t\\tq.push(root);\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint n=q.size();\\n\\t\\t\\t\\tNode *prev;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\t\\t\\tNode *r=q.front();\\n\\t\\t\\t\\t\\t\\tprev=r;\\n\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\tif(r->left) q.push(r->left);\\n\\t\\t\\t\\t\\t\\tif(r->right) q.push(r->right);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1778019,
                "title": "populating-next-right-pointers-in-each-node-ii-solution-java",
                "content": "class Solution {\\n  public Node connect(Node root) {\\n    Node node = root; // the node just above current needling\\n\\n    while (node != null) {\\n      Node dummy = new Node(); // dummy node before needling\\n      // needle children of node\\n      for (Node needle = dummy; node != null; node = node.next) {\\n        if (node.left != null) { // needle left child\\n          needle.next = node.left;\\n          needle = needle.next;\\n        }\\n        if (node.right != null) { // needle right child\\n          needle.next = node.right;\\n          needle = needle.next;\\n        }\\n      }\\n      node = dummy.next; // move node to the next level\\n    }\\n\\n    return root;\\n  }\\n}\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n  public Node connect(Node root) {\\n    Node node = root; // the node just above current needling\\n\\n    while (node != null) {\\n      Node dummy = new Node(); // dummy node before needling\\n      // needle children of node\\n      for (Node needle = dummy; node != null; node = node.next) {\\n        if (node.left != null) { // needle left child\\n          needle.next = node.left;\\n          needle = needle.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1725606,
                "title": "c-pre-order-dfs-right-child-first-o-1-space-followup-intuition-and-explanation",
                "content": "**TLDR**\\npre-order traverse, recursively connect 2 nodes. Trick here is to recursion on right first. (so kinda double pre-order dfs)\\n\\n**Detailed intuition/explanation:**\\nIntuition comes from #116, where tree is perfect tree. In 116, we have a recursion on current node version.\\nLogic is very straightforward:\\nstep 1: connect my child.\\nstep 2: connect me to the next node.\\n\\nFor step2, \\nIn #116, we  have **\"root->right->next = root->next->left\"** \\nhere, **root->right** is some **\"pre\"** node we need to find, and **\"root->next->left\"** is some after node we need to find.\\nSo logic is just **\"pre->after\"**\\n\\nOne caveat here tho, as we are doing DFS, usually we go left, then right. \\nBut here, locating the one **\"after\"** requires all connection already **\"connected\"** in the **right** of the one **\"after\"** node.\\nThis is different from going left first.\\n\\nA bit mouthful to explain, so check out the following testcase **(dfs going left first vs dfs going right first)**\\n[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]\\nThis is kinda like we connect all nodes to right, so let\\'s do right first.(lol)\\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        //M2: pre-order dfs, with right recursion first.\\n        traverse(root);\\n        return root;\\n    }\\n\\nprivate:\\n    void traverse(Node* root) {\\n        if (!root) return;\\n        \\n        //connect me\\n        if (root->left) root->left->next = root->right;\\n        \\n        //connect me to next. i.e. pre to after\\n        Node* pre = root->left ? root->left : root->right;\\n        \\n        if (pre) {\\n            Node* tmp = root;\\n\\t\\t\\t//find the first \\'next\\' node, which has \\'after\\' node to connect to\\n            while (tmp->next) {\\n                Node* after = tmp->next->left ? tmp->next->left : tmp->next->right;\\n                if (after) {\\n                    if (pre->next) pre->next->next = after;\\n                    else pre->next = after;\\n                    break;\\n                }\\n                tmp = tmp->next;\\n            }   \\n        }\\n        \\n        //need to fill the next from right to left, then we can do bottom up(dfs)\\n        traverse(root->right);\\n        traverse(root->left);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        //M2: pre-order dfs, with right recursion first.\\n        traverse(root);\\n        return root;\\n    }\\n\\nprivate:\\n    void traverse(Node* root) {\\n        if (!root) return;\\n        \\n        //connect me\\n        if (root->left) root->left->next = root->right;\\n        \\n        //connect me to next. i.e. pre to after\\n        Node* pre = root->left ? root->left : root->right;\\n        \\n        if (pre) {\\n            Node* tmp = root;\\n\\t\\t\\t//find the first \\'next\\' node, which has \\'after\\' node to connect to\\n            while (tmp->next) {\\n                Node* after = tmp->next->left ? tmp->next->left : tmp->next->right;\\n                if (after) {\\n                    if (pre->next) pre->next->next = after;\\n                    else pre->next = after;\\n                    break;\\n                }\\n                tmp = tmp->next;\\n            }   \\n        }\\n        \\n        //need to fill the next from right to left, then we can do bottom up(dfs)\\n        traverse(root->right);\\n        traverse(root->left);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674478,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar connect = function(root) {\\n\\t\\tif (!root) return root;\\n\\t\\tconst getNext = (next) => {\\n\\t\\t\\tif (!next) return null;\\n\\t\\t\\tconst nextLeft = next?.left;\\n\\t\\t\\tconst nextRight = next?.right;\\n\\t\\t\\treturn nextLeft ?? nextRight ?? getNext(next.next);\\n\\t\\t};\\n\\n\\t\\tif (root.left) root.left.next = root.right ?? getNext(root?.next); \\n\\t\\tif (root.right) root.right.next = getNext(root?.next);\\n\\n\\t\\tconnect(root.right);\\n\\t\\tconnect(root.left);\\n\\t\\treturn root;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar connect = function(root) {\\n\\t\\tif (!root) return root;\\n\\t\\tconst getNext = (next) => {\\n\\t\\t\\tif (!next) return null;\\n\\t\\t\\tconst nextLeft = next?.left;\\n\\t\\t\\tconst nextRight = next?.right;\\n\\t\\t\\treturn nextLeft ?? nextRight ?? getNext(next.next);\\n\\t\\t};\\n\\n\\t\\tif (root.left) root.left.next = root.right ?? getNext(root?.next); \\n\\t\\tif (root.right) root.right.next = getNext(root?.next);\\n\\n\\t\\tconnect(root.right);\\n\\t\\tconnect(root.left);\\n\\t\\treturn root;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1658841,
                "title": "java-same-sol-116-117-explained-in-detail-constant-space",
                "content": "// Similar question : https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\n// Difference in this ques and above ques is that the above ques mentions the tree as PERFECT BINARY TREE (every parent has 2 child and all leaves are on same level) whereas in this ques, it is just a binary tree\\n\\n// This solution will work for both this and the other ques.\\n\\n// TC : O(N) -> Num of nodes\\n// SC : O(1) -> other than recursion stack\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return  null;\\n        \\n        if(root.left != null) { // check for left first\\n            if(root.right != null) // if right of root is also present, then just assign this to left.next\\n                root.left.next = root.right;\\n            else \\n                root.left.next = findNext(root); // we need to find out which node in root.next comes next\\n        }\\n        \\n        if(root.right != null) {\\n            root.right.next = findNext(root); // for any right node of a root, we need to use the root\\'s next to find the next\\n        }\\n        \\n        connect(root.right); // call from root.right first because of the way we use findNext(). We need to have answers in right first to find for left\\n        connect(root.left);\\n        \\n        return root;\\n    }\\n    \\n    private Node findNext(Node node) {\\n        while(node.next != null) { // do until we get the next \\n            node = node.next;\\n            if(node.left != null) return node.left;\\n            if(node.right != null) return node.right;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return  null;\\n        \\n        if(root.left != null) { // check for left first\\n            if(root.right != null) // if right of root is also present, then just assign this to left.next\\n                root.left.next = root.right;\\n            else \\n                root.left.next = findNext(root); // we need to find out which node in root.next comes next\\n        }\\n        \\n        if(root.right != null) {\\n            root.right.next = findNext(root); // for any right node of a root, we need to use the root\\'s next to find the next\\n        }\\n        \\n        connect(root.right); // call from root.right first because of the way we use findNext(). We need to have answers in right first to find for left\\n        connect(root.left);\\n        \\n        return root;\\n    }\\n    \\n    private Node findNext(Node node) {\\n        while(node.next != null) { // do until we get the next \\n            node = node.next;\\n            if(node.left != null) return node.left;\\n            if(node.right != null) return node.right;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546196,
                "title": "simple-java-iterative-solution-using-bfs",
                "content": "\\nclass Solution {\\n\\n    public Node connect(Node root) {\\n        \\n        Queue<Node> queue= new LinkedList<>();\\n        \\n        if(root!=null){\\n            queue.offer(root);\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            int qs=queue.size();\\n            LinkedList<Node> nodeList= new LinkedList<>();\\n            for(int i=0;i<qs;i++){ \\n                Node current=queue.poll();\\n                nodeList.add(current);\\n                if(current.left!=null){\\n                    queue.offer(current.left);\\n                }\\n                if(current.right!=null){\\n                    queue.offer(current.right);\\n                }\\n            }\\n            if(nodeList.size()>0){\\n                int i=1;\\n                while(i<nodeList.size()){\\n                    nodeList.get(i-1).next=nodeList.get(i);\\n                    i++;\\n                }\\n                nodeList.get(nodeList.size()-1).next=null;\\n            }\\n        }\\n        \\n        return root;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public Node connect(Node root) {\\n        \\n        Queue<Node> queue= new LinkedList<>();\\n        \\n        if(root!=null){\\n            queue.offer(root);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1292962,
                "title": "0ms-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        helper(root);\\n        return root;\\n    }\\n    \\n    private void helper(Node node) {\\n        if(node == null) return;\\n                \\n        Node nextNode = getNextNode(node.next); //recursively try to get the node to be connected with either right or left\\n        \\n        if(node.left != null) node.left.next = node.right != null ? node.right : nextNode;\\n        \\n        if(node.right != null) {\\n            node.right.next = nextNode;\\n        }\\n        \\n        helper(node.right); //Need to connect the right side first! We will fail to connect flipped V shaped deep trees otherwise\\n        helper(node.left);\\n    }\\n    \\n    private Node getNextNode(Node node) {\\n        if(node == null) return node;\\n        if(node.left != null) return node.left;\\n        if(node.right != null) return node.right;\\n        \\n        return getNextNode(node.next);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        helper(root);\\n        return root;\\n    }\\n    \\n    private void helper(Node node) {\\n        if(node == null) return;\\n                \\n        Node nextNode = getNextNode(node.next); //recursively try to get the node to be connected with either right or left\\n        \\n        if(node.left != null) node.left.next = node.right != null ? node.right : nextNode;\\n        \\n        if(node.right != null) {\\n            node.right.next = nextNode;\\n        }\\n        \\n        helper(node.right); //Need to connect the right side first! We will fail to connect flipped V shaped deep trees otherwise\\n        helper(node.left);\\n    }\\n    \\n    private Node getNextNode(Node node) {\\n        if(node == null) return node;\\n        if(node.left != null) return node.left;\\n        if(node.right != null) return node.right;\\n        \\n        return getNextNode(node.next);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171236,
                "title": "simple-easy-cpp-level-order-transversal-solution",
                "content": "```\\n  Node* connect(Node* root) {\\n        if(!root)return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int a=q.size();\\n            Node* prev=NULL;\\n            while(a){\\n                Node* n=q.front();\\n                if(prev!=NULL){\\n                    prev->next=n;\\n                }\\n                q.pop();\\n                if(n->left)q.push(n->left);\\n                if(n->right)q.push(n->right);\\n                a--;\\n               \\n                prev=n;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n  Node* connect(Node* root) {\\n        if(!root)return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int a=q.size();\\n            Node* prev=NULL;\\n            while(a){\\n                Node* n=q.front();\\n                if(prev!=NULL){\\n                    prev->next=n;\\n                }\\n                q.pop();\\n                if(n->left)q.push(n->left);\\n                if(n->right)q.push(n->right);\\n                a--;\\n               \\n                prev=n;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1145370,
                "title": "java-constant-space-solution-0ms",
                "content": "```\\npublic Node connect(Node root) {\\n        connectNodes(root);\\n        return root;\\n    }\\n    \\n    public void connectNodes(Node root){\\n        if(root == null) return;\\n        \\n        if(root.left != null){\\n            if(root.right != null)\\n                root.left.next = root.right;\\n            else\\n                root.left.next = getNextNode(root);\\n        }\\n        \\n        if(root.right != null)\\n            root.right.next = getNextNode(root);\\n        \\n        connectNodes(root.right);\\n        connectNodes(root.left);\\n    }\\n    \\n    public Node getNextNode(Node root){\\n        while(root.next != null){\\n            root = root.next;\\n            \\n            if(root.left != null) return root.left;\\n            else if(root.right != null) return root.right;\\n        }\\n        \\n        return null;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic Node connect(Node root) {\\n        connectNodes(root);\\n        return root;\\n    }\\n    \\n    public void connectNodes(Node root){\\n        if(root == null) return;\\n        \\n        if(root.left != null){\\n            if(root.right != null)\\n                root.left.next = root.right;\\n            else\\n                root.left.next = getNextNode(root);\\n        }\\n        \\n        if(root.right != null)\\n            root.right.next = getNextNode(root);\\n        \\n        connectNodes(root.right);\\n        connectNodes(root.left);\\n    }\\n    \\n    public Node getNextNode(Node root){\\n        while(root.next != null){\\n            root = root.next;\\n            \\n            if(root.left != null) return root.left;\\n            else if(root.right != null) return root.right;\\n        }\\n        \\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961916,
                "title": "python-bfs-o-1-space",
                "content": "Last month we have encountered the first version of this problem, there I used an approach using a getter function. Here that idea fails, as the binary tree can be very deep (as only the number of nodes are constrained).\\n\\nHere is an alternative approach: Now let\\'s say at depth `d` we have all the nodes linked. Then we basically have a linked list. If we know the first element of this linked list, we can traverse the whole level. At each depth we store the first node of the linked list in `header`. The header for next level will be `next_header`. Break the loop when `next_header == None`. Finally we need to link all the nodes in next level; for this use a queue, but anytime the queue length exceeds `2` we link from the left and pop the elements, as we don\\'t need them anymore.\\n\\nTime: `O(N)` (traverse each node twice)\\nSpace: `O(1)` (we use the tree itself for BFS which is not extra space).\\n\\n```python\\nfrom collections import deque\\nclass Solution:    \\n    def connect(self, root):\\n        #corner cases\\n        if not root: return None\\n        if not (root.left or root.right): return root\\n        \\n        #link at depth 2\\n        if root.left:\\n            root.left.next = root.right\\n        \\n        #link at deeper\\n        header = root.left if root.left else root.right\\n        next_header = None\\n        while header:\\n            que = deque([])\\n            while header:\\n                for node in (header.left, header.right):\\n                    if node: que.append(node)\\n                    if node and not next_header: next_header = node\\n                while len(que)>=2:\\n                    que[0].next = que[1]\\n                    que.popleft()\\n                header = header.next\\n            header = next_header\\n            next_header = None\\n        return root\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import deque\\nclass Solution:    \\n    def connect(self, root):\\n        #corner cases\\n        if not root: return None\\n        if not (root.left or root.right): return root\\n        \\n        #link at depth 2\\n        if root.left:\\n            root.left.next = root.right\\n        \\n        #link at deeper\\n        header = root.left if root.left else root.right\\n        next_header = None\\n        while header:\\n            que = deque([])\\n            while header:\\n                for node in (header.left, header.right):\\n                    if node: que.append(node)\\n                    if node and not next_header: next_header = node\\n                while len(que)>=2:\\n                    que[0].next = que[1]\\n                    que.popleft()\\n                header = header.next\\n            header = next_header\\n            next_header = None\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687311,
                "title": "c-o-n-time-and-o-1-space-using-3-pointer-variables",
                "content": "3 pointer approach \\nparent pointer-> to traverse each parent at a particular level\\nleftmost pointer-> to store the first node of the next level\\nprev pointer->to traverse and connect each child node\\n\\nclass Solution {\\npublic:\\n\\n    Node* connect(Node* root) {\\n        Node* parent=root;\\n        while(parent!=NULL) //For each level\\n        {\\n           Node*leftmost=NULL;Node*prev=NULL;\\n           while(parent!=NULL) //For each parent node in that level \\n           {\\n               if(parent->left!=NULL)\\n               {\\n                  if(leftmost==NULL) leftmost=parent->left;//First node in the next level\\n                  else prev->next=parent->left;\\n                  prev=parent->left;\\n               }\\n               if(parent->right!=NULL)\\n               {\\n                   if(leftmost==NULL) leftmost=parent->right;//First node in next the level\\n                   else prev->next=parent->right;\\n                   prev=parent->right;\\n               }\\n               parent=parent->next;//Update to next parent node in the same level\\n           }\\n         parent=leftmost;\\n        }\\n        return root;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    Node* connect(Node* root) {\\n        Node* parent=root;\\n        while(parent!=NULL) //For each level\\n        {\\n           Node*leftmost=NULL;Node*prev=NULL;\\n           while(parent!=NULL) //For each parent node in that level \\n           {\\n               if(parent->left!=NULL)\\n               {\\n                  if(leftmost==NULL) leftmost=parent->left;//First node in the next level\\n                  else prev->next=parent->left;\\n                  prev=parent->left;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 571741,
                "title": "intuitive-iterative-java-solution-with-runtime-1-ms",
                "content": "Just some modifications done to BFS algorithm!\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null) return root; // when tree is empty\\n        \\n        Queue<Node> q= new LinkedList<>();\\n        q.add(root);\\n        q.add(null);\\n        while(!q.isEmpty()){\\n            Node temp= q.remove();\\n            if(temp==null && !q.isEmpty()) {    \\n                q.add(null); continue;\\n            }\\n            \\n            if(temp!=null) {    // accessing node\\'s fields\\n                if(temp.left!=null) q.add(temp.left);\\n                if(temp.right!=null) q.add(temp.right);\\n                temp.next= q.peek();\\n            }          \\n            \\n        }\\n        return root;\\n    }\\n}\\n```\\n\\nHappy Coding!",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null) return root; // when tree is empty\\n        \\n        Queue<Node> q= new LinkedList<>();\\n        q.add(root);\\n        q.add(null);\\n        while(!q.isEmpty()){\\n            Node temp= q.remove();\\n            if(temp==null && !q.isEmpty()) {    \\n                q.add(null); continue;\\n            }\\n            \\n            if(temp!=null) {    // accessing node\\'s fields\\n                if(temp.left!=null) q.add(temp.left);\\n                if(temp.right!=null) q.add(temp.right);\\n                temp.next= q.peek();\\n            }          \\n            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560567,
                "title": "c-solution-dfs-and-bfs",
                "content": "dfs solution\\n```\\nvoid connectHelper(struct Node *root, struct Node *next)\\n{\\n    if(root == NULL)\\n        return;\\n\\n    root->next = next;\\n\\n    struct Node *tmp = NULL;\\n    while(next)\\n    {\\n        if(next->left)\\n        {\\n            tmp = next->left;\\n            break;\\n        }\\n        else if(next->right)\\n        {\\n            tmp = next->right;\\n            break;\\n        }\\n        else\\n            next = next->next;\\n    }\\n\\n    connectHelper(root->right, tmp);\\n    if(root->right)\\n        connectHelper(root->left, root->right);\\n    else\\n        connectHelper(root->left, tmp);\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tconnectHelper(root, NULL);\\n    return root;\\n}\\n```\\n\\nbfs solution\\n```\\nstruct Node* connect(struct Node* root) {\\n    if(root == NULL)\\n        return NULL;\\n\\n    struct Node *first = root, *cur, *pre;\\n    while(first)\\n    {\\n        cur = first;\\n        pre = first = NULL;\\n        while(cur)\\n        {\\n            if(cur->left)\\n            {\\n                if(pre) pre->next = cur->left;\\n                else first = cur->left;\\n\\n                pre = cur->left;\\n            }\\n\\n            if(cur->right)\\n            {\\n                if(pre) pre->next = cur->right;\\n                else first = cur->right;\\n\\n                pre = cur->right;\\n            }\\n\\n            cur = cur->next;\\n        }\\n    }\\n\\n    return root;\\n}\\n```\\n55/55 cases passed (8 ms)\\nYour runtime beats 100 % of c submissions\\nYour memory usage beats 100 % of c submissions (7.5 MB)",
                "solutionTags": [],
                "code": "```\\nvoid connectHelper(struct Node *root, struct Node *next)\\n{\\n    if(root == NULL)\\n        return;\\n\\n    root->next = next;\\n\\n    struct Node *tmp = NULL;\\n    while(next)\\n    {\\n        if(next->left)\\n        {\\n            tmp = next->left;\\n            break;\\n        }\\n        else if(next->right)\\n        {\\n            tmp = next->right;\\n            break;\\n        }\\n        else\\n            next = next->next;\\n    }\\n\\n    connectHelper(root->right, tmp);\\n    if(root->right)\\n        connectHelper(root->left, root->right);\\n    else\\n        connectHelper(root->left, tmp);\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tconnectHelper(root, NULL);\\n    return root;\\n}\\n```\n```\\nstruct Node* connect(struct Node* root) {\\n    if(root == NULL)\\n        return NULL;\\n\\n    struct Node *first = root, *cur, *pre;\\n    while(first)\\n    {\\n        cur = first;\\n        pre = first = NULL;\\n        while(cur)\\n        {\\n            if(cur->left)\\n            {\\n                if(pre) pre->next = cur->left;\\n                else first = cur->left;\\n\\n                pre = cur->left;\\n            }\\n\\n            if(cur->right)\\n            {\\n                if(pre) pre->next = cur->right;\\n                else first = cur->right;\\n\\n                pre = cur->right;\\n            }\\n\\n            cur = cur->next;\\n        }\\n    }\\n\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 539662,
                "title": "faster-than-97-small-code",
                "content": "```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root: return\\n        par, child_root = root, Node()\\n        child = child_root\\n        \\n        while child and par:\\n            if par.left:\\n                child.next = par.left\\n                child = child.next\\n            if par.right:\\n                child.next = par.right\\n                child = child.next\\n            par = par.next            \\n            \\n        self.connect(child_root.next)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root: return\\n        par, child_root = root, Node()\\n        child = child_root\\n        \\n        while child and par:\\n            if par.left:\\n                child.next = par.left\\n                child = child.next\\n            if par.right:\\n                child.next = par.right\\n                child = child.next\\n            par = par.next            \\n            \\n        self.connect(child_root.next)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489126,
                "title": "simple-java-iterative-dfs-o-1-space-approach-with-explanation",
                "content": "```\\n    public Node connect(Node root) {\\n        \\n        /*\\n        Approach: For each node in current level,\\n                  1. Store the first node of next level in a pointer\\n                  2. Have a pointer that will connect the nodes of next level in a level-order traversal manner\\n                  3. Move to the next level\\n        */\\n        \\n        \\n        Node firstNodeOfThisLevel = root;\\n        \\n        while(firstNodeOfThisLevel != null){\\n            \\n            Node dummyfirstNodeOfNextLevel = new Node(0);                       //Dummy node that will be situated before\\n                                                                                //first node of next level, with \"next\" \\n                                                                                //pointing to the first node\\n            \\n            Node currentNodeOfNextLevel = dummyfirstNodeOfNextLevel;            //Node that will move in the next level\\n                                                                                //and build the connection\\n            \\n            for(Node currentNodeOfThisLevel = firstNodeOfThisLevel;             //For each node in this level\\n                currentNodeOfThisLevel != null;\\n                currentNodeOfThisLevel = currentNodeOfThisLevel.next){\\n                \\n                if(currentNodeOfThisLevel.left != null){                        //If this level node has left child\\n                    currentNodeOfNextLevel.next = currentNodeOfThisLevel.left;  //Build the connection\\n                    currentNodeOfNextLevel = currentNodeOfNextLevel.next;       //Move to next node\\n                }\\n                if(currentNodeOfThisLevel.right != null){                       //If this level node has right child\\n                    currentNodeOfNextLevel.next = currentNodeOfThisLevel.right; //Build the connection\\n                    currentNodeOfNextLevel = currentNodeOfNextLevel.next;       //Move to next node\\n                }\\n            }\\n            \\n            firstNodeOfThisLevel = dummyfirstNodeOfNextLevel.next;              //Since this dummy node\\'s \"next\" points to \\n                                                                                //the actual first node of the next level, \\n                                                                                //move to it\\n        }\\n        \\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    public Node connect(Node root) {\\n        \\n        /*\\n        Approach: For each node in current level,\\n                  1. Store the first node of next level in a pointer\\n                  2. Have a pointer that will connect the nodes of next level in a level-order traversal manner\\n                  3. Move to the next level\\n        */\\n        \\n        \\n        Node firstNodeOfThisLevel = root;\\n        \\n        while(firstNodeOfThisLevel != null){\\n            \\n            Node dummyfirstNodeOfNextLevel = new Node(0);                       //Dummy node that will be situated before\\n                                                                                //first node of next level, with \"next\" \\n                                                                                //pointing to the first node\\n            \\n            Node currentNodeOfNextLevel = dummyfirstNodeOfNextLevel;            //Node that will move in the next level\\n                                                                                //and build the connection\\n            \\n            for(Node currentNodeOfThisLevel = firstNodeOfThisLevel;             //For each node in this level\\n                currentNodeOfThisLevel != null;\\n                currentNodeOfThisLevel = currentNodeOfThisLevel.next){\\n                \\n                if(currentNodeOfThisLevel.left != null){                        //If this level node has left child\\n                    currentNodeOfNextLevel.next = currentNodeOfThisLevel.left;  //Build the connection\\n                    currentNodeOfNextLevel = currentNodeOfNextLevel.next;       //Move to next node\\n                }\\n                if(currentNodeOfThisLevel.right != null){                       //If this level node has right child\\n                    currentNodeOfNextLevel.next = currentNodeOfThisLevel.right; //Build the connection\\n                    currentNodeOfNextLevel = currentNodeOfNextLevel.next;       //Move to next node\\n                }\\n            }\\n            \\n            firstNodeOfThisLevel = dummyfirstNodeOfNextLevel.next;              //Since this dummy node\\'s \"next\" points to \\n                                                                                //the actual first node of the next level, \\n                                                                                //move to it\\n        }\\n        \\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 411659,
                "title": "o-1-space-python-code-use-dummy-head-easy-to-understand",
                "content": "See the explaination in docstings.  **easy to understand**.\\n\\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \"\"\"\\n        Refer to https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/discuss/37826/Concise-python-solution-9-lines-space-O(1)\\n        \\n        Level by level traversal with a dummy head prekid.\\n\\n        root: is for the current level;\\n        prekid: The dummy head;\\n        prekid.next: let dummy head\\'s next store the first node of the child level for us;\\n        kid: is for the child level traversal, to connect each node in child level while moving ahead.\\n        \\n        When this level\\'s work are all done, we move to next level by: \\n            root = prekid.next   # Just the child level\\'s head\\n            kid = prekid         # We use this dummy head for the new level\\'s traversal.\\n            kid.next = None      # Let the dummy head\\'s next be None, before we going for this new level.\\n\\n        O(1) in Space, O(N) in Time.\\n        \"\"\"\\n        old_root = root\\n        prekid = Node(0)\\n        kid = prekid   # Let kid point to prekid \\n        while root:\\n            while root:\\n                if root.left:\\n                    kid.next = root.left\\n                    kid = kid.next\\n                if root.right:\\n                    kid.next = root.right\\n                    kid = kid.next\\n                root = root.next\\n            root, kid = prekid.next, prekid\\n            kid.next = None  # Reset the chain for prekid\\n        return old_root\\n```\\nRefer to [@cmc](https://leetcode.com/cmc) \\'s  sharing at https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/discuss/37826/Concise-python-solution-9-lines-space-O(1) .   \\nThis is marvellous.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \"\"\"\\n        Refer to https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/discuss/37826/Concise-python-solution-9-lines-space-O(1)\\n        \\n        Level by level traversal with a dummy head prekid.\\n\\n        root: is for the current level;\\n        prekid: The dummy head;\\n        prekid.next: let dummy head\\'s next store the first node of the child level for us;\\n        kid: is for the child level traversal, to connect each node in child level while moving ahead.\\n        \\n        When this level\\'s work are all done, we move to next level by: \\n            root = prekid.next   # Just the child level\\'s head\\n            kid = prekid         # We use this dummy head for the new level\\'s traversal.\\n            kid.next = None      # Let the dummy head\\'s next be None, before we going for this new level.\\n\\n        O(1) in Space, O(N) in Time.\\n        \"\"\"\\n        old_root = root\\n        prekid = Node(0)\\n        kid = prekid   # Let kid point to prekid \\n        while root:\\n            while root:\\n                if root.left:\\n                    kid.next = root.left\\n                    kid = kid.next\\n                if root.right:\\n                    kid.next = root.right\\n                    kid = kid.next\\n                root = root.next\\n            root, kid = prekid.next, prekid\\n            kid.next = None  # Reset the chain for prekid\\n        return old_root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359074,
                "title": "simple-solution-with-a-dummy-node-beat-100",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node cur = root;\\n        // this check is for the level head\\n        while (cur != null) {\\n            // connect the next level using a dummy\\n            Node sen = new Node();\\n            Node p = sen;\\n            // this check is for cur.next\\n            while (cur != null) {\\n                if (cur.left != null) {\\n                    p.next = cur.left;\\n                    p = p.next;\\n                }\\n                if (cur.right != null) {\\n                    p.next = cur.right;\\n                    p = p.next;\\n                }\\n                cur = cur.next;\\n            }\\n            cur = sen.next;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node cur = root;\\n        // this check is for the level head\\n        while (cur != null) {\\n            // connect the next level using a dummy\\n            Node sen = new Node();\\n            Node p = sen;\\n            // this check is for cur.next\\n            while (cur != null) {\\n                if (cur.left != null) {\\n                    p.next = cur.left;\\n                    p = p.next;\\n                }\\n                if (cur.right != null) {\\n                    p.next = cur.right;\\n                    p = p.next;\\n                }\\n                cur = cur.next;\\n            }\\n            cur = sen.next;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312989,
                "title": "java-solution-0-1-space",
                "content": "```\\npublic Node connect(Node root) {\\n        Node pre = root;\\n        Node dummyNode = new Node();\\n        Node prev = dummyNode;\\n        while(root != null){\\n            if(root.left != null) {\\n                prev.next = root.left;\\n                prev = prev.next;\\n            }\\n            if(root.right != null) {\\n                prev.next = root.right;\\n                prev = prev.next;\\n            }\\n            root = root.next;\\n            if(root == null) { \\n                prev = dummyNode;\\n                root = dummyNode.next;\\n                dummyNode.next = null;\\n            }\\n        }\\n        return pre;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic Node connect(Node root) {\\n        Node pre = root;\\n        Node dummyNode = new Node();\\n        Node prev = dummyNode;\\n        while(root != null){\\n            if(root.left != null) {\\n                prev.next = root.left;\\n                prev = prev.next;\\n            }\\n            if(root.right != null) {\\n                prev.next = root.right;\\n                prev = prev.next;\\n            }\\n            root = root.next;\\n            if(root == null) { \\n                prev = dummyNode;\\n                root = dummyNode.next;\\n                dummyNode.next = null;\\n            }\\n        }\\n        return pre;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 312524,
                "title": "python-dfs-recursive-solution",
                "content": "I *think* this solution is O(1) space and should be O(n), though the `while` loop in the recursive method might need optimization or refactoring.    \\n\\nThe approach is connect each level from top to bottom, which allows the next level to connect to nodes across the previous level.  The 1st level is simple to connect, since the root node will not have any siblings.  To connect each subsequent level, each node is passed a reference to its parent, and then determine what the node\\'s next pointer should be.  If the node is a left child and the parent has a right child, simply set the node\\'s pointer to the parent\\'s right child.  Otherwise, see if the parent has a next pointer, and if so check to see if that next node has any children.  Repeat this until either a node is found with children or no such node is found (in which case the next pointer will be null).  \\n\\nThe most important thing for this DFS is to process the tree going right to left.  This is because the the leftmost nodes require potentially iterating over all the previous level\\'s next pointers, which won\\'t be fully connected if the DFS started from the left side.  \\n\\nPlease provide any feedback or suggestions for a better design/code.  \\n\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, left, right, next):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\"\"\"\\n\\ndef has_children(node: \\'Node\\'):\\n    return node.right is not None or node.left is not None\\n\\nclass Solution:\\n    \\n    def _connect(self, node: \\'Node\\', parent: \\'Node\\'):\\n        if node is None:\\n            return\\n        # look for right node if it\\'s not the same\\n        if parent.right is not None and node != parent.right:\\n            node.next = parent.right\\n        # look for children of the next parent if no right sibling\\n        elif parent.next:\\n            nxt = parent.next\\n            while nxt is not None and not has_children(nxt):\\n                nxt = nxt.next\\n            if nxt is not None:\\n                if nxt.left is not None:\\n                    node.next = nxt.left\\n                elif nxt.right is not None:\\n                    node.next = nxt.right\\n        # this order is very important\\n        self._connect(node.right, node)\\n        self._connect(node.left, node)\\n               \\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root is not None:\\n            # this order is very important, must go from \"right\" to \"left\"\\n            self._connect(root.right, root)\\n            self._connect(root.left, root)\\n        return root\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, left, right, next):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\"\"\"\\n\\ndef has_children(node: \\'Node\\'):\\n    return node.right is not None or node.left is not None\\n\\nclass Solution:\\n    \\n    def _connect(self, node: \\'Node\\', parent: \\'Node\\'):\\n        if node is None:\\n            return\\n        # look for right node if it\\'s not the same\\n        if parent.right is not None and node != parent.right:\\n            node.next = parent.right\\n        # look for children of the next parent if no right sibling\\n        elif parent.next:\\n            nxt = parent.next\\n            while nxt is not None and not has_children(nxt):\\n                nxt = nxt.next\\n            if nxt is not None:\\n                if nxt.left is not None:\\n                    node.next = nxt.left\\n                elif nxt.right is not None:\\n                    node.next = nxt.right\\n        # this order is very important\\n        self._connect(node.right, node)\\n        self._connect(node.left, node)\\n               \\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root is not None:\\n            # this order is very important, must go from \"right\" to \"left\"\\n            self._connect(root.right, root)\\n            self._connect(root.left, root)\\n        return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250615,
                "title": "c-iterative-recursive",
                "content": "Connect all subtrees of the current-level nodes as a singly linked list.\\n\\n**Iterative**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node *cur = root, *dummy = new Node(0, NULL, NULL, NULL);\\n        while (cur) {\\n            for (Node* pre = dummy; cur; cur = cur -> next) {\\n                if (cur -> left) {\\n                    pre -> next = cur -> left;\\n                    pre = pre -> next;\\n                }\\n                if (cur -> right) {\\n                    pre -> next = cur -> right;\\n                    pre = pre -> next;\\n                }\\n            }\\n            cur = dummy -> next;\\n            dummy -> next = NULL;\\n        }\\n        delete dummy;\\n        return root;\\n    }\\n};\\n```\\n\\n**Recursive**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return NULL;\\n        }\\n        Node *cur = root, *dummy = new Node(0, NULL, NULL, NULL);\\n        for (Node* pre = dummy; cur; cur = cur -> next) {\\n            if (cur -> left) {\\n                pre -> next = cur -> left;\\n                pre = pre -> next;\\n            }\\n            if (cur -> right) {\\n                pre -> next = cur -> right;\\n                pre = pre -> next;\\n            }\\n        }\\n        connect(dummy -> next);\\n        dummy -> next = NULL;\\n        delete dummy;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node *cur = root, *dummy = new Node(0, NULL, NULL, NULL);\\n        while (cur) {\\n            for (Node* pre = dummy; cur; cur = cur -> next) {\\n                if (cur -> left) {\\n                    pre -> next = cur -> left;\\n                    pre = pre -> next;\\n                }\\n                if (cur -> right) {\\n                    pre -> next = cur -> right;\\n                    pre = pre -> next;\\n                }\\n            }\\n            cur = dummy -> next;\\n            dummy -> next = NULL;\\n        }\\n        delete dummy;\\n        return root;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return NULL;\\n        }\\n        Node *cur = root, *dummy = new Node(0, NULL, NULL, NULL);\\n        for (Node* pre = dummy; cur; cur = cur -> next) {\\n            if (cur -> left) {\\n                pre -> next = cur -> left;\\n                pre = pre -> next;\\n            }\\n            if (cur -> right) {\\n                pre -> next = cur -> right;\\n                pre = pre -> next;\\n            }\\n        }\\n        connect(dummy -> next);\\n        dummy -> next = NULL;\\n        delete dummy;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 195382,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    # @param root, a tree link node\\n    # @return nothing\\n    def connect(self, root):\\n      if not root:\\n        return None\\n      \\n      from collections import deque\\n      root.next = None\\n      q = deque([root])\\n      \\n      while q:\\n        # Each time update the length of q\\n        N = len(q)\\n        for _ in range(N):\\n          node = q.popleft()\\n          if node.left:\\n            q.append(node.left)\\n          \\n          if node.right:\\n            q.append(node.right)\\n        \\n        \\n        # Update the relationship between each node\\n        if len(q) > 1:\\n          for i in range(len(q)-1):\\n            q[i].next = q[i+1]\\n          \\n          q[-1].next = None\\n            \\n          \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # @param root, a tree link node\\n    # @return nothing\\n    def connect(self, root):\\n      if not root:\\n        return None\\n      \\n      from collections import deque\\n      root.next = None\\n      q = deque([root])\\n      \\n      while q:\\n        # Each time update the length of q\\n        N = len(q)\\n        for _ in range(N):\\n          node = q.popleft()\\n          if node.left:\\n            q.append(node.left)\\n          \\n          if node.right:\\n            q.append(node.right)\\n        \\n        \\n        # Update the relationship between each node\\n        if len(q) > 1:\\n          for i in range(len(q)-1):\\n            q[i].next = q[i+1]\\n          \\n          q[-1].next = None\\n            \\n          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 141474,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def connect(self, root):\\n        if not root:\\n            return root\\n\\n        dummy = Node(0)\\n        curr = root\\n        while curr:\\n            dummy.next = None\\n            tmp = dummy\\n            while curr:\\n                if curr.left:\\n                    tmp.next = curr.left\\n                    tmp = tmp.next\\n                if curr.right:\\n                    tmp.next = curr.right\\n                    tmp = tmp.next\\n                curr = curr.next\\n            curr = dummy.next\\n\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connect(self, root):\\n        if not root:\\n            return root\\n\\n        dummy = Node(0)\\n        curr = root\\n        while curr:\\n            dummy.next = None\\n            tmp = dummy\\n            while curr:\\n                if curr.left:\\n                    tmp.next = curr.left\\n                    tmp = tmp.next\\n                if curr.right:\\n                    tmp.next = curr.right\\n                    tmp = tmp.next\\n                curr = curr.next\\n            curr = dummy.next\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37881,
                "title": "python-dfs",
                "content": "\\n```\\nclass Solution:\\n    def connect(self, root):\\n        dic = {}\\n        def dfs(r, d):\\n            if not r:\\n                return\\n            if d in dic:\\n                dic[d].next = r\\n            dic[d] = r\\n            r.next = None\\n            dfs(r.left, d + 1)\\n            dfs(r.right, d + 1)\\n        dfs(root, 0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connect(self, root):\\n        dic = {}\\n        def dfs(r, d):\\n            if not r:\\n                return\\n            if d in dic:\\n                dic[d].next = r\\n            dic[d] = r\\n            r.next = None\\n            dfs(r.left, d + 1)\\n            dfs(r.right, d + 1)\\n        dfs(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37908,
                "title": "java-solution-with-o-n-time-and-o-1-space-27-lines",
                "content": "Once you got the basic idea, it is easy to understand this solution.\\n\\nThe most important thing to realize is that:\\n\\n**Each level above the current level, is already a linked list!**\\n\\nFor example,\\n```\\n     1 -> NULL        level 1\\n    /  \\\\\\n   2 -> 3 -> NULL     level 2\\n  / \\\\    \\\\\\n4-> 5 -> 7 -> NULL    level 3\\n```\\n\\nConsider this tree. At first, link ```root``` to ```null```; Thus level 1 is a linked list. Then we move on to level 2; and sicne level 1 is already a linked list, we can iterate each node in the linked list (just one node except null at this level), and link the children from left to right (), then link to ```null``` at the end. Moving on to level 3; level 2 is already a linked list, so we iterate each node (```2```, and ```3```), link their children from left to right (skip if the children is null, such as the left child of node ```3```), then link to ```null``` at the end. Same idea applies beyond.\\n\\nThus, we just need to iterate each element of the above level, link their left and right nodes (if it has) in order, and then iterate through each level.\\n\\nThe Java code is attached below: (~ 27 lines) It uses ```O(n)``` time and ```O(1)``` space.\\n\\n```\\npublic class Solution {\\n    public void connect(TreeLinkNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        root.next = null;\\n        TreeLinkNode lasthead = root;\\n        TreeLinkNode dummy;\\n        TreeLinkNode cur;\\n        while (lasthead != null) {\\n            dummy = new TreeLinkNode(0);\\n            cur = dummy;\\n            while (lasthead!= null) {\\n                if (lasthead.left != null) {\\n                    cur.next = lasthead.left;\\n                    cur = cur.next;\\n                }\\n                if (lasthead.right != null) {\\n                    cur.next = lasthead.right;\\n                    cur = cur.next;\\n                }\\n                lasthead = lasthead.next;\\n            }\\n            cur.next = null;\\n            lasthead = dummy.next;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n     1 -> NULL        level 1\\n    /  \\\\\\n   2 -> 3 -> NULL     level 2\\n  / \\\\    \\\\\\n4-> 5 -> 7 -> NULL    level 3\\n```\n```root```\n```null```\n```null```\n```2```\n```3```\n```3```\n```null```\n```O(n)```\n```O(1)```\n```\\npublic class Solution {\\n    public void connect(TreeLinkNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        root.next = null;\\n        TreeLinkNode lasthead = root;\\n        TreeLinkNode dummy;\\n        TreeLinkNode cur;\\n        while (lasthead != null) {\\n            dummy = new TreeLinkNode(0);\\n            cur = dummy;\\n            while (lasthead!= null) {\\n                if (lasthead.left != null) {\\n                    cur.next = lasthead.left;\\n                    cur = cur.next;\\n                }\\n                if (lasthead.right != null) {\\n                    cur.next = lasthead.right;\\n                    cur = cur.next;\\n                }\\n                lasthead = lasthead.next;\\n            }\\n            cur.next = null;\\n            lasthead = dummy.next;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37928,
                "title": "straight-forward-java-recursive-solution",
                "content": "```\\n public void connect2(TreeLinkNode root) {\\n         if (root == null) return;\\n         \\n         if (root.left != null) {\\n             if (root.right != null) root.left.next = root.right;\\n             else {\\n                 TreeLinkNode next = root.next;\\n                 while (next != null) {\\n                     if (next.left != null || next.right != null) {\\n                         root.left.next = next.left != null ? next.left : next.right;\\n                         break;\\n                     } else next = next.next;\\n                 }\\n             }\\n         }\\n         if (root.right != null) {\\n             TreeLinkNode next = root.next;\\n             while (next != null) {\\n                 if (next.left != null || next.right != null) {\\n                     root.right.next = next.left != null ? next.left : next.right;\\n                     break;\\n                 } else next = next.next;\\n             }\\n         }\\n         \\n         \\n         connect2(root.right);\\n         connect2(root.left);\\n     }\\n```",
                "solutionTags": [],
                "code": "```\\n public void connect2(TreeLinkNode root) {\\n         if (root == null) return;\\n         \\n         if (root.left != null) {\\n             if (root.right != null) root.left.next = root.right;\\n             else {\\n                 TreeLinkNode next = root.next;\\n                 while (next != null) {\\n                     if (next.left != null || next.right != null) {\\n                         root.left.next = next.left != null ? next.left : next.right;\\n                         break;\\n                     } else next = next.next;\\n                 }\\n             }\\n         }\\n         if (root.right != null) {\\n             TreeLinkNode next = root.next;\\n             while (next != null) {\\n                 if (next.left != null || next.right != null) {\\n                     root.right.next = next.left != null ? next.left : next.right;\\n                     break;\\n                 } else next = next.next;\\n             }\\n         }\\n         \\n         \\n         connect2(root.right);\\n         connect2(root.left);\\n     }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38004,
                "title": "ac-java-o-n-time-o-1-space-short",
                "content": "\\n     public void connect(TreeLinkNode root) {\\n        TreeLinkNode previous = null;\\n        TreeLinkNode levelLeftmost = root;\\n        while (levelLeftmost != null) {\\n            TreeLinkNode parent = levelLeftmost;\\n            levelLeftmost = null;\\n            previous = null;\\n            while(parent != null) {\\n                if (levelLeftmost == null) levelLeftmost = parent.left;\\n                if (levelLeftmost == null) levelLeftmost = parent.right;\\n                previous = connectNodes(previous, parent.left);\\n                previous = connectNodes(previous, parent.right);\\n                parent = parent.next;\\n            }\\n        }\\n     }\\n     \\n     private TreeLinkNode connectNodes(TreeLinkNode previous, TreeLinkNode next) {\\n         if (previous != null) previous.next = next;\\n         return next == null ? previous : next;\\n     }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "\\n     public void connect(TreeLinkNode root) {\\n        TreeLinkNode previous = null;\\n        TreeLinkNode levelLeftmost = root;\\n        while (levelLeftmost != null) {\\n            TreeLinkNode parent = levelLeftmost;\\n            levelLeftmost = null;\\n            previous = null;\\n            while(parent != null) {\\n                if (levelLeftmost == null) levelLeftmost = parent.left;\\n                if (levelLeftmost == null) levelLeftmost = parent.right;\\n                previous = connectNodes(previous, parent.left);\\n                previous = connectNodes(previous, parent.right);\\n                parent = parent.next;\\n            }\\n        }\\n     }\\n     \\n     private TreeLinkNode connectNodes(TreeLinkNode previous, TreeLinkNode next) {\\n         if (previous != null) previous.next = next;\\n         return next == null ? previous : next;\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 38016,
                "title": "super-short-java-recursion-solution-with-o-1-space-and-another-iterative-bfs-o-n-time-and-o-1-space",
                "content": "Code is short and easy to understand, the merge part is just like a DFS in two trees simultaneously, the order of the four recursions matters.\\n\\nThen the pain is the time complexity. It's slow but just enough to get AC.\\n\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n        \\tif(root==null) return; \\n        \\tconnect(root.left);\\n        \\tconnect(root.right);\\n        \\tmerge(root.left,1,root.right,new int[1]);\\n        }\\n        \\n        public void merge(TreeLinkNode rootL, int currDepth, TreeLinkNode rootR, int[] visitedDepth){\\n        \\tif(rootL==null || rootR==null) return;\\n        \\tif(currDepth> visitedDepth[0]) {\\n        \\t\\trootL.next = rootR;\\n        \\t\\tvisitedDepth[0]++;\\n        \\t}\\n        \\tmerge(rootL.right,currDepth+1,rootR.left,visitedDepth);\\n        \\tmerge(rootL.right,currDepth+1,rootR.right,visitedDepth);\\n        \\tmerge(rootL.left,currDepth+1,rootR.left,visitedDepth);\\n        \\tmerge(rootL.left,currDepth+1,rootR.right,visitedDepth);\\n        }\\n    }\\n\\nHere is iterative BFS solution with O(n) time complexity and O(1) space.\\n\\nExplanation for 2nd solution: It's a BFS traversal inspired by [aileengw][1]. The curr pointer is the current level traveler and head is the left most element at next level and the tail is the right most element at next level till now. We move curr pointer at current level and populate the the next-link at its children level. (Here the gist is we can move curr to its next because this relationship was already populated in the previous round).\\n\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n        \\tTreeLinkNode curr = root;\\n        \\tTreeLinkNode head = null, tail = null;\\n        \\twhile(curr!=null) {\\n        \\t    if(curr.left!=null) {\\n        \\t        if(tail!=null) {\\n        \\t            tail.next = curr.left;\\n        \\t            tail = tail.next;\\n        \\t        }\\n        \\t        else {\\n        \\t            head = curr.left;\\n        \\t            tail = head;\\n        \\t        }\\n        \\t    }\\n        \\t    if(curr.right!=null) {\\n        \\t        if(tail!=null) {\\n        \\t            tail.next = curr.right;\\n        \\t            tail = tail.next;\\n        \\t        }\\n        \\t        else {\\n        \\t            head = curr.right;\\n        \\t            tail = head;\\n        \\t        }\\n        \\t    }\\n        \\t    if(curr.next!=null) curr = curr.next;\\n        \\t    else {\\n        \\t        curr = head;\\n        \\t        head = null;\\n        \\t        tail = null;\\n        \\t    }\\n        \\t}\\n        }\\n    }\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/44411/simple-40ms-c-o-n-o-1-solution-with-only-one-while-loop",
                "solutionTags": [],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n        \\tif(root==null) return; \\n        \\tconnect(root.left);\\n        \\tconnect(root.right);\\n        \\tmerge(root.left,1,root.right,new int[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 38020,
                "title": "accepted-solution-in-java-using-queue-level-order-traversal",
                "content": "    public void connect(TreeLinkNode root) {\\n        Queue<TreeLinkNode> qu = new LinkedList<>();\\n        if(root != null) {\\n            qu.add(root);\\n            while (!qu.isEmpty()) {\\n                int n = qu.size();\\n                for (int i = 0; i < n; i++) {\\n                    TreeLinkNode p = qu.remove();\\n                    if (p.left != null) qu.add(p.left);\\n                    if (p.right != null) qu.add(p.right);\\n                    if (i == n - 1) {\\n                        p.next = null;\\n                    } else {\\n                        p.next = qu.peek();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\nI solved problem using queue. I think its time-complexity is O(n). Is space-complexity of this O(n)?",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "    public void connect(TreeLinkNode root) {\\n        Queue<TreeLinkNode> qu = new LinkedList<>();\\n        if(root != null) {\\n            qu.add(root);\\n            while (!qu.isEmpty()) {\\n                int n = qu.size();\\n                for (int i = 0; i < n; i++) {\\n                    TreeLinkNode p = qu.remove();\\n                    if (p.left != null) qu.add(p.left);\\n                    if (p.right != null) qu.add(p.right);\\n                    if (i == n - 1) {\\n                        p.next = null;\\n                    } else {\\n                        p.next = qu.peek();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\nI solved problem using queue. I think its time-complexity is O(n). Is space-complexity of this O(n)?",
                "codeTag": "Unknown"
            },
            {
                "id": 38036,
                "title": "another-accepted-java-solution",
                "content": "The idea is to use next pointer to traverse at each level, and call getNext(root) to get the left most node at the next level.\\n\\n    public static class Solution {\\n        \\n        public void connect(TreeLinkNode root) {\\n          while (root != null) {\\n            TreeLinkNode curr = root;\\n            \\n            // level traversal\\n            while (curr != null) {\\n              if (curr.left != null) {\\n                curr.left.next = curr.right != null ? curr.right : getNext(curr);\\n              }\\n              \\n              if (curr.right != null) {\\n                curr.right.next = getNext(curr);\\n              }\\n              \\n              curr = curr.next;\\n            }\\n            \\n            // next level\\n            if (root.left != null) {\\n              root = root.left;\\n            } else if (root.right != null) {\\n              root = root.right;\\n            } else {\\n              root = getNext(root);\\n            }\\n          }\\n        }\\n        \\n        TreeLinkNode getNext(TreeLinkNode node) {\\n          TreeLinkNode next = node.next;\\n          \\n          while (next != null) {\\n            if (next.left != null) return next.left;\\n            if (next.right != null) return next.right;\\n            next = next.next;\\n          }\\n          \\n          return null;\\n        }\\n        \\n      }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        \\n        public void connect(TreeLinkNode root) {\\n          while (root != null) {\\n            TreeLinkNode curr = root;\\n            \\n            // level traversal\\n            while (curr != null) {\\n              if (curr.left != null) {\\n                curr.left.next = curr.right != null ? curr.right : getNext(curr);\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 38058,
                "title": "share-c-40ms-code-constant-space",
                "content": "#C++ Code:(old version with extra function, easier to understand)\\n\\n    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            temp = new TreeLinkNode(0);\\n            TreeLinkNode *next_root = root;\\n            while(next_root){\\n                link(next_root);\\n                next_root = temp->next;\\n            }\\n        }\\n    private:\\n        TreeLinkNode *temp;\\n        void link(TreeLinkNode *head){\\n            temp->next = NULL;\\n            TreeLinkNode *leaf_head = temp;\\n            while(head){\\n                TreeLinkNode *leaf = head->left;\\n                if(leaf){\\n                    leaf_head->next = leaf;\\n                    leaf_head = leaf_head->next;\\n                }\\n                leaf = head->right;\\n                if(leaf){\\n                    leaf_head->next = leaf;\\n                    leaf_head = leaf_head->next;\\n                }\\n                head=head->next;\\n            }\\n        }\\n    };\\n\\n___\\n#Optimized Version:(costs less time, change some variable name)\\n\\n    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            TreeLinkNode *pseudo = new TreeLinkNode(0);\\n            TreeLinkNode *level = root;\\n            while(level!=NULL){\\n                pseudo->next = NULL;\\n                TreeLinkNode *leaf_head = pseudo;\\n                while(level!=NULL){\\n                    TreeLinkNode *node = level->left;\\n                    if(node!=NULL){\\n                        leaf_head->next = node;\\n                        leaf_head = node;\\n                    }\\n                    node = level->right;\\n                    if(node!=NULL){\\n                        leaf_head->next = node;\\n                        leaf_head = node;\\n                    }\\n                    level=level->next;\\n                }\\n                level = pseudo->next;\\n            }\\n        }\\n    };\\n\\n___\\n#And make it more concise:\\n\\n    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            TreeLinkNode *pseudo = new TreeLinkNode(0);\\n            TreeLinkNode *level = root;\\n            while(level){\\n                pseudo->next = NULL;\\n                TreeLinkNode *leaf_head = pseudo;\\n                TreeLinkNode *temp;\\n                while(level){\\n                    temp = level->left;\\n                    (!temp)||(leaf_head->next=temp,leaf_head=temp);\\n                    temp = level->right;\\n                    (!temp)||(leaf_head->next=temp,leaf_head=temp);\\n                    level=level->next;\\n                }\\n                level = pseudo->next;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            temp = new TreeLinkNode(0);\\n            TreeLinkNode *next_root = root;\\n            while(next_root){\\n                link(next_root);\\n                next_root = temp->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 38110,
                "title": "my-solution-with-o-1-space-and-o-n-time-anyone-has-simpler-code",
                "content": "This is my code. Is there any simpler solution?\\n\\n    void connect(TreeLinkNode *root) {\\n        if (root == NULL) return;\\n        TreeLinkNode * start = root;\\n        TreeLinkNode * end = root;\\n        TreeLinkNode * levelEnd = root;\\n        while (start != NULL)\\n        {\\n            if (start->left != NULL)\\n            {\\n                end->next = start->left;\\n                end = end->next;\\n            }\\n            if (start->right != NULL)\\n            {\\n                end->next = start->right;\\n                end = end->next;\\n            }\\n            if (start == levelEnd)\\n            {\\n                start = start->next;\\n                levelEnd->next = NULL;\\n                levelEnd = end;\\n            }\\n            else\\n            {\\n                start = start->next;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "This is my code. Is there any simpler solution?\\n\\n    void connect(TreeLinkNode *root) {\\n        if (root == NULL) return;\\n        TreeLinkNode * start = root;\\n        TreeLinkNode * end = root;\\n        TreeLinkNode * levelEnd = root;\\n        while (start != NULL)\\n        {\\n            if (start->left != NULL)\\n            {\\n                end->next = start->left;\\n                end = end->next;\\n            }\\n            if (start->right != NULL)\\n            {\\n                end->next = start->right;\\n                end = end->next;\\n            }\\n            if (start == levelEnd)\\n            {\\n                start = start->next;\\n                levelEnd->next = NULL;\\n                levelEnd = end;\\n            }\\n            else\\n            {\\n                start = start->next;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3835306,
                "title": "3-solutions-brute-optimal-self-explanatory-comments-time-beats-95-memory-beats-98",
                "content": "~ \\uD835\\uDE52\\uD835\\uDE5E\\uD835\\uDE69\\uD835\\uDE5D \\u2764\\uFE0F \\uD835\\uDE57\\uD835\\uDE6E \\uD835\\uDE43\\uD835\\uDE5E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE63 \\uD83D\\uDE0A\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHey There! It\\'s Easy Just Take A Look At The Code And Comments Within It! You\\'ll Get It.\\n\\nStill Got Doubts! Feel Free To Comment, I Will Definitely Reply!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- All Accepted\\n\\n# Complexity\\n- Time complexity: Mentioned in the code\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Mentioned in the code\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nApproach 1 : Using DFS + Vector\\n```\\n// #1 Method helper\\nvoid dfs(Node* root, vector<Node*>& nodesLevelWise, int currLevel) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return;\\n\\n    // When the current level is seen for the first time\\n    if(nodesLevelWise.size() == currLevel)\\n        nodesLevelWise.push_back(root);\\n    // Else when the current level is seen again\\n    else\\n        nodesLevelWise[currLevel]->next = root, nodesLevelWise[currLevel] = root;\\n\\n    dfs(root->left, nodesLevelWise, currLevel+1);\\n    dfs(root->right, nodesLevelWise, currLevel+1);\\n}\\n\\n// #1 Method to populate next right pointers in each node using dfs - O(N) & O(L) : Where L is the total number of levels\\nNode* connect(Node* root) {\\n    vector<Node*> nodesLevelWise;\\n    dfs(root, nodesLevelWise, 0);\\n    return root;\\n}\\n```\\nApproach 2 : Using BFS\\n```\\n// #2 Method to populate next right pointers in each node using bfs - O(N) & O(M) : Where M let be the maximum nodes at any level\\nNode* connect(Node* root) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return nullptr;\\n\\n    queue<Node*> q;\\n    q.push(root);\\n\\n    while(!q.empty()) {\\n        int qSize = q.size();\\n        Node* prev = nullptr; // Require to track the previous node of any node at a level\\n\\n        while(qSize--) {\\n            Node* curr = q.front(); q.pop();\\n            \\n            // If the previous node of the current node exist\\n            if(prev)\\n                prev->next = curr;\\n            \\n            // If the left of the current node exist\\n            if(curr->left)\\n                q.push(curr->left);\\n\\n            // If the right of the current node exist\\n            if(curr->right)\\n                q.push(curr->right);\\n\\n            prev = curr;\\n        }\\n\\n    }\\n\\n    return root;\\n}\\n```\\nApproach 3 : Using BFS + Constant Space\\n```\\n// #3 Method to populate next right pointers in each node (in-place) - O(N) & O(1)\\nNode* connect(Node* root) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return nullptr;\\n\\n    // Require to represent the first node of any level\\n    Node* currLevelFirstNode = root;\\n\\n    while(currLevelFirstNode) {\\n        Node* currentNode = currLevelFirstNode;\\n        currLevelFirstNode = nullptr;\\n        // Require to represent the previously connected node for the current level node\\n        Node* lastConnectedNode = nullptr;\\n\\n        while(currentNode) {\\n            for(auto& child : {currentNode->left, currentNode->right}) {\\n                // If the node does not exist\\n                if(!child)\\n                    continue;\\n                \\n                // If current is the first node of the current level\\n                if(!currLevelFirstNode)\\n                    currLevelFirstNode = child;\\n\\n                // If the previously connected node exist\\n                if(lastConnectedNode)\\n                    lastConnectedNode->next = child;\\n\\n                // Update the previously connected node each time\\n                lastConnectedNode = child;\\n            }\\n            currentNode = currentNode->next;\\n        }          \\n\\n    }\\n\\n    return root;\\n}\\n```\\n\\uD835\\uDDE8\\uD835\\uDDE3\\uD835\\uDDE9\\uD835\\uDDE2\\uD835\\uDDE7\\uD835\\uDDD8 \\uD835\\uDDDC\\uD835\\uDDD9 \\uD835\\uDDEC\\uD835\\uDDE2\\uD835\\uDDE8 \\uD835\\uDDDF\\uD835\\uDDDC\\uD835\\uDDDE\\uD835\\uDDD8 \\uD835\\uDDE7\\uD835\\uDDDB\\uD835\\uDDD8 \\uD835\\uDDE6\\uD835\\uDDE2\\uD835\\uDDDF\\uD835\\uDDE8\\uD835\\uDDE7\\uD835\\uDDDC\\uD835\\uDDE2\\uD835\\uDDE1 \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// #1 Method helper\\nvoid dfs(Node* root, vector<Node*>& nodesLevelWise, int currLevel) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return;\\n\\n    // When the current level is seen for the first time\\n    if(nodesLevelWise.size() == currLevel)\\n        nodesLevelWise.push_back(root);\\n    // Else when the current level is seen again\\n    else\\n        nodesLevelWise[currLevel]->next = root, nodesLevelWise[currLevel] = root;\\n\\n    dfs(root->left, nodesLevelWise, currLevel+1);\\n    dfs(root->right, nodesLevelWise, currLevel+1);\\n}\\n\\n// #1 Method to populate next right pointers in each node using dfs - O(N) & O(L) : Where L is the total number of levels\\nNode* connect(Node* root) {\\n    vector<Node*> nodesLevelWise;\\n    dfs(root, nodesLevelWise, 0);\\n    return root;\\n}\\n```\n```\\n// #2 Method to populate next right pointers in each node using bfs - O(N) & O(M) : Where M let be the maximum nodes at any level\\nNode* connect(Node* root) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return nullptr;\\n\\n    queue<Node*> q;\\n    q.push(root);\\n\\n    while(!q.empty()) {\\n        int qSize = q.size();\\n        Node* prev = nullptr; // Require to track the previous node of any node at a level\\n\\n        while(qSize--) {\\n            Node* curr = q.front(); q.pop();\\n            \\n            // If the previous node of the current node exist\\n            if(prev)\\n                prev->next = curr;\\n            \\n            // If the left of the current node exist\\n            if(curr->left)\\n                q.push(curr->left);\\n\\n            // If the right of the current node exist\\n            if(curr->right)\\n                q.push(curr->right);\\n\\n            prev = curr;\\n        }\\n\\n    }\\n\\n    return root;\\n}\\n```\n```\\n// #3 Method to populate next right pointers in each node (in-place) - O(N) & O(1)\\nNode* connect(Node* root) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return nullptr;\\n\\n    // Require to represent the first node of any level\\n    Node* currLevelFirstNode = root;\\n\\n    while(currLevelFirstNode) {\\n        Node* currentNode = currLevelFirstNode;\\n        currLevelFirstNode = nullptr;\\n        // Require to represent the previously connected node for the current level node\\n        Node* lastConnectedNode = nullptr;\\n\\n        while(currentNode) {\\n            for(auto& child : {currentNode->left, currentNode->right}) {\\n                // If the node does not exist\\n                if(!child)\\n                    continue;\\n                \\n                // If current is the first node of the current level\\n                if(!currLevelFirstNode)\\n                    currLevelFirstNode = child;\\n\\n                // If the previously connected node exist\\n                if(lastConnectedNode)\\n                    lastConnectedNode->next = child;\\n\\n                // Update the previously connected node each time\\n                lastConnectedNode = child;\\n            }\\n            currentNode = currentNode->next;\\n        }          \\n\\n    }\\n\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3669199,
                "title": "java-solution-recursion-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null) return root;\\n        if(root.left!=null && root.right!=null) root.left.next = root.right;\\n        if(root.left!=null && root.right==null && root.next!=null){\\n            root.left.next = helper(root.next);    \\n        }  \\n        if(root.right!=null && root.next!=null) root.right.next = helper(root.next);      \\n        connect(root.right);\\n        connect(root.left);\\n        return root;\\n    }\\n\\n    public Node helper(Node root){\\n        if(root==null) return root;\\n        if(root.left!=null) return root.left;\\n        if(root.right!=null) return root.right;\\n        return helper(root.next);\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null) return root;\\n        if(root.left!=null && root.right!=null) root.left.next = root.right;\\n        if(root.left!=null && root.right==null && root.next!=null){\\n            root.left.next = helper(root.next);    \\n        }  \\n        if(root.right!=null && root.next!=null) root.right.next = helper(root.next);      \\n        connect(root.right);\\n        connect(root.left);\\n        return root;\\n    }\\n\\n    public Node helper(Node root){\\n        if(root==null) return root;\\n        if(root.left!=null) return root.left;\\n        if(root.right!=null) return root.right;\\n        return helper(root.next);\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596476,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null){\\n            return null;\\n        }\\n   Queue<Node>alpha = new LinkedList<>();\\n  alpha.add(root);\\n  alpha.add(null);\\n  while(!alpha.isEmpty()){ \\n     Node current = alpha.poll();\\n     if(current==null){\\n        if(alpha.isEmpty()){\\n        //  return root;  \\n        break; \\n        }\\n        else{\\n            alpha.add(null);\\n        }\\n     }\\n     else{\\n         current.next = alpha.peek();\\n         if(current.left!=null){\\n             alpha.add(current.left);\\n         }\\n         if(current.right!=null){\\n             alpha.add(current.right);\\n         }\\n     } \\n  }\\n   return root;  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null){\\n            return null;\\n        }\\n   Queue<Node>alpha = new LinkedList<>();\\n  alpha.add(root);\\n  alpha.add(null);\\n  while(!alpha.isEmpty()){ \\n     Node current = alpha.poll();\\n     if(current==null){\\n        if(alpha.isEmpty()){\\n        //  return root;  \\n        break; \\n        }\\n        else{\\n            alpha.add(null);\\n        }\\n     }\\n     else{\\n         current.next = alpha.peek();\\n         if(current.left!=null){\\n             alpha.add(current.left);\\n         }\\n         if(current.right!=null){\\n             alpha.add(current.right);\\n         }\\n     } \\n  }\\n   return root;  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415391,
                "title": "c-solution-easy-solution",
                "content": "\\n# Code\\n```\\n/*\\n// Definition for a Node.\\npublic class Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n}\\n*/\\n\\npublic class Solution {\\n    public Node Connect(Node root) {\\n        if(root == null) return root;\\n        Queue<Node> q = new Queue<Node>();\\n        q.Enqueue(root);\\n        while(q.Count > 0){\\n            int count = q.Count;\\n            Node prev = null;\\n            for(int i = 0; i < count;i++){\\n                Node cur = q.Dequeue();\\n                if(cur.right != null)  q.Enqueue(cur.right);\\n                if(cur.left != null)  q.Enqueue(cur.left);\\n                cur.next = prev;\\n                prev = cur;\\n            }\\n        }\\n        return root;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\npublic class Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n}\\n*/\\n\\npublic class Solution {\\n    public Node Connect(Node root) {\\n        if(root == null) return root;\\n        Queue<Node> q = new Queue<Node>();\\n        q.Enqueue(root);\\n        while(q.Count > 0){\\n            int count = q.Count;\\n            Node prev = null;\\n            for(int i = 0; i < count;i++){\\n                Node cur = q.Dequeue();\\n                if(cur.right != null)  q.Enqueue(cur.right);\\n                if(cur.left != null)  q.Enqueue(cur.left);\\n                cur.next = prev;\\n                prev = cur;\\n            }\\n        }\\n        return root;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197037,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root)return root;\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int x=q.size();\\n            while(x--){\\n                Node* s=q.front();\\n                q.pop();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t/* If s is the rightmost node of current level, set next pointer to NULL */\\n                if(x==0)s->next=NULL;\\n                else s->next=q.front();\\n\\t\\t\\t\\t\\n                if(s->left)q.push(s->left);\\n                if(s->right)q.push(s->right);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root)return root;\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int x=q.size();\\n            while(x--){\\n                Node* s=q.front();\\n                q.pop();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t/* If s is the rightmost node of current level, set next pointer to NULL */\\n                if(x==0)s->next=NULL;\\n                else s->next=q.front();\\n\\t\\t\\t\\t\\n                if(s->left)q.push(s->left);\\n                if(s->right)q.push(s->right);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196566,
                "title": "bfs-traversal-simple-solution-one-code-for-2-questions",
                "content": "This code will work for both these questions :\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question we given only the right view of binary tree is null so this problem is similar to https://leetcode.com/problems/binary-tree-right-side-view/\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBFS Traversal\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(W) width of binary tree\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null)\\n            return null;\\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                Node cur = q.poll();\\n                if(i == size-1)\\n                    cur.next = null;\\n                else\\n                    cur.next = q.peek();\\n                if(cur.left != null)\\n                    q.offer(cur.left);\\n                if(cur.right != null)\\n                    q.offer(cur.right);\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null)\\n            return null;\\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                Node cur = q.poll();\\n                if(i == size-1)\\n                    cur.next = null;\\n                else\\n                    cur.next = q.peek();\\n                if(cur.left != null)\\n                    q.offer(cur.left);\\n                if(cur.right != null)\\n                    q.offer(cur.right);\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195700,
                "title": "with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can solve this problem using BFS. We can traverse the tree level by level using the BFS approach and for each node, we can keep track of its next pointer. We can use a queue to keep track of the nodes of the current level. We can then process the nodes of the current level by dequeuing them from the queue one by one, and assigning the next pointer of each node to the front element of the queue. Once we have processed all the nodes of the current level, we can move to the next level by enqueuing the children of the nodes of the current level.\\n\\n# Complexity\\n- Time complexity:\\nO(N), where N is the number of nodes in the tree.\\n\\n- Space complexity:\\nO(N), where N is the maximum number of nodes at any level in the tree. In the worst case, the maximum number of nodes at any level in the tree is N/2. This happens when the binary tree is a complete binary tree. In this case, the last level of the tree has N/2 nodes, and the size of the queue can be at most N/2. Therefore, the space complexity of the algorithm is O(N).\\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n  def connect(self, root: \\'Node\\') -> \\'Node\\':\\n    # Edge case - If the root is None, then return None\\n    if root is None:\\n        return None\\n    \\n    # Create a queue and enqueue the root node\\n    q = deque([root])\\n    \\n    # Traverse the tree level by level\\n    while q:\\n        \\n        # Get the number of nodes of the current level\\n        level_size = len(q)\\n        \\n        # Process the nodes of the current level\\n        for i in range(level_size):\\n            \\n            # Dequeue a node from the front of the queue\\n            node = q.popleft()\\n            \\n            # Assign the next pointer of the node\\n            if i < level_size - 1:\\n                node.next = q[0]\\n            \\n            # Enqueue the children of the node (if any)\\n            if node.left is not None:\\n                q.append(node.left)\\n            if node.right is not None:\\n                q.append(node.right)\\n    \\n    # Return the root node\\n    return root\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n  def connect(self, root: \\'Node\\') -> \\'Node\\':\\n    # Edge case - If the root is None, then return None\\n    if root is None:\\n        return None\\n    \\n    # Create a queue and enqueue the root node\\n    q = deque([root])\\n    \\n    # Traverse the tree level by level\\n    while q:\\n        \\n        # Get the number of nodes of the current level\\n        level_size = len(q)\\n        \\n        # Process the nodes of the current level\\n        for i in range(level_size):\\n            \\n            # Dequeue a node from the front of the queue\\n            node = q.popleft()\\n            \\n            # Assign the next pointer of the node\\n            if i < level_size - 1:\\n                node.next = q[0]\\n            \\n            # Enqueue the children of the node (if any)\\n            if node.left is not None:\\n                q.append(node.left)\\n            if node.right is not None:\\n                q.append(node.right)\\n    \\n    # Return the root node\\n    return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094430,
                "title": "simple-concise-c-solution",
                "content": "\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root)return root;\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                Node* curr=q.front();\\n                q.pop();\\n                if(i==n-1){\\n                    curr->next=NULL;\\n                }else{\\n                    curr->next=q.front();\\n                }\\n                if(curr->left)q.push(curr->left);\\n                if(curr->right)q.push(curr->right);\\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root)return root;\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                Node* curr=q.front();\\n                q.pop();\\n                if(i==n-1){\\n                    curr->next=NULL;\\n                }else{\\n                    curr->next=q.front();\\n                }\\n                if(curr->left)q.push(curr->left);\\n                if(curr->right)q.push(curr->right);\\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053056,
                "title": "c-level-order-traversal-easy-to-understand",
                "content": "\\n\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(W)$$,  `Where W = max width`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        vector<Node*> q;\\n        q.push_back(root);\\n\\n\\n        while(!q.empty()) {\\n            vector<Node*> t;\\n            if(q[0] == nullptr) return root;\\n            for(auto x : q) {\\n                if( x -> left) t.push_back(x -> left);\\n                if( x -> right) t.push_back(x -> right);\\n            }\\n\\n            for(int i = 0; i < q.size() - 1; i++) {\\n                q[i] -> next = q[i+1];\\n            }\\n            swap(q, t);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        vector<Node*> q;\\n        q.push_back(root);\\n\\n\\n        while(!q.empty()) {\\n            vector<Node*> t;\\n            if(q[0] == nullptr) return root;\\n            for(auto x : q) {\\n                if( x -> left) t.push_back(x -> left);\\n                if( x -> right) t.push_back(x -> right);\\n            }\\n\\n            for(int i = 0; i < q.size() - 1; i++) {\\n                q[i] -> next = q[i+1];\\n            }\\n            swap(q, t);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040947,
                "title": "c-solution-using-bfs-with-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node*> q;\\n        if(root)q.push(root);\\n        \\n        int ln;\\n        while(!q.empty()){\\n            \\n            ln= q.size();\\n            for(int i=0;i<ln;i++){\\n                \\n                auto temp= q.front();\\n                q.pop();\\n                \\n                if(temp->left)q.push(temp->left);\\n                if(temp->right)q.push(temp->right);\\n\\n                if(i== ln-1) temp->next= NULL;\\n                else temp->next= q.front();\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node*> q;\\n        if(root)q.push(root);\\n        \\n        int ln;\\n        while(!q.empty()){\\n            \\n            ln= q.size();\\n            for(int i=0;i<ln;i++){\\n                \\n                auto temp= q.front();\\n                q.pop();\\n                \\n                if(temp->left)q.push(temp->left);\\n                if(temp->right)q.push(temp->right);\\n\\n                if(i== ln-1) temp->next= NULL;\\n                else temp->next= q.front();\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952479,
                "title": "2-java-solution-itertative-and-recursive",
                "content": "\\nJust Perform level order level wise and keep track of next node.\\nsince we want next node to available. hence add right child to queue first. so that we will have already processed next node of current node first.\\n\\n\\n# Code Iterative\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null) {\\n            return null;\\n        }\\n        Deque<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty()) {\\n            int size=queue.size();\\n            Node next=null;\\n            while(size-->0) {\\n                Node node = queue.poll();\\n                node.next = next;\\n                if(node.right!=null) {\\n                    queue.add(node.right);\\n                }\\n                if(node.left!=null) {\\n                    queue.add(node.left);\\n                }\\n                next=node;\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n\\n# Code Recursive\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null) {\\n            return null;\\n        }\\n        if(root.left!=null) {\\n            if(root.right!=null) {\\n                root.left.next=root.right;\\n            } else {\\n                root.left.next=find(root.next);\\n            }\\n        }\\n        if(root.right!=null) {\\n            root.right.next=find(root.next);\\n        }\\n        connect(root.right);\\n        connect(root.left);\\n        return root;\\n    }\\n    private Node find(Node root) {\\n        while(root!=null) {\\n            if(root.left!=null) {\\n                return root.left;\\n            }\\n            if(root.right!=null) {\\n                return root.right;\\n            }\\n            root=root.next;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null) {\\n            return null;\\n        }\\n        Deque<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty()) {\\n            int size=queue.size();\\n            Node next=null;\\n            while(size-->0) {\\n                Node node = queue.poll();\\n                node.next = next;\\n                if(node.right!=null) {\\n                    queue.add(node.right);\\n                }\\n                if(node.left!=null) {\\n                    queue.add(node.left);\\n                }\\n                next=node;\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null) {\\n            return null;\\n        }\\n        if(root.left!=null) {\\n            if(root.right!=null) {\\n                root.left.next=root.right;\\n            } else {\\n                root.left.next=find(root.next);\\n            }\\n        }\\n        if(root.right!=null) {\\n            root.right.next=find(root.next);\\n        }\\n        connect(root.right);\\n        connect(root.left);\\n        return root;\\n    }\\n    private Node find(Node root) {\\n        while(root!=null) {\\n            if(root.left!=null) {\\n                return root.left;\\n            }\\n            if(root.right!=null) {\\n                return root.right;\\n            }\\n            root=root.next;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1709233,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1569165,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1566440,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1696555,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1567196,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1569840,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1570618,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1573105,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1569486,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1573696,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1709233,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1569165,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1566440,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1696555,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1567196,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1569840,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1570618,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1573105,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1569486,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1573696,
                "content": [
                    {
                        "username": "abhipsamishra1",
                        "content": "There is an issue with the Javascript function of this problem. Even when you run the empty function, we get the below issue. Please fix this.\\n\\nLine 97 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\\n             ^\\nTypeError: undefined is not valid value for the expected return type Node\\n    Line 97: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 29: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "same here "
                    },
                    {
                        "username": "chemkhi",
                        "content": "same issue"
                    },
                    {
                        "username": "githubdudu",
                        "content": "Same situation"
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have spent 3.5 hours and still not able to understand how you guys implemented it. I am only able to implement the level order traversal using queue. I highly appreciate if a Good Samaritan can explain the solution for the poor souls like I am. Thanks in advance."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@redhair_rs](/redhair_rs) \\nGreat!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "redhair_rs",
                        "content": "Node* connect(Node* root) {\\n        if (root == NULL)\\n        {\\n            return NULL;\\n        }\\n        queue<Node*> q1;\\n        q1.push(root);\\n        while (!q1.empty())\\n        {\\n            int cnt = q1.size();\\n            Node* dummy = new Node(0);\\n            for (int i = 0; i < cnt; ++i) {\\n                Node* curr = q1.front();\\n                q1.pop();\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if (curr->left != NULL)\\n                {\\n                    q1.push(curr->left);\\n                }\\n                if (curr->right != NULL)\\n                {\\n                    q1.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "[@LeetCode](/LeetCode) tests broken?  \nLine 100 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node"
                    },
                    {
                        "username": "paullam328",
                        "content": "Use TypeScript compiler instead"
                    },
                    {
                        "username": "mikedadalin",
                        "content": "[@riyadzaigir280](/riyadzaigir280) same here \\n"
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Same Problem"
                    },
                    {
                        "username": "flyby23",
                        "content": "I have an recursive solution that got accepted. But just wondering since for the recursive function, internally the calling stack is consuming O(N) memory space where N is the depth of the recursion (in my case, it's the height of the tree), so it seems not qualified as const extra space?"
                    },
                    {
                        "username": "piepi",
                        "content": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\\n\\nHow are these two problems different?"
                    },
                    {
                        "username": "mvalpha",
                        "content": "I have the same solution for both problems and it is accepted. I used BFS."
                    },
                    {
                        "username": "stephanie0530",
                        "content": "the first one is a perfect binary tree where it\\'s guaranteed that for each node it has 2 children"
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "If you are thinking of a recursive solution, then try to solve the right part of the tree first before you solve the left part."
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "[@arjun202](/arjun202) Intuition is You need to link the either left or right child of a node to its right sided at first node, So we need to traverse from left to right in parent level to find the right sided first node, But if we dont process the right sub tree first, how we can get the link on parent level nodes. I know its hard to understand, Dry run this exp> "
                    },
                    {
                        "username": "charonme",
                        "content": "[@arjun202](/arjun202) in my case it wasn\\'t intuition, it was one of the test cases failing because I forgot my solution assumed the right portion of the tree is already processed, but at the end of the recursion I called processing of the left descendants before processing the right descendants :)"
                    },
                    {
                        "username": "arjun202",
                        "content": "What was the intuition behind this?"
                    },
                    {
                        "username": "bomboneiro",
                        "content": "Is there something we can visualize the testcases with?"
                    },
                    {
                        "username": "wbbqhs",
                        "content": "The ambiguity in the desciption wasted my time. Should\\'ve just said \"next node\"."
                    },
                    {
                        "username": "Soul_xHacker",
                        "content": "Can anyone explain why this question is different from part 1?"
                    },
                    {
                        "username": "s_ninja777",
                        "content": "the first one is a perfect binary tree where each node will always have 2 children but here its a binary tree where there is no such guarantee."
                    }
                ]
            },
            {
                "id": 1571239,
                "content": [
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I saw that this problem is categorized into DFS. When I use BFS to do it, it takes O(1) space as instructed by the problem. But when I use DFS, I have to use O(h) space, and that is not what the problem instructed, right? Then why is this problem categorized into DFS? Or is there anyway to use DFS with constant space?"
                    },
                    {
                        "username": "LoveJenny",
                        "content": "But still don't know what this tree looks like:\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}"
                    },
                    {
                        "username": "BioDaddy",
                        "content": "Hello, I've solve the problem using hashmap (level of depth, TreeLinkNode). It got accepted, but i am not sure what constant extra space meant. I can also solve the problem using ArrayList instead of hashmap (a little less memory) using the same concept, keep the tail of each level and update to whatever comes next. If the solution is a tree with 5 levels, I would have 5 copies of tail for each level. Would this count as constant extra space?\\n\\nI would be happy to share my solution, if anyone want to see."
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "yes please share\\n"
                    },
                    {
                        "username": "umarf22",
                        "content": "Sometimes you just fail to solve a relatively easy problem, then look  at the submissions and even the newbies have solved it in one go. Mostly because you\\'ve been solving advanced problems that require advance logic, so you apply advance logic to a simple problem, because of \"recency bias\" cognitive fallacy. It\\'s good to keep an eye on whether the problem is actually easy or not. Presumptions suck."
                    },
                    {
                        "username": "charonme",
                        "content": "nice, very interesting continuation of the https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ problem!"
                    },
                    {
                        "username": "malar",
                        "content": "Getting runtime error for this problem from yesterday and even accepted solution is getting runtime error. \n\nI am using level order traversal and recursion too \n[@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "malar",
                        "content": "[@LeetCode](/LeetCode) Please fix test cases"
                    },
                    {
                        "username": "sergeyn1",
                        "content": "have the same issue, tests are broken"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "I have this too, probably the tests are broken.\\n"
                    },
                    {
                        "username": "sidazhang",
                        "content": "I know how to read the input. However, I would also like to run this code in my local environment for testing and debugging. \\n\\nHas anyone written python based tools to deserialize Leetcode inputs?\\n\\ne.g. \\n\\n    Input =\\t{2,1,3,0,7,9,1,2,#,1,0,#,#,8,8,#,#,#,#,7}\\n    tree = deserialize(input)"
                    },
                    {
                        "username": "wisdompilot",
                        "content": "I am trying to debug my code. Now I got an error.\\n\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}\\n\\n\\nAnyone knows what's the shape of the input and output trees. Anywhere that I may find the specification of the representations?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Same exact code for level order traversal worked for part I and II"
                    },
                    {
                        "username": "amit26",
                        "content": "Looks like there is a bug  in the way the function is called during test. Please check online code snippet at: https://onlinegdb.com/yO5CNW-Xi\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 3\nQueue size: 3, node count: 3:  0, 4; 1, 5; 2, 7; \nQ Size: 0\nQueue size: 1, node count: 1:  0,\n\nRuntime Error\nLine 33: Char 44: runtime error: member access within null pointer of type 'Node' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:60:44\n\n\nAt online GDB https://onlinegdb.com/yO5CNW-Xi, I can see correct execution:\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 4; 1, 5; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 6; 1, 7; \nQ Size: 0\n\n\n...Program finished with exit code 0\nPress ENTER to exit console."
                    }
                ]
            },
            {
                "id": 1571241,
                "content": [
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I saw that this problem is categorized into DFS. When I use BFS to do it, it takes O(1) space as instructed by the problem. But when I use DFS, I have to use O(h) space, and that is not what the problem instructed, right? Then why is this problem categorized into DFS? Or is there anyway to use DFS with constant space?"
                    },
                    {
                        "username": "LoveJenny",
                        "content": "But still don't know what this tree looks like:\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}"
                    },
                    {
                        "username": "BioDaddy",
                        "content": "Hello, I've solve the problem using hashmap (level of depth, TreeLinkNode). It got accepted, but i am not sure what constant extra space meant. I can also solve the problem using ArrayList instead of hashmap (a little less memory) using the same concept, keep the tail of each level and update to whatever comes next. If the solution is a tree with 5 levels, I would have 5 copies of tail for each level. Would this count as constant extra space?\\n\\nI would be happy to share my solution, if anyone want to see."
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "yes please share\\n"
                    },
                    {
                        "username": "umarf22",
                        "content": "Sometimes you just fail to solve a relatively easy problem, then look  at the submissions and even the newbies have solved it in one go. Mostly because you\\'ve been solving advanced problems that require advance logic, so you apply advance logic to a simple problem, because of \"recency bias\" cognitive fallacy. It\\'s good to keep an eye on whether the problem is actually easy or not. Presumptions suck."
                    },
                    {
                        "username": "charonme",
                        "content": "nice, very interesting continuation of the https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ problem!"
                    },
                    {
                        "username": "malar",
                        "content": "Getting runtime error for this problem from yesterday and even accepted solution is getting runtime error. \n\nI am using level order traversal and recursion too \n[@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "malar",
                        "content": "[@LeetCode](/LeetCode) Please fix test cases"
                    },
                    {
                        "username": "sergeyn1",
                        "content": "have the same issue, tests are broken"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "I have this too, probably the tests are broken.\\n"
                    },
                    {
                        "username": "sidazhang",
                        "content": "I know how to read the input. However, I would also like to run this code in my local environment for testing and debugging. \\n\\nHas anyone written python based tools to deserialize Leetcode inputs?\\n\\ne.g. \\n\\n    Input =\\t{2,1,3,0,7,9,1,2,#,1,0,#,#,8,8,#,#,#,#,7}\\n    tree = deserialize(input)"
                    },
                    {
                        "username": "wisdompilot",
                        "content": "I am trying to debug my code. Now I got an error.\\n\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}\\n\\n\\nAnyone knows what's the shape of the input and output trees. Anywhere that I may find the specification of the representations?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Same exact code for level order traversal worked for part I and II"
                    },
                    {
                        "username": "amit26",
                        "content": "Looks like there is a bug  in the way the function is called during test. Please check online code snippet at: https://onlinegdb.com/yO5CNW-Xi\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 3\nQueue size: 3, node count: 3:  0, 4; 1, 5; 2, 7; \nQ Size: 0\nQueue size: 1, node count: 1:  0,\n\nRuntime Error\nLine 33: Char 44: runtime error: member access within null pointer of type 'Node' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:60:44\n\n\nAt online GDB https://onlinegdb.com/yO5CNW-Xi, I can see correct execution:\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 4; 1, 5; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 6; 1, 7; \nQ Size: 0\n\n\n...Program finished with exit code 0\nPress ENTER to exit console."
                    }
                ]
            },
            {
                "id": 1567861,
                "content": [
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I saw that this problem is categorized into DFS. When I use BFS to do it, it takes O(1) space as instructed by the problem. But when I use DFS, I have to use O(h) space, and that is not what the problem instructed, right? Then why is this problem categorized into DFS? Or is there anyway to use DFS with constant space?"
                    },
                    {
                        "username": "LoveJenny",
                        "content": "But still don't know what this tree looks like:\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}"
                    },
                    {
                        "username": "BioDaddy",
                        "content": "Hello, I've solve the problem using hashmap (level of depth, TreeLinkNode). It got accepted, but i am not sure what constant extra space meant. I can also solve the problem using ArrayList instead of hashmap (a little less memory) using the same concept, keep the tail of each level and update to whatever comes next. If the solution is a tree with 5 levels, I would have 5 copies of tail for each level. Would this count as constant extra space?\\n\\nI would be happy to share my solution, if anyone want to see."
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "yes please share\\n"
                    },
                    {
                        "username": "umarf22",
                        "content": "Sometimes you just fail to solve a relatively easy problem, then look  at the submissions and even the newbies have solved it in one go. Mostly because you\\'ve been solving advanced problems that require advance logic, so you apply advance logic to a simple problem, because of \"recency bias\" cognitive fallacy. It\\'s good to keep an eye on whether the problem is actually easy or not. Presumptions suck."
                    },
                    {
                        "username": "charonme",
                        "content": "nice, very interesting continuation of the https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ problem!"
                    },
                    {
                        "username": "malar",
                        "content": "Getting runtime error for this problem from yesterday and even accepted solution is getting runtime error. \n\nI am using level order traversal and recursion too \n[@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "malar",
                        "content": "[@LeetCode](/LeetCode) Please fix test cases"
                    },
                    {
                        "username": "sergeyn1",
                        "content": "have the same issue, tests are broken"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "I have this too, probably the tests are broken.\\n"
                    },
                    {
                        "username": "sidazhang",
                        "content": "I know how to read the input. However, I would also like to run this code in my local environment for testing and debugging. \\n\\nHas anyone written python based tools to deserialize Leetcode inputs?\\n\\ne.g. \\n\\n    Input =\\t{2,1,3,0,7,9,1,2,#,1,0,#,#,8,8,#,#,#,#,7}\\n    tree = deserialize(input)"
                    },
                    {
                        "username": "wisdompilot",
                        "content": "I am trying to debug my code. Now I got an error.\\n\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}\\n\\n\\nAnyone knows what's the shape of the input and output trees. Anywhere that I may find the specification of the representations?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Same exact code for level order traversal worked for part I and II"
                    },
                    {
                        "username": "amit26",
                        "content": "Looks like there is a bug  in the way the function is called during test. Please check online code snippet at: https://onlinegdb.com/yO5CNW-Xi\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 3\nQueue size: 3, node count: 3:  0, 4; 1, 5; 2, 7; \nQ Size: 0\nQueue size: 1, node count: 1:  0,\n\nRuntime Error\nLine 33: Char 44: runtime error: member access within null pointer of type 'Node' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:60:44\n\n\nAt online GDB https://onlinegdb.com/yO5CNW-Xi, I can see correct execution:\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 4; 1, 5; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 6; 1, 7; \nQ Size: 0\n\n\n...Program finished with exit code 0\nPress ENTER to exit console."
                    }
                ]
            },
            {
                "id": 1570533,
                "content": [
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I saw that this problem is categorized into DFS. When I use BFS to do it, it takes O(1) space as instructed by the problem. But when I use DFS, I have to use O(h) space, and that is not what the problem instructed, right? Then why is this problem categorized into DFS? Or is there anyway to use DFS with constant space?"
                    },
                    {
                        "username": "LoveJenny",
                        "content": "But still don't know what this tree looks like:\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}"
                    },
                    {
                        "username": "BioDaddy",
                        "content": "Hello, I've solve the problem using hashmap (level of depth, TreeLinkNode). It got accepted, but i am not sure what constant extra space meant. I can also solve the problem using ArrayList instead of hashmap (a little less memory) using the same concept, keep the tail of each level and update to whatever comes next. If the solution is a tree with 5 levels, I would have 5 copies of tail for each level. Would this count as constant extra space?\\n\\nI would be happy to share my solution, if anyone want to see."
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "yes please share\\n"
                    },
                    {
                        "username": "umarf22",
                        "content": "Sometimes you just fail to solve a relatively easy problem, then look  at the submissions and even the newbies have solved it in one go. Mostly because you\\'ve been solving advanced problems that require advance logic, so you apply advance logic to a simple problem, because of \"recency bias\" cognitive fallacy. It\\'s good to keep an eye on whether the problem is actually easy or not. Presumptions suck."
                    },
                    {
                        "username": "charonme",
                        "content": "nice, very interesting continuation of the https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ problem!"
                    },
                    {
                        "username": "malar",
                        "content": "Getting runtime error for this problem from yesterday and even accepted solution is getting runtime error. \n\nI am using level order traversal and recursion too \n[@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "malar",
                        "content": "[@LeetCode](/LeetCode) Please fix test cases"
                    },
                    {
                        "username": "sergeyn1",
                        "content": "have the same issue, tests are broken"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "I have this too, probably the tests are broken.\\n"
                    },
                    {
                        "username": "sidazhang",
                        "content": "I know how to read the input. However, I would also like to run this code in my local environment for testing and debugging. \\n\\nHas anyone written python based tools to deserialize Leetcode inputs?\\n\\ne.g. \\n\\n    Input =\\t{2,1,3,0,7,9,1,2,#,1,0,#,#,8,8,#,#,#,#,7}\\n    tree = deserialize(input)"
                    },
                    {
                        "username": "wisdompilot",
                        "content": "I am trying to debug my code. Now I got an error.\\n\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}\\n\\n\\nAnyone knows what's the shape of the input and output trees. Anywhere that I may find the specification of the representations?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Same exact code for level order traversal worked for part I and II"
                    },
                    {
                        "username": "amit26",
                        "content": "Looks like there is a bug  in the way the function is called during test. Please check online code snippet at: https://onlinegdb.com/yO5CNW-Xi\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 3\nQueue size: 3, node count: 3:  0, 4; 1, 5; 2, 7; \nQ Size: 0\nQueue size: 1, node count: 1:  0,\n\nRuntime Error\nLine 33: Char 44: runtime error: member access within null pointer of type 'Node' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:60:44\n\n\nAt online GDB https://onlinegdb.com/yO5CNW-Xi, I can see correct execution:\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 4; 1, 5; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 6; 1, 7; \nQ Size: 0\n\n\n...Program finished with exit code 0\nPress ENTER to exit console."
                    }
                ]
            },
            {
                "id": 1766439,
                "content": [
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I saw that this problem is categorized into DFS. When I use BFS to do it, it takes O(1) space as instructed by the problem. But when I use DFS, I have to use O(h) space, and that is not what the problem instructed, right? Then why is this problem categorized into DFS? Or is there anyway to use DFS with constant space?"
                    },
                    {
                        "username": "LoveJenny",
                        "content": "But still don't know what this tree looks like:\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}"
                    },
                    {
                        "username": "BioDaddy",
                        "content": "Hello, I've solve the problem using hashmap (level of depth, TreeLinkNode). It got accepted, but i am not sure what constant extra space meant. I can also solve the problem using ArrayList instead of hashmap (a little less memory) using the same concept, keep the tail of each level and update to whatever comes next. If the solution is a tree with 5 levels, I would have 5 copies of tail for each level. Would this count as constant extra space?\\n\\nI would be happy to share my solution, if anyone want to see."
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "yes please share\\n"
                    },
                    {
                        "username": "umarf22",
                        "content": "Sometimes you just fail to solve a relatively easy problem, then look  at the submissions and even the newbies have solved it in one go. Mostly because you\\'ve been solving advanced problems that require advance logic, so you apply advance logic to a simple problem, because of \"recency bias\" cognitive fallacy. It\\'s good to keep an eye on whether the problem is actually easy or not. Presumptions suck."
                    },
                    {
                        "username": "charonme",
                        "content": "nice, very interesting continuation of the https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ problem!"
                    },
                    {
                        "username": "malar",
                        "content": "Getting runtime error for this problem from yesterday and even accepted solution is getting runtime error. \n\nI am using level order traversal and recursion too \n[@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "malar",
                        "content": "[@LeetCode](/LeetCode) Please fix test cases"
                    },
                    {
                        "username": "sergeyn1",
                        "content": "have the same issue, tests are broken"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "I have this too, probably the tests are broken.\\n"
                    },
                    {
                        "username": "sidazhang",
                        "content": "I know how to read the input. However, I would also like to run this code in my local environment for testing and debugging. \\n\\nHas anyone written python based tools to deserialize Leetcode inputs?\\n\\ne.g. \\n\\n    Input =\\t{2,1,3,0,7,9,1,2,#,1,0,#,#,8,8,#,#,#,#,7}\\n    tree = deserialize(input)"
                    },
                    {
                        "username": "wisdompilot",
                        "content": "I am trying to debug my code. Now I got an error.\\n\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}\\n\\n\\nAnyone knows what's the shape of the input and output trees. Anywhere that I may find the specification of the representations?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Same exact code for level order traversal worked for part I and II"
                    },
                    {
                        "username": "amit26",
                        "content": "Looks like there is a bug  in the way the function is called during test. Please check online code snippet at: https://onlinegdb.com/yO5CNW-Xi\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 3\nQueue size: 3, node count: 3:  0, 4; 1, 5; 2, 7; \nQ Size: 0\nQueue size: 1, node count: 1:  0,\n\nRuntime Error\nLine 33: Char 44: runtime error: member access within null pointer of type 'Node' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:60:44\n\n\nAt online GDB https://onlinegdb.com/yO5CNW-Xi, I can see correct execution:\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 4; 1, 5; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 6; 1, 7; \nQ Size: 0\n\n\n...Program finished with exit code 0\nPress ENTER to exit console."
                    }
                ]
            },
            {
                "id": 1692159,
                "content": [
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I saw that this problem is categorized into DFS. When I use BFS to do it, it takes O(1) space as instructed by the problem. But when I use DFS, I have to use O(h) space, and that is not what the problem instructed, right? Then why is this problem categorized into DFS? Or is there anyway to use DFS with constant space?"
                    },
                    {
                        "username": "LoveJenny",
                        "content": "But still don't know what this tree looks like:\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}"
                    },
                    {
                        "username": "BioDaddy",
                        "content": "Hello, I've solve the problem using hashmap (level of depth, TreeLinkNode). It got accepted, but i am not sure what constant extra space meant. I can also solve the problem using ArrayList instead of hashmap (a little less memory) using the same concept, keep the tail of each level and update to whatever comes next. If the solution is a tree with 5 levels, I would have 5 copies of tail for each level. Would this count as constant extra space?\\n\\nI would be happy to share my solution, if anyone want to see."
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "yes please share\\n"
                    },
                    {
                        "username": "umarf22",
                        "content": "Sometimes you just fail to solve a relatively easy problem, then look  at the submissions and even the newbies have solved it in one go. Mostly because you\\'ve been solving advanced problems that require advance logic, so you apply advance logic to a simple problem, because of \"recency bias\" cognitive fallacy. It\\'s good to keep an eye on whether the problem is actually easy or not. Presumptions suck."
                    },
                    {
                        "username": "charonme",
                        "content": "nice, very interesting continuation of the https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ problem!"
                    },
                    {
                        "username": "malar",
                        "content": "Getting runtime error for this problem from yesterday and even accepted solution is getting runtime error. \n\nI am using level order traversal and recursion too \n[@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "malar",
                        "content": "[@LeetCode](/LeetCode) Please fix test cases"
                    },
                    {
                        "username": "sergeyn1",
                        "content": "have the same issue, tests are broken"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "I have this too, probably the tests are broken.\\n"
                    },
                    {
                        "username": "sidazhang",
                        "content": "I know how to read the input. However, I would also like to run this code in my local environment for testing and debugging. \\n\\nHas anyone written python based tools to deserialize Leetcode inputs?\\n\\ne.g. \\n\\n    Input =\\t{2,1,3,0,7,9,1,2,#,1,0,#,#,8,8,#,#,#,#,7}\\n    tree = deserialize(input)"
                    },
                    {
                        "username": "wisdompilot",
                        "content": "I am trying to debug my code. Now I got an error.\\n\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}\\n\\n\\nAnyone knows what's the shape of the input and output trees. Anywhere that I may find the specification of the representations?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Same exact code for level order traversal worked for part I and II"
                    },
                    {
                        "username": "amit26",
                        "content": "Looks like there is a bug  in the way the function is called during test. Please check online code snippet at: https://onlinegdb.com/yO5CNW-Xi\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 3\nQueue size: 3, node count: 3:  0, 4; 1, 5; 2, 7; \nQ Size: 0\nQueue size: 1, node count: 1:  0,\n\nRuntime Error\nLine 33: Char 44: runtime error: member access within null pointer of type 'Node' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:60:44\n\n\nAt online GDB https://onlinegdb.com/yO5CNW-Xi, I can see correct execution:\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 4; 1, 5; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 6; 1, 7; \nQ Size: 0\n\n\n...Program finished with exit code 0\nPress ENTER to exit console."
                    }
                ]
            },
            {
                "id": 1571240,
                "content": [
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I saw that this problem is categorized into DFS. When I use BFS to do it, it takes O(1) space as instructed by the problem. But when I use DFS, I have to use O(h) space, and that is not what the problem instructed, right? Then why is this problem categorized into DFS? Or is there anyway to use DFS with constant space?"
                    },
                    {
                        "username": "LoveJenny",
                        "content": "But still don't know what this tree looks like:\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}"
                    },
                    {
                        "username": "BioDaddy",
                        "content": "Hello, I've solve the problem using hashmap (level of depth, TreeLinkNode). It got accepted, but i am not sure what constant extra space meant. I can also solve the problem using ArrayList instead of hashmap (a little less memory) using the same concept, keep the tail of each level and update to whatever comes next. If the solution is a tree with 5 levels, I would have 5 copies of tail for each level. Would this count as constant extra space?\\n\\nI would be happy to share my solution, if anyone want to see."
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "yes please share\\n"
                    },
                    {
                        "username": "umarf22",
                        "content": "Sometimes you just fail to solve a relatively easy problem, then look  at the submissions and even the newbies have solved it in one go. Mostly because you\\'ve been solving advanced problems that require advance logic, so you apply advance logic to a simple problem, because of \"recency bias\" cognitive fallacy. It\\'s good to keep an eye on whether the problem is actually easy or not. Presumptions suck."
                    },
                    {
                        "username": "charonme",
                        "content": "nice, very interesting continuation of the https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ problem!"
                    },
                    {
                        "username": "malar",
                        "content": "Getting runtime error for this problem from yesterday and even accepted solution is getting runtime error. \n\nI am using level order traversal and recursion too \n[@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "malar",
                        "content": "[@LeetCode](/LeetCode) Please fix test cases"
                    },
                    {
                        "username": "sergeyn1",
                        "content": "have the same issue, tests are broken"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "I have this too, probably the tests are broken.\\n"
                    },
                    {
                        "username": "sidazhang",
                        "content": "I know how to read the input. However, I would also like to run this code in my local environment for testing and debugging. \\n\\nHas anyone written python based tools to deserialize Leetcode inputs?\\n\\ne.g. \\n\\n    Input =\\t{2,1,3,0,7,9,1,2,#,1,0,#,#,8,8,#,#,#,#,7}\\n    tree = deserialize(input)"
                    },
                    {
                        "username": "wisdompilot",
                        "content": "I am trying to debug my code. Now I got an error.\\n\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}\\n\\n\\nAnyone knows what's the shape of the input and output trees. Anywhere that I may find the specification of the representations?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Same exact code for level order traversal worked for part I and II"
                    },
                    {
                        "username": "amit26",
                        "content": "Looks like there is a bug  in the way the function is called during test. Please check online code snippet at: https://onlinegdb.com/yO5CNW-Xi\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 3\nQueue size: 3, node count: 3:  0, 4; 1, 5; 2, 7; \nQ Size: 0\nQueue size: 1, node count: 1:  0,\n\nRuntime Error\nLine 33: Char 44: runtime error: member access within null pointer of type 'Node' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:60:44\n\n\nAt online GDB https://onlinegdb.com/yO5CNW-Xi, I can see correct execution:\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 4; 1, 5; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 6; 1, 7; \nQ Size: 0\n\n\n...Program finished with exit code 0\nPress ENTER to exit console."
                    }
                ]
            },
            {
                "id": 1571242,
                "content": [
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I saw that this problem is categorized into DFS. When I use BFS to do it, it takes O(1) space as instructed by the problem. But when I use DFS, I have to use O(h) space, and that is not what the problem instructed, right? Then why is this problem categorized into DFS? Or is there anyway to use DFS with constant space?"
                    },
                    {
                        "username": "LoveJenny",
                        "content": "But still don't know what this tree looks like:\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}"
                    },
                    {
                        "username": "BioDaddy",
                        "content": "Hello, I've solve the problem using hashmap (level of depth, TreeLinkNode). It got accepted, but i am not sure what constant extra space meant. I can also solve the problem using ArrayList instead of hashmap (a little less memory) using the same concept, keep the tail of each level and update to whatever comes next. If the solution is a tree with 5 levels, I would have 5 copies of tail for each level. Would this count as constant extra space?\\n\\nI would be happy to share my solution, if anyone want to see."
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "yes please share\\n"
                    },
                    {
                        "username": "umarf22",
                        "content": "Sometimes you just fail to solve a relatively easy problem, then look  at the submissions and even the newbies have solved it in one go. Mostly because you\\'ve been solving advanced problems that require advance logic, so you apply advance logic to a simple problem, because of \"recency bias\" cognitive fallacy. It\\'s good to keep an eye on whether the problem is actually easy or not. Presumptions suck."
                    },
                    {
                        "username": "charonme",
                        "content": "nice, very interesting continuation of the https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ problem!"
                    },
                    {
                        "username": "malar",
                        "content": "Getting runtime error for this problem from yesterday and even accepted solution is getting runtime error. \n\nI am using level order traversal and recursion too \n[@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "malar",
                        "content": "[@LeetCode](/LeetCode) Please fix test cases"
                    },
                    {
                        "username": "sergeyn1",
                        "content": "have the same issue, tests are broken"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "I have this too, probably the tests are broken.\\n"
                    },
                    {
                        "username": "sidazhang",
                        "content": "I know how to read the input. However, I would also like to run this code in my local environment for testing and debugging. \\n\\nHas anyone written python based tools to deserialize Leetcode inputs?\\n\\ne.g. \\n\\n    Input =\\t{2,1,3,0,7,9,1,2,#,1,0,#,#,8,8,#,#,#,#,7}\\n    tree = deserialize(input)"
                    },
                    {
                        "username": "wisdompilot",
                        "content": "I am trying to debug my code. Now I got an error.\\n\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}\\n\\n\\nAnyone knows what's the shape of the input and output trees. Anywhere that I may find the specification of the representations?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Same exact code for level order traversal worked for part I and II"
                    },
                    {
                        "username": "amit26",
                        "content": "Looks like there is a bug  in the way the function is called during test. Please check online code snippet at: https://onlinegdb.com/yO5CNW-Xi\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 3\nQueue size: 3, node count: 3:  0, 4; 1, 5; 2, 7; \nQ Size: 0\nQueue size: 1, node count: 1:  0,\n\nRuntime Error\nLine 33: Char 44: runtime error: member access within null pointer of type 'Node' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:60:44\n\n\nAt online GDB https://onlinegdb.com/yO5CNW-Xi, I can see correct execution:\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 4; 1, 5; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 6; 1, 7; \nQ Size: 0\n\n\n...Program finished with exit code 0\nPress ENTER to exit console."
                    }
                ]
            },
            {
                "id": 2072115,
                "content": [
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I saw that this problem is categorized into DFS. When I use BFS to do it, it takes O(1) space as instructed by the problem. But when I use DFS, I have to use O(h) space, and that is not what the problem instructed, right? Then why is this problem categorized into DFS? Or is there anyway to use DFS with constant space?"
                    },
                    {
                        "username": "LoveJenny",
                        "content": "But still don't know what this tree looks like:\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}"
                    },
                    {
                        "username": "BioDaddy",
                        "content": "Hello, I've solve the problem using hashmap (level of depth, TreeLinkNode). It got accepted, but i am not sure what constant extra space meant. I can also solve the problem using ArrayList instead of hashmap (a little less memory) using the same concept, keep the tail of each level and update to whatever comes next. If the solution is a tree with 5 levels, I would have 5 copies of tail for each level. Would this count as constant extra space?\\n\\nI would be happy to share my solution, if anyone want to see."
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "yes please share\\n"
                    },
                    {
                        "username": "umarf22",
                        "content": "Sometimes you just fail to solve a relatively easy problem, then look  at the submissions and even the newbies have solved it in one go. Mostly because you\\'ve been solving advanced problems that require advance logic, so you apply advance logic to a simple problem, because of \"recency bias\" cognitive fallacy. It\\'s good to keep an eye on whether the problem is actually easy or not. Presumptions suck."
                    },
                    {
                        "username": "charonme",
                        "content": "nice, very interesting continuation of the https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ problem!"
                    },
                    {
                        "username": "malar",
                        "content": "Getting runtime error for this problem from yesterday and even accepted solution is getting runtime error. \n\nI am using level order traversal and recursion too \n[@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "malar",
                        "content": "[@LeetCode](/LeetCode) Please fix test cases"
                    },
                    {
                        "username": "sergeyn1",
                        "content": "have the same issue, tests are broken"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "I have this too, probably the tests are broken.\\n"
                    },
                    {
                        "username": "sidazhang",
                        "content": "I know how to read the input. However, I would also like to run this code in my local environment for testing and debugging. \\n\\nHas anyone written python based tools to deserialize Leetcode inputs?\\n\\ne.g. \\n\\n    Input =\\t{2,1,3,0,7,9,1,2,#,1,0,#,#,8,8,#,#,#,#,7}\\n    tree = deserialize(input)"
                    },
                    {
                        "username": "wisdompilot",
                        "content": "I am trying to debug my code. Now I got an error.\\n\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}\\n\\n\\nAnyone knows what's the shape of the input and output trees. Anywhere that I may find the specification of the representations?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Same exact code for level order traversal worked for part I and II"
                    },
                    {
                        "username": "amit26",
                        "content": "Looks like there is a bug  in the way the function is called during test. Please check online code snippet at: https://onlinegdb.com/yO5CNW-Xi\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 3\nQueue size: 3, node count: 3:  0, 4; 1, 5; 2, 7; \nQ Size: 0\nQueue size: 1, node count: 1:  0,\n\nRuntime Error\nLine 33: Char 44: runtime error: member access within null pointer of type 'Node' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:60:44\n\n\nAt online GDB https://onlinegdb.com/yO5CNW-Xi, I can see correct execution:\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 4; 1, 5; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 6; 1, 7; \nQ Size: 0\n\n\n...Program finished with exit code 0\nPress ENTER to exit console."
                    }
                ]
            },
            {
                "id": 2017451,
                "content": [
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I saw that this problem is categorized into DFS. When I use BFS to do it, it takes O(1) space as instructed by the problem. But when I use DFS, I have to use O(h) space, and that is not what the problem instructed, right? Then why is this problem categorized into DFS? Or is there anyway to use DFS with constant space?"
                    },
                    {
                        "username": "LoveJenny",
                        "content": "But still don't know what this tree looks like:\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}"
                    },
                    {
                        "username": "BioDaddy",
                        "content": "Hello, I've solve the problem using hashmap (level of depth, TreeLinkNode). It got accepted, but i am not sure what constant extra space meant. I can also solve the problem using ArrayList instead of hashmap (a little less memory) using the same concept, keep the tail of each level and update to whatever comes next. If the solution is a tree with 5 levels, I would have 5 copies of tail for each level. Would this count as constant extra space?\\n\\nI would be happy to share my solution, if anyone want to see."
                    },
                    {
                        "username": "divyam_vijay",
                        "content": "yes please share\\n"
                    },
                    {
                        "username": "umarf22",
                        "content": "Sometimes you just fail to solve a relatively easy problem, then look  at the submissions and even the newbies have solved it in one go. Mostly because you\\'ve been solving advanced problems that require advance logic, so you apply advance logic to a simple problem, because of \"recency bias\" cognitive fallacy. It\\'s good to keep an eye on whether the problem is actually easy or not. Presumptions suck."
                    },
                    {
                        "username": "charonme",
                        "content": "nice, very interesting continuation of the https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ problem!"
                    },
                    {
                        "username": "malar",
                        "content": "Getting runtime error for this problem from yesterday and even accepted solution is getting runtime error. \n\nI am using level order traversal and recursion too \n[@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "malar",
                        "content": "[@LeetCode](/LeetCode) Please fix test cases"
                    },
                    {
                        "username": "sergeyn1",
                        "content": "have the same issue, tests are broken"
                    },
                    {
                        "username": "Syrgak96",
                        "content": "I have this too, probably the tests are broken.\\n"
                    },
                    {
                        "username": "sidazhang",
                        "content": "I know how to read the input. However, I would also like to run this code in my local environment for testing and debugging. \\n\\nHas anyone written python based tools to deserialize Leetcode inputs?\\n\\ne.g. \\n\\n    Input =\\t{2,1,3,0,7,9,1,2,#,1,0,#,#,8,8,#,#,#,#,7}\\n    tree = deserialize(input)"
                    },
                    {
                        "username": "wisdompilot",
                        "content": "I am trying to debug my code. Now I got an error.\\n\\n\\nInput:\\t{1,2,3,4,5,#,6,7,#,#,#,#,8}\\n\\nOutput:\\t{1,#,2,3,#,4,5,6,#,7,#}\\n\\nExpected:\\t{1,#,2,3,#,4,5,6,#,7,8,#}\\n\\n\\nAnyone knows what's the shape of the input and output trees. Anywhere that I may find the specification of the representations?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Same exact code for level order traversal worked for part I and II"
                    },
                    {
                        "username": "amit26",
                        "content": "Looks like there is a bug  in the way the function is called during test. Please check online code snippet at: https://onlinegdb.com/yO5CNW-Xi\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 3\nQueue size: 3, node count: 3:  0, 4; 1, 5; 2, 7; \nQ Size: 0\nQueue size: 1, node count: 1:  0,\n\nRuntime Error\nLine 33: Char 44: runtime error: member access within null pointer of type 'Node' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:60:44\n\n\nAt online GDB https://onlinegdb.com/yO5CNW-Xi, I can see correct execution:\n\nQueue size: 1, node count: 1:  0, 1; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 2; 1, 3; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 4; 1, 5; \nQ Size: 2\nQueue size: 2, node count: 2:  0, 6; 1, 7; \nQ Size: 0\n\n\n...Program finished with exit code 0\nPress ENTER to exit console."
                    }
                ]
            }
        ]
    },
    {
        "title": "Swap Salary",
        "question_content": "<p>Table: <code>Salary</code></p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| id          | int      |\n| name        | varchar  |\n| sex         | ENUM     |\n| salary      | int      |\n+-------------+----------+\nid is the primary key (column with unique values) for this table.\nThe sex column is ENUM (category) value of type (&#39;m&#39;, &#39;f&#39;).\nThe table contains information about an employee.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to swap all <code>&#39;f&#39;</code> and <code>&#39;m&#39;</code> values (i.e., change all <code>&#39;f&#39;</code> values to <code>&#39;m&#39;</code> and vice versa) with a <strong>single update statement</strong> and no intermediate temporary tables.</p>\n\n<p>Note that you must write a single update statement, <strong>do not</strong> write any select statement for this problem.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nSalary table:\n+----+------+-----+--------+\n| id | name | sex | salary |\n+----+------+-----+--------+\n| 1  | A    | m   | 2500   |\n| 2  | B    | f   | 1500   |\n| 3  | C    | m   | 5500   |\n| 4  | D    | f   | 500    |\n+----+------+-----+--------+\n<strong>Output:</strong> \n+----+------+-----+--------+\n| id | name | sex | salary |\n+----+------+-----+--------+\n| 1  | A    | f   | 2500   |\n| 2  | B    | m   | 1500   |\n| 3  | C    | f   | 5500   |\n| 4  | D    | m   | 500    |\n+----+------+-----+--------+\n<strong>Explanation:</strong> \n(1, A) and (3, C) were changed from &#39;m&#39; to &#39;f&#39;.\n(2, B) and (4, D) were changed from &#39;f&#39; to &#39;m&#39;.\n</pre>\n",
        "solutions": [
            {
                "id": 2755326,
                "title": "mysql-solution",
                "content": "Solution using cases in MySQL:\\n\\n```\\nUPDATE salary SET sex =\\nCASE sex\\n    WHEN \\'m\\' THEN \\'f\\'\\n    ELSE \\'m\\'\\nEND;\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/541b8e36-5eb3-4283-b953-6067480389c3_1675058399.1742556.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE salary SET sex =\\nCASE sex\\n    WHEN \\'m\\' THEN \\'f\\'\\n    ELSE \\'m\\'\\nEND;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 104713,
                "title": "accept-solution-with-xor",
                "content": "```\\nupdate salary set sex = CHAR(ASCII('f') ^ ASCII('m') ^ ASCII(sex));\\n```",
                "solutionTags": [],
                "code": "```\\nupdate salary set sex = CHAR(ASCII('f') ^ ASCII('m') ^ ASCII(sex));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2551003,
                "title": "mysql-shortest-solution",
                "content": "***Please UPVOTE \\uD83D\\uDD25***\\n```\\nUPDATE Salary \\nSET sex = (CASE WHEN sex = \\'f\\' THEN \\'m\\' ELSE \\'f\\' END) \\n```\\n***Please UPVOTE \\uD83D\\uDD25***",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary \\nSET sex = (CASE WHEN sex = \\'f\\' THEN \\'m\\' ELSE \\'f\\' END) \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 104716,
                "title": "short-and-simple",
                "content": "```\\nUPDATE salary\\n    SET sex  = (CASE WHEN sex = 'm' \\n        THEN  'f' \\n        ELSE 'm' \\n        END)\\n```",
                "solutionTags": [],
                "code": "```\\nUPDATE salary\\n    SET sex  = (CASE WHEN sex = 'm' \\n        THEN  'f' \\n        ELSE 'm' \\n        END)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 226352,
                "title": "solution-using-replace-faster-than-88",
                "content": "```\\nUPDATE salary SET sex = REPLACE (\\'fm\\', sex, \\'\\');\\n```",
                "solutionTags": [],
                "code": "```\\nUPDATE salary SET sex = REPLACE (\\'fm\\', sex, \\'\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2890835,
                "title": "sqs-simple-sql-solutions-5-solutions",
                "content": "**1. CASE expression**\\n\\n```\\nUPDATE Salary SET sex = (CASE sex WHEN \\'m\\' THEN \\'f\\' ELSE \\'m\\' END)\\n```\\n\\n**2. Ternary operator**\\n\\n```\\nUPDATE Salary SET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\')\\n```\\n\\n**3. REPLACE() function**\\n\\n```\\nUPDATE Salary SET sex = REPLACE(\\'fm\\', sex, \\'\\')\\n```\\n\\n**4. Math approach**\\n\\n```\\nUPDATE Salary SET sex = CHAR(ASCII(\\'f\\') + ASCII(\\'m\\') - ASCII(sex))\\n```\\n\\n**5. XOR swap**\\n\\nhttps://en.wikipedia.org/wiki/XOR_swap_algorithm\\n\\n```\\nUPDATE Salary SET sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex))\\n```\\n\\nor\\n\\n```\\nUPDATE Salary SET sex = CHAR(ASCII(sex) ^ 11)\\n```\\n\\nNOTE: ```ASCII(\\'f\\') ^ ASCII(\\'m\\') = 11```\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary SET sex = (CASE sex WHEN \\'m\\' THEN \\'f\\' ELSE \\'m\\' END)\\n```\n```\\nUPDATE Salary SET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\')\\n```\n```\\nUPDATE Salary SET sex = REPLACE(\\'fm\\', sex, \\'\\')\\n```\n```\\nUPDATE Salary SET sex = CHAR(ASCII(\\'f\\') + ASCII(\\'m\\') - ASCII(sex))\\n```\n```\\nUPDATE Salary SET sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex))\\n```\n```\\nUPDATE Salary SET sex = CHAR(ASCII(sex) ^ 11)\\n```\n```ASCII(\\'f\\') ^ ASCII(\\'m\\') = 11```",
                "codeTag": "Unknown"
            },
            {
                "id": 104722,
                "title": "simple-and-short-with-if",
                "content": "```\\nUPDATE salary SET sex = IF(sex = 'm', 'f', 'm')\\n```",
                "solutionTags": [],
                "code": "```\\nUPDATE salary SET sex = IF(sex = 'm', 'f', 'm')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1309028,
                "title": "faster-easy",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nUPDATE Salary\\nSET sex = \\nCASE\\n    WHEN sex = \"f\" THEN \"m\"\\n    WHEN sex = \"m\" THEN \"f\"\\nEND\\n```",
                "solutionTags": [],
                "code": "```\\nUPDATE Salary\\nSET sex = \\nCASE\\n    WHEN sex = \"f\" THEN \"m\"\\n    WHEN sex = \"m\" THEN \"f\"\\nEND\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2490253,
                "title": "mysql-simple-and-clean-solution",
                "content": "**Please Upvote if it helped you !!!**\\n```\\nupdate Salary set sex= if(sex=\\'f\\',\\'m\\',\\'f\\');\\n```\\n\\n\\n```\\nupdate Salary set sex= \\ncase\\nwhen sex=\\'f\\' then \\'m\\'\\nwhen sex=\\'m\\' then \\'f\\'\\nend;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate Salary set sex= if(sex=\\'f\\',\\'m\\',\\'f\\');\\n```\n```\\nupdate Salary set sex= \\ncase\\nwhen sex=\\'f\\' then \\'m\\'\\nwhen sex=\\'m\\' then \\'f\\'\\nend;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1961676,
                "title": "mysql-solution",
                "content": "# Solution\\n```\\nUPDATE  salary\\nSET  sex = CASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' END\\n```\\nWhen you need to replace data in rows on some condition you can use **WHERE**. But when you **UPDATE** all data, you can use condition on **SET**.\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE  salary\\nSET  sex = CASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' END\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745367,
                "title": "mysql-95-fast-100-memory",
                "content": "If you found the solution helpful, kindly upvote. :)\\n\\n```\\nUPDATE salary \\nSET \\n    sex= CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;\\n```",
                "solutionTags": [],
                "code": "```\\nUPDATE salary \\nSET \\n    sex= CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 255305,
                "title": "solution-without-using-case-faster-than-98",
                "content": "```\\nUPDATE salary\\nSET sex = CHAR(ASCII(\\'f\\') + ASCII(\\'m\\') - ASCII(`sex`);\\n```",
                "solutionTags": [],
                "code": "```\\nUPDATE salary\\nSET sex = CHAR(ASCII(\\'f\\') + ASCII(\\'m\\') - ASCII(`sex`);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172698,
                "title": "solution-using-ascii-code",
                "content": "```\\nupdate salary set sex = char(211-ascii(sex))\\n```\\n\\nascii(\\'f\\') = 102\\nascii(\\'m\\') = 109",
                "solutionTags": [],
                "code": "```\\nupdate salary set sex = char(211-ascii(sex))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3424269,
                "title": "one-line-of-query-sql",
                "content": "\\n\\n# SQL--->Structured Query Language\\n```\\nupdate salary set sex = case sex when \"m\" then \"f\" else \"m\" end;\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate salary set sex = case sex when \"m\" then \"f\" else \"m\" end;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887765,
                "title": "simple-and-clean",
                "content": "**IF (MySQL)**:\\n```\\nUPDATE salary SET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\')\\n```\\n\\n**IIF (MS SQL)**:\\n```\\nUPDATE salary SET sex = IIF(sex = \\'m\\', \\'f\\', \\'m\\')\\n```\\n\\n**CASE WHEN (MySQL + MS SQL + Oracle)**:\\n```\\nUPDATE salary SET sex = CASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' END\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nUPDATE salary SET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\')\\n```\n```\\nUPDATE salary SET sex = IIF(sex = \\'m\\', \\'f\\', \\'m\\')\\n```\n```\\nUPDATE salary SET sex = CASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' END\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2546197,
                "title": "627-swap-salary",
                "content": "```\\nUPDATE salary\\nSET sex = IF(sex=\\'f\\', \\'m\\', \\'f\\');",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE salary\\nSET sex = IF(sex=\\'f\\', \\'m\\', \\'f\\');",
                "codeTag": "Unknown"
            },
            {
                "id": 1816763,
                "title": "mysql-solution-solution-to-invalid-testcase-error-2-different-methods",
                "content": "In case you get INVALID TESTCASE \\'salary\\' error. Ignore the error and directly submit the solution. The system will ACCEPT.\\n\\nThere is some problem in the default testcase.\\n\\n*Please Upvote if you like the solution.\\n\\n# 1st Method\\n```\\n UPDATE salary SET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\')\\n```\\n# 2nd Method\\n```\\nUPDATE salary\\nSET\\n    sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n UPDATE salary SET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\')\\n```\n```\\nUPDATE salary\\nSET\\n    sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3063060,
                "title": "mysql-use-of-dml-case-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/d6e7365b-8a51-435b-8e99-a7ecf7c46323_1673949193.1438491.png)\\n\\n\\n\\tUPDATE salary SET sex = (\\n\\t\\tCASE \\n\\t\\t\\tWHEN sex = \\'m\\' THEN \\'f\\'\\n\\t\\t\\tELSE \\'m\\'\\n\\t\\tEND\\n\\t);",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/d6e7365b-8a51-435b-8e99-a7ecf7c46323_1673949193.1438491.png)\\n\\n\\n\\tUPDATE salary SET sex = (\\n\\t\\tCASE \\n\\t\\t\\tWHEN sex = \\'m\\' THEN \\'f\\'\\n\\t\\t\\tELSE \\'m\\'\\n\\t\\tEND\\n\\t);",
                "codeTag": "Unknown"
            },
            {
                "id": 2604512,
                "title": "swap-salary-best-sql-query-to-understand",
                "content": "```\\nupdate salary set sex = if(sex = \\'m\\',\\'f\\',\\'m\\');\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nupdate salary set sex = if(sex = \\'m\\',\\'f\\',\\'m\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2387462,
                "title": "2-accepted-solutions",
                "content": "DO UPVOTE IF YOU LIKE MY SOLUTIONS :)\\n```\\n# 1.\\nUPDATE salary\\nSET sex = CASE sex\\n    WHEN \\'f\\' THEN \\'m\\'\\n    WHEN \\'m\\' THEN \\'f\\'\\nEND\\n\\n# 2.\\nUpdate salary \\nSET sex = IF(sex =\\'f\\',\"m\",\"f\");\\n```\\nIf you have any doubts, feel free to ask...\\nIf you understand the concept. Don\\'t Forget to upvote \\uD83D\\uDE0A",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# 1.\\nUPDATE salary\\nSET sex = CASE sex\\n    WHEN \\'f\\' THEN \\'m\\'\\n    WHEN \\'m\\' THEN \\'f\\'\\nEND\\n\\n# 2.\\nUpdate salary \\nSET sex = IF(sex =\\'f\\',\"m\",\"f\");\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 599124,
                "title": "mysql-solution",
                "content": "```\\nUPDATE salary\\nSET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\');\\n```",
                "solutionTags": [],
                "code": "```\\nUPDATE salary\\nSET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2453867,
                "title": "sql-easy-query-91-faster",
                "content": "UPDATE Salary\\nSET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\') //if sex=\\'m\\' change it to \\'f\\' else change it to \\'m\\'",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "UPDATE Salary\\nSET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\') //if sex=\\'m\\' change it to \\'f\\' else change it to \\'m\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2193299,
                "title": "simplest-mysql-query-using-if-set",
                "content": "```\\nupdate salary set sex = IF (sex = \"m\", \"f\", \"m\");\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate salary set sex = IF (sex = \"m\", \"f\", \"m\");\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1917693,
                "title": "swap-salary-invalid-testcase-error-solution",
                "content": "May be their is problem from backend.\\nJust ignore the error message and submit the solution.\\n**Solution will be accepted....**\\n\\n*Please Upvote if the solution is useful.\\n\\n\\'\\'\\'\\n\\nUPDATE salary \\nSET \\nsex = CASE \\nWHEN sex = \\'m\\' THEN \\'f\\' \\nELSE \\'m\\' \\nEND\\n\\n**OR**\\n\\nUPDATE salary SET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\')\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "May be their is problem from backend.\\nJust ignore the error message and submit the solution.\\n**Solution will be accepted....**\\n\\n*Please Upvote if the solution is useful.\\n\\n\\'\\'\\'\\n\\nUPDATE salary \\nSET \\nsex = CASE \\nWHEN sex = \\'m\\' THEN \\'f\\' \\nELSE \\'m\\' \\nEND\\n\\n**OR**\\n\\nUPDATE salary SET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\')\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1770472,
                "title": "5-different-solutions",
                "content": "1. IF \\n```\\nUPDATE Salary\\nSET sex = IF(sex=\"f\", \"m\", \"f\") ;\\n```\\n\\n2. XOR\\n```\\nUPDATE Salary\\nSET sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex)) ;\\n```\\n3. CASE\\n```\\nUPDATE Salary\\nSET sex = (\\n    CASE\\n        WHEN sex=\"f\" THEN \"m\"\\n        ELSE \"f\"\\n    END\\n)\\n```\\n4. REPLACE \\n```\\nUPDATE Salary\\nSET sex = REPLACE (\\'fm\\', sex, \\'\\');\\n```\\nExplanation : \\nThis is the syntax of REPLACE() :\\n`REPLACE(string, char_to_find, char_to_replace)`\\nIt finds `char_to_find` in `string` and replace that character with `char_to_replace`\\n\\nThe `sex` column can have only values `f` and `m` . \\nSo `REPLACE(\\'fm\\', \\'f\\', \\'\\')` replace `f` with blank string in `fm` , basically removing `f`.\\n`REPLACE(\\'fm\\', \\'f\\', \\'\\') is m` and, \\n`REPLACE(\\'fm\\', \\'m\\', \\'\\') is f` .\\n\\n(PS : I am not sure if is allows you to find and replace whole substrings and I am too lazy to check it  :) )\\n\\n5. ASCII Values\\n```\\nUPDATE Salary\\nSET sex = CHAR(ASCII(\\'f\\') + ASCII(\\'m\\') - ASCII(sex));\\n```\\n",
                "solutionTags": [],
                "code": "```\\nUPDATE Salary\\nSET sex = IF(sex=\"f\", \"m\", \"f\") ;\\n```\n```\\nUPDATE Salary\\nSET sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex)) ;\\n```\n```\\nUPDATE Salary\\nSET sex = (\\n    CASE\\n        WHEN sex=\"f\" THEN \"m\"\\n        ELSE \"f\"\\n    END\\n)\\n```\n```\\nUPDATE Salary\\nSET sex = REPLACE (\\'fm\\', sex, \\'\\');\\n```\n```\\nUPDATE Salary\\nSET sex = CHAR(ASCII(\\'f\\') + ASCII(\\'m\\') - ASCII(sex));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3269702,
                "title": "mysql-solution",
                "content": "# Code 1 (if)\\n```\\n# Write your MySQL query statement below\\nupdate Salary set sex = if(sex = \\'m\\', \\'f\\', \\'m\\');\\n```\\n\\n# Code 2 (case)\\n```\\n# Write your MySQL query statement below\\nupdate Salary set sex = (case sex when \\'m\\' then \\'f\\' else \\'m\\' end);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nupdate Salary set sex = if(sex = \\'m\\', \\'f\\', \\'m\\');\\n```\n```\\n# Write your MySQL query statement below\\nupdate Salary set sex = (case sex when \\'m\\' then \\'f\\' else \\'m\\' end);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2201924,
                "title": "sql-easy-using-case-self-explanatory",
                "content": "```\\nUPDATE Salary \\nSET sex= \\nCASE sex\\n    WHEN \\'f\\' THEN \\'m\\'\\n    WHEN \\'m\\' THEN \\'f\\'\\nEND;\\n\\n\\n```\\nPlease upvote if you found this useful :)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary \\nSET sex= \\nCASE sex\\n    WHEN \\'f\\' THEN \\'m\\'\\n    WHEN \\'m\\' THEN \\'f\\'\\nEND;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1938901,
                "title": "three-quick-mysql-solutions",
                "content": "**Note:** As of 12/04/2022, using the testcases yields an error (\\'Invalid Testcase\\'). However, submitting any of the following solutions works perfectly fine. \\n\\n<br>\\n\\n-- Solution #01: Using `CASE`\\n```sql\\nUPDATE Salary\\nSET\\n    sex = CASE sex\\n            WHEN \\'m\\' THEN \\'f\\'\\n            ELSE \\'m\\'\\n          END;\\n```\\n\\n<br>\\n\\n-- Solution #02: Using `IF`\\n```sql\\nUPDATE Salary\\nSET sex = IF(sex=\\'m\\', \\'f\\', \\'m\\')\\n```\\n\\n<br>\\n\\n-- Solution #03: Using `REPLACE`\\n```sql\\nUPDATE Salary\\nSET sex = REPLACE(\\'fm\\', sex, \\'\\');\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nUPDATE Salary\\nSET\\n    sex = CASE sex\\n            WHEN \\'m\\' THEN \\'f\\'\\n            ELSE \\'m\\'\\n          END;\\n```\n```sql\\nUPDATE Salary\\nSET sex = IF(sex=\\'m\\', \\'f\\', \\'m\\')\\n```\n```sql\\nUPDATE Salary\\nSET sex = REPLACE(\\'fm\\', sex, \\'\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1808814,
                "title": "simple-mysql-solution",
                "content": "Using case:\\n```\\nupdate salary \\nset sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end;\\n```\\n\\nIn case you get INVALID TESTCASE \\'salary\\' error. Ignore the error and directly submit the solution. The system will ACCEPT.\\n\\nThere is some problem in the default testcase.\\n\\nPlease Upvote if you like the solution.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate salary \\nset sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 179858,
                "title": "the-solution-with-multiplication-and-division-of-ascii-codes",
                "content": "```\\nupdate salary set sex=char(ascii(\\'f\\') * ascii(\\'m\\') / ascii(sex))\\n```",
                "solutionTags": [],
                "code": "```\\nupdate salary set sex=char(ascii(\\'f\\') * ascii(\\'m\\') / ascii(sex))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541005,
                "title": "my-update-salary",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nUPDATE Salary\\nSET sex = CASE\\nWHEN sex = \\'m\\' then \\'f\\'\\nWHEN sex = \\'f\\' then \\'m\\'\\nend;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nUPDATE Salary\\nSET sex = CASE\\nWHEN sex = \\'m\\' then \\'f\\'\\nWHEN sex = \\'f\\' then \\'m\\'\\nend;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3294916,
                "title": "very-easy-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nUPDATE SALARY SET SEX=IF(SEX=\\'m\\',\\'f\\',\\'m\\');\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nUPDATE SALARY SET SEX=IF(SEX=\\'m\\',\\'f\\',\\'m\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3242494,
                "title": "easy-sql-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nUPDATE Salary set sex =if(sex=\\'m\\',\\'f\\',\\'m\\'); \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nUPDATE Salary set sex =if(sex=\\'m\\',\\'f\\',\\'m\\'); \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2563160,
                "title": "short-and-simple-solution-using-case",
                "content": "**<<<<<<<<<<<<< UPVOTE IF YOU LIKE IT**\\n```\\n# Write your MySQL query statement below\\nUPDATE Salary \\nSET sex=\\n(case \\n   when sex=\\'f\\' Then \\'m\\'\\n\\telse \\'f\\'\\nend);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nUPDATE Salary \\nSET sex=\\n(case \\n   when sex=\\'f\\' Then \\'m\\'\\n\\telse \\'f\\'\\nend);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2162489,
                "title": "simple-solution-using-if",
                "content": "Syntax of IF Statement --\\n```\\nIF(condition , value_if_true , value_if_false);\\n```\\n\\nCode for the problem\\n```\\nUPDATE Salary\\nSET sex = IF(sex = \\'m\\' , \\'f\\' , \\'m\\');\\n```",
                "solutionTags": [],
                "code": "```\\nIF(condition , value_if_true , value_if_false);\\n```\n```\\nUPDATE Salary\\nSET sex = IF(sex = \\'m\\' , \\'f\\' , \\'m\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1926416,
                "title": "accepted-solution-for-mysql",
                "content": "```sql\\nUPDATE Salary SET sex = IF(sex=\\'m\\',\\'f\\',\\'m\\')\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nUPDATE Salary SET sex = IF(sex=\\'m\\',\\'f\\',\\'m\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008360,
                "title": "mysql-easy-solution",
                "content": "```\\nUPDATE salary SET sex = (CASE \\nWHEN sex = \\'f\\' \\nTHEN \\'m\\' \\nELSE \\'f\\' \\nEND);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE salary SET sex = (CASE \\nWHEN sex = \\'f\\' \\nTHEN \\'m\\' \\nELSE \\'f\\' \\nEND);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 418662,
                "title": "3-solution-in-mysql-using-case-when-and-if",
                "content": "All of three are pretty alike.\\n\\n1. simply case, when, else\\n```\\nupdate salary \\nset sex = case sex when \\'m\\' then \\'f\\' else \\'m\\' end\\n```\\n2. specific case written\\n```\\n# update salary \\nset sex = case sex when \\'m\\' then \\'f\\'\\n                   when \\'f\\' then \\'m\\' end\\nwhere sex in (\\'m\\', \\'f\\')\\n```\\n3. if function\\n```\\n#IF\\nupdate salary\\nset sex = if(sex = \\'m\\', \\'f\\', \\'m\\') where sex in (\\'m\\', \\'f\\')\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate salary \\nset sex = case sex when \\'m\\' then \\'f\\' else \\'m\\' end\\n```\n```\\n# update salary \\nset sex = case sex when \\'m\\' then \\'f\\'\\n                   when \\'f\\' then \\'m\\' end\\nwhere sex in (\\'m\\', \\'f\\')\\n```\n```\\n#IF\\nupdate salary\\nset sex = if(sex = \\'m\\', \\'f\\', \\'m\\') where sex in (\\'m\\', \\'f\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374842,
                "title": "sql-server-solution",
                "content": "```\\nUpdate salary\\nSET sex = CASE\\nWHEN sex = \\'m\\' then \\'f\\'\\nwhen sex = \\'f\\' then \\'m\\'\\nELSE sex end\\n```",
                "solutionTags": [],
                "code": "```\\nUpdate salary\\nSET sex = CASE\\nWHEN sex = \\'m\\' then \\'f\\'\\nwhen sex = \\'f\\' then \\'m\\'\\nELSE sex end\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536630,
                "title": "mysql-solution-for-swap-salary-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the given solution is to update the sex column in the salary table. It uses a CASE statement to conditionally set the value of sex based on its current value. If the current value is \\'m\\', it is updated to \\'f\\', and if the current value is \\'f\\', it is updated to \\'m\\'.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken is to use a CASE statement, which allows for conditional logic in SQL queries. By specifying the condition when sex = \\'m\\', the query checks if the current value of sex is \\'m\\' and sets it to \\'f\\' in that case. Similarly, the else part handles the case when the current value is \\'f\\' and sets it to \\'m\\'.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the update operation itself depends on the size of the salary table and the database system being used. However, the complexity of the CASE statement is constant because it evaluates the condition and sets the value in a single step.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is also constant as it only involves updating the values in the existing rows of the salary table and does not require additional storage.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nupdate salary\\nset sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nupdate salary\\nset sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2861873,
                "title": "4-acceptable-solutions",
                "content": "#Updating using IF \\nUPDATE Salary SET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\');\\n\\n#Updating using CASE WHEN\\nUPDATE salary SET sex = (\\nCASE WHEN sex = \\'m\\' THEN  \\'f\\' \\nELSE \\'m\\' \\nEND\\n);\\n        \\n#Updating using REPLACE function        \\nUPDATE salary SET sex = REPLACE (\\'fm\\', sex, \\'\\');\\n\\n#Updating using XOR operator\\nUPDATE salary SET sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "#Updating using IF \\nUPDATE Salary SET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\');\\n\\n#Updating using CASE WHEN\\nUPDATE salary SET sex = (\\nCASE WHEN sex = \\'m\\' THEN  \\'f\\' \\nELSE \\'m\\' \\nEND\\n);\\n        \\n#Updating using REPLACE function        \\nUPDATE salary SET sex = REPLACE (\\'fm\\', sex, \\'\\');\\n\\n#Updating using XOR operator\\nUPDATE salary SET sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));",
                "codeTag": "Unknown"
            },
            {
                "id": 2714534,
                "title": "mysql-simply-short-code",
                "content": "```\\nUPDATE Salary \\nSET sex = CASE WHEN sex = \\'f\\' THEN \\'m\\'\\n               WHEN sex = \\'m\\' THEN \\'f\\'\\n          END;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary \\nSET sex = CASE WHEN sex = \\'f\\' THEN \\'m\\'\\n               WHEN sex = \\'m\\' THEN \\'f\\'\\n          END;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2594465,
                "title": "sql-beginner-using-if",
                "content": "\\t\\tupdate salary set sex = if (sex =\\'m\\',\\'f\\',\\'m\\');",
                "solutionTags": [],
                "code": "\\t\\tupdate salary set sex = if (sex =\\'m\\',\\'f\\',\\'m\\');",
                "codeTag": "Unknown"
            },
            {
                "id": 2575686,
                "title": "mysql-easiest-solution-most-efficient-solution",
                "content": "```\\nUPDATE salary\\nSET\\n    sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nUPDATE salary\\nSET\\n    sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2537280,
                "title": "mysql-two-solution",
                "content": "#Using if() similar to ternary operator  if(condition,if cond. is true return this, else return this)\\n```\\nupdate salary set sex = IF (sex = \"m\", \"f\", \"m\")\\n```\\n\\n#using case..when\\n```\\nupdate salary\\nset sex=case\\n            when sex=\\'f\\' then \\'m\\'\\n            when sex=\\'m\\' then \\'f\\'\\n        end;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate salary set sex = IF (sex = \"m\", \"f\", \"m\")\\n```\n```\\nupdate salary\\nset sex=case\\n            when sex=\\'f\\' then \\'m\\'\\n            when sex=\\'m\\' then \\'f\\'\\n        end;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2463057,
                "title": "easy-solution-of-swap-salary-one-line-query-mysql",
                "content": "```\\nupdate Salary set sex = if(sex = \\'m\\',\\'f\\',\\'m\\');",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate Salary set sex = if(sex = \\'m\\',\\'f\\',\\'m\\');",
                "codeTag": "Unknown"
            },
            {
                "id": 2436377,
                "title": "mysql-very-easy-solution-uwu",
                "content": "`UPDATE Salary SET sex = IF(sex=\\'m\\', \\'f\\', \\'m\\');`",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "`UPDATE Salary SET sex = IF(sex=\\'m\\', \\'f\\', \\'m\\');`",
                "codeTag": "Unknown"
            },
            {
                "id": 2433137,
                "title": "mysql-1-liner-solution-beginner-level-simple-short-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome.***\\n*====================================================================*\\n\\u2705 **MySQL Code :**\\n```\\nUPDATE salary SET sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));\\n```\\n**Runtime:** 412 ms\\n**Memory Usage:**  0B\\n________________________________\\n__________________________________\\n\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE salary SET sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297554,
                "title": "faster-than-93-mysql-solution",
                "content": "```\\nUPDATE\\n    salary\\nSET\\n    sex = IF(sex = \\'m\\', \\'f\\', \\'m\\');\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE\\n    salary\\nSET\\n    sex = IF(sex = \\'m\\', \\'f\\', \\'m\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140761,
                "title": "fastest-shortest",
                "content": "# ***For ALL solutions of MYSQL-1 STUDY PLAN  refer  https://github.com/its-red-eagle/LEETCODE-MYSQL-I-STUDY-PLAN-SOLUTIONS***\\n```\\nupdate salary set sex= char(ascii(\\'f\\') + ascii(\\'m\\') - ascii(sex));\\n```\\nIf you like the solution, please upvote\\n",
                "solutionTags": [],
                "code": "```\\nupdate salary set sex= char(ascii(\\'f\\') + ascii(\\'m\\') - ascii(sex));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2057129,
                "title": "easy-solution-97-76-faster",
                "content": "```\\nupdate Salary set sex = if(sex = \\'f\\' , \\'m\\',\\'f\\');\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate Salary set sex = if(sex = \\'f\\' , \\'m\\',\\'f\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2050576,
                "title": "using-update-and-if-mysql-very-easy",
                "content": "**How IF works?**\\nIF (condition, truthyValue, falsyValue). If condition is true, truthyValue is returned, otherwise falsyValue is returned.\\n\\n```\\nUPDATE Salary\\nSET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\');\\n```\\n\\n**IF FOUND USEFUL, PLEASE UPVOTE**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary\\nSET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1826497,
                "title": "mysql-solution",
                "content": "Ignore invalid test case \\'Salary\\' and submit\\n\\n```\\nUPDATE Salary SET sex = CASE WHEN sex = \"m\" THEN \"f\" ELSE \"m\" END\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary SET sex = CASE WHEN sex = \"m\" THEN \"f\" ELSE \"m\" END\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1518019,
                "title": "ms-sql",
                "content": "#### Question\\n```\\n627. Swap Salary\\nEasy\\n\\nSQL Schema\\nTable: Salary\\n\\n+-------------+----------+\\n| Column Name | Type     |\\n+-------------+----------+\\n| id          | int      |\\n| name        | varchar  |\\n| sex         | ENUM     |\\n| salary      | int      |\\n+-------------+----------+\\nid is the primary key for this table.\\nThe sex column is ENUM value of type (\\'m\\', \\'f\\').\\nThe table contains information about an employee.\\n \\n\\nWrite an SQL query to swap all \\'f\\' and \\'m\\' values (i.e., change all \\'f\\' values to \\'m\\' and vice versa) with a single update statement and no intermediate temp table(s).\\n\\nNote that you must write a single update statement, DO NOT write any select statement for this problem.\\n\\nThe query result format is in the following example:\\n\\n \\n\\nSalary table:\\n+----+------+-----+--------+\\n| id | name | sex | salary |\\n+----+------+-----+--------+\\n| 1  | A    | m   | 2500   |\\n| 2  | B    | f   | 1500   |\\n| 3  | C    | m   | 5500   |\\n| 4  | D    | f   | 500    |\\n+----+------+-----+--------+\\n\\nResult table:\\n+----+------+-----+--------+\\n| id | name | sex | salary |\\n+----+------+-----+--------+\\n| 1  | A    | f   | 2500   |\\n| 2  | B    | m   | 1500   |\\n| 3  | C    | f   | 5500   |\\n| 4  | D    | m   | 500    |\\n+----+------+-----+--------+\\n(1, A) and (3, C) were changed from \\'m\\' to \\'f\\'.\\n(2, B) and (4, D) were changed from \\'f\\' to \\'m\\'.\\n\\n```\\n\\n#### Answer\\n\\n##### Approach 1\\n```SQL\\nupdate salary set sex = IF (sex = \"m\", \"f\", \"m\");\\n```\\n\\n##### Approach 2\\n```SQL\\nUPDATE salary\\nSET\\n    sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n627. Swap Salary\\nEasy\\n\\nSQL Schema\\nTable: Salary\\n\\n+-------------+----------+\\n| Column Name | Type     |\\n+-------------+----------+\\n| id          | int      |\\n| name        | varchar  |\\n| sex         | ENUM     |\\n| salary      | int      |\\n+-------------+----------+\\nid is the primary key for this table.\\nThe sex column is ENUM value of type (\\'m\\', \\'f\\').\\nThe table contains information about an employee.\\n \\n\\nWrite an SQL query to swap all \\'f\\' and \\'m\\' values (i.e., change all \\'f\\' values to \\'m\\' and vice versa) with a single update statement and no intermediate temp table(s).\\n\\nNote that you must write a single update statement, DO NOT write any select statement for this problem.\\n\\nThe query result format is in the following example:\\n\\n \\n\\nSalary table:\\n+----+------+-----+--------+\\n| id | name | sex | salary |\\n+----+------+-----+--------+\\n| 1  | A    | m   | 2500   |\\n| 2  | B    | f   | 1500   |\\n| 3  | C    | m   | 5500   |\\n| 4  | D    | f   | 500    |\\n+----+------+-----+--------+\\n\\nResult table:\\n+----+------+-----+--------+\\n| id | name | sex | salary |\\n+----+------+-----+--------+\\n| 1  | A    | f   | 2500   |\\n| 2  | B    | m   | 1500   |\\n| 3  | C    | f   | 5500   |\\n| 4  | D    | m   | 500    |\\n+----+------+-----+--------+\\n(1, A) and (3, C) were changed from \\'m\\' to \\'f\\'.\\n(2, B) and (4, D) were changed from \\'f\\' to \\'m\\'.\\n\\n```\n```SQL\\nupdate salary set sex = IF (sex = \"m\", \"f\", \"m\");\\n```\n```SQL\\nUPDATE salary\\nSET\\n    sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1259325,
                "title": "sql-solution-easy-one-liner-memory-usage-less-than-100",
                "content": "```\\nUpdate Salary SET sex= CASE when sex=\\'m\\' then \\'f\\' when sex=\\'f\\' then \\'m\\' END;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUpdate Salary SET sex= CASE when sex=\\'m\\' then \\'f\\' when sex=\\'f\\' then \\'m\\' END;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1179841,
                "title": "mysql-simple",
                "content": "```\\nUPDATE Salary\\nSET sex = CASE \\n            WHEN sex = \\'m\\' THEN \\'f\\'\\n            WHEN sex = \\'f\\' THEN \\'m\\'\\n        END;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary\\nSET sex = CASE \\n            WHEN sex = \\'m\\' THEN \\'f\\'\\n            WHEN sex = \\'f\\' THEN \\'m\\'\\n        END;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745035,
                "title": "using-ascii",
                "content": "Using ASCII values of characters\\n```\\nUPDATE salary\\nSET sex = char( ASCII(\\'f\\') + ASCII(\\'m\\') - ASCII(sex) );",
                "solutionTags": [],
                "code": "Using ASCII values of characters\\n```\\nUPDATE salary\\nSET sex = char( ASCII(\\'f\\') + ASCII(\\'m\\') - ASCII(sex) );",
                "codeTag": "Unknown"
            },
            {
                "id": 550337,
                "title": "2-line-mysql",
                "content": "```\\nupdate salary\\nset sex = \\n    case when sex = \\'f\\' then \\'m\\' else \\'f\\' end\\n\\t",
                "solutionTags": [],
                "code": "```\\nupdate salary\\nset sex = \\n    case when sex = \\'f\\' then \\'m\\' else \\'f\\' end\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 342663,
                "title": "two-simple-and-short-solution-using-function-trim-or-xor",
                "content": "1. using function \"TRIM\":\\n```\\n update salary set sex = TRIM(sex from \"fm\");\\n ```\\n 2. using the bit op \"XOR\":\\n ```\\n update salary set sex = char(11 ^ ascii(sex));\\n ```\\n the `11` in the statement  is the result of  `102 ^ 109` where `102` stands for `\"f\"` in ascii and `109` for `\"m\"`.\\n",
                "solutionTags": [],
                "code": "```\\n update salary set sex = TRIM(sex from \"fm\");\\n ```\n```\\n update salary set sex = char(11 ^ ascii(sex));\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 199600,
                "title": "simple-mysql",
                "content": "```\\nUPDATE salary\\nSET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\')\\n```\\n",
                "solutionTags": [],
                "code": "```\\nUPDATE salary\\nSET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 162200,
                "title": "solution-with-update-case-accepted",
                "content": "```\\nUPDATE salary SET sex = (CASE WHEN sex = \\'m\\' THEN \\'f\\'\\n                              WHEN sex = \\'f\\' THEN \\'m\\'\\n                              else sex\\n                        END);```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nUPDATE salary SET sex = (CASE WHEN sex = \\'m\\' THEN \\'f\\'\\n                              WHEN sex = \\'f\\' THEN \\'m\\'\\n                              else sex\\n                        END);```",
                "codeTag": "Unknown"
            },
            {
                "id": 3556622,
                "title": "replace-function-used",
                "content": "# Intuition\\n**Syntax for Replace():**\\n\\n`replace(string,to_be_replaced,replaced_by)`\\n\\nHere we gave fm as string if `sex=f` then we will replace `f` of `fm` with `\\'\\'` so it will be simply` m`.\\nsimilarly, \\nif `sex=m` then we will replace `m` by `\\'\\'` and hence our string will become `f`\\nso the replace() function here is working as the conversion of `f` as `m` and `m` as `f`.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nupdate salary set sex=replace(\\'fm\\',sex,\\'\\');\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nupdate salary set sex=replace(\\'fm\\',sex,\\'\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3275881,
                "title": "sql-server-clean-easy",
                "content": "```\\n/* Write your T-SQL query statement below */\\nUPDATE Salary\\nSET sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        WHEN \\'f\\' THEN \\'m\\'\\n        END;\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nUPDATE Salary\\nSET sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        WHEN \\'f\\' THEN \\'m\\'\\n        END;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2890139,
                "title": "mysql-update-table-set-field-case",
                "content": "https://leetcode.com/submissions/detail/856532337/\\n```\\n# Write your MySQL query statement below\\nupdate Salary set sex = case \\n    when sex = \\'m\\' then \\'f\\'\\n    when sex = \\'f\\' then \\'m\\'\\n    end\\n```",
                "solutionTags": [
                    "MySQL",
                    "Ordered Set"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nupdate Salary set sex = case \\n    when sex = \\'m\\' then \\'f\\'\\n    when sex = \\'f\\' then \\'m\\'\\n    end\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2656201,
                "title": "sql-server",
                "content": "```\\nUPDATE salary\\nSET\\n    sex = CASE WHEN sex = \\'f\\' THEN \\'m\\' ELSE \\'f\\' END\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nUPDATE salary\\nSET\\n    sex = CASE WHEN sex = \\'f\\' THEN \\'m\\' ELSE \\'f\\' END\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2554772,
                "title": "sql-server",
                "content": "```\\nupdate salary \\nset sex = \\ncase \\n  when sex = \\'m\\' then  \\'f\\'\\n  else \\'m\\'\\nend \\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nupdate salary \\nset sex = \\ncase \\n  when sex = \\'m\\' then  \\'f\\'\\n  else \\'m\\'\\nend \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2517433,
                "title": "neat-and-easy-solution",
                "content": "**#Solution**\\n\\nUPDATE Salary\\nSET sex = \\nCASE\\n    WHEN sex = \"f\" THEN \"m\"\\n    WHEN sex = \"m\" THEN \"f\"\\nEND",
                "solutionTags": [
                    "MySQL",
                    "Ordered Set"
                ],
                "code": "**#Solution**\\n\\nUPDATE Salary\\nSET sex = \\nCASE\\n    WHEN sex = \"f\" THEN \"m\"\\n    WHEN sex = \"m\" THEN \"f\"\\nEND",
                "codeTag": "Unknown"
            },
            {
                "id": 2507870,
                "title": "mysql-simple-solution",
                "content": "***\\nUPDATE Salary\\nSET Sex= (CASE WHEN Sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END)\\n\\n***",
                "solutionTags": [],
                "code": "***\\nUPDATE Salary\\nSET Sex= (CASE WHEN Sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END)\\n\\n***",
                "codeTag": "Unknown"
            },
            {
                "id": 2477647,
                "title": "mysql-solution-case-statment-easy-understanding-faster-than-70",
                "content": "```\\nupdate SALARY\\nSET SEX = CASE WHEN SEX = \\'m\\' THEN \\'f\\' \\n               WHEN sex = \\'f\\' THEN \\'m\\' \\n          END\\n```\\n\\n**VOTE UP IF IT USEFULL **",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nupdate SALARY\\nSET SEX = CASE WHEN SEX = \\'m\\' THEN \\'f\\' \\n               WHEN sex = \\'f\\' THEN \\'m\\' \\n          END\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2306192,
                "title": "sql-for-dummies",
                "content": "\\tupdate Salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');",
                "solutionTags": [],
                "code": "\\tupdate Salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');",
                "codeTag": "Unknown"
            },
            {
                "id": 2212244,
                "title": "accept-solution-with-mysql-using-update-short-and-simple",
                "content": "\\t//MYSQL without select \\n\\t\\n\\tUPDATE Salary \\n\\t\\t\\tSET sex = IF(sex = \\'m\\', \\'f\\' , \\'m\\')",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\t//MYSQL without select \\n\\t\\n\\tUPDATE Salary \\n\\t\\t\\tSET sex = IF(sex = \\'m\\', \\'f\\' , \\'m\\')",
                "codeTag": "Unknown"
            },
            {
                "id": 2176238,
                "title": "2-mysql-solution",
                "content": "You can follow any of the two methods\\n```\\nupdate salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');\\n```\\n\\n```\\nupdate salary\\nset sex = \\ncase sex when \\'m\\' then \\'f\\' else \\'m\\'\\nend;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');\\n```\n```\\nupdate salary\\nset sex = \\ncase sex when \\'m\\' then \\'f\\' else \\'m\\'\\nend;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2123516,
                "title": "mysql-2-different-solutions",
                "content": "```\\n# Solution 1\\n\\nUPDATE Salary\\n    SET sex = (Case sex \\n                WHEN \\'m\\' THEN \\'f\\'\\n                ELSE \\'m\\'\\n              END ) \\n\\n#Solution  2\\n\\nUPDATE Salary\\nSET sex = IF(sex = \"m\",\"f\",\"m\");\\n```\\n",
                "solutionTags": [
                    "MySQL",
                    "Ordered Set"
                ],
                "code": "```\\n# Solution 1\\n\\nUPDATE Salary\\n    SET sex = (Case sex \\n                WHEN \\'m\\' THEN \\'f\\'\\n                ELSE \\'m\\'\\n              END ) \\n\\n#Solution  2\\n\\nUPDATE Salary\\nSET sex = IF(sex = \"m\",\"f\",\"m\");\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2082487,
                "title": "mysql-2-simple-solutions",
                "content": "***Using If Conditon***\\n```\\nUPDATE SALARY\\nSET SEX = IF(SEX=\\'f\\',\\'m\\',\\'f\\');\\n```\\n***Using Replace***\\n```\\nUPDATE SALARY\\nSET SEX = REPLACE(\\'fm\\',SEX,\\'\\');\\n```",
                "solutionTags": [],
                "code": "```\\nUPDATE SALARY\\nSET SEX = IF(SEX=\\'f\\',\\'m\\',\\'f\\');\\n```\n```\\nUPDATE SALARY\\nSET SEX = REPLACE(\\'fm\\',SEX,\\'\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2065490,
                "title": "easy-solution-faster-than-100",
                "content": "```\\n# Write your MySQL query statement below\\nupdate salary set sex=if(sex =\\'m\\',\\'f\\',\\'m\\') ;\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nupdate salary set sex=if(sex =\\'m\\',\\'f\\',\\'m\\') ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1959921,
                "title": "solution-with-if",
                "content": "```\\nupdate Salary \\nset sex = IF(sex = \"m\", \"f\", \"m\")\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate Salary \\nset sex = IF(sex = \"m\", \"f\", \"m\")\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1942160,
                "title": "mysql-easy-implementation",
                "content": "```\\nUPDATE Salary\\nSET\\n    sex = CASE sex\\n            WHEN \\'m\\' THEN \\'f\\'\\n            ELSE \\'m\\'\\n          END;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary\\nSET\\n    sex = CASE sex\\n            WHEN \\'m\\' THEN \\'f\\'\\n            ELSE \\'m\\'\\n          END;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1928874,
                "title": "627-swap-salary",
                "content": "```\\n# Write your MySQL query statement below\\nUPDATE Salary SET sex = IF(sex=\\'m\\',\\'f\\',\\'m\\')\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nUPDATE Salary SET sex = IF(sex=\\'m\\',\\'f\\',\\'m\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921988,
                "title": "oracle-96-04",
                "content": "```\\nupdate salary set sex = TRANSLATE(sex, \\'fm\\', \\'mf\\')\\n```",
                "solutionTags": [],
                "code": "```\\nupdate salary set sex = TRANSLATE(sex, \\'fm\\', \\'mf\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525783,
                "title": "mysql-simple-solution-using-case",
                "content": "```\\n# https://leetcode.com/problems/swap-salary/submissions/\\n-- Use If Else to set value\\n\\nUPDATE Salary\\nSET \\n    sex = \\n    CASE\\n        WHEN sex = \\'f\\' THEN \\'m\\'\\n        WHEN sex = \\'m\\' THEN \\'f\\'\\n    END;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# https://leetcode.com/problems/swap-salary/submissions/\\n-- Use If Else to set value\\n\\nUPDATE Salary\\nSET \\n    sex = \\n    CASE\\n        WHEN sex = \\'f\\' THEN \\'m\\'\\n        WHEN sex = \\'m\\' THEN \\'f\\'\\n    END;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1341746,
                "title": "sql-update-case-when-solution",
                "content": "```\\nupdate salary\\nset sex = \\ncase\\n    when sex = \\'f\\' then \\'m\\'\\n    when sex = \\'m\\' then \\'f\\'\\nend;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate salary\\nset sex = \\ncase\\n    when sex = \\'f\\' then \\'m\\'\\n    when sex = \\'m\\' then \\'f\\'\\nend;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878181,
                "title": "my-solution-using-if-statement-faster-than-98-5",
                "content": "```\\nUPDATE SALARY\\nSET sex = IF(sex =\\'m\\', \\'f\\', \\'m\\')\\n```",
                "solutionTags": [],
                "code": "```\\nUPDATE SALARY\\nSET sex = IF(sex =\\'m\\', \\'f\\', \\'m\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 874938,
                "title": "mysql-simple-short-concise-beginner-interview-prep-beats-100",
                "content": "```\\nUPDATE salary \\nSET sex = CASE sex\\n    WHEN \\'m\\' THEN \\'f\\'\\n    ELSE \\'m\\'\\nEND;\\n```",
                "solutionTags": [],
                "code": "```\\nUPDATE salary \\nSET sex = CASE sex\\n    WHEN \\'m\\' THEN \\'f\\'\\n    ELSE \\'m\\'\\nEND;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 833643,
                "title": "mysql-easy-solution",
                "content": "```\\nupdate salary\\nset sex = case\\n    when sex = \\'m\\' then \\'f\\'\\n    else \\'m\\'\\nend",
                "solutionTags": [],
                "code": "```\\nupdate salary\\nset sex = case\\n    when sex = \\'m\\' then \\'f\\'\\n    else \\'m\\'\\nend",
                "codeTag": "Unknown"
            },
            {
                "id": 537865,
                "title": "mysql-solution",
                "content": "# Vesry Simple Solution\\n```\\nUPDATE salary\\nSET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\');\\n```",
                "solutionTags": [],
                "code": "```\\nUPDATE salary\\nSET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 504204,
                "title": "oracle-solution",
                "content": "```\\nUPDATE salary s\\nSET sex = \\nCASE \\n  WHEN sex=\\'m\\' THEN \\'f\\'\\n  WHEN sex=\\'f\\' THEN \\'m\\'\\nEND;\\n```",
                "solutionTags": [],
                "code": "```\\nUPDATE salary s\\nSET sex = \\nCASE \\n  WHEN sex=\\'m\\' THEN \\'f\\'\\n  WHEN sex=\\'f\\' THEN \\'m\\'\\nEND;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 501072,
                "title": "mysql-simple-solution",
                "content": "```\\n# Write your MySQL query statement below\\nUPDATE salary SET\\nsex = CASE\\n    WHEN sex = \"m\" THEN \"f\"\\n    WHEN sex = \"f\" THEN \"m\"   \\nEND\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nUPDATE salary SET\\nsex = CASE\\n    WHEN sex = \"m\" THEN \"f\"\\n    WHEN sex = \"f\" THEN \"m\"   \\nEND\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 449277,
                "title": "mysql-with-explanation",
                "content": "```\\n# UPDATE query is used to update existing data in table \"salary\"\\nUPDATE salary \\n# The SET will tell what to change,\\n# with WHERE clause will limit when it is changed.\\n# example: SET sex = \\'f\\' WHERE sex = \\'m\\';\\n# but we want to change all entries, but conditionally\\n# So, let\\'s add some logic saying:\\n#    If sex is \\'m\\' use \\'f\\' otherwise use \\'m\\'\\nSET sex = IF(sex=\\'m\\',\\'f\\',\\'m\\')\\n```",
                "solutionTags": [],
                "code": "```\\n# UPDATE query is used to update existing data in table \"salary\"\\nUPDATE salary \\n# The SET will tell what to change,\\n# with WHERE clause will limit when it is changed.\\n# example: SET sex = \\'f\\' WHERE sex = \\'m\\';\\n# but we want to change all entries, but conditionally\\n# So, let\\'s add some logic saying:\\n#    If sex is \\'m\\' use \\'f\\' otherwise use \\'m\\'\\nSET sex = IF(sex=\\'m\\',\\'f\\',\\'m\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427531,
                "title": "t-sql-one-line",
                "content": "```\\nupdate salary set sex = CHAR(ASCII(sex)^11)\\n```\\n\\nASCII values:\\nf = 0110 0110\\nm = 0110 1101\\n\\nThe inverse bits are 1011 (integer value 11) - so XOR with that.",
                "solutionTags": [],
                "code": "```\\nupdate salary set sex = CHAR(ASCII(sex)^11)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311014,
                "title": "using-case-when",
                "content": "```\\nupdate salary \\nset sex = (case when sex=\\'m\\' then \\'f\\' when sex=\\'f\\' then \\'m\\' end)\\n```",
                "solutionTags": [],
                "code": "```\\nupdate salary \\nset sex = (case when sex=\\'m\\' then \\'f\\' when sex=\\'f\\' then \\'m\\' end)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 265273,
                "title": "simple-using-case",
                "content": "```\\nUpdate salary\\nSET sex = Case\\n                When sex = \\'m\\' then \\'f\\'\\n                else \\'m\\'\\n            end\\n```",
                "solutionTags": [],
                "code": "```\\nUpdate salary\\nSET sex = Case\\n                When sex = \\'m\\' then \\'f\\'\\n                else \\'m\\'\\n            end\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 245050,
                "title": "123ms-solution",
                "content": "This does not change the table, but it gives you a 123ms solution. Oo.\\n```\\nselect s.id, \\n    s.name,\\n    case when s.sex = \\'m\\' then \\'f\\'\\n        else \\'m\\' \\n    end as sex,\\n    s.salary\\nfrom salary as s;\\n```",
                "solutionTags": [],
                "code": "```\\nselect s.id, \\n    s.name,\\n    case when s.sex = \\'m\\' then \\'f\\'\\n        else \\'m\\' \\n    end as sex,\\n    s.salary\\nfrom salary as s;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067071,
                "title": "pandas-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse dataframe function - replace\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef swap_salary(salary: pd.DataFrame) -> pd.DataFrame:\\n    return salary.replace({\\'f\\':\\'m\\', \\'m\\':\\'f\\'})\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef swap_salary(salary: pd.DataFrame) -> pd.DataFrame:\\n    return salary.replace({\\'f\\':\\'m\\', \\'m\\':\\'f\\'})\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4065423,
                "title": "pandas-sql-easy-swap-salary",
                "content": "[see the successfully Accepted Submission](https://leetcode.com/submissions/detail/1053788418/)\\n```\\nimport pandas as pd\\n\\ndef swap_salary(salary: pd.DataFrame) -> pd.DataFrame:\\n    # We just use the \\'replace\\' method to update the \\'sex\\' column values ;) \\n    salary[\\'sex\\'] = salary[\\'sex\\'].replace({\\'m\\': \\'f\\', \\n                                           \\'f\\': \\'m\\'})\\n    return salary\\n```\\n\\n**SQL**\\n[see the successfully Accepted Submission](https://leetcode.com/submissions/detail/1061676948/)\\n\\n```\\nUPDATE Salary \\nSET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\');\\n```\\n\\n```\\n-- Update the \"Salary\" tabl\\nUPDATE Salary \\n\\n-- Set the \"sex\" column value to a new value using a conditional statement:\\n-- If the current value of \"sex\" is \\'m\\' (male), then change it to \\'f\\' (female).\\n-- If the current value of \"sex\" is \\'f\\' (female), then change it to \\'m\\' (male).\\nSET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\');\\n```\\n\\n![image](https://assets.leetcode.com/users/images/db6108e6-d7e8-427b-9594-bfb348992a2b_1695144218.1195602.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef swap_salary(salary: pd.DataFrame) -> pd.DataFrame:\\n    # We just use the \\'replace\\' method to update the \\'sex\\' column values ;) \\n    salary[\\'sex\\'] = salary[\\'sex\\'].replace({\\'m\\': \\'f\\', \\n                                           \\'f\\': \\'m\\'})\\n    return salary\\n```\n```\\nUPDATE Salary \\nSET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\');\\n```\n```\\n-- Update the \"Salary\" tabl\\nUPDATE Salary \\n\\n-- Set the \"sex\" column value to a new value using a conditional statement:\\n-- If the current value of \"sex\" is \\'m\\' (male), then change it to \\'f\\' (female).\\n-- If the current value of \"sex\" is \\'f\\' (female), then change it to \\'m\\' (male).\\nSET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\');\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3960847,
                "title": "most-easy-solution-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nUPDATE SALARY SET SEX=IF(SEX=\\'m\\',\\'f\\',\\'m\\');\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nUPDATE SALARY SET SEX=IF(SEX=\\'m\\',\\'f\\',\\'m\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3557087,
                "title": "one-line-update-statement",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\nUPDATE salary SET sex = CASE when sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' END;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nUPDATE salary SET sex = CASE when sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' END;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3490309,
                "title": "mysql-easy-solution",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nupdate salary\\nset sex=case sex\\nwhen \\'m\\' then \\'f\\'\\nwhen \\'f\\' then \\'m\\'\\nend;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nupdate salary\\nset sex=case sex\\nwhen \\'m\\' then \\'f\\'\\nwhen \\'f\\' then \\'m\\'\\nend;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3072634,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nUPDATE Salary\\nSET sex = CASE WHEN sex = \\'m\\' THEN \\'f\\' \\n                WHEN sex = \\'f\\' THEN \\'m\\' END\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nUPDATE Salary\\nSET sex = CASE WHEN sex = \\'m\\' THEN \\'f\\' \\n                WHEN sex = \\'f\\' THEN \\'m\\' END\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2764823,
                "title": "mysql-single-line-solution",
                "content": "Simple MySQL query using IF statement, runs **85%** faster than other submissions.\\n\\nHere the IF statement checks whether sex = \\'m\\', if True then \\'f\\' is returned or else \\'m\\' is returned\\n\\n```\\nUPDATE SALARY SET SEX = IF(SEX=\\'m\\',\\'f\\',\\'m\\');\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE SALARY SET SEX = IF(SEX=\\'m\\',\\'f\\',\\'m\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2698915,
                "title": "two-approach-case-when-then-if",
                "content": "```\\n# 1. Method\\nUPDATE Salary\\nSET Salary.sex = IF(Salary.sex = \\'m\\', \\'f\\',\\'m\\')\\n\\n# 2. method\\nUPDATE Salary\\nSET sex =  CASE WHEN sex = \\'m\\' THEN \\'f\\'\\nWHEN sex = \\'f\\' THEN \\'m\\' END\\n```\\nPlease do upvote if you like it",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# 1. Method\\nUPDATE Salary\\nSET Salary.sex = IF(Salary.sex = \\'m\\', \\'f\\',\\'m\\')\\n\\n# 2. method\\nUPDATE Salary\\nSET sex =  CASE WHEN sex = \\'m\\' THEN \\'f\\'\\nWHEN sex = \\'f\\' THEN \\'m\\' END\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2643065,
                "title": "mysql-one-line-cleanest",
                "content": "```\\nupdate salary set sex = if(sex=\\'f\\', \\'m\\', \\'f\\');\\n```",
                "solutionTags": [],
                "code": "```\\nupdate salary set sex = if(sex=\\'f\\', \\'m\\', \\'f\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2626928,
                "title": "mysql-using-if-statement",
                "content": "\\tUPDATE Salary\\n\\t\\tSET sex = if(sex = \\'m\\', \\'f\\', \\'m\\')",
                "solutionTags": [],
                "code": "\\tUPDATE Salary\\n\\t\\tSET sex = if(sex = \\'m\\', \\'f\\', \\'m\\')",
                "codeTag": "Unknown"
            },
            {
                "id": 2624601,
                "title": "case-when-explanation",
                "content": "**Update** function is to modify the existing records in the table\\n**Set** follows Update syntax\\nWe\\'re setting new values for Sex by giving it a conditional Case When syntax\\n\\n```\\nUpdate Salary\\nset sex = \\n    case\\n        when sex = \\'m\\' then \\'f\\'\\n        else \\'m\\'\\n    end\\n```\\n\\n*Pls upvote if you find this helpful :)*",
                "solutionTags": [],
                "code": "```\\nUpdate Salary\\nset sex = \\n    case\\n        when sex = \\'m\\' then \\'f\\'\\n        else \\'m\\'\\n    end\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2612347,
                "title": "mysql",
                "content": "```\\nupdate  Salary set sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end\\n\\n```",
                "solutionTags": [],
                "code": "```\\nupdate  Salary set sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2595388,
                "title": "swap-salary-338ms-easy-solution-one-line",
                "content": "Please upvote. \\n\\nUPDATE Salary SET sex = IF(sex=\\'m\\',\\'f\\',\\'m\\')",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "Please upvote. \\n\\nUPDATE Salary SET sex = IF(sex=\\'m\\',\\'f\\',\\'m\\')",
                "codeTag": "Unknown"
            },
            {
                "id": 2580752,
                "title": "swap-salary-using-if-or-case",
                "content": "You can solve this using `IF` OR `CASE` using a single update statement\\n\\n### Solution 1\\n\\n`UPDATE Salary set sex=(CASE WHEN sex = \\'m\\' then \\'f\\' else \\'m\\' end);`\\n\\n### Solution 2\\n\\n`UPDATE Salary set sex= IF(sex=\\'m\\', \\'f\\', \\'m\\');`",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "You can solve this using `IF` OR `CASE` using a single update statement\\n\\n### Solution 1\\n\\n`UPDATE Salary set sex=(CASE WHEN sex = \\'m\\' then \\'f\\' else \\'m\\' end);`\\n\\n### Solution 2\\n\\n`UPDATE Salary set sex= IF(sex=\\'m\\', \\'f\\', \\'m\\');`",
                "codeTag": "Unknown"
            },
            {
                "id": 2577833,
                "title": "easy-sql-solution-using-case-when",
                "content": "```\\nUPDATE Salary SET sex = CASE WHEN sex=\\'m\\' THEN \\'f\\' else \\'m\\' end\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary SET sex = CASE WHEN sex=\\'m\\' THEN \\'f\\' else \\'m\\' end\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2576446,
                "title": "petty-straightforward-and-easy",
                "content": "```\\nUPDATE Salary \\nSET sex = IF(sex=\\'m\\',\\'f\\',\\'m\\');\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary \\nSET sex = IF(sex=\\'m\\',\\'f\\',\\'m\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2568309,
                "title": "1-liner-my-sql-conditional-approach",
                "content": "UPDATE salary SET sex  = (CASE WHEN sex = \\'m\\' THEN  \\'f\\' ELSE \\'m\\' END)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "UPDATE salary SET sex  = (CASE WHEN sex = \\'m\\' THEN  \\'f\\' ELSE \\'m\\' END)",
                "codeTag": "Unknown"
            },
            {
                "id": 2558670,
                "title": "easiest-sql-solution",
                "content": "Do upvote if you like it!\\n\\n```\\nupdate salary set sex = IF (sex = \"m\", \"f\", \"m\")\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate salary set sex = IF (sex = \"m\", \"f\", \"m\")\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2519992,
                "title": "mysql-case",
                "content": "```\\nupdate salary\\nset sex = case\\nwhen sex=\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate salary\\nset sex = case\\nwhen sex=\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2505274,
                "title": "easy-mysql-solution",
                "content": "update Salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "update Salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');",
                "codeTag": "Unknown"
            },
            {
                "id": 2450446,
                "title": "mysql-solution-using-case-if",
                "content": "**Approach 1**\\n\\n```\\nupdate salary\\nset sex = case when sex = \\'f\\' then \\'m\\'\\n               when sex = \\'m\\' then \\'f\\'\\n               end;\\n\\t\\n\\t\\n```\\n**Approach 2**\\n\\n```\\nupdate salary set sex= if(sex=\\'f\\',\\'m\\',\\'f\\');\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate salary\\nset sex = case when sex = \\'f\\' then \\'m\\'\\n               when sex = \\'m\\' then \\'f\\'\\n               end;\\n\\t\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2444679,
                "title": "mysql-solution-using-if-condition",
                "content": "```\\nupdate salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2425078,
                "title": "detailed-explanation-update-if-beginners",
                "content": "```\\n# UPDATE Syntax\\nUPDATE table_name\\nSET column1 = value1, column2 = value2, ...\\nWHERE condition;\\n\\n# IF Syntax\\n# IF(condition, value_if_true, value_if_false)\\n\\nUPDATE Salary SET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\');\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# UPDATE Syntax\\nUPDATE table_name\\nSET column1 = value1, column2 = value2, ...\\nWHERE condition;\\n\\n# IF Syntax\\n# IF(condition, value_if_true, value_if_false)\\n\\nUPDATE Salary SET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2424126,
                "title": "swap-ascii-codes-mathematically-mysql",
                "content": "This solution is based on the fact that swapping 2 posivitve integers x, y can be done through the formula: `swap(current) = (current - (min(x, y) + max(x, y))) * -1`.\\nAs known, ASCII code of `m` is `109`, while that of `f` is `102`. This means that `min(x, y) + max(x, y) = 109 + 102 =  211`.\\n\\nFinally the final solution will be as in the follwing:\\n\\n```\\nUPDATE Salary SET sex = CHAR((ASCII(sex) - 211) * -1);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary SET sex = CHAR((ASCII(sex) - 211) * -1);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2366566,
                "title": "oracle-solution",
                "content": "```\\nupdate Salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\'\\nelse \\'m\\'\\nend\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nupdate Salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\'\\nelse \\'m\\'\\nend\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2364331,
                "title": "easy-faster-running-all-test-cases",
                "content": "```\\nupdate salary\\nset sex = if(sex= \\'m\\',\\'f\\',\\'m\\');",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate salary\\nset sex = if(sex= \\'m\\',\\'f\\',\\'m\\');",
                "codeTag": "Unknown"
            },
            {
                "id": 2354433,
                "title": "mysql-two-approaches-case-if-else",
                "content": "**IF-ELSE**\\n```\\nupdate Salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\');\\n```\\n**CASE**\\n```\\nupdate salary set sex=\\ncase \\nwhen sex=\\'f\\' then \\'m\\'\\nelse \\'f\\'\\nend ;\\n```",
                "solutionTags": [],
                "code": "```\\nupdate Salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\');\\n```\n```\\nupdate salary set sex=\\ncase \\nwhen sex=\\'f\\' then \\'m\\'\\nelse \\'f\\'\\nend ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2351532,
                "title": "swap-salary",
                "content": "```\\nUPDATE Salary SET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\');\\n```",
                "solutionTags": [
                    "MySQL",
                    "Ordered Set"
                ],
                "code": "```\\nUPDATE Salary SET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2350848,
                "title": "two-simple-easy-to-understand-solution",
                "content": "**Method 1:**\\n\\'\\'\\'\\n\\n\\tupdate salary\\n\\tset sex = (case when sex=\"m\" then \"f\" else \"m\" end)\\n\\'\\'\\'\\n\\n\\n**Method 2:**\\n\\'\\'\\'\\n\\n\\tupdate Salary\\n\\tset sex = if(sex = \\'f\\', \\'m\\', \\'f\\')\\n\\'\\'\\'\\n\\n#### Please Upvote if you find this solution Helpful !!!",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**Method 1:**\\n\\'\\'\\'\\n\\n\\tupdate salary\\n\\tset sex = (case when sex=\"m\" then \"f\" else \"m\" end)\\n\\'\\'\\'\\n\\n\\n**Method 2:**\\n\\'\\'\\'\\n\\n\\tupdate Salary\\n\\tset sex = if(sex = \\'f\\', \\'m\\', \\'f\\')\\n\\'\\'\\'\\n\\n#### Please Upvote if you find this solution Helpful !!!",
                "codeTag": "Unknown"
            },
            {
                "id": 2347988,
                "title": "mysql",
                "content": "```\\n# Write your MySQL query statement below\\nupdate Salary\\nset sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nupdate Salary\\nset sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2328707,
                "title": "100-faster-using-simple-if-statement",
                "content": "```\\nUPDATE \\n    salary \\nSET \\n    sex = IF (sex = \"m\", \"f\", \"m\");\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE \\n    salary \\nSET \\n    sex = IF (sex = \"m\", \"f\", \"m\");\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2321826,
                "title": "mysql-solution-using-if-faster-than-91",
                "content": "```\\nupdate Salary set sex = IF(sex = \\'m\\', \"f\", \"m\");\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nupdate Salary set sex = IF(sex = \\'m\\', \"f\", \"m\");\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2303983,
                "title": "faster-than-86-05",
                "content": "```\\n# Write your MySQL query statement below\\nUPDATE Salary SET sex = CASE WHEN sex = \\'f\\' THEN \\'m\\' ELSE \\'f\\' END",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nUPDATE Salary SET sex = CASE WHEN sex = \\'f\\' THEN \\'m\\' ELSE \\'f\\' END",
                "codeTag": "Unknown"
            },
            {
                "id": 2284211,
                "title": "mysql-fast-using-case-if",
                "content": "```\\nupdate Salary \\nset sex =\\ncase\\nwhen sex=\\'m\\' then \\'f\\'\\nelse \\'m\\'\\nend",
                "solutionTags": [],
                "code": "```\\nupdate Salary \\nset sex =\\ncase\\nwhen sex=\\'m\\' then \\'f\\'\\nelse \\'m\\'\\nend",
                "codeTag": "Unknown"
            },
            {
                "id": 2270901,
                "title": "3-approach-easy-to-understand",
                "content": "Method 1:\\n```\\nupdate salary set sex= \\n                      case sex\\n                      when \\'f\\' then \\'m\\'\\n                      else \\'f\\'\\n                      end\\n```\\nmethod 2 :\\n```               \\nupdate salary set sex =if(sex=\\'f\\',\\'m\\',\\'f\\')\\n```\\nMethod 3 :\\n```\\nupdate salary set sex=char(ascii(\\'f\\') ^ ascii(\\'m\\') ^ ascii(sex))  \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate salary set sex= \\n                      case sex\\n                      when \\'f\\' then \\'m\\'\\n                      else \\'f\\'\\n                      end\\n```\n```               \\nupdate salary set sex =if(sex=\\'f\\',\\'m\\',\\'f\\')\\n```\n```\\nupdate salary set sex=char(ascii(\\'f\\') ^ ascii(\\'m\\') ^ ascii(sex))  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2269657,
                "title": "1-line-simple-code-mysql",
                "content": "```\\nUPDATE Salary SET sex = IF(sex=\\'m\\', \\'f\\', \\'m\\');\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary SET sex = IF(sex=\\'m\\', \\'f\\', \\'m\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2254288,
                "title": "mysql-simple-mysql-solution-using-if-else-condition",
                "content": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 479 ms, faster than 12.29% of MySQL online submissions for Swap Salary.\\n# Memory Usage: 0B, less than 100.00% of MySQL online submissions for Swap Salary.\\n\\n\\tUPDATE SALARY \\n\\tSET \\n\\t\\tSEX = CASE \\n\\t\\t\\t\\tWHEN SEX = \\'f\\' THEN \\'m\\'\\n\\t\\t\\t\\tELSE \\'f\\'\\n\\t\\t\\t  END;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 479 ms, faster than 12.29% of MySQL online submissions for Swap Salary.\\n# Memory Usage: 0B, less than 100.00% of MySQL online submissions for Swap Salary.\\n\\n\\tUPDATE SALARY \\n\\tSET \\n\\t\\tSEX = CASE \\n\\t\\t\\t\\tWHEN SEX = \\'f\\' THEN \\'m\\'\\n\\t\\t\\t\\tELSE \\'f\\'\\n\\t\\t\\t  END;",
                "codeTag": "Unknown"
            },
            {
                "id": 2248985,
                "title": "solution-using-case",
                "content": "```\\nUPDATE Salary SET sex = (\\n  CASE sex\\n  WHEN \\'m\\' THEN \\'f\\'\\n  WHEN \\'f\\' THEN \\'m\\'\\n  END\\n)\\n```",
                "solutionTags": [],
                "code": "```\\nUPDATE Salary SET sex = (\\n  CASE sex\\n  WHEN \\'m\\' THEN \\'f\\'\\n  WHEN \\'f\\' THEN \\'m\\'\\n  END\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246235,
                "title": "simples-oracle-solution",
                "content": "```\\nupdate Salary\\nset sex = case\\nwhen sex=\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nupdate Salary\\nset sex = case\\nwhen sex=\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2226474,
                "title": "two-simple-solutions",
                "content": "**1st Solution using if condition**\\n```\\nUPDATE Salary SET sex = IF(sex=\\'f\\', \\'m\\', \\'f\\');\\n```\\n**2nd Solution using case when condition**\\n```\\n\\nupdate Salary set sex =\\ncase\\nwhen sex = \\'m\\'\\nthen \\'f\\'\\nelse \\'m\\'\\nend\\n```\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary SET sex = IF(sex=\\'f\\', \\'m\\', \\'f\\');\\n```\n```\\n\\nupdate Salary set sex =\\ncase\\nwhen sex = \\'m\\'\\nthen \\'f\\'\\nelse \\'m\\'\\nend\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2216518,
                "title": "627-swap-salary",
                "content": "```\\n\\nupdate Salary set sex = (case when sex = \\'m\\' then \\'f\\' else \\'m\\' end) \\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n\\nupdate Salary set sex = (case when sex = \\'m\\' then \\'f\\' else \\'m\\' end) \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2212672,
                "title": "627-swap-salary",
                "content": "```\\nupdate Salary set sex = (case when sex = \\'f\\' then \\'m\\' else \\'f\\' end)\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nupdate Salary set sex = (case when sex = \\'f\\' then \\'m\\' else \\'f\\' end)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2204197,
                "title": "beats-91-easy",
                "content": "```\\nUPDATE Salary SET \\nsex = CHAR(ASCII(\\'f\\') + ASCII(\\'m\\') - ASCII(sex))`\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary SET \\nsex = CHAR(ASCII(\\'f\\') + ASCII(\\'m\\') - ASCII(sex))`\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192922,
                "title": "mysql-solution-using-if-statement",
                "content": "```\\nUPDATE Salary SET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\');\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary SET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2186843,
                "title": "line-by-line-explanation",
                "content": "```\\nupdate Salary set sex=    #updating sex value depending on cases\\n    case\\n        when sex=\\'f\\' then \\'m\\'   #if sex is \\'f\\', then change it to \\'m\\'\\n        else \\'f\\'                #otherwise to \\'f\\'\\n    end;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate Salary set sex=    #updating sex value depending on cases\\n    case\\n        when sex=\\'f\\' then \\'m\\'   #if sex is \\'f\\', then change it to \\'m\\'\\n        else \\'f\\'                #otherwise to \\'f\\'\\n    end;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152228,
                "title": "89-faster-using-if-statement",
                "content": "`UPDATE` and `SET` are used to change data of table\\nBelow `if` condition means `if(condition, true_value, false_value)` swaping \\n`sex = \\'m\\'` to `\\'f\\'` when true and `m` when false\\n```\\nupdate Salary\\nset sex = if(sex = \\'m\\', \\'f\\', \\'m\\')\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate Salary\\nset sex = if(sex = \\'m\\', \\'f\\', \\'m\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2115404,
                "title": "four-approaches",
                "content": "**1st**\\n```\\nUPDATE SALARY \\nSET sex = IF(sex=\\'m\\', \\'f\\', \\'m\\');\\n```\\n\\n**2nd**\\n```\\nUPDATE SALARY \\nSET sex = \\nCASE\\n    WHEN sex=\\'m\\' THEN \\'f\\'\\n    else \\'m\\'\\nEND;\\n```\\n\\n**3rd**\\n```\\nUPDATE SALARY \\nSET sex = CHAR(ASCII(\\'f\\') + ASCII(\\'m\\') - ASCII(sex));\\n```\\n\\n**4th**\\n```\\nUPDATE SALARY \\nSET sex = CHAR(ASCII(\\'f\\') + ASCII(\\'m\\') - ASCII(sex));\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE SALARY \\nSET sex = IF(sex=\\'m\\', \\'f\\', \\'m\\');\\n```\n```\\nUPDATE SALARY \\nSET sex = \\nCASE\\n    WHEN sex=\\'m\\' THEN \\'f\\'\\n    else \\'m\\'\\nEND;\\n```\n```\\nUPDATE SALARY \\nSET sex = CHAR(ASCII(\\'f\\') + ASCII(\\'m\\') - ASCII(sex));\\n```\n```\\nUPDATE SALARY \\nSET sex = CHAR(ASCII(\\'f\\') + ASCII(\\'m\\') - ASCII(sex));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113036,
                "title": "100-unique-solution",
                "content": "```\\nUPDATE Salary\\nSET sex= IF (sex=\\'m\\',\\'f\\',\\'m\\') ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary\\nSET sex= IF (sex=\\'m\\',\\'f\\',\\'m\\') ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2079318,
                "title": "very-easy-sql-query-short-and-simple",
                "content": "```\\nUPDATE Salary\\nset sex=(CASE\\n         when sex=\\'m\\' then \\'f\\'\\n         else \\'m\\'\\n         END\\n);```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nUPDATE Salary\\nset sex=(CASE\\n         when sex=\\'m\\' then \\'f\\'\\n         else \\'m\\'\\n         END\\n);```",
                "codeTag": "Unknown"
            },
            {
                "id": 2076433,
                "title": "2-solution-with-different-approaches",
                "content": "I have done this with the following 2 solutions - \\n\\nSolution 1 : **IF statement**\\n```\\nUPDATE salary SET sex = IF(sex=\\'m\\',\\'f\\',\\'m\\');\\n```\\nHere we use the IF statement which has the following format : \\n**IF( condition , value_if_true , value_if_false)**\\n\\nNow if the sex = **\\'m\\'** then it is replaced by **\\'f\\'**  \\nIf not **\\'m; i.e = f** (as there are only two options in the question) it will replace it with **\\'m\\'**\\nThe table is completely updated.\\n\\nSolution 2 : **Using REPLACE**\\n\\n```\\nUPDATE salary SET sex = REPLACE (\\'fm\\', sex, \\'\\');\\n```\\nHere we use the REPLACE statement which has the following format : \\n**REPLACE(string, from_string, new_string)**\\n\\nSo in this question every time the sex value would be replaced\\nIf the sex is **\\'m\\'** then in the **\\'fm\\'**, **m** is replaced by **\\'\\'** (Blank) leaving only **\\'f\\'** and this value is set. \\nSimilarly if sex is **\\'f\\'** then in the **\\'fm\\'**, **f** is replaced by **\\'\\'** (Blank) leaving only **\\'m\\'** and that value is set\\nThe table gets updated \\n\\n-SS",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nUPDATE salary SET sex = IF(sex=\\'m\\',\\'f\\',\\'m\\');\\n```\n```\\nUPDATE salary SET sex = REPLACE (\\'fm\\', sex, \\'\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2050246,
                "title": "using-update-command",
                "content": "```\\nUPDATE salary\\n    SET sex  = (CASE WHEN sex = \\'f\\' \\n        THEN  \\'m\\' \\n        ELSE \\'f\\' \\n        END)\\n```",
                "solutionTags": [],
                "code": "```\\nUPDATE salary\\n    SET sex  = (CASE WHEN sex = \\'f\\' \\n        THEN  \\'m\\' \\n        ELSE \\'f\\' \\n        END)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2049782,
                "title": "sql-server-solution-using-iif-ternary",
                "content": "```\\nupdate Salary\\nset sex = IIF (sex = \\'f\\', \\'m\\', \\'f\\') \\n\\n-- iif (<condition>, <result when condition is True>, <result when False>)\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nupdate Salary\\nset sex = IIF (sex = \\'f\\', \\'m\\', \\'f\\') \\n\\n-- iif (<condition>, <result when condition is True>, <result when False>)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018892,
                "title": "common-solution-with-if-and-case-statement",
                "content": "Solution with IF statement\\n\\n```\\nUPDATE Salary\\nSET sex = IF(sex = \"m\", \"f\", \"m\")\\n```\\n\\nRuntime: 209 ms, faster than 83.88% of MySQL online submissions for Swap Salary.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Swap Salary.\\n\\nSolution with CASE statement\\n\\n```\\nUPDATE Salary\\nSET sex = CASE\\n          WHEN sex = \\'f\\' THEN \\'m\\'\\n          ELSE \\'f\\'\\nEND\\n```\\n\\nRuntime: 241 ms, faster than 58.31% of MySQL online submissions for Swap Salary.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Swap Salary.",
                "solutionTags": [],
                "code": "```\\nUPDATE Salary\\nSET sex = IF(sex = \"m\", \"f\", \"m\")\\n```\n```\\nUPDATE Salary\\nSET sex = CASE\\n          WHEN sex = \\'f\\' THEN \\'m\\'\\n          ELSE \\'f\\'\\nEND\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1984266,
                "title": "swap-salary-using-simple-case-stmt",
                "content": "```\\n-- Using Case Statement Solves The Problem.\\nUPDATE SALARY\\nSET SEX =  CASE \\n                  WHEN SEX = \\'m\\' THEN \\'f\\'\\n                  WHEN SEX = \\'f\\'  THEN \\'m\\'\\n\\t\\t\\t\\t  END\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n-- Using Case Statement Solves The Problem.\\nUPDATE SALARY\\nSET SEX =  CASE \\n                  WHEN SEX = \\'m\\' THEN \\'f\\'\\n                  WHEN SEX = \\'f\\'  THEN \\'m\\'\\n\\t\\t\\t\\t  END\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977767,
                "title": "627-swap-salary",
                "content": "```\\nupdate Salary\\n    set sex = (case when sex = \\'f\\' then \\'m\\' else \\'f\\' end)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nupdate Salary\\n    set sex = (case when sex = \\'f\\' then \\'m\\' else \\'f\\' end)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1968652,
                "title": "if",
                "content": "```\\nUPDATE Salary\\nSET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\')",
                "solutionTags": [],
                "code": "```\\nUPDATE Salary\\nSET sex = IF(sex = \\'m\\', \\'f\\', \\'m\\')",
                "codeTag": "Unknown"
            },
            {
                "id": 1963205,
                "title": "udpate-with-case-and-update-with-if-explanation",
                "content": "Firstly let\\'s get familiar with syntax of CASE the syntax is something like\\n\\n```\\nUPDATE Table1\\nSET Table1.COLUMN =\\n\\tCASE\\n\\tWHEN CONDITION1 AND CONDITION2 THEN SOMEVALUE1\\n\\tWHEN CONDITION3 OR CONDITION4 THEN SOMEVALUE2\\n\\tELSE SOMEDEFAULTVALUE\\n\\tEND \\n```\\n\\nIn our case we only have two conditions where sex = \"f\" and when sex = \"m\" also in our case we need to set the value\\nso our query is as follows\\n\\n```\\nupdate  Salary \\nset sex = (CASE when Salary.sex = \"f\" then \"m\" when sex=\"m\" then \"f\" END)\\n```\\n\\nThe other way is using IF  if works as follows if condition is true it will return value1 else it will return value2\\n\\nIF(CONDITION,VALUE1,VALUE2)\\n\\n```\\nupdate  Salary \\nset sex = (if(sex=\"m\",\"f\",\"m\"))\\n```\\n\\nOR\\n```\\nupdate  Salary \\nset sex = (if(sex=\"f\",\"m\",\"f\"))\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nUPDATE Table1\\nSET Table1.COLUMN =\\n\\tCASE\\n\\tWHEN CONDITION1 AND CONDITION2 THEN SOMEVALUE1\\n\\tWHEN CONDITION3 OR CONDITION4 THEN SOMEVALUE2\\n\\tELSE SOMEDEFAULTVALUE\\n\\tEND \\n```\n```\\nupdate  Salary \\nset sex = (CASE when Salary.sex = \"f\" then \"m\" when sex=\"m\" then \"f\" END)\\n```\n```\\nupdate  Salary \\nset sex = (if(sex=\"m\",\"f\",\"m\"))\\n```\n```\\nupdate  Salary \\nset sex = (if(sex=\"f\",\"m\",\"f\"))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1960004,
                "title": "easy-to-understand-sql",
                "content": "```\\n#case\\nupdate\\n    salary\\nset\\n    sex = (case when sex=\\'m\\' then \\'f\\' else \\'m\\' end);\\n\\t\\n#if\\nupdate\\n    salary\\nset\\n    sex = if(sex = \\'m\\', \\'f\\', \\'m\\');\\n```\\n\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Don\\'t Forget to **upvote**\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n#case\\nupdate\\n    salary\\nset\\n    sex = (case when sex=\\'m\\' then \\'f\\' else \\'m\\' end);\\n\\t\\n#if\\nupdate\\n    salary\\nset\\n    sex = if(sex = \\'m\\', \\'f\\', \\'m\\');\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1568777,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1565123,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1565976,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1566423,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1566713,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1570742,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1576764,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1566830,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1572498,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1570855,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1568777,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1565123,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1565976,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1566423,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1566713,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1570742,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1576764,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1566830,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1572498,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1570855,
                "content": [
                    {
                        "username": "Sasuke1267",
                        "content": "\\nupdate Salary \\nset sex =\\ncase \\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend \\n//make sure to upvote :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "do not post solutions here"
                    },
                    {
                        "username": "zhangzhizheng",
                        "content": "update salary set sex = CHAR(ASCII(\\'f\\') ^ ASCII(\\'m\\') ^ ASCII(sex));"
                    },
                    {
                        "username": "purplehat",
                        "content": "This problem ask for a single UPDATE function, so if you use \\nUPDATE and CASE, this should be the correct answer..\\n\\nHowever, if you you UPDATE statement, though the table was updated, the system won\\'t actual display the result.\\nYou will get Blank output and the system will mark your answer incorrect.\\n\\nSo you need to use SELECT + IF for submission to pass. SELECT statement will show an output. SO the system can compare.\\n\\nLeetcode should update this question. Otherwise it\\'s very confusing."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "postgres also mentions returning\\n```\\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\\n  WHERE city = \\'San Francisco\\' AND date = \\'2003-07-03\\'\\n  RETURNING temp_lo, temp_hi, prcp;\\n```"
                    },
                    {
                        "username": "gowthu_18",
                        "content": "I am getting the error even when I try to submit the approved solution. Is there a fix?"
                    },
                    {
                        "username": "prashantpatel0",
                        "content": "<h2>If you are getting this Error then dont worry and submit it.\\nIt will be accepted.<h2>"
                    },
                    {
                        "username": "oybekakramov",
                        "content": "UPDATE Salary SET sex=IIF(\\'m\\'=sex,\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "apetresc",
                        "content": "The only thing we\\'re swapping is sex. That\\'s just weird. Is this supposed to be some sort of pay gap joke or something?"
                    },
                    {
                        "username": "leetcode_zlq",
                        "content": "update salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "mishe1",
                        "content": "Look at this:\\n\\n![image](https://assets.leetcode.com/users/mishe1/image_1551723890.png)\\n\\n"
                    },
                    {
                        "username": "Archana154799",
                        "content": "update salary set sex = (if(sex=\\'m\\',\\'f\\',\\'m\\'))"
                    }
                ]
            },
            {
                "id": 1569390,
                "content": [
                    {
                        "username": "viva1119",
                        "content": "update salary\\nset sex = \\n     case when sex =\\'m\\' then \\'f\\'\\n      when sex =\\'f\\' then \\'m\\'\\n        else sex end;\\n"
                    },
                    {
                        "username": "lemonxixi",
                        "content": "UPDATE salary SET sex = IF(sex='m','f','m');"
                    },
                    {
                        "username": "tgreaton",
                        "content": "The issue with this problem is that you are not actually switching the salaries, the problem itself is flawed."
                    },
                    {
                        "username": "PunamShaw",
                        "content": "update salary set sex = CASE when sex ='m' then 'f' else 'm' end;"
                    },
                    {
                        "username": "leihua",
                        "content": "UPDATE salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "jnkjnkjnk",
                        "content": "This problem should be named Swap Sex instead of Swap Salary."
                    },
                    {
                        "username": "user4295gJ",
                        "content": "The structure of the table does not match the description, at least when MySQL syntax is used. \\nThe datatype of the column `sex` is specified as ENUM. In MySQL needed update can be performed by `SET sex = 3 - sex`. But this solution produces \"Wrong answer\", and the column value is set to \\'3\\' which claims that the column datatype is of some CHAR datatype in practice. \\nSee fiddle: https://dbfiddle.uk/v4Vh7HdK\\nMust be fixed."
                    },
                    {
                        "username": "dastankg",
                        "content": "\\tUPDATE Salary SET sex = IF(sex = \\'f\\', \\'m\\', \\'f\\');"
                    },
                    {
                        "username": "vinita645",
                        "content": "\\tUPDATE Salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "pk80103",
                        "content": "\\'\\'\\'\\nUPDATE Salary\\nSET sex = \\nCASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' \\nEND\\n\\nUPDATE Salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569184,
                "content": [
                    {
                        "username": "viva1119",
                        "content": "update salary\\nset sex = \\n     case when sex =\\'m\\' then \\'f\\'\\n      when sex =\\'f\\' then \\'m\\'\\n        else sex end;\\n"
                    },
                    {
                        "username": "lemonxixi",
                        "content": "UPDATE salary SET sex = IF(sex='m','f','m');"
                    },
                    {
                        "username": "tgreaton",
                        "content": "The issue with this problem is that you are not actually switching the salaries, the problem itself is flawed."
                    },
                    {
                        "username": "PunamShaw",
                        "content": "update salary set sex = CASE when sex ='m' then 'f' else 'm' end;"
                    },
                    {
                        "username": "leihua",
                        "content": "UPDATE salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "jnkjnkjnk",
                        "content": "This problem should be named Swap Sex instead of Swap Salary."
                    },
                    {
                        "username": "user4295gJ",
                        "content": "The structure of the table does not match the description, at least when MySQL syntax is used. \\nThe datatype of the column `sex` is specified as ENUM. In MySQL needed update can be performed by `SET sex = 3 - sex`. But this solution produces \"Wrong answer\", and the column value is set to \\'3\\' which claims that the column datatype is of some CHAR datatype in practice. \\nSee fiddle: https://dbfiddle.uk/v4Vh7HdK\\nMust be fixed."
                    },
                    {
                        "username": "dastankg",
                        "content": "\\tUPDATE Salary SET sex = IF(sex = \\'f\\', \\'m\\', \\'f\\');"
                    },
                    {
                        "username": "vinita645",
                        "content": "\\tUPDATE Salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "pk80103",
                        "content": "\\'\\'\\'\\nUPDATE Salary\\nSET sex = \\nCASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' \\nEND\\n\\nUPDATE Salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569141,
                "content": [
                    {
                        "username": "viva1119",
                        "content": "update salary\\nset sex = \\n     case when sex =\\'m\\' then \\'f\\'\\n      when sex =\\'f\\' then \\'m\\'\\n        else sex end;\\n"
                    },
                    {
                        "username": "lemonxixi",
                        "content": "UPDATE salary SET sex = IF(sex='m','f','m');"
                    },
                    {
                        "username": "tgreaton",
                        "content": "The issue with this problem is that you are not actually switching the salaries, the problem itself is flawed."
                    },
                    {
                        "username": "PunamShaw",
                        "content": "update salary set sex = CASE when sex ='m' then 'f' else 'm' end;"
                    },
                    {
                        "username": "leihua",
                        "content": "UPDATE salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "jnkjnkjnk",
                        "content": "This problem should be named Swap Sex instead of Swap Salary."
                    },
                    {
                        "username": "user4295gJ",
                        "content": "The structure of the table does not match the description, at least when MySQL syntax is used. \\nThe datatype of the column `sex` is specified as ENUM. In MySQL needed update can be performed by `SET sex = 3 - sex`. But this solution produces \"Wrong answer\", and the column value is set to \\'3\\' which claims that the column datatype is of some CHAR datatype in practice. \\nSee fiddle: https://dbfiddle.uk/v4Vh7HdK\\nMust be fixed."
                    },
                    {
                        "username": "dastankg",
                        "content": "\\tUPDATE Salary SET sex = IF(sex = \\'f\\', \\'m\\', \\'f\\');"
                    },
                    {
                        "username": "vinita645",
                        "content": "\\tUPDATE Salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "pk80103",
                        "content": "\\'\\'\\'\\nUPDATE Salary\\nSET sex = \\nCASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' \\nEND\\n\\nUPDATE Salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569142,
                "content": [
                    {
                        "username": "viva1119",
                        "content": "update salary\\nset sex = \\n     case when sex =\\'m\\' then \\'f\\'\\n      when sex =\\'f\\' then \\'m\\'\\n        else sex end;\\n"
                    },
                    {
                        "username": "lemonxixi",
                        "content": "UPDATE salary SET sex = IF(sex='m','f','m');"
                    },
                    {
                        "username": "tgreaton",
                        "content": "The issue with this problem is that you are not actually switching the salaries, the problem itself is flawed."
                    },
                    {
                        "username": "PunamShaw",
                        "content": "update salary set sex = CASE when sex ='m' then 'f' else 'm' end;"
                    },
                    {
                        "username": "leihua",
                        "content": "UPDATE salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "jnkjnkjnk",
                        "content": "This problem should be named Swap Sex instead of Swap Salary."
                    },
                    {
                        "username": "user4295gJ",
                        "content": "The structure of the table does not match the description, at least when MySQL syntax is used. \\nThe datatype of the column `sex` is specified as ENUM. In MySQL needed update can be performed by `SET sex = 3 - sex`. But this solution produces \"Wrong answer\", and the column value is set to \\'3\\' which claims that the column datatype is of some CHAR datatype in practice. \\nSee fiddle: https://dbfiddle.uk/v4Vh7HdK\\nMust be fixed."
                    },
                    {
                        "username": "dastankg",
                        "content": "\\tUPDATE Salary SET sex = IF(sex = \\'f\\', \\'m\\', \\'f\\');"
                    },
                    {
                        "username": "vinita645",
                        "content": "\\tUPDATE Salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "pk80103",
                        "content": "\\'\\'\\'\\nUPDATE Salary\\nSET sex = \\nCASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' \\nEND\\n\\nUPDATE Salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1567551,
                "content": [
                    {
                        "username": "viva1119",
                        "content": "update salary\\nset sex = \\n     case when sex =\\'m\\' then \\'f\\'\\n      when sex =\\'f\\' then \\'m\\'\\n        else sex end;\\n"
                    },
                    {
                        "username": "lemonxixi",
                        "content": "UPDATE salary SET sex = IF(sex='m','f','m');"
                    },
                    {
                        "username": "tgreaton",
                        "content": "The issue with this problem is that you are not actually switching the salaries, the problem itself is flawed."
                    },
                    {
                        "username": "PunamShaw",
                        "content": "update salary set sex = CASE when sex ='m' then 'f' else 'm' end;"
                    },
                    {
                        "username": "leihua",
                        "content": "UPDATE salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "jnkjnkjnk",
                        "content": "This problem should be named Swap Sex instead of Swap Salary."
                    },
                    {
                        "username": "user4295gJ",
                        "content": "The structure of the table does not match the description, at least when MySQL syntax is used. \\nThe datatype of the column `sex` is specified as ENUM. In MySQL needed update can be performed by `SET sex = 3 - sex`. But this solution produces \"Wrong answer\", and the column value is set to \\'3\\' which claims that the column datatype is of some CHAR datatype in practice. \\nSee fiddle: https://dbfiddle.uk/v4Vh7HdK\\nMust be fixed."
                    },
                    {
                        "username": "dastankg",
                        "content": "\\tUPDATE Salary SET sex = IF(sex = \\'f\\', \\'m\\', \\'f\\');"
                    },
                    {
                        "username": "vinita645",
                        "content": "\\tUPDATE Salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "pk80103",
                        "content": "\\'\\'\\'\\nUPDATE Salary\\nSET sex = \\nCASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' \\nEND\\n\\nUPDATE Salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1790274,
                "content": [
                    {
                        "username": "viva1119",
                        "content": "update salary\\nset sex = \\n     case when sex =\\'m\\' then \\'f\\'\\n      when sex =\\'f\\' then \\'m\\'\\n        else sex end;\\n"
                    },
                    {
                        "username": "lemonxixi",
                        "content": "UPDATE salary SET sex = IF(sex='m','f','m');"
                    },
                    {
                        "username": "tgreaton",
                        "content": "The issue with this problem is that you are not actually switching the salaries, the problem itself is flawed."
                    },
                    {
                        "username": "PunamShaw",
                        "content": "update salary set sex = CASE when sex ='m' then 'f' else 'm' end;"
                    },
                    {
                        "username": "leihua",
                        "content": "UPDATE salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "jnkjnkjnk",
                        "content": "This problem should be named Swap Sex instead of Swap Salary."
                    },
                    {
                        "username": "user4295gJ",
                        "content": "The structure of the table does not match the description, at least when MySQL syntax is used. \\nThe datatype of the column `sex` is specified as ENUM. In MySQL needed update can be performed by `SET sex = 3 - sex`. But this solution produces \"Wrong answer\", and the column value is set to \\'3\\' which claims that the column datatype is of some CHAR datatype in practice. \\nSee fiddle: https://dbfiddle.uk/v4Vh7HdK\\nMust be fixed."
                    },
                    {
                        "username": "dastankg",
                        "content": "\\tUPDATE Salary SET sex = IF(sex = \\'f\\', \\'m\\', \\'f\\');"
                    },
                    {
                        "username": "vinita645",
                        "content": "\\tUPDATE Salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "pk80103",
                        "content": "\\'\\'\\'\\nUPDATE Salary\\nSET sex = \\nCASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' \\nEND\\n\\nUPDATE Salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1734043,
                "content": [
                    {
                        "username": "viva1119",
                        "content": "update salary\\nset sex = \\n     case when sex =\\'m\\' then \\'f\\'\\n      when sex =\\'f\\' then \\'m\\'\\n        else sex end;\\n"
                    },
                    {
                        "username": "lemonxixi",
                        "content": "UPDATE salary SET sex = IF(sex='m','f','m');"
                    },
                    {
                        "username": "tgreaton",
                        "content": "The issue with this problem is that you are not actually switching the salaries, the problem itself is flawed."
                    },
                    {
                        "username": "PunamShaw",
                        "content": "update salary set sex = CASE when sex ='m' then 'f' else 'm' end;"
                    },
                    {
                        "username": "leihua",
                        "content": "UPDATE salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "jnkjnkjnk",
                        "content": "This problem should be named Swap Sex instead of Swap Salary."
                    },
                    {
                        "username": "user4295gJ",
                        "content": "The structure of the table does not match the description, at least when MySQL syntax is used. \\nThe datatype of the column `sex` is specified as ENUM. In MySQL needed update can be performed by `SET sex = 3 - sex`. But this solution produces \"Wrong answer\", and the column value is set to \\'3\\' which claims that the column datatype is of some CHAR datatype in practice. \\nSee fiddle: https://dbfiddle.uk/v4Vh7HdK\\nMust be fixed."
                    },
                    {
                        "username": "dastankg",
                        "content": "\\tUPDATE Salary SET sex = IF(sex = \\'f\\', \\'m\\', \\'f\\');"
                    },
                    {
                        "username": "vinita645",
                        "content": "\\tUPDATE Salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "pk80103",
                        "content": "\\'\\'\\'\\nUPDATE Salary\\nSET sex = \\nCASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' \\nEND\\n\\nUPDATE Salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576994,
                "content": [
                    {
                        "username": "viva1119",
                        "content": "update salary\\nset sex = \\n     case when sex =\\'m\\' then \\'f\\'\\n      when sex =\\'f\\' then \\'m\\'\\n        else sex end;\\n"
                    },
                    {
                        "username": "lemonxixi",
                        "content": "UPDATE salary SET sex = IF(sex='m','f','m');"
                    },
                    {
                        "username": "tgreaton",
                        "content": "The issue with this problem is that you are not actually switching the salaries, the problem itself is flawed."
                    },
                    {
                        "username": "PunamShaw",
                        "content": "update salary set sex = CASE when sex ='m' then 'f' else 'm' end;"
                    },
                    {
                        "username": "leihua",
                        "content": "UPDATE salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "jnkjnkjnk",
                        "content": "This problem should be named Swap Sex instead of Swap Salary."
                    },
                    {
                        "username": "user4295gJ",
                        "content": "The structure of the table does not match the description, at least when MySQL syntax is used. \\nThe datatype of the column `sex` is specified as ENUM. In MySQL needed update can be performed by `SET sex = 3 - sex`. But this solution produces \"Wrong answer\", and the column value is set to \\'3\\' which claims that the column datatype is of some CHAR datatype in practice. \\nSee fiddle: https://dbfiddle.uk/v4Vh7HdK\\nMust be fixed."
                    },
                    {
                        "username": "dastankg",
                        "content": "\\tUPDATE Salary SET sex = IF(sex = \\'f\\', \\'m\\', \\'f\\');"
                    },
                    {
                        "username": "vinita645",
                        "content": "\\tUPDATE Salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "pk80103",
                        "content": "\\'\\'\\'\\nUPDATE Salary\\nSET sex = \\nCASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' \\nEND\\n\\nUPDATE Salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576961,
                "content": [
                    {
                        "username": "viva1119",
                        "content": "update salary\\nset sex = \\n     case when sex =\\'m\\' then \\'f\\'\\n      when sex =\\'f\\' then \\'m\\'\\n        else sex end;\\n"
                    },
                    {
                        "username": "lemonxixi",
                        "content": "UPDATE salary SET sex = IF(sex='m','f','m');"
                    },
                    {
                        "username": "tgreaton",
                        "content": "The issue with this problem is that you are not actually switching the salaries, the problem itself is flawed."
                    },
                    {
                        "username": "PunamShaw",
                        "content": "update salary set sex = CASE when sex ='m' then 'f' else 'm' end;"
                    },
                    {
                        "username": "leihua",
                        "content": "UPDATE salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "jnkjnkjnk",
                        "content": "This problem should be named Swap Sex instead of Swap Salary."
                    },
                    {
                        "username": "user4295gJ",
                        "content": "The structure of the table does not match the description, at least when MySQL syntax is used. \\nThe datatype of the column `sex` is specified as ENUM. In MySQL needed update can be performed by `SET sex = 3 - sex`. But this solution produces \"Wrong answer\", and the column value is set to \\'3\\' which claims that the column datatype is of some CHAR datatype in practice. \\nSee fiddle: https://dbfiddle.uk/v4Vh7HdK\\nMust be fixed."
                    },
                    {
                        "username": "dastankg",
                        "content": "\\tUPDATE Salary SET sex = IF(sex = \\'f\\', \\'m\\', \\'f\\');"
                    },
                    {
                        "username": "vinita645",
                        "content": "\\tUPDATE Salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "pk80103",
                        "content": "\\'\\'\\'\\nUPDATE Salary\\nSET sex = \\nCASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' \\nEND\\n\\nUPDATE Salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576773,
                "content": [
                    {
                        "username": "viva1119",
                        "content": "update salary\\nset sex = \\n     case when sex =\\'m\\' then \\'f\\'\\n      when sex =\\'f\\' then \\'m\\'\\n        else sex end;\\n"
                    },
                    {
                        "username": "lemonxixi",
                        "content": "UPDATE salary SET sex = IF(sex='m','f','m');"
                    },
                    {
                        "username": "tgreaton",
                        "content": "The issue with this problem is that you are not actually switching the salaries, the problem itself is flawed."
                    },
                    {
                        "username": "PunamShaw",
                        "content": "update salary set sex = CASE when sex ='m' then 'f' else 'm' end;"
                    },
                    {
                        "username": "leihua",
                        "content": "UPDATE salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "jnkjnkjnk",
                        "content": "This problem should be named Swap Sex instead of Swap Salary."
                    },
                    {
                        "username": "user4295gJ",
                        "content": "The structure of the table does not match the description, at least when MySQL syntax is used. \\nThe datatype of the column `sex` is specified as ENUM. In MySQL needed update can be performed by `SET sex = 3 - sex`. But this solution produces \"Wrong answer\", and the column value is set to \\'3\\' which claims that the column datatype is of some CHAR datatype in practice. \\nSee fiddle: https://dbfiddle.uk/v4Vh7HdK\\nMust be fixed."
                    },
                    {
                        "username": "dastankg",
                        "content": "\\tUPDATE Salary SET sex = IF(sex = \\'f\\', \\'m\\', \\'f\\');"
                    },
                    {
                        "username": "vinita645",
                        "content": "\\tUPDATE Salary set sex=if(sex=\\'f\\',\\'m\\',\\'f\\')"
                    },
                    {
                        "username": "pk80103",
                        "content": "\\'\\'\\'\\nUPDATE Salary\\nSET sex = \\nCASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' \\nEND\\n\\nUPDATE Salary\\nSET sex = IF(sex = \\'m\\',\\'f\\',\\'m\\')\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576693,
                "content": [
                    {
                        "username": "parmitkr",
                        "content": "Update Salary set sex = \\ncase \\n    when sex = \\'m\\' then \\'f\\'\\n    when sex = \\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "mandilrinky",
                        "content": "\\'\\'\\'\\nUpdate Salary set sex = case when sex = \\'m\\' then \\'f\\'\\nwhen sex = \\'f\\' then \\'m\\'\\nelse \\'\\'\\nend\\n\\'\\'\\'"
                    },
                    {
                        "username": "vishnuthogulu",
                        "content": "update Salary  \\nset sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "Ankitkumar_2022",
                        "content": "/* Write your T-SQL query statement below */\\n\\nUPDATE Salary\\nSET \\nsex = CASE WHEN sex = \\'f\\' THEN \\'m\\' ELSE \\'f\\' END"
                    },
                    {
                        "username": "sahabudin",
                        "content": "update Salary\\n\\nset sex =case when sex=\\'m\\' then \\'f\\'\\n              when sex=\\'f\\' then \\'m\\'\\n         end\\nwhere sex in (\\'m\\',\\'f\\');"
                    },
                    {
                        "username": "vishrut444",
                        "content": "**# Write your MySQL query statement below**\\nUPDATE Salary SET sex = (CASE WHEN sex =\\'m\\' THEN \\'f\\'\\n                              WHEN sex = \\'f\\' THEN \\'m\\' \\n                              END );"
                    },
                    {
                        "username": "trwavx",
                        "content": "update Salary\\nset sex = case sex\\n    when \\'m\\' then \\'f\\'\\n    else \\'m\\'\\nend\\n"
                    },
                    {
                        "username": "ora_dev",
                        "content": "UPDATE Salary\\nSET SEX = DECODE(SEX,\\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "update Salary set sex= case sex when \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\nupdate Salary\\n\\nset sex=if(strcmp(sex,\\'m\\')=0, \\'f\\',\\'m\\');\\n\\n\\nHOW IF WORKS \\nIF( CONDITION ,IF_TRUE, IF_FASLE );"
                    }
                ]
            },
            {
                "id": 1576689,
                "content": [
                    {
                        "username": "parmitkr",
                        "content": "Update Salary set sex = \\ncase \\n    when sex = \\'m\\' then \\'f\\'\\n    when sex = \\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "mandilrinky",
                        "content": "\\'\\'\\'\\nUpdate Salary set sex = case when sex = \\'m\\' then \\'f\\'\\nwhen sex = \\'f\\' then \\'m\\'\\nelse \\'\\'\\nend\\n\\'\\'\\'"
                    },
                    {
                        "username": "vishnuthogulu",
                        "content": "update Salary  \\nset sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "Ankitkumar_2022",
                        "content": "/* Write your T-SQL query statement below */\\n\\nUPDATE Salary\\nSET \\nsex = CASE WHEN sex = \\'f\\' THEN \\'m\\' ELSE \\'f\\' END"
                    },
                    {
                        "username": "sahabudin",
                        "content": "update Salary\\n\\nset sex =case when sex=\\'m\\' then \\'f\\'\\n              when sex=\\'f\\' then \\'m\\'\\n         end\\nwhere sex in (\\'m\\',\\'f\\');"
                    },
                    {
                        "username": "vishrut444",
                        "content": "**# Write your MySQL query statement below**\\nUPDATE Salary SET sex = (CASE WHEN sex =\\'m\\' THEN \\'f\\'\\n                              WHEN sex = \\'f\\' THEN \\'m\\' \\n                              END );"
                    },
                    {
                        "username": "trwavx",
                        "content": "update Salary\\nset sex = case sex\\n    when \\'m\\' then \\'f\\'\\n    else \\'m\\'\\nend\\n"
                    },
                    {
                        "username": "ora_dev",
                        "content": "UPDATE Salary\\nSET SEX = DECODE(SEX,\\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "update Salary set sex= case sex when \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\nupdate Salary\\n\\nset sex=if(strcmp(sex,\\'m\\')=0, \\'f\\',\\'m\\');\\n\\n\\nHOW IF WORKS \\nIF( CONDITION ,IF_TRUE, IF_FASLE );"
                    }
                ]
            },
            {
                "id": 1576687,
                "content": [
                    {
                        "username": "parmitkr",
                        "content": "Update Salary set sex = \\ncase \\n    when sex = \\'m\\' then \\'f\\'\\n    when sex = \\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "mandilrinky",
                        "content": "\\'\\'\\'\\nUpdate Salary set sex = case when sex = \\'m\\' then \\'f\\'\\nwhen sex = \\'f\\' then \\'m\\'\\nelse \\'\\'\\nend\\n\\'\\'\\'"
                    },
                    {
                        "username": "vishnuthogulu",
                        "content": "update Salary  \\nset sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "Ankitkumar_2022",
                        "content": "/* Write your T-SQL query statement below */\\n\\nUPDATE Salary\\nSET \\nsex = CASE WHEN sex = \\'f\\' THEN \\'m\\' ELSE \\'f\\' END"
                    },
                    {
                        "username": "sahabudin",
                        "content": "update Salary\\n\\nset sex =case when sex=\\'m\\' then \\'f\\'\\n              when sex=\\'f\\' then \\'m\\'\\n         end\\nwhere sex in (\\'m\\',\\'f\\');"
                    },
                    {
                        "username": "vishrut444",
                        "content": "**# Write your MySQL query statement below**\\nUPDATE Salary SET sex = (CASE WHEN sex =\\'m\\' THEN \\'f\\'\\n                              WHEN sex = \\'f\\' THEN \\'m\\' \\n                              END );"
                    },
                    {
                        "username": "trwavx",
                        "content": "update Salary\\nset sex = case sex\\n    when \\'m\\' then \\'f\\'\\n    else \\'m\\'\\nend\\n"
                    },
                    {
                        "username": "ora_dev",
                        "content": "UPDATE Salary\\nSET SEX = DECODE(SEX,\\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "update Salary set sex= case sex when \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\nupdate Salary\\n\\nset sex=if(strcmp(sex,\\'m\\')=0, \\'f\\',\\'m\\');\\n\\n\\nHOW IF WORKS \\nIF( CONDITION ,IF_TRUE, IF_FASLE );"
                    }
                ]
            },
            {
                "id": 1576668,
                "content": [
                    {
                        "username": "parmitkr",
                        "content": "Update Salary set sex = \\ncase \\n    when sex = \\'m\\' then \\'f\\'\\n    when sex = \\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "mandilrinky",
                        "content": "\\'\\'\\'\\nUpdate Salary set sex = case when sex = \\'m\\' then \\'f\\'\\nwhen sex = \\'f\\' then \\'m\\'\\nelse \\'\\'\\nend\\n\\'\\'\\'"
                    },
                    {
                        "username": "vishnuthogulu",
                        "content": "update Salary  \\nset sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "Ankitkumar_2022",
                        "content": "/* Write your T-SQL query statement below */\\n\\nUPDATE Salary\\nSET \\nsex = CASE WHEN sex = \\'f\\' THEN \\'m\\' ELSE \\'f\\' END"
                    },
                    {
                        "username": "sahabudin",
                        "content": "update Salary\\n\\nset sex =case when sex=\\'m\\' then \\'f\\'\\n              when sex=\\'f\\' then \\'m\\'\\n         end\\nwhere sex in (\\'m\\',\\'f\\');"
                    },
                    {
                        "username": "vishrut444",
                        "content": "**# Write your MySQL query statement below**\\nUPDATE Salary SET sex = (CASE WHEN sex =\\'m\\' THEN \\'f\\'\\n                              WHEN sex = \\'f\\' THEN \\'m\\' \\n                              END );"
                    },
                    {
                        "username": "trwavx",
                        "content": "update Salary\\nset sex = case sex\\n    when \\'m\\' then \\'f\\'\\n    else \\'m\\'\\nend\\n"
                    },
                    {
                        "username": "ora_dev",
                        "content": "UPDATE Salary\\nSET SEX = DECODE(SEX,\\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "update Salary set sex= case sex when \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\nupdate Salary\\n\\nset sex=if(strcmp(sex,\\'m\\')=0, \\'f\\',\\'m\\');\\n\\n\\nHOW IF WORKS \\nIF( CONDITION ,IF_TRUE, IF_FASLE );"
                    }
                ]
            },
            {
                "id": 1576641,
                "content": [
                    {
                        "username": "parmitkr",
                        "content": "Update Salary set sex = \\ncase \\n    when sex = \\'m\\' then \\'f\\'\\n    when sex = \\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "mandilrinky",
                        "content": "\\'\\'\\'\\nUpdate Salary set sex = case when sex = \\'m\\' then \\'f\\'\\nwhen sex = \\'f\\' then \\'m\\'\\nelse \\'\\'\\nend\\n\\'\\'\\'"
                    },
                    {
                        "username": "vishnuthogulu",
                        "content": "update Salary  \\nset sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "Ankitkumar_2022",
                        "content": "/* Write your T-SQL query statement below */\\n\\nUPDATE Salary\\nSET \\nsex = CASE WHEN sex = \\'f\\' THEN \\'m\\' ELSE \\'f\\' END"
                    },
                    {
                        "username": "sahabudin",
                        "content": "update Salary\\n\\nset sex =case when sex=\\'m\\' then \\'f\\'\\n              when sex=\\'f\\' then \\'m\\'\\n         end\\nwhere sex in (\\'m\\',\\'f\\');"
                    },
                    {
                        "username": "vishrut444",
                        "content": "**# Write your MySQL query statement below**\\nUPDATE Salary SET sex = (CASE WHEN sex =\\'m\\' THEN \\'f\\'\\n                              WHEN sex = \\'f\\' THEN \\'m\\' \\n                              END );"
                    },
                    {
                        "username": "trwavx",
                        "content": "update Salary\\nset sex = case sex\\n    when \\'m\\' then \\'f\\'\\n    else \\'m\\'\\nend\\n"
                    },
                    {
                        "username": "ora_dev",
                        "content": "UPDATE Salary\\nSET SEX = DECODE(SEX,\\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "update Salary set sex= case sex when \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\nupdate Salary\\n\\nset sex=if(strcmp(sex,\\'m\\')=0, \\'f\\',\\'m\\');\\n\\n\\nHOW IF WORKS \\nIF( CONDITION ,IF_TRUE, IF_FASLE );"
                    }
                ]
            },
            {
                "id": 1576637,
                "content": [
                    {
                        "username": "parmitkr",
                        "content": "Update Salary set sex = \\ncase \\n    when sex = \\'m\\' then \\'f\\'\\n    when sex = \\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "mandilrinky",
                        "content": "\\'\\'\\'\\nUpdate Salary set sex = case when sex = \\'m\\' then \\'f\\'\\nwhen sex = \\'f\\' then \\'m\\'\\nelse \\'\\'\\nend\\n\\'\\'\\'"
                    },
                    {
                        "username": "vishnuthogulu",
                        "content": "update Salary  \\nset sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "Ankitkumar_2022",
                        "content": "/* Write your T-SQL query statement below */\\n\\nUPDATE Salary\\nSET \\nsex = CASE WHEN sex = \\'f\\' THEN \\'m\\' ELSE \\'f\\' END"
                    },
                    {
                        "username": "sahabudin",
                        "content": "update Salary\\n\\nset sex =case when sex=\\'m\\' then \\'f\\'\\n              when sex=\\'f\\' then \\'m\\'\\n         end\\nwhere sex in (\\'m\\',\\'f\\');"
                    },
                    {
                        "username": "vishrut444",
                        "content": "**# Write your MySQL query statement below**\\nUPDATE Salary SET sex = (CASE WHEN sex =\\'m\\' THEN \\'f\\'\\n                              WHEN sex = \\'f\\' THEN \\'m\\' \\n                              END );"
                    },
                    {
                        "username": "trwavx",
                        "content": "update Salary\\nset sex = case sex\\n    when \\'m\\' then \\'f\\'\\n    else \\'m\\'\\nend\\n"
                    },
                    {
                        "username": "ora_dev",
                        "content": "UPDATE Salary\\nSET SEX = DECODE(SEX,\\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "update Salary set sex= case sex when \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\nupdate Salary\\n\\nset sex=if(strcmp(sex,\\'m\\')=0, \\'f\\',\\'m\\');\\n\\n\\nHOW IF WORKS \\nIF( CONDITION ,IF_TRUE, IF_FASLE );"
                    }
                ]
            },
            {
                "id": 1575752,
                "content": [
                    {
                        "username": "parmitkr",
                        "content": "Update Salary set sex = \\ncase \\n    when sex = \\'m\\' then \\'f\\'\\n    when sex = \\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "mandilrinky",
                        "content": "\\'\\'\\'\\nUpdate Salary set sex = case when sex = \\'m\\' then \\'f\\'\\nwhen sex = \\'f\\' then \\'m\\'\\nelse \\'\\'\\nend\\n\\'\\'\\'"
                    },
                    {
                        "username": "vishnuthogulu",
                        "content": "update Salary  \\nset sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "Ankitkumar_2022",
                        "content": "/* Write your T-SQL query statement below */\\n\\nUPDATE Salary\\nSET \\nsex = CASE WHEN sex = \\'f\\' THEN \\'m\\' ELSE \\'f\\' END"
                    },
                    {
                        "username": "sahabudin",
                        "content": "update Salary\\n\\nset sex =case when sex=\\'m\\' then \\'f\\'\\n              when sex=\\'f\\' then \\'m\\'\\n         end\\nwhere sex in (\\'m\\',\\'f\\');"
                    },
                    {
                        "username": "vishrut444",
                        "content": "**# Write your MySQL query statement below**\\nUPDATE Salary SET sex = (CASE WHEN sex =\\'m\\' THEN \\'f\\'\\n                              WHEN sex = \\'f\\' THEN \\'m\\' \\n                              END );"
                    },
                    {
                        "username": "trwavx",
                        "content": "update Salary\\nset sex = case sex\\n    when \\'m\\' then \\'f\\'\\n    else \\'m\\'\\nend\\n"
                    },
                    {
                        "username": "ora_dev",
                        "content": "UPDATE Salary\\nSET SEX = DECODE(SEX,\\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "update Salary set sex= case sex when \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\nupdate Salary\\n\\nset sex=if(strcmp(sex,\\'m\\')=0, \\'f\\',\\'m\\');\\n\\n\\nHOW IF WORKS \\nIF( CONDITION ,IF_TRUE, IF_FASLE );"
                    }
                ]
            },
            {
                "id": 1575606,
                "content": [
                    {
                        "username": "parmitkr",
                        "content": "Update Salary set sex = \\ncase \\n    when sex = \\'m\\' then \\'f\\'\\n    when sex = \\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "mandilrinky",
                        "content": "\\'\\'\\'\\nUpdate Salary set sex = case when sex = \\'m\\' then \\'f\\'\\nwhen sex = \\'f\\' then \\'m\\'\\nelse \\'\\'\\nend\\n\\'\\'\\'"
                    },
                    {
                        "username": "vishnuthogulu",
                        "content": "update Salary  \\nset sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "Ankitkumar_2022",
                        "content": "/* Write your T-SQL query statement below */\\n\\nUPDATE Salary\\nSET \\nsex = CASE WHEN sex = \\'f\\' THEN \\'m\\' ELSE \\'f\\' END"
                    },
                    {
                        "username": "sahabudin",
                        "content": "update Salary\\n\\nset sex =case when sex=\\'m\\' then \\'f\\'\\n              when sex=\\'f\\' then \\'m\\'\\n         end\\nwhere sex in (\\'m\\',\\'f\\');"
                    },
                    {
                        "username": "vishrut444",
                        "content": "**# Write your MySQL query statement below**\\nUPDATE Salary SET sex = (CASE WHEN sex =\\'m\\' THEN \\'f\\'\\n                              WHEN sex = \\'f\\' THEN \\'m\\' \\n                              END );"
                    },
                    {
                        "username": "trwavx",
                        "content": "update Salary\\nset sex = case sex\\n    when \\'m\\' then \\'f\\'\\n    else \\'m\\'\\nend\\n"
                    },
                    {
                        "username": "ora_dev",
                        "content": "UPDATE Salary\\nSET SEX = DECODE(SEX,\\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "update Salary set sex= case sex when \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\nupdate Salary\\n\\nset sex=if(strcmp(sex,\\'m\\')=0, \\'f\\',\\'m\\');\\n\\n\\nHOW IF WORKS \\nIF( CONDITION ,IF_TRUE, IF_FASLE );"
                    }
                ]
            },
            {
                "id": 1575590,
                "content": [
                    {
                        "username": "parmitkr",
                        "content": "Update Salary set sex = \\ncase \\n    when sex = \\'m\\' then \\'f\\'\\n    when sex = \\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "mandilrinky",
                        "content": "\\'\\'\\'\\nUpdate Salary set sex = case when sex = \\'m\\' then \\'f\\'\\nwhen sex = \\'f\\' then \\'m\\'\\nelse \\'\\'\\nend\\n\\'\\'\\'"
                    },
                    {
                        "username": "vishnuthogulu",
                        "content": "update Salary  \\nset sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "Ankitkumar_2022",
                        "content": "/* Write your T-SQL query statement below */\\n\\nUPDATE Salary\\nSET \\nsex = CASE WHEN sex = \\'f\\' THEN \\'m\\' ELSE \\'f\\' END"
                    },
                    {
                        "username": "sahabudin",
                        "content": "update Salary\\n\\nset sex =case when sex=\\'m\\' then \\'f\\'\\n              when sex=\\'f\\' then \\'m\\'\\n         end\\nwhere sex in (\\'m\\',\\'f\\');"
                    },
                    {
                        "username": "vishrut444",
                        "content": "**# Write your MySQL query statement below**\\nUPDATE Salary SET sex = (CASE WHEN sex =\\'m\\' THEN \\'f\\'\\n                              WHEN sex = \\'f\\' THEN \\'m\\' \\n                              END );"
                    },
                    {
                        "username": "trwavx",
                        "content": "update Salary\\nset sex = case sex\\n    when \\'m\\' then \\'f\\'\\n    else \\'m\\'\\nend\\n"
                    },
                    {
                        "username": "ora_dev",
                        "content": "UPDATE Salary\\nSET SEX = DECODE(SEX,\\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "update Salary set sex= case sex when \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\nupdate Salary\\n\\nset sex=if(strcmp(sex,\\'m\\')=0, \\'f\\',\\'m\\');\\n\\n\\nHOW IF WORKS \\nIF( CONDITION ,IF_TRUE, IF_FASLE );"
                    }
                ]
            },
            {
                "id": 1575520,
                "content": [
                    {
                        "username": "parmitkr",
                        "content": "Update Salary set sex = \\ncase \\n    when sex = \\'m\\' then \\'f\\'\\n    when sex = \\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "mandilrinky",
                        "content": "\\'\\'\\'\\nUpdate Salary set sex = case when sex = \\'m\\' then \\'f\\'\\nwhen sex = \\'f\\' then \\'m\\'\\nelse \\'\\'\\nend\\n\\'\\'\\'"
                    },
                    {
                        "username": "vishnuthogulu",
                        "content": "update Salary  \\nset sex = case when sex = \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "Ankitkumar_2022",
                        "content": "/* Write your T-SQL query statement below */\\n\\nUPDATE Salary\\nSET \\nsex = CASE WHEN sex = \\'f\\' THEN \\'m\\' ELSE \\'f\\' END"
                    },
                    {
                        "username": "sahabudin",
                        "content": "update Salary\\n\\nset sex =case when sex=\\'m\\' then \\'f\\'\\n              when sex=\\'f\\' then \\'m\\'\\n         end\\nwhere sex in (\\'m\\',\\'f\\');"
                    },
                    {
                        "username": "vishrut444",
                        "content": "**# Write your MySQL query statement below**\\nUPDATE Salary SET sex = (CASE WHEN sex =\\'m\\' THEN \\'f\\'\\n                              WHEN sex = \\'f\\' THEN \\'m\\' \\n                              END );"
                    },
                    {
                        "username": "trwavx",
                        "content": "update Salary\\nset sex = case sex\\n    when \\'m\\' then \\'f\\'\\n    else \\'m\\'\\nend\\n"
                    },
                    {
                        "username": "ora_dev",
                        "content": "UPDATE Salary\\nSET SEX = DECODE(SEX,\\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "update Salary set sex= case sex when \\'m\\' then \\'f\\' else \\'m\\' end"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\nupdate Salary\\n\\nset sex=if(strcmp(sex,\\'m\\')=0, \\'f\\',\\'m\\');\\n\\n\\nHOW IF WORKS \\nIF( CONDITION ,IF_TRUE, IF_FASLE );"
                    }
                ]
            },
            {
                "id": 1573502,
                "content": [
                    {
                        "username": "augustgirl",
                        "content": "UPDATE salary\\nSET \\nsex = IF(sex = \\'m\\', \\'f\\', \\'m\\');"
                    },
                    {
                        "username": "KarunaMeena",
                        "content": "\\'\\'\\'\\n    \\nUPDATE salary\\nSET sex= CASE\\n   WHEN sex=\\'m\\' THEN \\'f\\'\\n   WHEN sex=\\'f\\' THEN \\'m\\'\\nEND\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "qweruiop316",
                        "content": "\\nSubmit this SQL but get runtime error\\n\\tUPDATE salary SET sex = (CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END)\\n\\t\\nAnd get accept with SQL below\\n\\tSELECT ID,NAME,CASE WHEN SEX=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END SEX, SALARY FROM SALARY"
                    },
                    {
                        "username": "alixkevin",
                        "content": "I don\\'t know what wrong with my code\\nCould any one help me?\\nThanks!\\n\\nMy code:\\nUpdate salary as s1, salary as s2 Set s1.sex = \\'f\\', s2.sex =\\'m\\' Where s1.sex = \\'m\\' Or s2.sex = \\'f\\'"
                    },
                    {
                        "username": "Abhilash_Roy",
                        "content": "UPDATE salary SET sex = REPLACE('mf',sex,'')"
                    },
                    {
                        "username": "neeljain",
                        "content": "update salary\\n\\nset sex = if(sex = \\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "kirosevheyxaa",
                        "content": "UPDATE Salary SET \\nsex = CASE WHEN  sex = \\'f\\' THEN \\'m\\'\\n         ELSE \\'f\\' END "
                    },
                    {
                        "username": "user3271Nb",
                        "content": "update salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "vishal_88",
                        "content": "UPDATE Salary\\nSET sex = CASE \\n    WHEN sex = \\'f\\' THEN \\'m\\'\\n    WHEN sex = \\'m\\' THEN \\'f\\'\\n    ELSE sex\\n    END; "
                    },
                    {
                        "username": "Codingfish89",
                        "content": "This is accepted answer\\uFF1A\\nupdate Salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\'\\n     when sex = \\'f\\' then \\'m\\'\\nelse sex\\nend"
                    }
                ]
            },
            {
                "id": 1572967,
                "content": [
                    {
                        "username": "augustgirl",
                        "content": "UPDATE salary\\nSET \\nsex = IF(sex = \\'m\\', \\'f\\', \\'m\\');"
                    },
                    {
                        "username": "KarunaMeena",
                        "content": "\\'\\'\\'\\n    \\nUPDATE salary\\nSET sex= CASE\\n   WHEN sex=\\'m\\' THEN \\'f\\'\\n   WHEN sex=\\'f\\' THEN \\'m\\'\\nEND\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "qweruiop316",
                        "content": "\\nSubmit this SQL but get runtime error\\n\\tUPDATE salary SET sex = (CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END)\\n\\t\\nAnd get accept with SQL below\\n\\tSELECT ID,NAME,CASE WHEN SEX=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END SEX, SALARY FROM SALARY"
                    },
                    {
                        "username": "alixkevin",
                        "content": "I don\\'t know what wrong with my code\\nCould any one help me?\\nThanks!\\n\\nMy code:\\nUpdate salary as s1, salary as s2 Set s1.sex = \\'f\\', s2.sex =\\'m\\' Where s1.sex = \\'m\\' Or s2.sex = \\'f\\'"
                    },
                    {
                        "username": "Abhilash_Roy",
                        "content": "UPDATE salary SET sex = REPLACE('mf',sex,'')"
                    },
                    {
                        "username": "neeljain",
                        "content": "update salary\\n\\nset sex = if(sex = \\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "kirosevheyxaa",
                        "content": "UPDATE Salary SET \\nsex = CASE WHEN  sex = \\'f\\' THEN \\'m\\'\\n         ELSE \\'f\\' END "
                    },
                    {
                        "username": "user3271Nb",
                        "content": "update salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "vishal_88",
                        "content": "UPDATE Salary\\nSET sex = CASE \\n    WHEN sex = \\'f\\' THEN \\'m\\'\\n    WHEN sex = \\'m\\' THEN \\'f\\'\\n    ELSE sex\\n    END; "
                    },
                    {
                        "username": "Codingfish89",
                        "content": "This is accepted answer\\uFF1A\\nupdate Salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\'\\n     when sex = \\'f\\' then \\'m\\'\\nelse sex\\nend"
                    }
                ]
            },
            {
                "id": 1572478,
                "content": [
                    {
                        "username": "augustgirl",
                        "content": "UPDATE salary\\nSET \\nsex = IF(sex = \\'m\\', \\'f\\', \\'m\\');"
                    },
                    {
                        "username": "KarunaMeena",
                        "content": "\\'\\'\\'\\n    \\nUPDATE salary\\nSET sex= CASE\\n   WHEN sex=\\'m\\' THEN \\'f\\'\\n   WHEN sex=\\'f\\' THEN \\'m\\'\\nEND\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "qweruiop316",
                        "content": "\\nSubmit this SQL but get runtime error\\n\\tUPDATE salary SET sex = (CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END)\\n\\t\\nAnd get accept with SQL below\\n\\tSELECT ID,NAME,CASE WHEN SEX=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END SEX, SALARY FROM SALARY"
                    },
                    {
                        "username": "alixkevin",
                        "content": "I don\\'t know what wrong with my code\\nCould any one help me?\\nThanks!\\n\\nMy code:\\nUpdate salary as s1, salary as s2 Set s1.sex = \\'f\\', s2.sex =\\'m\\' Where s1.sex = \\'m\\' Or s2.sex = \\'f\\'"
                    },
                    {
                        "username": "Abhilash_Roy",
                        "content": "UPDATE salary SET sex = REPLACE('mf',sex,'')"
                    },
                    {
                        "username": "neeljain",
                        "content": "update salary\\n\\nset sex = if(sex = \\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "kirosevheyxaa",
                        "content": "UPDATE Salary SET \\nsex = CASE WHEN  sex = \\'f\\' THEN \\'m\\'\\n         ELSE \\'f\\' END "
                    },
                    {
                        "username": "user3271Nb",
                        "content": "update salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "vishal_88",
                        "content": "UPDATE Salary\\nSET sex = CASE \\n    WHEN sex = \\'f\\' THEN \\'m\\'\\n    WHEN sex = \\'m\\' THEN \\'f\\'\\n    ELSE sex\\n    END; "
                    },
                    {
                        "username": "Codingfish89",
                        "content": "This is accepted answer\\uFF1A\\nupdate Salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\'\\n     when sex = \\'f\\' then \\'m\\'\\nelse sex\\nend"
                    }
                ]
            },
            {
                "id": 1572203,
                "content": [
                    {
                        "username": "augustgirl",
                        "content": "UPDATE salary\\nSET \\nsex = IF(sex = \\'m\\', \\'f\\', \\'m\\');"
                    },
                    {
                        "username": "KarunaMeena",
                        "content": "\\'\\'\\'\\n    \\nUPDATE salary\\nSET sex= CASE\\n   WHEN sex=\\'m\\' THEN \\'f\\'\\n   WHEN sex=\\'f\\' THEN \\'m\\'\\nEND\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "qweruiop316",
                        "content": "\\nSubmit this SQL but get runtime error\\n\\tUPDATE salary SET sex = (CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END)\\n\\t\\nAnd get accept with SQL below\\n\\tSELECT ID,NAME,CASE WHEN SEX=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END SEX, SALARY FROM SALARY"
                    },
                    {
                        "username": "alixkevin",
                        "content": "I don\\'t know what wrong with my code\\nCould any one help me?\\nThanks!\\n\\nMy code:\\nUpdate salary as s1, salary as s2 Set s1.sex = \\'f\\', s2.sex =\\'m\\' Where s1.sex = \\'m\\' Or s2.sex = \\'f\\'"
                    },
                    {
                        "username": "Abhilash_Roy",
                        "content": "UPDATE salary SET sex = REPLACE('mf',sex,'')"
                    },
                    {
                        "username": "neeljain",
                        "content": "update salary\\n\\nset sex = if(sex = \\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "kirosevheyxaa",
                        "content": "UPDATE Salary SET \\nsex = CASE WHEN  sex = \\'f\\' THEN \\'m\\'\\n         ELSE \\'f\\' END "
                    },
                    {
                        "username": "user3271Nb",
                        "content": "update salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "vishal_88",
                        "content": "UPDATE Salary\\nSET sex = CASE \\n    WHEN sex = \\'f\\' THEN \\'m\\'\\n    WHEN sex = \\'m\\' THEN \\'f\\'\\n    ELSE sex\\n    END; "
                    },
                    {
                        "username": "Codingfish89",
                        "content": "This is accepted answer\\uFF1A\\nupdate Salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\'\\n     when sex = \\'f\\' then \\'m\\'\\nelse sex\\nend"
                    }
                ]
            },
            {
                "id": 1571787,
                "content": [
                    {
                        "username": "augustgirl",
                        "content": "UPDATE salary\\nSET \\nsex = IF(sex = \\'m\\', \\'f\\', \\'m\\');"
                    },
                    {
                        "username": "KarunaMeena",
                        "content": "\\'\\'\\'\\n    \\nUPDATE salary\\nSET sex= CASE\\n   WHEN sex=\\'m\\' THEN \\'f\\'\\n   WHEN sex=\\'f\\' THEN \\'m\\'\\nEND\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "qweruiop316",
                        "content": "\\nSubmit this SQL but get runtime error\\n\\tUPDATE salary SET sex = (CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END)\\n\\t\\nAnd get accept with SQL below\\n\\tSELECT ID,NAME,CASE WHEN SEX=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END SEX, SALARY FROM SALARY"
                    },
                    {
                        "username": "alixkevin",
                        "content": "I don\\'t know what wrong with my code\\nCould any one help me?\\nThanks!\\n\\nMy code:\\nUpdate salary as s1, salary as s2 Set s1.sex = \\'f\\', s2.sex =\\'m\\' Where s1.sex = \\'m\\' Or s2.sex = \\'f\\'"
                    },
                    {
                        "username": "Abhilash_Roy",
                        "content": "UPDATE salary SET sex = REPLACE('mf',sex,'')"
                    },
                    {
                        "username": "neeljain",
                        "content": "update salary\\n\\nset sex = if(sex = \\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "kirosevheyxaa",
                        "content": "UPDATE Salary SET \\nsex = CASE WHEN  sex = \\'f\\' THEN \\'m\\'\\n         ELSE \\'f\\' END "
                    },
                    {
                        "username": "user3271Nb",
                        "content": "update salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "vishal_88",
                        "content": "UPDATE Salary\\nSET sex = CASE \\n    WHEN sex = \\'f\\' THEN \\'m\\'\\n    WHEN sex = \\'m\\' THEN \\'f\\'\\n    ELSE sex\\n    END; "
                    },
                    {
                        "username": "Codingfish89",
                        "content": "This is accepted answer\\uFF1A\\nupdate Salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\'\\n     when sex = \\'f\\' then \\'m\\'\\nelse sex\\nend"
                    }
                ]
            },
            {
                "id": 1575495,
                "content": [
                    {
                        "username": "augustgirl",
                        "content": "UPDATE salary\\nSET \\nsex = IF(sex = \\'m\\', \\'f\\', \\'m\\');"
                    },
                    {
                        "username": "KarunaMeena",
                        "content": "\\'\\'\\'\\n    \\nUPDATE salary\\nSET sex= CASE\\n   WHEN sex=\\'m\\' THEN \\'f\\'\\n   WHEN sex=\\'f\\' THEN \\'m\\'\\nEND\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "qweruiop316",
                        "content": "\\nSubmit this SQL but get runtime error\\n\\tUPDATE salary SET sex = (CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END)\\n\\t\\nAnd get accept with SQL below\\n\\tSELECT ID,NAME,CASE WHEN SEX=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END SEX, SALARY FROM SALARY"
                    },
                    {
                        "username": "alixkevin",
                        "content": "I don\\'t know what wrong with my code\\nCould any one help me?\\nThanks!\\n\\nMy code:\\nUpdate salary as s1, salary as s2 Set s1.sex = \\'f\\', s2.sex =\\'m\\' Where s1.sex = \\'m\\' Or s2.sex = \\'f\\'"
                    },
                    {
                        "username": "Abhilash_Roy",
                        "content": "UPDATE salary SET sex = REPLACE('mf',sex,'')"
                    },
                    {
                        "username": "neeljain",
                        "content": "update salary\\n\\nset sex = if(sex = \\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "kirosevheyxaa",
                        "content": "UPDATE Salary SET \\nsex = CASE WHEN  sex = \\'f\\' THEN \\'m\\'\\n         ELSE \\'f\\' END "
                    },
                    {
                        "username": "user3271Nb",
                        "content": "update salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "vishal_88",
                        "content": "UPDATE Salary\\nSET sex = CASE \\n    WHEN sex = \\'f\\' THEN \\'m\\'\\n    WHEN sex = \\'m\\' THEN \\'f\\'\\n    ELSE sex\\n    END; "
                    },
                    {
                        "username": "Codingfish89",
                        "content": "This is accepted answer\\uFF1A\\nupdate Salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\'\\n     when sex = \\'f\\' then \\'m\\'\\nelse sex\\nend"
                    }
                ]
            },
            {
                "id": 2054717,
                "content": [
                    {
                        "username": "augustgirl",
                        "content": "UPDATE salary\\nSET \\nsex = IF(sex = \\'m\\', \\'f\\', \\'m\\');"
                    },
                    {
                        "username": "KarunaMeena",
                        "content": "\\'\\'\\'\\n    \\nUPDATE salary\\nSET sex= CASE\\n   WHEN sex=\\'m\\' THEN \\'f\\'\\n   WHEN sex=\\'f\\' THEN \\'m\\'\\nEND\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "qweruiop316",
                        "content": "\\nSubmit this SQL but get runtime error\\n\\tUPDATE salary SET sex = (CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END)\\n\\t\\nAnd get accept with SQL below\\n\\tSELECT ID,NAME,CASE WHEN SEX=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END SEX, SALARY FROM SALARY"
                    },
                    {
                        "username": "alixkevin",
                        "content": "I don\\'t know what wrong with my code\\nCould any one help me?\\nThanks!\\n\\nMy code:\\nUpdate salary as s1, salary as s2 Set s1.sex = \\'f\\', s2.sex =\\'m\\' Where s1.sex = \\'m\\' Or s2.sex = \\'f\\'"
                    },
                    {
                        "username": "Abhilash_Roy",
                        "content": "UPDATE salary SET sex = REPLACE('mf',sex,'')"
                    },
                    {
                        "username": "neeljain",
                        "content": "update salary\\n\\nset sex = if(sex = \\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "kirosevheyxaa",
                        "content": "UPDATE Salary SET \\nsex = CASE WHEN  sex = \\'f\\' THEN \\'m\\'\\n         ELSE \\'f\\' END "
                    },
                    {
                        "username": "user3271Nb",
                        "content": "update salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "vishal_88",
                        "content": "UPDATE Salary\\nSET sex = CASE \\n    WHEN sex = \\'f\\' THEN \\'m\\'\\n    WHEN sex = \\'m\\' THEN \\'f\\'\\n    ELSE sex\\n    END; "
                    },
                    {
                        "username": "Codingfish89",
                        "content": "This is accepted answer\\uFF1A\\nupdate Salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\'\\n     when sex = \\'f\\' then \\'m\\'\\nelse sex\\nend"
                    }
                ]
            },
            {
                "id": 2035897,
                "content": [
                    {
                        "username": "augustgirl",
                        "content": "UPDATE salary\\nSET \\nsex = IF(sex = \\'m\\', \\'f\\', \\'m\\');"
                    },
                    {
                        "username": "KarunaMeena",
                        "content": "\\'\\'\\'\\n    \\nUPDATE salary\\nSET sex= CASE\\n   WHEN sex=\\'m\\' THEN \\'f\\'\\n   WHEN sex=\\'f\\' THEN \\'m\\'\\nEND\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "qweruiop316",
                        "content": "\\nSubmit this SQL but get runtime error\\n\\tUPDATE salary SET sex = (CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END)\\n\\t\\nAnd get accept with SQL below\\n\\tSELECT ID,NAME,CASE WHEN SEX=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END SEX, SALARY FROM SALARY"
                    },
                    {
                        "username": "alixkevin",
                        "content": "I don\\'t know what wrong with my code\\nCould any one help me?\\nThanks!\\n\\nMy code:\\nUpdate salary as s1, salary as s2 Set s1.sex = \\'f\\', s2.sex =\\'m\\' Where s1.sex = \\'m\\' Or s2.sex = \\'f\\'"
                    },
                    {
                        "username": "Abhilash_Roy",
                        "content": "UPDATE salary SET sex = REPLACE('mf',sex,'')"
                    },
                    {
                        "username": "neeljain",
                        "content": "update salary\\n\\nset sex = if(sex = \\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "kirosevheyxaa",
                        "content": "UPDATE Salary SET \\nsex = CASE WHEN  sex = \\'f\\' THEN \\'m\\'\\n         ELSE \\'f\\' END "
                    },
                    {
                        "username": "user3271Nb",
                        "content": "update salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "vishal_88",
                        "content": "UPDATE Salary\\nSET sex = CASE \\n    WHEN sex = \\'f\\' THEN \\'m\\'\\n    WHEN sex = \\'m\\' THEN \\'f\\'\\n    ELSE sex\\n    END; "
                    },
                    {
                        "username": "Codingfish89",
                        "content": "This is accepted answer\\uFF1A\\nupdate Salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\'\\n     when sex = \\'f\\' then \\'m\\'\\nelse sex\\nend"
                    }
                ]
            },
            {
                "id": 2016818,
                "content": [
                    {
                        "username": "augustgirl",
                        "content": "UPDATE salary\\nSET \\nsex = IF(sex = \\'m\\', \\'f\\', \\'m\\');"
                    },
                    {
                        "username": "KarunaMeena",
                        "content": "\\'\\'\\'\\n    \\nUPDATE salary\\nSET sex= CASE\\n   WHEN sex=\\'m\\' THEN \\'f\\'\\n   WHEN sex=\\'f\\' THEN \\'m\\'\\nEND\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "qweruiop316",
                        "content": "\\nSubmit this SQL but get runtime error\\n\\tUPDATE salary SET sex = (CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END)\\n\\t\\nAnd get accept with SQL below\\n\\tSELECT ID,NAME,CASE WHEN SEX=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END SEX, SALARY FROM SALARY"
                    },
                    {
                        "username": "alixkevin",
                        "content": "I don\\'t know what wrong with my code\\nCould any one help me?\\nThanks!\\n\\nMy code:\\nUpdate salary as s1, salary as s2 Set s1.sex = \\'f\\', s2.sex =\\'m\\' Where s1.sex = \\'m\\' Or s2.sex = \\'f\\'"
                    },
                    {
                        "username": "Abhilash_Roy",
                        "content": "UPDATE salary SET sex = REPLACE('mf',sex,'')"
                    },
                    {
                        "username": "neeljain",
                        "content": "update salary\\n\\nset sex = if(sex = \\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "kirosevheyxaa",
                        "content": "UPDATE Salary SET \\nsex = CASE WHEN  sex = \\'f\\' THEN \\'m\\'\\n         ELSE \\'f\\' END "
                    },
                    {
                        "username": "user3271Nb",
                        "content": "update salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "vishal_88",
                        "content": "UPDATE Salary\\nSET sex = CASE \\n    WHEN sex = \\'f\\' THEN \\'m\\'\\n    WHEN sex = \\'m\\' THEN \\'f\\'\\n    ELSE sex\\n    END; "
                    },
                    {
                        "username": "Codingfish89",
                        "content": "This is accepted answer\\uFF1A\\nupdate Salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\'\\n     when sex = \\'f\\' then \\'m\\'\\nelse sex\\nend"
                    }
                ]
            },
            {
                "id": 2008796,
                "content": [
                    {
                        "username": "augustgirl",
                        "content": "UPDATE salary\\nSET \\nsex = IF(sex = \\'m\\', \\'f\\', \\'m\\');"
                    },
                    {
                        "username": "KarunaMeena",
                        "content": "\\'\\'\\'\\n    \\nUPDATE salary\\nSET sex= CASE\\n   WHEN sex=\\'m\\' THEN \\'f\\'\\n   WHEN sex=\\'f\\' THEN \\'m\\'\\nEND\\n\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "qweruiop316",
                        "content": "\\nSubmit this SQL but get runtime error\\n\\tUPDATE salary SET sex = (CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END)\\n\\t\\nAnd get accept with SQL below\\n\\tSELECT ID,NAME,CASE WHEN SEX=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END SEX, SALARY FROM SALARY"
                    },
                    {
                        "username": "alixkevin",
                        "content": "I don\\'t know what wrong with my code\\nCould any one help me?\\nThanks!\\n\\nMy code:\\nUpdate salary as s1, salary as s2 Set s1.sex = \\'f\\', s2.sex =\\'m\\' Where s1.sex = \\'m\\' Or s2.sex = \\'f\\'"
                    },
                    {
                        "username": "Abhilash_Roy",
                        "content": "UPDATE salary SET sex = REPLACE('mf',sex,'')"
                    },
                    {
                        "username": "neeljain",
                        "content": "update salary\\n\\nset sex = if(sex = \\'m\\',\\'f\\',\\'m\\');"
                    },
                    {
                        "username": "kirosevheyxaa",
                        "content": "UPDATE Salary SET \\nsex = CASE WHEN  sex = \\'f\\' THEN \\'m\\'\\n         ELSE \\'f\\' END "
                    },
                    {
                        "username": "user3271Nb",
                        "content": "update salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "vishal_88",
                        "content": "UPDATE Salary\\nSET sex = CASE \\n    WHEN sex = \\'f\\' THEN \\'m\\'\\n    WHEN sex = \\'m\\' THEN \\'f\\'\\n    ELSE sex\\n    END; "
                    },
                    {
                        "username": "Codingfish89",
                        "content": "This is accepted answer\\uFF1A\\nupdate Salary\\nset sex =\\ncase when sex = \\'m\\' then \\'f\\'\\n     when sex = \\'f\\' then \\'m\\'\\nelse sex\\nend"
                    }
                ]
            },
            {
                "id": 1998498,
                "content": [
                    {
                        "username": "rejent",
                        "content": "`\nUPDATE Salary \nSET sex=CASE WHEN sex='f' THEN 'm'\nWHEN sex='m' THEN 'f'\nELSE sex END \n`"
                    },
                    {
                        "username": "shouvik32",
                        "content": "Here is my Normal Query and Optimize query from 530 ms to 427 ms\\n#Query-1\\nUPDATE salary SET sex = CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END\\n#Query-2\\nUPDATE Salary SET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\')  #excel tric  if(con, if_true, if_false)"
                    },
                    {
                        "username": "neha_7317",
                        "content": "update Salary \\nset sex = if(sex=\\'f\\' , \\'m\\',\\'f\\');"
                    },
                    {
                        "username": "Shafi_49",
                        "content": "update salary set sex = \\nif (sex = \\'m\\', \\'f\\', \\'m\\')"
                    },
                    {
                        "username": "Jazzz_1226",
                        "content": "Why does the answer add \"sex\" after CASE? I ran into warnings with this: \\nUPDATE salary\\nSET\\n    sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;"
                    },
                    {
                        "username": "anilbharadia",
                        "content": "The title should be `swap sex` instead of `swap salary`"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "update Salary\\nset sex= case when sex=\\'m\\' then \\'f\\'\\n            when sex=\\'f\\' then \\'m\\' end;"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nupdate Salary as s set s.sex =\\ncase\\nWHEN s.sex=\\'f\\' THEN \\'m\\'\\nWHEN s.sex=\\'m\\' THEN \\'f\\'\\nEND "
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "update Salary set sex = case when sex=\\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "navneet_jain_0154",
                        "content": "Can't we update tables in these questions of SQL not sure why following code is giving error :\n```\nupdate Salary\n    set sex = case\n        when sex = 'm' then 'f'\n        when sex = 'f' then 'm'\n    end;\nselect * from Salary; ```"
                    }
                ]
            },
            {
                "id": 1990265,
                "content": [
                    {
                        "username": "rejent",
                        "content": "`\nUPDATE Salary \nSET sex=CASE WHEN sex='f' THEN 'm'\nWHEN sex='m' THEN 'f'\nELSE sex END \n`"
                    },
                    {
                        "username": "shouvik32",
                        "content": "Here is my Normal Query and Optimize query from 530 ms to 427 ms\\n#Query-1\\nUPDATE salary SET sex = CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END\\n#Query-2\\nUPDATE Salary SET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\')  #excel tric  if(con, if_true, if_false)"
                    },
                    {
                        "username": "neha_7317",
                        "content": "update Salary \\nset sex = if(sex=\\'f\\' , \\'m\\',\\'f\\');"
                    },
                    {
                        "username": "Shafi_49",
                        "content": "update salary set sex = \\nif (sex = \\'m\\', \\'f\\', \\'m\\')"
                    },
                    {
                        "username": "Jazzz_1226",
                        "content": "Why does the answer add \"sex\" after CASE? I ran into warnings with this: \\nUPDATE salary\\nSET\\n    sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;"
                    },
                    {
                        "username": "anilbharadia",
                        "content": "The title should be `swap sex` instead of `swap salary`"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "update Salary\\nset sex= case when sex=\\'m\\' then \\'f\\'\\n            when sex=\\'f\\' then \\'m\\' end;"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nupdate Salary as s set s.sex =\\ncase\\nWHEN s.sex=\\'f\\' THEN \\'m\\'\\nWHEN s.sex=\\'m\\' THEN \\'f\\'\\nEND "
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "update Salary set sex = case when sex=\\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "navneet_jain_0154",
                        "content": "Can't we update tables in these questions of SQL not sure why following code is giving error :\n```\nupdate Salary\n    set sex = case\n        when sex = 'm' then 'f'\n        when sex = 'f' then 'm'\n    end;\nselect * from Salary; ```"
                    }
                ]
            },
            {
                "id": 1950748,
                "content": [
                    {
                        "username": "rejent",
                        "content": "`\nUPDATE Salary \nSET sex=CASE WHEN sex='f' THEN 'm'\nWHEN sex='m' THEN 'f'\nELSE sex END \n`"
                    },
                    {
                        "username": "shouvik32",
                        "content": "Here is my Normal Query and Optimize query from 530 ms to 427 ms\\n#Query-1\\nUPDATE salary SET sex = CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END\\n#Query-2\\nUPDATE Salary SET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\')  #excel tric  if(con, if_true, if_false)"
                    },
                    {
                        "username": "neha_7317",
                        "content": "update Salary \\nset sex = if(sex=\\'f\\' , \\'m\\',\\'f\\');"
                    },
                    {
                        "username": "Shafi_49",
                        "content": "update salary set sex = \\nif (sex = \\'m\\', \\'f\\', \\'m\\')"
                    },
                    {
                        "username": "Jazzz_1226",
                        "content": "Why does the answer add \"sex\" after CASE? I ran into warnings with this: \\nUPDATE salary\\nSET\\n    sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;"
                    },
                    {
                        "username": "anilbharadia",
                        "content": "The title should be `swap sex` instead of `swap salary`"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "update Salary\\nset sex= case when sex=\\'m\\' then \\'f\\'\\n            when sex=\\'f\\' then \\'m\\' end;"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nupdate Salary as s set s.sex =\\ncase\\nWHEN s.sex=\\'f\\' THEN \\'m\\'\\nWHEN s.sex=\\'m\\' THEN \\'f\\'\\nEND "
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "update Salary set sex = case when sex=\\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "navneet_jain_0154",
                        "content": "Can't we update tables in these questions of SQL not sure why following code is giving error :\n```\nupdate Salary\n    set sex = case\n        when sex = 'm' then 'f'\n        when sex = 'f' then 'm'\n    end;\nselect * from Salary; ```"
                    }
                ]
            },
            {
                "id": 1929955,
                "content": [
                    {
                        "username": "rejent",
                        "content": "`\nUPDATE Salary \nSET sex=CASE WHEN sex='f' THEN 'm'\nWHEN sex='m' THEN 'f'\nELSE sex END \n`"
                    },
                    {
                        "username": "shouvik32",
                        "content": "Here is my Normal Query and Optimize query from 530 ms to 427 ms\\n#Query-1\\nUPDATE salary SET sex = CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END\\n#Query-2\\nUPDATE Salary SET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\')  #excel tric  if(con, if_true, if_false)"
                    },
                    {
                        "username": "neha_7317",
                        "content": "update Salary \\nset sex = if(sex=\\'f\\' , \\'m\\',\\'f\\');"
                    },
                    {
                        "username": "Shafi_49",
                        "content": "update salary set sex = \\nif (sex = \\'m\\', \\'f\\', \\'m\\')"
                    },
                    {
                        "username": "Jazzz_1226",
                        "content": "Why does the answer add \"sex\" after CASE? I ran into warnings with this: \\nUPDATE salary\\nSET\\n    sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;"
                    },
                    {
                        "username": "anilbharadia",
                        "content": "The title should be `swap sex` instead of `swap salary`"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "update Salary\\nset sex= case when sex=\\'m\\' then \\'f\\'\\n            when sex=\\'f\\' then \\'m\\' end;"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nupdate Salary as s set s.sex =\\ncase\\nWHEN s.sex=\\'f\\' THEN \\'m\\'\\nWHEN s.sex=\\'m\\' THEN \\'f\\'\\nEND "
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "update Salary set sex = case when sex=\\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "navneet_jain_0154",
                        "content": "Can't we update tables in these questions of SQL not sure why following code is giving error :\n```\nupdate Salary\n    set sex = case\n        when sex = 'm' then 'f'\n        when sex = 'f' then 'm'\n    end;\nselect * from Salary; ```"
                    }
                ]
            },
            {
                "id": 1907744,
                "content": [
                    {
                        "username": "rejent",
                        "content": "`\nUPDATE Salary \nSET sex=CASE WHEN sex='f' THEN 'm'\nWHEN sex='m' THEN 'f'\nELSE sex END \n`"
                    },
                    {
                        "username": "shouvik32",
                        "content": "Here is my Normal Query and Optimize query from 530 ms to 427 ms\\n#Query-1\\nUPDATE salary SET sex = CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END\\n#Query-2\\nUPDATE Salary SET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\')  #excel tric  if(con, if_true, if_false)"
                    },
                    {
                        "username": "neha_7317",
                        "content": "update Salary \\nset sex = if(sex=\\'f\\' , \\'m\\',\\'f\\');"
                    },
                    {
                        "username": "Shafi_49",
                        "content": "update salary set sex = \\nif (sex = \\'m\\', \\'f\\', \\'m\\')"
                    },
                    {
                        "username": "Jazzz_1226",
                        "content": "Why does the answer add \"sex\" after CASE? I ran into warnings with this: \\nUPDATE salary\\nSET\\n    sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;"
                    },
                    {
                        "username": "anilbharadia",
                        "content": "The title should be `swap sex` instead of `swap salary`"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "update Salary\\nset sex= case when sex=\\'m\\' then \\'f\\'\\n            when sex=\\'f\\' then \\'m\\' end;"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nupdate Salary as s set s.sex =\\ncase\\nWHEN s.sex=\\'f\\' THEN \\'m\\'\\nWHEN s.sex=\\'m\\' THEN \\'f\\'\\nEND "
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "update Salary set sex = case when sex=\\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "navneet_jain_0154",
                        "content": "Can't we update tables in these questions of SQL not sure why following code is giving error :\n```\nupdate Salary\n    set sex = case\n        when sex = 'm' then 'f'\n        when sex = 'f' then 'm'\n    end;\nselect * from Salary; ```"
                    }
                ]
            },
            {
                "id": 1876884,
                "content": [
                    {
                        "username": "rejent",
                        "content": "`\nUPDATE Salary \nSET sex=CASE WHEN sex='f' THEN 'm'\nWHEN sex='m' THEN 'f'\nELSE sex END \n`"
                    },
                    {
                        "username": "shouvik32",
                        "content": "Here is my Normal Query and Optimize query from 530 ms to 427 ms\\n#Query-1\\nUPDATE salary SET sex = CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END\\n#Query-2\\nUPDATE Salary SET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\')  #excel tric  if(con, if_true, if_false)"
                    },
                    {
                        "username": "neha_7317",
                        "content": "update Salary \\nset sex = if(sex=\\'f\\' , \\'m\\',\\'f\\');"
                    },
                    {
                        "username": "Shafi_49",
                        "content": "update salary set sex = \\nif (sex = \\'m\\', \\'f\\', \\'m\\')"
                    },
                    {
                        "username": "Jazzz_1226",
                        "content": "Why does the answer add \"sex\" after CASE? I ran into warnings with this: \\nUPDATE salary\\nSET\\n    sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;"
                    },
                    {
                        "username": "anilbharadia",
                        "content": "The title should be `swap sex` instead of `swap salary`"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "update Salary\\nset sex= case when sex=\\'m\\' then \\'f\\'\\n            when sex=\\'f\\' then \\'m\\' end;"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nupdate Salary as s set s.sex =\\ncase\\nWHEN s.sex=\\'f\\' THEN \\'m\\'\\nWHEN s.sex=\\'m\\' THEN \\'f\\'\\nEND "
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "update Salary set sex = case when sex=\\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "navneet_jain_0154",
                        "content": "Can't we update tables in these questions of SQL not sure why following code is giving error :\n```\nupdate Salary\n    set sex = case\n        when sex = 'm' then 'f'\n        when sex = 'f' then 'm'\n    end;\nselect * from Salary; ```"
                    }
                ]
            },
            {
                "id": 1867351,
                "content": [
                    {
                        "username": "rejent",
                        "content": "`\nUPDATE Salary \nSET sex=CASE WHEN sex='f' THEN 'm'\nWHEN sex='m' THEN 'f'\nELSE sex END \n`"
                    },
                    {
                        "username": "shouvik32",
                        "content": "Here is my Normal Query and Optimize query from 530 ms to 427 ms\\n#Query-1\\nUPDATE salary SET sex = CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END\\n#Query-2\\nUPDATE Salary SET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\')  #excel tric  if(con, if_true, if_false)"
                    },
                    {
                        "username": "neha_7317",
                        "content": "update Salary \\nset sex = if(sex=\\'f\\' , \\'m\\',\\'f\\');"
                    },
                    {
                        "username": "Shafi_49",
                        "content": "update salary set sex = \\nif (sex = \\'m\\', \\'f\\', \\'m\\')"
                    },
                    {
                        "username": "Jazzz_1226",
                        "content": "Why does the answer add \"sex\" after CASE? I ran into warnings with this: \\nUPDATE salary\\nSET\\n    sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;"
                    },
                    {
                        "username": "anilbharadia",
                        "content": "The title should be `swap sex` instead of `swap salary`"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "update Salary\\nset sex= case when sex=\\'m\\' then \\'f\\'\\n            when sex=\\'f\\' then \\'m\\' end;"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nupdate Salary as s set s.sex =\\ncase\\nWHEN s.sex=\\'f\\' THEN \\'m\\'\\nWHEN s.sex=\\'m\\' THEN \\'f\\'\\nEND "
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "update Salary set sex = case when sex=\\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "navneet_jain_0154",
                        "content": "Can't we update tables in these questions of SQL not sure why following code is giving error :\n```\nupdate Salary\n    set sex = case\n        when sex = 'm' then 'f'\n        when sex = 'f' then 'm'\n    end;\nselect * from Salary; ```"
                    }
                ]
            },
            {
                "id": 1860084,
                "content": [
                    {
                        "username": "rejent",
                        "content": "`\nUPDATE Salary \nSET sex=CASE WHEN sex='f' THEN 'm'\nWHEN sex='m' THEN 'f'\nELSE sex END \n`"
                    },
                    {
                        "username": "shouvik32",
                        "content": "Here is my Normal Query and Optimize query from 530 ms to 427 ms\\n#Query-1\\nUPDATE salary SET sex = CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END\\n#Query-2\\nUPDATE Salary SET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\')  #excel tric  if(con, if_true, if_false)"
                    },
                    {
                        "username": "neha_7317",
                        "content": "update Salary \\nset sex = if(sex=\\'f\\' , \\'m\\',\\'f\\');"
                    },
                    {
                        "username": "Shafi_49",
                        "content": "update salary set sex = \\nif (sex = \\'m\\', \\'f\\', \\'m\\')"
                    },
                    {
                        "username": "Jazzz_1226",
                        "content": "Why does the answer add \"sex\" after CASE? I ran into warnings with this: \\nUPDATE salary\\nSET\\n    sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;"
                    },
                    {
                        "username": "anilbharadia",
                        "content": "The title should be `swap sex` instead of `swap salary`"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "update Salary\\nset sex= case when sex=\\'m\\' then \\'f\\'\\n            when sex=\\'f\\' then \\'m\\' end;"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nupdate Salary as s set s.sex =\\ncase\\nWHEN s.sex=\\'f\\' THEN \\'m\\'\\nWHEN s.sex=\\'m\\' THEN \\'f\\'\\nEND "
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "update Salary set sex = case when sex=\\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "navneet_jain_0154",
                        "content": "Can't we update tables in these questions of SQL not sure why following code is giving error :\n```\nupdate Salary\n    set sex = case\n        when sex = 'm' then 'f'\n        when sex = 'f' then 'm'\n    end;\nselect * from Salary; ```"
                    }
                ]
            },
            {
                "id": 1852782,
                "content": [
                    {
                        "username": "rejent",
                        "content": "`\nUPDATE Salary \nSET sex=CASE WHEN sex='f' THEN 'm'\nWHEN sex='m' THEN 'f'\nELSE sex END \n`"
                    },
                    {
                        "username": "shouvik32",
                        "content": "Here is my Normal Query and Optimize query from 530 ms to 427 ms\\n#Query-1\\nUPDATE salary SET sex = CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END\\n#Query-2\\nUPDATE Salary SET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\')  #excel tric  if(con, if_true, if_false)"
                    },
                    {
                        "username": "neha_7317",
                        "content": "update Salary \\nset sex = if(sex=\\'f\\' , \\'m\\',\\'f\\');"
                    },
                    {
                        "username": "Shafi_49",
                        "content": "update salary set sex = \\nif (sex = \\'m\\', \\'f\\', \\'m\\')"
                    },
                    {
                        "username": "Jazzz_1226",
                        "content": "Why does the answer add \"sex\" after CASE? I ran into warnings with this: \\nUPDATE salary\\nSET\\n    sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;"
                    },
                    {
                        "username": "anilbharadia",
                        "content": "The title should be `swap sex` instead of `swap salary`"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "update Salary\\nset sex= case when sex=\\'m\\' then \\'f\\'\\n            when sex=\\'f\\' then \\'m\\' end;"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nupdate Salary as s set s.sex =\\ncase\\nWHEN s.sex=\\'f\\' THEN \\'m\\'\\nWHEN s.sex=\\'m\\' THEN \\'f\\'\\nEND "
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "update Salary set sex = case when sex=\\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "navneet_jain_0154",
                        "content": "Can't we update tables in these questions of SQL not sure why following code is giving error :\n```\nupdate Salary\n    set sex = case\n        when sex = 'm' then 'f'\n        when sex = 'f' then 'm'\n    end;\nselect * from Salary; ```"
                    }
                ]
            },
            {
                "id": 1843458,
                "content": [
                    {
                        "username": "rejent",
                        "content": "`\nUPDATE Salary \nSET sex=CASE WHEN sex='f' THEN 'm'\nWHEN sex='m' THEN 'f'\nELSE sex END \n`"
                    },
                    {
                        "username": "shouvik32",
                        "content": "Here is my Normal Query and Optimize query from 530 ms to 427 ms\\n#Query-1\\nUPDATE salary SET sex = CASE WHEN sex=\\'m\\' THEN \\'f\\' ELSE \\'m\\' END\\n#Query-2\\nUPDATE Salary SET sex=IF(sex=\\'m\\',\\'f\\',\\'m\\')  #excel tric  if(con, if_true, if_false)"
                    },
                    {
                        "username": "neha_7317",
                        "content": "update Salary \\nset sex = if(sex=\\'f\\' , \\'m\\',\\'f\\');"
                    },
                    {
                        "username": "Shafi_49",
                        "content": "update salary set sex = \\nif (sex = \\'m\\', \\'f\\', \\'m\\')"
                    },
                    {
                        "username": "Jazzz_1226",
                        "content": "Why does the answer add \"sex\" after CASE? I ran into warnings with this: \\nUPDATE salary\\nSET\\n    sex = CASE sex\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\n    END;"
                    },
                    {
                        "username": "anilbharadia",
                        "content": "The title should be `swap sex` instead of `swap salary`"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "update Salary\\nset sex= case when sex=\\'m\\' then \\'f\\'\\n            when sex=\\'f\\' then \\'m\\' end;"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below query worked for me,\\nupdate Salary as s set s.sex =\\ncase\\nWHEN s.sex=\\'f\\' THEN \\'m\\'\\nWHEN s.sex=\\'m\\' THEN \\'f\\'\\nEND "
                    },
                    {
                        "username": "prarthitshah899",
                        "content": "update Salary set sex = case when sex=\\'m\\' then \\'f\\' else \\'m\\' end;"
                    },
                    {
                        "username": "navneet_jain_0154",
                        "content": "Can't we update tables in these questions of SQL not sure why following code is giving error :\n```\nupdate Salary\n    set sex = case\n        when sex = 'm' then 'f'\n        when sex = 'f' then 'm'\n    end;\nselect * from Salary; ```"
                    }
                ]
            },
            {
                "id": 1843131,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hi everyone! Please check out my solution and let me know what you think. If you find it helpful, please consider upvoting it to show your support. Your feedback is greatly appreciated! Thank you.\\nURL: https://leetcode.com/problems/swap-salary/solutions/3339725/easy-solution-update-using-case-sql/\\nKeep Coding :)"
                    },
                    {
                        "username": "surajon727",
                        "content": "UPDATE Salary set sex =\\ncase when sex =\\'m\\' then \\'f\\'\\nelse \\'m\\' \\nend \\n"
                    },
                    {
                        "username": "chinmaydhok",
                        "content": "update Salary \\nset sex = \\nif (sex=\\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "user5810tH",
                        "content": "UPDATE Salary SET sex =\\nCASE sex\\nwhen \\'m\\' then \\'f\\'\\nwhen \\'f\\' then \\'m\\'\\nelse NULL\\nend;"
                    },
                    {
                        "username": "akanksha7252",
                        "content": "why the statement \\nselect id, name, if(sex=\\'f\\',\\'m\\',\\'f\\') as sex, salary from salary\\nis not working correctly."
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "UPDATE salary\\nSET     sex = CASE sex\\n              WHEN \\'f\\' THEN \\'m\\'\\n              ELSE \\'f\\'\\n              END;"
                    },
                    {
                        "username": "digitalghostdev",
                        "content": "I have a question,\\nThe official solution shows this:\\n\\n UPDATE salary\\nSET\\n    sex = CASE sex <-- why is the column reference here?\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\nEND;\\n\\nDoes anyone know why the `sex` column is referenced here AFTER the `CASE` statement?"
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi DEV,\\nAs per my understanding ,\\nThe \\'sex\\' column is given after \\'CASE\\' to give the CASE function the column in which it have to check the \\'WHEN\\' function.\\n\\n\"\\nUPDATE Salary SET sex = \\nCASE \\nWHEN sex = \\'f\\' then \\'m\\'\\nELSE \\'f\\' \\nEND ;\\n\"\\nIn the above solution that I have used , I have also done the same."
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "update Salary set sex = Case when sex like \\'m\\' then \\'f\\'\\nelse \\'m\\'\\nend;"
                    },
                    {
                        "username": "sourabh19",
                        "content": "UPDATE Salary\\nSet sex = CASE sex\\n            WHEN \\'m\\' THEN \\'f\\'\\n            WHEN \\'f\\' THEN \\'m\\'\\n            else \\'no\\'\\n            END;"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`update Salary\\nset sex = if(sex = \\'m\\', \\'f\\', \\'m\\')`"
                    }
                ]
            },
            {
                "id": 1843106,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hi everyone! Please check out my solution and let me know what you think. If you find it helpful, please consider upvoting it to show your support. Your feedback is greatly appreciated! Thank you.\\nURL: https://leetcode.com/problems/swap-salary/solutions/3339725/easy-solution-update-using-case-sql/\\nKeep Coding :)"
                    },
                    {
                        "username": "surajon727",
                        "content": "UPDATE Salary set sex =\\ncase when sex =\\'m\\' then \\'f\\'\\nelse \\'m\\' \\nend \\n"
                    },
                    {
                        "username": "chinmaydhok",
                        "content": "update Salary \\nset sex = \\nif (sex=\\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "user5810tH",
                        "content": "UPDATE Salary SET sex =\\nCASE sex\\nwhen \\'m\\' then \\'f\\'\\nwhen \\'f\\' then \\'m\\'\\nelse NULL\\nend;"
                    },
                    {
                        "username": "akanksha7252",
                        "content": "why the statement \\nselect id, name, if(sex=\\'f\\',\\'m\\',\\'f\\') as sex, salary from salary\\nis not working correctly."
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "UPDATE salary\\nSET     sex = CASE sex\\n              WHEN \\'f\\' THEN \\'m\\'\\n              ELSE \\'f\\'\\n              END;"
                    },
                    {
                        "username": "digitalghostdev",
                        "content": "I have a question,\\nThe official solution shows this:\\n\\n UPDATE salary\\nSET\\n    sex = CASE sex <-- why is the column reference here?\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\nEND;\\n\\nDoes anyone know why the `sex` column is referenced here AFTER the `CASE` statement?"
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi DEV,\\nAs per my understanding ,\\nThe \\'sex\\' column is given after \\'CASE\\' to give the CASE function the column in which it have to check the \\'WHEN\\' function.\\n\\n\"\\nUPDATE Salary SET sex = \\nCASE \\nWHEN sex = \\'f\\' then \\'m\\'\\nELSE \\'f\\' \\nEND ;\\n\"\\nIn the above solution that I have used , I have also done the same."
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "update Salary set sex = Case when sex like \\'m\\' then \\'f\\'\\nelse \\'m\\'\\nend;"
                    },
                    {
                        "username": "sourabh19",
                        "content": "UPDATE Salary\\nSet sex = CASE sex\\n            WHEN \\'m\\' THEN \\'f\\'\\n            WHEN \\'f\\' THEN \\'m\\'\\n            else \\'no\\'\\n            END;"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`update Salary\\nset sex = if(sex = \\'m\\', \\'f\\', \\'m\\')`"
                    }
                ]
            },
            {
                "id": 1842237,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hi everyone! Please check out my solution and let me know what you think. If you find it helpful, please consider upvoting it to show your support. Your feedback is greatly appreciated! Thank you.\\nURL: https://leetcode.com/problems/swap-salary/solutions/3339725/easy-solution-update-using-case-sql/\\nKeep Coding :)"
                    },
                    {
                        "username": "surajon727",
                        "content": "UPDATE Salary set sex =\\ncase when sex =\\'m\\' then \\'f\\'\\nelse \\'m\\' \\nend \\n"
                    },
                    {
                        "username": "chinmaydhok",
                        "content": "update Salary \\nset sex = \\nif (sex=\\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "user5810tH",
                        "content": "UPDATE Salary SET sex =\\nCASE sex\\nwhen \\'m\\' then \\'f\\'\\nwhen \\'f\\' then \\'m\\'\\nelse NULL\\nend;"
                    },
                    {
                        "username": "akanksha7252",
                        "content": "why the statement \\nselect id, name, if(sex=\\'f\\',\\'m\\',\\'f\\') as sex, salary from salary\\nis not working correctly."
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "UPDATE salary\\nSET     sex = CASE sex\\n              WHEN \\'f\\' THEN \\'m\\'\\n              ELSE \\'f\\'\\n              END;"
                    },
                    {
                        "username": "digitalghostdev",
                        "content": "I have a question,\\nThe official solution shows this:\\n\\n UPDATE salary\\nSET\\n    sex = CASE sex <-- why is the column reference here?\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\nEND;\\n\\nDoes anyone know why the `sex` column is referenced here AFTER the `CASE` statement?"
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi DEV,\\nAs per my understanding ,\\nThe \\'sex\\' column is given after \\'CASE\\' to give the CASE function the column in which it have to check the \\'WHEN\\' function.\\n\\n\"\\nUPDATE Salary SET sex = \\nCASE \\nWHEN sex = \\'f\\' then \\'m\\'\\nELSE \\'f\\' \\nEND ;\\n\"\\nIn the above solution that I have used , I have also done the same."
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "update Salary set sex = Case when sex like \\'m\\' then \\'f\\'\\nelse \\'m\\'\\nend;"
                    },
                    {
                        "username": "sourabh19",
                        "content": "UPDATE Salary\\nSet sex = CASE sex\\n            WHEN \\'m\\' THEN \\'f\\'\\n            WHEN \\'f\\' THEN \\'m\\'\\n            else \\'no\\'\\n            END;"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`update Salary\\nset sex = if(sex = \\'m\\', \\'f\\', \\'m\\')`"
                    }
                ]
            },
            {
                "id": 1833937,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hi everyone! Please check out my solution and let me know what you think. If you find it helpful, please consider upvoting it to show your support. Your feedback is greatly appreciated! Thank you.\\nURL: https://leetcode.com/problems/swap-salary/solutions/3339725/easy-solution-update-using-case-sql/\\nKeep Coding :)"
                    },
                    {
                        "username": "surajon727",
                        "content": "UPDATE Salary set sex =\\ncase when sex =\\'m\\' then \\'f\\'\\nelse \\'m\\' \\nend \\n"
                    },
                    {
                        "username": "chinmaydhok",
                        "content": "update Salary \\nset sex = \\nif (sex=\\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "user5810tH",
                        "content": "UPDATE Salary SET sex =\\nCASE sex\\nwhen \\'m\\' then \\'f\\'\\nwhen \\'f\\' then \\'m\\'\\nelse NULL\\nend;"
                    },
                    {
                        "username": "akanksha7252",
                        "content": "why the statement \\nselect id, name, if(sex=\\'f\\',\\'m\\',\\'f\\') as sex, salary from salary\\nis not working correctly."
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "UPDATE salary\\nSET     sex = CASE sex\\n              WHEN \\'f\\' THEN \\'m\\'\\n              ELSE \\'f\\'\\n              END;"
                    },
                    {
                        "username": "digitalghostdev",
                        "content": "I have a question,\\nThe official solution shows this:\\n\\n UPDATE salary\\nSET\\n    sex = CASE sex <-- why is the column reference here?\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\nEND;\\n\\nDoes anyone know why the `sex` column is referenced here AFTER the `CASE` statement?"
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi DEV,\\nAs per my understanding ,\\nThe \\'sex\\' column is given after \\'CASE\\' to give the CASE function the column in which it have to check the \\'WHEN\\' function.\\n\\n\"\\nUPDATE Salary SET sex = \\nCASE \\nWHEN sex = \\'f\\' then \\'m\\'\\nELSE \\'f\\' \\nEND ;\\n\"\\nIn the above solution that I have used , I have also done the same."
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "update Salary set sex = Case when sex like \\'m\\' then \\'f\\'\\nelse \\'m\\'\\nend;"
                    },
                    {
                        "username": "sourabh19",
                        "content": "UPDATE Salary\\nSet sex = CASE sex\\n            WHEN \\'m\\' THEN \\'f\\'\\n            WHEN \\'f\\' THEN \\'m\\'\\n            else \\'no\\'\\n            END;"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`update Salary\\nset sex = if(sex = \\'m\\', \\'f\\', \\'m\\')`"
                    }
                ]
            },
            {
                "id": 1805830,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hi everyone! Please check out my solution and let me know what you think. If you find it helpful, please consider upvoting it to show your support. Your feedback is greatly appreciated! Thank you.\\nURL: https://leetcode.com/problems/swap-salary/solutions/3339725/easy-solution-update-using-case-sql/\\nKeep Coding :)"
                    },
                    {
                        "username": "surajon727",
                        "content": "UPDATE Salary set sex =\\ncase when sex =\\'m\\' then \\'f\\'\\nelse \\'m\\' \\nend \\n"
                    },
                    {
                        "username": "chinmaydhok",
                        "content": "update Salary \\nset sex = \\nif (sex=\\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "user5810tH",
                        "content": "UPDATE Salary SET sex =\\nCASE sex\\nwhen \\'m\\' then \\'f\\'\\nwhen \\'f\\' then \\'m\\'\\nelse NULL\\nend;"
                    },
                    {
                        "username": "akanksha7252",
                        "content": "why the statement \\nselect id, name, if(sex=\\'f\\',\\'m\\',\\'f\\') as sex, salary from salary\\nis not working correctly."
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "UPDATE salary\\nSET     sex = CASE sex\\n              WHEN \\'f\\' THEN \\'m\\'\\n              ELSE \\'f\\'\\n              END;"
                    },
                    {
                        "username": "digitalghostdev",
                        "content": "I have a question,\\nThe official solution shows this:\\n\\n UPDATE salary\\nSET\\n    sex = CASE sex <-- why is the column reference here?\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\nEND;\\n\\nDoes anyone know why the `sex` column is referenced here AFTER the `CASE` statement?"
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi DEV,\\nAs per my understanding ,\\nThe \\'sex\\' column is given after \\'CASE\\' to give the CASE function the column in which it have to check the \\'WHEN\\' function.\\n\\n\"\\nUPDATE Salary SET sex = \\nCASE \\nWHEN sex = \\'f\\' then \\'m\\'\\nELSE \\'f\\' \\nEND ;\\n\"\\nIn the above solution that I have used , I have also done the same."
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "update Salary set sex = Case when sex like \\'m\\' then \\'f\\'\\nelse \\'m\\'\\nend;"
                    },
                    {
                        "username": "sourabh19",
                        "content": "UPDATE Salary\\nSet sex = CASE sex\\n            WHEN \\'m\\' THEN \\'f\\'\\n            WHEN \\'f\\' THEN \\'m\\'\\n            else \\'no\\'\\n            END;"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`update Salary\\nset sex = if(sex = \\'m\\', \\'f\\', \\'m\\')`"
                    }
                ]
            },
            {
                "id": 1803014,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hi everyone! Please check out my solution and let me know what you think. If you find it helpful, please consider upvoting it to show your support. Your feedback is greatly appreciated! Thank you.\\nURL: https://leetcode.com/problems/swap-salary/solutions/3339725/easy-solution-update-using-case-sql/\\nKeep Coding :)"
                    },
                    {
                        "username": "surajon727",
                        "content": "UPDATE Salary set sex =\\ncase when sex =\\'m\\' then \\'f\\'\\nelse \\'m\\' \\nend \\n"
                    },
                    {
                        "username": "chinmaydhok",
                        "content": "update Salary \\nset sex = \\nif (sex=\\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "user5810tH",
                        "content": "UPDATE Salary SET sex =\\nCASE sex\\nwhen \\'m\\' then \\'f\\'\\nwhen \\'f\\' then \\'m\\'\\nelse NULL\\nend;"
                    },
                    {
                        "username": "akanksha7252",
                        "content": "why the statement \\nselect id, name, if(sex=\\'f\\',\\'m\\',\\'f\\') as sex, salary from salary\\nis not working correctly."
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "UPDATE salary\\nSET     sex = CASE sex\\n              WHEN \\'f\\' THEN \\'m\\'\\n              ELSE \\'f\\'\\n              END;"
                    },
                    {
                        "username": "digitalghostdev",
                        "content": "I have a question,\\nThe official solution shows this:\\n\\n UPDATE salary\\nSET\\n    sex = CASE sex <-- why is the column reference here?\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\nEND;\\n\\nDoes anyone know why the `sex` column is referenced here AFTER the `CASE` statement?"
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi DEV,\\nAs per my understanding ,\\nThe \\'sex\\' column is given after \\'CASE\\' to give the CASE function the column in which it have to check the \\'WHEN\\' function.\\n\\n\"\\nUPDATE Salary SET sex = \\nCASE \\nWHEN sex = \\'f\\' then \\'m\\'\\nELSE \\'f\\' \\nEND ;\\n\"\\nIn the above solution that I have used , I have also done the same."
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "update Salary set sex = Case when sex like \\'m\\' then \\'f\\'\\nelse \\'m\\'\\nend;"
                    },
                    {
                        "username": "sourabh19",
                        "content": "UPDATE Salary\\nSet sex = CASE sex\\n            WHEN \\'m\\' THEN \\'f\\'\\n            WHEN \\'f\\' THEN \\'m\\'\\n            else \\'no\\'\\n            END;"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`update Salary\\nset sex = if(sex = \\'m\\', \\'f\\', \\'m\\')`"
                    }
                ]
            },
            {
                "id": 1790950,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hi everyone! Please check out my solution and let me know what you think. If you find it helpful, please consider upvoting it to show your support. Your feedback is greatly appreciated! Thank you.\\nURL: https://leetcode.com/problems/swap-salary/solutions/3339725/easy-solution-update-using-case-sql/\\nKeep Coding :)"
                    },
                    {
                        "username": "surajon727",
                        "content": "UPDATE Salary set sex =\\ncase when sex =\\'m\\' then \\'f\\'\\nelse \\'m\\' \\nend \\n"
                    },
                    {
                        "username": "chinmaydhok",
                        "content": "update Salary \\nset sex = \\nif (sex=\\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "user5810tH",
                        "content": "UPDATE Salary SET sex =\\nCASE sex\\nwhen \\'m\\' then \\'f\\'\\nwhen \\'f\\' then \\'m\\'\\nelse NULL\\nend;"
                    },
                    {
                        "username": "akanksha7252",
                        "content": "why the statement \\nselect id, name, if(sex=\\'f\\',\\'m\\',\\'f\\') as sex, salary from salary\\nis not working correctly."
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "UPDATE salary\\nSET     sex = CASE sex\\n              WHEN \\'f\\' THEN \\'m\\'\\n              ELSE \\'f\\'\\n              END;"
                    },
                    {
                        "username": "digitalghostdev",
                        "content": "I have a question,\\nThe official solution shows this:\\n\\n UPDATE salary\\nSET\\n    sex = CASE sex <-- why is the column reference here?\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\nEND;\\n\\nDoes anyone know why the `sex` column is referenced here AFTER the `CASE` statement?"
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi DEV,\\nAs per my understanding ,\\nThe \\'sex\\' column is given after \\'CASE\\' to give the CASE function the column in which it have to check the \\'WHEN\\' function.\\n\\n\"\\nUPDATE Salary SET sex = \\nCASE \\nWHEN sex = \\'f\\' then \\'m\\'\\nELSE \\'f\\' \\nEND ;\\n\"\\nIn the above solution that I have used , I have also done the same."
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "update Salary set sex = Case when sex like \\'m\\' then \\'f\\'\\nelse \\'m\\'\\nend;"
                    },
                    {
                        "username": "sourabh19",
                        "content": "UPDATE Salary\\nSet sex = CASE sex\\n            WHEN \\'m\\' THEN \\'f\\'\\n            WHEN \\'f\\' THEN \\'m\\'\\n            else \\'no\\'\\n            END;"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`update Salary\\nset sex = if(sex = \\'m\\', \\'f\\', \\'m\\')`"
                    }
                ]
            },
            {
                "id": 1782534,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hi everyone! Please check out my solution and let me know what you think. If you find it helpful, please consider upvoting it to show your support. Your feedback is greatly appreciated! Thank you.\\nURL: https://leetcode.com/problems/swap-salary/solutions/3339725/easy-solution-update-using-case-sql/\\nKeep Coding :)"
                    },
                    {
                        "username": "surajon727",
                        "content": "UPDATE Salary set sex =\\ncase when sex =\\'m\\' then \\'f\\'\\nelse \\'m\\' \\nend \\n"
                    },
                    {
                        "username": "chinmaydhok",
                        "content": "update Salary \\nset sex = \\nif (sex=\\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "user5810tH",
                        "content": "UPDATE Salary SET sex =\\nCASE sex\\nwhen \\'m\\' then \\'f\\'\\nwhen \\'f\\' then \\'m\\'\\nelse NULL\\nend;"
                    },
                    {
                        "username": "akanksha7252",
                        "content": "why the statement \\nselect id, name, if(sex=\\'f\\',\\'m\\',\\'f\\') as sex, salary from salary\\nis not working correctly."
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "UPDATE salary\\nSET     sex = CASE sex\\n              WHEN \\'f\\' THEN \\'m\\'\\n              ELSE \\'f\\'\\n              END;"
                    },
                    {
                        "username": "digitalghostdev",
                        "content": "I have a question,\\nThe official solution shows this:\\n\\n UPDATE salary\\nSET\\n    sex = CASE sex <-- why is the column reference here?\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\nEND;\\n\\nDoes anyone know why the `sex` column is referenced here AFTER the `CASE` statement?"
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi DEV,\\nAs per my understanding ,\\nThe \\'sex\\' column is given after \\'CASE\\' to give the CASE function the column in which it have to check the \\'WHEN\\' function.\\n\\n\"\\nUPDATE Salary SET sex = \\nCASE \\nWHEN sex = \\'f\\' then \\'m\\'\\nELSE \\'f\\' \\nEND ;\\n\"\\nIn the above solution that I have used , I have also done the same."
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "update Salary set sex = Case when sex like \\'m\\' then \\'f\\'\\nelse \\'m\\'\\nend;"
                    },
                    {
                        "username": "sourabh19",
                        "content": "UPDATE Salary\\nSet sex = CASE sex\\n            WHEN \\'m\\' THEN \\'f\\'\\n            WHEN \\'f\\' THEN \\'m\\'\\n            else \\'no\\'\\n            END;"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`update Salary\\nset sex = if(sex = \\'m\\', \\'f\\', \\'m\\')`"
                    }
                ]
            },
            {
                "id": 1780742,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hi everyone! Please check out my solution and let me know what you think. If you find it helpful, please consider upvoting it to show your support. Your feedback is greatly appreciated! Thank you.\\nURL: https://leetcode.com/problems/swap-salary/solutions/3339725/easy-solution-update-using-case-sql/\\nKeep Coding :)"
                    },
                    {
                        "username": "surajon727",
                        "content": "UPDATE Salary set sex =\\ncase when sex =\\'m\\' then \\'f\\'\\nelse \\'m\\' \\nend \\n"
                    },
                    {
                        "username": "chinmaydhok",
                        "content": "update Salary \\nset sex = \\nif (sex=\\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "user5810tH",
                        "content": "UPDATE Salary SET sex =\\nCASE sex\\nwhen \\'m\\' then \\'f\\'\\nwhen \\'f\\' then \\'m\\'\\nelse NULL\\nend;"
                    },
                    {
                        "username": "akanksha7252",
                        "content": "why the statement \\nselect id, name, if(sex=\\'f\\',\\'m\\',\\'f\\') as sex, salary from salary\\nis not working correctly."
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "UPDATE salary\\nSET     sex = CASE sex\\n              WHEN \\'f\\' THEN \\'m\\'\\n              ELSE \\'f\\'\\n              END;"
                    },
                    {
                        "username": "digitalghostdev",
                        "content": "I have a question,\\nThe official solution shows this:\\n\\n UPDATE salary\\nSET\\n    sex = CASE sex <-- why is the column reference here?\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\nEND;\\n\\nDoes anyone know why the `sex` column is referenced here AFTER the `CASE` statement?"
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi DEV,\\nAs per my understanding ,\\nThe \\'sex\\' column is given after \\'CASE\\' to give the CASE function the column in which it have to check the \\'WHEN\\' function.\\n\\n\"\\nUPDATE Salary SET sex = \\nCASE \\nWHEN sex = \\'f\\' then \\'m\\'\\nELSE \\'f\\' \\nEND ;\\n\"\\nIn the above solution that I have used , I have also done the same."
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "update Salary set sex = Case when sex like \\'m\\' then \\'f\\'\\nelse \\'m\\'\\nend;"
                    },
                    {
                        "username": "sourabh19",
                        "content": "UPDATE Salary\\nSet sex = CASE sex\\n            WHEN \\'m\\' THEN \\'f\\'\\n            WHEN \\'f\\' THEN \\'m\\'\\n            else \\'no\\'\\n            END;"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`update Salary\\nset sex = if(sex = \\'m\\', \\'f\\', \\'m\\')`"
                    }
                ]
            },
            {
                "id": 1774222,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hi everyone! Please check out my solution and let me know what you think. If you find it helpful, please consider upvoting it to show your support. Your feedback is greatly appreciated! Thank you.\\nURL: https://leetcode.com/problems/swap-salary/solutions/3339725/easy-solution-update-using-case-sql/\\nKeep Coding :)"
                    },
                    {
                        "username": "surajon727",
                        "content": "UPDATE Salary set sex =\\ncase when sex =\\'m\\' then \\'f\\'\\nelse \\'m\\' \\nend \\n"
                    },
                    {
                        "username": "chinmaydhok",
                        "content": "update Salary \\nset sex = \\nif (sex=\\'m\\',\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "user5810tH",
                        "content": "UPDATE Salary SET sex =\\nCASE sex\\nwhen \\'m\\' then \\'f\\'\\nwhen \\'f\\' then \\'m\\'\\nelse NULL\\nend;"
                    },
                    {
                        "username": "akanksha7252",
                        "content": "why the statement \\nselect id, name, if(sex=\\'f\\',\\'m\\',\\'f\\') as sex, salary from salary\\nis not working correctly."
                    },
                    {
                        "username": "prasannaguda62",
                        "content": "UPDATE salary\\nSET     sex = CASE sex\\n              WHEN \\'f\\' THEN \\'m\\'\\n              ELSE \\'f\\'\\n              END;"
                    },
                    {
                        "username": "digitalghostdev",
                        "content": "I have a question,\\nThe official solution shows this:\\n\\n UPDATE salary\\nSET\\n    sex = CASE sex <-- why is the column reference here?\\n        WHEN \\'m\\' THEN \\'f\\'\\n        ELSE \\'m\\'\\nEND;\\n\\nDoes anyone know why the `sex` column is referenced here AFTER the `CASE` statement?"
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi DEV,\\nAs per my understanding ,\\nThe \\'sex\\' column is given after \\'CASE\\' to give the CASE function the column in which it have to check the \\'WHEN\\' function.\\n\\n\"\\nUPDATE Salary SET sex = \\nCASE \\nWHEN sex = \\'f\\' then \\'m\\'\\nELSE \\'f\\' \\nEND ;\\n\"\\nIn the above solution that I have used , I have also done the same."
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "update Salary set sex = Case when sex like \\'m\\' then \\'f\\'\\nelse \\'m\\'\\nend;"
                    },
                    {
                        "username": "sourabh19",
                        "content": "UPDATE Salary\\nSet sex = CASE sex\\n            WHEN \\'m\\' THEN \\'f\\'\\n            WHEN \\'f\\' THEN \\'m\\'\\n            else \\'no\\'\\n            END;"
                    },
                    {
                        "username": "pth_1641",
                        "content": "`update Salary\\nset sex = if(sex = \\'m\\', \\'f\\', \\'m\\')`"
                    }
                ]
            },
            {
                "id": 1761122,
                "content": [
                    {
                        "username": "jsycfym",
                        "content": "update Salary\\nset sex =\\ncase\\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "TienNg21",
                        "content": "update salary\\nset sex = if(sex = \\'f\\', \\'m\\', \\'f\\')\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "update Salary\\nset sex = case \\nsex when \\'f\\' then \\'m\\'\\nwhen \\'m\\'then \\'f\\'\\nelse sex\\nend \\nwhere sex in (\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "update Salary\\nset sex = case\\n   when sex = \\'m\\' then \\'f\\'\\n   when sex = \\'f\\' then \\'m\\'\\n   end;"
                    },
                    {
                        "username": "Cyril195",
                        "content": "my solution \\n`update salary set sex = if(sex = \\'m\\', \\'f\\',\\'m\\')`"
                    },
                    {
                        "username": "user0609P",
                        "content": "Why we are using sex = CASE sex and just CASE?"
                    },
                    {
                        "username": "obayed",
                        "content": "Solution in MS SQL Server  \\n==============\\nUpdate Salary set sex = IIF(sex=\\'m\\',\\'f\\',\\'m\\');\\n                            "
                    },
                    {
                        "username": "husein14",
                        "content": "update salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "UPDATE Salary SET sex = CASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' END"
                    },
                    {
                        "username": "shahrahil",
                        "content": "--another solution by using simple decode function\\n\\nupdate salary set sex decode(sex,\\'f\\',\\'m\\',\\'m\\',\\'f\\',\\'others\\');"
                    }
                ]
            },
            {
                "id": 1750695,
                "content": [
                    {
                        "username": "jsycfym",
                        "content": "update Salary\\nset sex =\\ncase\\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "TienNg21",
                        "content": "update salary\\nset sex = if(sex = \\'f\\', \\'m\\', \\'f\\')\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "update Salary\\nset sex = case \\nsex when \\'f\\' then \\'m\\'\\nwhen \\'m\\'then \\'f\\'\\nelse sex\\nend \\nwhere sex in (\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "update Salary\\nset sex = case\\n   when sex = \\'m\\' then \\'f\\'\\n   when sex = \\'f\\' then \\'m\\'\\n   end;"
                    },
                    {
                        "username": "Cyril195",
                        "content": "my solution \\n`update salary set sex = if(sex = \\'m\\', \\'f\\',\\'m\\')`"
                    },
                    {
                        "username": "user0609P",
                        "content": "Why we are using sex = CASE sex and just CASE?"
                    },
                    {
                        "username": "obayed",
                        "content": "Solution in MS SQL Server  \\n==============\\nUpdate Salary set sex = IIF(sex=\\'m\\',\\'f\\',\\'m\\');\\n                            "
                    },
                    {
                        "username": "husein14",
                        "content": "update salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "UPDATE Salary SET sex = CASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' END"
                    },
                    {
                        "username": "shahrahil",
                        "content": "--another solution by using simple decode function\\n\\nupdate salary set sex decode(sex,\\'f\\',\\'m\\',\\'m\\',\\'f\\',\\'others\\');"
                    }
                ]
            },
            {
                "id": 1725460,
                "content": [
                    {
                        "username": "jsycfym",
                        "content": "update Salary\\nset sex =\\ncase\\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "TienNg21",
                        "content": "update salary\\nset sex = if(sex = \\'f\\', \\'m\\', \\'f\\')\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "update Salary\\nset sex = case \\nsex when \\'f\\' then \\'m\\'\\nwhen \\'m\\'then \\'f\\'\\nelse sex\\nend \\nwhere sex in (\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "update Salary\\nset sex = case\\n   when sex = \\'m\\' then \\'f\\'\\n   when sex = \\'f\\' then \\'m\\'\\n   end;"
                    },
                    {
                        "username": "Cyril195",
                        "content": "my solution \\n`update salary set sex = if(sex = \\'m\\', \\'f\\',\\'m\\')`"
                    },
                    {
                        "username": "user0609P",
                        "content": "Why we are using sex = CASE sex and just CASE?"
                    },
                    {
                        "username": "obayed",
                        "content": "Solution in MS SQL Server  \\n==============\\nUpdate Salary set sex = IIF(sex=\\'m\\',\\'f\\',\\'m\\');\\n                            "
                    },
                    {
                        "username": "husein14",
                        "content": "update salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "UPDATE Salary SET sex = CASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' END"
                    },
                    {
                        "username": "shahrahil",
                        "content": "--another solution by using simple decode function\\n\\nupdate salary set sex decode(sex,\\'f\\',\\'m\\',\\'m\\',\\'f\\',\\'others\\');"
                    }
                ]
            },
            {
                "id": 1708421,
                "content": [
                    {
                        "username": "jsycfym",
                        "content": "update Salary\\nset sex =\\ncase\\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "TienNg21",
                        "content": "update salary\\nset sex = if(sex = \\'f\\', \\'m\\', \\'f\\')\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "update Salary\\nset sex = case \\nsex when \\'f\\' then \\'m\\'\\nwhen \\'m\\'then \\'f\\'\\nelse sex\\nend \\nwhere sex in (\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "update Salary\\nset sex = case\\n   when sex = \\'m\\' then \\'f\\'\\n   when sex = \\'f\\' then \\'m\\'\\n   end;"
                    },
                    {
                        "username": "Cyril195",
                        "content": "my solution \\n`update salary set sex = if(sex = \\'m\\', \\'f\\',\\'m\\')`"
                    },
                    {
                        "username": "user0609P",
                        "content": "Why we are using sex = CASE sex and just CASE?"
                    },
                    {
                        "username": "obayed",
                        "content": "Solution in MS SQL Server  \\n==============\\nUpdate Salary set sex = IIF(sex=\\'m\\',\\'f\\',\\'m\\');\\n                            "
                    },
                    {
                        "username": "husein14",
                        "content": "update salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "UPDATE Salary SET sex = CASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' END"
                    },
                    {
                        "username": "shahrahil",
                        "content": "--another solution by using simple decode function\\n\\nupdate salary set sex decode(sex,\\'f\\',\\'m\\',\\'m\\',\\'f\\',\\'others\\');"
                    }
                ]
            },
            {
                "id": 1701224,
                "content": [
                    {
                        "username": "jsycfym",
                        "content": "update Salary\\nset sex =\\ncase\\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "TienNg21",
                        "content": "update salary\\nset sex = if(sex = \\'f\\', \\'m\\', \\'f\\')\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "update Salary\\nset sex = case \\nsex when \\'f\\' then \\'m\\'\\nwhen \\'m\\'then \\'f\\'\\nelse sex\\nend \\nwhere sex in (\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "update Salary\\nset sex = case\\n   when sex = \\'m\\' then \\'f\\'\\n   when sex = \\'f\\' then \\'m\\'\\n   end;"
                    },
                    {
                        "username": "Cyril195",
                        "content": "my solution \\n`update salary set sex = if(sex = \\'m\\', \\'f\\',\\'m\\')`"
                    },
                    {
                        "username": "user0609P",
                        "content": "Why we are using sex = CASE sex and just CASE?"
                    },
                    {
                        "username": "obayed",
                        "content": "Solution in MS SQL Server  \\n==============\\nUpdate Salary set sex = IIF(sex=\\'m\\',\\'f\\',\\'m\\');\\n                            "
                    },
                    {
                        "username": "husein14",
                        "content": "update salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "UPDATE Salary SET sex = CASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' END"
                    },
                    {
                        "username": "shahrahil",
                        "content": "--another solution by using simple decode function\\n\\nupdate salary set sex decode(sex,\\'f\\',\\'m\\',\\'m\\',\\'f\\',\\'others\\');"
                    }
                ]
            },
            {
                "id": 1694199,
                "content": [
                    {
                        "username": "jsycfym",
                        "content": "update Salary\\nset sex =\\ncase\\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "TienNg21",
                        "content": "update salary\\nset sex = if(sex = \\'f\\', \\'m\\', \\'f\\')\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "update Salary\\nset sex = case \\nsex when \\'f\\' then \\'m\\'\\nwhen \\'m\\'then \\'f\\'\\nelse sex\\nend \\nwhere sex in (\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "update Salary\\nset sex = case\\n   when sex = \\'m\\' then \\'f\\'\\n   when sex = \\'f\\' then \\'m\\'\\n   end;"
                    },
                    {
                        "username": "Cyril195",
                        "content": "my solution \\n`update salary set sex = if(sex = \\'m\\', \\'f\\',\\'m\\')`"
                    },
                    {
                        "username": "user0609P",
                        "content": "Why we are using sex = CASE sex and just CASE?"
                    },
                    {
                        "username": "obayed",
                        "content": "Solution in MS SQL Server  \\n==============\\nUpdate Salary set sex = IIF(sex=\\'m\\',\\'f\\',\\'m\\');\\n                            "
                    },
                    {
                        "username": "husein14",
                        "content": "update salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "UPDATE Salary SET sex = CASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' END"
                    },
                    {
                        "username": "shahrahil",
                        "content": "--another solution by using simple decode function\\n\\nupdate salary set sex decode(sex,\\'f\\',\\'m\\',\\'m\\',\\'f\\',\\'others\\');"
                    }
                ]
            },
            {
                "id": 1685325,
                "content": [
                    {
                        "username": "jsycfym",
                        "content": "update Salary\\nset sex =\\ncase\\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "TienNg21",
                        "content": "update salary\\nset sex = if(sex = \\'f\\', \\'m\\', \\'f\\')\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "update Salary\\nset sex = case \\nsex when \\'f\\' then \\'m\\'\\nwhen \\'m\\'then \\'f\\'\\nelse sex\\nend \\nwhere sex in (\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "update Salary\\nset sex = case\\n   when sex = \\'m\\' then \\'f\\'\\n   when sex = \\'f\\' then \\'m\\'\\n   end;"
                    },
                    {
                        "username": "Cyril195",
                        "content": "my solution \\n`update salary set sex = if(sex = \\'m\\', \\'f\\',\\'m\\')`"
                    },
                    {
                        "username": "user0609P",
                        "content": "Why we are using sex = CASE sex and just CASE?"
                    },
                    {
                        "username": "obayed",
                        "content": "Solution in MS SQL Server  \\n==============\\nUpdate Salary set sex = IIF(sex=\\'m\\',\\'f\\',\\'m\\');\\n                            "
                    },
                    {
                        "username": "husein14",
                        "content": "update salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "UPDATE Salary SET sex = CASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' END"
                    },
                    {
                        "username": "shahrahil",
                        "content": "--another solution by using simple decode function\\n\\nupdate salary set sex decode(sex,\\'f\\',\\'m\\',\\'m\\',\\'f\\',\\'others\\');"
                    }
                ]
            },
            {
                "id": 1673543,
                "content": [
                    {
                        "username": "jsycfym",
                        "content": "update Salary\\nset sex =\\ncase\\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "TienNg21",
                        "content": "update salary\\nset sex = if(sex = \\'f\\', \\'m\\', \\'f\\')\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "update Salary\\nset sex = case \\nsex when \\'f\\' then \\'m\\'\\nwhen \\'m\\'then \\'f\\'\\nelse sex\\nend \\nwhere sex in (\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "update Salary\\nset sex = case\\n   when sex = \\'m\\' then \\'f\\'\\n   when sex = \\'f\\' then \\'m\\'\\n   end;"
                    },
                    {
                        "username": "Cyril195",
                        "content": "my solution \\n`update salary set sex = if(sex = \\'m\\', \\'f\\',\\'m\\')`"
                    },
                    {
                        "username": "user0609P",
                        "content": "Why we are using sex = CASE sex and just CASE?"
                    },
                    {
                        "username": "obayed",
                        "content": "Solution in MS SQL Server  \\n==============\\nUpdate Salary set sex = IIF(sex=\\'m\\',\\'f\\',\\'m\\');\\n                            "
                    },
                    {
                        "username": "husein14",
                        "content": "update salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "UPDATE Salary SET sex = CASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' END"
                    },
                    {
                        "username": "shahrahil",
                        "content": "--another solution by using simple decode function\\n\\nupdate salary set sex decode(sex,\\'f\\',\\'m\\',\\'m\\',\\'f\\',\\'others\\');"
                    }
                ]
            },
            {
                "id": 1644752,
                "content": [
                    {
                        "username": "jsycfym",
                        "content": "update Salary\\nset sex =\\ncase\\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "TienNg21",
                        "content": "update salary\\nset sex = if(sex = \\'f\\', \\'m\\', \\'f\\')\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "update Salary\\nset sex = case \\nsex when \\'f\\' then \\'m\\'\\nwhen \\'m\\'then \\'f\\'\\nelse sex\\nend \\nwhere sex in (\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "update Salary\\nset sex = case\\n   when sex = \\'m\\' then \\'f\\'\\n   when sex = \\'f\\' then \\'m\\'\\n   end;"
                    },
                    {
                        "username": "Cyril195",
                        "content": "my solution \\n`update salary set sex = if(sex = \\'m\\', \\'f\\',\\'m\\')`"
                    },
                    {
                        "username": "user0609P",
                        "content": "Why we are using sex = CASE sex and just CASE?"
                    },
                    {
                        "username": "obayed",
                        "content": "Solution in MS SQL Server  \\n==============\\nUpdate Salary set sex = IIF(sex=\\'m\\',\\'f\\',\\'m\\');\\n                            "
                    },
                    {
                        "username": "husein14",
                        "content": "update salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "UPDATE Salary SET sex = CASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' END"
                    },
                    {
                        "username": "shahrahil",
                        "content": "--another solution by using simple decode function\\n\\nupdate salary set sex decode(sex,\\'f\\',\\'m\\',\\'m\\',\\'f\\',\\'others\\');"
                    }
                ]
            },
            {
                "id": 1640888,
                "content": [
                    {
                        "username": "jsycfym",
                        "content": "update Salary\\nset sex =\\ncase\\nwhen sex =\\'m\\' then \\'f\\'\\nwhen sex=\\'f\\' then \\'m\\'\\nend"
                    },
                    {
                        "username": "TienNg21",
                        "content": "update salary\\nset sex = if(sex = \\'f\\', \\'m\\', \\'f\\')\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "update Salary\\nset sex = case \\nsex when \\'f\\' then \\'m\\'\\nwhen \\'m\\'then \\'f\\'\\nelse sex\\nend \\nwhere sex in (\\'f\\',\\'m\\')"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "update Salary\\nset sex = case\\n   when sex = \\'m\\' then \\'f\\'\\n   when sex = \\'f\\' then \\'m\\'\\n   end;"
                    },
                    {
                        "username": "Cyril195",
                        "content": "my solution \\n`update salary set sex = if(sex = \\'m\\', \\'f\\',\\'m\\')`"
                    },
                    {
                        "username": "user0609P",
                        "content": "Why we are using sex = CASE sex and just CASE?"
                    },
                    {
                        "username": "obayed",
                        "content": "Solution in MS SQL Server  \\n==============\\nUpdate Salary set sex = IIF(sex=\\'m\\',\\'f\\',\\'m\\');\\n                            "
                    },
                    {
                        "username": "husein14",
                        "content": "update salary set sex = if(sex=\\'m\\',\\'f\\',\\'m\\');\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "UPDATE Salary SET sex = CASE WHEN sex = \\'m\\' THEN \\'f\\' ELSE \\'m\\' END"
                    },
                    {
                        "username": "shahrahil",
                        "content": "--another solution by using simple decode function\\n\\nupdate salary set sex decode(sex,\\'f\\',\\'m\\',\\'m\\',\\'f\\',\\'others\\');"
                    }
                ]
            }
        ]
    }
]