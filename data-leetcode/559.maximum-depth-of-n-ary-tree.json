[
    {
        "title": "Spiral Matrix II",
        "question_content": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n&nbsp;\nExample 1:\n\nInput: n = 3\nOutput: [[1,2,3],[8,9,4],[7,6,5]]\n\nExample 2:\n\nInput: n = 1\nOutput: [[1]]\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 20",
        "solutions": [
            {
                "id": 22282,
                "title": "4-9-lines-python-solutions",
                "content": "**Solution 1: *Build it inside-out*** - 44 ms, 5 lines\\n\\nStart with the empty matrix, add the numbers in reverse order until we added the number 1. Always rotate the matrix clockwise and add a top row:\\n\\n        ||  =>  |9|  =>  |8|      |6 7|      |4 5|      |1 2 3|\\n                         |9|  =>  |9 8|  =>  |9 6|  =>  |8 9 4|\\n                                             |8 7|      |7 6 5|\\n\\nThe code:\\n\\n    def generateMatrix(self, n):\\n        A, lo = [], n*n+1\\n        while lo > 1:\\n            lo, hi = lo - len(A), lo\\n            A = [range(lo, hi)] + zip(*A[::-1])\\n        return A\\n\\nWhile this isn't O(n^2), it's actually quite fast, presumably due to me not doing much in Python but relying on `zip` and `range` and `+` being fast. I got it accepted in 44 ms, matching the fastest time for recent Python submissions (according to the submission detail page).\\n\\n---\\n\\n**Solution 2: *Ugly inside-out*** - 48 ms, 4 lines\\n\\nSame as solution 1, but without helper variables. Saves a line, but makes it ugly. Also, because I access A[0][0], I had to handle the n=0 case differently.\\n\\n    def generateMatrix(self, n):\\n        A = [[n*n]]\\n        while A[0][0] > 1:\\n            A = [range(A[0][0] - len(A), A[0][0])] + zip(*A[::-1])\\n        return A * (n>0)\\n\\n---\\n\\n**Solution 3: *Walk the spiral*** - 52 ms, 9 lines\\n\\nInitialize the matrix with zeros, then walk the spiral path and write the numbers 1 to n*n. Make a right turn when the cell ahead is already non-zero.\\n\\n    def generateMatrix(self, n):\\n        A = [[0] * n for _ in range(n)]\\n        i, j, di, dj = 0, 0, 0, 1\\n        for k in xrange(n*n):\\n            A[i][j] = k + 1\\n            if A[(i+di)%n][(j+dj)%n]:\\n                di, dj = dj, -di\\n            i += di\\n            j += dj\\n        return A",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution 1: *Build it inside-out*** - 44 ms, 5 lines\\n\\nStart with the empty matrix, add the numbers in reverse order until we added the number 1. Always rotate the matrix clockwise and add a top row:\\n\\n        ||  =>  |9|  =>  |8|      |6 7|      |4 5|      |1 2 3|\\n                         |9|  =>  |9 8|  =>  |9 6|  =>  |8 9 4|\\n                                             |8 7|      |7 6 5|\\n\\nThe code:\\n\\n    def generateMatrix(self, n):\\n        A, lo = [], n*n+1\\n        while lo > 1:\\n            lo, hi = lo - len(A), lo\\n            A = [range(lo, hi)] + zip(*A[::-1])\\n        return A\\n\\nWhile this isn't O(n^2), it's actually quite fast, presumably due to me not doing much in Python but relying on `zip` and `range` and `+` being fast. I got it accepted in 44 ms, matching the fastest time for recent Python submissions (according to the submission detail page).\\n\\n---\\n\\n**Solution 2: *Ugly inside-out*** - 48 ms, 4 lines\\n\\nSame as solution 1, but without helper variables. Saves a line, but makes it ugly. Also, because I access A[0][0], I had to handle the n=0 case differently.\\n\\n    def generateMatrix(self, n):\\n        A = [[n*n]]\\n        while A[0][0] > 1:\\n            A = [range(A[0][0] - len(A), A[0][0])] + zip(*A[::-1])\\n        return A * (n>0)\\n\\n---\\n\\n**Solution 3: *Walk the spiral*** - 52 ms, 9 lines\\n\\nInitialize the matrix with zeros, then walk the spiral path and write the numbers 1 to n*n. Make a right turn when the cell ahead is already non-zero.\\n\\n    def generateMatrix(self, n):\\n        A = [[0] * n for _ in range(n)]\\n        i, j, di, dj = 0, 0, 0, 1\\n        for k in xrange(n*n):\\n            A[i][j] = k + 1\\n            if A[(i+di)%n][(j+dj)%n]:\\n                di, dj = dj, -di\\n            i += di\\n            j += dj\\n        return A",
                "codeTag": "Python3"
            },
            {
                "id": 22289,
                "title": "my-super-simple-solution-can-be-used-for-both-spiral-matrix-i-and-ii",
                "content": "This is my solution for Spiral Matrix I, [https://oj.leetcode.com/discuss/12228/super-simple-and-easy-to-understand-solution][1]. If you can understand that, this one is a no brainer :)\\n\\nGuess what? I just made several lines of change (with comment \"//change\") from that and I have the following AC code:\\n\\n    public class Solution {\\n        public int[][] generateMatrix(int n) {\\n            // Declaration\\n            int[][] matrix = new int[n][n];\\n            \\n            // Edge Case\\n            if (n == 0) {\\n                return matrix;\\n            }\\n            \\n            // Normal Case\\n            int rowStart = 0;\\n            int rowEnd = n-1;\\n            int colStart = 0;\\n            int colEnd = n-1;\\n            int num = 1; //change\\n            \\n            while (rowStart <= rowEnd && colStart <= colEnd) {\\n                for (int i = colStart; i <= colEnd; i ++) {\\n                    matrix[rowStart][i] = num ++; //change\\n                }\\n                rowStart ++;\\n                \\n                for (int i = rowStart; i <= rowEnd; i ++) {\\n                    matrix[i][colEnd] = num ++; //change\\n                }\\n                colEnd --;\\n                \\n                for (int i = colEnd; i >= colStart; i --) {\\n                    if (rowStart <= rowEnd)\\n                        matrix[rowEnd][i] = num ++; //change\\n                }\\n                rowEnd --;\\n                \\n                for (int i = rowEnd; i >= rowStart; i --) {\\n                    if (colStart <= colEnd)\\n                        matrix[i][colStart] = num ++; //change\\n                }\\n                colStart ++;\\n            }\\n            \\n            return matrix;\\n        }\\n    }\\n\\nObviously, you could merge colStart and colEnd into rowStart and rowEnd because it is a square matrix. But this is easily extensible to matrices that are m*n.\\n\\nHope this helps :)\\n\\n\\n  [1]: https://oj.leetcode.com/discuss/12228/super-simple-and-easy-to-understand-solution",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int[][] generateMatrix(int n) {\\n            // Declaration\\n            int[][] matrix = new int[n][n];\\n            \\n            // Edge Case\\n            if (n == 0) {\\n                return matrix;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 963128,
                "title": "python-rotate-when-need-explained",
                "content": "Let us notice one clue property about our spiral matrix: first we need to go to the right and rotate clockwise 90 degrees, then we go down and again when we reached bottom, we rotate 90 degrees clockwise and so on. So, all we need to do is to rotate 90 degrees clockwise when we need:\\n1. When we reached border of our matrix\\n2. When we reached cell which is already filled.\\n\\nLet `x, y` be coordinates on our `grid` and `dx, dy` is current direction we need to move. In geometrical sense, rotate by `90` degrees clockwise is written as `dx, dy = -dy, dx`.\\n\\nNote, that `matrix[y][x]` is cell with coordinates `(x,y)`, which is not completely obvious.\\n\\n**Complexity**: time complexity is `O(n^2)`, we process each element once. Space complexity is `O(n^2)` as well.\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n):\\n        matrix = [[0] * n for _ in range(n)]\\n        x, y, dx, dy = 0, 0, 1, 0\\n        for i in range(n*n):\\n            matrix[y][x] = i + 1\\n            if not 0 <= x + dx < n or not 0 <= y + dy < n or matrix[y+dy][x+dx] != 0:\\n                dx, dy = -dy, dx\\n            x, y = x + dx, y + dy\\n        return matrix\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n):\\n        matrix = [[0] * n for _ in range(n)]\\n        x, y, dx, dy = 0, 0, 1, 0\\n        for i in range(n*n):\\n            matrix[y][x] = i + 1\\n            if not 0 <= x + dx < n or not 0 <= y + dy < n or matrix[y+dy][x+dx] != 0:\\n                dx, dy = -dy, dx\\n            x, y = x + dx, y + dy\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22309,
                "title": "simple-c-solution-with-explaination",
                "content": "   \\n    class Solution {\\n        public:\\n            vector<vector<int> > generateMatrix(int n) {\\n                vector<vector<int> > ret( n, vector<int>(n) );\\n            \\tint k = 1, i = 0;\\n            \\twhile( k <= n * n )\\n            \\t{\\n            \\t\\tint j = i;\\n                        // four steps\\n            \\t\\twhile( j < n - i )             // 1. horizonal, left to right\\n            \\t\\t\\tret[i][j++] = k++;\\n            \\t\\tj = i + 1;\\n            \\t\\twhile( j < n - i )             // 2. vertical, top to bottom\\n            \\t\\t\\tret[j++][n-i-1] = k++;\\n            \\t\\tj = n - i - 2;\\n            \\t\\twhile( j > i )                  // 3. horizonal, right to left \\n            \\t\\t\\tret[n-i-1][j--] = k++;\\n            \\t\\tj = n - i - 1;\\n            \\t\\twhile( j > i )                  // 4. vertical, bottom to  top \\n            \\t\\t\\tret[j--][i] = k++;\\n            \\t\\ti++;      // next loop\\n            \\t}\\n            \\treturn ret;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            vector<vector<int> > generateMatrix(int n) {\\n                vector<vector<int> > ret( n, vector<int>(n) );\\n            \\tint k = 1, i = 0;\\n            \\twhile( k <= n * n )\\n            \\t{\\n            \\t\\tint j = i;\\n                        // four steps\\n            \\t\\twhile( j < n - i )             // 1. horizonal, left to right\\n            \\t\\t\\tret[i][j++] = k++;\\n            \\t\\tj = i + 1;\\n            \\t\\twhile( j < n - i )             // 2. vertical, top to bottom\\n            \\t\\t\\tret[j++][n-i-1] = k++;\\n            \\t\\tj = n - i - 2;\\n            \\t\\twhile( j > i )                  // 3. horizonal, right to left \\n            \\t\\t\\tret[n-i-1][j--] = k++;\\n            \\t\\tj = n - i - 1;\\n            \\t\\twhile( j > i )                  // 4. vertical, bottom to  top \\n            \\t\\t\\tret[j--][i] = k++;\\n            \\t\\ti++;      // next loop\\n            \\t}",
                "codeTag": "Java"
            },
            {
                "id": 1941068,
                "title": "c-0ms-100-easy-to-understand",
                "content": "# 59. Spiral Matrix II\\n**KNOCKCAT**\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Please Upvote if it helps\\u2B06\\uFE0F\\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**ALGORITHM**\\n* We **have to fill the matrix layer by layer in four direction**.\\n* From **left to right** \\u27A1\\uFE0F:\\n\\t*  the **row will remain constant** while **column is updated till reaches n-1**.\\n* From **Top to bottom** \\u2B07\\uFE0F(moving down)\\n\\t* The **column will remain constant as n-1** and **we will start filling from r1 + 1**, as first row is filled in previous step & row will be updated.\\n* From **right to left** \\u2B05\\uFE0F\\n\\t* we will **start filling from c2 - 1 because c2 is filled in previous step**.\\n\\t* so the **row will be fixed** and c2 will be updated from c2-1 till its greater than c1.\\n* From **botom to up** \\u2B06\\uFE0F (move up)\\n\\t* the **column will be fixed as c1** while row will be updated form r2 till it greater than r1.\\n* After that we will **updates the row and column pointers, as now we will have to fill the inner layers.**\\n\\n**ANALYSIS -:**\\n* TIME COMPLEXITY = **O(N^2)**\\n* SPACE COMPLEXITY = **O(1)**\\n\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int r1 = 0, r2 = n-1;\\n        int c1 = 0, c2 = n-1;\\n        int val = 0;\\n\\t\\t\\n\\t\\t// result matrix\\n        vector<vector<int>> v(n, vector<int> (n));\\n        while(r1 <= r2 && c1 <= c2)\\n        {\\n            // left to right (row will be fixed)\\n            for(int i = c1; i <= c2; ++i)\\n                v[r1][i] = ++val;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// move down(col will be fixed)\\n            for(int i = r1+1; i <= r2; ++i)\\n                v[i][c2] = ++val;\\n\\t\\t\\t\\t\\n            // move right to left\\n            // move  up\\n            if(r1 < r2 && c1 < c2)\\n            {\\n                // move right to left (row will be fixed)\\n                for(int i = c2-1; i>c1; --i)\\n                    v[r2][i] = ++val;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// move up (col will be fixed)\\n\\t\\t\\t\\t\\tfor(int i = r2; i>r1; --i) \\n                    v[i][c1] = ++val;\\n            }\\n            ++r1;\\n            --r2;\\n            ++c1;\\n            --c2;\\n        }\\n        return v;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Please Upvote if it helps\\u2B06\\uFE0F\\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int r1 = 0, r2 = n-1;\\n        int c1 = 0, c2 = n-1;\\n        int val = 0;\\n\\t\\t\\n\\t\\t// result matrix\\n        vector<vector<int>> v(n, vector<int> (n));\\n        while(r1 <= r2 && c1 <= c2)\\n        {\\n            // left to right (row will be fixed)\\n            for(int i = c1; i <= c2; ++i)\\n                v[r1][i] = ++val;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// move down(col will be fixed)\\n            for(int i = r1+1; i <= r2; ++i)\\n                v[i][c2] = ++val;\\n\\t\\t\\t\\t\\n            // move right to left\\n            // move  up\\n            if(r1 < r2 && c1 < c2)\\n            {\\n                // move right to left (row will be fixed)\\n                for(int i = c2-1; i>c1; --i)\\n                    v[r2][i] = ++val;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// move up (col will be fixed)\\n\\t\\t\\t\\t\\tfor(int i = r2; i>r1; --i) \\n                    v[i][c1] = ++val;\\n            }\\n            ++r1;\\n            --r2;\\n            ++c1;\\n            --c2;\\n        }\\n        return v;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22290,
                "title": "python-easy-to-follow-solution",
                "content": "        \\n    def generateMatrix(self, n):\\n        if not n:\\n            return []\\n        res = [[0 for _ in xrange(n)] for _ in xrange(n)]\\n        left, right, top, down, num = 0, n-1, 0, n-1, 1\\n        while left <= right and top <= down:\\n            for i in xrange(left, right+1):\\n                res[top][i] = num \\n                num += 1\\n            top += 1\\n            for i in xrange(top, down+1):\\n                res[i][right] = num\\n                num += 1\\n            right -= 1\\n            for i in xrange(right, left-1, -1):\\n                res[down][i] = num\\n                num += 1\\n            down -= 1\\n            for i in xrange(down, top-1, -1):\\n                res[i][left] = num\\n                num += 1\\n            left += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def generateMatrix(self, n):\\n        if not n:\\n            return []\\n        res = [[0 for _ in xrange(n)] for _ in xrange(n)]\\n        left, right, top, down, num = 0, n-1, 0, n-1, 1\\n        while left <= right and top <= down:\\n            for i in xrange(left, right+1):\\n                res[top][i] = num \\n                num += 1\\n            top += 1\\n            for i in xrange(top, down+1):\\n                res[i][right] = num\\n                num += 1\\n            right -= 1\\n            for i in xrange(right, left-1, -1):\\n                res[down][i] = num\\n                num += 1\\n            down -= 1\\n            for i in xrange(down, top-1, -1):\\n                res[i][left] = num\\n                num += 1\\n            left += 1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 22292,
                "title": "share-my-java-solution",
                "content": "    public static int[][] generateMatrix(int n) {\\n\\t\\tint[][] ret = new int[n][n];\\n\\t\\tint left = 0,top = 0;\\n\\t\\tint right = n -1,down = n - 1;\\n\\t\\tint count = 1;\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tfor (int j = left; j <= right; j ++) {\\n\\t\\t\\t\\tret[top][j] = count++;\\n\\t\\t\\t}\\n\\t\\t\\ttop ++;\\n\\t\\t\\tfor (int i = top; i <= down; i ++) {\\n\\t\\t\\t\\tret[i][right] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tright --;\\n\\t\\t\\tfor (int j = right; j >= left; j --) {\\n\\t\\t\\t\\tret[down][j] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tdown --;\\n\\t\\t\\tfor (int i = down; i >= top; i --) {\\n\\t\\t\\t\\tret[i][left] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tleft ++;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public static int[][] generateMatrix(int n) {\\n\\t\\tint[][] ret = new int[n][n];\\n\\t\\tint left = 0,top = 0;\\n\\t\\tint right = n -1,down = n - 1;\\n\\t\\tint count = 1;\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tfor (int j = left; j <= right; j ++) {\\n\\t\\t\\t\\tret[top][j] = count++;\\n\\t\\t\\t}\\n\\t\\t\\ttop ++;\\n\\t\\t\\tfor (int i = top; i <= down; i ++) {\\n\\t\\t\\t\\tret[i][right] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tright --;\\n\\t\\t\\tfor (int j = right; j >= left; j --) {\\n\\t\\t\\t\\tret[down][j] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tdown --;\\n\\t\\t\\tfor (int i = down; i >= top; i --) {\\n\\t\\t\\t\\tret[i][left] = count ++;\\n\\t\\t\\t}\\n\\t\\t\\tleft ++;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 22454,
                "title": "simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > generateMatrix(int n) {\\n            vector<vector<int> > vv(n, vector<int>(n));\\n        \\n            int rowStart = 0, rowEnd = n - 1;\\n            int colStart = 0, colEnd = n - 1;\\n            int cnt = 1;\\n        \\n            while(rowStart <= rowEnd && colStart <= colEnd)\\n            {\\n                for(int i = colStart; i<= colEnd; i++)\\n                    vv[rowStart][i] = cnt++;\\n                rowStart++;\\n            \\n                for(int i = rowStart; i<= rowEnd; i++)\\n                    vv[i][colEnd] = cnt++;\\n                colEnd--;\\n            \\n                for(int i = colEnd; i>= colStart; i--)\\n                    vv[rowEnd][i] = cnt++;\\n                rowEnd--;\\n            \\n                for(int i = rowEnd; i>= rowStart; i--)\\n                    vv[i][colStart] = cnt++;\\n                colStart++;\\n            }\\n        \\n            return vv;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > generateMatrix(int n) {\\n            vector<vector<int> > vv(n, vector<int>(n));\\n        \\n            int rowStart = 0, rowEnd = n - 1;\\n            int colStart = 0, colEnd = n - 1;\\n            int cnt = 1;\\n        \\n            while(rowStart <= rowEnd && colStart <= colEnd)\\n            {\\n                for(int i = colStart; i<= colEnd; i++)\\n                    vv[rowStart][i] = cnt++;\\n                rowStart++;\\n            \\n                for(int i = rowStart; i<= rowEnd; i++)\\n                    vv[i][colEnd] = cnt++;\\n                colEnd--;\\n            \\n                for(int i = colEnd; i>= colStart; i--)\\n                    vv[rowEnd][i] = cnt++;\\n                rowEnd--;\\n            \\n                for(int i = rowEnd; i>= rowStart; i--)\\n                    vv[i][colStart] = cnt++;\\n                colStart++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3506445,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. I planned to give for next 10,000 Subscribers as well. If you\\'re interested **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n\\n# or\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\n\\n- Initialize an empty matrix of size n x n with all elements set to zero.\\n- Define variables left, right, top, bottom, and num.\\n- Use a while loop to iterate over the matrix in a spiral order.\\n- In each iteration, fill in the top row, right column, bottom row, and left column of the remaining submatrix, in that order.\\n- Increment/decrement the values of left, right, top, and bottom accordingly after each iteration, and update the value of num to be filled in the next iteration.\\n- Return the generated matrix.\\n# Intuition:\\n\\nThe code generates the matrix by filling in its elements in a spiral order, starting from the top-left corner and moving clockwise. It uses the variables left, right, top, and bottom to keep track of the current submatrix being filled in, and the variable num to keep track of the next number to be filled in the matrix. The algorithm fills in the matrix in four steps:\\n\\n- Fill in the top row from left to right.\\n- Fill in the right column from top to bottom.\\n- Fill in the bottom row from right to left.\\n- Fill in the left column from bottom to top.\\n\\nAfter each step, the corresponding variable (left, right, top, or bottom) is incremented or decremented to exclude the already filled elements in the next iteration. The algorithm stops when the submatrix being filled in becomes empty, i.e., left > right or top > bottom. Finally, the generated matrix is returned.\\n\\n\\n```Python []\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        if not n:\\n            return []\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        left, right, top, bottom, num = 0, n-1, 0, n-1, 1\\n        while left <= right and top <= bottom:\\n            for i in range(left, right+1):\\n                matrix[top][i] = num \\n                num += 1\\n            top += 1\\n            for i in range(top, bottom+1):\\n                matrix[i][right] = num\\n                num += 1\\n            right -= 1\\n            if top <= bottom:\\n                for i in range(right, left-1, -1):\\n                    matrix[bottom][i] = num\\n                    num += 1\\n                bottom -= 1\\n            if left <= right:\\n                for i in range(bottom, top-1, -1):\\n                    matrix[i][left] = num\\n                    num += 1\\n                left += 1\\n        return matrix\\n\\n```\\n```Java []\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n == 0) {\\n            return new int[0][0];\\n        }\\n        int[][] matrix = new int[n][n];\\n        int left = 0, right = n-1, top = 0, bottom = n-1, num = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        if (n == 0) {\\n            return {};\\n        }\\n        vector<vector<int>> matrix(n, vector<int>(n, 0));\\n        int left = 0, right = n-1, top = 0, bottom = n-1, num = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```Python []\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        if not n:\\n            return []\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        left, right, top, bottom, num = 0, n-1, 0, n-1, 1\\n        while left <= right and top <= bottom:\\n            for i in range(left, right+1):\\n                matrix[top][i] = num \\n                num += 1\\n            top += 1\\n            for i in range(top, bottom+1):\\n                matrix[i][right] = num\\n                num += 1\\n            right -= 1\\n            if top <= bottom:\\n                for i in range(right, left-1, -1):\\n                    matrix[bottom][i] = num\\n                    num += 1\\n                bottom -= 1\\n            if left <= right:\\n                for i in range(bottom, top-1, -1):\\n                    matrix[i][left] = num\\n                    num += 1\\n                left += 1\\n        return matrix\\n\\n```\n```Java []\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n == 0) {\\n            return new int[0][0];\\n        }\\n        int[][] matrix = new int[n][n];\\n        int left = 0, right = n-1, top = 0, bottom = n-1, num = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        if (n == 0) {\\n            return {};\\n        }\\n        vector<vector<int>> matrix(n, vector<int>(n, 0));\\n        int left = 0, right = n-1, top = 0, bottom = n-1, num = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1468207,
                "title": "python-smart-simulate-by-marking-as-visited-super-clean-concise",
                "content": "**Idea**\\n- Initially, we move by the RIGHT direction.\\n- If we meet the boundary or we meet visited cell then we change to the next direction.\\n- Directions are in order [RIGHT, DOWN, LEFT, TOP].\\n- We iterate `n^2` times to fill `n^2` values to our answer.\\n\\n![image](https://assets.leetcode.com/users/images/8cc7cea1-b48b-48d2-9dfb-fbf541631d25_1631860276.5949159.png)\\n\\n```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        ans = [[0] * n for _ in range(n)]\\n        DIR = [0, 1, 0, -1, 0]  # (r + DIR[i], c + DIR[i+1]) corresponding to move [RIGHT, DOWN, LEFT, TOP]\\n        r, c = 0, 0  # start at cell (0, 0)\\n        d = 0  # start with RIGHT direction\\n        for num in range(1, n*n+1):\\n            nr, nc = r + DIR[d], c + DIR[d+1]\\n            if not 0 <= nr < n or not 0 <= nc < n or ans[nr][nc] != 0:  # If out of bound or already visited\\n                d = (d + 1) % 4  # Change next direction\\n                nr, nc = r + DIR[d], c + DIR[d+1]\\n                \\n            ans[r][c] = num\\n            r, c = nr, nc\\n        \\n        return ans\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 20` is length of side of the square matrix.\\n- Extra space (without couting output as space): `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        ans = [[0] * n for _ in range(n)]\\n        DIR = [0, 1, 0, -1, 0]  # (r + DIR[i], c + DIR[i+1]) corresponding to move [RIGHT, DOWN, LEFT, TOP]\\n        r, c = 0, 0  # start at cell (0, 0)\\n        d = 0  # start with RIGHT direction\\n        for num in range(1, n*n+1):\\n            nr, nc = r + DIR[d], c + DIR[d+1]\\n            if not 0 <= nr < n or not 0 <= nc < n or ans[nr][nc] != 0:  # If out of bound or already visited\\n                d = (d + 1) % 4  # Change next direction\\n                nr, nc = r + DIR[d], c + DIR[d+1]\\n                \\n            ans[r][c] = num\\n            r, c = nr, nc\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506760,
                "title": "day-405-brute-better-optimal-3-liner-0ms-100-python-java-c-explained",
                "content": "\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n![image.png](https://assets.leetcode.com/users/images/6c06c3b7-3f00-49f3-8e49-5c21b8ef8460_1683686244.3385067.png)\\n\\n\\n# BRUTE\\nThe brute force solution to generate a matrix in spiral order is to simulate the process of filling the matrix in a spiral order. We can start by initializing the matrix with zeros and then fill the matrix in a spiral order by moving right, down, left, and up. We keep track of the current position in the matrix and the direction of movement. Whenever we reach the boundary of the matrix or encounter a non-zero element, we change the direction of movement. We continue this process until all the elements in the matrix are filled.\\n\\n```java []\\npublic int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int num = 1;\\n        int row = 0;\\n        int col = 0;\\n        int direction = 0;\\n        int[] dr = {0, 1, 0, -1};\\n        int[] dc = {1, 0, -1, 0};\\n        while (num <= n * n) {\\n            matrix[row][col] = num;\\n            num++;\\n            int nextRow = row + dr[direction];\\n            int nextCol = col + dc[direction];\\n            if (nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || matrix[nextRow][nextCol] != 0) {\\n                direction = (direction + 1) % 4;\\n            }\\n            row += dr[direction];\\n            col += dc[direction];\\n        }\\n        return matrix;\\n    }\\n```\\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int num = 1;\\n    int row = 0;\\n    int col = 0;\\n    int direction = 0;\\n    vector<int> dr = {0, 1, 0, -1};\\n    vector<int> dc = {1, 0, -1, 0};\\n    while (num <= n * n) {\\n        matrix[row][col] = num;\\n        num++;\\n        int nextRow = row + dr[direction];\\n        int nextCol = col + dc[direction];\\n        if (nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || matrix[nextRow][nextCol] != 0) {\\n            direction = (direction + 1) % 4;\\n        }\\n        row += dr[direction];\\n        col += dc[direction];\\n    }\\n    return matrix;\\n}\\n```\\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    num = 1\\n    row = 0\\n    col = 0\\n    direction = 0\\n    dr = [0, 1, 0, -1]\\n    dc = [1, 0, -1, 0]\\n    while num <= n * n:\\n        matrix[row][col] = num\\n        num += 1\\n        nextRow = row + dr[direction]\\n        nextCol = col + dc[direction]\\n        if nextRow < 0 or nextRow >= n or nextCol < 0 or nextCol >= n or matrix[nextRow][nextCol] != 0:\\n            direction = (direction + 1) % 4\\n        row += dr[direction]\\n        col += dc[direction]\\n    return matrix\\n```\\n# Complexity\\nThe time complexity of the brute force solution is O(n^2) because we need to fill all the elements in the matrix. The space complexity is also O(n^2)+2*O(1D) because we need to create a matrix of size n x n to store the elements and two direction 1D arrays.\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Better Solution:\\n\\nA better solution to generate a matrix in spiral order is to use a recursive approach. We can divide the matrix into four sub-matrices and fill each sub-matrix in a spiral order recursively. We start by filling the top row of the matrix, then fill the right column, then the bottom row, and finally the left column. We repeat this process for the remaining sub-matrix until all the elements in the matrix are filled.\\n\\n```java []\\npublic  int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        fillMatrix(matrix, 0, n - 1, 0, n - 1, 1);\\n        return matrix;\\n    }\\n\\n    public  void fillMatrix(int[][] matrix, int top, int bottom, int left, int right, int num) {\\n        if (top > bottom || left > right) {\\n            return;\\n        }\\n        for (int i = left; i <= right; i++) {\\n            matrix[top][i] = num;\\n            num++;\\n        }\\n        for (int i = top + 1; i <= bottom; i++) {\\n            matrix[i][right] = num;\\n            num++;\\n        }\\n        if (top < bottom && left < right) {\\n            for (int i = right - 1; i >= left; i--) {\\n                matrix[bottom][i] = num;\\n                num++;\\n            }\\n            for (int i = bottom - 1; i > top; i--) {\\n                matrix[i][left] = num;\\n                num++;\\n            }\\n        }\\n        fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num);\\n    }\\n\\n```\\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    fillMatrix(matrix, 0, n - 1, 0, n - 1, 1);\\n    return matrix;\\n}\\n\\nvoid fillMatrix(vector<vector<int>>& matrix, int top, int bottom, int left, int right, int num) {\\n    if (top > bottom || left > right) {\\n        return;\\n    }\\n    for (int i = left; i <= right; i++) {\\n        matrix[top][i] = num;\\n        num++;\\n    }\\n    for (int i = top + 1; i <= bottom; i++) {\\n        matrix[i][right] = num;\\n        num++;\\n    }\\n    if (top < bottom && left < right) {\\n        for (int i = right - 1; i >= left; i--) {\\n            matrix[bottom][i] = num;\\n            num++;\\n        }\\n        for (int i = bottom - 1; i > top; i--) {\\n            matrix[i][left] = num;\\n            num++;\\n        }\\n    }\\n    fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num);\\n}\\n```\\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    fillMatrix(matrix, 0, n - 1, 0, n - 1, 1)\\n    return matrix\\n\\ndef fillMatrix(matrix: List[List[int]], top: int, bottom: int, left: int, right: int, num: int) -> None:\\n    if top > bottom or left > right:\\n        return\\n    for i in range(left, right + 1):\\n        matrix[top][i] = num\\n        num += 1\\n    for i in range(top + 1, bottom + 1):\\n        matrix[i][right] = num\\n        num += 1\\n    if top < bottom and left < right:\\n        for i in range(right - 1, left - 1, -1):\\n            matrix[bottom][i] = num\\n            num += 1\\n        for i in range(bottom - 1, top, -1):\\n            matrix[i][left] = num\\n            num += 1\\n    fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num)\\n```\\n# Complexity\\nThe time complexity of the better solution is O(n^2) because we need to fill all the elements in the matrix. The space complexity is also O(n^2) because we need to create a matrix of size n x n to store the elements. However, the space complexity of the recursive approach is O(n2)+o(log n) because we use the call stack to store the recursive calls, which has a maximum depth of log n.\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n# optimal\\n\\n```java []\\npublic int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int top = 0;\\n        int bottom = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int num = 1;\\n        while (top <= bottom && left <= right) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num;\\n                num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num;\\n                num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num;\\n                    num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num;\\n                    num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n```\\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int top = 0;\\n    int bottom = n - 1;\\n    int left = 0;\\n    int right = n - 1;\\n    int num = 1;\\n    while (top <= bottom && <= right) {\\n        for (int i = left; i <= right; i++) {\\n            matrix[top][i] = num;\\n            num++;\\n        }\\n        top++;\\n        for (int i = top; i <= bottom; i++) {\\n            matrix[i][right] = num;\\n            num++;\\n        }\\n        right--;\\n        if (top <= bottom) {\\n            for (int i = right; i >= left; i--) {\\n                matrix[bottom][i] = num;\\n                num++;\\n            }\\n            bottom--;\\n        }\\n        if (left <= right) {\\n            for (int i = bottom; i >= top; i--) {\\n                matrix[i][left] = num;\\n                num++;\\n            }\\n            left++;\\n        }\\n    }\\n    return matrix;\\n}\\n```\\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    top = 0\\n    bottom = n - 1\\n    left = 0\\n    right = n - 1\\n    num = 1\\n    while top <= bottom and left <= right:\\n        for i in range(left, right + 1):\\n            matrix[top][i] = num\\n            num += 1\\n        top += 1\\n        for i in range(top, bottom + 1):\\n            matrix[i][right] = num\\n            num += 1\\n        right -= 1\\n        if top <= bottom:\\n            for i in range(right, left - 1, -1):\\n                matrix[bottom][i] = num\\n                num += 1\\n            bottom -= 1\\n        if left <= right:\\n            for i in range(bottom, top - 1, -1):\\n                matrix[i][left] = num\\n                num += 1\\n            left += 1\\n    return matrix\\n```\\n# Complexity\\nThe time complexity of the optimal solution is O(n^2) because we need to fill all the elements in the matrix. The space complexity is o(n2)+ O(1) because we only need to create a constant number of variables to store the boundaries of the matrix and the current number to fill.\\n\\nIn terms of time complexity, the optimal solution is the best because it has the same time complexity as the other two solutions but uses a single loop instead of recursion or simulating the process of filling the matrix. In terms of space complexity, the optimal solution is the best because it only uses a constant amount of space, whereas the other two solutions use a matrix of size n x n or a call stack of size log n.\\n\\n# concise code\\n# Algorithm\\n##### \\u2022\\tUse four variables i, j, di, and dj to keep track of the current position and direction\\n##### \\u2022\\tThen starts by initializing the matrix with all zeros\\n##### \\u2022\\tIt then fills the matrix in a spiral order by moving in the current direction and changing direction when it encounters a non-zero element\\n##### \\u2022\\tThe loop variable k starts from 1 and goes up to n * n\\n##### \\u2022\\tIn each iteration, then sets the value of the current position (i, j) to k\\n##### \\u2022\\tIt then checks if the next position in the current direction (i + di, j + dj) is already filled with a non-zero value\\n##### \\u2022\\tIf it is, changes the direction by swapping di and dj and negating one of them\\n##### \\u2022\\tFinally, updates the current position by adding di to i and dj to j\\n##### \\u2022\\tOnce the loop is complete, the matrix is filled in a spiral order and returns the matrix\\n\\n```java []\\npublic int[][] generateMatrix(int n) {\\n    int matrix[][] = new int[n][n],i = 0, j = 0, di = 0, dj = 1;\\n    for (int k = 1; k <= n * n; k++) {\\n        matrix[i][j] = k;\\n        if (matrix[(i + di + n) % n][(j + dj + n) % n] != 0) {\\n            int temp = di;\\n            di = dj;\\n            dj = -temp;\\n        }\\n        i += di;\\n        j += dj;\\n    } return matrix;\\n}\\n```\\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int i = 0, j = 0, di = 0, dj = 1;\\n    for (int k = 1; k <= n * n; k++) {\\n        matrix[i][j] = k;\\n        if (matrix[(i + di + n) % n][(j + dj + n) % n] != 0) {\\n            int temp = di;\\n            di = dj;\\n            dj = -temp;\\n        }\\n        i += di;\\n        j += dj;\\n    }\\n    return matrix;\\n}\\n```\\n```python []\\ndef generateMatrix(self, n):\\n    A = [[0] * n for _ in range(n)]\\n    i, j, di, dj = 0, 0, 0, 1\\n    for k in xrange(n*n):\\n        A[i][j] = k + 1\\n        if A[(i+di)%n][(j+dj)%n]:\\n            di, dj = dj, -di\\n        i += di\\n        j += dj\\n    return A\\n```\\n\\n# dry run for n=3\\n##### \\u2022\\tInitially, we create a new n x n matrix filled with zeros\\n##### \\u2022\\tWe also initialize i and j to 0, and di and dj to 0 and 1 respectively\\n##### \\u2022\\tWe then enter a loop that runs from k=1 to k=n*n\\n##### \\u2022\\tIn each iteration of the loop, we do the following:We set the value of the current cell to k\\n##### \\u2022\\tWe check if the next cell in the direction of (di, dj) is already filled\\n##### \\u2022\\tIf it is, we change the direction of motion by swapping di and dj and negating the new value of dj\\n##### \\u2022\\tWe update the values of i and j by adding di and dj respectively\\n##### \\u2022\\tAfter the loop completes, we return the filled matrix\\n##### \\u2022\\tThe final matrix is:\\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\\n# 3 LINES code\\n# Algorithm\\n##### \\u2022\\tFirst initializes an empty list A and a variable lo to n*n+1\\n##### \\u2022\\tIt then enters a loop that continues until lo is less than or equal to 1\\n##### \\u2022\\tIn each iteration, set hi to the current value of lo and updates lo to lo - len(A)\\n##### \\u2022\\tIt then creates a new list of integers from lo to hi and appends it to the beginning of A\\n##### \\u2022\\tThen reverses the order of the remaining elements in A and transposes the resulting list of lists using the zip() function\\n##### \\u2022\\tThis effectively rotates the matrix by 90 degrees counterclockwise\\n##### \\u2022\\tThe loop continues until lo is less than or equal to 1, at which point the matrix is filled in a spiral order and  returns A\\n\\n```PYTHON []\\ndef generateMatrix(self, n):\\n    A = [[n*n]]\\n    while A[0][0] > 1:\\n        A = [range(A[0][0] - len(A), A[0][0])] + zip(*A[::-1])\\n    return A * (n>0)\\n```\\n```PYTHON []\\ndef generateMatrix(self, n):\\n    A, lo = [], n*n+1\\n    while lo > 1:\\n        lo, hi = lo - len(A), lo\\n        A = [range(lo, hi)] + zip(*A[::-1])\\n    return A\\n```\\n# dry run for n=3\\n##### \\u2022\\tInitially, A is set to [[9]]\\n##### \\u2022\\tIn the while loop, we check if the first element of A is greater than 1\\n##### \\u2022\\tSince it is, we perform the following steps:We create a new list B containing a range of numbers from A[0][0] - len(A) to A[0][0] - 1\\n##### \\u2022\\tIn this case, B is equal to range(7, 9)\\n##### \\u2022\\tWe then take the transpose of A using zip(*A[::-1])\\n##### \\u2022\\tThe [::-1] reverses the order of the elements in A, and the * unpacks the elements of A as arguments to zip\\n##### \\u2022\\tThe zip function then groups the elements of each sub-list of A with the corresponding elements of B, effectively rotating the matrix by 90 degrees counterclockwise\\n##### \\u2022\\tWe concatenate B with the result of step 2 to form a new matrix A\\n##### \\u2022\\tWe repeat steps 1-3 until the first element of A is equal to 1\\n##### \\u2022\\tFinally, we return A multiplied by (n>0), which is equivalent to returning A if n is positive and an empty list if n is zero\\n\\nAt each iteration, the code fills in one element of the matrix in a spiral order. The final matrix is filled in the following order:\\n1 2 3\\n8 9 4\\n7 6 5\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```java []\\npublic int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int num = 1;\\n        int row = 0;\\n        int col = 0;\\n        int direction = 0;\\n        int[] dr = {0, 1, 0, -1};\\n        int[] dc = {1, 0, -1, 0};\\n        while (num <= n * n) {\\n            matrix[row][col] = num;\\n            num++;\\n            int nextRow = row + dr[direction];\\n            int nextCol = col + dc[direction];\\n            if (nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || matrix[nextRow][nextCol] != 0) {\\n                direction = (direction + 1) % 4;\\n            }\\n            row += dr[direction];\\n            col += dc[direction];\\n        }\\n        return matrix;\\n    }\\n```\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int num = 1;\\n    int row = 0;\\n    int col = 0;\\n    int direction = 0;\\n    vector<int> dr = {0, 1, 0, -1};\\n    vector<int> dc = {1, 0, -1, 0};\\n    while (num <= n * n) {\\n        matrix[row][col] = num;\\n        num++;\\n        int nextRow = row + dr[direction];\\n        int nextCol = col + dc[direction];\\n        if (nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || matrix[nextRow][nextCol] != 0) {\\n            direction = (direction + 1) % 4;\\n        }\\n        row += dr[direction];\\n        col += dc[direction];\\n    }\\n    return matrix;\\n}\\n```\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    num = 1\\n    row = 0\\n    col = 0\\n    direction = 0\\n    dr = [0, 1, 0, -1]\\n    dc = [1, 0, -1, 0]\\n    while num <= n * n:\\n        matrix[row][col] = num\\n        num += 1\\n        nextRow = row + dr[direction]\\n        nextCol = col + dc[direction]\\n        if nextRow < 0 or nextRow >= n or nextCol < 0 or nextCol >= n or matrix[nextRow][nextCol] != 0:\\n            direction = (direction + 1) % 4\\n        row += dr[direction]\\n        col += dc[direction]\\n    return matrix\\n```\n```java []\\npublic  int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        fillMatrix(matrix, 0, n - 1, 0, n - 1, 1);\\n        return matrix;\\n    }\\n\\n    public  void fillMatrix(int[][] matrix, int top, int bottom, int left, int right, int num) {\\n        if (top > bottom || left > right) {\\n            return;\\n        }\\n        for (int i = left; i <= right; i++) {\\n            matrix[top][i] = num;\\n            num++;\\n        }\\n        for (int i = top + 1; i <= bottom; i++) {\\n            matrix[i][right] = num;\\n            num++;\\n        }\\n        if (top < bottom && left < right) {\\n            for (int i = right - 1; i >= left; i--) {\\n                matrix[bottom][i] = num;\\n                num++;\\n            }\\n            for (int i = bottom - 1; i > top; i--) {\\n                matrix[i][left] = num;\\n                num++;\\n            }\\n        }\\n        fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num);\\n    }\\n\\n```\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    fillMatrix(matrix, 0, n - 1, 0, n - 1, 1);\\n    return matrix;\\n}\\n\\nvoid fillMatrix(vector<vector<int>>& matrix, int top, int bottom, int left, int right, int num) {\\n    if (top > bottom || left > right) {\\n        return;\\n    }\\n    for (int i = left; i <= right; i++) {\\n        matrix[top][i] = num;\\n        num++;\\n    }\\n    for (int i = top + 1; i <= bottom; i++) {\\n        matrix[i][right] = num;\\n        num++;\\n    }\\n    if (top < bottom && left < right) {\\n        for (int i = right - 1; i >= left; i--) {\\n            matrix[bottom][i] = num;\\n            num++;\\n        }\\n        for (int i = bottom - 1; i > top; i--) {\\n            matrix[i][left] = num;\\n            num++;\\n        }\\n    }\\n    fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num);\\n}\\n```\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    fillMatrix(matrix, 0, n - 1, 0, n - 1, 1)\\n    return matrix\\n\\ndef fillMatrix(matrix: List[List[int]], top: int, bottom: int, left: int, right: int, num: int) -> None:\\n    if top > bottom or left > right:\\n        return\\n    for i in range(left, right + 1):\\n        matrix[top][i] = num\\n        num += 1\\n    for i in range(top + 1, bottom + 1):\\n        matrix[i][right] = num\\n        num += 1\\n    if top < bottom and left < right:\\n        for i in range(right - 1, left - 1, -1):\\n            matrix[bottom][i] = num\\n            num += 1\\n        for i in range(bottom - 1, top, -1):\\n            matrix[i][left] = num\\n            num += 1\\n    fillMatrix(matrix, top + 1, bottom - 1, left + 1, right - 1, num)\\n```\n```java []\\npublic int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int top = 0;\\n        int bottom = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int num = 1;\\n        while (top <= bottom && left <= right) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = num;\\n                num++;\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = num;\\n                num++;\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = num;\\n                    num++;\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = num;\\n                    num++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n```\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int top = 0;\\n    int bottom = n - 1;\\n    int left = 0;\\n    int right = n - 1;\\n    int num = 1;\\n    while (top <= bottom && <= right) {\\n        for (int i = left; i <= right; i++) {\\n            matrix[top][i] = num;\\n            num++;\\n        }\\n        top++;\\n        for (int i = top; i <= bottom; i++) {\\n            matrix[i][right] = num;\\n            num++;\\n        }\\n        right--;\\n        if (top <= bottom) {\\n            for (int i = right; i >= left; i--) {\\n                matrix[bottom][i] = num;\\n                num++;\\n            }\\n            bottom--;\\n        }\\n        if (left <= right) {\\n            for (int i = bottom; i >= top; i--) {\\n                matrix[i][left] = num;\\n                num++;\\n            }\\n            left++;\\n        }\\n    }\\n    return matrix;\\n}\\n```\n```python []\\ndef generateMatrix(n: int) -> List[List[int]]:\\n    matrix = [[0] * n for _ in range(n)]\\n    top = 0\\n    bottom = n - 1\\n    left = 0\\n    right = n - 1\\n    num = 1\\n    while top <= bottom and left <= right:\\n        for i in range(left, right + 1):\\n            matrix[top][i] = num\\n            num += 1\\n        top += 1\\n        for i in range(top, bottom + 1):\\n            matrix[i][right] = num\\n            num += 1\\n        right -= 1\\n        if top <= bottom:\\n            for i in range(right, left - 1, -1):\\n                matrix[bottom][i] = num\\n                num += 1\\n            bottom -= 1\\n        if left <= right:\\n            for i in range(bottom, top - 1, -1):\\n                matrix[i][left] = num\\n                num += 1\\n            left += 1\\n    return matrix\\n```\n```java []\\npublic int[][] generateMatrix(int n) {\\n    int matrix[][] = new int[n][n],i = 0, j = 0, di = 0, dj = 1;\\n    for (int k = 1; k <= n * n; k++) {\\n        matrix[i][j] = k;\\n        if (matrix[(i + di + n) % n][(j + dj + n) % n] != 0) {\\n            int temp = di;\\n            di = dj;\\n            dj = -temp;\\n        }\\n        i += di;\\n        j += dj;\\n    } return matrix;\\n}\\n```\n```c++ []\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> matrix(n, vector<int>(n));\\n    int i = 0, j = 0, di = 0, dj = 1;\\n    for (int k = 1; k <= n * n; k++) {\\n        matrix[i][j] = k;\\n        if (matrix[(i + di + n) % n][(j + dj + n) % n] != 0) {\\n            int temp = di;\\n            di = dj;\\n            dj = -temp;\\n        }\\n        i += di;\\n        j += dj;\\n    }\\n    return matrix;\\n}\\n```\n```python []\\ndef generateMatrix(self, n):\\n    A = [[0] * n for _ in range(n)]\\n    i, j, di, dj = 0, 0, 0, 1\\n    for k in xrange(n*n):\\n        A[i][j] = k + 1\\n        if A[(i+di)%n][(j+dj)%n]:\\n            di, dj = dj, -di\\n        i += di\\n        j += dj\\n    return A\\n```\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\n```PYTHON []\\ndef generateMatrix(self, n):\\n    A = [[n*n]]\\n    while A[0][0] > 1:\\n        A = [range(A[0][0] - len(A), A[0][0])] + zip(*A[::-1])\\n    return A * (n>0)\\n```\n```PYTHON []\\ndef generateMatrix(self, n):\\n    A, lo = [], n*n+1\\n    while lo > 1:\\n        lo, hi = lo - len(A), lo\\n        A = [range(lo, hi)] + zip(*A[::-1])\\n    return A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 460726,
                "title": "python-easy-to-understand-solution-with-fully-commented-code-ref-caikehe-s-solution",
                "content": "NOTE: this solution is an adaption of @caikehe\\'s [brilliant and clean solution](https://leetcode.com/problems/spiral-matrix-ii/discuss/22290/Python-easy-to-follow-solution).\\n\\nintuition:\\n\\n- initialize a matrix of zeros\\n- fill in the numbers in a spiral order layer-by-layer\\n\\nie. if n =3, initialize a 3-by-3 matrix\\n```\\n[\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ]\\n]\\n```\\ndivide up the matrix into 4 types of layers\\n```python\\n        top = 0 # top layer: top row index\\n        right = n - 1 # right layer: right col index\\n        down = n - 1 # bottom layer: bottom row index\\n        left = 0 # left layer: left col index\\n```\\n\\n```\\n[  \\n [ X, 0, 0 ], <-- you start filling in numbers at the top-left position\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ]\\n]\\n```\\n\\nwhen filling the top layer (horizontal row), fix the row index and increment the col index.\\nafter you are done with the top layer (horizontal row), move the top layer inward(downward) \\n\\n```python\\n for i in range(left, right+1): # from left to right. right + 1 to reach the last position in a row\\n\\t matrix[top][i] = num # to fill top row, fix the top row index and increment the col position\\n     num += 1 # update num\\n top += 1 # after traversing top row, move top row index inward(downward) by one unit\\n```\\n\\nyour matrix will be\\n\\n\\n```\\n[\\n [ 1, 2, 3 ],\\n [ 0, 0, X ], <--- since you increment the top layer by 1, you will start fillin in the next number here at the \\'x\\' position\\n [ 0, 0, 0 ]\\n]\\n```\\n\\nrepeat for the right col (vertical layer going down), bottom row (horizontal layer going right to left), left col (vertical layer going from bottom up)\\n```\\n[\\n [ 1, 2, 3 ],\\n [ 0, 0, 4 ], \\n [ 0, X, 5 ] <--- since you increment the right layer by -1, you will start fillin in the next number here at the \\'x\\' position\\n]\\n```\\n\\n```\\n[\\n [ 1, 2, 3 ],\\n [ X, 0, 4 ], <--- since you increment the bottom layer by -1, you will start fillin in the next number here at the \\'x\\' position\\n [ 7, 6, 5 ]\\n]\\n```\\n\\ntime O(n by n)\\nspace O(n by n)\\n\\n```python\\n# 59 Spiral Matrix II\\nclass Solution:\\n    def generateMatrix(self, n):\\n        matrix = []\\n        if not n: return matrix\\n\\n        # construct a matrix of zeros\\n        for row in range(n):\\n            rowArray = []\\n            for col in range(n):\\n                rowArray.append(0)\\n            matrix.append(rowArray)\\n\\n        # layer by layer strategy\\n        num = 1\\n        top = 0 # top layer: top row index\\n        right = n - 1 # right layer: right col index\\n        down = n - 1 # bottom layer: bottom row index\\n        left = 0 # left layer: left col index\\n\\t\\t \\n\\t\\t # while layers closing inward but not overlapping. if overlap = reached end of spiral matrix\\n        while left <= right and top <= down: \\n            # top row\\n            for i in range(left, right+1): # from left to right. right + 1 to reach the last position in a row\\n                matrix[top][i] = num # to fill top row, fix the top row index and increment the col position\\n                num += 1 # update num\\n            top += 1 # after traversing top row, move top row index inward(downward) by one unit\\n\\n            # right col\\n            for i in range(top, down+1): # from top to bottom. bottom + 1 to reach the last positin in a col\\n                matrix[i][right] = num # to fill the right col, fix the right col index and increment the row position\\n                num += 1 # update num\\n            right -= 1 # after traversing right col, move right col index inward(towards the left) by one unit\\n\\n            # bottom row\\n            for i in range(right, left-1, -1): # from left to right, in reverse order. left-1 to reach the leftmost position in a row\\n                matrix[down][i] = num\\n                num += 1 # update num\\n            down -= 1 # after traversing bottom row, move bottom row index inward(upward) by one unit\\n\\n            # left col\\n            for i in range(down, top-1, -1): # from bottom to top, in reverse order. top-1 to reach the topmost position in a col\\n                matrix[i][left] = num # to fill the left col, fix the left col index and increment the row position\\n                num += 1\\n            left += 1 # after traversing left col, move left col index inward(towards the right) by one unit\\n\\n            # repeat until top-bottom or left-right indices collide (ie. have completed all layers)\\n        return matrix\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n[\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ]\\n]\\n```\n```python\\n        top = 0 # top layer: top row index\\n        right = n - 1 # right layer: right col index\\n        down = n - 1 # bottom layer: bottom row index\\n        left = 0 # left layer: left col index\\n```\n```\\n[  \\n [ X, 0, 0 ], <-- you start filling in numbers at the top-left position\\n [ 0, 0, 0 ],\\n [ 0, 0, 0 ]\\n]\\n```\n```python\\n for i in range(left, right+1): # from left to right. right + 1 to reach the last position in a row\\n\\t matrix[top][i] = num # to fill top row, fix the top row index and increment the col position\\n     num += 1 # update num\\n top += 1 # after traversing top row, move top row index inward(downward) by one unit\\n```\n```\\n[\\n [ 1, 2, 3 ],\\n [ 0, 0, X ], <--- since you increment the top layer by 1, you will start fillin in the next number here at the \\'x\\' position\\n [ 0, 0, 0 ]\\n]\\n```\n```\\n[\\n [ 1, 2, 3 ],\\n [ 0, 0, 4 ], \\n [ 0, X, 5 ] <--- since you increment the right layer by -1, you will start fillin in the next number here at the \\'x\\' position\\n]\\n```\n```\\n[\\n [ 1, 2, 3 ],\\n [ X, 0, 4 ], <--- since you increment the bottom layer by -1, you will start fillin in the next number here at the \\'x\\' position\\n [ 7, 6, 5 ]\\n]\\n```\n```python\\n# 59 Spiral Matrix II\\nclass Solution:\\n    def generateMatrix(self, n):\\n        matrix = []\\n        if not n: return matrix\\n\\n        # construct a matrix of zeros\\n        for row in range(n):\\n            rowArray = []\\n            for col in range(n):\\n                rowArray.append(0)\\n            matrix.append(rowArray)\\n\\n        # layer by layer strategy\\n        num = 1\\n        top = 0 # top layer: top row index\\n        right = n - 1 # right layer: right col index\\n        down = n - 1 # bottom layer: bottom row index\\n        left = 0 # left layer: left col index\\n\\t\\t \\n\\t\\t # while layers closing inward but not overlapping. if overlap = reached end of spiral matrix\\n        while left <= right and top <= down: \\n            # top row\\n            for i in range(left, right+1): # from left to right. right + 1 to reach the last position in a row\\n                matrix[top][i] = num # to fill top row, fix the top row index and increment the col position\\n                num += 1 # update num\\n            top += 1 # after traversing top row, move top row index inward(downward) by one unit\\n\\n            # right col\\n            for i in range(top, down+1): # from top to bottom. bottom + 1 to reach the last positin in a col\\n                matrix[i][right] = num # to fill the right col, fix the right col index and increment the row position\\n                num += 1 # update num\\n            right -= 1 # after traversing right col, move right col index inward(towards the left) by one unit\\n\\n            # bottom row\\n            for i in range(right, left-1, -1): # from left to right, in reverse order. left-1 to reach the leftmost position in a row\\n                matrix[down][i] = num\\n                num += 1 # update num\\n            down -= 1 # after traversing bottom row, move bottom row index inward(upward) by one unit\\n\\n            # left col\\n            for i in range(down, top-1, -1): # from bottom to top, in reverse order. top-1 to reach the topmost position in a col\\n                matrix[i][left] = num # to fill the left col, fix the left col index and increment the row position\\n                num += 1\\n            left += 1 # after traversing left col, move left col index inward(towards the right) by one unit\\n\\n            # repeat until top-bottom or left-right indices collide (ie. have completed all layers)\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941112,
                "title": "python3-straightforward-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nWe use helper function here that fills only one circle at the time.\\n\\nTime: **O(n^2)**\\nSpace: **O(1)**\\n\\nRuntime: 35 ms, faster than **82.95%** of Python3 online submissions for Spiral Matrix II.\\nMemory Usage: 13.9 MB, less than **85.84%** of Python3 online submissions for Spiral Matrix II.\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        res = [[0] * n for _ in range(n)]\\n        \\n        def fill_circle(el, start, n):\\n            i, j = start, start            \\n            for k in range(j, j + n): \\n                res[i][k], el = el, el + 1\\n            for k in range(i + 1, i + n): \\n                res[k][j + n - 1], el = el, el + 1\\n            for k in reversed(range(j, j + n - 1)): \\n                res[i + n - 1][k], el = el, el + 1\\n            for k in reversed(range(i + 1, i + n - 1)): \\n                res[k][j], el = el, el + 1\\n        \\n        el, start = 1, 0\\n        while n > 0:\\n            fill_circle(el, start, n)\\n            el = el + 4*(n - 1)\\n            n, start = n - 2, start + 1\\n            \\n        return res\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        res = [[0] * n for _ in range(n)]\\n        \\n        def fill_circle(el, start, n):\\n            i, j = start, start            \\n            for k in range(j, j + n): \\n                res[i][k], el = el, el + 1\\n            for k in range(i + 1, i + n): \\n                res[k][j + n - 1], el = el, el + 1\\n            for k in reversed(range(j, j + n - 1)): \\n                res[i + n - 1][k], el = el, el + 1\\n            for k in reversed(range(i + 1, i + n - 1)): \\n                res[k][j], el = el, el + 1\\n        \\n        el, start = 1, 0\\n        while n > 0:\\n            fill_circle(el, start, n)\\n            el = el + 4*(n - 1)\\n            n, start = n - 2, start + 1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22443,
                "title": "9-lines-python-solution",
                "content": "(1) Create a matrix to store the coordinates\\n> (0,0) (0,1) (0,2)\\n\\n> (1,0) (1,1) (1,2)\\n\\n> (2,0) (2,1) (2,2)\\n\\n(2) Read it out using the trick of \"[Spiral Matrix I][1]\"\\n\\n> (0,0) (0,1) (0,2) (1,2) (2,2) ...\\n\\n(3) Put 1, 2, 3, ... n**2 at these coordinates sequentially.  Done.\\n\\n    def generateMatrix(self, n):\\n        \\n        result = [[0 for i in range(n)] for j in range(n)]\\n        coord = [[(i,j) for j in range(n)] for i in range(n)]\\n        \\n        count = 1\\n        \\n        while coord:\\n            for x, y in coord.pop(0):\\n                result[x][y] = count\\n                count += 1\\n            coord = zip(*coord)[::-1]\\n\\n        return result\\n\\n\\n  [1]: https://leetcode.com/discuss/46516/lines-recursive-python-solution-lines-solution-recursion",
                "solutionTags": [
                    "Python"
                ],
                "code": "(1) Create a matrix to store the coordinates\\n> (0,0) (0,1) (0,2)\\n\\n> (1,0) (1,1) (1,2)\\n\\n> (2,0) (2,1) (2,2)\\n\\n(2) Read it out using the trick of \"[Spiral Matrix I][1]\"\\n\\n> (0,0) (0,1) (0,2) (1,2) (2,2) ...\\n\\n(3) Put 1, 2, 3, ... n**2 at these coordinates sequentially.  Done.\\n\\n    def generateMatrix(self, n):\\n        \\n        result = [[0 for i in range(n)] for j in range(n)]\\n        coord = [[(i,j) for j in range(n)] for i in range(n)]\\n        \\n        count = 1\\n        \\n        while coord:\\n            for x, y in coord.pop(0):\\n                result[x][y] = count\\n                count += 1\\n            coord = zip(*coord)[::-1]\\n\\n        return result\\n\\n\\n  [1]: https://leetcode.com/discuss/46516/lines-recursive-python-solution-lines-solution-recursion",
                "codeTag": "Python3"
            },
            {
                "id": 22469,
                "title": "if-we-can-t-write-data-to-the-matrix-we-change-the-direction-a-simple-python-solution",
                "content": "    class Solution:\\n    # @return a list of lists of integer\\n    def generateMatrix(self, n):\\n        matrix = [[0]*n for _ in range(n)]\\n        directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        d = 0\\n        y, x = 0, 0\\n        for i in range(1, n*n+1):\\n            matrix[y][x] = i\\n            dy, dx = directions[d % 4]\\n            if -1 < y+dy < n and -1 < x+dx < n and matrix[y+dy][x+dx] == 0:\\n                y, x = y+dy, x+dx\\n            else:\\n                d += 1\\n                dy, dx = directions[d % 4]\\n                y, x = y+dy, x+dx\\n        return matrix\\n\\nChange the direction If the we can't write to the matrix",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @return a list of lists of integer\\n    def generateMatrix(self, n):\\n        matrix = [[0]*n for _ in range(n)]\\n        directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        d = 0\\n        y, x = 0, 0\\n        for i in range(1, n*n+1):\\n            matrix[y][x] = i\\n            dy, dx = directions[d % 4]\\n            if -1 < y+dy < n and -1 < x+dx < n and matrix[y+dy][x+dx] == 0:\\n                y, x = y+dy, x+dx\\n            else:\\n                d += 1\\n                dy, dx = directions[d % 4]\\n                y, x = y+dy, x+dx\\n        return matrix\\n\\nChange the direction If the we can't write to the matrix",
                "codeTag": "Java"
            },
            {
                "id": 1511479,
                "title": "java-tc-o-n-2-sc-o-1-multiple-optimized-ways-to-solve-this-question",
                "content": "**Using Switch-Case - Simulating the spiral traversal**\\n```java\\n/**\\n * Using Switch-Case: Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int top = 0;\\n        int bottom = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int num = 1;\\n        int dir = 0;\\n\\n        while (top <= bottom && left <= right) {\\n            switch (dir) {\\n                case 0: // Left\\n                    for (int i = left; i <= right; i++) {\\n                        result[top][i] = num++;\\n                    }\\n                    top++;\\n                    break;\\n                case 1: // Down\\n                    for (int i = top; i <= bottom; i++) {\\n                        result[i][right] = num++;\\n                    }\\n                    right--;\\n                    break;\\n                case 2: // Right\\n                    for (int i = right; i >= left; i--) {\\n                        result[bottom][i] = num++;\\n                    }\\n                    bottom--;\\n                    break;\\n                case 3: // Up\\n                    for (int i = bottom; i >= top; i--) {\\n                        result[i][left] = num++;\\n                    }\\n                    left++;\\n            }\\n            dir = (dir + 1) % 4;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Without using Switch-Case - Simulating the spiral traversal**\\n\\n```java\\n/**\\n * Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int rowBegin = 0;\\n        int rowEnd = n - 1;\\n        int colBegin = 0;\\n        int colEnd = n - 1;\\n        int num = 1;\\n\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            // Traverse Right\\n            for (int i = colBegin; i <= colEnd; i++) {\\n                result[rowBegin][i] = num++;\\n            }\\n            rowBegin++;\\n            // Traverse Down\\n            for (int i = rowBegin; i <= rowEnd; i++) {\\n                result[i][colEnd] = num++;\\n            }\\n            colEnd--;\\n            // Traverse Left\\n            if (rowBegin <= rowEnd) {\\n                for (int i = colEnd; i >= colBegin; i--) {\\n                    result[rowEnd][i] = num++;\\n                }\\n                rowEnd--;\\n            }\\n            // Traverse Up\\n            if (colBegin <= colEnd) {\\n                for (int i = rowEnd; i >= rowBegin; i--) {\\n                    result[i][colBegin] = num++;\\n                }\\n                colBegin++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Using 2D Directions array to calculate the next valid position - Simulating the spiral traversal**\\n\\n```java\\n/**\\n * Using 2D Directions array to calculate the next valid position. Traverse\\n * Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n        int row = 0;\\n        int col = 0;\\n        int dirIdx = 0;\\n        int num = 1;\\n\\n        while (num <= n * n) {\\n            result[row][col] = num++;\\n            row += dirs[dirIdx][0];\\n            col += dirs[dirIdx][1];\\n\\n            if (row < 0 || row >= n || col < 0 || col >= n || result[row][col] != 0) {\\n                // Moving back from invalid position\\n                row -= dirs[dirIdx][0];\\n                col -= dirs[dirIdx][1];\\n                // Going to next dir\\n                dirIdx = (dirIdx + 1) % 4;\\n                // Updating row and col to valid next position\\n                row += dirs[dirIdx][0];\\n                col += dirs[dirIdx][1];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Spiral Matrix question on LeetCode:\\n- [54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/discuss/1511476/Java-or-TC:-O(M*N)-or-SC:-O(1)-or-Optimized-solution-using-Switch-Case)\\n- [885. Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/discuss/1511489/Java-or-TC:-O(max(R-C)2)-or-SC:-O(1)-or-Simulating-a-Spiral-Walk)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```java\\n/**\\n * Using Switch-Case: Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int top = 0;\\n        int bottom = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int num = 1;\\n        int dir = 0;\\n\\n        while (top <= bottom && left <= right) {\\n            switch (dir) {\\n                case 0: // Left\\n                    for (int i = left; i <= right; i++) {\\n                        result[top][i] = num++;\\n                    }\\n                    top++;\\n                    break;\\n                case 1: // Down\\n                    for (int i = top; i <= bottom; i++) {\\n                        result[i][right] = num++;\\n                    }\\n                    right--;\\n                    break;\\n                case 2: // Right\\n                    for (int i = right; i >= left; i--) {\\n                        result[bottom][i] = num++;\\n                    }\\n                    bottom--;\\n                    break;\\n                case 3: // Up\\n                    for (int i = bottom; i >= top; i--) {\\n                        result[i][left] = num++;\\n                    }\\n                    left++;\\n            }\\n            dir = (dir + 1) % 4;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int rowBegin = 0;\\n        int rowEnd = n - 1;\\n        int colBegin = 0;\\n        int colEnd = n - 1;\\n        int num = 1;\\n\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            // Traverse Right\\n            for (int i = colBegin; i <= colEnd; i++) {\\n                result[rowBegin][i] = num++;\\n            }\\n            rowBegin++;\\n            // Traverse Down\\n            for (int i = rowBegin; i <= rowEnd; i++) {\\n                result[i][colEnd] = num++;\\n            }\\n            colEnd--;\\n            // Traverse Left\\n            if (rowBegin <= rowEnd) {\\n                for (int i = colEnd; i >= colBegin; i--) {\\n                    result[rowEnd][i] = num++;\\n                }\\n                rowEnd--;\\n            }\\n            // Traverse Up\\n            if (colBegin <= colEnd) {\\n                for (int i = rowEnd; i >= rowBegin; i--) {\\n                    result[i][colBegin] = num++;\\n                }\\n                colBegin++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Using 2D Directions array to calculate the next valid position. Traverse\\n * Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1) excluding the result space.\\n */\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        int[][] result = new int[n][n];\\n        if (n == 0) {\\n            return result;\\n        }\\n\\n        int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n        int row = 0;\\n        int col = 0;\\n        int dirIdx = 0;\\n        int num = 1;\\n\\n        while (num <= n * n) {\\n            result[row][col] = num++;\\n            row += dirs[dirIdx][0];\\n            col += dirs[dirIdx][1];\\n\\n            if (row < 0 || row >= n || col < 0 || col >= n || result[row][col] != 0) {\\n                // Moving back from invalid position\\n                row -= dirs[dirIdx][0];\\n                col -= dirs[dirIdx][1];\\n                // Going to next dir\\n                dirIdx = (dirIdx + 1) % 4;\\n                // Updating row and col to valid next position\\n                row += dirs[dirIdx][0];\\n                col += dirs[dirIdx][1];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941264,
                "title": "runtime-0-ms-faster-than-100-00-0-easy-to-understand",
                "content": "***Runtime: 0 ms, faster than 100.00% of Java online submissions for Spiral Matrix II.***\\n\\n***LOGIC***=We have to keep insering the number while moving in a particular direction and changing the direction when `certain condtion` occur:\\n\\n* next row index is -1\\n* next col index is -1\\n* next col index is n\\n* next row index is n\\n* next cell in current direction is already filled.\\n\\nIf `any one` of the following conditions arise, the direction should be changed\\n\\nThere is a `proper order` which we have to follow while `changing the direction`:\\n\\n* initial: right -> new: down\\n* initial: down -> new: left\\n* initial: left -> new: up\\n* initial: up -> new: right\\n\\n\\n\\n```\\nclass Solution {\\n    Integer rowDir = 0, colDir = 1;\\n    \\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int num = 1;\\n        int row =0, col=0;\\n        \\n        \\n        while(num<= n*n) {\\n            matrix[row][col] = num;\\n            \\n            int tempRow = row+rowDir;\\n            int tempCol = col+colDir;\\n\\t\\t\\t\\n\\t\\t\\t//Condition to change direction \\n            if(tempRow < 0 || tempCol <0 || tempRow == n || tempCol == n || matrix[tempRow][tempCol] != 0) {\\n                changeDirection();\\n            }\\n            \\n            row += rowDir;\\n            col += colDir;\\n            \\n            num++;\\n        }\\n        \\n        return matrix;\\n    }\\n    \\n    public void changeDirection() {\\n\\t\\t\\n        if(rowDir == 0 && colDir ==1) {\\n\\t\\t\\t// initial: right -> new: down\\n            colDir = 0;\\n            rowDir = 1;\\n        } else if (colDir == 0 && rowDir ==1) {\\n\\t\\t\\t// initial: down -> new: left\\n            rowDir = 0;\\n            colDir = -1;\\n        } else if (colDir == -1 && rowDir == 0) {\\n\\t\\t\\t// initial: left -> new: up\\n            rowDir = -1;\\n            colDir = 0;\\n        } else if (rowDir == -1 && colDir == 0) {\\n\\t\\t\\t// initial: up -> new: right\\n            colDir = 1;\\n            rowDir = 0;\\n        }\\n    }\\n}\\n```\\n<hr>\\n<hr>\\n\\n**Time Complexity =O(N*N)**\\n**Space Complexity = O(N)**\\n\\n<hr>\\n<hr>\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer rowDir = 0, colDir = 1;\\n    \\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int num = 1;\\n        int row =0, col=0;\\n        \\n        \\n        while(num<= n*n) {\\n            matrix[row][col] = num;\\n            \\n            int tempRow = row+rowDir;\\n            int tempCol = col+colDir;\\n\\t\\t\\t\\n\\t\\t\\t//Condition to change direction \\n            if(tempRow < 0 || tempCol <0 || tempRow == n || tempCol == n || matrix[tempRow][tempCol] != 0) {\\n                changeDirection();\\n            }\\n            \\n            row += rowDir;\\n            col += colDir;\\n            \\n            num++;\\n        }\\n        \\n        return matrix;\\n    }\\n    \\n    public void changeDirection() {\\n\\t\\t\\n        if(rowDir == 0 && colDir ==1) {\\n\\t\\t\\t// initial: right -> new: down\\n            colDir = 0;\\n            rowDir = 1;\\n        } else if (colDir == 0 && rowDir ==1) {\\n\\t\\t\\t// initial: down -> new: left\\n            rowDir = 0;\\n            colDir = -1;\\n        } else if (colDir == -1 && rowDir == 0) {\\n\\t\\t\\t// initial: left -> new: up\\n            rowDir = -1;\\n            colDir = 0;\\n        } else if (rowDir == -1 && colDir == 0) {\\n\\t\\t\\t// initial: up -> new: right\\n            colDir = 1;\\n            rowDir = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22409,
                "title": "c-concise-solution",
                "content": "        \\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n, vector<int> (n, 1));\\n        int left, right, top, down, index;\\n        left = top = index = 0, right = down = n-1;\\n        while (left <= right && top <= down) {\\n            for (unsigned int j = left; j <= right; j++)\\n                res[top][j] = ++index;\\n            top++;\\n            for (unsigned int i = top; i <= down; i++)\\n                res[i][right] = ++index;\\n            right--;\\n            for (int j = right; j >= left; j--)\\n                res[down][j] = ++index;\\n            down--;\\n            for (int i = down; i >= top; i--)\\n                res[i][left] = ++index;\\n            left++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n, vector<int> (n, 1));\\n        int left, right, top, down, index;\\n        left = top = index = 0, right = down = n-1;\\n        while (left <= right && top <= down) {\\n            for (unsigned int j = left; j <= right; j++)\\n                res[top][j] = ++index;\\n            top++;\\n            for (unsigned int i = top; i <= down; i++)\\n                res[i][right] = ++index;\\n            right--;\\n            for (int j = right; j >= left; j--)\\n                res[down][j] = ++index;\\n            down--;\\n            for (int i = down; i >= top; i--)\\n                res[i][left] = ++index;\\n            left++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1804819,
                "title": "c-0ms-fastest-solution",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }\\n                top++;\\n            \\n                for(int i=top;i<=bottom;i++){\\n                   m[i][right]=c;\\n                    c++; \\n                }\\n                right--;\\n            \\n                for(int i=right;i>=left;i--){\\n                    m[bottom][i]=c;\\n                    c++;\\n                }\\n                bottom--;\\n            \\n             \\n                for(int i=bottom;i>=top;i--){\\n                   m[i][left]=c;\\n                    c++; \\n                }\\n                left++;\\n            \\n        }\\n        return m;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 22466,
                "title": "my-ac-solution-with-using-direction-variable",
                "content": "      \\n     vector<vector<int> > generateMatrix(int n) {\\n                int dir = 0;\\n                vector< vector<int> > matrix(n, vector<int> (n, 0));\\n                int i = 0, j = 0, k = 1;\\n                while (k <= n * n) {\\n                    matrix[i][j] = k++;\\n                    if (dir == 0){\\n                        j++;\\n                        if (j == n || matrix[i][j] != 0) dir = 1, j--, i++;\\n                    } else\\n                    if (dir == 1) {\\n                        i++;\\n                        if (i == n || matrix[i][j] != 0) dir = 2, i--, j--;\\n                    } else\\n                    if (dir == 2) {\\n                        j--;\\n                        if (j < 0 || matrix[i][j] != 0) dir = 3, j++, i--;\\n                    } else\\n                    if (dir == 3) {\\n                        i--;\\n                        if (i < 0 || matrix[i][j] != 0) dir = 0, i++, j++;\\n                    }\\n                }\\n                return matrix;\\n            }",
                "solutionTags": [],
                "code": "      \\n     vector<vector<int> > generateMatrix(int n) {\\n                int dir = 0;\\n                vector< vector<int> > matrix(n, vector<int> (n, 0));\\n                int i = 0, j = 0, k = 1;\\n                while (k <= n * n) {\\n                    matrix[i][j] = k++;\\n                    if (dir == 0){\\n                        j++;\\n                        if (j == n || matrix[i][j] != 0) dir = 1, j--, i++;\\n                    } else\\n                    if (dir == 1) {\\n                        i++;\\n                        if (i == n || matrix[i][j] != 0) dir = 2, i--, j--;\\n                    } else\\n                    if (dir == 2) {\\n                        j--;\\n                        if (j < 0 || matrix[i][j] != 0) dir = 3, j++, i--;\\n                    } else\\n                    if (dir == 3) {\\n                        i--;\\n                        if (i < 0 || matrix[i][j] != 0) dir = 0, i++, j++;\\n                    }\\n                }\\n                return matrix;\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 3506464,
                "title": "easy-c-java-code-beats-100-step-by-step-explanattion-begginers-freindly",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe matrix is initialized with all elements set to 0.\\n\\nThe goal is to fill the matrix with integers from 1 to n x n in a spiral order. \\nFor example, for n = 3, the matrix should look like this:\\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\\nInitialize the matrix with all elements set to 0.\\n```\\n0 0 0\\n0 0 0\\n0 0 0\\n```\\nInitialize variables to keep track of the starting and ending rows and columns. Initially, the starting row and column are both 0, and the ending row and column are both n - 1.\\n```\\nstartingrow = 0\\nstartingcol = 0\\nendingrow = 2\\nendingcol = 2\\n```\\nStart filling the matrix in a clockwise spiral order. The first step is to fill the top row from left to right. The count variable keeps track of the current number being filled in the matrix. After each number is placed in the matrix, count is incremented.\\n```\\n1 2 3\\n0 0 0\\n0 0 0\\ncount = 1\\n```\\nMove the starting row down by one, so that the next step will fill the right column from top to bottom.\\n```\\n0 0 0\\n0 0 0\\n0 0 0\\ncount = 1\\nstartingrow = 1\\n```\\nFill the right column from top to bottom.\\n```\\n1 2 3\\n0 0 4\\n0 0 5\\ncount = 3\\n```\\nMove the ending column left by one, so that the next step will fill the bottom row from right to left.\\n```\\n1 2 3\\n0 0 4\\n0 0 5\\ncount = 3\\nendingcol = 1\\n```\\nFill the bottom row from right to left.\\n```\\n1 2 3\\n0 0 4\\n6 7 5\\ncount = 6\\n```\\nMove the ending row up by one, so that the next step will fill the left column from bottom to top.\\n```\\n1 2 3\\n0 0 4\\n6 7 5\\ncount = 6\\nendingrow = 1\\n```\\nFill the left column from bottom to top.\\n```\\n1 2 3\\n8 0 4\\n6 7 5\\ncount = 9\\n```\\nMove the starting column right by one, so that the next step will fill the top row from left to right again.\\n```\\n1 2 3\\n8 0 4\\n6 7 5\\ncount = 9\\nstartingcol = 1\\n```\\nRepeat steps 3 through 10 until the entire matrix is filled with numbers.\\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\\nThe matrix filled with integers from 1 to n x n in a clockwise spiral order.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# ---------------------------------------------------------\\n# Please Upvote If It helps You\\n# ---------------------------------------------------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        // creating a vector of n*n\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        \\n        //int row=matrix.size();\\n        //int col =matrix[0].size();\\n        int count =0;\\n        int total =n*n;\\n        \\n        //// all index \\n        \\n        int startingrow=0;\\n        int startingcol=0;\\n        int endingrow=n-1;\\n        int endingcol=n-1;\\n        \\n        while(count<total)\\n        {\\n            for(int i=startingcol;count<total && i<=endingcol; i++)\\n            {\\n                count++;\\n                ans[startingrow][i]=count;\\n                \\n            }\\n            startingrow++;\\n            \\n            for(int i=startingrow;count<total && i<=endingrow; i++)\\n            {\\n            \\n                count++;\\n                ans[i][endingcol]=count;\\n            }\\n            endingcol--;\\n            \\n            for(int i=endingcol;count<total && i>=startingcol; i--)\\n            {\\n                 count++;\\n                ans[endingrow][i]=count;\\n            }\\n            endingrow--;\\n            \\n            for(int i=endingrow;count<total && i>=startingrow; i--)\\n            {\\n                 count++;\\n                ans[i][startingcol]=count;\\n            \\n            }\\n            startingcol++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n# java code \\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n        // creating a matrix of n x n\\n        \\n        int[][] ans = new int[n][n];\\n        \\n        int count = 1;\\n        int total = n * n;\\n        \\n        // initialize variables for keeping track of starting and ending rows and columns\\n        int startingRow = 0;\\n        int endingRow = n - 1;\\n        int startingCol = 0;\\n        int endingCol = n - 1;\\n        \\n        while (count <= total) {\\n            \\n            // fill in the top row from left to right\\n            for (int i = startingCol; i <= endingCol; i++) {\\n                ans[startingRow][i] = count;\\n                count++;\\n            }\\n            startingRow++;\\n            \\n            // fill in the right column from top to bottom\\n            for (int i = startingRow; i <= endingRow; i++) {\\n                ans[i][endingCol] = count;\\n                count++;\\n            }\\n            endingCol--;\\n            \\n            // fill in the bottom row from right to left\\n            for (int i = endingCol; i >= startingCol; i--) {\\n                ans[endingRow][i] = count;\\n                count++;\\n            }\\n            endingRow--;\\n            \\n            // fill in the left column from bottom to top\\n            for (int i = endingRow; i >= startingRow; i--) {\\n                ans[i][startingCol] = count;\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Matrix"
                ],
                "code": "```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\n```\\n0 0 0\\n0 0 0\\n0 0 0\\n```\n```\\nstartingrow = 0\\nstartingcol = 0\\nendingrow = 2\\nendingcol = 2\\n```\n```\\n1 2 3\\n0 0 0\\n0 0 0\\ncount = 1\\n```\n```\\n0 0 0\\n0 0 0\\n0 0 0\\ncount = 1\\nstartingrow = 1\\n```\n```\\n1 2 3\\n0 0 4\\n0 0 5\\ncount = 3\\n```\n```\\n1 2 3\\n0 0 4\\n0 0 5\\ncount = 3\\nendingcol = 1\\n```\n```\\n1 2 3\\n0 0 4\\n6 7 5\\ncount = 6\\n```\n```\\n1 2 3\\n0 0 4\\n6 7 5\\ncount = 6\\nendingrow = 1\\n```\n```\\n1 2 3\\n8 0 4\\n6 7 5\\ncount = 9\\n```\n```\\n1 2 3\\n8 0 4\\n6 7 5\\ncount = 9\\nstartingcol = 1\\n```\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        // creating a vector of n*n\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        \\n        //int row=matrix.size();\\n        //int col =matrix[0].size();\\n        int count =0;\\n        int total =n*n;\\n        \\n        //// all index \\n        \\n        int startingrow=0;\\n        int startingcol=0;\\n        int endingrow=n-1;\\n        int endingcol=n-1;\\n        \\n        while(count<total)\\n        {\\n            for(int i=startingcol;count<total && i<=endingcol; i++)\\n            {\\n                count++;\\n                ans[startingrow][i]=count;\\n                \\n            }\\n            startingrow++;\\n            \\n            for(int i=startingrow;count<total && i<=endingrow; i++)\\n            {\\n            \\n                count++;\\n                ans[i][endingcol]=count;\\n            }\\n            endingcol--;\\n            \\n            for(int i=endingcol;count<total && i>=startingcol; i--)\\n            {\\n                 count++;\\n                ans[endingrow][i]=count;\\n            }\\n            endingrow--;\\n            \\n            for(int i=endingrow;count<total && i>=startingrow; i--)\\n            {\\n                 count++;\\n                ans[i][startingcol]=count;\\n            \\n            }\\n            startingcol++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n        // creating a matrix of n x n\\n        \\n        int[][] ans = new int[n][n];\\n        \\n        int count = 1;\\n        int total = n * n;\\n        \\n        // initialize variables for keeping track of starting and ending rows and columns\\n        int startingRow = 0;\\n        int endingRow = n - 1;\\n        int startingCol = 0;\\n        int endingCol = n - 1;\\n        \\n        while (count <= total) {\\n            \\n            // fill in the top row from left to right\\n            for (int i = startingCol; i <= endingCol; i++) {\\n                ans[startingRow][i] = count;\\n                count++;\\n            }\\n            startingRow++;\\n            \\n            // fill in the right column from top to bottom\\n            for (int i = startingRow; i <= endingRow; i++) {\\n                ans[i][endingCol] = count;\\n                count++;\\n            }\\n            endingCol--;\\n            \\n            // fill in the bottom row from right to left\\n            for (int i = endingCol; i >= startingCol; i--) {\\n                ans[endingRow][i] = count;\\n                count++;\\n            }\\n            endingRow--;\\n            \\n            // fill in the left column from bottom to top\\n            for (int i = endingRow; i >= startingRow; i--) {\\n                ans[i][startingCol] = count;\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978960,
                "title": "0ms-faster-than-100-easy-to-understand-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n,vector<int>(n));\\n        int top = 0, bottom = n-1, left = 0, right = n-1;\\n        int val = 1,direction=1;\\n        while(left<=right && top<=bottom)\\n        {\\n            if(direction == 1)    \\n            {   \\n                for(int i=left;i<=right;i++)\\n                {\\n                    res[top][i]=val++;\\n                }\\n                top++;\\n                direction=2;\\n            }\\n            else if(direction == 2)\\n            {\\n                for(int i = top;i<=bottom;i++)\\n                {\\n                    res[i][right]=val++;\\n                }\\n                right--;\\n                direction = 3;\\n            }\\n            else if(direction == 3)\\n            {\\n                for(int i = right;i>=left;i--)\\n                {\\n                    res[bottom][i]=val++;\\n                }\\n                bottom--;\\n                direction=4;\\n            }\\n            else if(direction == 4)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                    res[i][left]=val++;\\n                }\\n                left++;\\n                direction = 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n,vector<int>(n));\\n        int top = 0, bottom = n-1, left = 0, right = n-1;\\n        int val = 1,direction=1;\\n        while(left<=right && top<=bottom)\\n        {\\n            if(direction == 1)    \\n            {   \\n                for(int i=left;i<=right;i++)\\n                {\\n                    res[top][i]=val++;\\n                }\\n                top++;\\n                direction=2;\\n            }\\n            else if(direction == 2)\\n            {\\n                for(int i = top;i<=bottom;i++)\\n                {\\n                    res[i][right]=val++;\\n                }\\n                right--;\\n                direction = 3;\\n            }\\n            else if(direction == 3)\\n            {\\n                for(int i = right;i>=left;i--)\\n                {\\n                    res[bottom][i]=val++;\\n                }\\n                bottom--;\\n                direction=4;\\n            }\\n            else if(direction == 4)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                    res[i][left]=val++;\\n                }\\n                left++;\\n                direction = 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941099,
                "title": "python3-solution-using-spiral-traversal-in-o-n-n-time",
                "content": "I have seen some of the solutions to this problem in the discussion section which is mostly related to checking the matrix bounds or validating if the current cell is zero to determine the change of direction. \\n\\nI have actually solved a similar problem before -> https://leetcode.com/problems/spiral-matrix/ and I will try to explain the same approach that I used there as I think its easier to comprehend and seemed more intuitive.\\n\\nThe main idea here is that we initialize **bounds** for four directions: **up**, **down**, **left** and **right**. For each iteration, we **traverse the complete spiral** i.e in all 4 directions. At the end, we just need to **increment or decrement the bounds** accordingly. The code has an extra check after traversing right and down directions to determine if it has landed on same row or column. \\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        up, down, left, right = 0, n-1, 0, n-1\\n        \\n        num = 1\\n        while num <= (n * n):\\n            for idx in range(left, right + 1):\\n                matrix[up][idx] = num\\n                num+=1\\n            \\n            for idx in range(up + 1, down + 1):\\n                matrix[idx][right] = num\\n                num+=1\\n            \\n            # not the same row\\n            if up != down:\\n                for idx in range(right - 1, left - 1, -1):\\n                    matrix[down][idx] = num\\n                    num+=1\\n            #not the same column\\n            if left != right:\\n                for idx in range(down - 1, up, -1):\\n                    matrix[idx][left] = num\\n                    num+=1\\n            \\n            left+=1\\n            up+=1\\n            right-=1\\n            down-=1\\n        return matrix\\n```\\n\\nPlease upvote if you find it useful\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        up, down, left, right = 0, n-1, 0, n-1\\n        \\n        num = 1\\n        while num <= (n * n):\\n            for idx in range(left, right + 1):\\n                matrix[up][idx] = num\\n                num+=1\\n            \\n            for idx in range(up + 1, down + 1):\\n                matrix[idx][right] = num\\n                num+=1\\n            \\n            # not the same row\\n            if up != down:\\n                for idx in range(right - 1, left - 1, -1):\\n                    matrix[down][idx] = num\\n                    num+=1\\n            #not the same column\\n            if left != right:\\n                for idx in range(down - 1, up, -1):\\n                    matrix[idx][left] = num\\n                    num+=1\\n            \\n            left+=1\\n            up+=1\\n            right-=1\\n            down-=1\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471809,
                "title": "javascript-simple",
                "content": "Runtime: 68 ms, faster than 90.62% of JavaScript online submissions for Spiral Matrix II.\\nMemory Usage: 38.7 MB, less than 83.38% of JavaScript online submissions for Spiral Matrix II.\\n\\n```\\nvar generateMatrix = function(n) {\\n    \\n    let output = new Array(n).fill(0).map(() => new Array(n).fill(0))\\n    \\n    let count = 0;\\n    \\n    let size = n * n;\\n    \\n    let left = 0;\\n    \\n    let right = n - 1;\\n    \\n    let top = 0;\\n    \\n    let bottom = n -1;\\n    \\n    while(count < size){\\n        \\n        //going left\\n        for(let i = left; i <= right; i++){\\n            count++;\\n            output[top][i] = count;\\n        }\\n        top++;\\n                \\n        // going down\\n        for(let i = top; i <= bottom; i++){\\n            count++;\\n            output[i][right] = count;\\n        }\\n        right--;\\n        \\n        //going left\\n        for(let i = right; i >= left; i--){\\n            count++;\\n            output[bottom][i] = count;\\n        }\\n        bottom--;\\n        \\n        //going up\\n        for(let i = bottom; i >= top; i--){\\n            count++;\\n            output[i][left] = count;\\n        }\\n        left++;\\n    }\\n    \\n    return output;\\n    \\n};\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateMatrix = function(n) {\\n    \\n    let output = new Array(n).fill(0).map(() => new Array(n).fill(0))\\n    \\n    let count = 0;\\n    \\n    let size = n * n;\\n    \\n    let left = 0;\\n    \\n    let right = n - 1;\\n    \\n    let top = 0;\\n    \\n    let bottom = n -1;\\n    \\n    while(count < size){\\n        \\n        //going left\\n        for(let i = left; i <= right; i++){\\n            count++;\\n            output[top][i] = count;\\n        }\\n        top++;\\n                \\n        // going down\\n        for(let i = top; i <= bottom; i++){\\n            count++;\\n            output[i][right] = count;\\n        }\\n        right--;\\n        \\n        //going left\\n        for(let i = right; i >= left; i--){\\n            count++;\\n            output[bottom][i] = count;\\n        }\\n        bottom--;\\n        \\n        //going up\\n        for(let i = bottom; i >= top; i--){\\n            count++;\\n            output[i][left] = count;\\n        }\\n        left++;\\n    }\\n    \\n    return output;\\n    \\n};\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22295,
                "title": "java-simple-and-clear-easy-understood",
                "content": "```\\npublic class Solution {\\n    public int[][] generateMatrix(int n) {\\n        // similar to spiral matrix I,done by myself\\n        int[][] rs = new int[n][n];\\n        int top = 0,bottom = n-1,left = 0,right = n-1;\\n        int num = 1;\\n        \\n        while(left<=right && top <=bottom){\\n            for(int i=left;i<=right;i++){\\n                rs[top][i] = num++;\\n            }\\n            top++;\\n            for(int i= top;i<=bottom;i++){\\n                rs[i][right] = num++;\\n            }\\n            right--;\\n            for(int i= right;i>=left;i-- ){\\n                rs[bottom][i] = num++;\\n            }\\n            bottom--;\\n            for(int i = bottom;i>=top;i--){\\n                rs[i][left] = num++;\\n            }\\n            left++;\\n        }\\n        return rs;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] generateMatrix(int n) {\\n        // similar to spiral matrix I,done by myself\\n        int[][] rs = new int[n][n];\\n        int top = 0,bottom = n-1,left = 0,right = n-1;\\n        int num = 1;\\n        \\n        while(left<=right && top <=bottom){\\n            for(int i=left;i<=right;i++){\\n                rs[top][i] = num++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1738824,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        let map = [Int](repeating: -1, count: n)\\n        var res = [[Int]](repeating: map, count: n)\\n        let grid = (n * n)\\n        var top = 0, btm = n - 1, lhs = 0, rhs = (n - 1)\\n        var elm = 1\\n        \\n        while elm <= grid {\\n            if lhs <= rhs && elm <= grid { // left -> right\\n                for i in lhs...rhs {\\n                    res[top][i] = elm\\n                    elm += 1\\n                }\\n                top += 1\\n            }\\n            if top <= btm && elm <= grid { // top -> bottom\\n                for i in top...btm {\\n                    res[i][rhs] =  elm\\n                    elm += 1\\n                }\\n                rhs -= 1\\n            }\\n            if lhs <= rhs && elm <= grid { // right -> left\\n                for i in (lhs...rhs).reversed() {\\n                    res[btm][i] = elm\\n                    elm +=  1\\n                }\\n                btm -= 1\\n            }\\n            if top <= btm && elm <= grid { // bottom -> top\\n                for i in (top...btm).reversed() {\\n                    res[i][lhs] = elm\\n                    elm += 1\\n                }\\n                lhs += 1\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.generateMatrix(3)\\n        XCTAssertEqual(value, [[1,2,3],[8,9,4],[7,6,5]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.generateMatrix(1)\\n        XCTAssertEqual(value, [[1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        let map = [Int](repeating: -1, count: n)\\n        var res = [[Int]](repeating: map, count: n)\\n        let grid = (n * n)\\n        var top = 0, btm = n - 1, lhs = 0, rhs = (n - 1)\\n        var elm = 1\\n        \\n        while elm <= grid {\\n            if lhs <= rhs && elm <= grid { // left -> right\\n                for i in lhs...rhs {\\n                    res[top][i] = elm\\n                    elm += 1\\n                }\\n                top += 1\\n            }\\n            if top <= btm && elm <= grid { // top -> bottom\\n                for i in top...btm {\\n                    res[i][rhs] =  elm\\n                    elm += 1\\n                }\\n                rhs -= 1\\n            }\\n            if lhs <= rhs && elm <= grid { // right -> left\\n                for i in (lhs...rhs).reversed() {\\n                    res[btm][i] = elm\\n                    elm +=  1\\n                }\\n                btm -= 1\\n            }\\n            if top <= btm && elm <= grid { // bottom -> top\\n                for i in (top...btm).reversed() {\\n                    res[i][lhs] = elm\\n                    elm += 1\\n                }\\n                lhs += 1\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.generateMatrix(3)\\n        XCTAssertEqual(value, [[1,2,3],[8,9,4],[7,6,5]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.generateMatrix(1)\\n        XCTAssertEqual(value, [[1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941149,
                "title": "c-easy-to-understand-solved-live-on-stream",
                "content": "Pretty straight forward.  No special algo.  \\nWe solve problems EVERYDAY 6pm PT.  There are dozens of us.\\n**Link in profile**\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n, 0));\\n        \\n        int top = 0;\\n        int bot = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int dir = 0; \\n        int num = 1;\\n        \\n        while(top <= bot && left <= right) {\\n            if(dir == 0) {\\n                for(int c = left; c <= right; c++) {\\n                    matrix[top][c] = num++;\\n                }\\n                dir++;\\n                top++;\\n            } else if (dir == 1) {\\n                for(int r = top; r <= bot; r++) {\\n                    matrix[r][right] = num++;\\n                }\\n                dir++;\\n                right--;\\n            } else if (dir == 2) {\\n                for(int c = right; c >= left; c--) {\\n                    matrix[bot][c] = num++;\\n                }\\n                dir++;\\n                bot--;\\n            } else if (dir == 3) {\\n                for(int r = bot; r >= top; r--){\\n                    matrix[r][left] = num++;\\n                }\\n                dir = 0;\\n                left++;\\n            }\\n        }      \\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n, 0));\\n        \\n        int top = 0;\\n        int bot = n - 1;\\n        int left = 0;\\n        int right = n - 1;\\n        int dir = 0; \\n        int num = 1;\\n        \\n        while(top <= bot && left <= right) {\\n            if(dir == 0) {\\n                for(int c = left; c <= right; c++) {\\n                    matrix[top][c] = num++;\\n                }\\n                dir++;\\n                top++;\\n            } else if (dir == 1) {\\n                for(int r = top; r <= bot; r++) {\\n                    matrix[r][right] = num++;\\n                }\\n                dir++;\\n                right--;\\n            } else if (dir == 2) {\\n                for(int c = right; c >= left; c--) {\\n                    matrix[bot][c] = num++;\\n                }\\n                dir++;\\n                bot--;\\n            } else if (dir == 3) {\\n                for(int r = bot; r >= top; r--){\\n                    matrix[r][left] = num++;\\n                }\\n                dir = 0;\\n                left++;\\n            }\\n        }      \\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912550,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        var matrix: [[Int]] = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        let count = n / 2\\n        var num = 1\\n        \\n        for i in 0..<count {\\n            var index = 0\\n            for j in i..<(n - i - 1) {\\n                \\n                let i1 = i\\n                let j1 = j\\n                matrix[i1][j1] =  num + j - i\\n                \\n                let i2 = j\\n                let j2 = n - i - 1\\n                matrix[i2][j2] =  num + j + (n - i * 2 - 1) * 1 - i\\n                \\n                let i3 = n - i - 1\\n                let j3 = n - j - 1\\n                matrix[i3][j3] =  num + j + (n - i * 2 - 1) * 2 - i\\n                \\n                let i4 = n - j - 1\\n                let j4 = i\\n                matrix[i4][j4] =  num + j + (n - i * 2 - 1) * 3 - i\\n                index += 4\\n            }\\n            num += index\\n        }\\n        \\n        if n % 2 == 1 { matrix[(n - 1) / 2][(n - 1) / 2] = n * n }\\n        return matrix\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        var matrix: [[Int]] = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        let count = n / 2\\n        var num = 1\\n        \\n        for i in 0..<count {\\n            var index = 0\\n            for j in i..<(n - i - 1) {\\n                \\n                let i1 = i\\n                let j1 = j\\n                matrix[i1][j1] =  num + j - i\\n                \\n                let i2 = j\\n                let j2 = n - i - 1\\n                matrix[i2][j2] =  num + j + (n - i * 2 - 1) * 1 - i\\n                \\n                let i3 = n - i - 1\\n                let j3 = n - j - 1\\n                matrix[i3][j3] =  num + j + (n - i * 2 - 1) * 2 - i\\n                \\n                let i4 = n - j - 1\\n                let j4 = i\\n                matrix[i4][j4] =  num + j + (n - i * 2 - 1) * 3 - i\\n                index += 4\\n            }\\n            num += index\\n        }\\n        \\n        if n % 2 == 1 { matrix[(n - 1) / 2][(n - 1) / 2] = n * n }\\n        return matrix\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705624,
                "title": "java-dfs-recursive",
                "content": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        var m = new int[n][n];\\n        dfs(m, 0, 0, false, 1);\\n        return m;\\n    }\\n    private void dfs(int[][] m, int row, int col, boolean goup,int count) {\\n        if (row < 0 || col < 0 || col >= m[0].length || row >= m.length || m[row][col] != 0) return;\\n        m[row][col] = count;\\n        count++;\\n        if (goup) dfs(m, row-1, col, true, count);\\n        dfs(m, row, col+1, false, count);\\n        dfs(m, row + 1, col, false, count);\\n        dfs(m, row, col-1, false, count);\\n        dfs(m, row-1, col, true, count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        var m = new int[n][n];\\n        dfs(m, 0, 0, false, 1);\\n        return m;\\n    }\\n    private void dfs(int[][] m, int row, int col, boolean goup,int count) {\\n        if (row < 0 || col < 0 || col >= m[0].length || row >= m.length || m[row][col] != 0) return;\\n        m[row][col] = count;\\n        count++;\\n        if (goup) dfs(m, row-1, col, true, count);\\n        dfs(m, row, col+1, false, count);\\n        dfs(m, row + 1, col, false, count);\\n        dfs(m, row, col-1, false, count);\\n        dfs(m, row-1, col, true, count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507200,
                "title": "single-loop-java-solution-easy-to-understand-0-ms",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int x = 1,cnt = 0;\\n        int[][] ans = new int[n][n];\\n        int i = 0,j = 0,k = 0;\\n        while(cnt < (n * n)){\\n            i(ans[i][j] == 0){\\n                ans[i][j] = x++;\\n                if(i == k && j < n - 1 - k) j++;\\n                else if(j == n - 1 - k && i < n - 1 - k) i++;\\n                else if(i == n - 1 - k && j <= n - 1 - k && j != k) j--;\\n                else if(i <= n - 1 - k && j == k) i--;\\n                cnt++;\\n            }else{ \\n                k++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int x = 1,cnt = 0;\\n        int[][] ans = new int[n][n];\\n        int i = 0,j = 0,k = 0;\\n        while(cnt < (n * n)){\\n            i(ans[i][j] == 0){\\n                ans[i][j] = x++;\\n                if(i == k && j < n - 1 - k) j++;\\n                else if(j == n - 1 - k && i < n - 1 - k) i++;\\n                else if(i == n - 1 - k && j <= n - 1 - k && j != k) j--;\\n                else if(i <= n - 1 - k && j == k) i--;\\n                cnt++;\\n            }else{ \\n                k++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941021,
                "title": "javascript-neat-3-methods-elegant-math-no-if",
                "content": "## 1. Elegant (optimized 2nd approach)\\n\\n```js\\nconst generateMatrix = (n) => {\\n  const M = [...Array(n)].map(() => Array(n).fill(0));\\n  let x = 0, y = 0, dx = 1, dy = 0;\\n  for (let i = 1, nn = n**2; i <= nn; ++i) {\\n    M[y][x] = i;\\n    if (!M[y + dy] || M[y + dy][x + dx] !== 0)\\n      [dx, dy] = [-dy, dx];\\n    x += dx;\\n    y += dy;\\n  }\\n  return M;\\n};\\n```\\n\\n## 2. Math power\\n\\n```js\\nconst generateMatrix = (n) => {\\n  const {max, abs, floor} = Math;\\n  const num = (x, y) => {\\n    x += x - n + 1;\\n    y += y - n + 1;\\n    const m = max(abs(x), abs(y));\\n    let p = floor((x + y) / 2);\\n    if (x < y) p = 2 * m - p;\\n    return n * n - m * m - m + p;\\n  }\\n    \\n  const M = [];\\n  for (let y = 0; y < n; ++y) {\\n    M[y] = [];\\n    for (let x = 0; x < n; ++x)\\n      M[y][x] = num(x, y);\\n  }\\n  return M;\\n};\\n```\\n\\n## 3. Without IF\\n\\nThere are the steps in each direction in the spiral for n = 5.\\n`[0, 5, 4, 4, 3, 3, 2, 2, 1, 1]` and for any n `[0, n,  n - 1, n - 1,  ..., 3, 3, 2, 2, 1, 1]`\\nUpdate signs of directions.\\n`[0, 5, 4, -4, -3, 3, 2, -2, -1, 1]`\\n\\n```js\\nconst generateMatrix = (n) => {    \\n  const M = [...Array(n)].map(() => Array(n));\\n  let v = 0, x = -1, y = 0;\\n  for (let i = 0, m, s, dx, dy; i < 2*n; ++i) {\\n    m = i && (2*n - i + 1) / 2|0;\\n    s = (-1)**((i - 1)/2|0);\\n    dx = s * (i % 2);\\n    dy = s * ((i + 1) % 2);\\n    for (let j = 0; j < m; ++j) {\\n      x += dx;\\n      y += dy;\\n      M[y][x] = ++v;\\n    }\\n  }\\n  return M;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst generateMatrix = (n) => {\\n  const M = [...Array(n)].map(() => Array(n).fill(0));\\n  let x = 0, y = 0, dx = 1, dy = 0;\\n  for (let i = 1, nn = n**2; i <= nn; ++i) {\\n    M[y][x] = i;\\n    if (!M[y + dy] || M[y + dy][x + dx] !== 0)\\n      [dx, dy] = [-dy, dx];\\n    x += dx;\\n    y += dy;\\n  }\\n  return M;\\n};\\n```\n```js\\nconst generateMatrix = (n) => {\\n  const {max, abs, floor} = Math;\\n  const num = (x, y) => {\\n    x += x - n + 1;\\n    y += y - n + 1;\\n    const m = max(abs(x), abs(y));\\n    let p = floor((x + y) / 2);\\n    if (x < y) p = 2 * m - p;\\n    return n * n - m * m - m + p;\\n  }\\n    \\n  const M = [];\\n  for (let y = 0; y < n; ++y) {\\n    M[y] = [];\\n    for (let x = 0; x < n; ++x)\\n      M[y][x] = num(x, y);\\n  }\\n  return M;\\n};\\n```\n```js\\nconst generateMatrix = (n) => {    \\n  const M = [...Array(n)].map(() => Array(n));\\n  let v = 0, x = -1, y = 0;\\n  for (let i = 0, m, s, dx, dy; i < 2*n; ++i) {\\n    m = i && (2*n - i + 1) / 2|0;\\n    s = (-1)**((i - 1)/2|0);\\n    dx = s * (i % 2);\\n    dy = s * ((i + 1) % 2);\\n    for (let j = 0; j < m; ++j) {\\n      x += dx;\\n      y += dy;\\n      M[y][x] = ++v;\\n    }\\n  }\\n  return M;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 963337,
                "title": "c-100-simple-walk-the-spiral-solution",
                "content": "My C++ walk the spiral solution going clockwise from outside to inside\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        // create n * n vector of vectors we will populate and return at the end\\n        vector<vector<int>> result(n, vector<int>(n));\\n        \\n        // calculate how many levels deep the spiral is and keep count of walking the spiral\\n        int level = ceil(n / 2), count = 1;\\n        \\n        // start from outside level moving inside\\n        for (int l = 0; l <= level; ++l) {\\n            // populate top row from left to right\\n            for (int a = l; a < n - l; ++a) result[l][a] = count++;\\n            \\n            // populate right column from top to bottom\\n            for (int b = l + 1; b < n - l; ++b) result[b][n - l - 1] = count++;\\n            \\n            // populate bottom row from right to left\\n            for (int c = l + 1; c < n - l; ++c) result[n - l - 1][n - c - 1] = count++;\\n            \\n            // populate left column from bottom to top\\n            for (int d = l + 1; d < n - l - 1; ++d) result[n - d - 1][l] = count++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        // create n * n vector of vectors we will populate and return at the end\\n        vector<vector<int>> result(n, vector<int>(n));\\n        \\n        // calculate how many levels deep the spiral is and keep count of walking the spiral\\n        int level = ceil(n / 2), count = 1;\\n        \\n        // start from outside level moving inside\\n        for (int l = 0; l <= level; ++l) {\\n            // populate top row from left to right\\n            for (int a = l; a < n - l; ++a) result[l][a] = count++;\\n            \\n            // populate right column from top to bottom\\n            for (int b = l + 1; b < n - l; ++b) result[b][n - l - 1] = count++;\\n            \\n            // populate bottom row from right to left\\n            for (int c = l + 1; c < n - l; ++c) result[n - l - 1][n - c - 1] = count++;\\n            \\n            // populate left column from bottom to top\\n            for (int d = l + 1; d < n - l - 1; ++d) result[n - d - 1][l] = count++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22473,
                "title": "share-my-simple-solution-with-graphical-explanation-java",
                "content": "If n is odd, only the first direction will cover it (top left -> right, shown as # in the graph), because the other three direction all start from the next position( +1 or -1).\\n\\n    /**\\n    \\t * -> -> ->\\n    \\t * ^      |\\n    \\t * |      |\\n    \\t * <- <-- V\\n    \\t * \\n    \\t * # # # #\\n    \\t * %     $\\n    \\t * %     $\\n    \\t * & & & $\\n    \\t *     \\n    \\t */\\n        public static int[][] generateMatrix(int n) {\\n        \\tint[][] res = new int[n][n];\\n        \\t\\n        \\tint num = 1;\\n        \\tint level = (int) Math.ceil(n / 2.);\\n        \\t\\n        \\tfor(int i = 0; i < level; i++) {\\n        \\t\\t\\n        \\t\\t// top left -> right, shown as #\\n        \\t\\tfor(int j = i; j < n - i; j++)\\n        \\t\\t\\tres[i][j] = num++;\\n        \\t\\t\\n        \\t\\t// top right + 1 -> bot, shown as $\\n        \\t\\tfor(int j = i + 1; j < n - i; j++)\\n        \\t\\t\\tres[j][n - i - 1] = num++;\\n        \\t\\t\\n        \\t\\t// bot right - 1 -> left, shown as &\\n        \\t\\tfor(int j = n - i - 2; j >= i; j--)\\n        \\t\\t\\tres[n - i - 1][j] = num++;\\n        \\t\\t\\n        \\t\\t// bot left -1 -> top + 1, shown as %\\n        \\t\\tfor(int j = n - i - 2; j > i; j--)\\n        \\t\\t\\tres[j][i] = num++;\\n        \\t}\\n        \\treturn res;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "If n is odd, only the first direction will cover it (top left -> right, shown as # in the graph), because the other three direction all start from the next position( +1 or -1).\\n\\n    /**\\n    \\t * -> -> ->\\n    \\t * ^      |\\n    \\t * |      |\\n    \\t * <- <-- V\\n    \\t * \\n    \\t * # # # #\\n    \\t * %     $\\n    \\t * %     $\\n    \\t * & & & $\\n    \\t *     \\n    \\t */\\n        public static int[][] generateMatrix(int n) {\\n        \\tint[][] res = new int[n][n];\\n        \\t\\n        \\tint num = 1;\\n        \\tint level = (int) Math.ceil(n / 2.);\\n        \\t\\n        \\tfor(int i = 0; i < level; i++) {\\n        \\t\\t\\n        \\t\\t// top left -> right, shown as #\\n        \\t\\tfor(int j = i; j < n - i; j++)\\n        \\t\\t\\tres[i][j] = num++;\\n        \\t\\t\\n        \\t\\t// top right + 1 -> bot, shown as $\\n        \\t\\tfor(int j = i + 1; j < n - i; j++)\\n        \\t\\t\\tres[j][n - i - 1] = num++;\\n        \\t\\t\\n        \\t\\t// bot right - 1 -> left, shown as &\\n        \\t\\tfor(int j = n - i - 2; j >= i; j--)\\n        \\t\\t\\tres[n - i - 1][j] = num++;\\n        \\t\\t\\n        \\t\\t// bot left -1 -> top + 1, shown as %\\n        \\t\\tfor(int j = n - i - 2; j > i; j--)\\n        \\t\\t\\tres[j][i] = num++;\\n        \\t}\\n        \\treturn res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3507105,
                "title": "simple-java-solution-beginner-friendly-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStarting from the top left corner and moving clockwise. It traverse by filling the top row, right column, bottom row, and left column of the matrix in sequence until the entire matrix is filled.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize a 2D array of size n x n with all elements set to 0.\\n- Use four variables l, t, b, and r to keep track of the boundaries of the matrix.\\n- Use a while loop that continues until either t becomes greater than b or l becomes greater than r, indicating that the entire matrix has been filled.\\n- Use four nested if statements, each of which generates a segment of the spiral by iterating through the appropriate row or column and assigning values to the matrix elements.\\n- After each segment is generated, update the corresponding boundary variables to exclude the row or column that has been filled.\\n- Return the resulting matrix.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int [][] a = new int[n][n];\\n        int l=0,t=0,b=n-1,r=n-1,v=1;\\n        while(t<=b||l<=r){\\n         if(t<=b){\\n             for(int i=l;i<=r;i++)\\n                a[t][i]=v++;\\n             t++;\\n         }\\n         if(l<=r){\\n             for(int i=t;i<=b;i++)\\n                 a[i][r]=v++;\\n             r--;\\n         }\\n         if(t<=b){\\n             for(int i=r;i>=l;i--)\\n             a[b][i]=v++;\\n             b--;\\n         }\\n         if(t<=b){\\n             for(int i=b;i>=t;i--)\\n             a[i][l]=v++;\\n         }\\n         l++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int [][] a = new int[n][n];\\n        int l=0,t=0,b=n-1,r=n-1,v=1;\\n        while(t<=b||l<=r){\\n         if(t<=b){\\n             for(int i=l;i<=r;i++)\\n                a[t][i]=v++;\\n             t++;\\n         }\\n         if(l<=r){\\n             for(int i=t;i<=b;i++)\\n                 a[i][r]=v++;\\n             r--;\\n         }\\n         if(t<=b){\\n             for(int i=r;i>=l;i--)\\n             a[b][i]=v++;\\n             b--;\\n         }\\n         if(t<=b){\\n             for(int i=b;i>=t;i--)\\n             a[i][l]=v++;\\n         }\\n         l++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506353,
                "title": "c-beats-100-solution-t-c-o-n-n-fully-explained-step-by-step",
                "content": "\\n# Approach\\n1.Here we have a sqare matrix of size n*n;\\n2.declare variables like starting top=0, right= n-1, left=0, bottom= n-1 and a =1.\\n3.declare count=0 and check it at every moment that it is less than and equal to end.\\nfirst we will print first row, by moving from left to right. and increase top by 1, so that we can print next row in second iteration and insert value in vector and increase by 1.\\nThen, we will print last column, by moving from top to bottom and decrease right by 1 so that we can to next inner col and insert value in vector and increase by 1.\\nthen we will print last row, by moving from right to left. and decrease bottom by 1, so that we can move to next inner row in next iteration and insert value in vector and increase by 1.\\nthen we will print first col, by moving from bottom to top, and increase left by 1, so that we can move to next col in next iteration and insert value in vector and increase by 1.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>res(n,vector<int>(n));\\n        int top=0;int left=0;\\n        int right=n-1;int bottom=n-1;\\n        int a=1;\\n        while(top<=bottom && left<=right){\\n            for(int i=left;i<=right;i++){//top\\n                \\n                res[top][i]=a;\\n                a++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){//right\\n                res[i][right]=a;\\n                a++;\\n            }\\n            right--;\\n            if(top<=bottom){\\n                for(int i=right;i>=left;i--){//bottom in reverse\\n                res[bottom][i]=a;\\n                a++;\\n            }\\n            bottom--;\\n            }\\n            if(left<=right){\\n                for(int i=bottom;i>=top;i--){//left in reverse\\n                res[i][left]=a;\\n                a++;\\n            }\\n            left++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>res(n,vector<int>(n));\\n        int top=0;int left=0;\\n        int right=n-1;int bottom=n-1;\\n        int a=1;\\n        while(top<=bottom && left<=right){\\n            for(int i=left;i<=right;i++){//top\\n                \\n                res[top][i]=a;\\n                a++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){//right\\n                res[i][right]=a;\\n                a++;\\n            }\\n            right--;\\n            if(top<=bottom){\\n                for(int i=right;i>=left;i--){//bottom in reverse\\n                res[bottom][i]=a;\\n                a++;\\n            }\\n            bottom--;\\n            }\\n            if(left<=right){\\n                for(int i=bottom;i>=top;i--){//left in reverse\\n                res[i][left]=a;\\n                a++;\\n            }\\n            left++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202560,
                "title": "spiral-matrix-i-ii-iii-iv-solutions",
                "content": "# Explaination\\n- This is a very simple and easy to understand solution. I have traversed RIGHT and incremented TOP, then traverse DOWN and decrement RIGHT, then I traverse LEFT and decrement BOTTOM, and finally I have traversed UP and increment LEFT.\\n\\n- The only tricky part is that when I traverse left or up I have to check whether the row or col still exists to prevent duplicates. \\nAny comments greatly appreciated.\\n\\n# Complexity\\n- Time Complexity: O(m*n)\\n- Space Complexity: O(1)\\n\\n# Spiral Matrix I\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> v;\\n        if (matrix.size() == 0) \\n            return v;\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                v.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                v.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                v.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                v.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n```\\n# Spiral Matrix II\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int> (n, 0));\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        int count = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = count;\\n                count++;\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = count;\\n                count++;\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                matrix[bottom][i] = count;\\n                count++;\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                matrix[i][left] = count;\\n                count++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\\n# Spiral Matrix III\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> matrix;\\n        int count = 0, step = 1;\\n        \\n        while(count < rows*cols){\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart++;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart++;\\n            }\\n            step++;\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart--;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart--;\\n            }\\n            step++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\\n# Sprial Matrix IV\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> matrix(m, vector<int> (n, -1));\\n        int left = 0, right = n-1, top = 0, bottom = m-1;\\n        while(left<=right and top<=bottom){\\n            for(int i = left; i<=right; i++){\\n                if(head){\\n                    matrix[top][i] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            top++;\\n            for(int i = top; i<=bottom; i++){\\n                if(head){\\n                    matrix[i][right] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            right--;\\n            for(int i = right; top<=bottom && i>=left; i--){ \\n                if(head){\\n                    matrix[bottom][i] = head->val;\\n                    head = head->next;\\n                }\\n            }   \\n            bottom--;\\n            for(int i = bottom; left<=right && i>=top; i--){\\n                if(head){\\n                    matrix[i][left] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> v;\\n        if (matrix.size() == 0) \\n            return v;\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                v.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                v.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                v.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                v.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int> (n, 0));\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        int count = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = count;\\n                count++;\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = count;\\n                count++;\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                matrix[bottom][i] = count;\\n                count++;\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                matrix[i][left] = count;\\n                count++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> matrix;\\n        int count = 0, step = 1;\\n        \\n        while(count < rows*cols){\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart++;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart++;\\n            }\\n            step++;\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart--;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart--;\\n            }\\n            step++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> matrix(m, vector<int> (n, -1));\\n        int left = 0, right = n-1, top = 0, bottom = m-1;\\n        while(left<=right and top<=bottom){\\n            for(int i = left; i<=right; i++){\\n                if(head){\\n                    matrix[top][i] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            top++;\\n            for(int i = top; i<=bottom; i++){\\n                if(head){\\n                    matrix[i][right] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            right--;\\n            for(int i = right; top<=bottom && i>=left; i--){ \\n                if(head){\\n                    matrix[bottom][i] = head->val;\\n                    head = head->next;\\n                }\\n            }   \\n            bottom--;\\n            for(int i = bottom; left<=right && i>=top; i--){\\n                if(head){\\n                    matrix[i][left] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309475,
                "title": "easy-java-solution-beats-100-online-java-submissions",
                "content": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n       int[][] ans=new int[n][n];\\n       \\n        int rowBegin=0;\\n        int rowEnd=n-1;\\n        int columnBegin=0;\\n        int columnEnd=n-1;\\n        int counter=0;\\n      \\n        while(rowBegin<=rowEnd && columnBegin<=columnEnd && counter<=n*n){\\n            \\n            for(int i=columnBegin;i<=columnEnd;i++){\\n                counter++;\\n                ans[rowBegin][i]=counter;\\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd;i++){\\n                counter++;\\n                ans[i][columnEnd]=counter;\\n            }\\n            columnEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=columnEnd;i>=columnBegin;i--){\\n                counter++;\\n                ans[rowEnd][i]=counter;\\n            }\\n           \\n            }\\n             rowEnd--;\\n            if(columnBegin<=columnEnd){\\n                for(int i=rowEnd;i>=rowBegin;i--){\\n                counter++;    \\n                ans[i][columnBegin]=counter;\\n            }\\n            \\n            }\\n            columnBegin++;\\n           \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n       int[][] ans=new int[n][n];\\n       \\n        int rowBegin=0;\\n        int rowEnd=n-1;\\n        int columnBegin=0;\\n        int columnEnd=n-1;\\n        int counter=0;\\n      \\n        while(rowBegin<=rowEnd && columnBegin<=columnEnd && counter<=n*n){\\n            \\n            for(int i=columnBegin;i<=columnEnd;i++){\\n                counter++;\\n                ans[rowBegin][i]=counter;\\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd;i++){\\n                counter++;\\n                ans[i][columnEnd]=counter;\\n            }\\n            columnEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=columnEnd;i>=columnBegin;i--){\\n                counter++;\\n                ans[rowEnd][i]=counter;\\n            }\\n           \\n            }\\n             rowEnd--;\\n            if(columnBegin<=columnEnd){\\n                for(int i=rowEnd;i>=rowBegin;i--){\\n                counter++;    \\n                ans[i][columnBegin]=counter;\\n            }\\n            \\n            }\\n            columnBegin++;\\n           \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941152,
                "title": "c-two-pointer-approach",
                "content": "```\\nAlgorithm\\n---------\\n* Step1: Initialize beg = 0 and end  = n - 1\\n* Step2: Repeat Step3 to Step7 while beg < end\\n* Step3: Fill current first row(beg) from left-right\\n* Step4: Fill current last column(end) from top-bottom\\n* Step5: Fill current last row(end) from right-left\\n* Step6: Fill current first column(beg) from bottom-top\\n* Step7: Increment beg and decrement end\\n* Step8: Go to Step2\\n* Step9: Fill the cell[beg][end] if beg == end\\n* Step10: Return matrix\\n\\nComplexities\\n------------\\n* Time: O(n*n)\\n* Space: O(1)\\n\\nNote: Since, the matrix is square, we can traverse it spirally by using just 2 pointers.\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        \\n        int beg = 0, end = n - 1, temp = -1, ptr = 1;\\n        while(beg < end) {\\n            // fill left to right\\n            temp = beg;\\n            while(temp < end) {\\n                matrix[beg][temp++] = ptr++;\\n            }\\n            \\n            // fill top to bottom\\n            temp = beg;\\n            while(temp < end) {\\n                matrix[temp++][end] = ptr++;\\n            }\\n            \\n            //fill right to left\\n            temp = end;\\n            while(temp > beg) {\\n                matrix[end][temp--] = ptr++;\\n            }\\n            \\n            //fill bottom to top\\n            temp = end;\\n            while(temp > beg) {\\n                matrix[temp--][beg] = ptr++;\\n            }\\n            beg++;\\n            end--;\\n        }\\n        \\n        // for odd n\\n        if(beg == end) matrix[beg][end] = ptr;\\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nAlgorithm\\n---------\\n* Step1: Initialize beg = 0 and end  = n - 1\\n* Step2: Repeat Step3 to Step7 while beg < end\\n* Step3: Fill current first row(beg) from left-right\\n* Step4: Fill current last column(end) from top-bottom\\n* Step5: Fill current last row(end) from right-left\\n* Step6: Fill current first column(beg) from bottom-top\\n* Step7: Increment beg and decrement end\\n* Step8: Go to Step2\\n* Step9: Fill the cell[beg][end] if beg == end\\n* Step10: Return matrix\\n\\nComplexities\\n------------\\n* Time: O(n*n)\\n* Space: O(1)\\n\\nNote: Since, the matrix is square, we can traverse it spirally by using just 2 pointers.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        \\n        int beg = 0, end = n - 1, temp = -1, ptr = 1;\\n        while(beg < end) {\\n            // fill left to right\\n            temp = beg;\\n            while(temp < end) {\\n                matrix[beg][temp++] = ptr++;\\n            }\\n            \\n            // fill top to bottom\\n            temp = beg;\\n            while(temp < end) {\\n                matrix[temp++][end] = ptr++;\\n            }\\n            \\n            //fill right to left\\n            temp = end;\\n            while(temp > beg) {\\n                matrix[end][temp--] = ptr++;\\n            }\\n            \\n            //fill bottom to top\\n            temp = end;\\n            while(temp > beg) {\\n                matrix[temp--][beg] = ptr++;\\n            }\\n            beg++;\\n            end--;\\n        }\\n        \\n        // for odd n\\n        if(beg == end) matrix[beg][end] = ptr;\\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791511,
                "title": "python-simple-logic",
                "content": "We can move in 4 directions:\\nIf direction == 0: Move from left to right in top row\\nIf direction == 1: Move from top to bottom in right column\\nIf direction == 2: Move from right to left in bottom row\\nIf direction == 3: Move from bottom to top in left column\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        if not n:\\n            return []\\n        if n == 1:\\n            return [[1]]\\n        \\n        ans = [[0]* n for _ in range(n)]\\n        \\n        left, right = 0, n-1\\n        top, bottom = 0, n-1\\n        \\n        k = 1\\n        direction = 0\\n        \\n        while left <= right and top <= bottom:\\n            # from left to right in top row\\n            if direction == 0:\\n                for j in range(left, right+1):\\n                    ans[top][j] = k\\n                    k += 1\\n                top += 1\\n                direction = 1\\n            elif direction == 1:\\n                # from top to bottom in right column\\n                for i in range(top, bottom+1):\\n                    ans[i][right] = k\\n                    k += 1\\n                right -= 1\\n                direction = 2\\n            elif direction == 2:\\n                # from right to left in bottom row\\n                for j in range(right, left-1, -1):\\n                    ans[bottom][j] = k\\n                    k += 1\\n                bottom -= 1\\n                direction = 3\\n            else:\\n                # bottom to top in left column\\n                for i in range(bottom, top-1, -1):\\n                    ans[i][left] = k\\n                    k += 1\\n                left += 1\\n                direction = 0\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "We can move in 4 directions:\\nIf direction == 0: Move from left to right in top row\\nIf direction == 1: Move from top to bottom in right column\\nIf direction == 2: Move from right to left in bottom row\\nIf direction == 3: Move from bottom to top in left column\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        if not n:\\n            return []\\n        if n == 1:\\n            return [[1]]\\n        \\n        ans = [[0]* n for _ in range(n)]\\n        \\n        left, right = 0, n-1\\n        top, bottom = 0, n-1\\n        \\n        k = 1\\n        direction = 0\\n        \\n        while left <= right and top <= bottom:\\n            # from left to right in top row\\n            if direction == 0:\\n                for j in range(left, right+1):\\n                    ans[top][j] = k\\n                    k += 1\\n                top += 1\\n                direction = 1\\n            elif direction == 1:\\n                # from top to bottom in right column\\n                for i in range(top, bottom+1):\\n                    ans[i][right] = k\\n                    k += 1\\n                right -= 1\\n                direction = 2\\n            elif direction == 2:\\n                # from right to left in bottom row\\n                for j in range(right, left-1, -1):\\n                    ans[bottom][j] = k\\n                    k += 1\\n                bottom -= 1\\n                direction = 3\\n            else:\\n                # bottom to top in left column\\n                for i in range(bottom, top-1, -1):\\n                    ans[i][left] = k\\n                    k += 1\\n                left += 1\\n                direction = 0\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 22381,
                "title": "7-line-python-solution-step-pattern-is-n-n-1-n-1-n-2-n-2-2-2-1-1",
                "content": "If `n` is 5, `step` list will be [5, 4, 4, 3, 3, 2, 2, 1, 1], it means move forward 5 steps, turn right, move forward 4 steps, turn right, move forward 4 steps, turn right and so on. `x` axis is from left to right, `y` axis is from top to bottom, we start from point `(-1, 0)`.\\n\\n    def generateMatrix(self, n):\\n        mat, x, y, dx, dy, number = [[0] * n for i in xrange(n)], -1, 0, 1, 0, 0\\n        for step in [i / 2 for i in xrange(2 * n, 1, -1)]:\\n            for j in xrange(step):\\n                x, y, number = x + dx, y + dy, number + 1\\n                mat[y][x] = number\\n            dx, dy = -dy, dx # turn right\\n        return mat",
                "solutionTags": [
                    "Python"
                ],
                "code": "If `n` is 5, `step` list will be [5, 4, 4, 3, 3, 2, 2, 1, 1], it means move forward 5 steps, turn right, move forward 4 steps, turn right, move forward 4 steps, turn right and so on. `x` axis is from left to right, `y` axis is from top to bottom, we start from point `(-1, 0)`.\\n\\n    def generateMatrix(self, n):\\n        mat, x, y, dx, dy, number = [[0] * n for i in xrange(n)], -1, 0, 1, 0, 0\\n        for step in [i / 2 for i in xrange(2 * n, 1, -1)]:\\n            for j in xrange(step):\\n                x, y, number = x + dx, y + dy, number + 1\\n                mat[y][x] = number\\n            dx, dy = -dy, dx # turn right\\n        return mat",
                "codeTag": "Python3"
            },
            {
                "id": 3516518,
                "title": "easy-java-solution-with-proper-explanation-beats-100-in-tc",
                "content": "![Screenshot 2023-05-12 at 18.46.26.png](https://assets.leetcode.com/users/images/bb2248b9-f6b1-48ee-92ec-27c3e3612f5b_1683902818.4458783.png)\\n\\n\\n\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis code initializes an n x n matrix with all elements set to zero. It then uses four variables t, b, l, and r to keep track of the boundaries of the current spiral. It starts filling the matrix by traversing from left to right along the top boundary, then from top to bottom along the right boundary, then from right to left along the bottom boundary, and finally from bottom to top along the left boundary. It repeats this process until all elements have been filled in the matrix. Finally, it returns the filled matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        int[][] arr = new int[n][n];\\n        int b = n, r = n;\\n        int t = 0, l = 0, size = b*r,s=1;\\n        while(t<=b && l<=r){\\n            for (int i = l; i < r; i++) {\\n                arr[t][i]=s++;\\n            }\\n            t++;\\n            for (int i = t; i < b; i++) {\\n                arr[i][r-1] = s++;\\n            }\\n            r--;\\n\\n            for (int i = r-1; i >= l; i--) {\\n                arr[b-1][i] = s++;\\n            }\\n            b--;\\n\\n            for (int i = b-1; i >= t; i--) {\\n                arr[i][l]=s++;\\n            }\\n            l++;\\n\\n\\n        }\\n        return arr;\\n\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        int[][] arr = new int[n][n];\\n        int b = n, r = n;\\n        int t = 0, l = 0, size = b*r,s=1;\\n        while(t<=b && l<=r){\\n            for (int i = l; i < r; i++) {\\n                arr[t][i]=s++;\\n            }\\n            t++;\\n            for (int i = t; i < b; i++) {\\n                arr[i][r-1] = s++;\\n            }\\n            r--;\\n\\n            for (int i = r-1; i >= l; i--) {\\n                arr[b-1][i] = s++;\\n            }\\n            b--;\\n\\n            for (int i = b-1; i >= t; i--) {\\n                arr[i][l]=s++;\\n            }\\n            l++;\\n\\n\\n        }\\n        return arr;\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509960,
                "title": "java-spiral-matrix-2",
                "content": "\\n```\\nclass Solution {\\n    public static void spiralOrder(int[][] matrix) {\\n        int move[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int x = 0;\\n        int y = -1;\\n        int i = 0;\\n        boolean finish = false;\\n        int ch = 1;\\n        while (!finish) {\\n            finish = true;\\n            while (true) {\\n                int tmpX = x;\\n                int tmpY = y;\\n                if (x + move[i % 4][0] < matrix.length && x + move[i % 4][0] > -1) x += move[i % 4][0];\\n                if (y + move[i % 4][1] < matrix[0].length && y + move[i % 4][1] > -1) y += move[i % 4][1];\\n                if (x < matrix.length && y < matrix[0].length && matrix[x][y] == 0) {\\n                    matrix[x][y] = ch++;\\n                    finish = false;\\n                }\\n                else {\\n                    x = tmpX;\\n                    y = tmpY;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n    }\\n\\n    public static int[][] generateMatrix(int n) {\\n        int matrix[][] = new int[n][n];\\n        spiralOrder(matrix);\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static void spiralOrder(int[][] matrix) {\\n        int move[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int x = 0;\\n        int y = -1;\\n        int i = 0;\\n        boolean finish = false;\\n        int ch = 1;\\n        while (!finish) {\\n            finish = true;\\n            while (true) {\\n                int tmpX = x;\\n                int tmpY = y;\\n                if (x + move[i % 4][0] < matrix.length && x + move[i % 4][0] > -1) x += move[i % 4][0];\\n                if (y + move[i % 4][1] < matrix[0].length && y + move[i % 4][1] > -1) y += move[i % 4][1];\\n                if (x < matrix.length && y < matrix[0].length && matrix[x][y] == 0) {\\n                    matrix[x][y] = ch++;\\n                    finish = false;\\n                }\\n                else {\\n                    x = tmpX;\\n                    y = tmpY;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n    }\\n\\n    public static int[][] generateMatrix(int n) {\\n        int matrix[][] = new int[n][n];\\n        spiralOrder(matrix);\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506563,
                "title": "simple-clean-beats-100",
                "content": "# Intuition\\nSimple brute force\\n\\n# Approach\\nWe use left , right , top , bottom pointers to represent the configuration of the matrix.\\nSTEPS of traversal:\\n\\n1. Traverse from left to right , then update top=top+1, AS topmost row is filled.\\n\\n2. Traverse from top to bottom, then update right=right-1, AS rightmost column is filled.\\n\\n3. Traverse from right to left, then update bottom= bottom-1 , AS \\nbottomMost row is filled.\\n\\n 4. Traverse from bottom to top, then update left=left+1, \\n  AS leftmost column is filled.\\n\\n# Complexity\\n- Time complexity:\\n  O(N*N) for traversing the matrix.\\n\\n- Space complexity:\\n  O(N*N) for storing the matrix.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int num=1,left=0,right=n-1,top=0,bottom=n-1;\\n        vector<vector<int>>matrix(n,vector<int>(n));\\n\\n        while(left<=right && top<=bottom){\\n            for(int i=left; i<=right; i++){\\n                matrix[top][i]=num++;\\n            }\\n            top++;\\n\\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=num++;\\n            }\\n            right--;\\n\\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=num++;\\n            }\\n            bottom--;\\n\\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=num++;\\n            }\\n            left++;\\n        }\\n\\n        return matrix;\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int num=1,left=0,right=n-1,top=0,bottom=n-1;\\n        vector<vector<int>>matrix(n,vector<int>(n));\\n\\n        while(left<=right && top<=bottom){\\n            for(int i=left; i<=right; i++){\\n                matrix[top][i]=num++;\\n            }\\n            top++;\\n\\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=num++;\\n            }\\n            right--;\\n\\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=num++;\\n            }\\n            bottom--;\\n\\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=num++;\\n            }\\n            left++;\\n        }\\n\\n        return matrix;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506487,
                "title": "99-6-javascript-easy-to-understand",
                "content": "Visit my youtube! Thank you!\\nhttps://www.youtube.com/channel/UCkhEaNAOO8tig5NHqqxXIeg\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar generateMatrix = function(n) {\\n    let save = Array.from(Array(n),()=>new Array(n).fill(0))\\n    let count =1;\\n    let left =0;\\n    let right =n-1;\\n    let bottom = n-1;\\n    let top = 0;\\n    let dir = 0;\\n\\n    while(count <= n*n){\\n        if(dir == 0){\\n            for(let i =left; i<=right; i++){\\n                save[top][i] = count;\\n                count++\\n            }\\n            top++\\n            dir++\\n        }\\n        if(dir == 1){\\n            for(let i =top; i<=bottom; i++){\\n                save[i][right] = count;\\n                count++\\n            }\\n            right--\\n            dir++        \\n        }\\n        if(dir == 2){\\n            for(let i =right; i>=left; i--){\\n                save[bottom][i] = count;\\n                count++\\n            }\\n            bottom--\\n            dir++        \\n        }\\n        if(dir == 3){\\n            for(let i =bottom; i>=top; i--){\\n                save[i][left] = count;\\n                count++\\n            }\\n            left++\\n            dir++        \\n        }\\n        dir = 0;\\n    }\\n\\n    return save;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar generateMatrix = function(n) {\\n    let save = Array.from(Array(n),()=>new Array(n).fill(0))\\n    let count =1;\\n    let left =0;\\n    let right =n-1;\\n    let bottom = n-1;\\n    let top = 0;\\n    let dir = 0;\\n\\n    while(count <= n*n){\\n        if(dir == 0){\\n            for(let i =left; i<=right; i++){\\n                save[top][i] = count;\\n                count++\\n            }\\n            top++\\n            dir++\\n        }\\n        if(dir == 1){\\n            for(let i =top; i<=bottom; i++){\\n                save[i][right] = count;\\n                count++\\n            }\\n            right--\\n            dir++        \\n        }\\n        if(dir == 2){\\n            for(let i =right; i>=left; i--){\\n                save[bottom][i] = count;\\n                count++\\n            }\\n            bottom--\\n            dir++        \\n        }\\n        if(dir == 3){\\n            for(let i =bottom; i>=top; i--){\\n                save[i][left] = count;\\n                count++\\n            }\\n            left++\\n            dir++        \\n        }\\n        dir = 0;\\n    }\\n\\n    return save;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1942901,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n,vector<int>(n,0));\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        int x=1;\\n        while(x<=n*n){\\n            for(int i=left;i<=right;i++)\\n                res[top][i]=x++;\\n            top++;\\n            for(int i=top;i<=bottom;i++)\\n                res[i][right]=x++;\\n            right--;\\n            for(int i=right;i>=left;i--)\\n                res[bottom][i]=x++;\\n            bottom--;\\n            for(int i=bottom;i>=top;i--)\\n                res[i][left]=x++;\\n            left++;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> res(n,vector<int>(n,0));\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        int x=1;\\n        while(x<=n*n){\\n            for(int i=left;i<=right;i++)\\n                res[top][i]=x++;\\n            top++;\\n            for(int i=top;i<=bottom;i++)\\n                res[i][right]=x++;\\n            right--;\\n            for(int i=right;i>=left;i--)\\n                res[bottom][i]=x++;\\n            bottom--;\\n            for(int i=bottom;i>=top;i--)\\n                res[i][left]=x++;\\n            left++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1855638,
                "title": "simple-c-solution-with-explanation-commented-faster-than-100-00-of-c-online-submissions",
                "content": "Algorithm:\\n\\n* Enter value in starting row (horizonal, left to right)\\n* Enter value in ending column (vertical, top to bottom)\\n* Enter value in ending row (horizonal, right to left)\\n* Enter value in starting column (vertical, bottom to top)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,1));\\n        //index intialisation\\n        int strow=0, stcol=0;\\n        int endrow=n-1,endcol=n-1;\\n        //counters\\n        int cnt=n*n;\\n        int a=1;\\n        \\n        while(a<=cnt){\\n            \\n            //enter value in starting row\\n            for(int i=stcol;i<=endcol&&a<=cnt;i++){\\n                ans[strow][i]=a;\\n                a++;\\n            }\\n            strow++;\\n            \\n            //enter value in ending col\\n            for(int i=strow;i<=endrow&&a<=cnt;i++){\\n                ans[i][endcol]=a;\\n                a++;\\n            }\\n            endcol--;\\n            \\n            //enter value in ending row\\n            for(int i=endcol;i>=stcol&&a<=cnt;i--){\\n                ans[endrow][i]=a;\\n                a++;\\n            }\\n            endrow--;\\n            \\n            //enter value in starting col\\n            for(int i=endrow;i>=strow&&a<=cnt;i--){\\n                ans[i][stcol]=a;\\n                a++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Upvote ++ (if it helps)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,1));\\n        //index intialisation\\n        int strow=0, stcol=0;\\n        int endrow=n-1,endcol=n-1;\\n        //counters\\n        int cnt=n*n;\\n        int a=1;\\n        \\n        while(a<=cnt){\\n            \\n            //enter value in starting row\\n            for(int i=stcol;i<=endcol&&a<=cnt;i++){\\n                ans[strow][i]=a;\\n                a++;\\n            }\\n            strow++;\\n            \\n            //enter value in ending col\\n            for(int i=strow;i<=endrow&&a<=cnt;i++){\\n                ans[i][endcol]=a;\\n                a++;\\n            }\\n            endcol--;\\n            \\n            //enter value in ending row\\n            for(int i=endcol;i>=stcol&&a<=cnt;i--){\\n                ans[endrow][i]=a;\\n                a++;\\n            }\\n            endrow--;\\n            \\n            //enter value in starting col\\n            for(int i=endrow;i>=strow&&a<=cnt;i--){\\n                ans[i][stcol]=a;\\n                a++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999515,
                "title": "python-simple-and-easy-solution",
                "content": "The approach is inspired by [ \"Stefan Pochmann\"](https://leetcode.com/StefanPochmann/)\\n\\nfirst we will push an element in the array\\nthen, rotate the array.\\n\\n(We will start from the 9 upto 1)\\ne.g. for n = 3\\n\\n|9|\\nrotate and push new element\\n|8|\\n|9|\\n\\nrotate and push new elements\\n|6  7|\\n|9  8|\\n\\nrotate and push new elements\\n|4  5|\\n|9  6|\\n|8  7|\\n\\nrotate and push new elements\\n\\n|1  2  3|\\n|8  9  4|\\n|7  6  5|\\n\\n\\n\\n\\n```\\ndef generateMatrix(n):\\n#n = 3 for example\\n    result = []\\n    current = n*n -1  # =  8, for n = 3  \\n    #current will hold the value for inserting\\n    result.append([current + 1]) # first case, Handling first element explicitly result = [[9]]\\n    while current > 1:\\n        result = list(zip(*result[::-1])) # will rotate the array\\n        temp = len(result[0])\\n        # temp will hold the length of the first element of the result i.e. len([9]) i.e. 1\\n        # from temp we would know how many elements we have to push\\n        \\n        result.insert(0,list(range(current-temp+1,current+1)))\\n        #inserting the values on the top of the array\\n        \\n        current = current -temp\\n    return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef generateMatrix(n):\\n#n = 3 for example\\n    result = []\\n    current = n*n -1  # =  8, for n = 3  \\n    #current will hold the value for inserting\\n    result.append([current + 1]) # first case, Handling first element explicitly result = [[9]]\\n    while current > 1:\\n        result = list(zip(*result[::-1])) # will rotate the array\\n        temp = len(result[0])\\n        # temp will hold the length of the first element of the result i.e. len([9]) i.e. 1\\n        # from temp we would know how many elements we have to push\\n        \\n        result.insert(0,list(range(current-temp+1,current+1)))\\n        #inserting the values on the top of the array\\n        \\n        current = current -temp\\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 22337,
                "title": "simplest-c-solution-easy-and-clear-have-a-look",
                "content": "comments will be highly appreciated . \\n\\n    vector<vector<int>> generateMatrix(int n) {\\n            // 2d vector initialization  vector<vector<int>> myvec(rowsize,vector<int>(colsize,0));\\n            vector<vector<int>> res(n,vector<int>(n,0));\\n            if(!n) return res;\\n            \\n            int l=0,r=n-1,t=0,b=n-1,limit=n*n+1;  // l=left column , r=right column , t=top row, b=bottom row \\n            int count=1;\\n            \\n            while(count<limit){         // loop until count == n*n \\n                for(int i=l;i<=r;i++) res[t][i]=count++; // process top row\\n                t++;\\n                for(int i=t;i<=b;i++) res[i][r]=count++; // process right column\\n                r--;\\n                if(count==limit) break;         // termination condition to avoid overwritting          \\n                for(int i=r; i>=l;i--) res[b][i]=count++; // process bottom row\\n                b--;\\n                for(int i=b;i>=t;i--) res[i][l]=count++;  //process left column\\n                l++;\\n            }\\n            \\n           return res;\\n        }",
                "solutionTags": [],
                "code": "comments will be highly appreciated . \\n\\n    vector<vector<int>> generateMatrix(int n) {\\n            // 2d vector initialization  vector<vector<int>> myvec(rowsize,vector<int>(colsize,0));\\n            vector<vector<int>> res(n,vector<int>(n,0));\\n            if(!n) return res;\\n            \\n            int l=0,r=n-1,t=0,b=n-1,limit=n*n+1;  // l=left column , r=right column , t=top row, b=bottom row \\n            int count=1;\\n            \\n            while(count<limit){         // loop until count == n*n \\n                for(int i=l;i<=r;i++) res[t][i]=count++; // process top row\\n                t++;\\n                for(int i=t;i<=b;i++) res[i][r]=count++; // process right column\\n                r--;\\n                if(count==limit) break;         // termination condition to avoid overwritting          \\n                for(int i=r; i>=l;i--) res[b][i]=count++; // process bottom row\\n                b--;\\n                for(int i=b;i>=t;i--) res[i][l]=count++;  //process left column\\n                l++;\\n            }\\n            \\n           return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3510009,
                "title": "c-spiral-arrangement-of-the-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int i, j, o, k, num;\\n        vector<vector<int>> vec(n, vector<int>(n));\\n        for (i = j = o = 0 , num = 1; num <= (n * n) && i < n - o; o++, i++, j++) {\\n            cout << vec[i][j] << endl;\\n            while (j < n - o) {\\n                if (num > n*n) break;\\n                vec[i][j++] = num++;\\n            }\\n            j--;\\n            for (k = i + 1; k < n - o; k++) {\\n                if (num > n*n) break;\\n                vec[k][j] = num++;\\n            }\\n            k--;\\n            while (j > o) {\\n                if (num > n*n) break;\\n                vec[k][--j] = num++;\\n            }\\n            while (k > i + 1) {\\n                if (num > n*n) break;\\n                vec[--k][o] = num++;\\n            }\\n            \\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int i, j, o, k, num;\\n        vector<vector<int>> vec(n, vector<int>(n));\\n        for (i = j = o = 0 , num = 1; num <= (n * n) && i < n - o; o++, i++, j++) {\\n            cout << vec[i][j] << endl;\\n            while (j < n - o) {\\n                if (num > n*n) break;\\n                vec[i][j++] = num++;\\n            }\\n            j--;\\n            for (k = i + 1; k < n - o; k++) {\\n                if (num > n*n) break;\\n                vec[k][j] = num++;\\n            }\\n            k--;\\n            while (j > o) {\\n                if (num > n*n) break;\\n                vec[k][--j] = num++;\\n            }\\n            while (k > i + 1) {\\n                if (num > n*n) break;\\n                vec[--k][o] = num++;\\n            }\\n            \\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3508950,
                "title": "best-and-easy-approach-for-solving-competitive-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsoc=starting of column\\nsor=starting of row\\neor=end of column\\neoc=end of coloumn\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>finaldata(n,vector<int>(n,0));\\n        int soc=0,sor=0,eor=n-1,eoc=n-1,count=1;\\n        while(soc<=eoc && sor<=eor)\\n        {\\n            for(int x=soc;x<=eoc;x++)\\n            {\\n                finaldata[sor][x]=count;\\n                count++;\\n            }\\n            sor++;\\n            for(int x=sor;x<=eor;x++)\\n            {\\n                finaldata[x][eoc]=count;\\n                count++;\\n            }\\n            eoc--;\\n            for(int x=eoc;x>=soc;x--)\\n            {\\n                finaldata[eor][x]=count;\\n                count++;\\n            }\\n            eor--;\\n            for(int x=eor;x>=sor;x--)\\n            {\\n                finaldata[x][soc]=count;\\n                count++;\\n            }\\n            soc++;\\n        }\\n        return finaldata;\\n    }\\n};\\nIF YOU LOVE YOUR MOTHER UPVOTE!!!\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>finaldata(n,vector<int>(n,0));\\n        int soc=0,sor=0,eor=n-1,eoc=n-1,count=1;\\n        while(soc<=eoc && sor<=eor)\\n        {\\n            for(int x=soc;x<=eoc;x++)\\n            {\\n                finaldata[sor][x]=count;\\n                count++;\\n            }\\n            sor++;\\n            for(int x=sor;x<=eor;x++)\\n            {\\n                finaldata[x][eoc]=count;\\n                count++;\\n            }\\n            eoc--;\\n            for(int x=eoc;x>=soc;x--)\\n            {\\n                finaldata[eor][x]=count;\\n                count++;\\n            }\\n            eor--;\\n            for(int x=eor;x>=sor;x--)\\n            {\\n                finaldata[x][soc]=count;\\n                count++;\\n            }\\n            soc++;\\n        }\\n        return finaldata;\\n    }\\n};\\nIF YOU LOVE YOUR MOTHER UPVOTE!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507369,
                "title": "java-simulation-beats-100-15-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[][] generateMatrix(int n) {\\n    int x = 0, y = -1, cnt = 1;\\n    var xMoves = new int[] {n};\\n    var yMoves = new int[] {n+1};\\n    var mat = new int[n][n];\\n\\n    for (var d = 0; cnt <= n*n; d = (d+1) % 4) {\\n      var moves = d % 2 == 0 ? yMoves : xMoves;\\n      moves[0]--;\\n\\n      for (var i = 0; i < moves[0]; i++) {\\n        switch(d) {\\n          case 0 : y++; break;\\n          case 1 : x++; break;\\n          case 2 : y--; break;\\n          case 3 : x--; break;\\n        }\\n        mat[x][y] = cnt++;\\n      }\\n    }\\n    return mat;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n  public int[][] generateMatrix(int n) {\\n    int x = 0, y = -1, cnt = 1;\\n    var xMoves = new int[] {n};\\n    var yMoves = new int[] {n+1};\\n    var mat = new int[n][n];\\n\\n    for (var d = 0; cnt <= n*n; d = (d+1) % 4) {\\n      var moves = d % 2 == 0 ? yMoves : xMoves;\\n      moves[0]--;\\n\\n      for (var i = 0; i < moves[0]; i++) {\\n        switch(d) {\\n          case 0 : y++; break;\\n          case 1 : x++; break;\\n          case 2 : y--; break;\\n          case 3 : x--; break;\\n        }\\n        mat[x][y] = cnt++;\\n      }\\n    }\\n    return mat;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507016,
                "title": "easy-java-code-beats-100",
                "content": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] ans = new int[n][n];\\n        //right -> bottom -> left -> top\\n        int top = 0, left = 0;\\n        int bottom = n-1, right = n-1;\\n        int k = 1;\\n        while(top<=bottom && left<=right){\\n            //right\\n            for(int i=left;i<=right;i++){\\n                ans[top][i] = k++ ;\\n            }\\n            top++;\\n            //bottom\\n            for(int i=top;i<=bottom;i++){\\n                ans[i][right] = k++;\\n            }\\n            right--;\\n            if(top<=bottom){\\n                //left\\n                for(int i=right;i>=left;i--){\\n                    ans[bottom][i] = k++;\\n                  }\\n                 bottom--;\\n            }\\n            if(left<=right){\\n                //top\\n                for(int i=bottom;i>=top;i--){\\n                    ans[i][left] = k++;\\n                }  \\n                left++;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] ans = new int[n][n];\\n        //right -> bottom -> left -> top\\n        int top = 0, left = 0;\\n        int bottom = n-1, right = n-1;\\n        int k = 1;\\n        while(top<=bottom && left<=right){\\n            //right\\n            for(int i=left;i<=right;i++){\\n                ans[top][i] = k++ ;\\n            }\\n            top++;\\n            //bottom\\n            for(int i=top;i<=bottom;i++){\\n                ans[i][right] = k++;\\n            }\\n            right--;\\n            if(top<=bottom){\\n                //left\\n                for(int i=right;i>=left;i--){\\n                    ans[bottom][i] = k++;\\n                  }\\n                 bottom--;\\n            }\\n            if(left<=right){\\n                //top\\n                for(int i=bottom;i>=top;i--){\\n                    ans[i][left] = k++;\\n                }  \\n                left++;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506521,
                "title": "simple-spiral-traversing-c-98-efficient",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter initializing a new 2-d Array, simply traverse the array from the outer spiral towards inner spiral and place the incrementing numbers\\n\\n![Screenshot 2023-05-10 062834.png](https://assets.leetcode.com/users/images/0f78400f-bde1-46d9-912d-955e0b0787a5_1683680327.0288699.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) - as we need to place (n^2) items in the array of size (n*n), given n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - as we do not use any extra memory other than the resulting 2-d array\\n\\n## Please upvote if you like the simplicity of the approach\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] GenerateMatrix(int n) {\\n        int[][] result = Initialize(n);\\n        int num = 1;\\n        for (int i = 0, j = n - 1; i <= j; i++, j--)\\n        {\\n            for (int x = i; x <= j; x++)\\n            {\\n                result[i][x] = num++;\\n            }\\n            \\n            for (int x = i + 1; x <= j; x++)\\n            {\\n                result[x][j] = num++;\\n            }\\n            \\n            for (int x = j - 1; x >= i; x--)\\n            {\\n                result[j][x] = num++;\\n            }\\n            \\n            for (int x = j - 1; x > i; x--)\\n            {\\n                result[x][i] = num++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int[][] Initialize(int n)\\n    {\\n        int[][] result = new int[n][];\\n        for (int i = 0; i < n; i++)\\n        {\\n            result[i] = new int[n];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n## Please upvote if you like the simplicity of the approach",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] GenerateMatrix(int n) {\\n        int[][] result = Initialize(n);\\n        int num = 1;\\n        for (int i = 0, j = n - 1; i <= j; i++, j--)\\n        {\\n            for (int x = i; x <= j; x++)\\n            {\\n                result[i][x] = num++;\\n            }\\n            \\n            for (int x = i + 1; x <= j; x++)\\n            {\\n                result[x][j] = num++;\\n            }\\n            \\n            for (int x = j - 1; x >= i; x--)\\n            {\\n                result[j][x] = num++;\\n            }\\n            \\n            for (int x = j - 1; x > i; x--)\\n            {\\n                result[x][i] = num++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int[][] Initialize(int n)\\n    {\\n        int[][] result = new int[n][];\\n        for (int i = 0; i < n; i++)\\n        {\\n            result[i] = new int[n];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941775,
                "title": "javascript-easy-to-understand-intuition-explained",
                "content": "**Intuition** -> This problem is similar to [Spiral matrix I](https://leetcode.com/problems/spiral-matrix/) in which we take 4 pointers and move them as per the condition, in this problem the pointer part in same only thing that has been changed is how many times the outer loop will run and how efficiently we can manage , below is the code hope it helps.\\n```\\nvar generateMatrix = function(n) {\\n    let c1=0;\\n    let c2=n-1;\\n    let r1=0;\\n    let r2=n-1;\\n    \\n    let arr=Array.from(Array(n),()=>Array(n));\\n    let i=1;\\n    while(i<=n*n){\\n        \\n        for(let c=c1;c<=c2;c++){\\n            arr[r1][c]=i;\\n            i++;\\n        }\\n        r1++;\\n        for(let r=r1;r<=r2;r++){\\n            arr[r][c2]=i;\\n            i++;\\n        }\\n        c2--;\\n        for(let c=c2;c>=c1;c--){\\n            arr[r2][c]=i;\\n            i++;\\n        }\\n        r2--;\\n        for(let r=r2;r>=r1;r--){\\n            arr[r][c1]=i;\\n            i++;\\n        }\\n        c1++;        \\n    }\\n    return arr;\\n};\\n```\\n\\n***Please upvote if you like the solution \\uD83D\\uDE80***",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar generateMatrix = function(n) {\\n    let c1=0;\\n    let c2=n-1;\\n    let r1=0;\\n    let r2=n-1;\\n    \\n    let arr=Array.from(Array(n),()=>Array(n));\\n    let i=1;\\n    while(i<=n*n){\\n        \\n        for(let c=c1;c<=c2;c++){\\n            arr[r1][c]=i;\\n            i++;\\n        }\\n        r1++;\\n        for(let r=r1;r<=r2;r++){\\n            arr[r][c2]=i;\\n            i++;\\n        }\\n        c2--;\\n        for(let c=c2;c>=c1;c--){\\n            arr[r2][c]=i;\\n            i++;\\n        }\\n        r2--;\\n        for(let r=r2;r>=r1;r--){\\n            arr[r][c1]=i;\\n            i++;\\n        }\\n        c1++;        \\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1941159,
                "title": "java-simple-reuse-lc-54",
                "content": "**Idea:** \\n* This question is near identical to [LC 54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/discuss/3502622/Java-or-Simple-or-Explained) and the solution can be reused. \\n* Fill the matrix in this order: First Row \\u279D Last Column \\u279D Last Row \\u279D First Column\\n* Repeat till a cross-over happends between rows or columns\\n>**T/S:** O(n\\xB2)/O(1)\\n```\\npublic int[][] generateMatrix(int n) {\\n\\tvar matrix = new int[n][n];\\n\\tvar firstRow = 0;\\n\\tvar firstCol = 0;\\n\\tvar lastRow = n - 1;\\n\\tvar lastCol = n - 1;\\n\\tvar x = 1;\\n\\n\\twhile (firstRow <= lastRow && firstCol <= lastCol) {\\n\\t\\t// first row\\n\\t\\tfor (var j = firstCol; j <= lastCol; j++)\\n\\t\\t\\tmatrix[firstRow][j] = x++;\\n\\t\\tfirstRow++;\\n\\n\\t\\t// last col\\n\\t\\tfor (var i = firstRow; i <= lastRow; i++)\\n\\t\\t\\tmatrix[i][lastCol] = x++;\\n\\t\\tlastCol--;\\n\\n\\t\\tif (firstRow > lastRow || firstCol > lastCol)\\n\\t\\t\\tbreak;\\n\\n\\t\\t// last row\\n\\t\\tfor (var j = lastCol; j >= firstCol; j--)\\n\\t\\t\\tmatrix[lastRow][j] = x++;\\n\\t\\tlastRow--;\\n\\n\\t\\t// first col\\n\\t\\tfor (var i = lastRow; i >= firstRow; i--)\\n\\t\\t\\tmatrix[i][firstCol] = x++;\\n\\t\\tfirstCol++;\\n\\t}\\n\\n\\treturn matrix;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] generateMatrix(int n) {\\n\\tvar matrix = new int[n][n];\\n\\tvar firstRow = 0;\\n\\tvar firstCol = 0;\\n\\tvar lastRow = n - 1;\\n\\tvar lastCol = n - 1;\\n\\tvar x = 1;\\n\\n\\twhile (firstRow <= lastRow && firstCol <= lastCol) {\\n\\t\\t// first row\\n\\t\\tfor (var j = firstCol; j <= lastCol; j++)\\n\\t\\t\\tmatrix[firstRow][j] = x++;\\n\\t\\tfirstRow++;\\n\\n\\t\\t// last col\\n\\t\\tfor (var i = firstRow; i <= lastRow; i++)\\n\\t\\t\\tmatrix[i][lastCol] = x++;\\n\\t\\tlastCol--;\\n\\n\\t\\tif (firstRow > lastRow || firstCol > lastCol)\\n\\t\\t\\tbreak;\\n\\n\\t\\t// last row\\n\\t\\tfor (var j = lastCol; j >= firstCol; j--)\\n\\t\\t\\tmatrix[lastRow][j] = x++;\\n\\t\\tlastRow--;\\n\\n\\t\\t// first col\\n\\t\\tfor (var i = lastRow; i >= firstRow; i--)\\n\\t\\t\\tmatrix[i][firstCol] = x++;\\n\\t\\tfirstCol++;\\n\\t}\\n\\n\\treturn matrix;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1941009,
                "title": "golang-simple-solution-with-rotation",
                "content": "We basically need to walk through the matrix, changing direction if we either a) got out of bounds, or b) got previously filled cell.\\n\\n```go\\nfunc generateMatrix(n int) [][]int {\\n    res := make([][]int, n)\\n    for i := 0; i < n; i++ { res[i] = make([]int, n) }\\n    \\n    dirs := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n    \\n    i, j, d := 0, 0, 0 \\n    for k := 1; k <= n*n; k++ {\\n        res[i][j] = k\\n        \\n        di, dj := dirs[d%4][0], dirs[d%4][1]\\n        if i+di < 0 || i+di >= n || j+dj < 0 || j+dj >= n || res[i+di][j+dj] != 0 {\\n            d++\\n            di, dj = dirs[d%4][0], dirs[d%4][1]\\n        }\\n        \\n        i, j = i+di, j+dj\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc generateMatrix(n int) [][]int {\\n    res := make([][]int, n)\\n    for i := 0; i < n; i++ { res[i] = make([]int, n) }\\n    \\n    dirs := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n    \\n    i, j, d := 0, 0, 0 \\n    for k := 1; k <= n*n; k++ {\\n        res[i][j] = k\\n        \\n        di, dj := dirs[d%4][0], dirs[d%4][1]\\n        if i+di < 0 || i+di >= n || j+dj < 0 || j+dj >= n || res[i+di][j+dj] != 0 {\\n            d++\\n            di, dj = dirs[d%4][0], dirs[d%4][1]\\n        }\\n        \\n        i, j = i+di, j+dj\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 963937,
                "title": "spiral-matrix-ii-python-o-n2-simple-offset",
                "content": "The following solution keeps track of an x-y position (location in the resulting array) and an offset (used to move spiral toward the center).\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        spiral = [[0]*n for i in range(n)]\\n        x, y, off = 0, 0, 0\\n        \\n        for i in range(1, n*n +1):\\n            spiral[y][x] = i\\n      \\n            if x == (n-1-off) and y < (n-1-off): y += 1 # Right Edge\\n            elif y == (n-1-off) and x > off: x -=1 # Bottom Edge\\n            elif x == off and y > off: # Left Edge\\n                y -= 1\\n                if y == off+1: off += 1\\n            else: x += 1 # Top Edge\\n\\n        return spiral\\n```\\n\\nThe above solution runs in *`O(n2)`* time. \\nThe above solution takes *`O(n2)`* space.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        spiral = [[0]*n for i in range(n)]\\n        x, y, off = 0, 0, 0\\n        \\n        for i in range(1, n*n +1):\\n            spiral[y][x] = i\\n      \\n            if x == (n-1-off) and y < (n-1-off): y += 1 # Right Edge\\n            elif y == (n-1-off) and x > off: x -=1 # Bottom Edge\\n            elif x == off and y > off: # Left Edge\\n                y -= 1\\n                if y == off+1: off += 1\\n            else: x += 1 # Top Edge\\n\\n        return spiral\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963514,
                "title": "c-simulation-self-explained-without-comment",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int begX = 0, endX = n - 1;\\n        int begY = 0, endY = n - 1;\\n        int counter = 0;\\n        while(true){\\n            for(int j = begX; j <= endX; j++) ans[begY][j] = ++counter;\\n            if(++begY>endY) break;\\n            for(int j = begY; j <= endY; j++) ans[j][endX] = ++counter;\\n            if(begX>--endX) break;\\n            for(int j = endX; j >= begX; j--) ans[endY][j] = ++counter;\\n            if(begY>--endY) break;\\n            for(int j = endY; j >= begY; j--) ans[j][begX] = ++counter;\\n            if(++begX>endY) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int begX = 0, endX = n - 1;\\n        int begY = 0, endY = n - 1;\\n        int counter = 0;\\n        while(true){\\n            for(int j = begX; j <= endX; j++) ans[begY][j] = ++counter;\\n            if(++begY>endY) break;\\n            for(int j = begY; j <= endY; j++) ans[j][endX] = ++counter;\\n            if(begX>--endX) break;\\n            for(int j = endX; j >= begX; j--) ans[endY][j] = ++counter;\\n            if(begY>--endY) break;\\n            for(int j = endY; j >= begY; j--) ans[j][begX] = ++counter;\\n            if(++begX>endY) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552710,
                "title": "c-minimalizm",
                "content": "Track the direction (left, down, right, and up). When your next position is out of bouds, or there is already a number, we change the direction.\\n\\n```cpp\\nint ds[4][2] = {{0,1}, {1,0}, {0,-1}, {-1,0}};\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> res(n, vector<int>(n));\\n    for (auto i = 0, j = 0, k = 1, d = 0; k <= n * n; i += ds[d][0], j += ds[d][1]) {\\n        res[i][j] = k++;\\n        auto ni = i + ds[d][0], nj = j + ds[d][1];\\n        if (ni < 0 || ni == n || nj < 0 || nj == n || res[ni][nj] != 0)\\n            d = (++d) % 4;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint ds[4][2] = {{0,1}, {1,0}, {0,-1}, {-1,0}};\\nvector<vector<int>> generateMatrix(int n) {\\n    vector<vector<int>> res(n, vector<int>(n));\\n    for (auto i = 0, j = 0, k = 1, d = 0; k <= n * n; i += ds[d][0], j += ds[d][1]) {\\n        res[i][j] = k++;\\n        auto ni = i + ds[d][0], nj = j + ds[d][1];\\n        if (ni < 0 || ni == n || nj < 0 || nj == n || res[ni][nj] != 0)\\n            d = (++d) % 4;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 408699,
                "title": "clean-javascript-solution",
                "content": "Reference from a similar question https://leetcode.com/problems/spiral-matrix/discuss/20573/A-concise-C++-implementation-based-on-Directions\\n\\n```\\n// When traversing the matrix in the spiral order, at any time we follow one out of the following four directions:\\n// RIGHT DOWN LEFT UP. Suppose we are working on a 5 x 3 matrix as such:\\n// 0  1  2  3  4  5\\n//    6  7  8  9 10\\n//   11 12 13 14 15\\n//\\n// Imagine a cursor starts off at (0, -1), i.e. the position at \\'0\\', then we can achieve the spiral order by doing\\n// the following:\\n// 1. Go right 5 times\\n// 2. Go down 2 times\\n// 3. Go left 4 times\\n// 4. Go up 1 times.\\n// 5. Go right 3 times\\n// 6. Go down 0 times -> quit\\n\\nconst generateMatrix = (n) => {\\n  const matrix = [...Array(n)].map(() => Array(n).fill(null));\\n  const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // right, down, left, up\\n  const steps = [n, n - 1];\\n\\n  let num = 1;\\n  let dir = 0;\\n  let x = 0;\\n  let y = -1;\\n\\n  while (steps[dir % 2] > 0) {\\n    for (let i = 0; i < steps[dir % 2]; i++) {\\n      x += dirs[dir][0];\\n      y += dirs[dir][1];\\n      matrix[x][y] = num++;\\n    }\\n\\n    steps[dir % 2]--;\\n    dir = (dir + 1) % 4;\\n  }\\n  return matrix;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// When traversing the matrix in the spiral order, at any time we follow one out of the following four directions:\\n// RIGHT DOWN LEFT UP. Suppose we are working on a 5 x 3 matrix as such:\\n// 0  1  2  3  4  5\\n//    6  7  8  9 10\\n//   11 12 13 14 15\\n//\\n// Imagine a cursor starts off at (0, -1), i.e. the position at \\'0\\', then we can achieve the spiral order by doing\\n// the following:\\n// 1. Go right 5 times\\n// 2. Go down 2 times\\n// 3. Go left 4 times\\n// 4. Go up 1 times.\\n// 5. Go right 3 times\\n// 6. Go down 0 times -> quit\\n\\nconst generateMatrix = (n) => {\\n  const matrix = [...Array(n)].map(() => Array(n).fill(null));\\n  const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // right, down, left, up\\n  const steps = [n, n - 1];\\n\\n  let num = 1;\\n  let dir = 0;\\n  let x = 0;\\n  let y = -1;\\n\\n  while (steps[dir % 2] > 0) {\\n    for (let i = 0; i < steps[dir % 2]; i++) {\\n      x += dirs[dir][0];\\n      y += dirs[dir][1];\\n      matrix[x][y] = num++;\\n    }\\n\\n    steps[dir % 2]--;\\n    dir = (dir + 1) % 4;\\n  }\\n  return matrix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123723,
                "title": "beat-100-java-code",
                "content": "Hi all, this code divides the whole construction into n/2 loops. In each loop, it finishes one spiral. If n is an odd number, add an extra number in the center before return.\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n==1)\\n            return new int [][] {{1}};\\n        int[][] result=new int[n][n];\\n        int col=0, row=0, min=0, max=n-1, i=1, loop=0;\\n        while(loop<n/2) {\\n            result[row][col]=i++;\\n            if (row==min && col!=max) \\n                col++;\\n            else if(col==max && row!=max)\\n                row++;\\n            else if(row==max && col!=min) \\n                col--;\\n            else if(col==min && row!=min+1)\\n                row--;\\n            else {\\n                min++;\\n                max--;\\n                col=min;\\n                row=min;\\n                loop++;\\n            }\\n        }\\n        if (n%2==1) \\n            result[n/2][n/2]=i;\\n        return result;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        if (n==1)\\n            return new int [][] {{1}};\\n        int[][] result=new int[n][n];\\n        int col=0, row=0, min=0, max=n-1, i=1, loop=0;\\n        while(loop<n/2) {\\n            result[row][col]=i++;\\n            if (row==min && col!=max) \\n                col++;\\n            else if(col==max && row!=max)\\n                row++;\\n            else if(row==max && col!=min) \\n                col--;\\n            else if(col==min && row!=min+1)\\n                row--;\\n            else {\\n                min++;\\n                max--;\\n                col=min;\\n                row=min;\\n                loop++;\\n            }\\n        }\\n        if (n%2==1) \\n            result[n/2][n/2]=i;\\n        return result;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22488,
                "title": "a-better-solution-than-switching-directions",
                "content": "Rotate the Matrix is more easier :)\\n\\n\\tpublic class Solution {\\n\\t\\tint[][] step = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\t\\tint cnt = 1;\\n\\t\\tvoid vortex(int[][] res, int len, int wid, int x, int y, int sg){\\n\\t\\t\\tif(len == 0) return;\\n\\t\\t\\tfor(int i = 0; i < len; ++i){\\n\\t\\t\\t\\tx += step[sg][0];\\n\\t\\t\\t\\ty += step[sg][1];\\n\\t\\t\\t\\tres[x][y] = cnt++;\\n\\t\\t\\t}\\n\\t\\t\\tsg = (sg+1)%4;\\n\\t\\t\\tvortex(res,--wid,len, x, y, sg);\\n\\t\\t}\\n\\t    public int[][] generateMatrix(int n) {\\n\\t        int[][] res = new int[n][n];\\n\\t        vortex(res,n,n,0,-1,0);\\n\\t        return res;\\n\\t    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tint[][] step = {{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 4084193,
                "title": "best-o-n-2-solution",
                "content": "# Approach\\nTraversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat (n, vector<int>(n));\\n        int num = 1;\\n        int r1 = 0, r2 = n - 1, c1 = n - 1, c2 = 0;\\n        while (num <= n * n) {\\n            for (int i = r1; i <= r2; i++) {\\n                mat[r1][i] = num;\\n                num++;\\n            }\\n            r1++;\\n            for (int i = c2 + 1; i <= c1; i++) {\\n                mat[i][c1] = num;\\n                num++;\\n            }\\n            c1--;\\n            for (int i = r2 - 1; i >= r1 - 1; i--) {\\n                mat[r2][i] = num;\\n                num++;\\n            }\\n            r2--;\\n            for (int i = c1; i >= c2 + 1; i--) {\\n                mat[i][c2] = num;\\n                num++;\\n            }\\n            c2++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat (n, vector<int>(n));\\n        int num = 1;\\n        int r1 = 0, r2 = n - 1, c1 = n - 1, c2 = 0;\\n        while (num <= n * n) {\\n            for (int i = r1; i <= r2; i++) {\\n                mat[r1][i] = num;\\n                num++;\\n            }\\n            r1++;\\n            for (int i = c2 + 1; i <= c1; i++) {\\n                mat[i][c1] = num;\\n                num++;\\n            }\\n            c1--;\\n            for (int i = r2 - 1; i >= r1 - 1; i--) {\\n                mat[r2][i] = num;\\n                num++;\\n            }\\n            r2--;\\n            for (int i = c1; i >= c2 + 1; i--) {\\n                mat[i][c2] = num;\\n                num++;\\n            }\\n            c2++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652362,
                "title": "beats-100-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntraverse through matrix hit right when you hit a visited node or go out of limits. break when count goes to n^2 +1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaintain n*n matrix. change direction when you hit a visited node or go out of limits. increment count after every insertion \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N2)\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> visited(n, vector<int>(n, 0)); int c = 1; \\n        vector<vector<int>> res(n, vector<int>(n, 0));  int x = 0; int y = 0;   char d = \\'r\\'; \\n        while( c != n*n+1){\\n            if(d == \\'r\\'){\\n                res[x][y] = c;  visited[x][y] = 1; y++; c++; \\n                if(y>=n||visited[x][y] == 1) {y--; x++; d = \\'d\\'; continue;  }\\n            }\\n            else if(d == \\'d\\'){\\n                res[x][y] = c; visited[x][y] = 1; x++; c++; \\n                if(x>=n || visited[x][y] == 1) {x--; y--; d = \\'l\\'; continue; }\\n            }\\n            else if(d == \\'l\\'){\\n                res[x][y] = c; visited[x][y] = 1; y--; c++;\\n                if(y<0 || visited[x][y] == 1) { y++; x--; d = \\'u\\'; continue; }\\n            }\\n            else if(d == \\'u\\'){\\n                res[x][y] = c; visited[x][y] = 1; x--; c++;\\n                if(x<0 || visited[x][y] == 1) {x++; y++; d = \\'r\\'; continue; }\\n            }\\n        }\\n\\n        // cout << x << y << d ; \\n\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> visited(n, vector<int>(n, 0)); int c = 1; \\n        vector<vector<int>> res(n, vector<int>(n, 0));  int x = 0; int y = 0;   char d = \\'r\\'; \\n        while( c != n*n+1){\\n            if(d == \\'r\\'){\\n                res[x][y] = c;  visited[x][y] = 1; y++; c++; \\n                if(y>=n||visited[x][y] == 1) {y--; x++; d = \\'d\\'; continue;  }\\n            }\\n            else if(d == \\'d\\'){\\n                res[x][y] = c; visited[x][y] = 1; x++; c++; \\n                if(x>=n || visited[x][y] == 1) {x--; y--; d = \\'l\\'; continue; }\\n            }\\n            else if(d == \\'l\\'){\\n                res[x][y] = c; visited[x][y] = 1; y--; c++;\\n                if(y<0 || visited[x][y] == 1) { y++; x--; d = \\'u\\'; continue; }\\n            }\\n            else if(d == \\'u\\'){\\n                res[x][y] = c; visited[x][y] = 1; x--; c++;\\n                if(x<0 || visited[x][y] == 1) {x++; y++; d = \\'r\\'; continue; }\\n            }\\n        }\\n\\n        // cout << x << y << d ; \\n\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3508409,
                "title": "c-beats-100-easy-like-if-it-helps-you-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMatrix Simulation type question.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n#Define a N*N vector initiated with value 0. And then move forward in the matrix in the directions of top->bottom, right->left, left->right, bottom->top. \\n\\n#The loop runs till we reach number limit of n^2. \\n\\n#Looking for openions for optimizing my solution.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n         vector<vector<int>> grid(n, vector<int> (n,0));\\n         int dir=1;\\n         int num=1;\\n         int top=0,bottom=n-1,right=n-1,left=0;\\n         while(num<=pow(n,2))\\n         {\\n             if(dir==1)\\n             {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    grid[top][i]=num;\\n                    num++;\\n                }\\n                top++;\\n                dir=2;\\n             }\\n\\n             else if(dir==2)\\n             {\\n                 for(int i=top;i<=bottom;i++)\\n                 {\\n                     grid[i][right]=num;\\n                     num++;\\n                 }\\n                 right--;\\n                 dir=3;\\n             }\\n             else if(dir==3)\\n             {\\n                 for(int i=right;i>=left;i--)\\n                 {\\n                    grid[bottom][i]=num;\\n                    num++;\\n                 }\\n                 bottom--;\\n                 dir=4;\\n             }\\n\\n             else if(dir==4)\\n             {\\n                 for(int i=bottom;i>=top;i--)\\n                 {\\n                     grid[i][left]=num;\\n                     num++;\\n                 }\\n                 left++;\\n                 dir=1;\\n             }\\n         }\\n          return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n         vector<vector<int>> grid(n, vector<int> (n,0));\\n         int dir=1;\\n         int num=1;\\n         int top=0,bottom=n-1,right=n-1,left=0;\\n         while(num<=pow(n,2))\\n         {\\n             if(dir==1)\\n             {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    grid[top][i]=num;\\n                    num++;\\n                }\\n                top++;\\n                dir=2;\\n             }\\n\\n             else if(dir==2)\\n             {\\n                 for(int i=top;i<=bottom;i++)\\n                 {\\n                     grid[i][right]=num;\\n                     num++;\\n                 }\\n                 right--;\\n                 dir=3;\\n             }\\n             else if(dir==3)\\n             {\\n                 for(int i=right;i>=left;i--)\\n                 {\\n                    grid[bottom][i]=num;\\n                    num++;\\n                 }\\n                 bottom--;\\n                 dir=4;\\n             }\\n\\n             else if(dir==4)\\n             {\\n                 for(int i=bottom;i>=top;i--)\\n                 {\\n                     grid[i][left]=num;\\n                     num++;\\n                 }\\n                 left++;\\n                 dir=1;\\n             }\\n         }\\n          return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507313,
                "title": "c-easy-to-understand-matrix",
                "content": "sr : starting of row\\ner : end of row\\nsc : starting of row\\nec : end of columns\\n\\n{first traverse first row increment starting row by one\\nsecond traversal for insert last columns decrement last columns by 1\\nthird time insert last row decrement last row by one\\nfourth time insert first row increment 1st column by row}\\nrepeat these all four steps untill sr <= er && sc <= ec.\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int sr = 0, sc = 0, er = n-1,ec = n-1,x=1,i;\\n        vector<vector<int>> v(n,vector<int>(n));\\n        while(sr<=er && sc <= ec){\\n            for(i = sc; i <= ec && sr<=er; i++){\\n                v[sr][i] = x++;\\n            }\\n            sr++;\\n            for(i = sr; i <= er &&  sc<=ec; i++){\\n                v[i][ec] = x++;\\n            }\\n            ec--;\\n            for(i = ec; i >= sc &&  sr<=er; i--){\\n                v[er][i] = x++;\\n            }\\n            er--;\\n            for(i = er; i >= sr && sc<=ec; i--){\\n                v[i][sc] = x++;\\n            }\\n            sc++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int sr = 0, sc = 0, er = n-1,ec = n-1,x=1,i;\\n        vector<vector<int>> v(n,vector<int>(n));\\n        while(sr<=er && sc <= ec){\\n            for(i = sc; i <= ec && sr<=er; i++){\\n                v[sr][i] = x++;\\n            }\\n            sr++;\\n            for(i = sr; i <= er &&  sc<=ec; i++){\\n                v[i][ec] = x++;\\n            }\\n            ec--;\\n            for(i = ec; i >= sc &&  sr<=er; i--){\\n                v[er][i] = x++;\\n            }\\n            er--;\\n            for(i = er; i >= sr && sc<=ec; i--){\\n                v[i][sc] = x++;\\n            }\\n            sc++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506683,
                "title": "c-best-solution-o-n-n-easy-to-understand",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we have total n*n element for making n*n matrix in spiral order.\\nSo we can follow this **4 step**\\n\\n***Step-1*** : printing the starting row\\n***Step-2*** : printing the ending column\\n***Step-3*** : printing the ending row\\n***Step-4*** : printing the starting column\\n\\n# Dry Run\\nlet n=3\\nSo we have total 3*3 = 9 elements\\ninitial our matrix is : \\n>0 0 0\\n0 0 0\\n0 0 0\\n\\n**step-1:** *starting row*\\n>1 2 3\\n0 0 0\\n0 0 0\\n\\n**step-2:** *ending column*\\n>1 2 3\\n0 0 4\\n0 0 5\\n\\n**step-3:** *ending row*\\n>1 2 3\\n0 0 4\\n7 6 5\\n\\n**step-4:** *starting column*\\n>1 2 3\\n8 0 4\\n7 6 5\\n\\n**HERE 4 STEP IS COMPLETED BUT THE MATRIX IS NOT FILLED BY N*N ELEMENTS SO WE HAVE TO REPET THIS 4 STAPES AGAIN WHILE THERE IS LESS THEN N*N ELEMENTS**\\n\\n**step-1:** *starting row*\\n>1 2 3\\n8 9 4\\n7 6 5\\nThis is our answer\\n\\n# Complexity\\n- Time complexity: $$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int srow = 0, erow = n-1, scol = 0, ecol = n-1, element = 1, total = n*n;\\n        while(element <= total)    {\\n            // step-1 : starting row\\n            for(int i=scol; i<=ecol && element<=total; i++)   {\\n                ans[srow][i] = element++;\\n            }\\n            srow++;\\n\\n            // step-2 : ending column\\n            for(int i=srow; i<=erow && element<=total; i++)   {\\n                ans[i][ecol] = element++;\\n            }\\n            ecol--;\\n\\n            // step-3 : ending row\\n            for(int i=ecol; i>=scol && element<=total; i--)   {\\n                ans[erow][i] = element++;\\n            }\\n            erow--;\\n\\n            // step-4 : starting column\\n            for(int i=erow; i>=srow && element<=total; i--)   {\\n                ans[i][scol] = element++;\\n            }\\n            scol++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Matrix",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int srow = 0, erow = n-1, scol = 0, ecol = n-1, element = 1, total = n*n;\\n        while(element <= total)    {\\n            // step-1 : starting row\\n            for(int i=scol; i<=ecol && element<=total; i++)   {\\n                ans[srow][i] = element++;\\n            }\\n            srow++;\\n\\n            // step-2 : ending column\\n            for(int i=srow; i<=erow && element<=total; i++)   {\\n                ans[i][ecol] = element++;\\n            }\\n            ecol--;\\n\\n            // step-3 : ending row\\n            for(int i=ecol; i>=scol && element<=total; i--)   {\\n                ans[erow][i] = element++;\\n            }\\n            erow--;\\n\\n            // step-4 : starting column\\n            for(int i=erow; i>=srow && element<=total; i--)   {\\n                ans[i][scol] = element++;\\n            }\\n            scol++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089593,
                "title": "python-beginner-friendly-similar-to-spiral-matrix-1",
                "content": "Please upvote if you like the post\\n\\n```\\n   class Solution:\\n       def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        matrix_size = n * n\\n        up = left = value = 0\\n        right = n - 1\\n        down = n - 1\\n        \\n        while value != matrix_size:\\n            \\n            for col in range(left, right + 1):\\n                value += 1\\n                matrix[up][col] = value\\n            \\n            for row in range(up + 1, down + 1):\\n                value += 1\\n                matrix[row][right] = value\\n                \\n            if up != down:\\n                for col in range(right - 1, left - 1, -1):\\n                    value += 1\\n                    matrix[down][col] = value\\n            \\n            if left != right:\\n                for row in range(down - 1, up, -1):\\n                    value += 1\\n                    matrix[row][left] = value\\n        \\n            left += 1\\n            right -= 1\\n            up += 1\\n            down -= 1\\n\\n        return matrix\\n             \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n   class Solution:\\n       def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        matrix_size = n * n\\n        up = left = value = 0\\n        right = n - 1\\n        down = n - 1\\n        \\n        while value != matrix_size:\\n            \\n            for col in range(left, right + 1):\\n                value += 1\\n                matrix[up][col] = value\\n            \\n            for row in range(up + 1, down + 1):\\n                value += 1\\n                matrix[row][right] = value\\n                \\n            if up != down:\\n                for col in range(right - 1, left - 1, -1):\\n                    value += 1\\n                    matrix[down][col] = value\\n            \\n            if left != right:\\n                for row in range(down - 1, up, -1):\\n                    value += 1\\n                    matrix[row][left] = value\\n        \\n            left += 1\\n            right -= 1\\n            up += 1\\n            down -= 1\\n\\n        return matrix\\n             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942288,
                "title": "python-optimized-spiral-traversal-in-a-few-lines-explained",
                "content": "We fill the matrix following a spiral pattern, changing direction when going outside of the matrix or when encountering a non-zero value.\\nUsing `next`on an `itertools.cycle` is far easier to read than using modulos IMO.\\n\\n```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        directions = cycle([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n        row, col = 0, 0\\n        x, y = next(directions)\\n        for i in range(1, n ** 2 + 1):\\n            matrix[row][col] = i\\n            if not (0 <= row + x < n and 0 <= col + y < n and matrix[row + x][col + y] == 0):\\n                x, y = next(directions)\\n            row += x\\n            col += y  \\n        return matrix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        directions = cycle([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n        row, col = 0, 0\\n        x, y = next(directions)\\n        for i in range(1, n ** 2 + 1):\\n            matrix[row][col] = i\\n            if not (0 <= row + x < n and 0 <= col + y < n and matrix[row + x][col + y] == 0):\\n                x, y = next(directions)\\n            row += x\\n            col += y  \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941795,
                "title": "c-100-simple-solution-o-n-2",
                "content": "```\\nint** generateMatrix(int n, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = n;\\n    *returnColumnSizes = malloc(sizeof(int) * n);\\n    int **res = malloc(sizeof(int*) * n);\\n    for (int i = 0; i < n; i++) {\\n        (*returnColumnSizes)[i] = n;\\n        res[i] = malloc(sizeof(int) * n);\\n    }\\n    \\n    int top = 0;\\n    int bot = n - 1;\\n    int left = 0;\\n    int right = n - 1;\\n    \\n    int j = 1;\\n    while (j <= n * n) {\\n        for (int i = left; i <= right; i++, j++)\\n            res[top][i] = j;\\n        top++;\\n\\n        for (int i = top; i <= bot; i++, j++)\\n            res[i][right] = j;\\n        right--;\\n\\n        for (int i = right; i >= left; i--, j++)\\n            res[bot][i] = j;\\n        bot--;\\n\\n        for (int i = bot; i >= top; i--, j++)\\n            res[i][left] = j;\\n        left++;\\n    }\\n\\n    return res;\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** generateMatrix(int n, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = n;\\n    *returnColumnSizes = malloc(sizeof(int) * n);\\n    int **res = malloc(sizeof(int*) * n);\\n    for (int i = 0; i < n; i++) {\\n        (*returnColumnSizes)[i] = n;\\n        res[i] = malloc(sizeof(int) * n);\\n    }\\n    \\n    int top = 0;\\n    int bot = n - 1;\\n    int left = 0;\\n    int right = n - 1;\\n    \\n    int j = 1;\\n    while (j <= n * n) {\\n        for (int i = left; i <= right; i++, j++)\\n            res[top][i] = j;\\n        top++;\\n\\n        for (int i = top; i <= bot; i++, j++)\\n            res[i][right] = j;\\n        right--;\\n\\n        for (int i = right; i >= left; i--, j++)\\n            res[bot][i] = j;\\n        bot--;\\n\\n        for (int i = bot; i >= top; i--, j++)\\n            res[i][left] = j;\\n        left++;\\n    }\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1941360,
                "title": "easy-c-solution-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        // Defining the boundaries of the matrix.\\n        int top = 0, bottom = n-1, right = n-1, left = 0;\\n        // Defining the direction in which the array is to be traversed.\\n        int dir = 1, val = 1;\\n        vector<vector<int>> matirx (n, vector<int>(n, 0));\\n        while( top <= bottom && left <= right){\\n            // moving left->right\\n            if(dir == 1){\\n                for(int i=left; i <= right; i++){\\n                    matirx[top][i]=val;\\n                    val++;\\n                }\\n            }\\n            // Since we have traversed the whole first\\n            // row, move down to the next row.\\n            dir = 2;\\n            top++;\\n            // moving top->bottom\\n            if(dir == 2){\\n                for(int i=top; i <= bottom; i++){\\n                    matirx[i][right]=val;\\n                    val++;\\n                }\\n            }\\n            // Since we have traversed the whole last\\n            // column, move left to the previous column.\\n            dir = 3;\\n            right--;\\n            // moving right->left\\n            if(dir == 3){\\n                for(int i=right; i >= left; i--){\\n                    matirx[bottom][i] = val;\\n                    val++;\\n                }\\n            }\\n            // Since we have traversed the whole last\\n            // row, move up to the previous row.\\n            dir = 4;\\n            bottom--;\\n            // moving bottom->up\\n            if(dir == 4){\\n                for(int i=bottom; i>= top; i--){\\n                    matirx[i][left]=val;\\n                    val++;\\n                }\\n            }\\n            // Since we have traversed the whole first\\n            // col, move right to the next column.\\n            dir = 1;\\n            left ++;\\n            \\n        }\\n        \\n        return matirx;\\n        \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        // Defining the boundaries of the matrix.\\n        int top = 0, bottom = n-1, right = n-1, left = 0;\\n        // Defining the direction in which the array is to be traversed.\\n        int dir = 1, val = 1;\\n        vector<vector<int>> matirx (n, vector<int>(n, 0));\\n        while( top <= bottom && left <= right){\\n            // moving left->right\\n            if(dir == 1){\\n                for(int i=left; i <= right; i++){\\n                    matirx[top][i]=val;\\n                    val++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1941154,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * N)***\\n* ***Space Complexity : O(1), because space taken for outputing the result doesn\\'t count as space complexity***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> mat(n, vector<int> (n, 0));\\n        \\n        int k = 1;\\n        \\n        int top = 0;\\n        \\n        int bottom = n - 1;\\n        \\n        int left = 0;\\n        \\n        int right = n - 1;\\n        \\n        while(left <= right && top <= bottom)\\n        {\\n            if(top <= bottom)\\n            {\\n                for(int i = left; i <= right; i++)\\n                {\\n                    mat[top][i] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                top++;\\n            }\\n            \\n            if(left <= right)\\n            {\\n                for(int i = top; i <= bottom; i++)\\n                {\\n                    mat[i][right] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                right--;\\n            }\\n            \\n            if(top <= bottom)\\n            {\\n                for(int i = right; i >= left; i--)\\n                {\\n                    mat[bottom][i] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                bottom--;\\n            }\\n            \\n            if(left <= right)\\n            {\\n                for(int i = bottom; i >= top; i--)\\n                {\\n                    mat[i][left] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                left++;\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> mat(n, vector<int> (n, 0));\\n        \\n        int k = 1;\\n        \\n        int top = 0;\\n        \\n        int bottom = n - 1;\\n        \\n        int left = 0;\\n        \\n        int right = n - 1;\\n        \\n        while(left <= right && top <= bottom)\\n        {\\n            if(top <= bottom)\\n            {\\n                for(int i = left; i <= right; i++)\\n                {\\n                    mat[top][i] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                top++;\\n            }\\n            \\n            if(left <= right)\\n            {\\n                for(int i = top; i <= bottom; i++)\\n                {\\n                    mat[i][right] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                right--;\\n            }\\n            \\n            if(top <= bottom)\\n            {\\n                for(int i = right; i >= left; i--)\\n                {\\n                    mat[bottom][i] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                bottom--;\\n            }\\n            \\n            if(left <= right)\\n            {\\n                for(int i = bottom; i >= top; i--)\\n                {\\n                    mat[i][left] = k;\\n                    \\n                    k++;\\n                }\\n                \\n                left++;\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767351,
                "title": "python-solution",
                "content": "Need to be careful for the corner element traversal. \\n```\\nclass Solution(object):\\n    def generateMatrix(self, n):\\n        top, bottom, left, right = 0, n-1, 0, n-1\\n        num = 1 \\n        if not n:\\n            return \\n        matrix = [[0]*n for _ in xrange(n)]\\n        while left <= right and top <= bottom:\\n            for i in xrange(left, right+1):\\n                matrix[top][i] = num\\n                num += 1\\n            top += 1 \\n            \\n            for i in xrange(top, bottom+1):\\n                matrix[i][right] = num\\n                num += 1 \\n            right -= 1 \\n            \\n            for i in xrange(right, left-1, -1):\\n                matrix[bottom][i] = num\\n                num += 1\\n            bottom -= 1 \\n            \\n            for i in xrange(bottom, top-1, -1):\\n                matrix[i][left] = num\\n                num += 1 \\n            left += 1\\n            \\n        return matrix",
                "solutionTags": [
                    "Python"
                ],
                "code": "Need to be careful for the corner element traversal. \\n```\\nclass Solution(object):\\n    def generateMatrix(self, n):\\n        top, bottom, left, right = 0, n-1, 0, n-1\\n        num = 1 \\n        if not n:\\n            return \\n        matrix = [[0]*n for _ in xrange(n)]\\n        while left <= right and top <= bottom:\\n            for i in xrange(left, right+1):\\n                matrix[top][i] = num\\n                num += 1\\n            top += 1 \\n            \\n            for i in xrange(top, bottom+1):\\n                matrix[i][right] = num\\n                num += 1 \\n            right -= 1 \\n            \\n            for i in xrange(right, left-1, -1):\\n                matrix[bottom][i] = num\\n                num += 1\\n            bottom -= 1 \\n            \\n            for i in xrange(bottom, top-1, -1):\\n                matrix[i][left] = num\\n                num += 1 \\n            left += 1\\n            \\n        return matrix",
                "codeTag": "Java"
            },
            {
                "id": 1500943,
                "title": "c-100-each-and-every-steps-explained-easy-efficient",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int val=1,r=0,c=0,m=n,i;\\n       \\n \\n    /*  r - starting row index\\n        m - ending row index\\n        c - starting column index\\n        n - ending column index\\n        i - iterator\\n    */\\n \\n    while (r < m && c < n) {\\n        /* Assigning value to first row from\\n               the remaining rows */\\n        for (i = c; i < n; ++i) {\\n            a[r][i] = val++;\\n        }\\n        r++;\\n \\n        /* Assigning value to last column\\n         from the remaining columns */\\n        for (i = r; i < m; ++i) {\\n            a[i][n - 1] = val++;\\n        }\\n        n--;\\n \\n        /* Assigning value to last row from\\n                the remaining rows */\\n        if (r < m) {\\n            for (i = n - 1; i >= c; --i) {\\n                a[m - 1][i] = val++;\\n            }\\n            m--;\\n        }\\n \\n        /* Assigning value to first column from\\n                   the remaining columns */\\n        if (c < n) {\\n            for (i = m - 1; i >= r; --i) {\\n                a[i][c] = val++;\\n            }\\n            c++;\\n        }\\n    }\\n        return a;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int val=1,r=0,c=0,m=n,i;\\n       \\n \\n    /*  r - starting row index\\n        m - ending row index\\n        c - starting column index\\n        n - ending column index\\n        i - iterator\\n    */\\n \\n    while (r < m && c < n) {\\n        /* Assigning value to first row from\\n               the remaining rows */\\n        for (i = c; i < n; ++i) {\\n            a[r][i] = val++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 969392,
                "title": "faster-than-100-00-beginner-friendly-easy-understanding",
                "content": "```\\n//Runtime: 0 ms, faster than 100.00%\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int cnt=0;\\n        int rs=0,re=n-1;\\n        int cs=0,ce=n-1;\\n        int j=1;\\n        vector<vector<int>>res(n,vector<int>(n,0));\\n        while(rs <= re && cs <= ce){\\n            for(int i=cs;i<=ce;i++){\\n                res[rs][i]=j++;\\n            }\\n            rs++;\\n            for(int i=rs;i<=re;i++){\\n                res[i][ce]=j++;\\n            }\\n            ce--;\\n             if (rs <= re)\\n            for(int i=ce;i>=cs;i--){\\n                res[re][i]=j++;\\n            }\\n            re--;\\n            if (cs <= ce)\\n            for(int i=re;i>=rs;i--){\\n                res[i][cs]=j++;\\n            }\\n            cs++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//Runtime: 0 ms, faster than 100.00%\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int cnt=0;\\n        int rs=0,re=n-1;\\n        int cs=0,ce=n-1;\\n        int j=1;\\n        vector<vector<int>>res(n,vector<int>(n,0));\\n        while(rs <= re && cs <= ce){\\n            for(int i=cs;i<=ce;i++){\\n                res[rs][i]=j++;\\n            }\\n            rs++;\\n            for(int i=rs;i<=re;i++){\\n                res[i][ce]=j++;\\n            }\\n            ce--;\\n             if (rs <= re)\\n            for(int i=ce;i>=cs;i--){\\n                res[re][i]=j++;\\n            }\\n            re--;\\n            if (cs <= ce)\\n            for(int i=re;i>=rs;i--){\\n                res[i][cs]=j++;\\n            }\\n            cs++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964177,
                "title": "c-0ms-solution-easy-to-understand",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>v(n,vector<int>(n));\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n-i;j++){   //left to right\\n                v[i][j]=++count;\\n            }\\n            for(int k=i+1;k<n-i-1;k++){   //top to bottom\\n                v[k][n-i-1]=++count;\\n            }\\n            for(int l=n-1-i;l>i;l--){            // right to left\\n                v[n-i-1][l]=++count;\\n            }\\n            for(int m=n-1-i;m>i;m--){      //bottom to top\\n                v[m][i]=++count;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>v(n,vector<int>(n));\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n-i;j++){   //left to right\\n                v[i][j]=++count;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 963097,
                "title": "python",
                "content": "We do as told and construct the matrix via traversing the spiral.\\n\\n```python\\nclass Solution:\\n    def generateMatrix(self, n):\\n        ans = [[0]*n for _ in range(n)]\\n        x = y = j = 0\\n        dirs = [(0,1),(1,0),(0,-1),(-1,0)]\\n        for i in range(1,n**2+1):\\n            ans[x][y] = i\\n            dx, dy = dirs[j]\\n            if 0<=x+dx<=n-1 and 0<=y+dy<=n-1 and ans[x+dx][y+dy]==0:\\n                x, y = x+dx, y+dy\\n            else:\\n                j = (j+1)%4\\n                dx, dy = dirs[j]\\n                x, y = x+dx, y+dy   \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def generateMatrix(self, n):\\n        ans = [[0]*n for _ in range(n)]\\n        x = y = j = 0\\n        dirs = [(0,1),(1,0),(0,-1),(-1,0)]\\n        for i in range(1,n**2+1):\\n            ans[x][y] = i\\n            dx, dy = dirs[j]\\n            if 0<=x+dx<=n-1 and 0<=y+dy<=n-1 and ans[x+dx][y+dy]==0:\\n                x, y = x+dx, y+dy\\n            else:\\n                j = (j+1)%4\\n                dx, dy = dirs[j]\\n                x, y = x+dx, y+dy   \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394596,
                "title": "javascript-solution-beats-60",
                "content": "Here is my solution to solve this problem in JS.\\n\\n```\\n\\n/*         startColumn         endColumn\\n  startRow  1           2           3\\n            4           5           6\\n  endRow    7           8           9\\n */\\nconst spiral = n => {\\n    const results = [];\\n\\n    for (let i = 0; i < n; i++) {\\n        results.push([]);\\n    }\\n\\n    let startRow = 0,\\n        endRow = n - 1,\\n        startColumn = 0,\\n        endColumn = n - 1,\\n        count = 1;\\n\\n    while (startRow <= endRow && startColumn <= endColumn) {\\n        //Top Row\\n        for (let i = startColumn; i <= endColumn; i++) {\\n            results[startRow][i] = count;\\n            count++;\\n        }\\n        startRow++;\\n\\n        //Right Column\\n        for (let i = startRow; i <= endRow; i++) {\\n            results[i][endColumn] = count;\\n            count++;\\n        }\\n        endColumn--;\\n\\n        //bottom row\\n        for (let i = endColumn; i >= startColumn; i--) {\\n            results[endRow][i] = count;\\n            count++;\\n        }\\n        endRow--;\\n\\n        //Left Column\\n        for (let i = endRow; i >= startRow; i--) {\\n            results[i][startColumn] = count;\\n            count++;\\n        }\\n        startColumn++;\\n    }\\n    return results;\\n};\\n\\nconsole.log(spiral(3));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/*         startColumn         endColumn\\n  startRow  1           2           3\\n            4           5           6\\n  endRow    7           8           9\\n */\\nconst spiral = n => {\\n    const results = [];\\n\\n    for (let i = 0; i < n; i++) {\\n        results.push([]);\\n    }\\n\\n    let startRow = 0,\\n        endRow = n - 1,\\n        startColumn = 0,\\n        endColumn = n - 1,\\n        count = 1;\\n\\n    while (startRow <= endRow && startColumn <= endColumn) {\\n        //Top Row\\n        for (let i = startColumn; i <= endColumn; i++) {\\n            results[startRow][i] = count;\\n            count++;\\n        }\\n        startRow++;\\n\\n        //Right Column\\n        for (let i = startRow; i <= endRow; i++) {\\n            results[i][endColumn] = count;\\n            count++;\\n        }\\n        endColumn--;\\n\\n        //bottom row\\n        for (let i = endColumn; i >= startColumn; i--) {\\n            results[endRow][i] = count;\\n            count++;\\n        }\\n        endRow--;\\n\\n        //Left Column\\n        for (let i = endRow; i >= startRow; i--) {\\n            results[i][startColumn] = count;\\n            count++;\\n        }\\n        startColumn++;\\n    }\\n    return results;\\n};\\n\\nconsole.log(spiral(3));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 384461,
                "title": "c-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) \\n    {\\n        if(!n)\\n            return {};\\n        int rowStart = 0, rowEnd = n - 1, colStart = 0, colEnd = n - 1;\\n        int count = 1;\\n        vector<vector<int>> result(n, vector<int>(n));\\n        while(count <= n * n)\\n        {\\n            for(int i = colStart; i <= colEnd && count <= n * n; result[rowStart][i++] = count++);\\n            for(int i = ++rowStart; i <= rowEnd && count <=  n * n; result[i++][colEnd] = count++);\\n            for(int i = --colEnd; i >= colStart && count <=  n * n; result[rowEnd][i--] = count++);\\n            for(int i = --rowEnd; i >= rowStart && count <= n * n; result[i--][colStart] = count++);\\n            ++colStart;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) \\n    {\\n        if(!n)\\n            return {};\\n        int rowStart = 0, rowEnd = n - 1, colStart = 0, colEnd = n - 1;\\n        int count = 1;\\n        vector<vector<int>> result(n, vector<int>(n));\\n        while(count <= n * n)\\n        {\\n            for(int i = colStart; i <= colEnd && count <= n * n; result[rowStart][i++] = count++);\\n            for(int i = ++rowStart; i <= rowEnd && count <=  n * n; result[i++][colEnd] = count++);\\n            for(int i = --colEnd; i >= colStart && count <=  n * n; result[rowEnd][i--] = count++);\\n            for(int i = --rowEnd; i >= rowStart && count <= n * n; result[i--][colStart] = count++);\\n            ++colStart;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309573,
                "title": "swift-beating-all-linear-solution-kewl-lewpz-hacker-rank-scared-money",
                "content": "```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        \\n        var m = [[Int]](repeating: [Int](repeating: 0, count: n), count: n)\\n        \\n        var l = 0, r = n - 1, t = 0, b = n - 1, x = 0, y = 0, val = 1\\n        \\n        while t <= b {\\n            \\n            x = l; y = t\\n            while x <= r { m[t][x] = val; val += 1; x += 1 }\\n            \\n            t += 1; y = t\\n            while y <= b { m[y][r] = val; val += 1; y += 1 }\\n            \\n            r -= 1; x = r\\n            while x >= l { m[b][x] = val; val += 1; x -= 1 }\\n            \\n            b -= 1; y = b\\n            while y >= t { m[y][l] = val; val += 1; y -= 1 }\\n            \\n            l += 1\\n        }\\n        \\n        return m\\n    }\\n}\\n```\\n\\nBig big big big big big big big man.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {\\n        \\n        var m = [[Int]](repeating: [Int](repeating: 0, count: n), count: n)\\n        \\n        var l = 0, r = n - 1, t = 0, b = n - 1, x = 0, y = 0, val = 1\\n        \\n        while t <= b {\\n            \\n            x = l; y = t\\n            while x <= r { m[t][x] = val; val += 1; x += 1 }\\n            \\n            t += 1; y = t\\n            while y <= b { m[y][r] = val; val += 1; y += 1 }\\n            \\n            r -= 1; x = r\\n            while x >= l { m[b][x] = val; val += 1; x -= 1 }\\n            \\n            b -= 1; y = b\\n            while y >= t { m[y][l] = val; val += 1; y -= 1 }\\n            \\n            l += 1\\n        }\\n        \\n        return m\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238780,
                "title": "ruby-solution",
                "content": "the solution learns from the discuss, here is the code:\\n\\n```ruby\\n\\ndef generate_matrix(n)\\n  arr = Array.new(n){ Array.new(n) }\\n  \\n  i, j, di, dj = 0, 0, 0, 1\\n  (0...n*n).each do |k|\\n    arr[i][j] = k + 1  \\n    \\n    di, dj = dj, -di if arr[(i+di)%n][(j+dj)%n]\\n    \\n    i += di\\n    j += dj\\n  end\\n  \\n  arr\\nend\\n",
                "solutionTags": [],
                "code": "the solution learns from the discuss, here is the code:\\n\\n```ruby\\n\\ndef generate_matrix(n)\\n  arr = Array.new(n){ Array.new(n) }\\n  \\n  i, j, di, dj = 0, 0, 0, 1\\n  (0...n*n).each do |k|\\n    arr[i][j] = k + 1  \\n    \\n    di, dj = dj, -di if arr[(i+di)%n][(j+dj)%n]\\n    \\n    i += di\\n    j += dj\\n  end\\n  \\n  arr\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 22392,
                "title": "c-template-for-spiral-matrix-spiral-matrix-ii",
                "content": "Spiral Matrix II code:\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> generateMatrix(int n) {\\n            vector<vector<int>> result(n, vector<int>(n, 0));\\n            int l=0, r=n-1, u=0, d=n-1;\\n            int k=1;\\n            while(true){\\n                for(int i=l; i<=r; i++)  result[u][i]=k++;\\n                if(++u>d) break;\\n                \\n                for(int i=u; i<=d; i++)  result[i][r]=k++;\\n                if(r--<l) break;\\n                \\n                for(int i=r; i>=l; i--)  result[d][i]=k++;\\n                if(--d<u) break;\\n                \\n                for(int i=d; i>=u; i--)  result[i][l]=k++;\\n                if(++l>r) break;\\n            }\\n            return result;\\n        }\\n    };\\n\\nSpiral Matrix Code:\\n\\n    class Solution {\\n    public:\\n        vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n            if(matrix.empty())  return {};\\n            int m=matrix.size(), n=matrix[0].size();\\n            vector<int> spiral(m*n);\\n            int u=0, d=m-1, l=0, r=n-1, k=0;\\n            while(true){\\n                /** up **/\\n                for(int col=l; col<=r; col++)  spiral[k++]=matrix[u][col];\\n                if(++u>d) break;\\n                /** right **/\\n                for(int row=u; row<=d; row++)  spiral[k++]=matrix[row][r];\\n                if(--r<l) break;\\n                /** down **/\\n                for(int col=r; col>=l; col--)  spiral[k++]=matrix[d][col];\\n                if(--d<u) break;\\n                /** left **/\\n                for(int row=d; row>=u; row--)  spiral[k++]=matrix[row][l];\\n                if(++l>r) break;\\n            }\\n            return spiral;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> generateMatrix(int n) {\\n            vector<vector<int>> result(n, vector<int>(n, 0));\\n            int l=0, r=n-1, u=0, d=n-1;\\n            int k=1;\\n            while(true){\\n                for(int i=l; i<=r; i++)  result[u][i]=k++;\\n                if(++u>d) break;\\n                \\n                for(int i=u; i<=d; i++)  result[i][r]=k++;\\n                if(r--<l) break;\\n                \\n                for(int i=r; i>=l; i--)  result[d][i]=k++;\\n                if(--d<u) break;\\n                \\n                for(int i=d; i>=u; i--)  result[i][l]=k++;\\n                if(++l>r) break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3510253,
                "title": "algorithmic-approach-in-python-beginner-friendly",
                "content": "# Algorithmic Approach\\n* This problem makes more sense when you have solved the Spiral Matrix.\\n* This problem is to **generate a square matrix** **fil**led with **ele**ments from **`1 to n^2 in spiral order`**. \\n* The approach used in the code is to **kee**p **tra**ck of the `current top, bottom, left and right boundaries of the matrix`. \\n* The **alg**orithm **sta**rts from the `top left corner` and **moves** **tow**ards the `right boundary` while **fil**ling the **top row**. \\n* Once it **rea**ches the `right boundary`, it **moves down** **tow**ards the `bottom boundary` while **fil**ling the **rightmost column**.\\n*  Once it **rea**ches the `bottom boundary`, it **moves towards** the `left boundary` while **fil**ling the `bottom row`. \\n* Once it **rea**ches the `left boundary`, it **moves up tow**ards the `top boundary` while **fil**ling the `leftmost column`. \\n* After completing `one full cycle`, it `updates the top, bottom, left and right boundaries` and **rep**eats the **pro**cess **unt**il **all ele**ments have been **fil**led.\\n\\n![Image showing the initial values for top, bottom, left, and right](https://assets.leetcode.com/users/images/0cdc3ae1-62eb-4b85-86eb-50b0a72c3a94_1683755756.0455143.png)\\n\\n\\n# Time and Space Complexity: $O(n^2)$\\n\\n# Code\\n``` Python []\\n\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        # Initialize the top, bottom, right and left boundaries of the matrix\\n        top = 0\\n        bottom = n - 1\\n        right = n - 1\\n        left = 0\\n\\n        # Initialize a counter to keep track of the numbers to fill in the matrix\\n        count = 1\\n\\n        # Initialize an empty matrix of size n by n filled with zeros\\n        res = [[0 for _ in range(n)] for _ in range(n)]\\n\\n        # Loop until the row and column boundaries cross each other\\n        while top <= bottom and left <= right:\\n            \\n            # Left to right with top as constant\\n            for i in range(left, right + 1):\\n                res[top][i] = count\\n                count += 1\\n            # Move the top boundary down by one\\n            top += 1\\n\\n            # Top to bottom with right as constant\\n            for i in range(top, bottom + 1):\\n                res[i][right] = count\\n                count += 1\\n            # Move the right boundary left by one\\n            right -= 1\\n\\n            # Check if the top boundary is still below the bottom boundary\\n            # Right to left with bottom as constant\\n            if top <= bottom:\\n                for i in range(right, left - 1, -1):\\n                    res[bottom][i] = count\\n                    count += 1\\n                # Move the bottom boundary up by one\\n                bottom -= 1\\n\\n            # Check if the left boundary is still below the right boundary\\n            # Bottom to top with left as constant\\n            if left <= right:\\n                for i in range(bottom, top - 1, -1):\\n                    res[i][left] = count\\n                    count += 1\\n                # Move the left boundary right by one\\n                left += 1\\n\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "``` Python []\\n\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        # Initialize the top, bottom, right and left boundaries of the matrix\\n        top = 0\\n        bottom = n - 1\\n        right = n - 1\\n        left = 0\\n\\n        # Initialize a counter to keep track of the numbers to fill in the matrix\\n        count = 1\\n\\n        # Initialize an empty matrix of size n by n filled with zeros\\n        res = [[0 for _ in range(n)] for _ in range(n)]\\n\\n        # Loop until the row and column boundaries cross each other\\n        while top <= bottom and left <= right:\\n            \\n            # Left to right with top as constant\\n            for i in range(left, right + 1):\\n                res[top][i] = count\\n                count += 1\\n            # Move the top boundary down by one\\n            top += 1\\n\\n            # Top to bottom with right as constant\\n            for i in range(top, bottom + 1):\\n                res[i][right] = count\\n                count += 1\\n            # Move the right boundary left by one\\n            right -= 1\\n\\n            # Check if the top boundary is still below the bottom boundary\\n            # Right to left with bottom as constant\\n            if top <= bottom:\\n                for i in range(right, left - 1, -1):\\n                    res[bottom][i] = count\\n                    count += 1\\n                # Move the bottom boundary up by one\\n                bottom -= 1\\n\\n            # Check if the left boundary is still below the right boundary\\n            # Bottom to top with left as constant\\n            if left <= right:\\n                for i in range(bottom, top - 1, -1):\\n                    res[i][left] = count\\n                    count += 1\\n                # Move the left boundary right by one\\n                left += 1\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509833,
                "title": "easy-java-solution-0ms-100-faster-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int num[][] = new int[n][n];\\n        int count = 1;\\n        int top = 0,left = 0,bottom = n -1,right = n - 1;\\n        while(top <= bottom && left <= right){\\n            for(int i = left ; i <= right ; i++){\\n                num[top][i] = count++;\\n            }\\n            top++;\\n            for(int i = top ; i <= bottom; i++){\\n                num[i][right] = count++;\\n            }\\n            right--;\\n            if(top <= bottom){\\n                for(int i = right; i >= left; i --){\\n                    num[bottom][i] = count++;\\n                }\\n                bottom--;\\n            }\\n            if(left <= right){\\n                for(int i = bottom; i >= top; i --){\\n                    num[i][left] = count++;\\n                }\\n                left++;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int num[][] = new int[n][n];\\n        int count = 1;\\n        int top = 0,left = 0,bottom = n -1,right = n - 1;\\n        while(top <= bottom && left <= right){\\n            for(int i = left ; i <= right ; i++){\\n                num[top][i] = count++;\\n            }\\n            top++;\\n            for(int i = top ; i <= bottom; i++){\\n                num[i][right] = count++;\\n            }\\n            right--;\\n            if(top <= bottom){\\n                for(int i = right; i >= left; i --){\\n                    num[bottom][i] = count++;\\n                }\\n                bottom--;\\n            }\\n            if(left <= right){\\n                for(int i = bottom; i >= top; i --){\\n                    num[i][left] = count++;\\n                }\\n                left++;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508134,
                "title": "kotlin-2d-array-easy-solution-with-great-explanation",
                "content": "# Intuition\\nI solved this task yesterday lol, i just need to advance it :)\\n\\n# Approach\\nSo, we need to initialize `n * n` matrix/grid with zeroes on each position(which is our result, we need to edit this matrix/grid)\\n\\nNext we need to declare `direction` variable, which is equal to `\\'R\\'`, because start direction is `\"Right\"`.\\n\\nAfter that we can declare our borders on each side:\\n`borderLeft`, `borderUp` and etc.\\nNotice, that `borderUp` is equal to 1, because on start we already fill first line, so we need to move border.\\n\\nI used to `matrix[i][j]`, so i created iterables `i` which is a **Column**, and `j` which is a **Row**!\\n\\nNow we can start to travel in Matrix from `0` to `n * n` because we need to fill each cell from `1` to `n * n`, so in each step we are going to `matrix[i][j] = k + 1`(we could start from `1` to `n * n + 1`, because `until` works like: `1 <= until < (n * n + 1)`).\\n\\nI hope you understand =)\\nLet\\'s continue!\\n\\nIn Kotlin we have `when` statement, it\\'s equals to `switch`, but in my opinion much better :)\\nWe could do `when (direction) { /* TODO */ }`, but if we needed to write some `if` statements in `when` -> we can\\'t use mentioned before expression.\\n\\nWe\\'ll use `when` statement to check `direction` each time we go to somewhere. And so, if `direction == \\'R\\'`, we are going to move to the right with `j`(like `matrix[i][j++]`). And each time we are checking if we contact the `border` with `j`, if we contacted -> we are switching our direction according to statement to `\\'D\\'` and decrease possible `border`.\\n\\nNow we need to do the same with all directions. After `for` just return our edited matrix :)\\n\\n**If u liked my explanation please vote for this solution, its important to me!**\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```kotlin []\\nclass Solution {\\n    fun generateMatrix(n: Int): Array<IntArray> {\\n        var matrix = Array(n) { IntArray(n) }\\n        var direction = \\'R\\'\\n        var borderLeft = 0\\n        var borderRight = n - 1\\n        var borderUp = 1\\n        var borderDown = n - 1\\n        var i = 0\\n        var j = 0\\n        for (k in 0 until n * n) {\\n            matrix[i][j] = k + 1\\n            when {\\n                direction == \\'R\\' -> {\\n                    j++\\n                    if (j == borderRight) {\\n                        direction = \\'D\\'\\n                        borderRight--\\n                    }\\n                }\\n                direction == \\'D\\' -> {\\n                    i++\\n                    if (i == borderDown) {\\n                        direction = \\'L\\'\\n                        borderDown--\\n                    }\\n                }\\n                direction == \\'L\\' -> {\\n                    j--\\n                    if (j == borderLeft) {\\n                        direction = \\'U\\'\\n                        borderLeft++\\n                    }\\n                }\\n                direction == \\'U\\' -> {\\n                    i--\\n                    if (i == borderUp) {\\n                        direction = \\'R\\'\\n                        borderUp++\\n                    }\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Array",
                    "Matrix"
                ],
                "code": "```kotlin []\\nclass Solution {\\n    fun generateMatrix(n: Int): Array<IntArray> {\\n        var matrix = Array(n) { IntArray(n) }\\n        var direction = \\'R\\'\\n        var borderLeft = 0\\n        var borderRight = n - 1\\n        var borderUp = 1\\n        var borderDown = n - 1\\n        var i = 0\\n        var j = 0\\n        for (k in 0 until n * n) {\\n            matrix[i][j] = k + 1\\n            when {\\n                direction == \\'R\\' -> {\\n                    j++\\n                    if (j == borderRight) {\\n                        direction = \\'D\\'\\n                        borderRight--\\n                    }\\n                }\\n                direction == \\'D\\' -> {\\n                    i++\\n                    if (i == borderDown) {\\n                        direction = \\'L\\'\\n                        borderDown--\\n                    }\\n                }\\n                direction == \\'L\\' -> {\\n                    j--\\n                    if (j == borderLeft) {\\n                        direction = \\'U\\'\\n                        borderLeft++\\n                    }\\n                }\\n                direction == \\'U\\' -> {\\n                    i--\\n                    if (i == borderUp) {\\n                        direction = \\'R\\'\\n                        borderUp++\\n                    }\\n                }\\n            }\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507852,
                "title": "simple-java-beats-100-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to create a 2-dimensional matrix of size n x n such that the elements are filled in spiral form.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Follow the code below to understand the solution.**\\n\\n      **If this solution helped you, give it an up-vote to help others** \\n\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n\\n        int [][] arr = new int[n][n];\\n\\n        int i = 0;      //starting row index\\n        int j = 0;      //starting col index\\n\\n        int k = n;    //ending row index\\n        int l = n;    //ending col index\\n\\n        int count = 0;\\n\\n        boolean flag = true;\\n\\n        while(flag) {\\n\\n            flag = false;\\n\\n\\n            //--------------LEFT --->> RIGHT------------//\\n            while(j < l)\\n            {\\n              arr[i][j] = ++count;\\n              j++;\\n                flag = true;\\n            }\\n            j--;\\n            i++;\\n\\n\\n            //-------------TOP --->> BOTTOM-------------//\\n\\n            while (i < k) {\\n                arr[i][j] = ++count;\\n                i++;\\n                flag = true;\\n            }\\n            j--;\\n            i--;\\n            k--;\\n\\n            //-----------RIGHT --->> LEFT---------//\\n            while (j >= n - l) {\\n                arr[i][j] = ++count;\\n                j--;\\n                flag = true;\\n            }\\n            j++;\\n            l--;\\n            i--;\\n\\n            //----------BOTTOM --->> TOP-------------//\\n            while (i >= n - k) {\\n                arr[i][j] = ++count;\\n                i--;\\n                flag = true;\\n            }\\n            i++;\\n            j++;\\n        }\\n\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n\\n        int [][] arr = new int[n][n];\\n\\n        int i = 0;      //starting row index\\n        int j = 0;      //starting col index\\n\\n        int k = n;    //ending row index\\n        int l = n;    //ending col index\\n\\n        int count = 0;\\n\\n        boolean flag = true;\\n\\n        while(flag) {\\n\\n            flag = false;\\n\\n\\n            //--------------LEFT --->> RIGHT------------//\\n            while(j < l)\\n            {\\n              arr[i][j] = ++count;\\n              j++;\\n                flag = true;\\n            }\\n            j--;\\n            i++;\\n\\n\\n            //-------------TOP --->> BOTTOM-------------//\\n\\n            while (i < k) {\\n                arr[i][j] = ++count;\\n                i++;\\n                flag = true;\\n            }\\n            j--;\\n            i--;\\n            k--;\\n\\n            //-----------RIGHT --->> LEFT---------//\\n            while (j >= n - l) {\\n                arr[i][j] = ++count;\\n                j--;\\n                flag = true;\\n            }\\n            j++;\\n            l--;\\n            i--;\\n\\n            //----------BOTTOM --->> TOP-------------//\\n            while (i >= n - k) {\\n                arr[i][j] = ++count;\\n                i--;\\n                flag = true;\\n            }\\n            i++;\\n            j++;\\n        }\\n\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507748,
                "title": "o-1-space-easy-c-beats-100-explanation-beginner-friendly",
                "content": "# Explanation\\nThe given code is used to generate a matrix of size n by n, where n is a positive integer. The generated matrix follows a specific pattern: starting from the top-left corner, the elements of the matrix are filled in a clockwise spiral order until the center is reached.\\n\\nHere\\'s the intuition behind the code:\\n\\n1) Initialize the 2D vector v of size n by n with all elements set to 0. This vector will store the generated matrix.\\n\\n2) Initialize variables left, right, top, and bottom to keep track of the boundaries of the current spiral.\\n\\n3) Initialize a variable val to keep track of the value to be filled in the matrix. It starts from 1 and increments as we fill in the elements.\\n\\n4) While the element at the center of the matrix is not filled (i.e., v[n/2][n/2] == 0), continue the spiral filling process.\\n\\n5) Fill the top row of the current spiral from left to right with values from val and increment val.\\n\\n6) Increment top to exclude the filled top row from future iterations.\\n\\n7) Fill the right column of the current spiral from top to bottom with values from val and increment val.\\n\\n8) Decrement right to exclude the filled right column from future iterations.\\n\\n9) Fill the bottom row of the current spiral from right to left with values from val and increment val.\\n\\n10) Decrement bottom to exclude the filled bottom row from future iterations.\\n\\n11) Fill the left column of the current spiral from bottom to top with values from val and increment val.\\n\\n12) Increment left to exclude the filled left column from future iterations.\\n\\n13) Repeat steps 5 to 12 until the center element of the matrix is filled.\\n\\nFinally, return the generated matrix v.\\n\\nThe code utilizes the four variables left, right, top, and bottom to keep track of the current boundaries of the spiral. By incrementing or decrementing these boundaries, the code ensures that the next spiral is filled correctly.\\n\\nThe val variable is used to keep track of the value to be filled in the matrix. It starts from 1 and increments after each element is filled.\\n\\nBy following this spiral pattern and updating the boundaries accordingly, the code generates the desired matrix.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1), this is because we are not using any extra space other than what is asked in the question to return as the final answer.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE if you like the solution. Glad to help. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> v(n, vector<int>(n,0));\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        int val=1;\\n        while(v[n/2][n/2]==0){\\n            for(int i=left;i<=right;i++) v[top][i]=val++;\\n            top++;\\n            for(int i=top;i<=bottom;i++) v[i][right]=val++;\\n            right--;\\n            for(int i=right;i>=left;i--) v[bottom][i]=val++;\\n            bottom--;\\n            for(int i=bottom;i>=top;i--) v[i][left]=val++;\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> v(n, vector<int>(n,0));\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        int val=1;\\n        while(v[n/2][n/2]==0){\\n            for(int i=left;i<=right;i++) v[top][i]=val++;\\n            top++;\\n            for(int i=top;i<=bottom;i++) v[i][right]=val++;\\n            right--;\\n            for(int i=right;i>=left;i--) v[bottom][i]=val++;\\n            bottom--;\\n            for(int i=bottom;i>=top;i--) v[i][left]=val++;\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507281,
                "title": "easiest-and-fast-c-soln-beats-100",
                "content": "**Please upvote if it helps.**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int leftrow = 0,rightrow = n-1,leftcol = 0,rightcol = n-1;\\n        int count = 1,total = n*n;\\n        vector<vector<int>> ans(n,vector<int>(n));\\n\\n        while(count<=total)\\n        {\\n            for(int i=leftcol; i<=rightcol; i++)\\n            {\\n                ans[leftrow][i] = count;\\n                count++;\\n            }\\n            leftrow++;\\n\\n            if(count > total)\\n                break;\\n            for(int i=leftrow; i<=rightrow; i++)\\n            {\\n                ans[i][rightcol] = count;\\n                count++;\\n            }\\n            rightcol--;\\n\\n            if(count > total)\\n                break;\\n            for(int i=rightcol; i>=leftcol; i--)\\n            {\\n                ans[rightrow][i] = count;\\n                count++;\\n            }\\n            rightrow--;\\n\\n            if(count > total)\\n                break;\\n            for(int i=rightrow; i>=leftrow; i--)\\n            {\\n                ans[i][leftcol] = count;\\n                count++;\\n            }\\n            leftcol++;\\n            if(count > total)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int leftrow = 0,rightrow = n-1,leftcol = 0,rightcol = n-1;\\n        int count = 1,total = n*n;\\n        vector<vector<int>> ans(n,vector<int>(n));\\n\\n        while(count<=total)\\n        {\\n            for(int i=leftcol; i<=rightcol; i++)\\n            {\\n                ans[leftrow][i] = count;\\n                count++;\\n            }\\n            leftrow++;\\n\\n            if(count > total)\\n                break;\\n            for(int i=leftrow; i<=rightrow; i++)\\n            {\\n                ans[i][rightcol] = count;\\n                count++;\\n            }\\n            rightcol--;\\n\\n            if(count > total)\\n                break;\\n            for(int i=rightcol; i>=leftcol; i--)\\n            {\\n                ans[rightrow][i] = count;\\n                count++;\\n            }\\n            rightrow--;\\n\\n            if(count > total)\\n                break;\\n            for(int i=rightrow; i>=leftrow; i--)\\n            {\\n                ans[i][leftcol] = count;\\n                count++;\\n            }\\n            leftcol++;\\n            if(count > total)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507022,
                "title": "c-beats-100-only-few-changes-in-spiral-matrix-1",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- $$O(n*n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- $$O(n*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n\\n        int top = 0;\\n        int left = 0;\\n        int bottom = n - 1;\\n        int right = n - 1;\\n        int k = 1;\\n\\n        while(top <= bottom && left <= right) {\\n            // Traversing right\\n            for(int i = left; i <= right; i++) {\\n                matrix[top][i] = k;\\n                k++;\\n            }\\n            top++;\\n            // Traversing down\\n            for(int i = top; i <= bottom; i++) {\\n                matrix[i][right] = k;\\n                k++;\\n            }\\n            right--;\\n            // Traversing left\\n            if(top <= bottom) {\\n                for(int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = k;\\n                    k++;\\n                }\\n                bottom--;\\n            }\\n            // Traversing up\\n            if(left <= right) {\\n                for(int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = k;\\n                    k++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n\\n        int top = 0;\\n        int left = 0;\\n        int bottom = n - 1;\\n        int right = n - 1;\\n        int k = 1;\\n\\n        while(top <= bottom && left <= right) {\\n            // Traversing right\\n            for(int i = left; i <= right; i++) {\\n                matrix[top][i] = k;\\n                k++;\\n            }\\n            top++;\\n            // Traversing down\\n            for(int i = top; i <= bottom; i++) {\\n                matrix[i][right] = k;\\n                k++;\\n            }\\n            right--;\\n            // Traversing left\\n            if(top <= bottom) {\\n                for(int i = right; i >= left; i--) {\\n                    matrix[bottom][i] = k;\\n                    k++;\\n                }\\n                bottom--;\\n            }\\n            // Traversing up\\n            if(left <= right) {\\n                for(int i = bottom; i >= top; i--) {\\n                    matrix[i][left] = k;\\n                    k++;\\n                }\\n                left++;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506965,
                "title": "100-faster-c-solution-with-explanations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to generate a square matrix of size n with elements from 1 to n^2 in spiral order. To generate the matrix in spiral order, we can start by filling in the top row from left to right, then the right column from top to bottom, then the bottom row from right to left, and finally the left column from bottom to top. We can repeat this process until all the elements of the matrix have been filled in.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Create an n x n matrix with all elements initialized to 0.\\n2.Initialize variables startingRow, endingRow, startingCol, and endingCol to keep track of the current boundaries of the matrix.\\n3.Initialize k to 1, which represents the current element to be filled in the matrix.\\n4.Use a while loop to iterate over the matrix until all elements have been filled.\\n5.Within the while loop, use four for loops to fill in the elements of the matrix in spiral order:\\n6.The first loop fills in the top row of the matrix from left to right.\\n7.The second loop fills in the right column of the matrix from top to bottom.\\n8.The third loop fills in the bottom row of the matrix from right to left.\\n9.The fourth loop fills in the left column of the matrix from bottom to top.\\n10.After each loop, update the boundaries of the matrix by incrementing or decrementing the appropriate variables.\\n11.Increment k after each element is filled in the matrix.\\n12.Return the resulting matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given code is O(n^2) because the while loop iterates over all n^2 elements of the matrix, and each element is filled in exactly once.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the given code is O(n^2) because we create an n x n matrix to store the resulting elements.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n\\n        int startingRow=0;\\n        int endingRow=n-1;\\n        int startingCol=0;\\n        int endingCol=n-1;\\n        int k=1;\\n        int last=n*n;\\n    while(k<=last){\\n        for(int i=startingCol;k<=last,i<=endingCol;i++){\\n            mat[startingRow][i]=k++;\\n        }\\n        startingRow++;\\n        for(int i=startingRow;k<=last,i<=endingRow;i++){\\n            mat[i][endingCol]=k++;\\n        }\\n\\n        endingCol--;\\n        for(int i=endingCol;k<=last,i>=startingCol;i--){\\n            mat[endingRow][i]=k++;\\n        }\\n        endingRow--;\\n        for(int i=endingRow;k<=last, i>=startingRow;i--){\\n            mat[i][startingCol]=k++;\\n        }\\n        startingCol++;\\n     }\\n     return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n\\n        int startingRow=0;\\n        int endingRow=n-1;\\n        int startingCol=0;\\n        int endingCol=n-1;\\n        int k=1;\\n        int last=n*n;\\n    while(k<=last){\\n        for(int i=startingCol;k<=last,i<=endingCol;i++){\\n            mat[startingRow][i]=k++;\\n        }\\n        startingRow++;\\n        for(int i=startingRow;k<=last,i<=endingRow;i++){\\n            mat[i][endingCol]=k++;\\n        }\\n\\n        endingCol--;\\n        for(int i=endingCol;k<=last,i>=startingCol;i--){\\n            mat[endingRow][i]=k++;\\n        }\\n        endingRow--;\\n        for(int i=endingRow;k<=last, i>=startingRow;i--){\\n            mat[i][startingCol]=k++;\\n        }\\n        startingCol++;\\n     }\\n     return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506689,
                "title": "simple-bfs-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> generateMatrix(int n)\\n{\\n    int rr[] = {0, 1, 0, -1};\\n    int cc[] = {1, 0, -1, 0};\\n\\n    vector<vector<int>> visited(n, vector<int>(n, 0));\\n    vector<vector<int>> ans(n, vector<int>(n, 0));\\n    visited[0][0] = 1;\\n    ans[0][0] = 1;\\n\\n    int index = 0;\\n    int count = 1;\\n\\n    int row = 0;\\n    int col = 0;\\n\\n    while (count < n * n)\\n    {\\n        int r = row + rr[index];\\n        int c = col + cc[index];\\n\\n        if (r < n and c < n and r >= 0 and c >= 0 and !visited[r][c])\\n        {\\n            count++;\\n            ans[r][c] = count;\\n            visited[r][c] = 1;\\n            row = r;\\n            col = c;\\n        }\\n        else\\n        {\\n            index = (index + 1) % 4;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<vector<int>> generateMatrix(int n)\\n{\\n    int rr[] = {0, 1, 0, -1};\\n    int cc[] = {1, 0, -1, 0};\\n\\n    vector<vector<int>> visited(n, vector<int>(n, 0));\\n    vector<vector<int>> ans(n, vector<int>(n, 0));\\n    visited[0][0] = 1;\\n    ans[0][0] = 1;\\n\\n    int index = 0;\\n    int count = 1;\\n\\n    int row = 0;\\n    int col = 0;\\n\\n    while (count < n * n)\\n    {\\n        int r = row + rr[index];\\n        int c = col + cc[index];\\n\\n        if (r < n and c < n and r >= 0 and c >= 0 and !visited[r][c])\\n        {\\n            count++;\\n            ans[r][c] = count;\\n            visited[r][c] = 1;\\n            row = r;\\n            col = c;\\n        }\\n        else\\n        {\\n            index = (index + 1) % 4;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506597,
                "title": "beats-100-java-c-python-fast-and-elegant",
                "content": "> \\u26A0\\uFE0F **Disclaimer**: The original solution was crafted in Java. Thus, when we mention \"Beats 100%\" it applies specifically to Java submissions. The performance may vary for other languages.\\n\\nDon\\'t forget to upvote if you find the content below helpful. \\uD83D\\uDE43\\n\\n## Problem\\nThe problem is to generate a square matrix filled with elements from 1 to n\\xB2 in a spiral order.\\n\\n## Similarity to Previous Problem\\nThis solution is very similar to [my solution of Spiral Matrix problem](https://leetcode.com/problems/spiral-matrix/solutions/3503165/beats-100-java-c-python-elegant-solution-explained/), where we traverse a 2D matrix in a spiral order. The key difference is that in the current problem, we are generating the matrix, while in the previous one we are traversing it.\\n\\n## Approach\\nWe initialize a 2D matrix of size $$n \\\\times n$$. We keep track of the current cell that we are in using `(r, c)`, and the direction in which we are moving using `(dr, dc)`. \\n\\nInitially, we start from the cell `(0,0)` and move towards the right. For each cell, we assign a number starting from `1`. If the next cell in the current direction is out of bounds or already assigned, we turn `90` degrees to the right.\\n\\n# Complexity Analysis\\n- Time complexity: The time complexity is $$O(n\\xB2)$$, where $$n$$ is the input number. This is because we have to fill up $$n\\xB2$$ cells in the matrix.\\n\\n- Space Complexity: The space complexity is also $$O(n\\xB2)$$, as we need to allocate a 2D array of size $$n \\\\times n$$ to store the resulting matrix.\\n\\n## Code\\n```java []\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int r = 0, c = 0, dr = 0, dc = 1;\\n        for (int current = 1; current <= n * n; current++) {\\n            matrix[r][c] = current;\\n            if (r + dr >= matrix.length || r + dr < 0\\n                    || c + dc >= matrix[0].length || c + dc < 0\\n                    || matrix[r + dr][c + dc] != 0\\n            ) {\\n                int temp = dc;\\n                dc = -dr;\\n                dr = temp;\\n            }\\n            r += dr;\\n            c += dc;\\n        }\\n        return matrix;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        int r = 0, c = 0, dr = 0, dc = 1;\\n        for (int current = 1; current <= n * n; ++current) {\\n            matrix[r][c] = current;\\n            if (r + dr >= n || r + dr < 0 || c + dc >= n || c + dc < 0 || matrix[r + dr][c + dc] != 0) {\\n                swap(dr, dc);\\n                dr = -dr;\\n            }\\n            r += dr;\\n            c += dc;\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```\\n``` python3 []\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0]*n for _ in range(n)]\\n        r, c, dr, dc = 0, 0, 0, 1\\n        for current in range(1, n*n + 1):\\n            matrix[r][c] = current\\n            if not (0 <= r + dr < n and 0 <= c + dc < n and matrix[r + dr][c + dc] == 0):\\n                dr, dc = dc, -dr\\n            r += dr\\n            c += dc\\n        return matrix\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int r = 0, c = 0, dr = 0, dc = 1;\\n        for (int current = 1; current <= n * n; current++) {\\n            matrix[r][c] = current;\\n            if (r + dr >= matrix.length || r + dr < 0\\n                    || c + dc >= matrix[0].length || c + dc < 0\\n                    || matrix[r + dr][c + dc] != 0\\n            ) {\\n                int temp = dc;\\n                dc = -dr;\\n                dr = temp;\\n            }\\n            r += dr;\\n            c += dc;\\n        }\\n        return matrix;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        int r = 0, c = 0, dr = 0, dc = 1;\\n        for (int current = 1; current <= n * n; ++current) {\\n            matrix[r][c] = current;\\n            if (r + dr >= n || r + dr < 0 || c + dc >= n || c + dc < 0 || matrix[r + dr][c + dc] != 0) {\\n                swap(dr, dc);\\n                dr = -dr;\\n            }\\n            r += dr;\\n            c += dc;\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```\n``` python3 []\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0]*n for _ in range(n)]\\n        r, c, dr, dc = 0, 0, 0, 1\\n        for current in range(1, n*n + 1):\\n            matrix[r][c] = current\\n            if not (0 <= r + dr < n and 0 <= c + dc < n and matrix[r + dr][c + dc] == 0):\\n                dr, dc = dc, -dr\\n            r += dr\\n            c += dc\\n        return matrix\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464037,
                "title": "java-solution-for-spiral-matrix-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code generates a 2D matrix of size n x n with numbers from 1 to n*n in spiral order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt uses a loop to iterate over all the elements in the matrix and keeps track of the current position (x, y) in the matrix. It also keeps track of the current step in the spiral using the variable step.\\n\\nThe code then iterates through the four sides of the matrix in a spiral order, filling in the numbers as it goes along. The while loops are used to fill in each side of the matrix.\\n\\nOnce all the numbers have been filled in, the resulting 2D matrix is returned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) since it needs to fill in each of the n^2 elements in the matrix\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2) since it needs to create a 2D matrix of size n x n to store the result.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int total = n*n;\\n        int[][] result= new int[n][n];\\n        int x=0;\\n        int y=0;\\n        int step = 0;\\n        for(int i=0;i<total;)\\n        {\\n            while(y+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y++;\\n            }\\n            y--;\\n            x++;\\n            while(x+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x++;\\n            }\\n            x--;\\n            y--;\\n            while(y>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y--;\\n            }\\n            y++;\\n            x--;\\n            step++;\\n            while(x>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x--;\\n            }\\n            x++;\\n            y++;\\n        }\\n        return result;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int total = n*n;\\n        int[][] result= new int[n][n];\\n        int x=0;\\n        int y=0;\\n        int step = 0;\\n        for(int i=0;i<total;)\\n        {\\n            while(y+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y++;\\n            }\\n            y--;\\n            x++;\\n            while(x+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x++;\\n            }\\n            x--;\\n            y--;\\n            while(y>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y--;\\n            }\\n            y++;\\n            x--;\\n            step++;\\n            while(x>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x--;\\n            }\\n            x++;\\n            y++;\\n        }\\n        return result;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214880,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }\\n                top++;\\n                for(int i=top;i<=bottom;i++){\\n                   m[i][right]=c;\\n                    c++; \\n                }\\n                right--;\\n                for(int i=right;i>=left;i--){\\n                    m[bottom][i]=c;\\n                    c++;\\n                }\\n                bottom--;\\n                for(int i=bottom;i>=top;i--){\\n                   m[i][left]=c;\\n                    c++; \\n                }\\n                left++;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }\\n                top++;\\n                for(int i=top;i<=bottom;i++){\\n                   m[i][right]=c;\\n                    c++; \\n                }\\n                right--;\\n                for(int i=right;i>=left;i--){\\n                    m[bottom][i]=c;\\n                    c++;\\n                }\\n                bottom--;\\n                for(int i=bottom;i>=top;i--){\\n                   m[i][left]=c;\\n                    c++; \\n                }\\n                left++;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176492,
                "title": "59-spiral-matrix-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a 2D list matrix with size n x n filled with zeros.\\n2. Create a list direction that contains the possible direction of movement.\\n3. Initialize the variables curr_dir to keep track of the current direction, x and y for the current position.\\n4. Use a for loop to fill the matrix with elements from 1 to n * n.\\n5. On each iteration, calculate the next position next_x and next_y by adding the current position with the corresponding direction.\\n6. If the next position is within the bounds of the matrix and the value at the next position is 0, update the current position to the next position.\\n7. If the next position is not valid, change the direction by using curr_dir = (curr_dir + 1) % 4.\\n8. Repeat steps 5-7 until all elements from 1 to n * n are filled in the matrix.\\n9. Return the filled matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        curr_dir = 0\\n        x, y = 0, 0\\n        for num in range(1, n * n + 1):\\n            matrix[x][y] = num\\n            next_x, next_y = x + direction[curr_dir][0], y + direction[curr_dir][1]\\n            if 0 <= next_x < n and 0 <= next_y < n and matrix[next_x][next_y] == 0:\\n                x, y = next_x, next_y\\n            else:\\n                curr_dir = (curr_dir + 1) % 4\\n                x, y = x + direction[curr_dir][0], y + direction[curr_dir][1]\\n        return matrix\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0] * n for _ in range(n)]\\n        direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        curr_dir = 0\\n        x, y = 0, 0\\n        for num in range(1, n * n + 1):\\n            matrix[x][y] = num\\n            next_x, next_y = x + direction[curr_dir][0], y + direction[curr_dir][1]\\n            if 0 <= next_x < n and 0 <= next_y < n and matrix[next_x][next_y] == 0:\\n                x, y = next_x, next_y\\n            else:\\n                curr_dir = (curr_dir + 1) % 4\\n                x, y = x + direction[curr_dir][0], y + direction[curr_dir][1]\\n        return matrix\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117990,
                "title": "c-python3-solution-clean-concise",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> M(n, vector<int>(n));\\n        int val = 1;\\n        for(int i = 0; i < (n + 1) / 2; i++) {\\n            for(int j = i; j < n - i; j++) M[i][j] = val++;\\n            for(int j = i + 1; j < n - i; j++) M[j][n - i - 1] = val++;\\n            for(int j = n - i - 2; j >= i; j--) M[n - i - 1][j] = val++;\\n            for(int j = n - i - 2; j > i; j--) M[j][i] = val++;\\n        }\\n        return M;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def generateMatrix(self, n):\\n        M = [[0] * n for _ in range(n)]\\n        val = 0\\n        for i in range((n + 1) // 2):\\n            for j in range(i, n - i): M[i][j] = (val := val + 1)\\n            for j in range(i + 1, n - i): M[j][n - i - 1] = (val := val + 1)\\n            for j in range(n - i - 2, i - 1, -1): M[n - i - 1][j] = (val := val + 1)\\n            for j in range(n - i - 2, i, -1): M[j][i] = (val := val + 1)\\n        return M\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> M(n, vector<int>(n));\\n        int val = 1;\\n        for(int i = 0; i < (n + 1) / 2; i++) {\\n            for(int j = i; j < n - i; j++) M[i][j] = val++;\\n            for(int j = i + 1; j < n - i; j++) M[j][n - i - 1] = val++;\\n            for(int j = n - i - 2; j >= i; j--) M[n - i - 1][j] = val++;\\n            for(int j = n - i - 2; j > i; j--) M[j][i] = val++;\\n        }\\n        return M;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def generateMatrix(self, n):\\n        M = [[0] * n for _ in range(n)]\\n        val = 0\\n        for i in range((n + 1) // 2):\\n            for j in range(i, n - i): M[i][j] = (val := val + 1)\\n            for j in range(i + 1, n - i): M[j][n - i - 1] = (val := val + 1)\\n            for j in range(n - i - 2, i - 1, -1): M[n - i - 1][j] = (val := val + 1)\\n            for j in range(n - i - 2, i, -1): M[j][i] = (val := val + 1)\\n        return M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072223,
                "title": "0-ms-beats-100-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] arr = new int[n][n];\\n        int counter = 1 , up = 0 , left = 0 , right = n-1 , \\n            down = n-1 ;\\n        while(counter <= n*n){\\n            for(int i = left ; i<= right ; i++){\\n                arr[up][i] = counter++;\\n            }\\n            up++;\\n            for(int i = up ; i<=down  ; i++){\\n                arr[i][right] = counter++;\\n            }\\n            right--;\\n            for(int i = right ; i>= left ; i--){\\n                arr[down][i] = counter++;\\n            }\\n            down--;\\n            for(int i = down ; i>= up ; i--){\\n                arr[i][left] = counter++;\\n            }\\n            left++;\\n\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] arr = new int[n][n];\\n        int counter = 1 , up = 0 , left = 0 , right = n-1 , \\n            down = n-1 ;\\n        while(counter <= n*n){\\n            for(int i = left ; i<= right ; i++){\\n                arr[up][i] = counter++;\\n            }\\n            up++;\\n            for(int i = up ; i<=down  ; i++){\\n                arr[i][right] = counter++;\\n            }\\n            right--;\\n            for(int i = right ; i>= left ; i--){\\n                arr[down][i] = counter++;\\n            }\\n            down--;\\n            for(int i = down ; i>= up ; i--){\\n                arr[i][left] = counter++;\\n            }\\n            left++;\\n\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679788,
                "title": "java-easy-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n      int[][] result = new int[n][n];\\n        int k = 0;\\n        int rowStart = 0, rowEnd = n;\\n        int colStart = 0, colEnd = n;\\n        while (k < n * n) {\\n\\n            // right\\n            for(int i = rowStart; k < n * n && i < colEnd; i ++) {\\n                result[rowStart][i] = ++ k;\\n            }\\n            rowStart ++;\\n\\n            // down\\n            for(int i = rowStart; k < n * n && i < rowEnd; i ++) {\\n                result[i][colEnd - 1] = ++ k;\\n            }\\n            colEnd --;\\n\\n            // left\\n            for(int i = colEnd - 1; k < n * n && i >= colStart; i --) {\\n                result[rowEnd - 1][i] = ++ k;\\n            }\\n            rowEnd --;\\n\\n            // up\\n            for(int i = rowEnd - 1; k < n * n && i >= rowStart; i --) {\\n                result[i][colStart] = ++ k;\\n            }\\n            colStart ++;\\n\\n        }\\n        return result;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n      int[][] result = new int[n][n];\\n        int k = 0;\\n        int rowStart = 0, rowEnd = n;\\n        int colStart = 0, colEnd = n;\\n        while (k < n * n) {\\n\\n            // right\\n            for(int i = rowStart; k < n * n && i < colEnd; i ++) {\\n                result[rowStart][i] = ++ k;\\n            }\\n            rowStart ++;\\n\\n            // down\\n            for(int i = rowStart; k < n * n && i < rowEnd; i ++) {\\n                result[i][colEnd - 1] = ++ k;\\n            }\\n            colEnd --;\\n\\n            // left\\n            for(int i = colEnd - 1; k < n * n && i >= colStart; i --) {\\n                result[rowEnd - 1][i] = ++ k;\\n            }\\n            rowEnd --;\\n\\n            // up\\n            for(int i = rowEnd - 1; k < n * n && i >= rowStart; i --) {\\n                result[i][colStart] = ++ k;\\n            }\\n            colStart ++;\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664720,
                "title": "0ms-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n));\\n        int k = 1,rs = 0,cs = 0,ce = n-1,re = n-1,i;\\n        while(rs<=re && cs <= ce){\\n            for(i = cs; i<= ce; i++){\\n                ans[rs][i] = k++;\\n            }\\n            rs++;\\n            for(i = rs; i<= re; i++){\\n                ans[i][ce] = k++;\\n            }\\n            ce--;\\n            for(i = ce; i>= cs; i--){\\n                ans[re][i] = k++;\\n            }\\n            re--;\\n            for(i = re; i>=rs; i--){\\n                ans[i][cs] = k++;\\n            }\\n            cs++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n));\\n        int k = 1,rs = 0,cs = 0,ce = n-1,re = n-1,i;\\n        while(rs<=re && cs <= ce){\\n            for(i = cs; i<= ce; i++){\\n                ans[rs][i] = k++;\\n            }\\n            rs++;\\n            for(i = rs; i<= re; i++){\\n                ans[i][ce] = k++;\\n            }\\n            ce--;\\n            for(i = ce; i>= cs; i--){\\n                ans[re][i] = k++;\\n            }\\n            re--;\\n            for(i = re; i>=rs; i--){\\n                ans[i][cs] = k++;\\n            }\\n            cs++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162072,
                "title": "fastest-explained-easy-simple-clean-code-0ms",
                "content": "**Total number of iteration** through the matrix to get all the elements in spiral order is : **\"K= (n*2)-1 \"**\\nwhere **n : number of rows** (or *number of colums* as the matrix is **n *x* n**)\\n\\nThis formula can be understood by taking example of 3x3 *(5 iterations)*, 4x4 *(7 iterations)* , 5x5 *(9 iterations)* .... matrix (just to get the idea).\\nWe are basically iterating in the four directions through the matrix.\\ni.e. \\n*1)left to right in a particular row (i.e. iterating through columns in a particular row)\\n2)up to bottom in the particular column (i.e. iterating through rows in a particular column)\\n3)right to left in the particular row (i.e. iterating through columns in a particular row)\\n4)bottom to up in the particular column (i.e. iterating through rows in a particular column)*\\n\\n```\\n\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int c=0,r=1,k=(n*2)-1;\\n        while (c<k){\\n            for (int j = c; j < n; ++j) {\\n                matrix[c][j]=r;\\n                ++r;\\n            }\\n            for (int i = c +1; i <n; ++i) {\\n                matrix[i][n-1]=r;\\n                ++r;\\n            }\\n            for (int j = n-2; j >= c; --j) {\\n                matrix[n-1][j]=r;\\n                ++r;\\n            }\\n            for (int i = n-2; i > c; --i) {\\n                matrix[i][c]=r;\\n                ++r;\\n            }\\n            --n;\\n            ++c;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n];\\n        int c=0,r=1,k=(n*2)-1;\\n        while (c<k){\\n            for (int j = c; j < n; ++j) {\\n                matrix[c][j]=r;\\n                ++r;\\n            }\\n            for (int i = c +1; i <n; ++i) {\\n                matrix[i][n-1]=r;\\n                ++r;\\n            }\\n            for (int j = n-2; j >= c; --j) {\\n                matrix[n-1][j]=r;\\n                ++r;\\n            }\\n            for (int i = n-2; i > c; --i) {\\n                matrix[i][c]=r;\\n                ++r;\\n            }\\n            --n;\\n            ++c;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033042,
                "title": "c-simple-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int k = 0;                   //number of steps\\n        vector<vector<int>> res;     //to store the matrix\\n        \\n        //maybe you can find some better way to initialize the matrix array, but I decided to fill it with zeros))\\n        for(int i = 0; i < n; i++){\\n            vector<int> v;\\n            for(int j = 0; j < n; j++){\\n                v.push_back(0);\\n            }\\n            res.push_back(v);\\n        }\\n        \\n        //these variables will be used as pointers\\n        int r = n - 1;      //right bound \\n        int l = 0;          //left bound\\n        int u = 0;          //up bound\\n        int d = n - 1;      //down bound\\n        int i = 0;          //vertical position\\n        int j = 0;          //horizontal position\\n        \\n        while(k++ < n * n){       //we should make n*n steps to fill all the matrix\\n            res[i][j] = k;\\n            \\n            if(i == u && j < r) {    //move right\\n                j++;\\n                if(j == r) u++;      //if the bound is reached, shift the bound\\n            }\\n            else if(i < d && j == r) {       //move down\\n                i++;\\n                if(i == d) r--;\\n            }\\n            else if(i == d && j > l) {     //move left\\n                j--;\\n                if(j == l) d--;\\n            }\\n            else if(i > u && j == l) {     //move right\\n                i--;\\n                if(i == u) l++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int k = 0;                   //number of steps\\n        vector<vector<int>> res;     //to store the matrix\\n        \\n        //maybe you can find some better way to initialize the matrix array, but I decided to fill it with zeros))\\n        for(int i = 0; i < n; i++){\\n            vector<int> v;\\n            for(int j = 0; j < n; j++){\\n                v.push_back(0);\\n            }\\n            res.push_back(v);\\n        }\\n        \\n        //these variables will be used as pointers\\n        int r = n - 1;      //right bound \\n        int l = 0;          //left bound\\n        int u = 0;          //up bound\\n        int d = n - 1;      //down bound\\n        int i = 0;          //vertical position\\n        int j = 0;          //horizontal position\\n        \\n        while(k++ < n * n){       //we should make n*n steps to fill all the matrix\\n            res[i][j] = k;\\n            \\n            if(i == u && j < r) {    //move right\\n                j++;\\n                if(j == r) u++;      //if the bound is reached, shift the bound\\n            }\\n            else if(i < d && j == r) {       //move down\\n                i++;\\n                if(i == d) r--;\\n            }\\n            else if(i == d && j > l) {     //move left\\n                j--;\\n                if(j == l) d--;\\n            }\\n            else if(i > u && j == l) {     //move right\\n                i--;\\n                if(i == u) l++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943878,
                "title": "simple-solution-with-only-one-for-loop",
                "content": "```\\n\\npublic class Solution {\\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] matrix = new int[n][];\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            matrix[i] = Enumerable.Repeat(0, n).ToArray();\\n        }\\n        \\n        int[] directionX = new int[] { 0, 1, 0, -1 };\\n        int[] directionY = new int[] { 1, 0, -1, 0 };\\n        int x = 0;\\n        int y = 0;\\n        int direction = 0;\\n        \\n        for (int i = 1; i <= n * n; i++)\\n        {\\n            matrix[x][y] = i;\\n            \\n            //do not need this on the last step\\n            if (i != n * n)\\n            {\\n                x += directionX[direction];\\n                y += directionY[direction];\\n\\n                //if we are out of bounds or on the already visited cell then change the direction\\n                if (x < 0 || y < 0 || x > n-1 || y > n-1 || matrix[x][y] != 0)\\n                {\\n                    x -= directionX[direction];\\n                    y -= directionY[direction];\\n\\n                    direction = (direction + 1) % 4;\\n\\n                    x += directionX[direction];\\n                    y += directionY[direction];\\n                }\\n            }\\n        }\\n        \\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] matrix = new int[n][];\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            matrix[i] = Enumerable.Repeat(0, n).ToArray();\\n        }\\n        \\n        int[] directionX = new int[] { 0, 1, 0, -1 };\\n        int[] directionY = new int[] { 1, 0, -1, 0 };\\n        int x = 0;\\n        int y = 0;\\n        int direction = 0;\\n        \\n        for (int i = 1; i <= n * n; i++)\\n        {\\n            matrix[x][y] = i;\\n            \\n            //do not need this on the last step\\n            if (i != n * n)\\n            {\\n                x += directionX[direction];\\n                y += directionY[direction];\\n\\n                //if we are out of bounds or on the already visited cell then change the direction\\n                if (x < 0 || y < 0 || x > n-1 || y > n-1 || matrix[x][y] != 0)\\n                {\\n                    x -= directionX[direction];\\n                    y -= directionY[direction];\\n\\n                    direction = (direction + 1) % 4;\\n\\n                    x += directionX[direction];\\n                    y += directionY[direction];\\n                }\\n            }\\n        }\\n        \\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942034,
                "title": "java-100-solution",
                "content": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n]; \\n        \\n        int ele = 1; // the element to store in the matrix\\n        \\n        int[][] dir = new int[][]{{0,1},{1,0},{0,-1},{-1,0}}; //direction in which we traverse the matrix\\n        \\n        int flag = 0; // will take the values 0,1,2,3 to change direction according to increment values in dir array\\n        \\n        int row = 0, col = 0; //current row and column\\n        \\n        int rowinc = dir[flag % 4][0], colinc = dir[flag % 4][1]; //row increment, column increment\\n        \\n        while(ele <= Math.pow(n,2)){\\n            matrix[row][col] = ele;\\n            \\n            if(row + rowinc >= n || row + rowinc < 0 || col + colinc >= n || col + colinc < 0 || matrix[row + rowinc][col + colinc] != 0){\\n                //change direction\\n                \\n                flag++;\\n                rowinc = dir[flag % 4][0];\\n                colinc = dir[flag % 4][1];\\n            }\\n            \\n            ele++;\\n            row += rowinc;\\n            col += colinc;\\n        }\\n        \\n        return matrix;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] generateMatrix(int n) {\\n        int[][] matrix = new int[n][n]; \\n        \\n        int ele = 1; // the element to store in the matrix\\n        \\n        int[][] dir = new int[][]{{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 1942019,
                "title": "java-0ms-100-faster-simple-logic",
                "content": "```class Solution {\\n    public int[][] generateMatrix(int n) {\\n        int result[][]=new int[n][n];\\n        if(n==1){\\n            result[0][0]=1;\\n            return result;\\n        }\\n        int rowBegin=0;\\n        int rowEnd=n-1;\\n        int colBegin=0;\\n        int colEnd=n-1;\\n        int k=1;\\n        \\n        while(colBegin<=colEnd && rowBegin<=rowEnd){\\n            for(int i=colBegin;i<=colEnd;i++){\\n                result[rowBegin][i]=k++;\\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd;i++){\\n                result[i][colEnd]=k++;\\n            }\\n            colEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=colEnd;i>=colBegin;i--){\\n                    result[rowEnd][i]=k++;\\n                }\\n            }\\n            rowEnd--;\\n            if(colBegin<=colEnd){\\n                for(int i=rowEnd;i>=rowBegin;i--){\\n                    result[i][colBegin]=k++;\\n                }\\n            }\\n            colBegin++;\\n            \\n        }\\n            \\n        \\n        \\n        return result;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] generateMatrix(int n) {\\n        int result[][]=new int[n][n];\\n        if(n==1){\\n            result[0][0]=1;\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1941759,
                "title": "python-3-intuitive-6-lines-solution",
                "content": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:       \\n        A, S, D, X, Y =[[0]*n for _ in range(n)], 0, [[1,0],[0,1],[-1,0],[0,-1]], 0, 0\\n\\t\\t# - A:  Answer\\n\\t\\t# - S:  Status. 0: right, 1: up, 2: left, 3: down\\n\\t\\t# - D:  Direction list\\n\\t\\t# - X,Y: location\\n        valid = lambda x,y: 0<=x<n and 0<=y<n and A[y][x] == 0\\n        for i  in range(1,n*n+1):\\n            A[Y][X], S = i, (S + (not valid(X+D[S][0],Y+D[S][1]))*1) % 4\\n            X,Y = X+D[S][0], Y+D[S][1]\\n        return A\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:       \\n        A, S, D, X, Y =[[0]*n for _ in range(n)], 0, [[1,0],[0,1],[-1,0],[0,-1]], 0, 0\\n\\t\\t# - A:  Answer\\n\\t\\t# - S:  Status. 0: right, 1: up, 2: left, 3: down\\n\\t\\t# - D:  Direction list\\n\\t\\t# - X,Y: location\\n        valid = lambda x,y: 0<=x<n and 0<=y<n and A[y][x] == 0\\n        for i  in range(1,n*n+1):\\n            A[Y][X], S = i, (S + (not valid(X+D[S][0],Y+D[S][1]))*1) % 4\\n            X,Y = X+D[S][0], Y+D[S][1]\\n        return A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941530,
                "title": "c-0ms-100-faster-easy-and-simple",
                "content": "Here, we just have to understand the trend of matrix.\\nLike how we are filling the matrix.\\nfirst we are doing first column to last column,\\nthen first row +1 to last row then again last column to  first column and same with last row to first row...this way we can approach this question.\\n\\nyou will have more understanding after viewing the code.\\n\\nhope you like it.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> v(n,vector<int>(n,0));\\n        if(n==0)\\n        {\\n            return v;\\n        }\\n        int firstRow=0;\\n        int firstColumn=0;\\n        int lastRow=n-1;\\n        int lastColumn=n-1;\\n        int i=1;\\n        int num=n*n;\\n       \\n        while(firstRow<=lastRow && firstColumn<=lastColumn)\\n        {\\n            for(int j=firstColumn;j<=lastColumn;j++)\\n            { \\n                v[firstRow][j]=i;\\n                i++;\\n            }\\n            if(i>num)break;\\n            for(int j=firstRow+1;j<=lastRow;j++)\\n            {\\n                v[j][lastColumn]=i;\\n                i++;\\n            }\\n            if(i>num)break;\\n            for(int j=lastColumn-1;j>=firstColumn;j--)\\n            { \\n                v[lastRow][j]=i;\\n                i++;  \\n            }\\n            if(i>num)break;   \\n            for(int j=lastRow-1;j>firstRow;j--)\\n            {\\n                v[j][firstColumn]=i;\\n                i++;  \\n            }\\n            if(i>num)break;\\n            firstRow++;\\n            firstColumn++;\\n            lastRow--;\\n            lastColumn--;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> v(n,vector<int>(n,0));\\n        if(n==0)\\n        {\\n            return v;\\n        }\\n        int firstRow=0;\\n        int firstColumn=0;\\n        int lastRow=n-1;\\n        int lastColumn=n-1;\\n        int i=1;\\n        int num=n*n;\\n       \\n        while(firstRow<=lastRow && firstColumn<=lastColumn)\\n        {\\n            for(int j=firstColumn;j<=lastColumn;j++)\\n            { \\n                v[firstRow][j]=i;\\n                i++;\\n            }\\n            if(i>num)break;\\n            for(int j=firstRow+1;j<=lastRow;j++)\\n            {\\n                v[j][lastColumn]=i;\\n                i++;\\n            }\\n            if(i>num)break;\\n            for(int j=lastColumn-1;j>=firstColumn;j--)\\n            { \\n                v[lastRow][j]=i;\\n                i++;  \\n            }\\n            if(i>num)break;   \\n            for(int j=lastRow-1;j>firstRow;j--)\\n            {\\n                v[j][firstColumn]=i;\\n                i++;  \\n            }\\n            if(i>num)break;\\n            firstRow++;\\n            firstColumn++;\\n            lastRow--;\\n            lastColumn--;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941518,
                "title": "c-easy-to-understand-with-comments",
                "content": "```\\npublic class Solution \\n{\\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] mat = new int[n][];\\n        for (int i = 0; i < n; i++)\\n            mat[i] = new int[n];\\n        \\n        (int top, int bottom, int left, int right) = (0, n - 1, 0, n - 1);\\n        \\n        int val = 1;\\n        while (true) \\n        {\\n            //left to right, colms are changing\\n            for (int i = left; i <= right; i++)\\n                mat[top][i] = val++;\\n            \\n            top++; //row covered, bring it down\\n           \\n            if (top > bottom)\\n                break;\\n            \\n            //top to bottom, rows are changing\\n            for (int i = top; i <= bottom; i++)\\n                mat[i][right] = val++;\\n\\n            right--; //colm covered, shrink the column window\\n            \\n            if (left > right)\\n                break;\\n            \\n            //right to left, colms are changing\\n            for (int i = right; i >= left; i--)\\n                mat[bottom][i] = val++;\\n            \\n            bottom--; //row covered, shrink the row window\\n            \\n            //bottom to top, rows are changing\\n            for (int i = bottom; i >= top; i--)\\n                mat[i][left] = val++;\\n            \\n            left++; //col covered, shrink the colm window\\n            \\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] mat = new int[n][];\\n        for (int i = 0; i < n; i++)\\n            mat[i] = new int[n];\\n        \\n        (int top, int bottom, int left, int right) = (0, n - 1, 0, n - 1);\\n        \\n        int val = 1;\\n        while (true) \\n        {\\n            //left to right, colms are changing\\n            for (int i = left; i <= right; i++)\\n                mat[top][i] = val++;\\n            \\n            top++; //row covered, bring it down\\n           \\n            if (top > bottom)\\n                break;\\n            \\n            //top to bottom, rows are changing\\n            for (int i = top; i <= bottom; i++)\\n                mat[i][right] = val++;\\n\\n            right--; //colm covered, shrink the column window\\n            \\n            if (left > right)\\n                break;\\n            \\n            //right to left, colms are changing\\n            for (int i = right; i >= left; i--)\\n                mat[bottom][i] = val++;\\n            \\n            bottom--; //row covered, shrink the row window\\n            \\n            //bottom to top, rows are changing\\n            for (int i = bottom; i >= top; i--)\\n                mat[i][left] = val++;\\n            \\n            left++; //col covered, shrink the colm window\\n            \\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877702,
                "title": "python-easy-simulation-solution",
                "content": "### **Spiral Matrix II**\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:    \\n        r, c = 0, 0\\n        dr, dc = 0, 1\\n        res = [[0] * n for _ in range(n)]\\n        \\n        for i in range(1, n*n + 1):\\n            res[r][c] = i   \\n            \\n            # at most one right turn\\n            tmpR, tmpC = r + dr, c + dc\\n            if (\\n                tmpR < 0 or tmpR >= n or\\n                tmpC < 0 or tmpC >= n or \\n                res[tmpR][tmpC] != 0\\n            ):\\n                dr, dc = dc, -dr # 90 degree clockwise\\n            \\n            r, c = r + dr, c + dc\\n         \\n        return res\\n```\\nMy Solutions of Related Problems:\\n* 54. Spiral Matrix: [Python, easy simulation solution]( https://leetcode.com/problems/spiral-matrix/discuss/1875750/python-lazy-simulation)\\n* 885. Spiral Matrix III: [Python, easy simulation solution with explanation.](https://leetcode.com/problems/spiral-matrix-iii/discuss/1877691/python-easy-solution-with-explanation)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:    \\n        r, c = 0, 0\\n        dr, dc = 0, 1\\n        res = [[0] * n for _ in range(n)]\\n        \\n        for i in range(1, n*n + 1):\\n            res[r][c] = i   \\n            \\n            # at most one right turn\\n            tmpR, tmpC = r + dr, c + dc\\n            if (\\n                tmpR < 0 or tmpR >= n or\\n                tmpC < 0 or tmpC >= n or \\n                res[tmpR][tmpC] != 0\\n            ):\\n                dr, dc = dc, -dr # 90 degree clockwise\\n            \\n            r, c = r + dr, c + dc\\n         \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862754,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int top=0;\\n        int bottom=n-1;\\n        int left=0;\\n        int right=n-1;\\n        int count=1;\\n        int matrix[][]=new int[n][n];\\n        while(left<=right){\\n            for(int i=left;i<=right;i++){\\n                matrix[top][i]=count++;\\n            }\\n            top++;\\n            \\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=count++;\\n            }\\n            right--;\\n            \\n            \\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=count++;\\n            }\\n                bottom--;\\n            \\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=count++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int top=0;\\n        int bottom=n-1;\\n        int left=0;\\n        int right=n-1;\\n        int count=1;\\n        int matrix[][]=new int[n][n];\\n        while(left<=right){\\n            for(int i=left;i<=right;i++){\\n                matrix[top][i]=count++;\\n            }\\n            top++;\\n            \\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=count++;\\n            }\\n            right--;\\n            \\n            \\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=count++;\\n            }\\n                bottom--;\\n            \\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=count++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1810692,
                "title": "easy-understanding-java-solution",
                "content": "```\\nprivate int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\tprivate int direction = 0;\\n\\tpublic int[][] generateMatrix(int n) {\\n\\t\\tint[][] res = new int[n][n];\\n\\t\\tres[0][0] = 1;\\n\\t\\tint row = 0;\\n\\t\\tint col = 0;\\n\\t\\tint count = 2;\\n\\t\\twhile (count <= n * n) {\\n\\t\\t\\tif (canGo(row + dirs[direction][0], col + dirs[direction][1],res)){\\n\\t\\t\\t\\trow += dirs[direction][0];\\n\\t\\t\\t\\tcol += dirs[direction][1];\\n\\t\\t\\t\\tres[row][col] = count;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdirection++;\\n\\t\\t\\t\\tdirection = direction % 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\tprivate boolean canGo(int i, int j, int[][] res) {\\n\\t\\tif (i > res.length - 1 || i < 0 || j > res[0].length - 1 || j < 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif(res[i][j] != 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\tprivate int direction = 0;\\n\\tpublic int[][] generateMatrix(int n) {\\n\\t\\tint[][] res = new int[n][n];\\n\\t\\tres[0][0] = 1;\\n\\t\\tint row = 0;\\n\\t\\tint col = 0;\\n\\t\\tint count = 2;\\n\\t\\twhile (count <= n * n) {\\n\\t\\t\\tif (canGo(row + dirs[direction][0], col + dirs[direction][1],res)){\\n\\t\\t\\t\\trow += dirs[direction][0];\\n\\t\\t\\t\\tcol += dirs[direction][1];\\n\\t\\t\\t\\tres[row][col] = count;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdirection++;\\n\\t\\t\\t\\tdirection = direction % 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\tprivate boolean canGo(int i, int j, int[][] res) {\\n\\t\\tif (i > res.length - 1 || i < 0 || j > res[0].length - 1 || j < 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif(res[i][j] != 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1657189,
                "title": "c-100-faster-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) \\n    {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int num = 1,r1 =0,r2 = n-1,c1 =0,c2 = n-1;\\n        while(r1<=r2 && c1<=c2)\\n        {\\n            //For first row\\n            for(int i = c1;i<=c2;i++)\\n            {\\n                ans[r1][i] = num++;\\n            }\\n            //For last column\\n            for(int j =r1+1;j<=r2;j++)\\n            {\\n                ans[j][c2] = num++;\\n            }\\n            //For last row\\n            if(r1 != r2)\\n            {\\n                for(int i = c2-1;i>=c1;i--)\\n                {\\n                    ans[r2][i] = num++;\\n                }\\n            }\\n            //For first column\\n            if(c1 != c2)\\n            {\\n                for(int i = r2-1;i>r1;i--)\\n                {\\n                    ans[i][c1] = num++;\\n                }\\n            }\\n            r1++;\\n            r2--;\\n            c1++;\\n            c2--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) \\n    {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int num = 1,r1 =0,r2 = n-1,c1 =0,c2 = n-1;\\n        while(r1<=r2 && c1<=c2)\\n        {\\n            //For first row\\n            for(int i = c1;i<=c2;i++)\\n            {\\n                ans[r1][i] = num++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1620082,
                "title": "99-faster-python-code",
                "content": "Feel free to ask any question !\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        ans = [[0]*n for i in range(n)]\\n        i,j = 0, 0\\n        dire = [0,1,0,-1,0]\\n        po = 0\\n        for a in range(1,n*n+1):\\n            ans[i][j] = a\\n            ni,nj = i+dire[po],j+dire[po+1]\\n            if (not 0<=ni<n) or (not 0<=nj<n) or ans[ni][nj]!=0:\\n                po+=1\\n                po%=4\\n                ni,nj = i+dire[po],j+dire[po+1]\\n            i,j = ni,nj\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        ans = [[0]*n for i in range(n)]\\n        i,j = 0, 0\\n        dire = [0,1,0,-1,0]\\n        po = 0\\n        for a in range(1,n*n+1):\\n            ans[i][j] = a\\n            ni,nj = i+dire[po],j+dire[po+1]\\n            if (not 0<=ni<n) or (not 0<=nj<n) or ans[ni][nj]!=0:\\n                po+=1\\n                po%=4\\n                ni,nj = i+dire[po],j+dire[po+1]\\n            i,j = ni,nj\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424885,
                "title": "0-ms-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int p=1;\\n        int i=0,j=0,r=n,c=n;\\n        vector<vector<int>> v(n,vector<int>(n));\\n        while(i<r && j<c){\\n            for(int k=j;k<c;k++) v[i][k]=p++;\\n            i++;\\n            for(int k=i;k<r;k++) v[k][c-1]=p++;\\n            c--;\\n            if(j<c){\\n                for(int k=c-1;k>=j;k--) v[r-1][k]=p++;\\n                r--;\\n            }\\n            if(i<r){\\n                for(int k=r-1;k>=i;k--) v[k][j]=p++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int p=1;\\n        int i=0,j=0,r=n,c=n;\\n        vector<vector<int>> v(n,vector<int>(n));\\n        while(i<r && j<c){\\n            for(int k=j;k<c;k++) v[i][k]=p++;\\n            i++;\\n            for(int k=i;k<r;k++) v[k][c-1]=p++;\\n            c--;\\n            if(j<c){\\n                for(int k=c-1;k>=j;k--) v[r-1][k]=p++;\\n                r--;\\n            }\\n            if(i<r){\\n                for(int k=r-1;k>=i;k--) v[k][j]=p++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137794,
                "title": "java-explained-with-images-easy-intuitive-solution",
                "content": "We just need to iterate over the outer boundaries and do it for every inner squares \\n![image](https://assets.leetcode.com/users/images/abecb707-c10a-4c21-9f1f-626793445486_1617302946.2052238.jpeg)\\n\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n        int k=0;int[][] matrix = new int[n][n];int val=1;\\n        while( k <= n/2 )\\n        {\\n            for( int j = k; j < n-k; j++)\\n               matrix[k][j] = val++;\\n        \\n            for( int  i = k+1; i < n-k-1; i++ )\\n                matrix[i][n-k-1] = val++;\\n        \\n            for( int  j = n-k-1; j > k; j-- )\\n                matrix[n-k-1][j] = val++;\\n        \\n            for( int  i = n-k-1; i > k; i-- )\\n               matrix[i][k] = val++;\\n        k++;\\n        }        \\n     return matrix;   \\n    }\\n}\\nComplexity is O(n2) as we are iterating over all the cells in the matrix.\\nPlease upvote if you like the explanation.\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] generateMatrix(int n) {\\n        \\n        int k=0;int[][] matrix = new int[n][n];int val=1;\\n        while( k <= n/2 )\\n        {\\n            for( int j = k; j < n-k; j++)\\n               matrix[k][j] = val++;\\n        \\n            for( int  i = k+1; i < n-k-1; i++ )\\n                matrix[i][n-k-1] = val++;\\n        \\n            for( int  j = n-k-1; j > k; j-- )\\n                matrix[n-k-1][j] = val++;\\n        \\n            for( int  i = n-k-1; i > k; i-- )\\n               matrix[i][k] = val++;\\n        k++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1106288,
                "title": "100-fast-simple-easy-understanding-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int left=0,right=n-1,top=0,bottom=n-1,c=1;\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n        while(1){\\n            if(left>right){\\n                break;\\n            }\\n            for(int i=left;i<=right;i++){\\n                mat[top][i]=c;\\n                c++;\\n            }\\n            top++;\\n            if(top>bottom){\\n                break;\\n            }\\n            for(int i=top;i<=bottom;i++){\\n                mat[i][right]=c;\\n                c++;\\n            }\\n            right--;\\n            if(left>right){\\n                break;\\n            }\\n            for(int i=right;i>=left;i--){\\n                mat[bottom][i]=c;\\n                c++;\\n            }\\n            bottom--;\\n            if(top>bottom){\\n                break;\\n            }\\n            for(int i=bottom;i>=top;i--){\\n                mat[i][left]=c;\\n                c++;\\n            }\\n            left++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int left=0,right=n-1,top=0,bottom=n-1,c=1;\\n        vector<vector<int>> mat(n,vector<int> (n,0));\\n        while(1){\\n            if(left>right){\\n                break;\\n            }\\n            for(int i=left;i<=right;i++){\\n                mat[top][i]=c;\\n                c++;\\n            }\\n            top++;\\n            if(top>bottom){\\n                break;\\n            }\\n            for(int i=top;i<=bottom;i++){\\n                mat[i][right]=c;\\n                c++;\\n            }\\n            right--;\\n            if(left>right){\\n                break;\\n            }\\n            for(int i=right;i>=left;i--){\\n                mat[bottom][i]=c;\\n                c++;\\n            }\\n            bottom--;\\n            if(top>bottom){\\n                break;\\n            }\\n            for(int i=bottom;i>=top;i--){\\n                mat[i][left]=c;\\n                c++;\\n            }\\n            left++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081014,
                "title": "spiral-matrix-ii-js-solution-beats-100",
                "content": "```\\nvar generateMatrix = function (n) {\\n    let dr = [0, 1, 0, -1],\\n        dc = [1, 0, -1, 0],\\n        dir = 0,\\n        board = [],\\n        row = 0,\\n        col = 0;\\n    for (let i = 0; i < n; i++) {\\n        board[i] = Array(n).fill(0)\\n    }\\n    for (i = 1; i <= n * n; i++) {\\n        board[row][col] = i\\n        let nRow = row + dr[dir % 4],\\n            nCol = col + dc[dir % 4]\\n        if (nRow >= 0 && nRow < n && nCol >= 0 && nCol < n && board[nRow] && board[nRow][nCol] == 0) {\\n            row = nRow\\n            col = nCol\\n        } else {\\n            dir++\\n            row += dr[dir % 4]\\n            col += dc[dir % 4]\\n        }\\n    }\\n    return board\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateMatrix = function (n) {\\n    let dr = [0, 1, 0, -1],\\n        dc = [1, 0, -1, 0],\\n        dir = 0,\\n        board = [],\\n        row = 0,\\n        col = 0;\\n    for (let i = 0; i < n; i++) {\\n        board[i] = Array(n).fill(0)\\n    }\\n    for (i = 1; i <= n * n; i++) {\\n        board[row][col] = i\\n        let nRow = row + dr[dir % 4],\\n            nCol = col + dc[dir % 4]\\n        if (nRow >= 0 && nRow < n && nCol >= 0 && nCol < n && board[nRow] && board[nRow][nCol] == 0) {\\n            row = nRow\\n            col = nCol\\n        } else {\\n            dir++\\n            row += dr[dir % 4]\\n            col += dc[dir % 4]\\n        }\\n    }\\n    return board\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 963724,
                "title": "c-super-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isNextValid(int x, int y, int direction_x, int direction_y, int n, vector<vector<int>> mat) {\\n        if ((x + direction_x < 0) || (x + direction_x >= n))\\n            return false;\\n        if ((y + direction_y < 0) || (y + direction_y >= n))\\n            return false;\\n        if (mat[y + direction_y][x + direction_x] != 0)\\n            return false;\\n        return true;\\n    }\\n    \\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n, vector<int>(n));\\n        int direction_x = 1, direction_y = 0;\\n        int curr_x = 0, curr_y = 0;\\n        int count = 1;\\n        \\n        while (count <= pow(n, 2)) {\\n            mat[curr_y][curr_x] = count;\\n\\t\\t\\t\\n            // If next cell is out of range or filled already - change direction:\\n            if (!isNextValid(curr_x, curr_y, direction_x, direction_y, n, mat)) {\\n                swap(direction_x, direction_y);\\n                direction_x *= -1;\\n            }\\n            curr_x += direction_x;\\n            curr_y += direction_y;\\n            count++;\\n        }\\n        return mat;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isNextValid(int x, int y, int direction_x, int direction_y, int n, vector<vector<int>> mat) {\\n        if ((x + direction_x < 0) || (x + direction_x >= n))\\n            return false;\\n        if ((y + direction_y < 0) || (y + direction_y >= n))\\n            return false;\\n        if (mat[y + direction_y][x + direction_x] != 0)\\n            return false;\\n        return true;\\n    }\\n    \\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n, vector<int>(n));\\n        int direction_x = 1, direction_y = 0;\\n        int curr_x = 0, curr_y = 0;\\n        int count = 1;\\n        \\n        while (count <= pow(n, 2)) {\\n            mat[curr_y][curr_x] = count;\\n\\t\\t\\t\\n            // If next cell is out of range or filled already - change direction:\\n            if (!isNextValid(curr_x, curr_y, direction_x, direction_y, n, mat)) {\\n                swap(direction_x, direction_y);\\n                direction_x *= -1;\\n            }\\n            curr_x += direction_x;\\n            curr_y += direction_y;\\n            count++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819134,
                "title": "python-easy-to-understand-fast-o-n-2-time-and-space-complexity-explained",
                "content": "Objective is to traverse matrix in spiral order and assign values in ascending order. \\n\\nSo we can use directions 0 being left to right, 1 being right to down, 2 being down to left and 3 being down to up left corner. \\n\\nTo keep track of how much data we have fiiled we will use 4 variables **sr** (starting row/rows filled), **sc**(starting column/columns filled), **er** (ending row till which rows are filled), **ec** (ending column till which column are filled)\\n\\nEach time we go from upper left to right we increment sr (starting row) count by 1 denoting that we have filled that row. \\nThen we go from right corner up to down and we decrement ec (ending column) by 1 denoting that we filled right most column. \\nThen we go from bottom right to bottom left and fill the bottom row and decrement er (ending row) count by 1 denoting we have filled that row.\\nAnd same with the left most column going from bottom to up and incrementing sc (starting column) count by 1.\\n\\nWe will use these 4 variables into our program to navigate each direction from sc to ec, sr to er, ec to sc, er to sr.\\n\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        sr, sc, er, ec = 0, 0, n-1, n-1\\n        \\n        direction = 0\\n        counter = 1\\n        \\n        while sr <= er and sc <= ec:\\n            if direction == 0:\\n                for i in range(sc, ec+1):\\n                    matrix[sr][i] = counter\\n                    counter+=1\\n                sr+=1\\n                direction = 1\\n            elif direction==1:\\n                for i in range(sr, er+1):\\n                    matrix[i][ec] = counter\\n                    counter+=1\\n                ec-=1\\n                direction = 2\\n            elif direction==2:\\n                for i in range(ec, sc-1, -1):\\n                    matrix[er][i] = counter\\n                    counter+=1\\n                er-=1\\n                direction = 3\\n            else:\\n                for i in range(er, sr-1, -1):\\n                    matrix[i][sc] = counter\\n                    counter+=1\\n                sc+=1\\n                direction = 0\\n        \\n        return matrix\\n```\\n\\nSimplifying the code further. If you notice properly, we donot really need direction variable at all. Reason being that we have a square matrix and hence sr, sc, er, ec all would meet at the center. If the matrix was not square we would not be able to do this simplification. We can eliminate whole if else structure.\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        sr, sc, er, ec = 0, 0, n-1, n-1\\n        counter = 1\\n        \\n        while sr <= er and sc <= ec:\\n\\n            for i in range(sc, ec+1):\\n                matrix[sr][i] = counter\\n                counter+=1\\n            sr+=1\\n\\n            for i in range(sr, er+1):\\n                matrix[i][ec] = counter\\n                counter+=1\\n            ec-=1\\n\\n            for i in range(ec, sc-1, -1):\\n                matrix[er][i] = counter\\n                counter+=1\\n            er-=1\\n\\n            for i in range(er, sr-1, -1):\\n                matrix[i][sc] = counter\\n                counter+=1\\n            sc+=1\\n        \\n        return matrix\\n```\\n\\nTime Complexity: O(N^2)\\nSpace Complexity: O(N^2)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        sr, sc, er, ec = 0, 0, n-1, n-1\\n        \\n        direction = 0\\n        counter = 1\\n        \\n        while sr <= er and sc <= ec:\\n            if direction == 0:\\n                for i in range(sc, ec+1):\\n                    matrix[sr][i] = counter\\n                    counter+=1\\n                sr+=1\\n                direction = 1\\n            elif direction==1:\\n                for i in range(sr, er+1):\\n                    matrix[i][ec] = counter\\n                    counter+=1\\n                ec-=1\\n                direction = 2\\n            elif direction==2:\\n                for i in range(ec, sc-1, -1):\\n                    matrix[er][i] = counter\\n                    counter+=1\\n                er-=1\\n                direction = 3\\n            else:\\n                for i in range(er, sr-1, -1):\\n                    matrix[i][sc] = counter\\n                    counter+=1\\n                sc+=1\\n                direction = 0\\n        \\n        return matrix\\n```\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\\n        sr, sc, er, ec = 0, 0, n-1, n-1\\n        counter = 1\\n        \\n        while sr <= er and sc <= ec:\\n\\n            for i in range(sc, ec+1):\\n                matrix[sr][i] = counter\\n                counter+=1\\n            sr+=1\\n\\n            for i in range(sr, er+1):\\n                matrix[i][ec] = counter\\n                counter+=1\\n            ec-=1\\n\\n            for i in range(ec, sc-1, -1):\\n                matrix[er][i] = counter\\n                counter+=1\\n            er-=1\\n\\n            for i in range(er, sr-1, -1):\\n                matrix[i][sc] = counter\\n                counter+=1\\n            sc+=1\\n        \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732201,
                "title": "a-different-and-quick-approach-in-rust-but-explained",
                "content": "The most common approach is simulating, but actually we can write a function that maps `(n, x, y)` to `cell value`.\\n\\nFor example:\\n```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\\nIf we can write a function that maps `n=3, x=1, y = 2` to `6`, the problem will be easily solved.\\n\\n#### How to write it?\\n\\nWell, people may have different approaches, but mine is regarding the map as an onion which consists of several circles like this:\\n\\n```\\n[2, 2, 2, 2, 2, 2], \\n[2, 1, 1, 1, 1, 2], \\n[2, 1, 0, 0, 1, 2],\\n[2, 1, 0, 0, 1, 2], \\n[2, 1, 1, 1, 1, 2], \\n[2, 2, 2, 2, 2, 2]\\n```\\n\\nWith the circle numer(0-2), we calculate the base(the number current circle begins with):\\n\\n```\\n[0, 0,  0,  0,  0,  0],\\n[0, 20, 20, 20, 20, 0],\\n[0, 20, 32, 32, 20, 0],\\n[0, 20, 32, 32, 20, 0],\\n[0, 20, 20, 20, 20, 0],\\n[0, 0,  0,  0,  0,  0]]\\n```\\n\\nThen we calculates the offset(position of the cell locates on the circle):\\n\\n```\\n[0,  1,  2,  3,  4,  5 ], \\n[19, 0,  1,  2,  3,  6 ], \\n[18, 11, 0,  1,  4,  7 ], \\n[17, 10, 3,  2,  5,  8 ], \\n[16, 9,  8,  7,  6,  9 ], \\n[15, 14, 13, 12, 11, 10]\\n```\\n\\nThen we add it together:\\n\\n```\\n[0,  1,  2,  3,  4,  5 ], \\n[19, 20, 21, 22, 23, 6 ], \\n[18, 31, 32, 33, 24, 7 ], \\n[17, 30, 35, 34, 25, 8 ],\\n[16, 29, 28, 27, 26, 9 ],\\n[15, 14, 13, 12, 11, 10]\\n```\\n\\nThat\\'s all. Don\\'t forget to add 1. LOL. I wrote it in Rust:\\n\\n```\\nRuntime: 0 ms, faster than 100.00% of Rust online submissions for Spiral Matrix II.\\n```\\n\\n```Rust\\nfn spiral(n: usize, x: usize, y: usize) -> usize {\\n    let loop_max = (n - 1) / 2;\\n\\n    let tmp = |x| {\\n        if x <= loop_max {\\n            loop_max - x\\n        } else {\\n            x + loop_max + 1 - n\\n        }\\n    };\\n\\n    let loop_count = tmp(x).max(tmp(y));\\n\\n    let circle_len: fn(usize) -> usize = if n % 2 == 0 {\\n        |x| 8 * x + 4\\n    } else {\\n        |x| if x == 0 { 1 } else { 8 * x }\\n    };\\n\\n    let base = (loop_max - loop_count) * (circle_len(loop_max) + circle_len(loop_count + 1)) / 2;\\n\\n    let current_circle_len = circle_len(loop_count);\\n\\n    let diff = loop_max - loop_count;\\n\\n    let offset = if y == diff {\\n        x - y\\n    } else if x == n - 1 - diff {\\n        current_circle_len / 4 + (y - diff)\\n    } else if y == n - 1 - diff {\\n        3 * current_circle_len / 4 - (x - diff)\\n    } else if x == diff {\\n        current_circle_len - (y - diff)\\n    } else {\\n        unreachable!()\\n    };\\n\\n    base + offset\\n}\\n\\npub fn generate_matrix(n: i32) -> Vec<Vec<i32>> {\\n    if n == 0 {\\n        return vec![];\\n    }\\n    let n = n as usize;\\n    let mut result = vec![Vec::with_capacity(n); n];\\n    for y in 0..n {\\n        for x in 0..n {\\n            result[y].push(spiral(n, x, y) as i32 + 1);\\n        }\\n    }\\n    result\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n1 2 3\\n8 9 4\\n7 6 5\\n```\n```\\n[2, 2, 2, 2, 2, 2], \\n[2, 1, 1, 1, 1, 2], \\n[2, 1, 0, 0, 1, 2],\\n[2, 1, 0, 0, 1, 2], \\n[2, 1, 1, 1, 1, 2], \\n[2, 2, 2, 2, 2, 2]\\n```\n```\\n[0, 0,  0,  0,  0,  0],\\n[0, 20, 20, 20, 20, 0],\\n[0, 20, 32, 32, 20, 0],\\n[0, 20, 32, 32, 20, 0],\\n[0, 20, 20, 20, 20, 0],\\n[0, 0,  0,  0,  0,  0]]\\n```\n```\\n[0,  1,  2,  3,  4,  5 ], \\n[19, 0,  1,  2,  3,  6 ], \\n[18, 11, 0,  1,  4,  7 ], \\n[17, 10, 3,  2,  5,  8 ], \\n[16, 9,  8,  7,  6,  9 ], \\n[15, 14, 13, 12, 11, 10]\\n```\n```\\n[0,  1,  2,  3,  4,  5 ], \\n[19, 20, 21, 22, 23, 6 ], \\n[18, 31, 32, 33, 24, 7 ], \\n[17, 30, 35, 34, 25, 8 ],\\n[16, 29, 28, 27, 26, 9 ],\\n[15, 14, 13, 12, 11, 10]\\n```\n```\\nRuntime: 0 ms, faster than 100.00% of Rust online submissions for Spiral Matrix II.\\n```\n```Rust\\nfn spiral(n: usize, x: usize, y: usize) -> usize {\\n    let loop_max = (n - 1) / 2;\\n\\n    let tmp = |x| {\\n        if x <= loop_max {\\n            loop_max - x\\n        } else {\\n            x + loop_max + 1 - n\\n        }\\n    };\\n\\n    let loop_count = tmp(x).max(tmp(y));\\n\\n    let circle_len: fn(usize) -> usize = if n % 2 == 0 {\\n        |x| 8 * x + 4\\n    } else {\\n        |x| if x == 0 { 1 } else { 8 * x }\\n    };\\n\\n    let base = (loop_max - loop_count) * (circle_len(loop_max) + circle_len(loop_count + 1)) / 2;\\n\\n    let current_circle_len = circle_len(loop_count);\\n\\n    let diff = loop_max - loop_count;\\n\\n    let offset = if y == diff {\\n        x - y\\n    } else if x == n - 1 - diff {\\n        current_circle_len / 4 + (y - diff)\\n    } else if y == n - 1 - diff {\\n        3 * current_circle_len / 4 - (x - diff)\\n    } else if x == diff {\\n        current_circle_len - (y - diff)\\n    } else {\\n        unreachable!()\\n    };\\n\\n    base + offset\\n}\\n\\npub fn generate_matrix(n: i32) -> Vec<Vec<i32>> {\\n    if n == 0 {\\n        return vec![];\\n    }\\n    let n = n as usize;\\n    let mut result = vec![Vec::with_capacity(n); n];\\n    for y in 0..n {\\n        for x in 0..n {\\n            result[y].push(spiral(n, x, y) as i32 + 1);\\n        }\\n    }\\n    result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 726326,
                "title": "java-simple-and-easy-to-read",
                "content": "The approach is similar to other ones but I liked how clean my solution looked and thougth I would share! :)\\n\\nTime: O(n) where n is the total number of spaces to fill in the grid\\n```\\npublic int[][] generateMatrix(int n) {\\n        // Go around until im done and while I can\\n        \\n        int total = n*n;\\n        int[][] grid = new int[n][n]; // This will initialize every element with 0\\n        \\n        int i = 1;\\n        int r = 0, c = -1;\\n        while (i <= total) {\\n            // Go right as long as I can aka the next space is 0\\n            while (c < n - 1 && grid[r][c+1] == 0) {\\n                grid[r][++c] = i++;\\n            }\\n            \\n            // Go down\\n            while (r < n - 1 && grid[r+1][c] == 0) {\\n                grid[++r][c] = i++;\\n            }\\n            \\n            // Go left\\n            while (c > 0 && grid[r][c-1] == 0) {\\n                grid[r][--c] = i++;\\n            }\\n            // Go up\\n            while (r > 0 && grid[r-1][c] == 0) {\\n                grid[--r][c] = i++;\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }",
                "solutionTags": [],
                "code": "The approach is similar to other ones but I liked how clean my solution looked and thougth I would share! :)\\n\\nTime: O(n) where n is the total number of spaces to fill in the grid\\n```\\npublic int[][] generateMatrix(int n) {\\n        // Go around until im done and while I can\\n        \\n        int total = n*n;\\n        int[][] grid = new int[n][n]; // This will initialize every element with 0\\n        \\n        int i = 1;\\n        int r = 0, c = -1;\\n        while (i <= total) {\\n            // Go right as long as I can aka the next space is 0\\n            while (c < n - 1 && grid[r][c+1] == 0) {\\n                grid[r][++c] = i++;\\n            }\\n            \\n            // Go down\\n            while (r < n - 1 && grid[r+1][c] == 0) {\\n                grid[++r][c] = i++;\\n            }\\n            \\n            // Go left\\n            while (c > 0 && grid[r][c-1] == 0) {\\n                grid[r][--c] = i++;\\n            }\\n            // Go up\\n            while (r > 0 && grid[r-1][c] == 0) {\\n                grid[--r][c] = i++;\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 547692,
                "title": "short-and-clean-dfs",
                "content": "```\\npublic class Solution \\n{\\n    private int count = 0;\\n    \\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] mat = new int[n][];\\n        \\n        for(int i = 0; i < n; i++)\\n            mat[i] = new int[n];\\n        \\n        DFS(mat, 0, 0, n, Direction.RIGHT);\\n        \\n        return mat;\\n    }\\n    \\n    private void DFS(int[][] mat, int r, int c, int n, Direction direction)\\n    {\\n        if(r < 0 || c < 0 || r > n - 1 || c > n - 1 || mat[r][c] > 0)\\n            return;\\n        \\n        mat[r][c] = ++count;\\n        \\n        switch(direction)\\n        {\\n            case Direction.RIGHT:\\n                DFS(mat, r, c + 1, n, Direction.RIGHT);\\n                DFS(mat, r + 1, c, n, Direction.DOWN);\\n                break;\\n            case Direction.DOWN:\\n                DFS(mat, r + 1, c, n, Direction.DOWN);\\n                DFS(mat, r, c - 1, n, Direction.LEFT);\\n                break;\\n            case Direction.LEFT:\\n                DFS(mat, r, c - 1, n, Direction.LEFT);\\n                DFS(mat, r - 1, c, n, Direction.UP);\\n                break;\\n            case Direction.UP:\\n                DFS(mat, r - 1, c, n, Direction.UP);\\n                DFS(mat, r, c + 1, n, Direction.RIGHT);\\n                break;\\n            default:\\n                break;\\n        }\\n    }\\n}\\n\\npublic enum Direction\\n{\\n    RIGHT,\\n    DOWN,\\n    LEFT,\\n    UP\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution \\n{\\n    private int count = 0;\\n    \\n    public int[][] GenerateMatrix(int n) \\n    {\\n        int[][] mat = new int[n][];\\n        \\n        for(int i = 0; i < n; i++)\\n            mat[i] = new int[n];\\n        \\n        DFS(mat, 0, 0, n, Direction.RIGHT);\\n        \\n        return mat;\\n    }\\n    \\n    private void DFS(int[][] mat, int r, int c, int n, Direction direction)\\n    {\\n        if(r < 0 || c < 0 || r > n - 1 || c > n - 1 || mat[r][c] > 0)\\n            return;\\n        \\n        mat[r][c] = ++count;\\n        \\n        switch(direction)\\n        {\\n            case Direction.RIGHT:\\n                DFS(mat, r, c + 1, n, Direction.RIGHT);\\n                DFS(mat, r + 1, c, n, Direction.DOWN);\\n                break;\\n            case Direction.DOWN:\\n                DFS(mat, r + 1, c, n, Direction.DOWN);\\n                DFS(mat, r, c - 1, n, Direction.LEFT);\\n                break;\\n            case Direction.LEFT:\\n                DFS(mat, r, c - 1, n, Direction.LEFT);\\n                DFS(mat, r - 1, c, n, Direction.UP);\\n                break;\\n            case Direction.UP:\\n                DFS(mat, r - 1, c, n, Direction.UP);\\n                DFS(mat, r, c + 1, n, Direction.RIGHT);\\n                break;\\n            default:\\n                break;\\n        }\\n    }\\n}\\n\\npublic enum Direction\\n{\\n    RIGHT,\\n    DOWN,\\n    LEFT,\\n    UP\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508440,
                "title": "java-my-easy-solution",
                "content": "```\\npublic int[][] generateMatrix(int n) {\\n\\tint sol[][] = new int[n][n], count = 1;\\n\\tint rowMin = 0, colMin = 0, rowMax = n-1, colMax = n-1;\\n\\twhile(rowMin <= rowMax && colMin <= colMax) {\\n\\t\\tfor(int i = colMin; i <= colMax; i++) \\n\\t\\t\\tsol[rowMin][i] = count++;\\n\\t\\trowMin++;\\n\\t\\tfor(int i = rowMin; i <= rowMax; i++) \\n\\t\\t\\tsol[i][colMax] = count++;\\n\\t\\tcolMax--;\\n\\t\\tfor(int i = colMax; i >= colMin; i--)\\n\\t\\t\\tsol[rowMax][i] = count++;\\n\\t\\trowMax--;\\n\\t\\tfor(int i = rowMax; i >= rowMin; i--)\\n\\t\\t\\tsol[i][colMin] = count++;\\n\\t\\tcolMin++;\\n\\t}\\n\\treturn sol;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] generateMatrix(int n) {\\n\\tint sol[][] = new int[n][n], count = 1;\\n\\tint rowMin = 0, colMin = 0, rowMax = n-1, colMax = n-1;\\n\\twhile(rowMin <= rowMax && colMin <= colMax) {\\n\\t\\tfor(int i = colMin; i <= colMax; i++) \\n\\t\\t\\tsol[rowMin][i] = count++;\\n\\t\\trowMin++;\\n\\t\\tfor(int i = rowMin; i <= rowMax; i++) \\n\\t\\t\\tsol[i][colMax] = count++;\\n\\t\\tcolMax--;\\n\\t\\tfor(int i = colMax; i >= colMin; i--)\\n\\t\\t\\tsol[rowMax][i] = count++;\\n\\t\\trowMax--;\\n\\t\\tfor(int i = rowMax; i >= rowMin; i--)\\n\\t\\t\\tsol[i][colMin] = count++;\\n\\t\\tcolMin++;\\n\\t}\\n\\treturn sol;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477625,
                "title": "c",
                "content": "```\\npublic int[][] GenerateMatrix(int n) {\\n      \\n        int[][] result = new int[n][];\\n        for(int i = 0 ; i < result.Length; i++){\\n            result[i] = new int[n];\\n        }\\n        \\n        int count = 1;\\n        int rLowerEnd = 0, rHigherEnd = result.Length - 1;\\n        int cLowerEnd = 0, cHigherEnd = result[0].Length - 1;\\n        \\n        \\n        while (rLowerEnd <= rHigherEnd && cLowerEnd <= cHigherEnd) {\\n            for (int c = cLowerEnd; c <= cHigherEnd; c++) \\n                result[rLowerEnd][c] = count++;\\n            for (int r = rLowerEnd + 1; r <= rHigherEnd; r++) \\n                result[r][cHigherEnd] = count++;\\n            \\n            if (rLowerEnd < rHigherEnd && cLowerEnd < cHigherEnd) {\\n                for (int c = cHigherEnd - 1; c > cLowerEnd; c--) \\n                    result[rHigherEnd][c] = count++;\\n                for (int r = rHigherEnd; r > rLowerEnd; r--) \\n                    result[r][cLowerEnd] = count++;\\n            }\\n            // Move one row down \\n            rLowerEnd++;\\n            // move one row up\\n            rHigherEnd--;\\n            // move one column inside \\n            cLowerEnd++;\\n             // move one column inside \\n            cHigherEnd--;\\n        }        \\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] GenerateMatrix(int n) {\\n      \\n        int[][] result = new int[n][];\\n        for(int i = 0 ; i < result.Length; i++){\\n            result[i] = new int[n];\\n        }\\n        \\n        int count = 1;\\n        int rLowerEnd = 0, rHigherEnd = result.Length - 1;\\n        int cLowerEnd = 0, cHigherEnd = result[0].Length - 1;\\n        \\n        \\n        while (rLowerEnd <= rHigherEnd && cLowerEnd <= cHigherEnd) {\\n            for (int c = cLowerEnd; c <= cHigherEnd; c++) \\n                result[rLowerEnd][c] = count++;\\n            for (int r = rLowerEnd + 1; r <= rHigherEnd; r++) \\n                result[r][cHigherEnd] = count++;\\n            \\n            if (rLowerEnd < rHigherEnd && cLowerEnd < cHigherEnd) {\\n                for (int c = cHigherEnd - 1; c > cLowerEnd; c--) \\n                    result[rHigherEnd][c] = count++;\\n                for (int r = rHigherEnd; r > rLowerEnd; r--) \\n                    result[r][cLowerEnd] = count++;\\n            }\\n            // Move one row down \\n            rLowerEnd++;\\n            // move one row up\\n            rHigherEnd--;\\n            // move one column inside \\n            cLowerEnd++;\\n             // move one column inside \\n            cHigherEnd--;\\n        }        \\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 309040,
                "title": "c-100-beat-using-smart-loops-smart-memories-super-hack-video-rental-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> aResult(n, vector<int>(n));\\n        \\n        int _U = 0, _R = n - 1, _D = n - 1, _L = 0, x = 0, y = 0, VAL = 1;\\n        \\n        while (_L <= _R) {\\n            \\n            x = _L; y = _U;\\n            \\n            //Sweep right across the top.\\n            while (x <= _R) { aResult[y][x++] = VAL++; }\\n            _U += 1; y = _U;\\n            \\n            //Sweep down the right side.\\n            while (y <= _D) { aResult[y++][_R] = VAL++; }\\n            _R -= 1; x = _R;\\n            \\n            //Swipe left across the bottom.\\n            while (x >= _L) { aResult[_D][x--] = VAL++; }\\n            _D -= 1; y = _D;\\n            \\n            //Sweep up the left side.\\n            while (y >= _U) { aResult[y--][_L] = VAL++; }\\n            _L += 1;\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nDecided to try with all the variables being named in terrible ways. I am not sure how you can clock more speed given that the result needs to be a vector of vectors.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> aResult(n, vector<int>(n));\\n        \\n        int _U = 0, _R = n - 1, _D = n - 1, _L = 0, x = 0, y = 0, VAL = 1;\\n        \\n        while (_L <= _R) {\\n            \\n            x = _L; y = _U;\\n            \\n            //Sweep right across the top.\\n            while (x <= _R) { aResult[y][x++] = VAL++; }\\n            _U += 1; y = _U;\\n            \\n            //Sweep down the right side.\\n            while (y <= _D) { aResult[y++][_R] = VAL++; }\\n            _R -= 1; x = _R;\\n            \\n            //Swipe left across the bottom.\\n            while (x >= _L) { aResult[_D][x--] = VAL++; }\\n            _D -= 1; y = _D;\\n            \\n            //Sweep up the left side.\\n            while (y >= _U) { aResult[y--][_L] = VAL++; }\\n            _L += 1;\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285553,
                "title": "java-solution-beating-100-of-java-submissions-in-both-runtime-and-memory-usage",
                "content": "```\\npublic int[][] generateMatrix(int n) {\\n    int[][] rs = new int[n][n];\\n    \\n    int r1 = 0;\\n\\tint r2 = n - 1;\\n\\tint c1 = 0;\\n\\tint c2 = n - 1;\\n\\tint num = 1;\\n\\twhile (r1 <= r2 && c1 <= c2) {\\n\\t\\tfor (int c = c1; c <= c2; c++)\\n\\t\\t\\trs[r1][c] = num++;\\n\\t\\t\\n\\t\\tfor (int r = r1 + 1; r <= r2; r++)\\n\\t\\t\\trs[r][c2] = num++;\\n\\t\\t\\n\\t\\tif (r1 < r2 && c1 < c2) {\\n\\t\\t\\tfor (int c = c2 - 1; c > c1; c--)\\n\\t\\t\\t\\trs[r2][c] = num++;\\n\\t\\t\\t\\n\\t\\t\\tfor (int r = r2; r > r1; r--)\\n\\t\\t\\t\\trs[r][c1] = num++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tr1++;\\n\\t\\tc1++;\\n\\t\\tr2--;\\n\\t\\tc2--;\\n\\t}\\n\\treturn rs;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] generateMatrix(int n) {\\n    int[][] rs = new int[n][n];\\n    \\n    int r1 = 0;\\n\\tint r2 = n - 1;\\n\\tint c1 = 0;\\n\\tint c2 = n - 1;\\n\\tint num = 1;\\n\\twhile (r1 <= r2 && c1 <= c2) {\\n\\t\\tfor (int c = c1; c <= c2; c++)\\n\\t\\t\\trs[r1][c] = num++;\\n\\t\\t\\n\\t\\tfor (int r = r1 + 1; r <= r2; r++)\\n\\t\\t\\trs[r][c2] = num++;\\n\\t\\t\\n\\t\\tif (r1 < r2 && c1 < c2) {\\n\\t\\t\\tfor (int c = c2 - 1; c > c1; c--)\\n\\t\\t\\t\\trs[r2][c] = num++;\\n\\t\\t\\t\\n\\t\\t\\tfor (int r = r2; r > r1; r--)\\n\\t\\t\\t\\trs[r][c1] = num++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tr1++;\\n\\t\\tc1++;\\n\\t\\tr2--;\\n\\t\\tc2--;\\n\\t}\\n\\treturn rs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 131432,
                "title": "simple-javascript-solution-beating-100",
                "content": "```\\nvar generateMatrix = function(n) {\\n    let square = Array(n).fill(0).map(el => Array(n).fill(0));\\n    let count, row, col;\\n    count = row = col = 0;\\n    while (count < n * n) {\\n        while (square[row][col] === 0) {\\n            square[row][col++] = ++count;\\n        }\\n        col--;\\n        row++;\\n        while (square[row] && square[row][col] === 0) {\\n            square[row++][col] = ++count;\\n        }\\n        row--;\\n        col--;\\n        while (square[row][col] === 0) {\\n            square[row][col--] = ++count;\\n        }\\n        col++;\\n        row--;\\n        while (square[row] && square[row][col] === 0) {\\n            square[row--][col] = ++count;\\n        }\\n        row++;\\n        col++;\\n    }\\n    return square;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar generateMatrix = function(n) {\\n    let square = Array(n).fill(0).map(el => Array(n).fill(0));\\n    let count, row, col;\\n    count = row = col = 0;\\n    while (count < n * n) {\\n        while (square[row][col] === 0) {\\n            square[row][col++] = ++count;\\n        }\\n        col--;\\n        row++;\\n        while (square[row] && square[row][col] === 0) {\\n            square[row++][col] = ++count;\\n        }\\n        row--;\\n        col--;\\n        while (square[row][col] === 0) {\\n            square[row][col--] = ++count;\\n        }\\n        col++;\\n        row--;\\n        while (square[row] && square[row][col] === 0) {\\n            square[row--][col] = ++count;\\n        }\\n        row++;\\n        col++;\\n    }\\n    return square;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22322,
                "title": "golang-3-ms",
                "content": "```\\nfunc generateMatrix(n int) [][]int {\\n        matrix := make([][]int, n)\\n        for i := range matrix {\\n            matrix[i] = make([]int, n)\\n        }\\n        \\n        if n==0 {\\n            return matrix\\n        }\\n        \\n        rowStart := 0\\n        rowEnd := n - 1\\n        colStart := 0\\n        colEnd := n - 1\\n        num := 1\\n        \\n        for rowStart <= rowEnd && colStart <= colEnd {\\n            for i := colStart; i <= colEnd; i++ {\\n                matrix[rowStart][i] = num\\n                num++\\n            }\\n            rowStart++\\n            \\n            for i := rowStart;i<=rowEnd; i++ {\\n                matrix[i][colEnd] = num\\n                num++\\n            }\\n            colEnd--\\n            for  i:= colEnd; i >= colStart; i-- {\\n                if rowStart <= rowEnd {\\n                    matrix[rowEnd][i] = num\\n                    num++\\n                }\\n            }\\n            rowEnd--\\n            for  i:= rowEnd; i >= rowStart; i-- {\\n                if colStart <= colEnd {\\n                    matrix[i][colStart] = num\\n                    num++\\n                }\\n            }\\n            colStart++\\n        }\\n        return matrix\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc generateMatrix(n int) [][]int {\\n        matrix := make([][]int, n)\\n        for i := range matrix {\\n            matrix[i] = make([]int, n)\\n        }\\n        \\n        if n==0 {\\n            return matrix\\n        }\\n        \\n        rowStart := 0\\n        rowEnd := n - 1\\n        colStart := 0\\n        colEnd := n - 1\\n        num := 1\\n        \\n        for rowStart <= rowEnd && colStart <= colEnd {\\n            for i := colStart; i <= colEnd; i++ {\\n                matrix[rowStart][i] = num\\n                num++\\n            }\\n            rowStart++\\n            \\n            for i := rowStart;i<=rowEnd; i++ {\\n                matrix[i][colEnd] = num\\n                num++\\n            }\\n            colEnd--\\n            for  i:= colEnd; i >= colStart; i-- {\\n                if rowStart <= rowEnd {\\n                    matrix[rowEnd][i] = num\\n                    num++\\n                }\\n            }\\n            rowEnd--\\n            for  i:= rowEnd; i >= rowStart; i-- {\\n                if colStart <= colEnd {\\n                    matrix[i][colStart] = num\\n                    num++\\n                }\\n            }\\n            colStart++\\n        }\\n        return matrix\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050368,
                "title": "spiral-matrix-ii-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n\\n        int startingRow=0;\\n        int endingRow=n-1;\\n        int startingCol=0;\\n        int endingCol=n-1;\\n        int k=1;\\n        int last=n*n;\\n    while(k<=last){\\n        for(int i=startingCol;k<=last,i<=endingCol;i++){\\n            mat[startingRow][i]=k++;\\n        }\\n        startingRow++;\\n        for(int i=startingRow;k<=last,i<=endingRow;i++){\\n            mat[i][endingCol]=k++;\\n        }\\n\\n        endingCol--;\\n        for(int i=endingCol;k<=last,i>=startingCol;i--){\\n            mat[endingRow][i]=k++;\\n        }\\n        endingRow--;\\n        for(int i=endingRow;k<=last, i>=startingRow;i--){\\n            mat[i][startingCol]=k++;\\n        }\\n        startingCol++;\\n     }\\n     return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n\\n        int startingRow=0;\\n        int endingRow=n-1;\\n        int startingCol=0;\\n        int endingCol=n-1;\\n        int k=1;\\n        int last=n*n;\\n    while(k<=last){\\n        for(int i=startingCol;k<=last,i<=endingCol;i++){\\n            mat[startingRow][i]=k++;\\n        }\\n        startingRow++;\\n        for(int i=startingRow;k<=last,i<=endingRow;i++){\\n            mat[i][endingCol]=k++;\\n        }\\n\\n        endingCol--;\\n        for(int i=endingCol;k<=last,i>=startingCol;i--){\\n            mat[endingRow][i]=k++;\\n        }\\n        endingRow--;\\n        for(int i=endingRow;k<=last, i>=startingRow;i--){\\n            mat[i][startingCol]=k++;\\n        }\\n        startingCol++;\\n     }\\n     return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757828,
                "title": "spiral-matrix-ii-o-m-n-javascript-memory-95-45-meaningful-vars",
                "content": "```\\nfunction getNeighbors(array, rowIndex, columnIndex, storage) {\\n    const neighbors = {};\\n    if (\\n        array[rowIndex] &&\\n        array[rowIndex][columnIndex + 1] !== undefined &&\\n        !storage[`${rowIndex}_${columnIndex + 1}`]\\n    ) {\\n        neighbors.right = { rowIndex: rowIndex, columnIndex: columnIndex + 1 };\\n    }\\n\\n    if (\\n        array[rowIndex] &&\\n        array[rowIndex][columnIndex - 1] !== undefined &&\\n        !storage[`${rowIndex}_${columnIndex - 1}`]\\n    ) {\\n        neighbors.left = { rowIndex: rowIndex, columnIndex: columnIndex - 1 };\\n    }\\n    if (\\n        array[rowIndex + 1] &&\\n        array[rowIndex + 1][columnIndex] !== undefined &&\\n        !storage[`${rowIndex + 1}_${columnIndex}`]\\n    ) {\\n        neighbors.down = { rowIndex: rowIndex + 1, columnIndex: columnIndex };\\n    }\\n    if (\\n        array[rowIndex - 1] &&\\n        array[rowIndex - 1][columnIndex] !== undefined &&\\n        !storage[`${rowIndex - 1}_${columnIndex}`]\\n    ) {\\n        neighbors.up = { rowIndex: rowIndex - 1, columnIndex: columnIndex };\\n    }\\n    return neighbors;\\n}\\n\\nvar generateMatrix = function(size) {\\n    const output = [];\\n    const storage = {};\\n    let count = 2;\\n    let movement = `row`;\\n    let rowIndex = 0;\\n    let columnIndex = 0;\\n    let tempSize = size * size;\\n    for (let rowIndex = 0; rowIndex < size; rowIndex++) {\\n        output[rowIndex] = [];\\n        for (let columnIndex = 0; columnIndex < size; columnIndex++) {\\n            output[rowIndex][columnIndex] = 1;\\n        }\\n    }\\n    while (tempSize--) {\\n        storage[`${rowIndex}_${columnIndex}`] = true;\\n        const neighbors = getNeighbors(output, rowIndex, columnIndex, storage);\\n        if (Object.keys(neighbors).length === 0) {\\n            break;\\n        }\\n        if (Object.keys(neighbors).length === 1) {\\n            if (neighbors.right) {\\n                rowIndex = neighbors.right.rowIndex;\\n                columnIndex = neighbors.right.columnIndex;\\n                if (!output[neighbors.right.columnIndex]) {\\n                    output[neighbors.right.columnIndex] = [];\\n                }\\n                output[neighbors.right.rowIndex][neighbors.right.columnIndex] = count++;\\n                movement = `row`;\\n            } else if (neighbors.left) {\\n                rowIndex = neighbors.left.rowIndex;\\n                columnIndex = neighbors.left.columnIndex;\\n                if (!output[neighbors.left.columnIndex]) {\\n                    output[neighbors.left.columnIndex] = [];\\n                }\\n                output[neighbors.left.rowIndex][neighbors.left.columnIndex] = count++;\\n                movement = `row`;\\n            } else if (neighbors.down) {\\n                rowIndex = neighbors.down.rowIndex;\\n                columnIndex = neighbors.down.columnIndex;\\n                if (!output[neighbors.down.columnIndex]) {\\n                    output[neighbors.down.columnIndex] = [];\\n                }\\n                output[neighbors.down.rowIndex][neighbors.down.columnIndex] = count++;\\n                movement = `column`;\\n            } else {\\n                rowIndex = neighbors.up.rowIndex;\\n                columnIndex = neighbors.up.columnIndex;\\n                if (!output[neighbors.up.columnIndex]) {\\n                    output[neighbors.up.columnIndex] = [];\\n                }\\n                output[neighbors.up.rowIndex][neighbors.up.columnIndex] = count++;\\n                movement = `column`;\\n            }\\n        } else {\\n            if (movement === `row`) {\\n                if (neighbors.right) {\\n                    rowIndex = neighbors.right.rowIndex;\\n                    columnIndex = neighbors.right.columnIndex;\\n                    if (!output[neighbors.right.columnIndex]) {\\n                        output[neighbors.right.columnIndex] = [];\\n                    }\\n                    output[neighbors.right.rowIndex][neighbors.right.columnIndex] = count++;\\n                } else {\\n                    rowIndex = neighbors.left.rowIndex;\\n                    columnIndex = neighbors.left.columnIndex;\\n                    if (!output[neighbors.left.columnIndex]) {\\n                        output[neighbors.left.columnIndex] = [];\\n                    }\\n                    output[neighbors.left.rowIndex][neighbors.left.columnIndex] = count++;\\n                }\\n            } else {\\n                if (neighbors.up) {\\n                    rowIndex = neighbors.up.rowIndex;\\n                    columnIndex = neighbors.up.columnIndex;\\n                    if (!output[neighbors.up.columnIndex]) {\\n                        output[neighbors.up.columnIndex] = [];\\n                    }\\n                    output[neighbors.up.rowIndex][neighbors.up.columnIndex] = count++;\\n                } else {\\n                    rowIndex = neighbors.down.rowIndex;\\n                    columnIndex = neighbors.down.columnIndex;\\n                    if (!output[neighbors.down.columnIndex]) {\\n                        output[neighbors.down.columnIndex] = [];\\n                    }\\n                    output[neighbors.down.rowIndex][neighbors.down.columnIndex] = count++;\\n                }\\n            }\\n        }\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction getNeighbors(array, rowIndex, columnIndex, storage) {\\n    const neighbors = {};\\n    if (\\n        array[rowIndex] &&\\n        array[rowIndex][columnIndex + 1] !== undefined &&\\n        !storage[`${rowIndex}_${columnIndex + 1}`]\\n    ) {\\n        neighbors.right = { rowIndex: rowIndex, columnIndex: columnIndex + 1 };\\n    }\\n\\n    if (\\n        array[rowIndex] &&\\n        array[rowIndex][columnIndex - 1] !== undefined &&\\n        !storage[`${rowIndex}_${columnIndex - 1}`]\\n    ) {\\n        neighbors.left = { rowIndex: rowIndex, columnIndex: columnIndex - 1 };\\n    }\\n    if (\\n        array[rowIndex + 1] &&\\n        array[rowIndex + 1][columnIndex] !== undefined &&\\n        !storage[`${rowIndex + 1}_${columnIndex}`]\\n    ) {\\n        neighbors.down = { rowIndex: rowIndex + 1, columnIndex: columnIndex };\\n    }\\n    if (\\n        array[rowIndex - 1] &&\\n        array[rowIndex - 1][columnIndex] !== undefined &&\\n        !storage[`${rowIndex - 1}_${columnIndex}`]\\n    ) {\\n        neighbors.up = { rowIndex: rowIndex - 1, columnIndex: columnIndex };\\n    }\\n    return neighbors;\\n}\\n\\nvar generateMatrix = function(size) {\\n    const output = [];\\n    const storage = {};\\n    let count = 2;\\n    let movement = `row`;\\n    let rowIndex = 0;\\n    let columnIndex = 0;\\n    let tempSize = size * size;\\n    for (let rowIndex = 0; rowIndex < size; rowIndex++) {\\n        output[rowIndex] = [];\\n        for (let columnIndex = 0; columnIndex < size; columnIndex++) {\\n            output[rowIndex][columnIndex] = 1;\\n        }\\n    }\\n    while (tempSize--) {\\n        storage[`${rowIndex}_${columnIndex}`] = true;\\n        const neighbors = getNeighbors(output, rowIndex, columnIndex, storage);\\n        if (Object.keys(neighbors).length === 0) {\\n            break;\\n        }\\n        if (Object.keys(neighbors).length === 1) {\\n            if (neighbors.right) {\\n                rowIndex = neighbors.right.rowIndex;\\n                columnIndex = neighbors.right.columnIndex;\\n                if (!output[neighbors.right.columnIndex]) {\\n                    output[neighbors.right.columnIndex] = [];\\n                }\\n                output[neighbors.right.rowIndex][neighbors.right.columnIndex] = count++;\\n                movement = `row`;\\n            } else if (neighbors.left) {\\n                rowIndex = neighbors.left.rowIndex;\\n                columnIndex = neighbors.left.columnIndex;\\n                if (!output[neighbors.left.columnIndex]) {\\n                    output[neighbors.left.columnIndex] = [];\\n                }\\n                output[neighbors.left.rowIndex][neighbors.left.columnIndex] = count++;\\n                movement = `row`;\\n            } else if (neighbors.down) {\\n                rowIndex = neighbors.down.rowIndex;\\n                columnIndex = neighbors.down.columnIndex;\\n                if (!output[neighbors.down.columnIndex]) {\\n                    output[neighbors.down.columnIndex] = [];\\n                }\\n                output[neighbors.down.rowIndex][neighbors.down.columnIndex] = count++;\\n                movement = `column`;\\n            } else {\\n                rowIndex = neighbors.up.rowIndex;\\n                columnIndex = neighbors.up.columnIndex;\\n                if (!output[neighbors.up.columnIndex]) {\\n                    output[neighbors.up.columnIndex] = [];\\n                }\\n                output[neighbors.up.rowIndex][neighbors.up.columnIndex] = count++;\\n                movement = `column`;\\n            }\\n        } else {\\n            if (movement === `row`) {\\n                if (neighbors.right) {\\n                    rowIndex = neighbors.right.rowIndex;\\n                    columnIndex = neighbors.right.columnIndex;\\n                    if (!output[neighbors.right.columnIndex]) {\\n                        output[neighbors.right.columnIndex] = [];\\n                    }\\n                    output[neighbors.right.rowIndex][neighbors.right.columnIndex] = count++;\\n                } else {\\n                    rowIndex = neighbors.left.rowIndex;\\n                    columnIndex = neighbors.left.columnIndex;\\n                    if (!output[neighbors.left.columnIndex]) {\\n                        output[neighbors.left.columnIndex] = [];\\n                    }\\n                    output[neighbors.left.rowIndex][neighbors.left.columnIndex] = count++;\\n                }\\n            } else {\\n                if (neighbors.up) {\\n                    rowIndex = neighbors.up.rowIndex;\\n                    columnIndex = neighbors.up.columnIndex;\\n                    if (!output[neighbors.up.columnIndex]) {\\n                        output[neighbors.up.columnIndex] = [];\\n                    }\\n                    output[neighbors.up.rowIndex][neighbors.up.columnIndex] = count++;\\n                } else {\\n                    rowIndex = neighbors.down.rowIndex;\\n                    columnIndex = neighbors.down.columnIndex;\\n                    if (!output[neighbors.down.columnIndex]) {\\n                        output[neighbors.down.columnIndex] = [];\\n                    }\\n                    output[neighbors.down.rowIndex][neighbors.down.columnIndex] = count++;\\n                }\\n            }\\n        }\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3692221,
                "title": "easiest-c-solution-faster-than-100",
                "content": "vector<vector<int>> generateMatrix(int n) {\\n     vector<vector<int>> ans(n,vector<int>(n));\\n        int sr=0;\\n        int sc=0;\\n        int er=n-1;\\n        int ec =n-1;\\n        int c=1;\\n        while(sr<=er && sc<=ec){\\n        for(int i=sc;i<=ec;i++ ){\\n          ans[sr][i]= c;\\n            c++;\\n        }\\n        sr++;\\n    for(int i=sr;i<=er;i++ ){\\n          ans[i][ec]= c;\\n            c++;\\n        }\\n        ec--;\\n    for(int i=ec;i>=sc;i-- ){\\n          ans[er][i]= c;\\n            c++;\\n        }\\n        er--;\\n      for(int i=er;i>=sr;i-- ){\\n          ans[i][sc]= c;\\n            c++;\\n        }\\n        sc++; \\n    }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "vector<vector<int>> generateMatrix(int n) {\\n     vector<vector<int>> ans(n,vector<int>(n));\\n        int sr=0;\\n        int sc=0;\\n        int er=n-1;\\n        int ec =n-1;\\n        int c=1;\\n        while(sr<=er && sc<=ec){\\n        for(int i=sc;i<=ec;i++ ){\\n          ans[sr][i]= c;\\n            c++;\\n        }\\n        sr++;\\n    for(int i=sr;i<=er;i++ ){\\n          ans[i][ec]= c;\\n            c++;\\n        }\\n        ec--;\\n    for(int i=ec;i>=sc;i-- ){\\n          ans[er][i]= c;\\n            c++;\\n        }\\n        er--;\\n      for(int i=er;i>=sr;i-- ){\\n          ans[i][sc]= c;\\n            c++;\\n        }\\n        sc++; \\n    }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3524776,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        // creating a vector of n*n\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        \\n        //int row=matrix.size();\\n        //int col =matrix[0].size();\\n        int count =0;\\n        int total =n*n;\\n        \\n        //// all index \\n        \\n        int startingrow=0;\\n        int startingcol=0;\\n        int endingrow=n-1;\\n        int endingcol=n-1;\\n        \\n        while(count<total)\\n        {\\n            for(int i=startingcol;count<total && i<=endingcol; i++)\\n            {\\n                count++;\\n                ans[startingrow][i]=count;\\n                \\n            }\\n            startingrow++;\\n            \\n            for(int i=startingrow;count<total && i<=endingrow; i++)\\n            {\\n            \\n                count++;\\n                ans[i][endingcol]=count;\\n            }\\n            endingcol--;\\n            \\n            for(int i=endingcol;count<total && i>=startingcol; i--)\\n            {\\n                 count++;\\n                ans[endingrow][i]=count;\\n            }\\n            endingrow--;\\n            \\n            for(int i=endingrow;count<total && i>=startingrow; i--)\\n            {\\n                 count++;\\n                ans[i][startingcol]=count;\\n            \\n            }\\n            startingcol++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        // creating a vector of n*n\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        \\n        //int row=matrix.size();\\n        //int col =matrix[0].size();\\n        int count =0;\\n        int total =n*n;\\n        \\n        //// all index \\n        \\n        int startingrow=0;\\n        int startingcol=0;\\n        int endingrow=n-1;\\n        int endingcol=n-1;\\n        \\n        while(count<total)\\n        {\\n            for(int i=startingcol;count<total && i<=endingcol; i++)\\n            {\\n                count++;\\n                ans[startingrow][i]=count;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3509821,
                "title": "java-super-easy-to-understand-code-with-comments",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        //create a matrix of nxn size\\n        int[][] arr  = new int[n][n];\\n        //Initialized variables \\n        int top = 0 , bottom = n-1;\\n        int left = 0 , right = n-1;\\n        //Maintain counter to add elements in matrix \\n        int cnt =1;\\n        while(left <=  right && top<=bottom){\\n            //traverse left to right\\n            for (int i = left; i <= right; i++) {\\n                arr[top][i] = cnt++;\\n            }\\n            top++;\\n            //traverse top to bottom\\n            for(int i = top; i<=bottom;i++){\\n                arr[i][right] = cnt++;\\n            }\\n            right--;\\n            //traverse right to left\\n            if(top<=bottom){\\n                for (int i = right; i >=left; i--) {\\n                    arr[bottom][i] = cnt++;\\n                }\\n            }\\n            bottom--;\\n            //traverse bottom to top\\n            if(left<=right){\\n                for (int i = bottom; i >=top ; i--) {\\n                    arr[i][left] = cnt++;\\n                }\\n            }\\n            left++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        //create a matrix of nxn size\\n        int[][] arr  = new int[n][n];\\n        //Initialized variables \\n        int top = 0 , bottom = n-1;\\n        int left = 0 , right = n-1;\\n        //Maintain counter to add elements in matrix \\n        int cnt =1;\\n        while(left <=  right && top<=bottom){\\n            //traverse left to right\\n            for (int i = left; i <= right; i++) {\\n                arr[top][i] = cnt++;\\n            }\\n            top++;\\n            //traverse top to bottom\\n            for(int i = top; i<=bottom;i++){\\n                arr[i][right] = cnt++;\\n            }\\n            right--;\\n            //traverse right to left\\n            if(top<=bottom){\\n                for (int i = right; i >=left; i--) {\\n                    arr[bottom][i] = cnt++;\\n                }\\n            }\\n            bottom--;\\n            //traverse bottom to top\\n            if(left<=right){\\n                for (int i = bottom; i >=top ; i--) {\\n                    arr[i][left] = cnt++;\\n                }\\n            }\\n            left++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509654,
                "title": "easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n\\xB2)\\n\\n- Space complexity:\\nO(n\\xB2)\\n\\n# Code\\n```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {    \\n        var matrix = [[Int]](repeating: [Int](repeating: 0, count: n), count: n) \\n        var top = 0, bottom = n - 1\\n        var left = 0, right = n - 1\\n        var num = 1\\n        while top <= bottom && left <= right {\\n            for i in stride(from: left, to: right + 1, by: 1) {\\n                matrix[top][i] = num\\n                num += 1\\n            }\\n            top += 1\\n            \\n            for i in stride(from: top, to: bottom + 1, by: 1) {\\n                matrix[i][right] = num\\n                num += 1\\n            }\\n            right -= 1\\n            \\n            if top <= bottom {\\n                for i in stride(from: right, to: left - 1, by: -1) {\\n                    matrix[bottom][i] = num\\n                    num += 1\\n                }\\n            }\\n            bottom -= 1\\n            \\n            if left <= right {\\n                for i in stride(from: bottom, to: top - 1, by: -1) {\\n                    matrix[i][left] = num \\n                    num += 1\\n                }\\n            }\\n            left += 1\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func generateMatrix(_ n: Int) -> [[Int]] {    \\n        var matrix = [[Int]](repeating: [Int](repeating: 0, count: n), count: n) \\n        var top = 0, bottom = n - 1\\n        var left = 0, right = n - 1\\n        var num = 1\\n        while top <= bottom && left <= right {\\n            for i in stride(from: left, to: right + 1, by: 1) {\\n                matrix[top][i] = num\\n                num += 1\\n            }\\n            top += 1\\n            \\n            for i in stride(from: top, to: bottom + 1, by: 1) {\\n                matrix[i][right] = num\\n                num += 1\\n            }\\n            right -= 1\\n            \\n            if top <= bottom {\\n                for i in stride(from: right, to: left - 1, by: -1) {\\n                    matrix[bottom][i] = num\\n                    num += 1\\n                }\\n            }\\n            bottom -= 1\\n            \\n            if left <= right {\\n                for i in stride(from: bottom, to: top - 1, by: -1) {\\n                    matrix[i][left] = num \\n                    num += 1\\n                }\\n            }\\n            left += 1\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508767,
                "title": "java-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int [][] arr = new int[n][n];\\n        int size = 1;\\n        int rs=0, re=n-1, cs=0, ce=n-1;\\n        while(size <= n*n){\\n            for(int i=cs; i<=ce; i++){\\n                arr[rs][i] = size++;\\n            }\\n            rs++;\\n            for(int i=rs; i<=re; i++){\\n                arr[i][ce] = size++;\\n            }\\n            ce--;\\n            if(rs<=re){\\n                for(int i=ce; i>=cs; i--){\\n                    arr[re][i] = size++;\\n                }\\n                re--;\\n            }\\n            if(cs<=ce){\\n                for(int i=re; i>=rs; i--){\\n                    arr[i][cs] = size++;\\n                }\\n                cs++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int [][] arr = new int[n][n];\\n        int size = 1;\\n        int rs=0, re=n-1, cs=0, ce=n-1;\\n        while(size <= n*n){\\n            for(int i=cs; i<=ce; i++){\\n                arr[rs][i] = size++;\\n            }\\n            rs++;\\n            for(int i=rs; i<=re; i++){\\n                arr[i][ce] = size++;\\n            }\\n            ce--;\\n            if(rs<=re){\\n                for(int i=ce; i>=cs; i--){\\n                    arr[re][i] = size++;\\n                }\\n                re--;\\n            }\\n            if(cs<=ce){\\n                for(int i=re; i>=rs; i--){\\n                    arr[i][cs] = size++;\\n                }\\n                cs++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508582,
                "title": "c-simulation-solution-with-optimized-time-complexity",
                "content": "\\n\\n# Approach\\nThe given solution uses a simulation approach, where we keep track of the boundaries of the matrix using four variables: rowBegin, rowEnd, colBegin, and colEnd. We initialize these variables to 0 and n-1, as the first row and column are the boundaries of the matrix.\\n\\nWe then use a while loop to traverse the matrix in a spiral order. In each iteration of the loop, we traverse the matrix in four directions: right, down, left, and up. We use four for loops for this purpose, each of which increments or decrements one of the boundary variables, depending on the direction of traversal.\\n\\nAs we traverse the matrix, we fill in the elements with the values from 1 to n^2 in the order specified by the problem. We use a variable num to keep track of the value to be filled in each element. We increment this variable after each element is filled.\\n\\nOnce we have filled in all the elements of the matrix, we return the matrix as the final output.\\n\\n# Complexity\\n- Time complexity:\\n O(n^2) because we need to fill all n^2 elements of the matrix\\n\\n- Space complexity:\\nO(n^2) because we need to store the entire matrix.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        int rowBegin = 0, rowEnd = n-1, colBegin = 0, colEnd = n-1;\\n        int num = 1;\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            // traverse right\\n            for (int i = colBegin; i <= colEnd; ++i) {\\n                matrix[rowBegin][i] = num++;\\n            }\\n            ++rowBegin;\\n            \\n            // traverse down\\n            for (int i = rowBegin; i <= rowEnd; ++i) {\\n                matrix[i][colEnd] = num++;\\n            }\\n            --colEnd;\\n            \\n            // traverse left\\n            if (rowBegin <= rowEnd) {\\n                for (int i = colEnd; i >= colBegin; --i) {\\n                    matrix[rowEnd][i] = num++;\\n                }\\n            }\\n            --rowEnd;\\n            \\n            // traverse up\\n            if (colBegin <= colEnd) {\\n                for (int i = rowEnd; i >= rowBegin; --i) {\\n                    matrix[i][colBegin] = num++;\\n                }\\n            }\\n            ++colBegin;\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int>(n));\\n        int rowBegin = 0, rowEnd = n-1, colBegin = 0, colEnd = n-1;\\n        int num = 1;\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            // traverse right\\n            for (int i = colBegin; i <= colEnd; ++i) {\\n                matrix[rowBegin][i] = num++;\\n            }\\n            ++rowBegin;\\n            \\n            // traverse down\\n            for (int i = rowBegin; i <= rowEnd; ++i) {\\n                matrix[i][colEnd] = num++;\\n            }\\n            --colEnd;\\n            \\n            // traverse left\\n            if (rowBegin <= rowEnd) {\\n                for (int i = colEnd; i >= colBegin; --i) {\\n                    matrix[rowEnd][i] = num++;\\n                }\\n            }\\n            --rowEnd;\\n            \\n            // traverse up\\n            if (colBegin <= colEnd) {\\n                for (int i = rowEnd; i >= rowBegin; --i) {\\n                    matrix[i][colBegin] = num++;\\n                }\\n            }\\n            ++colBegin;\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507935,
                "title": "beats-100-c",
                "content": "![image.png](https://assets.leetcode.com/users/images/9885d1be-a40b-42c1-87b9-34306fc0e161_1683707490.7883291.png)\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n));\\n        int data=1;\\n        int top=0,bottom=n-1,left=0,right=n-1;\\n        while(left<=right && top<=bottom)\\n        {\\n            for(int i=left;i<=right;i++) {\\n                ans[top][i] = data++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++) {\\n                ans[i][right] = data++;\\n            }\\n            right--;\\n            if(top <= bottom) {\\n                for(int i=right;i>=left;i--) {\\n                    ans[bottom][i] = data++;\\n                }\\n                bottom--;\\n            }\\n            if(left<=right) {\\n                for(int i=bottom;i>=top;i--) {\\n                    ans[i][left] = data++;\\n                }\\n                left++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n));\\n        int data=1;\\n        int top=0,bottom=n-1,left=0,right=n-1;\\n        while(left<=right && top<=bottom)\\n        {\\n            for(int i=left;i<=right;i++) {\\n                ans[top][i] = data++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++) {\\n                ans[i][right] = data++;\\n            }\\n            right--;\\n            if(top <= bottom) {\\n                for(int i=right;i>=left;i--) {\\n                    ans[bottom][i] = data++;\\n                }\\n                bottom--;\\n            }\\n            if(left<=right) {\\n                for(int i=bottom;i>=top;i--) {\\n                    ans[i][left] = data++;\\n                }\\n                left++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507661,
                "title": "java-easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int top=0,bottom=n-1,left=0,right=n-1;\\n        int[][] ans = new int[n][n];\\n        int count=0;\\n        if(bottom==0){\\n            for(int i=left;i<=right;i++){\\n                count++;\\n                ans[bottom][i]=count;\\n            }\\n            return ans;\\n        }\\n        if(right==0){\\n            for(int j=top;j<=bottom;j++){\\n                count++;\\n                ans[j][right]=count;\\n            }\\n            return ans;\\n        }\\n        while(top<=bottom && left <=right){\\n            for(int i=left;i<=right;i++){\\n                count++;\\n                ans[top][i]=count;\\n            }\\n            top++;\\n\\n            for(int j=top;j<=bottom;j++){\\n                count++;\\n                ans[j][right]=count;\\n            }\\n            right--;\\n\\n            for(int k=right;k>=left;k--){\\n                count++;\\n                ans[bottom][k]=count;\\n            }\\n            bottom--;\\n\\n            for(int a=bottom;a>=top;a--){\\n                count++;\\n                ans[a][left]=count;\\n            }\\n            left++;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int top=0,bottom=n-1,left=0,right=n-1;\\n        int[][] ans = new int[n][n];\\n        int count=0;\\n        if(bottom==0){\\n            for(int i=left;i<=right;i++){\\n                count++;\\n                ans[bottom][i]=count;\\n            }\\n            return ans;\\n        }\\n        if(right==0){\\n            for(int j=top;j<=bottom;j++){\\n                count++;\\n                ans[j][right]=count;\\n            }\\n            return ans;\\n        }\\n        while(top<=bottom && left <=right){\\n            for(int i=left;i<=right;i++){\\n                count++;\\n                ans[top][i]=count;\\n            }\\n            top++;\\n\\n            for(int j=top;j<=bottom;j++){\\n                count++;\\n                ans[j][right]=count;\\n            }\\n            right--;\\n\\n            for(int k=right;k>=left;k--){\\n                count++;\\n                ans[bottom][k]=count;\\n            }\\n            bottom--;\\n\\n            for(int a=bottom;a>=top;a--){\\n                count++;\\n                ans[a][left]=count;\\n            }\\n            left++;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507492,
                "title": "my-java-o-n-2-solution-beats-100-of-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA simple and effective solution to create a matrix of size n x n with elements 1 to n^2 in a spiral order is to initialize the matrix with all zeros and then fill in the elements in the desired order by iterating through the matrix in a spiral pattern.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by initializing a 2D matrix of size n x n with all zeros. We then define four variables: rowStart, rowEnd, colStart, and colEnd, which represent the starting and ending indices for the rows and columns that we need to fill in. We also define a variable num, which represents the current number we want to fill in the matrix.\\n\\nWe then use a while loop to iterate through the matrix in a spiral pattern. In each iteration of the loop, we fill in the elements in the current row and column that we need to fill in. We then update the corresponding rowStart, rowEnd, colStart, and colEnd variables to reflect the fact that we have filled in those rows and columns.\\n\\nWe continue this process until we have filled in all the elements in the matrix in the desired order.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\nThe time complexity of this solution is O(n^2) because it needs to fill in every cell of the n x n matrix. The while loop runs exactly n/2 times, and each iteration fills in 4 rows or columns, which takes O(n) time. Therefore, the total time complexity is O(n/2 * 4n) = O(n^2).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n\\nThe space complexity of this solution is O(n^2) because the program needs to create an n x n matrix to store the result. No additional data structures are used, and the space required for the loop variables and integer counters is negligible compared to the size of the matrix.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] generateMatrix(int n) {\\n        // Declaration\\n        int[][] matrix = new int[n][n];\\n        \\n        // Edge Case\\n        if (n == 0) {\\n            return matrix;\\n        }\\n        \\n        // Normal Case\\n        int rowStart = 0;\\n        int rowEnd = n-1;\\n        int colStart = 0;\\n        int colEnd = n-1;\\n        int num = 1; //change\\n        \\n        while (rowStart <= rowEnd && colStart <= colEnd) {\\n            for (int i = colStart; i <= colEnd; i ++) {\\n                matrix[rowStart][i] = num ++; //change\\n            }\\n            rowStart ++;\\n            \\n            for (int i = rowStart; i <= rowEnd; i ++) {\\n                matrix[i][colEnd] = num ++; //change\\n            }\\n            colEnd --;\\n            \\n            for (int i = colEnd; i >= colStart; i --) {\\n                if (rowStart <= rowEnd)\\n                    matrix[rowEnd][i] = num ++; //change\\n            }\\n            rowEnd --;\\n            \\n            for (int i = rowEnd; i >= rowStart; i --) {\\n                if (colStart <= colEnd)\\n                    matrix[i][colStart] = num ++; //change\\n            }\\n            colStart ++;\\n        }\\n        \\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] generateMatrix(int n) {\\n        // Declaration\\n        int[][] matrix = new int[n][n];\\n        \\n        // Edge Case\\n        if (n == 0) {\\n            return matrix;\\n        }\\n        \\n        // Normal Case\\n        int rowStart = 0;\\n        int rowEnd = n-1;\\n        int colStart = 0;\\n        int colEnd = n-1;\\n        int num = 1; //change\\n        \\n        while (rowStart <= rowEnd && colStart <= colEnd) {\\n            for (int i = colStart; i <= colEnd; i ++) {\\n                matrix[rowStart][i] = num ++; //change\\n            }\\n            rowStart ++;\\n            \\n            for (int i = rowStart; i <= rowEnd; i ++) {\\n                matrix[i][colEnd] = num ++; //change\\n            }\\n            colEnd --;\\n            \\n            for (int i = colEnd; i >= colStart; i --) {\\n                if (rowStart <= rowEnd)\\n                    matrix[rowEnd][i] = num ++; //change\\n            }\\n            rowEnd --;\\n            \\n            for (int i = rowEnd; i >= rowStart; i --) {\\n                if (colStart <= colEnd)\\n                    matrix[i][colStart] = num ++; //change\\n            }\\n            colStart ++;\\n        }\\n        \\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507353,
                "title": "0ms-easy-approach-beasts-100-step-by-step-explanation",
                "content": "# Intuition\\n\\nEasy approach to solve this question :) \\uD83D\\uDD25.\\n\\nWe mainly focus on the `top row`, `right column`, `bottom row` & `left column` after creating a blank matrix.\\nAfter every iteration we increamnt `starting row` & `starting column` and decrement `ending row` & `ending column`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- **Creating** a blank matrix of size m.\\n`int[][] ans = new int[n][n];`\\n- **Initializing** the values for smooth travelling in the matrix \\n```\\nint startingRow = 0;\\nint endingRow = n - 1;\\nint startingCol = 0;\\nint endingCol = n - 1;\\n```\\n- For **Top Row** `Left -> Right` -> as we go left to right then we increament the values then we go to next row. i.e. `startingRow++`\\n```\\nfor (int i = startingCol; i <= endingCol; i++) {\\n        ans[startingRow][i] = count;\\n        count++;\\n    }\\n    startingRow++;\\n```\\n- For **Right Column** `Top-->Bottom` --> after the top row, for every next row we go with the last index value of every column, till last second row. Then decrement the ending column index  i.e. `endingCol--`.\\n```\\nfor (int i = startingRow; i <= endingRow; i++) {\\n        ans[i][endingCol] = count;\\n        count++;\\n    }\\n    endingCol--;\\n```\\n- For **Bottom Row** `Right-->LEft` --> we go right to left then we decrement the ending column variable. i.e. `endingCol--`.\\n```\\nfor (int i = endingCol; i >= startingCol; i--) {\\n        ans[endingRow][i] = count;\\n        count++;\\n    }\\n    endingRow--;\\n```\\n- For **Left Column** `Bottom-->Top` --> after the botto row, for every above row we go with the first index value till the top second row. Then we increment the first index of every column i.e. `startingCol++` . \\n```\\nfor (int i = endingRow; i >= startingRow; i--) {\\n        ans[i][startingCol] = count;\\n        count++;   \\n    }\\n    startingCol++;\\n```\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/f9496ec6-b5f3-4fd9-83af-4a801efab4ef_1683697175.891551.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n                \\n        int[][] ans = new int[n][n];\\n        \\n        int count = 1;\\n        int total = n * n;\\n        \\n        int startingRow = 0;\\n        int endingRow = n - 1;\\n        int startingCol = 0;\\n        int endingCol = n - 1;\\n        \\n        while (count <= total) {\\n            \\n            // Top row\\n            for (int i = startingCol; i <= endingCol; i++) {\\n                ans[startingRow][i] = count;\\n                count++;\\n            }\\n            startingRow++;\\n            \\n            // Right row\\n            for (int i = startingRow; i <= endingRow; i++) {\\n                ans[i][endingCol] = count;\\n                count++;\\n            }\\n            endingCol--;\\n            \\n            //  Bottom row \\n            for (int i = endingCol; i >= startingCol; i--) {\\n                ans[endingRow][i] = count;\\n                count++;\\n            }\\n            endingRow--;\\n            \\n            //   Left column\\n            for (int i = endingRow; i >= startingRow; i--) {\\n                ans[i][startingCol] = count;\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation",
                    "Iterator"
                ],
                "code": "```\\nint startingRow = 0;\\nint endingRow = n - 1;\\nint startingCol = 0;\\nint endingCol = n - 1;\\n```\n```\\nfor (int i = startingCol; i <= endingCol; i++) {\\n        ans[startingRow][i] = count;\\n        count++;\\n    }\\n    startingRow++;\\n```\n```\\nfor (int i = startingRow; i <= endingRow; i++) {\\n        ans[i][endingCol] = count;\\n        count++;\\n    }\\n    endingCol--;\\n```\n```\\nfor (int i = endingCol; i >= startingCol; i--) {\\n        ans[endingRow][i] = count;\\n        count++;\\n    }\\n    endingRow--;\\n```\n```\\nfor (int i = endingRow; i >= startingRow; i--) {\\n        ans[i][startingCol] = count;\\n        count++;   \\n    }\\n    startingCol++;\\n```\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n                \\n        int[][] ans = new int[n][n];\\n        \\n        int count = 1;\\n        int total = n * n;\\n        \\n        int startingRow = 0;\\n        int endingRow = n - 1;\\n        int startingCol = 0;\\n        int endingCol = n - 1;\\n        \\n        while (count <= total) {\\n            \\n            // Top row\\n            for (int i = startingCol; i <= endingCol; i++) {\\n                ans[startingRow][i] = count;\\n                count++;\\n            }\\n            startingRow++;\\n            \\n            // Right row\\n            for (int i = startingRow; i <= endingRow; i++) {\\n                ans[i][endingCol] = count;\\n                count++;\\n            }\\n            endingCol--;\\n            \\n            //  Bottom row \\n            for (int i = endingCol; i >= startingCol; i--) {\\n                ans[endingRow][i] = count;\\n                count++;\\n            }\\n            endingRow--;\\n            \\n            //   Left column\\n            for (int i = endingRow; i >= startingRow; i--) {\\n                ans[i][startingCol] = count;\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507277,
                "title": "solution-with-easy-understandable-logics",
                "content": "# Approach \\nCreating 2D array and storing sequence of numbers incremented by 1 starting at 1 in spiral order\\n# Institution\\n[Made by using logics from solution of this problem](https://leetcode.com/problems/spiral-matrix/solutions/3503965/beats-99-with-scomplexity/)\\n\\n\\n >BY  Seeker of Miracle\\n# Complexity\\n- Time complexity:O(n^2) \\n- Space complexity:O(n^2)\\nWhere n is length of one axis in matrix\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar generateMatrix = function(n) {\\n    // MATRIX[Y][X]\\n    //    ---------\\n    //Y0 | 1  2  3 |\\n    //Y1 | 4  5  6 |\\n    //Y2 | 7  8  9 |\\n    //    ---------\\n    //     X0 X1 X2\\n    \\n    let matrix=[],count=0,x=0,y=0;\\n    const maxElements=n*n;\\n\\n    for(let i=0; i<n;i++)\\n    {\\n        matrix[i]= new Array()\\n    }\\n\\n    while(maxElements>count)\\n    {\\n        for(let i=x; maxElements>count && i<n-x;i++)\\n        {\\n            count++;\\n            matrix[y][i]=count\\n            // console.log(1, matrix[y][i])\\n        }\\n        y++;\\n\\n        for(let i=y; maxElements>count && i<n-(y-1);i++)\\n        {\\n            count++;\\n            matrix[i][(n-1) - x]=count;\\n            // console.log(2, matrix[i][(n-1) - x])\\n        }\\n        x++;\\n\\n        for(let i=(n-1)-x; maxElements>count && i>=x-1; i--)\\n        {\\n            count++;\\n            matrix[(n-1)-(y-1)][i]=count;\\n            // console.log(3, matrix[(n-1)-(y-1)][i])\\n        }\\n\\n        for(let i=(n-1)-y; maxElements>count && i>=y; i--)\\n        {\\n            count++;\\n            matrix[i][x-1]=count\\n            // console.log(4, matrix[i][x-1])\\n        }\\n    }\\n    return matrix;\\n};\\n```\\n*I am happy if you leave your comments below as advise in order to improve my code*",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar generateMatrix = function(n) {\\n    // MATRIX[Y][X]\\n    //    ---------\\n    //Y0 | 1  2  3 |\\n    //Y1 | 4  5  6 |\\n    //Y2 | 7  8  9 |\\n    //    ---------\\n    //     X0 X1 X2\\n    \\n    let matrix=[],count=0,x=0,y=0;\\n    const maxElements=n*n;\\n\\n    for(let i=0; i<n;i++)\\n    {\\n        matrix[i]= new Array()\\n    }\\n\\n    while(maxElements>count)\\n    {\\n        for(let i=x; maxElements>count && i<n-x;i++)\\n        {\\n            count++;\\n            matrix[y][i]=count\\n            // console.log(1, matrix[y][i])\\n        }\\n        y++;\\n\\n        for(let i=y; maxElements>count && i<n-(y-1);i++)\\n        {\\n            count++;\\n            matrix[i][(n-1) - x]=count;\\n            // console.log(2, matrix[i][(n-1) - x])\\n        }\\n        x++;\\n\\n        for(let i=(n-1)-x; maxElements>count && i>=x-1; i--)\\n        {\\n            count++;\\n            matrix[(n-1)-(y-1)][i]=count;\\n            // console.log(3, matrix[(n-1)-(y-1)][i])\\n        }\\n\\n        for(let i=(n-1)-y; maxElements>count && i>=y; i--)\\n        {\\n            count++;\\n            matrix[i][x-1]=count\\n            // console.log(4, matrix[i][x-1])\\n        }\\n    }\\n    return matrix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3507180,
                "title": "beginner-friendly-solution-in-cpp-beats-100-in-time-and-90-in-space",
                "content": "\\n# Complexity\\n- Time complexity: $$(N * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$(N * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> generateMatrix(int n)\\n    {\\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        int row = 0, col = 0, number = 1, c = 0;\\n        while (c < (n + 1) / 2) // Filling the matrix in squares, starting from the outermost and then going inwards\\n        {\\n            row = sqr_count, col = sqr_count;\\n            for (; col < n - sqr_count - 1; col++) // Going from first element of the square to the second last in that row\\n                ans[row][col] = number++;\\n            for (; row < n - sqr_count - 1; row++) // Going from the last row element(first in the column) to the second last in that column\\n                ans[row][col] = number++;\\n            for (; col > sqr_count; col--) // From the last element in the last column(last row element) to the second element in the bottom row\\n                ans[row][col] = number++;\\n            for (; row > sqr_count; row--) // From the last element in the last row,(last column element) to the second element in the first column\\n                ans[row][col] = number++;\\n            sqr_count++;\\n        }\\n        if (n & 1)  // If the order of matrix is odd set the maximum in the center\\n            ans[n / 2][n / 2] = r;\\n        return ans;\\n    }\\n};\\n```\\n## Do upvote, if it helped",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> generateMatrix(int n)\\n    {\\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        int row = 0, col = 0, number = 1, c = 0;\\n        while (c < (n + 1) / 2) // Filling the matrix in squares, starting from the outermost and then going inwards\\n        {\\n            row = sqr_count, col = sqr_count;\\n            for (; col < n - sqr_count - 1; col++) // Going from first element of the square to the second last in that row\\n                ans[row][col] = number++;\\n            for (; row < n - sqr_count - 1; row++) // Going from the last row element(first in the column) to the second last in that column\\n                ans[row][col] = number++;\\n            for (; col > sqr_count; col--) // From the last element in the last column(last row element) to the second element in the bottom row\\n                ans[row][col] = number++;\\n            for (; row > sqr_count; row--) // From the last element in the last row,(last column element) to the second element in the first column\\n                ans[row][col] = number++;\\n            sqr_count++;\\n        }\\n        if (n & 1)  // If the order of matrix is odd set the maximum in the center\\n            ans[n / 2][n / 2] = r;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507106,
                "title": "daily-faster-than-100-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int top=0, down=n-1, left=0, right=n-1;\\n        int c=1;\\n        while(top<=down and left<=right){\\n            for(int i=left; i<=right; i++){\\n                ans[top][i]=c++;\\n            }\\n            top++;\\n            for(int i=top; i<=down; i++){\\n                ans[i][right]=c++;\\n            }\\n            right--;\\n            for(int i=right; i>=left; i--){\\n                ans[down][i]=c++;\\n            }\\n            down--;\\n            for(int i=down; i>=top; i--){\\n                ans[i][left]=c++;\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n, vector<int>(n));\\n        int top=0, down=n-1, left=0, right=n-1;\\n        int c=1;\\n        while(top<=down and left<=right){\\n            for(int i=left; i<=right; i++){\\n                ans[top][i]=c++;\\n            }\\n            top++;\\n            for(int i=top; i<=down; i++){\\n                ans[i][right]=c++;\\n            }\\n            right--;\\n            for(int i=right; i>=left; i--){\\n                ans[down][i]=c++;\\n            }\\n            down--;\\n            for(int i=down; i>=top; i--){\\n                ans[i][left]=c++;\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506922,
                "title": "python-short-and-clean-iterative-solution",
                "content": "# Approach\\n1. Reuse the `inwards_spiral` function from [Spiral Matrix I](https://leetcode.com/problems/spiral-matrix/solutions/1467615/python-short-and-clean-iterative-solution/?orderBy=most_votes) to generate indices in spiral order.\\n\\n2. Zip through indices and counter, assigning count to the corresponding index of the `matrix`.\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n\\n- Space complexity: $$O(1)$$, ignoring the returned list.\\n\\nwhere,\\n`m * n is the dimensions of matrix.`\\n\\n# Code\\n```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> list[list[int]]:\\n        \\n        def inwards_spiral(m: int, n: int) -> Iterator[Tuple[int, int]]:\\n            \"\"\"Return list of (i, j) indices of a m * n matrix in spiral order\"\"\"\\n            \\n            for k in range((min(m, n) + 1) // 2):\\n                (i1, j1), (i2, j2) = (k, k), (m - k - 1, n - k - 1)\\n                \\n                if (i1, j1) == (i2, j2): yield (i1, j1); return                                 # Center\\n                \\n                yield from ((i1, j) for j in range(j1, j2))                                     # Left to Right\\n                yield from ((i, j2) for i in range(i1, i2))                                     # Top to Bottom\\n                yield from ((i2, j) for j in range(j2, j1, -1)) if i1 != i2 else ((i2, j2),)    # Right to Left\\n                yield from ((i, j1) for i in range(i2, i1, -1)) if j1 != j2 else ((i2, j1),)    # Bottom to Top\\n        \\n        matrix = [[0] * n for _ in range(n)]\\n        for (i, j), x in zip(inwards_spiral(n, n), count(1)): matrix[i][j] = x\\n        return matrix\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```python\\nclass Solution:\\n    def generateMatrix(self, n: int) -> list[list[int]]:\\n        \\n        def inwards_spiral(m: int, n: int) -> Iterator[Tuple[int, int]]:\\n            \"\"\"Return list of (i, j) indices of a m * n matrix in spiral order\"\"\"\\n            \\n            for k in range((min(m, n) + 1) // 2):\\n                (i1, j1), (i2, j2) = (k, k), (m - k - 1, n - k - 1)\\n                \\n                if (i1, j1) == (i2, j2): yield (i1, j1); return                                 # Center\\n                \\n                yield from ((i1, j) for j in range(j1, j2))                                     # Left to Right\\n                yield from ((i, j2) for i in range(i1, i2))                                     # Top to Bottom\\n                yield from ((i2, j) for j in range(j2, j1, -1)) if i1 != i2 else ((i2, j2),)    # Right to Left\\n                yield from ((i, j1) for i in range(i2, i1, -1)) if j1 != j2 else ((i2, j1),)    # Bottom to Top\\n        \\n        matrix = [[0] * n for _ in range(n)]\\n        for (i, j), x in zip(inwards_spiral(n, n), count(1)): matrix[i][j] = x\\n        return matrix\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506910,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }\\n                top++;\\n                for(int i=top;i<=bottom;i++){\\n                   m[i][right]=c;\\n                    c++; \\n                }\\n                right--;\\n                for(int i=right;i>=left;i--){\\n                    m[bottom][i]=c;\\n                    c++;\\n                }\\n                bottom--;\\n                for(int i=bottom;i>=top;i--){\\n                   m[i][left]=c;\\n                    c++; \\n                }\\n                left++;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>>m(n,vector<int>(n,0));\\n        int c=1;\\n        int left=0,right=n-1,top=0,bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            \\n                for(int i=left;i<=right;i++){\\n                    m[top][i]=c;\\n                    c++;\\n                }\\n                top++;\\n                for(int i=top;i<=bottom;i++){\\n                   m[i][right]=c;\\n                    c++; \\n                }\\n                right--;\\n                for(int i=right;i>=left;i--){\\n                    m[bottom][i]=c;\\n                    c++;\\n                }\\n                bottom--;\\n                for(int i=bottom;i>=top;i--){\\n                   m[i][left]=c;\\n                    c++; \\n                }\\n                left++;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506897,
                "title": "direct-approach-java-0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int arr[][] = new int[n][n];\\n\\n        int count = 1;\\n        int k = 0;\\n        int l = 0;\\n        int t = 0;\\n        for (int i = k; i < n; i++) {\\n            for(int j=l;j<n;j++){\\n                arr[t][j] = count++;\\n            }\\n            t++;\\n            for(int j=t;j<n;j++){\\n                arr[j][n-1] = count++;\\n            }\\n            t--;\\n            for(int j=n-2;j>=t;j--){\\n                arr[n-1][j] = count++;\\n            }\\n            t++;\\n            for(int j=n-2;j>=t;j--){\\n                arr[j][t-1] = count++;\\n            }\\n            n--;\\n            l++;\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int arr[][] = new int[n][n];\\n\\n        int count = 1;\\n        int k = 0;\\n        int l = 0;\\n        int t = 0;\\n        for (int i = k; i < n; i++) {\\n            for(int j=l;j<n;j++){\\n                arr[t][j] = count++;\\n            }\\n            t++;\\n            for(int j=t;j<n;j++){\\n                arr[j][n-1] = count++;\\n            }\\n            t--;\\n            for(int j=n-2;j>=t;j--){\\n                arr[n-1][j] = count++;\\n            }\\n            t++;\\n            for(int j=n-2;j>=t;j--){\\n                arr[j][t-1] = count++;\\n            }\\n            n--;\\n            l++;\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506795,
                "title": "java-solution-for-spiral-matrix-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to use four loops, each representing a direction (right, down, left, up) to fill the matrix in a spiral order. The loops move along the outer boundaries of the matrix and increment the current number to be filled.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize variables: total to store the total number of elements in the matrix, result to store the generated matrix, x and y as the current positions in the matrix, and step to keep track of the current boundary step.\\n- Use a loop that runs until i reaches the total number of elements.\\n- Within the loop, move right until reaching the end of the current row, fill the current position with the next number, and increment i.\\n- Adjust the position and repeat the process for moving down, left, and up, respectively.\\n- Update step after completing one spiral loop to move to the inner boundaries of the matrix.\\n- Repeat the steps until all elements are filled.\\n- Return the generated matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n^2), where n is the given input. It iterates over each element in the matrix exactly once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n^2) as well since the solution creates a 2D matrix of size n x n to store the generated matrix.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int total = n*n;\\n        int[][] result= new int[n][n];\\n        int x=0;\\n        int y=0;\\n        int step = 0;\\n        for(int i=0;i<total;)\\n        {\\n            while(y+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y++;\\n            }\\n            y--;\\n            x++;\\n            while(x+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x++;\\n            }\\n            x--;\\n            y--;\\n            while(y>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y--;\\n            }\\n            y++;\\n            x--;\\n            step++;\\n            while(x>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x--;\\n            }\\n            x++;\\n            y++;\\n        }\\n        return result;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] generateMatrix(int n) {\\n        int total = n*n;\\n        int[][] result= new int[n][n];\\n        int x=0;\\n        int y=0;\\n        int step = 0;\\n        for(int i=0;i<total;)\\n        {\\n            while(y+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y++;\\n            }\\n            y--;\\n            x++;\\n            while(x+step<n)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x++;\\n            }\\n            x--;\\n            y--;\\n            while(y>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                y--;\\n            }\\n            y++;\\n            x--;\\n            step++;\\n            while(x>=0+step)\\n            {\\n                i++;\\n                result[x][y]=i;\\n                x--;\\n            }\\n            x++;\\n            y++;\\n        }\\n        return result;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506662,
                "title": "c-easy-implementation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int k=1;\\n        int top,bottom,left,right;\\n        vector<vector<int>> matrix(n, vector<int> (n));\\n        top=left=0;\\n        right=bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            for(int i=left;i<=right;i++){\\n                matrix[top][i]=k++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=k++;\\n            }\\n            right--;\\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=k++;\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=k++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        int k=1;\\n        int top,bottom,left,right;\\n        vector<vector<int>> matrix(n, vector<int> (n));\\n        top=left=0;\\n        right=bottom=n-1;\\n        while(left<=right && top<=bottom){\\n            for(int i=left;i<=right;i++){\\n                matrix[top][i]=k++;\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                matrix[i][right]=k++;\\n            }\\n            right--;\\n            for(int i=right;i>=left;i--){\\n                matrix[bottom][i]=k++;\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                matrix[i][left]=k++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506430,
                "title": "daily-leetcoding-challenge-may-day-10",
                "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3505265,
                "title": "c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, std::vector<int>(n, 0));\\n\\n        int rowTop = 0;\\n        int rowBottom = matrix.size() - 1;\\n        int columnLeft = 0;\\n        int columnRight = matrix.size() - 1;\\n\\n        int num = 1;\\n        while (true) {\\n            // right\\n            for (int i = columnLeft; i <= columnRight; i++) {\\n                matrix[rowTop][i] = num++;\\n            }\\n            rowTop++;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // down\\n            for (int i = rowTop; i <= rowBottom; i++) {\\n                matrix[i][columnRight] = num++;\\n            }\\n            columnRight--;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // left\\n            for (int i = columnRight; i >= columnLeft; i--) {\\n                matrix[rowBottom][i] = num++;\\n            }\\n            rowBottom--;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // up\\n            for (int i = rowBottom; i >= rowTop; i--) {\\n                matrix[i][columnLeft] = num++;\\n            }\\n            columnLeft++;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, std::vector<int>(n, 0));\\n\\n        int rowTop = 0;\\n        int rowBottom = matrix.size() - 1;\\n        int columnLeft = 0;\\n        int columnRight = matrix.size() - 1;\\n\\n        int num = 1;\\n        while (true) {\\n            // right\\n            for (int i = columnLeft; i <= columnRight; i++) {\\n                matrix[rowTop][i] = num++;\\n            }\\n            rowTop++;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // down\\n            for (int i = rowTop; i <= rowBottom; i++) {\\n                matrix[i][columnRight] = num++;\\n            }\\n            columnRight--;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // left\\n            for (int i = columnRight; i >= columnLeft; i--) {\\n                matrix[rowBottom][i] = num++;\\n            }\\n            rowBottom--;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n\\n            // up\\n            for (int i = rowBottom; i >= rowTop; i--) {\\n                matrix[i][columnLeft] = num++;\\n            }\\n            columnLeft++;\\n\\n            if (rowTop > rowBottom || columnLeft > columnRight) {\\n                break;\\n            }\\n        }\\n        return matrix;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3345184,
                "title": "c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int x=1;\\n        int i=0,j=0;\\n        int p=n,q=n;\\n        while(i<=p&&j<=q){\\n            for(int k=j;k<q;k++) {\\n               ans[i][k]=x;\\n               x++;\\n            }\\n            i++;\\n            for(int k=i;k<p;k++){\\n                ans[k][q-1]=x;\\n                x++;\\n            }\\n            q--;\\n            for(int k=q-1;k>=j;k--){\\n                ans[p-1][k]=x;\\n                x++;\\n            }\\n            p--;\\n            for(int k=p-1;k>=i;k--){\\n                ans[k][j]=x;\\n                x++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int x=1;\\n        int i=0,j=0;\\n        int p=n,q=n;\\n        while(i<=p&&j<=q){\\n            for(int k=j;k<q;k++) {\\n               ans[i][k]=x;\\n               x++;\\n            }\\n            i++;\\n            for(int k=i;k<p;k++){\\n                ans[k][q-1]=x;\\n                x++;\\n            }\\n            q--;\\n            for(int k=q-1;k>=j;k--){\\n                ans[p-1][k]=x;\\n                x++;\\n            }\\n            p--;\\n            for(int k=p-1;k>=i;k--){\\n                ans[k][j]=x;\\n                x++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1888784,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888659,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1710044,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888670,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1717655,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1567118,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888833,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888861,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888672,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1754605,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888784,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888659,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1710044,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888670,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1717655,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1567118,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888833,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888861,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1888672,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1754605,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Today\\'s problem is The Matrix Reloaded.\\nThe next one is The Matrix Revolution."
                    },
                    {
                        "username": "Msey",
                        "content": "Matrix Resolution sonds better for me"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Just pray that we don\\'t get The Matrix Resurrections"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Seems like a Matrix Week:-), \\ntomorrow :Spiral Matrix-III, and \\nday after tomorrow: Spiral Matrix-IV."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Bcoz you figured out the pattern, and disclosed it.. Leetcode will now change the pattern from tomorrow \\uD83E\\uDD1E"
                    },
                    {
                        "username": "Ver1",
                        "content": "Just why..."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "**Previously in [Spiral Matrix 1](https://leetcode.com/problems/spiral-matrix/)**\n`spiral1(matrix[m][n]) { ... answer[i] = matrix[r][c] ... }`\n\n**Now in Spiral Matrix 2**\n`spiral2(n) {}`\n- `m = n`\n- We have to make `matrix[n][n]`.\n- Here `answer` array is given as `answer[i] = i + 1`.\n- `spiral2(n) { ... matrix[r][c] = i + 1 ... }`\nEverything else is same."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Copy pasted most of my code from spiral matrix I, and being a sequel, perhaps this is intended? I\\'m not sure how sequels here are meant to work."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse Layer by Layer in Spiral Form\n\n  \n**Approach 2:** Optimized spiral traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "VyomDoshi",
                        "content": "Matrix II.....hmmmm......copy, paste, edit, submit.....code beats 100%\\uD83D\\uDE02\\uD83D\\uDE02 "
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Solved it yesterday after solving the Spiral Matrix I and today it is the LC challenge :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Modify the code on yesterday and done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix-ii/solutions/3506513/beats-100-c-solution/"
                    },
                    {
                        "username": "siddhanto",
                        "content": "While solving this think of multiple square which getting shrink, so begin it with 1st outer square and code it with considering each side of the square and saving it to a new matrix "
                    }
                ]
            },
            {
                "id": 1889104,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1889078,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 2072367,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 2026817,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1993751,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1984801,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1901066,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1889605,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1889361,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1889347,
                "content": [
                    {
                        "username": "nick3000",
                        "content": "I don\\'t know why but I hate Spiral Matrix now"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Question is nice. Everyone should try it."
                    },
                    {
                        "username": "Boggers0",
                        "content": "This is not in spiral order.... the result expected is different...\\n"
                    },
                    {
                        "username": "Blue_Bon",
                        "content": "\\uD83D\\uDE0A\\n"
                    },
                    {
                        "username": "Alphageek01",
                        "content": "Hey can someBody Help me why i am getting time limit exceeded error"
                    },
                    {
                        "username": "ayush_0110",
                        "content": "Can anyone tell what\\'s wrong in this code?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> a(n,vector<int>(n,0));\\n        int r=n-1,c=n-1,i=0,j=0,num=1,rm=1,cm=0;\\n        while(num<=(n*n)){\\n            while(j<=c && num<=(n*n)){\\n                a[i][j]=num;num++;j++;\\n            }\\n            j--;\\n            c--;\\n            while(i<=r && num<=(n*n)){\\n                a[i][j]=num;num++;i++;\\n            }\\n            i--;\\n            r--;\\n            while(j>=cm && num<=(n*n)){\\n                a[i][j]=num;num++;j--;\\n            }\\n            j++;\\n            cm++;\\n            while(i>=rm && num<=(n*n)){\\n                a[i][j]=num;num++;i--;\\n            }\\n            i++;\\n            rm++;\\n            if(num>=(n*n))break;\\n        }\\n        return a;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Mind blowing Editorial with visualization ..."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "When your code works from the first time, but you know leetCode testcases...\\nMe: I am going to try out all 20 testcases.\\nWOWWW!! All of them actually work!!"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If tomorrow is \"Spiral Matrix III\" I am dead \\uD83D\\uDE48"
                    },
                    {
                        "username": "mrping_11",
                        "content": "looks like i predicted that this question will be up for today\\'s challenge before solving yesterday\\'s challenge."
                    }
                ]
            },
            {
                "id": 1889341,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889319,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889286,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889196,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889166,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889133,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889100,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1889008,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1888971,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1888924,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "To be honest, I don\\'t like matrix problems"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "You gotta be kidding me"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "I think the matrix is following us \\uD83E\\uDD23"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "From last 3 days, I just have to click on Submit button.\\nBecause I have already solved these problems previously."
                    },
                    {
                        "username": "cJayesh",
                        "content": "Sqaure it and give it to next one"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Quite easy if you have solved Matrix-I."
                    },
                    {
                        "username": "rajneeshkabdwal",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int ctr=1;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n        //         cout<<ans[i][j]<<endl;\\n        //     }\\n        // }\\n        for(int i=0;i<1;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=n-1;j<n;j++){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        for(int i=n-1;i>0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                ans[i][j]=ctr++;\\n            }\\n        }\\n        // cout<<(n/2)-1<<endl;\\n        int x=pow(n,2);\\n        // cout<<x;\\n        ans[n/2][n/2]=x;\\n        int tmp=(n/2);\\n        tmp=tmp-1;\\n        cout<<tmp;\\n        ans[n/2][tmp]=x-1;\\n        return ans;\\n    }\\n};\\nits giving runtime error"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Just like yesterday\\'s but you have to go backwards. "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "seems weekend is gonna be full of super hards "
                    },
                    {
                        "username": "vetor",
                        "content": "didnt know its a spiral week :("
                    }
                ]
            },
            {
                "id": 1888912,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888878,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888847,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888816,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888812,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888799,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888776,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888721,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888715,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            },
            {
                "id": 1888677,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nah, no way. I did spiral matrix 1 and 2 just two days ago. before they were on daily. lmao."
                    },
                    {
                        "username": "dumb_me",
                        "content": "is next spiral matrix - 3 ?\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "My Brain cells are moving Spirally \\uD83C\\uDF6D\\uD83C\\uDF69\\uD83C\\uDF6A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Just . . . . . . Escape the matrix and Rule over your  Principle."
                    },
                    {
                        "username": "Iam_SinghSunny",
                        "content": "Matrix supremacy\\u2764\\uFE0F"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Copy Paste Yesterday\\'s Code Fill the Matrix instead of Filling the List."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This problem is better than yesterday\\'s."
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Neo will be like, what the matrix."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday\\'s daily for reference: https://leetcode.com/problems/spiral-matrix/\\nThis one might be easier since you just need to modify your code from the previous exercise."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You\\'ve gotta be kidding me, lol"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Substring with At Most Two Distinct Characters",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1566840,
                "content": [
                    {
                        "username": "suhanovsergey",
                        "content": "https://leetcode.com/problems/fruit-into-baskets. That one is marked as Medium however."
                    },
                    {
                        "username": "gaurav1903",
                        "content": "the only troubling thing about this question is that they decided to use uppercase as well as lowercase letters in the testcases"
                    },
                    {
                        "username": "sk4142",
                        "content": "Same as 340 except k = 2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Practice \\uD83D\\uDCAA\\uD83C\\uDFFC a little bit of `Variable Size Sliding Window` problems. Then this problem will feel like a piece of cake \\uD83C\\uDF70"
                    }
                ]
            },
            {
                "id": 1775696,
                "content": [
                    {
                        "username": "suhanovsergey",
                        "content": "https://leetcode.com/problems/fruit-into-baskets. That one is marked as Medium however."
                    },
                    {
                        "username": "gaurav1903",
                        "content": "the only troubling thing about this question is that they decided to use uppercase as well as lowercase letters in the testcases"
                    },
                    {
                        "username": "sk4142",
                        "content": "Same as 340 except k = 2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Practice \\uD83D\\uDCAA\\uD83C\\uDFFC a little bit of `Variable Size Sliding Window` problems. Then this problem will feel like a piece of cake \\uD83C\\uDF70"
                    }
                ]
            },
            {
                "id": 1979186,
                "content": [
                    {
                        "username": "suhanovsergey",
                        "content": "https://leetcode.com/problems/fruit-into-baskets. That one is marked as Medium however."
                    },
                    {
                        "username": "gaurav1903",
                        "content": "the only troubling thing about this question is that they decided to use uppercase as well as lowercase letters in the testcases"
                    },
                    {
                        "username": "sk4142",
                        "content": "Same as 340 except k = 2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Practice \\uD83D\\uDCAA\\uD83C\\uDFFC a little bit of `Variable Size Sliding Window` problems. Then this problem will feel like a piece of cake \\uD83C\\uDF70"
                    }
                ]
            },
            {
                "id": 1803117,
                "content": [
                    {
                        "username": "suhanovsergey",
                        "content": "https://leetcode.com/problems/fruit-into-baskets. That one is marked as Medium however."
                    },
                    {
                        "username": "gaurav1903",
                        "content": "the only troubling thing about this question is that they decided to use uppercase as well as lowercase letters in the testcases"
                    },
                    {
                        "username": "sk4142",
                        "content": "Same as 340 except k = 2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Practice \\uD83D\\uDCAA\\uD83C\\uDFFC a little bit of `Variable Size Sliding Window` problems. Then this problem will feel like a piece of cake \\uD83C\\uDF70"
                    }
                ]
            }
        ]
    },
    {
        "title": "3Sum Smaller",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565372,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "I was under the impression that 0 <= i < j < k < n and this applied to the vector coming in. If you sort the numbers, the indices are scrambled. All the solutions are sorting, so I must be misreading the problem... not sure how though..."
                    },
                    {
                        "username": "peachisamomoco",
                        "content": "I'm wondering what if the problem asks us to find the number of distinct triplets, instead of number of index triplets. Can we still solve it in O(n^2)? What's the good way to do it?"
                    },
                    {
                        "username": "miterl",
                        "content": "Agreed with [@Zak Coder](/zakcoder). The problem requires 0 <= i < j < k < n while i, j and k are apparently referring to the original indexes, and you lost them by sorting unless you save them somewhere.\\nIf the official problem description is correct, all the editorial solutions and most of the sorting based solutions actually solved a wrong problem: find the number of any 3-elements combinations such that the sum < target, thus the restriction \"0 <= i < j < k < n\" is meaningless."
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It only asks for the count and not the list of indices."
                    },
                    {
                        "username": "fpolica91",
                        "content": "This is a truly disappointingly wrong description. It is almost painful to derive to the answer as my initial understanding was different. In any case, if you have been solving the 3sum problems, what we are being asked in basically `ans+= abs(right - left);` that is the answer, not the number of occurrences of elements that are less than target.\\n\\nCheers"
                    },
                    {
                        "username": "lennonli999",
                        "content": "why starting from i+1 ends at  nums.length -2?\\n\\nfor (int i = 0; i < nums.length - 2; i++) {\\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\\n        }"
                    }
                ]
            },
            {
                "id": 1571498,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "I was under the impression that 0 <= i < j < k < n and this applied to the vector coming in. If you sort the numbers, the indices are scrambled. All the solutions are sorting, so I must be misreading the problem... not sure how though..."
                    },
                    {
                        "username": "peachisamomoco",
                        "content": "I'm wondering what if the problem asks us to find the number of distinct triplets, instead of number of index triplets. Can we still solve it in O(n^2)? What's the good way to do it?"
                    },
                    {
                        "username": "miterl",
                        "content": "Agreed with [@Zak Coder](/zakcoder). The problem requires 0 <= i < j < k < n while i, j and k are apparently referring to the original indexes, and you lost them by sorting unless you save them somewhere.\\nIf the official problem description is correct, all the editorial solutions and most of the sorting based solutions actually solved a wrong problem: find the number of any 3-elements combinations such that the sum < target, thus the restriction \"0 <= i < j < k < n\" is meaningless."
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It only asks for the count and not the list of indices."
                    },
                    {
                        "username": "fpolica91",
                        "content": "This is a truly disappointingly wrong description. It is almost painful to derive to the answer as my initial understanding was different. In any case, if you have been solving the 3sum problems, what we are being asked in basically `ans+= abs(right - left);` that is the answer, not the number of occurrences of elements that are less than target.\\n\\nCheers"
                    },
                    {
                        "username": "lennonli999",
                        "content": "why starting from i+1 ends at  nums.length -2?\\n\\nfor (int i = 0; i < nums.length - 2; i++) {\\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\\n        }"
                    }
                ]
            },
            {
                "id": 1847614,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "I was under the impression that 0 <= i < j < k < n and this applied to the vector coming in. If you sort the numbers, the indices are scrambled. All the solutions are sorting, so I must be misreading the problem... not sure how though..."
                    },
                    {
                        "username": "peachisamomoco",
                        "content": "I'm wondering what if the problem asks us to find the number of distinct triplets, instead of number of index triplets. Can we still solve it in O(n^2)? What's the good way to do it?"
                    },
                    {
                        "username": "miterl",
                        "content": "Agreed with [@Zak Coder](/zakcoder). The problem requires 0 <= i < j < k < n while i, j and k are apparently referring to the original indexes, and you lost them by sorting unless you save them somewhere.\\nIf the official problem description is correct, all the editorial solutions and most of the sorting based solutions actually solved a wrong problem: find the number of any 3-elements combinations such that the sum < target, thus the restriction \"0 <= i < j < k < n\" is meaningless."
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It only asks for the count and not the list of indices."
                    },
                    {
                        "username": "fpolica91",
                        "content": "This is a truly disappointingly wrong description. It is almost painful to derive to the answer as my initial understanding was different. In any case, if you have been solving the 3sum problems, what we are being asked in basically `ans+= abs(right - left);` that is the answer, not the number of occurrences of elements that are less than target.\\n\\nCheers"
                    },
                    {
                        "username": "lennonli999",
                        "content": "why starting from i+1 ends at  nums.length -2?\\n\\nfor (int i = 0; i < nums.length - 2; i++) {\\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\\n        }"
                    }
                ]
            },
            {
                "id": 1789850,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "I was under the impression that 0 <= i < j < k < n and this applied to the vector coming in. If you sort the numbers, the indices are scrambled. All the solutions are sorting, so I must be misreading the problem... not sure how though..."
                    },
                    {
                        "username": "peachisamomoco",
                        "content": "I'm wondering what if the problem asks us to find the number of distinct triplets, instead of number of index triplets. Can we still solve it in O(n^2)? What's the good way to do it?"
                    },
                    {
                        "username": "miterl",
                        "content": "Agreed with [@Zak Coder](/zakcoder). The problem requires 0 <= i < j < k < n while i, j and k are apparently referring to the original indexes, and you lost them by sorting unless you save them somewhere.\\nIf the official problem description is correct, all the editorial solutions and most of the sorting based solutions actually solved a wrong problem: find the number of any 3-elements combinations such that the sum < target, thus the restriction \"0 <= i < j < k < n\" is meaningless."
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It only asks for the count and not the list of indices."
                    },
                    {
                        "username": "fpolica91",
                        "content": "This is a truly disappointingly wrong description. It is almost painful to derive to the answer as my initial understanding was different. In any case, if you have been solving the 3sum problems, what we are being asked in basically `ans+= abs(right - left);` that is the answer, not the number of occurrences of elements that are less than target.\\n\\nCheers"
                    },
                    {
                        "username": "lennonli999",
                        "content": "why starting from i+1 ends at  nums.length -2?\\n\\nfor (int i = 0; i < nums.length - 2; i++) {\\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\\n        }"
                    }
                ]
            },
            {
                "id": 1624445,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "I was under the impression that 0 <= i < j < k < n and this applied to the vector coming in. If you sort the numbers, the indices are scrambled. All the solutions are sorting, so I must be misreading the problem... not sure how though..."
                    },
                    {
                        "username": "peachisamomoco",
                        "content": "I'm wondering what if the problem asks us to find the number of distinct triplets, instead of number of index triplets. Can we still solve it in O(n^2)? What's the good way to do it?"
                    },
                    {
                        "username": "miterl",
                        "content": "Agreed with [@Zak Coder](/zakcoder). The problem requires 0 <= i < j < k < n while i, j and k are apparently referring to the original indexes, and you lost them by sorting unless you save them somewhere.\\nIf the official problem description is correct, all the editorial solutions and most of the sorting based solutions actually solved a wrong problem: find the number of any 3-elements combinations such that the sum < target, thus the restriction \"0 <= i < j < k < n\" is meaningless."
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It only asks for the count and not the list of indices."
                    },
                    {
                        "username": "fpolica91",
                        "content": "This is a truly disappointingly wrong description. It is almost painful to derive to the answer as my initial understanding was different. In any case, if you have been solving the 3sum problems, what we are being asked in basically `ans+= abs(right - left);` that is the answer, not the number of occurrences of elements that are less than target.\\n\\nCheers"
                    },
                    {
                        "username": "lennonli999",
                        "content": "why starting from i+1 ends at  nums.length -2?\\n\\nfor (int i = 0; i < nums.length - 2; i++) {\\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\\n        }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Logger Rate Limiter",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1573233,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            },
            {
                "id": 1571634,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            },
            {
                "id": 1570043,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            },
            {
                "id": 1823927,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            },
            {
                "id": 1693749,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            },
            {
                "id": 1931162,
                "content": [
                    {
                        "username": "codekumar",
                        "content": "The problem basically is simple if we are going to consider only a single thread. Set plus queue based solution is fine but however the task of cleaning up the memory has to be done by the thread that request to log the message. This is unnecessary an overhead for a user  thread that does logging operation. \\n\\nLets say that there are multiple threads who are simultaneiously calling the shouldPrintMessage(), if the messages are different then obviously we have to store them all in the set. Now the question is how are we going to clean up this set as the size can increase indefinately. We may use a lock based approach and lock the set but this  makes the system unresponsive as other threads will block till the cleaner thread cleans some entries of the set and clears memory.\\n\\n**Epoch Based Approach:**\\nA epoch basically is an identifier during which some insertions happens on a paritcular set.\\nWe have 3 sets dedicated to 3 epochs. Lets say, set A for epoch 0, set B for epoch 1 and set C for epoch 2.\\n\\nWe basically have two housekeeping threads. First one is memory cleaner(Garbage collector) and second one is EpochActivator.\\n\\nEpochActivator thread wakes up every 10 seconds and does an operation like active_epoch = (active_epoch + 1)  % 3.\\n\\nWhen a thread wants to insert a message in the set, it checks if the message is present in the set belonging to current active epoch as well as previous active epoch. If the message is present, then it calculates the difference and adds message to the current active epoch  if the difference between time is greater than 10. \\n\\nThe garbage collector wakes periodically every 10 seconds and deletes the set which is 2 epochs behind the active epoch.\\n\\n\\nThis is one of the way we can implement a lock-free highly responsive logger for multiple threads.\\n"
                    },
                    {
                        "username": "queenkicker",
                        "content": "In your approach, are the 3 sets running on different threads? What happens if the message you are trying to add is not in the active_epoch (A) or previous active (B) set, i.e., it is in C."
                    },
                    {
                        "username": "Erick111",
                        "content": "Considering it's a problem from Google, I really want to know: where is the follow-up?"
                    },
                    {
                        "username": "xiaolucunzi",
                        "content": "The first test case is like this:\\n\\n[\"Logger\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\",\"shouldPrintMessage\"]\\n[[],[1,\"foo\"],[2,\"bar\"],[3,\"foo\"],[8,\"bar\"],[10,\"foo\"],[11,\"foo\"]]\\n\\nThe expected results are [null,true,true,false,false,false,true].\\n\\nThe last expected result should NOT be true becasue result[\"foo\"] =1,  result[\"foo\"] = 3, then result[\"foo\"]  = 10,  However, last test result[\"foo\"] = 11, and the delta is only 1 different from previous message \"foo\" timestamp, NOT > 10. So the value of the last expected result should be false."
                    },
                    {
                        "username": "user1193uB",
                        "content": "10 seconds is the next eligible time to be true, meaning 10 seconds past the first true response the log is eligible to be logged again. With the logic you presented, if a log request comes across every second it will never actually log after the first instance whereas the rules ask for it to be eligible to be logged again after 10 seconds. \\n\\n- [1,\"foo\"] is true\\n- [3,\"foo\"] is false because its within 10 seconds of that last log event\\n- [11,\"foo\"] is true because its the first \"foo\" log request to come across at 10+ seconds since the first."
                    },
                    {
                        "username": "cyph0r",
                        "content": "The test cases are correct, there is a difference of 10 units in the emission of first \"Foo\" and 11th \"Foo\""
                    },
                    {
                        "username": "rsbh",
                        "content": "Here is the follow up question for this\n\nQuestion: If duplicate messages come within a 10secs window then discard previous and current Message.\nThe solution for this question will be given using Linked list and a MAP. A map to store the last reference of the message and linked list to print those messages later. This question has been recently asked in FAANG."
                    },
                    {
                        "username": "queenkicker",
                        "content": "Then that changes the API right. You have one method to `void addMessage(timestamp, message)` and another to `list<string> flush(timestamp)`. And they need to be synchronized. "
                    },
                    {
                        "username": "Basic_CoderLearner",
                        "content": "In the interview, I came up with Queue + map solution similar to yours.\\nIts tricky.\\nBut later on brainstormed & found that in Map we need to keep range of conflicting intervals. So when we are clearing our queue we should check if that message lies in the conflicting range"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "There should be a follow up question on this, I believe. If we design a log rate limiter like this it\\'s can burn down the heap memory and bring the application down :D\\nThere should be some cron job or something which would clean up the map on regular interval. That interval depends on how frequently we print logs. If we have limited variety of log messages then extra cron job is not needed. We can actually run this in lower environment and see how large this can grow and take logical decision. This could be a hot topic for tech discussion. "
                    },
                    {
                        "username": "the-invisible-man",
                        "content": "Is this a phone screen question or an onsite? And for what level?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Repeated Substring Pattern",
        "question_content": "<p>Given a string <code>s</code>, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abab&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> It is the substring &quot;ab&quot; twice.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aba&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcabcabcabc&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> It is the substring &quot;abc&quot; four times or the substring &quot;abcabc&quot; twice.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 94334,
                "title": "easy-python-solution-with-explaination",
                "content": "Basic idea:\\n\\n1) First char of input string is first char of repeated substring\\n2) Last char of input string is last char of repeated substring\\n3) Let S1 = S + S (where S in input string)\\n4) Remove 1 and last char of S1. Let this be S2\\n5) If S exists in S2 then return true else false\\n6) Let i be index in S2 where S starts then repeated substring length i + 1 and repeated substring S[0: i+1] \\n\\n```\\ndef repeatedSubstringPattern(self, str):\\n\\n        \"\"\"\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        if not str:\\n            return False\\n            \\n        ss = (str + str)[1:-1]\\n        return ss.find(str) != -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef repeatedSubstringPattern(self, str):\\n\\n        \"\"\"\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        if not str:\\n            return False\\n            \\n        ss = (str + str)[1:-1]\\n        return ss.find(str) != -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 94352,
                "title": "java-simple-solution-with-explanation",
                "content": "```\\npublic boolean repeatedSubstringPattern(String str) {\\n\\tint l = str.length();\\n\\tfor(int i=l/2;i>=1;i--) {\\n\\t\\tif(l%i==0) {\\n\\t\\t\\tint m = l/i;\\n\\t\\t\\tString subS = str.substring(0,i);\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\tfor(int j=0;j<m;j++) {\\n\\t\\t\\t\\tsb.append(subS);\\n\\t\\t\\t}\\n\\t\\t\\tif(sb.toString().equals(str)) return true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```\\n1. The length of the repeating substring must be a divisor of the length of the input string\\n2. Search for all possible divisor of `str.length`, starting for `length/2`\\n3. If `i` is a divisor of `length`, repeat the substring from `0` to `i` the number of times `i` is contained in `s.length`\\n4. If the repeated substring is equals to the input `str` return `true`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean repeatedSubstringPattern(String str) {\\n\\tint l = str.length();\\n\\tfor(int i=l/2;i>=1;i--) {\\n\\t\\tif(l%i==0) {\\n\\t\\t\\tint m = l/i;\\n\\t\\t\\tString subS = str.substring(0,i);\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\tfor(int j=0;j<m;j++) {\\n\\t\\t\\t\\tsb.append(subS);\\n\\t\\t\\t}\\n\\t\\t\\tif(sb.toString().equals(str)) return true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94344,
                "title": "simple-java-solution-2-lines",
                "content": "```\\n    public boolean repeatedSubstringPattern(String str) {\\n        String s = str + str;\\n        return s.substring(1, s.length() - 1).contains(str);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean repeatedSubstringPattern(String str) {\\n        String s = str + str;\\n        return s.substring(1, s.length() - 1).contains(str);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94397,
                "title": "c-o-n-using-kmp-32ms-8-lines-of-code-with-brief-explanation",
                "content": "First, we build the KMP table. \\n1) Roughly speaking, dp[i+1] stores the maximum number of characters that the string is repeating itself up to position i.\\n2) Therefore, if a string repeats a length 5 substring 4 times, then the last entry would be of value 15.\\n3) To check if the string is repeating itself, we just need the last entry to be non-zero and  str.size() to divide (str.size()-last entry).\\n```\\n    bool repeatedSubstringPattern(string str) {\\n        int i = 1, j = 0, n = str.size();\\n        vector<int> dp(n+1,0);\\n        while( i < str.size() ){\\n            if( str[i] == str[j] ) dp[++i]=++j;\\n            else if( j == 0 ) i++;\\n            else j = dp[j];\\n        }\\n        return dp[n]&&dp[n]%(n-dp[n])==0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool repeatedSubstringPattern(string str) {\\n        int i = 1, j = 0, n = str.size();\\n        vector<int> dp(n+1,0);\\n        while( i < str.size() ){\\n            if( str[i] == str[j] ) dp[++i]=++j;\\n            else if( j == 0 ) i++;\\n            else j = dp[j];\\n        }\\n        return dp[n]&&dp[n]%(n-dp[n])==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94360,
                "title": "my-one-line-c-solution",
                "content": "```\\nbool repeatedSubstringPattern(string str) \\n    {\\n        return (str + str).substr(1, str.size() * 2 - 2).find(str)!=-1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool repeatedSubstringPattern(string str) \\n    {\\n        return (str + str).substr(1, str.size() * 2 - 2).find(str)!=-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826151,
                "title": "python-c-java-js-go-by-fold-and-find-w-simple-proof",
                "content": "![image](https://assets.leetcode.com/users/images/258103c9-2305-4e2a-812c-c585d1572ffa_1599127928.421695.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/917ae175-a569-4ce9-b648-77d6ebbde4bc_1599126979.9700963.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/70f0370c-f4dc-45f5-b780-b529525b8703_1599127500.4632437.png)\\n\\n---\\n\\n**Hint**:\\n\\na.\\nFold, make **s_fold** = s[ 1 : ] + s[ : -1 ]\\n\\nb.\\nCheck whether we can find **s** in **s_fold** or not\\n\\nIf s has repeated substring pattern, then we can find s in s_fold.\\nOtherwise, s cannot be found.\\n\\n---\\n\\n**Example & Demo**:\\n\\n#1.\\ns = \\'abab\\'\\ns_fold = \\'bababa\\'\\n\\nwe can find s in s_fold, where s_fold = \\'b**abab**a\\'\\n\\n---\\n\\n#2.\\n\\ns = \\'abac\\'\\ns_fold = \\'bacaba\\'\\n\\nwe cannot find s in s_fold, where s_fold = \\'bacaba\\'\\n\\n---\\n\\n**Implementation**:\\n\\n**Python**:\\n\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        \\n        s_fold = \"\".join( (s[1:], s[:-1]) )\\n        \\n        return s in s_fold\\n```\\n\\n---\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        \\n        int size = s.size();\\n        \\n        string postfix = s.substr(1, size-1);\\n        string prefix = s.substr(0, size-1);\\n        \\n        string sFold = postfix + prefix;\\n        \\n        return sFold.find(s) != string::npos;\\n    }\\n};\\n```\\n\\n---\\n\\n**Java**:\\n\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        \\n        int size = s.length();\\n        \\n        String sFold = s.substring(1, size) + s.substring(0, size-1);\\n        \\n        return sFold.contains(s);\\n        \\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript**:\\n\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    \\n    let size = s.length;\\n    let sFold = s.substr(1, size) + s.substr(0, size-1);\\n    \\n    return sFold.indexOf( s ) != -1;\\n};\\n```\\n\\n---\\n\\n**Golang**:\\n\\n```\\nfunc repeatedSubstringPattern(s string) bool {\\n    \\n    size := len(s)\\n    sFold := s[1:size] + s[0:size-1]\\n    \\n    return strings.Contains(sFold, s)\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        \\n        s_fold = \"\".join( (s[1:], s[:-1]) )\\n        \\n        return s in s_fold\\n```\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        \\n        int size = s.size();\\n        \\n        string postfix = s.substr(1, size-1);\\n        string prefix = s.substr(0, size-1);\\n        \\n        string sFold = postfix + prefix;\\n        \\n        return sFold.find(s) != string::npos;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        \\n        int size = s.length();\\n        \\n        String sFold = s.substring(1, size) + s.substring(0, size-1);\\n        \\n        return sFold.contains(s);\\n        \\n    }\\n}\\n```\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    \\n    let size = s.length;\\n    let sFold = s.substr(1, size) + s.substr(0, size-1);\\n    \\n    return sFold.indexOf( s ) != -1;\\n};\\n```\n```\\nfunc repeatedSubstringPattern(s string) bool {\\n    \\n    size := len(s)\\n    sFold := s[1:size] + s[0:size-1]\\n    \\n    return strings.Contains(sFold, s)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938580,
                "title": "99-42-2-approaches-o-n",
                "content": "# Problem Understanding\\n\\nIn the \"459. Repeated Substring Pattern\" problem, we are given a string `s`. The task is to check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.\\n\\nFor instance, given the string `s = \"abab\"`, the output should be `True` as it is constructed by repeating the substring \"ab\" twice.\\n\\n**Input**: \"abab\"\\n**Output**: True\\n\\n---\\n\\n# Live Coding v1 & v2:\\nhttps://youtu.be/RweTIFVSVck\\n\\n- [in Python \\uD83D\\uDC0D](https://youtu.be/RweTIFVSVck)\\n- [in Go \\uD83D\\uDC39](https://youtu.be/DeCw5VFDWaI)\\n\\n# Approach 1/2: Check All Possible Substrings\\n\\nTo solve the \"459. Repeated Substring Pattern\" problem, we iterate over all possible substring lengths (from 1 to `len(s)//2`). For each length, we check if the string can be constructed by repeating that substring.\\n\\n## Key Data Structures:\\n- **Substring**: To hold the possible substring that could be repeated to form the string `s`.\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - Start from the first character.\\n   \\n2. **Processing Each Substring**:\\n   - For each possible length of substring, check if repeating that substring forms the original string.\\n\\n3. **Wrap-up**:\\n   - Return `True` if any such substring is found, otherwise `False`.\\n\\n## Example:\\n\\nGiven the string \"abcabc\":\\n\\n1. First check with substring \"a\" - Does not form the original string.\\n2. Next, check with substring \"ab\" - Does not form the original string.\\n3. Finally, check with substring \"abc\" - Forms the original string. Hence, return `True`.\\n\\n---\\n\\n# Approach 2/2: Clever String Manipulation\\n\\nThe idea behind this approach is that if a string `s` can be constructed by repeating a substring, then concatenating two copies of `s` together and removing the first and last character would still contain `s` as a substring.\\n\\n## Key Data Structures:\\n- **Concatenated String**: A string formed by concatenating `s` with itself.\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - Concatenate string `s` with itself.\\n   \\n2. **Check for Repeated Pattern**:\\n   - Remove the first and last character from the concatenated string and check if the original string `s` is present.\\n\\n3. **Wrap-up**:\\n   - Return `True` if the string is present, otherwise `False`.\\n\\n## Example:\\n\\nGiven the string \"abab\":\\n\\n1. Concatenate to get \"abababab\".\\n2. Remove first and last characters to get \"bababa\".\\n3. Check if \"abab\" is present in \"bababa\" - It is. Hence, return `True`.\\n\\n---\\n\\n# Complexity:\\n\\n## For Approach 1/2:\\n**Time Complexity:** \\n- $$O(n^2)$$ as we are iterating over half the string and for each length, we are checking the entire string.\\n\\n**Space Complexity:** \\n- $$O(n)$$ as we are constructing a repeated string of length `n`.\\n\\n## For Approach 2/2:\\n**Time Complexity:** \\n- $$O(n)$$ for concatenation and substring check.\\n\\n**Space Complexity:** \\n- $$O(n)$$ for the concatenated string.\\n\\n---\\n\\n# Performance:\\n## Approach 1/2:\\n| Language   | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|------------|--------------|------------------|-------------|-----------------|\\n| Rust       | 9            | 20.37%           | 2.1         | 42.59%          |\\n| Go         | 30           | 22.41%           | 8.7         | 13.79%          |\\n| Java       | 36           | 64.96%           | 44.1        | 61.10%          |\\n| C++        | 46           | 30.24%           | 91.8        | 20.17%          |\\n| Python3    | 50           | 73.5%            | 16.4        | 75.82%          |\\n| JavaScript | 83           | 41.70%           | 48.5        | 42.47%          |\\n| C#         | 87           | 66.81%           | 117.6       | 18.14%          |\\n\\n![v1a.png](https://assets.leetcode.com/users/images/f65f92c1-e905-4a37-b010-0a848aec6910_1692579412.5117164.png)\\n\\n\\n## Approach 2/2\\n| Language   | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|------------|--------------|------------------|-------------|-----------------|\\n| Rust       | 2            | 94.44%           | 2.4         | 20.37%          |\\n| Go         | 7            | 60.92%           | 6.0         | 51.15%          |\\n| C++        | 16           | 79.18%           | 13.4        | 57.60%          |\\n| Python3    | 31           | 99.42%           | 16.5        | 46.1%           |\\n| JavaScript | 61           | 76.6%            | 44.9        | 70.8%           |\\n| C#         | 70           | 88.94%           | 50.8        | 64.60%          |\\n| Java       | 75           | 50.12%           | 44.2        | 46.38%          |\\n\\n![v2.png](https://assets.leetcode.com/users/images/075370bf-c81d-4a8e-9c46-3c7eef412b76_1692577907.1661692.png)\\n\\n---\\n\\n# Code 1/2\\n``` Python []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        for i in range(1, n//2 + 1):\\n            if n % i == 0:\\n                substring = s[:i]\\n                if substring * (n // i) == s:\\n                    return True\\n        return False\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; ++i) {\\n            if (n % i == 0) {\\n                string substring = s.substr(0, i);\\n                string repeated = \"\";\\n                for (int j = 0; j < n / i; ++j) {\\n                    repeated += substring;\\n                }\\n                if (repeated == s) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                String substring = s.substring(0, i);\\n                StringBuilder repeated = new StringBuilder();\\n                for (int j = 0; j < n / i; j++) {\\n                    repeated.append(substring);\\n                }\\n                if (repeated.toString().equals(s)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        int n = s.Length;\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                string substring = s.Substring(0, i);\\n                System.Text.StringBuilder builder = new System.Text.StringBuilder();\\n                for (int j = 0; j < n / i; j++) {\\n                    builder.Append(substring);\\n                }\\n                if (builder.ToString() == s) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    const n = s.length;\\n    for (let i = 1; i <= n / 2; i++) {\\n        if (n % i === 0) {\\n            const substring = s.slice(0, i);\\n            let repeated = \"\";\\n            for (let j = 0; j < n / i; j++) {\\n                repeated += substring;\\n            }\\n            if (repeated === s) return true;\\n        }\\n    }\\n    return false;\\n};\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn repeated_substring_pattern(s: String) -> bool {\\n        let n = s.len();\\n        for i in 1..=n / 2 {\\n            if n % i == 0 {\\n                let substring = &s[0..i];\\n                let mut repeated = String::new();\\n                for _ in 0..(n / i) {\\n                    repeated.push_str(substring);\\n                }\\n                if repeated == s {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n}\\n```\\n``` Go []\\nimport \"strings\"\\n\\nfunc repeatedSubstringPattern(s string) bool {\\n    n := len(s)\\n    for i := 1; i <= n/2; i++ {\\n        if n%i == 0 {\\n            substring := s[:i]\\n            var builder strings.Builder\\n            for j := 0; j < n/i; j++ {\\n                builder.WriteString(substring)\\n            }\\n            if builder.String() == s {\\n                return true\\n            }\\n        }\\n    }\\n    return false\\n}\\n```\\n# Code 2/2\\n``` Python []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s + s)[1:-1]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string doubled = s + s;\\n        string sub = doubled.substr(1, doubled.size() - 2);\\n        return sub.find(s) != string::npos;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String doubled = s + s;\\n        String sub = doubled.substring(1, doubled.length() - 1);\\n        return sub.contains(s);\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        string doubled = s + s;\\n        string sub = doubled.Substring(1, doubled.Length - 2);\\n        return sub.Contains(s);\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    const doubled = s + s;\\n    const sub = doubled.slice(1, -1);\\n    return sub.includes(s);\\n};\\n```\\n``` Go []\\nfunc repeatedSubstringPattern(s string) bool {\\n    doubled := s + s\\n    return strings.Contains(doubled[1:len(doubled)-1], s)\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn repeated_substring_pattern(s: String) -> bool {\\n        let doubled = s.clone() + &s;\\n        let sub = &doubled[1..doubled.len()-1];\\n        return sub.contains(&s);\\n    }\\n}\\n```\\n## Live Coding in Go:\\nhttps://youtu.be/DeCw5VFDWaI\\n\\nThis problem beautifully showcases the importance of understanding the nature of strings and pattern recognition. By thinking out of the box, one can come up with more efficient solutions. \\uD83D\\uDCA1\\uD83C\\uDF20\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "String",
                    "String Matching"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        for i in range(1, n//2 + 1):\\n            if n % i == 0:\\n                substring = s[:i]\\n                if substring * (n // i) == s:\\n                    return True\\n        return False\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; ++i) {\\n            if (n % i == 0) {\\n                string substring = s.substr(0, i);\\n                string repeated = \"\";\\n                for (int j = 0; j < n / i; ++j) {\\n                    repeated += substring;\\n                }\\n                if (repeated == s) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                String substring = s.substring(0, i);\\n                StringBuilder repeated = new StringBuilder();\\n                for (int j = 0; j < n / i; j++) {\\n                    repeated.append(substring);\\n                }\\n                if (repeated.toString().equals(s)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        int n = s.Length;\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                string substring = s.Substring(0, i);\\n                System.Text.StringBuilder builder = new System.Text.StringBuilder();\\n                for (int j = 0; j < n / i; j++) {\\n                    builder.Append(substring);\\n                }\\n                if (builder.ToString() == s) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    const n = s.length;\\n    for (let i = 1; i <= n / 2; i++) {\\n        if (n % i === 0) {\\n            const substring = s.slice(0, i);\\n            let repeated = \"\";\\n            for (let j = 0; j < n / i; j++) {\\n                repeated += substring;\\n            }\\n            if (repeated === s) return true;\\n        }\\n    }\\n    return false;\\n};\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn repeated_substring_pattern(s: String) -> bool {\\n        let n = s.len();\\n        for i in 1..=n / 2 {\\n            if n % i == 0 {\\n                let substring = &s[0..i];\\n                let mut repeated = String::new();\\n                for _ in 0..(n / i) {\\n                    repeated.push_str(substring);\\n                }\\n                if repeated == s {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n}\\n```\n``` Go []\\nimport \"strings\"\\n\\nfunc repeatedSubstringPattern(s string) bool {\\n    n := len(s)\\n    for i := 1; i <= n/2; i++ {\\n        if n%i == 0 {\\n            substring := s[:i]\\n            var builder strings.Builder\\n            for j := 0; j < n/i; j++ {\\n                builder.WriteString(substring)\\n            }\\n            if builder.String() == s {\\n                return true\\n            }\\n        }\\n    }\\n    return false\\n}\\n```\n``` Python []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s + s)[1:-1]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string doubled = s + s;\\n        string sub = doubled.substr(1, doubled.size() - 2);\\n        return sub.find(s) != string::npos;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String doubled = s + s;\\n        String sub = doubled.substring(1, doubled.length() - 1);\\n        return sub.contains(s);\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        string doubled = s + s;\\n        string sub = doubled.Substring(1, doubled.Length - 2);\\n        return sub.Contains(s);\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    const doubled = s + s;\\n    const sub = doubled.slice(1, -1);\\n    return sub.includes(s);\\n};\\n```\n``` Go []\\nfunc repeatedSubstringPattern(s string) bool {\\n    doubled := s + s\\n    return strings.Contains(doubled[1:len(doubled)-1], s)\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn repeated_substring_pattern(s: String) -> bool {\\n        let doubled = s.clone() + &s;\\n        let sub = &doubled[1..doubled.len()-1];\\n        return sub.contains(&s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826121,
                "title": "python-2-solutions-1-oneliner-explained",
                "content": "Nice and easy problem, which can be solved in different ways.\\n\\n### Solution 1\\n\\nJust check all posible divisors of lenght of `s`, replicate them and compare them with original string. If we have found it, we return `True`, if we reached the end and we did not find any, we return `False`.\\n\\n**Complexity**: time complexity is `O(n*sqrt(n))`, because we have no more than `O(sqrt(n))` divisors of number `n` (we can split them into pairs, where one number in pair will be `<sqrt(n)`. Space compexity is `O(n)`.\\n\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s):\\n        N = len(s)\\n        for i in range(1, N//2+1):\\n            if N % i == 0 and s[:i]* (N//i) == s:\\n                return True\\n        return False\\n```\\n\\n### Solution 2\\nBut wait, there is more! There is in fact very short and interesting solution. Let us replicate our sting, remove first and last elements and try to find original string: for example:\\n\\n`s = abcdabcd`, then we have `bcdabcdabcdabc`, where we can find `abcdabcd` inside. It is a bit more difficult to prove, that opposite is true: if we found substring it will mean that we have repeated substring pattern. I will add proof a bit later.\\n\\n**Complexity**: time complexity is basically `O(n)`, because we can find substrings in linear time. In python function `in` will work, using Boyer\\u2013Moore algorithm, which is in average work in linear time (if you do not like average, you can use KMP, which have worst linear time, not average). Space complexity is `O(n)`.\\n\\n```\\nreturn s in (s+s)[1:-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s):\\n        N = len(s)\\n        for i in range(1, N//2+1):\\n            if N % i == 0 and s[:i]* (N//i) == s:\\n                return True\\n        return False\\n```\n```\\nreturn s in (s+s)[1:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94346,
                "title": "29-ms-cpp-simple-solution-no-kmp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string str) {\\n        string nextStr = str;\\n        int len = str.length();\\n        if(len < 1) return false;\\n        for(int i = 1; i <= len / 2; i++){\\n            if(len % i == 0){\\n                nextStr = leftShift(str, i);\\n                if(nextStr == str) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    string leftShift(string &str, int l){\\n        string ret = str.substr(l);\\n        ret += str.substr(0, l);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string str) {\\n        string nextStr = str;\\n        int len = str.length();\\n        if(len < 1) return false;\\n        for(int i = 1; i <= len / 2; i++){\\n            if(len % i == 0){\\n                nextStr = leftShift(str, i);\\n                if(nextStr == str) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    string leftShift(string &str, int l){\\n        string ret = str.substr(l);\\n        ret += str.substr(0, l);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94340,
                "title": "java-o-n",
                "content": "```\\npublic boolean repeatedSubstringPattern(String str) {\\n\\t        //This is the kmp issue\\n\\t        int[] prefix = kmp(str);\\n\\t        int len = prefix[str.length()-1];\\n\\t        int n = str.length();\\n\\t        return (len > 0 && n%(n-len) == 0);\\n\\t    }\\n\\t    private int[] kmp(String s){\\n\\t        int len = s.length();\\n\\t        int[] res = new int[len];\\n\\t        char[] ch = s.toCharArray();\\n\\t        int i = 0, j = 1;\\n\\t        res[0] = 0;\\n\\t        while(i < ch.length && j < ch.length){\\n\\t            if(ch[j] == ch[i]){\\n\\t                res[j] = i+1;\\n\\t                i++;\\n\\t                j++;\\n\\t            }else{\\n\\t                if(i == 0){\\n\\t                    res[j] = 0;\\n\\t                    j++;\\n\\t                }else{\\n\\t                    i = res[i-1];\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t        return res;\\n\\t    }",
                "solutionTags": [],
                "code": "```\\npublic boolean repeatedSubstringPattern(String str) {\\n\\t        //This is the kmp issue\\n\\t        int[] prefix = kmp(str);\\n\\t        int len = prefix[str.length()-1];\\n\\t        int n = str.length();\\n\\t        return (len > 0 && n%(n-len) == 0);\\n\\t    }\\n\\t    private int[] kmp(String s){\\n\\t        int len = s.length();\\n\\t        int[] res = new int[len];\\n\\t        char[] ch = s.toCharArray();\\n\\t        int i = 0, j = 1;\\n\\t        res[0] = 0;\\n\\t        while(i < ch.length && j < ch.length){\\n\\t            if(ch[j] == ch[i]){\\n\\t                res[j] = i+1;\\n\\t                i++;\\n\\t                j++;\\n\\t            }else{\\n\\t                if(i == 0){\\n\\t                    res[j] = 0;\\n\\t                    j++;\\n\\t                }else{\\n\\t                    i = res[i-1];\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t        return res;\\n\\t    }",
                "codeTag": "Unknown"
            },
            {
                "id": 441613,
                "title": "easiest-python-solution-with-detailed-explanation-and-example",
                "content": "```class Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s+s)[1:-1]\\n```\\n\\nExample:\\nTo find if the string has a repeatable substring inside, we can create a new string by duplicating the original string. \\nEx. \"abcabc\" => \"abcabcabcabc\"\\nBy removing the first and last character of the new string we create the string \"bcabcabcabcab\"\\nIf the original string \"abcabc\" is in \"bc**abcabc**ab\", we return true. \\n\\nWhy it works:\\nIf the original string has a repeating substring, the repeating substring can be no larger than 1/2 the length of the original string. I.e \"xyxy\" would be \"xy\"\\nBy repeating the string and removing the first and last character of the new string,  I.e \"xyxyxyxy\" => \"yxyxyx\", if the original string \"xyxy\" can be found in \"y**xyxy**x\", it means that \"xyxy\" has a repeating substring. \\n\\nHowever, this solution doesn\\'t tell us what the repeating substring is, but does solve the question if it exists.",
                "solutionTags": [],
                "code": "```class Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s+s)[1:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551225,
                "title": "python-3-one-liner-beats-98-19",
                "content": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:] + s[:-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:] + s[:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145294,
                "title": "c-easy-fast-3-lines-of-code-commented-for-understanding",
                "content": "***\\u2714substring check method :***\\n\\n```\\nbool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        for(int i=n/2;i>=1;i--){                //commented below\\n            if(n%i==0){                                                             //i is expressing the size of the substring forming-->if length of the substring(i.e, i) divides n equally then we can say the substring can be/may be a possible solution,so we check further,else we skip.\\n                if(s.substr(0,n-i)==s.substr(i))return true;           //rotation approach-->if two substrings from first and last match then we can say they can repeatedly form the string.\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\n***\\u2714explaination of running loop from n/2 :***  \\uD83D\\uDE0E\\n \\nFor those who are wondering why to choose \\noption-1)    \"for(int i = len/2; i>=1; i--)\" \\nand not\\noption-2)     \"for(int i = 1; i<=len/2; i++)\" \\n\\nLet\\'s take a small example to find which is better :\\ns = \"abcabcabcabc\"\\n\\nIf we chose option-1, we can find \"abcabc\" is the substring which when repeated \"twice\" gives the string s.\\n\\nIf we chose option-2, we can find \"abc\" is the substring which when repeated \"4 times\" gives the string s.\\n\\nSo, obviously option-1 is better as we are looking for the largest repeated substring first to minimize the time.\\n\\nHope that helps.\\n\\n![image](https://assets.leetcode.com/users/images/4364ec55-e199-4a4b-b10c-6261827d6f11_1655091797.973157.png)\\n\\n\\n\\uD83D\\uDE4CHappy Coding !!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        for(int i=n/2;i>=1;i--){                //commented below\\n            if(n%i==0){                                                             //i is expressing the size of the substring forming-->if length of the substring(i.e, i) divides n equally then we can say the substring can be/may be a possible solution,so we check further,else we skip.\\n                if(s.substr(0,n-i)==s.substr(i))return true;           //rotation approach-->if two substrings from first and last match then we can say they can repeatedly form the string.\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383957,
                "title": "python-beats-100-easy-explanation",
                "content": "**if there is a k repeating pattern in s, then we can say that a k-char rotation of s must be equal to s**\\n```\\ndef repeatedSubstringPattern(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        # if there is a k repeating pattern in s, then\\n        # we can tell that a k-rotation of s should be equal to s\\n        for k in range(1, len(s)//2 +1):   \\n            if s == s[k:] + s[:k]:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef repeatedSubstringPattern(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        # if there is a k repeating pattern in s, then\\n        # we can tell that a k-rotation of s should be equal to s\\n        for k in range(1, len(s)//2 +1):   \\n            if s == s[k:] + s[:k]:\\n                return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 94382,
                "title": "from-intuitive-but-slow-to-really-fast-but-a-little-hard-to-comprehend",
                "content": "Solution 1:\\nLet us start with the very naive solution. It uses 188 ms to solve 100 test cases. The idea is that when we see a character in *str* that matches the very first character of *str*, we can start to hoping that *str* is a built by copies of the substring composed by all characters before the reappearance of the its first character. \\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int l = str.length();\\n        if(l == 1) {\\n            return false;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        char first = str.charAt(0);\\n        sb.append(first);\\n        int i = 1;\\n        while(i <= l / 2) {\\n            char c = str.charAt(i++);\\n            if(c == first && isCopies(str, sb.toString())) {\\n                return true;\\n            }else {\\n                sb.append(c);\\n            }\\n        }\\n        return false;\\n    }\\n    private boolean isCopies(String str, String substr) {\\n        if(str.length() % substr.length() != 0) {\\n            return false;\\n        }\\n        for(int i = substr.length(); i < str.length(); i += substr.length()){\\n            if(!str.substring(i).startsWith(substr)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\nSolution 2:\\nThe problem of the first solution is that we do not use the knowledge of failed matching, and the Knuth-Morris-Pratt algorithm is a classic example of how knowledge of failed tries can be use to guide future search. \\n\\nIn fact we only need to compute the pattern table (the lps array, see below) in the Knuth-Morris-Pratt algorithm. \\n\\nThe entry lps[i] is the length of the longest proper prefix that is also a suffix of (s[0], ..., s[i]), or equivalently, length of the longest prefix that is also a proper suffix of (s[0], ..., s[i]). lps[0] is 0, since a single - character string has no proper prefix or proper suffix. [Here](http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/)  is a very detailed explanation on the KMP algorithm and how lps is computed dynamically.\\n    \\nAfter we get lps, we relate the property of the lps table to the property of a string being constructed by joining copies of its substring. \\n\\nOne on hand, if *str = (s[0], ..., s[km - 1])* is constructed by joining m copies of its substring *substr = (s[0], ..., s[k-1])*, and assuming that *substr* is the finest making block*str* can be boiled down to, meaning *str* is not constructed by joining copies of any proper substring of *substr*. Then we must have lps[km - 1] equals (m - 1)k. \\n\\nOn the other hand, assuming that the longest proper *prefix* of string *str* that is also a *suffix*, and the remaining string *remainderStr* obtained by removing *prefix* from *str* satisfies the following 3 properties:\\n1. *remainderStr* is a proper substring of *str*,\\n2. |str| is divisiable by |remainderStr|,\\n2. *remainderStr* is a prefix of *prefixStr*.\\n\\nWe can show by induction that *str* is constructed by joining copies of *remainderStr*.\\nHere is the code. It solve the 100 test cases in 29ms. A great improvement over the native approach! Remember the statement above, since we are going to use it again.\\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int l = str.length();\\n        int[] lps = new int[l];\\n        int leading = 1;\\n        int chasing = 0;\\n        while(leading < l) {\\n            if(str.charAt(chasing) == str.charAt(leading)) {\\n                chasing++;\\n                lps[leading] = chasing;\\n                leading++;\\n            }else {\\n                if(chasing > 0) {\\n                    chasing = lps[chasing - 1];\\n                }else {\\n                    chasing = 0;\\n                    leading++;\\n                }\\n            }\\n        }\\n        int lp = lps[l - 1];\\n        return (lp > 0 && l % (l - lp) == 0 && str.startsWith(str.substring(lp)));\\n    }\\n}\\n```\\nSolution 3:\\nCan the problem be solved efficiently without KMP? The following solution runs even faster (23ms on 100 test cases)\\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int l = str.length();\\n        for(int i = l / 2; i > 0; i--) {\\n            if(l % i == 0) {\\n                String substr = str.substring(0, i);\\n                int j = i;\\n                while(j < l) {\\n                    if(!str.substring(j, j + i).equals(substr)){\\n                        break;\\n                    }else {\\n                        j += i;\\n                    }\\n                }\\n                if(j == l) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nSolution 4:\\nWant clearer code that runs even faster ? Here is it. The idea is stated at the end of the explanation for solution 2. Without really find the longest proper prefix that is also a suffix as in solution 2 and see whether the three properties are matched, we just test each *remainderStr*, from the longest possible that satisfies condition 1 and 2, that  whether the corresponding prefix and suffix match each other. It solve 100 test cases in 16ms. So maybe now, you really want to prove the statement since it lead to such a clean and fast solution? It is not hard to prove by induction.\\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int l = str.length();\\n        for(int i = (l + 1) / 2; i < l; i++) {\\n            if(l % (l - i) == 0) {\\n                String prefix = str.substring(0, i);\\n                String remainder = str.substring(i);\\n                String suffix = str.substring(l - i);\\n                if(str.startsWith(remainder) && suffix.equals(prefix)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int l = str.length();\\n        if(l == 1) {\\n            return false;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        char first = str.charAt(0);\\n        sb.append(first);\\n        int i = 1;\\n        while(i <= l / 2) {\\n            char c = str.charAt(i++);\\n            if(c == first && isCopies(str, sb.toString())) {\\n                return true;\\n            }else {\\n                sb.append(c);\\n            }\\n        }\\n        return false;\\n    }\\n    private boolean isCopies(String str, String substr) {\\n        if(str.length() % substr.length() != 0) {\\n            return false;\\n        }\\n        for(int i = substr.length(); i < str.length(); i += substr.length()){\\n            if(!str.substring(i).startsWith(substr)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int l = str.length();\\n        int[] lps = new int[l];\\n        int leading = 1;\\n        int chasing = 0;\\n        while(leading < l) {\\n            if(str.charAt(chasing) == str.charAt(leading)) {\\n                chasing++;\\n                lps[leading] = chasing;\\n                leading++;\\n            }else {\\n                if(chasing > 0) {\\n                    chasing = lps[chasing - 1];\\n                }else {\\n                    chasing = 0;\\n                    leading++;\\n                }\\n            }\\n        }\\n        int lp = lps[l - 1];\\n        return (lp > 0 && l % (l - lp) == 0 && str.startsWith(str.substring(lp)));\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int l = str.length();\\n        for(int i = l / 2; i > 0; i--) {\\n            if(l % i == 0) {\\n                String substr = str.substring(0, i);\\n                int j = i;\\n                while(j < l) {\\n                    if(!str.substring(j, j + i).equals(substr)){\\n                        break;\\n                    }else {\\n                        j += i;\\n                    }\\n                }\\n                if(j == l) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int l = str.length();\\n        for(int i = (l + 1) / 2; i < l; i++) {\\n            if(l % (l - i) == 0) {\\n                String prefix = str.substring(0, i);\\n                String remainder = str.substring(i);\\n                String suffix = str.substring(l - i);\\n                if(str.startsWith(remainder) && suffix.equals(prefix)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442971,
                "title": "javascript-single-line-solution",
                "content": "```js\\nvar repeatedSubstringPattern = function(s) {\\n    return s.repeat(2).slice(1, -1).includes(s);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar repeatedSubstringPattern = function(s) {\\n    return s.repeat(2).slice(1, -1).includes(s);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938646,
                "title": "c-simple-solution",
                "content": "Time complexity-O(n^2)\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string t = s; \\n\\n        for(int i=0; i<s.size()-1; i++){ \\n            char c = t[0];  // Store the first char\\n            t.erase(0,1); // Remove the first char\\n            t.push_back(c); // Append the char\\n\\n            if(t==s) { \\n                return true; \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nMethod 2  \\nTime Complexity- O(n^2)\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                string substring = s.substr(0, i);\\n               // cout<<substring.size()<<endl;\\n                string repeated;\\n                for (int j = 0; j < n / i; j++) {\\n                    repeated += substring;\\n                }\\n                if (repeated == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/59feb6ab-c9c8-4147-9b7a-444ab64a4d01_1692580232.9738462.webp)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string t = s; \\n\\n        for(int i=0; i<s.size()-1; i++){ \\n            char c = t[0];  // Store the first char\\n            t.erase(0,1); // Remove the first char\\n            t.push_back(c); // Append the char\\n\\n            if(t==s) { \\n                return true; \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                string substring = s.substr(0, i);\\n               // cout<<substring.size()<<endl;\\n                string repeated;\\n                for (int j = 0; j < n / i; j++) {\\n                    repeated += substring;\\n                }\\n                if (repeated == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3235934,
                "title": "c-2-line-code-using-substr-and-find",
                "content": "# Approach\\nTo explain with an example:\\nlet string be\\n# **\"abcabc\"**\\nso if we concatenate(add same string) it it becomes:\\n# **\"abcabcabcabc\"**\\nIf we remove 1st and last charater from this string:\\n# **\"bcabcabcab\"**\\nAnd now if we check for the original string in this and find it then the ans is true else false\\nAs we can see in the below line there is original string at the middle:\\n# **\"bc   abcabc   ab\"**\\nThen the output is TRUE.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string t=s+s;\\n        if(t.substr(1,t.size()-2).find(s)!=-1)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string t=s+s;\\n        if(t.substr(1,t.size()-2).find(s)!=-1)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694256,
                "title": "java-kmp-solution-with-explanation",
                "content": "Before going into details about how the solution works, you should have an understanding of the KMP algorithm.\\n\\nIn the KMP algorithm, we generate **lps[]** which represents the **longest proper prefix which is also suffix**. It tries to find the longest repetative pattern in given string. We can use this lps array to find out if given string can be created using pattern repeatedly.\\n\\nConsider string **\"ABABCD\"** and its lps array. In the case of a string with continuous repeated pattern if we subtract lps[i] from the length of string till that point it will give us the length of the pattern. In the given image we can see that `length(\"ABAB\") - lps[3] = 4-2 = 2` which is length of continuous repeated pattern **AB**.\\n\\n![image](https://assets.leetcode.com/users/images/5e2eaadb-5865-4f02-a666-987ed6e4a9ee_1642328355.7733243.png)\\n\\nAnother example. String **\"ABCABCABC\"**.\\n\\n![image](https://assets.leetcode.com/users/images/e4052dd9-4351-4fd2-9e17-02347ccc8f26_1642328467.3847742.png)\\n\\nSo, if the **length of string(n) % length of pattern(m) is zero** then we can say that the string can be constructed by taking a substring of it and appending multiple copies of the substring together. Where `length of pattern(m) = n - lps[n-1]`.\\n\\nJava solution\\n\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length(), prevLPS = 0, i = 1;\\n        int[] lps = new int[n];\\n        while (i < n) {\\n            if (s.charAt(i) == s.charAt(prevLPS)) {\\n                lps[i++] = ++prevLPS;\\n            } else if (prevLPS == 0) {\\n                lps[i++] = 0;\\n            } else {\\n                prevLPS = lps[prevLPS - 1];\\n            }\\n        }\\n        return lps[n - 1] > 0 && n % (n - lps[n - 1]) == 0;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length(), prevLPS = 0, i = 1;\\n        int[] lps = new int[n];\\n        while (i < n) {\\n            if (s.charAt(i) == s.charAt(prevLPS)) {\\n                lps[i++] = ++prevLPS;\\n            } else if (prevLPS == 0) {\\n                lps[i++] = 0;\\n            } else {\\n                prevLPS = lps[prevLPS - 1];\\n            }\\n        }\\n        return lps[n - 1] > 0 && n % (n - lps[n - 1]) == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203353,
                "title": "c-3-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string S = s + s;\\n        S = S.substr(1, S.size() - 2);\\n        return S.find(s) == string::npos ? false : true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string S = s + s;\\n        S = S.substr(1, S.size() - 2);\\n        return S.find(s) == string::npos ? false : true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 541860,
                "title": "one-liner-with-explaination",
                "content": "I found this solution is not unique, but very few people explained this properly. If a String s is a repetitive string, you will find s is a substring of ss.substring(1, ss.length()), where ss = s + s. The reason is, considering the basic case in which s is somestring s\\' repeated twice, where we have s = s\\' + s\\'. Imagine now you hold s to find a match in ss. Only when the cursor moves to the second s\\' in ss, we will find a match. Meanwhile, you get the pattern length which is the index of s in ss.substring() - 1. So in any repetitive string, you will be able to find a match once proceed the pattern length.\\n\\n```\\ns =   \\'abcabc\\'\\nss = \\'abcabcabcabc\\'\\n\\n\\'abcabcabcabc\\'\\n  abcabc\\n\\t...\\n\\'abcabcabcabc\\'\\n    abcabc\\n```\\t\\t        \\n\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int idx = (s + s).indexOf(s, 1);\\n        return  idx < s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\ns =   \\'abcabc\\'\\nss = \\'abcabcabcabc\\'\\n\\n\\'abcabcabcabc\\'\\n  abcabc\\n\\t...\\n\\'abcabcabcabc\\'\\n    abcabc\\n```\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int idx = (s + s).indexOf(s, 1);\\n        return  idx < s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940083,
                "title": "c-string-algo-day-21",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; ++i) {\\n            if (n % i == 0) {\\n                string substring = s.substr(0, i);\\n                string repeated = \"\";\\n                for (int j = 0; j < n / i; ++j) {\\n                    repeated += substring;\\n                }\\n                if (repeated == s) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/ee6509ef-a08e-4998-94da-9902b54d64bd_1692608855.7340677.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; ++i) {\\n            if (n % i == 0) {\\n                string substring = s.substr(0, i);\\n                string repeated = \"\";\\n                for (int j = 0; j < n / i; ++j) {\\n                    repeated += substring;\\n                }\\n                if (repeated == s) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826171,
                "title": "c-easy-to-understand-with-explanation-without-kmp",
                "content": "If there is any string that consists of any pattern then the pattern should present at least 2 times in the string. \\n\\nSuppose there is Y string which is created using X pattern then Y will be one of list [XX,  XXX, XXXX, ...]. For example, take Y as XX.\\n\\n* Append the same string twice will make it XXXX.   \\n* The First Pattern of the new string will be changed if we remove the first character, Assume it will become A.\\n* The Last Pattern of the new string will be changed if remove the last character. Assume it will become B.\\n\\t **Note**: I am taking A and B because the characters were removed from the different sides from patterns. \\n* Now, String is AXXB. Check original string is present in it or not. If yes, then the original string is definitely constructed using pattern.\\n\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string tmp = s+s;\\n        /* Remove first char to avoid to match with input string which is from 0 to s.length() */\\n        tmp = tmp.substr(1);\\n        /* Remove last char to avoid to match with input string which is appended after s.length() */\\n        tmp = tmp.substr(0, tmp.length()-1);\\n        /* if the input string present then then pattern is repeated*/\\n        return tmp.find(s) != string::npos ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string tmp = s+s;\\n        /* Remove first char to avoid to match with input string which is from 0 to s.length() */\\n        tmp = tmp.substr(1);\\n        /* Remove last char to avoid to match with input string which is appended after s.length() */\\n        tmp = tmp.substr(0, tmp.length()-1);\\n        /* if the input string present then then pattern is repeated*/\\n        return tmp.find(s) != string::npos ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825657,
                "title": "java-short-and-clean-two-pointers",
                "content": "Basically move two windows until you match or mismatch.\\nThere\\'s no need to append anything, all you\\'re supposed to do is compare characters...\\n\\nSimilar problem that uses this kind of thinking: https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times\\n\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int n = str.length();\\n        \\n        for (int i = n / 2; i > 0; i--) {\\n            if (n % i == 0) {\\n                int left = 0;\\n                int right = i;\\n                \\n                while (right < n && str.charAt(left++) == str.charAt(right)) right++;\\n                \\n                if (right == n) {\\n                    return true;\\n                }                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int n = str.length();\\n        \\n        for (int i = n / 2; i > 0; i--) {\\n            if (n % i == 0) {\\n                int left = 0;\\n                int right = i;\\n                \\n                while (right < n && str.charAt(left++) == str.charAt(right)) right++;\\n                \\n                if (right == n) {\\n                    return true;\\n                }                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826243,
                "title": "python-simple-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=I8NNSCpDt3U)\\nhttps://www.youtube.com/watch?v=I8NNSCpDt3U\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        rep = \\'\\'\\n        length_s = len(s)\\n        \\n        for i in range(length_s // 2):\\n            rep += s[i]\\n            if length_s % len(rep) == 0:\\n                if rep * (length_s // len(rep)) == s:\\n                    return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        rep = \\'\\'\\n        length_s = len(s)\\n        \\n        for i in range(length_s // 2):\\n            rep += s[i]\\n            if length_s % len(rep) == 0:\\n                if rep * (length_s // len(rep)) == s:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826105,
                "title": "python-shortest-simplest-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        for i in range(1, len(s)//2+1):\\n            if s[:i] * (len(s)//i) == s:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        for i in range(1, len(s)//2+1):\\n            if s[:i] * (len(s)//i) == s:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550956,
                "title": "two-js-solutions",
                "content": "```\\nvar repeatedSubstringPattern = function(s) {\\n    let i = 1, len = s.length;\\n    while (i <= Math.floor(len/2)) {\\n        if (s.slice(0, i).repeat(len/i) == s) return true;\\n        i++\\n    }\\n    return false;\\n};\\n```\\n\\n```\\nvar repeatedSubstringPattern = function(s) {\\n    let pattern = \"\";\\n    for (let i = 0; i < Math.floor(s.length/2); i++) {\\n        pattern += s[i];\\n        if (pattern.repeat(s.length / pattern.length) === s) return true;\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar repeatedSubstringPattern = function(s) {\\n    let i = 1, len = s.length;\\n    while (i <= Math.floor(len/2)) {\\n        if (s.slice(0, i).repeat(len/i) == s) return true;\\n        i++\\n    }\\n    return false;\\n};\\n```\n```\\nvar repeatedSubstringPattern = function(s) {\\n    let pattern = \"\";\\n    for (let i = 0; i < Math.floor(s.length/2); i++) {\\n        pattern += s[i];\\n        if (pattern.repeat(s.length / pattern.length) === s) return true;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 487699,
                "title": "java-solution-in-o-n-using-kmp",
                "content": "```\\n//Create one KMP table which will tell us about LPS in the string.\\n//Find the length of the pattern (if formed).\\n//check whether that pattern length is divisible by the length of the given string.\\n//Note:- we need to check the condition of the last index of LPS array. If that is 0 then it means that there is \\n//no pattern formed in the string.\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int[] lps = new int[s.length()];\\n        int i = 1;\\n        for(int j = 0; i < s.length();) {//\\n            if(s.charAt(i) == s.charAt(j)) {\\n                lps[i] = j+1;\\n                i++;\\n                j++;\\n            }\\n            else if(j!=0 && s.charAt(i) != s.charAt(j)) {\\n                j = lps[j-1];\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n        \\n        if(lps[lps.length - 1] == 0) return false;\\n        \\n        int patternlength = s.length() - lps[lps.length - 1];\\n        \\n        if(s.length() % patternlength == 0) return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Create one KMP table which will tell us about LPS in the string.\\n//Find the length of the pattern (if formed).\\n//check whether that pattern length is divisible by the length of the given string.\\n//Note:- we need to check the condition of the last index of LPS array. If that is 0 then it means that there is \\n//no pattern formed in the string.\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int[] lps = new int[s.length()];\\n        int i = 1;\\n        for(int j = 0; i < s.length();) {//\\n            if(s.charAt(i) == s.charAt(j)) {\\n                lps[i] = j+1;\\n                i++;\\n                j++;\\n            }\\n            else if(j!=0 && s.charAt(i) != s.charAt(j)) {\\n                j = lps[j-1];\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n        \\n        if(lps[lps.length - 1] == 0) return false;\\n        \\n        int patternlength = s.length() - lps[lps.length - 1];\\n        \\n        if(s.length() % patternlength == 0) return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94455,
                "title": "1-line-in-python",
                "content": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        return any(s[:i] * (len(s) / i) == s for i in range(1, len(s)) if len(s) % i == 0)\\n```\\n\\nTime complexity is O(n<sup>1.5</sup>) because I do for O(n<sup>0.5</sup>)   times (number of divisors of n) an O(n) operation, i.e.,  `s[:i] * (len(s) / d) == s `. Space complexity is O(n).",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        return any(s[:i] * (len(s) / i) == s for i in range(1, len(s)) if len(s) % i == 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94448,
                "title": "one-line-with-regex",
                "content": "```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        return str.matches(\"^([a-z]+)\\\\\\\\1+$\");\\n    }\\n}\\n```\\n\\nThanks to @StefanPochmann , it can be simplified:\\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        return str.matches(\"(.+)\\\\\\\\1+\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        return str.matches(\"^([a-z]+)\\\\\\\\1+$\");\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        return str.matches(\"(.+)\\\\\\\\1+\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94368,
                "title": "share-my-simple-solution",
                "content": "Try every possible substring, then check.\\n\\n```java\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int len = str.length();\\n        if(len<2) return false;\\n        for(int i=2;i<=len;i++){\\n            if(len%i!=0) continue;\\n            if(check(str, i)) return true;\\n        }\\n        return false;\\n    }\\n    public boolean check(String str, int repeat){\\n        int len = str.length();\\n        String cand = str.substring(0, len/repeat);\\n        for(int i=0;i<len;i++){\\n            if(str.charAt(i)!=cand.charAt(i%(len/repeat))) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int len = str.length();\\n        if(len<2) return false;\\n        for(int i=2;i<=len;i++){\\n            if(len%i!=0) continue;\\n            if(check(str, i)) return true;\\n        }\\n        return false;\\n    }\\n    public boolean check(String str, int repeat){\\n        int len = str.length();\\n        String cand = str.substring(0, len/repeat);\\n        for(int i=0;i<len;i++){\\n            if(str.charAt(i)!=cand.charAt(i%(len/repeat))) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938766,
                "title": "video-ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "I\\'m going to show you two ways to solve this quesiton.\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 245 videos as of August 21th.\\n\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nhttps://youtu.be/Fx7dQgDcZXU\\n\\n---\\n\\n# Approach1 with O(n^2) time\\nThis is based on Python. Other might be different a bit.\\n\\n**1. Iterate through potential substring lengths.**\\n- The code begins by calculating the length of the input string \\'s\\'. It then enters a loop that iterates through possible substring lengths, ranging from 1 to half of the string length (n // 2).\\n\\n**2. Check if the current length divides the string length evenly.**\\n- Within each loop iteration, the code verifies whether the current substring length \\'i\\' evenly divides the length of the string \\'s\\' using the modulo operation (n % i == 0). This condition ensures that the substring could be repeated to form the original string.\\n\\n**3. Compare the repeated substring with the original string.**\\n- If the current substring length is a valid divisor of the string length, the code extracts the substring of length \\'i\\' from the start of the string \\'s\\'. It then constructs a repeated string by replicating this substring a certain number of times (s[:i] * (n // i)). The code subsequently checks if this repeated substring matches the original string \\'s\\'. If they match, it signifies that the string \\'s\\' can indeed be formed by repeating this particular substring, and the function returns True.\\n\\n**4. Return False if no valid repeated substring is found.**\\n- In case the loop concludes without finding a valid repeated substring that can recreate the original string, the function returns False. This indicates that the input string cannot be generated through the repetition of any of its substrings.\\n\\nIn summary, the algorithm systematically examines all potential substring lengths to ascertain if any repeated substring can reconstruct the original string. If such a substring is identified, the function returns True; otherwise, it returns False.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(1)\\n\\n\\n# Approach2 with O(n) time\\n**1. Create a new string by concatenating the original string with itself.**\\n- The code starts by creating a new string, which is obtained by concatenating the original string \\'s\\' with itself (s + s).\\n\\n**2. Check if the original string is a substring of the concatenated string excluding the first and last characters.**\\n- The code then uses the \\'in\\' operator to check if the original string \\'s\\' is a substring of the concatenated string (s + s). However, the slice notation [1:-1] is applied to the concatenated string to exclude its first and last characters. This is because the original string cannot form a repeated substring pattern using the first and last characters of the concatenated string.\\n\\n**3. Return True if the condition is met, otherwise return False.**\\n- If the check for substring existence is successful, indicating that the original string can be formed by repeating a substring, the function returns True. If the condition is not met, it returns False, indicating that the original string cannot be formed by repeating any substring.\\n\\nIn summary, the algorithm creates a new string by doubling the original string and then checks whether the original string is a substring of the doubled string excluding the first and last characters. If this condition is satisfied, the function returns True; otherwise, it returns False.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code of Apporach1\\n```python []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        for i in range(1, n // 2 + 1):\\n            if n % i == 0 and s[:i] * (n // i) == s:\\n                return True\\n        \\n        return False\\n```\\n```javascript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    const n = s.length;\\n\\n    for (let i = 1; i <= Math.floor(n / 2); i++) {\\n        if (n % i === 0 && s.slice(0, i).repeat(n / i) === s) {\\n            return true;\\n        }\\n    }\\n    \\n    return false;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0 && s.substring(0, i).repeat(n / i).equals(s)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                string repeated = \"\";\\n                for (int j = 0; j < n / i; j++) {\\n                    repeated += s.substr(0, i);\\n                }\\n                if (repeated == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n# Code of Apporach2\\n```python []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s+s)[1:-1]\\n```\\n```javascript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    return (s + s).substring(1, s.length * 2 - 1).includes(s);    \\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String concatenated = s + s;\\n        return concatenated.substring(1, concatenated.length() - 1).contains(s);\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string concatenated = s + s;\\n        return concatenated.substr(1, concatenated.length() - 2).find(s) != string::npos;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        for i in range(1, n // 2 + 1):\\n            if n % i == 0 and s[:i] * (n // i) == s:\\n                return True\\n        \\n        return False\\n```\n```javascript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    const n = s.length;\\n\\n    for (let i = 1; i <= Math.floor(n / 2); i++) {\\n        if (n % i === 0 && s.slice(0, i).repeat(n / i) === s) {\\n            return true;\\n        }\\n    }\\n    \\n    return false;    \\n};\\n```\n```java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0 && s.substring(0, i).repeat(n / i).equals(s)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                string repeated = \"\";\\n                for (int j = 0; j < n / i; j++) {\\n                    repeated += s.substr(0, i);\\n                }\\n                if (repeated == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s+s)[1:-1]\\n```\n```javascript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    return (s + s).substring(1, s.length * 2 - 1).includes(s);    \\n};\\n```\n```java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String concatenated = s + s;\\n        return concatenated.substring(1, concatenated.length() - 1).contains(s);\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string concatenated = s + s;\\n        return concatenated.substr(1, concatenated.length() - 2).find(s) != string::npos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212659,
                "title": "java-one-line-solution",
                "content": "class Solution {\\n    public boolean repeatedSubstringPattern(String string) {\\n        return ((string + string).indexOf(string, 1) != string.length());\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean repeatedSubstringPattern(String string) {\\n        return ((string + string).indexOf(string, 1) != string.length());\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 235383,
                "title": "javascript",
                "content": "**\\u65B9\\u6CD51:** \\u66B4\\u529B\\u7834\\u89E3\\u6CD5\\n**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u4F7F\\u7528repeat\\u65B9\\u6CD5\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar repeatedSubstringPattern = function(s) {\\n  for (let i = 1; i < s.length; i++) {\\n    if (s.length % i === 0 && s.slice(0, i).repeat(s.length / i) === s) return true;\\n  }\\n  return false;\\n};\\n```\\n\\n**\\u65B9\\u6CD52:** \\u91CD\\u590D\\u5B57\\u7B26\\u4E32\\u6CD5\\n**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u91CD\\u590D\\u5B57\\u7B26\\u4E32, \\u53BB\\u9664\\u9996\\u5C3E\\u4E24\\u4E2A\\u5B57\\u7B26.\\n2. \\u5982\\u679C\\u662F\\u5B50\\u5B57\\u7B26\\u4E32\\u6784\\u6210\\u7684, \\u90A3\\u4E48\\u5E94\\u8BE5\\u5B58\\u5728\\u4E8E\\u91CD\\u590D\\u7684\\u5B57\\u7B26\\u4E32\\u4E2D.\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar repeatedSubstringPattern = function(s) {\\n  const str = s + s;\\n  return str.slice(1, str.length - 1).includes(s);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar repeatedSubstringPattern = function(s) {\\n  for (let i = 1; i < s.length; i++) {\\n    if (s.length % i === 0 && s.slice(0, i).repeat(s.length / i) === s) return true;\\n  }\\n  return false;\\n};\\n```\n```\\nvar repeatedSubstringPattern = function(s) {\\n  const str = s + s;\\n  return str.slice(1, str.length - 1).includes(s);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213464,
                "title": "java-1-line-clever-solution-that-i-came-across",
                "content": "```\\npublic boolean repeatedSubstringPattern(String s) {\\n\\treturn (s+s).substring(1,2*s.length()-1).contains(s);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean repeatedSubstringPattern(String s) {\\n\\treturn (s+s).substring(1,2*s.length()-1).contains(s);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94335,
                "title": "java-o-n-2-accepted-solution",
                "content": "```\\n    public boolean repeatedSubstringPattern(String str) {\\n        for(int i = 1; i <= str.length()/2; i++) {\\n            String pattern = str.substring(0, i);\\n            if(isRepeated(str.substring(i), pattern)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean isRepeated(String s, String pattern) {\\n        if(s == null || s.isEmpty()) {\\n            return true;\\n        }\\n        if(!s.startsWith(pattern)) {\\n            return false;\\n        }\\n        \\n        return isRepeated(s.substring(pattern.length()), pattern);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean repeatedSubstringPattern(String str) {\\n        for(int i = 1; i <= str.length()/2; i++) {\\n            String pattern = str.substring(0, i);\\n            if(isRepeated(str.substring(i), pattern)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean isRepeated(String s, String pattern) {\\n        if(s == null || s.isEmpty()) {\\n            return true;\\n        }\\n        if(!s.startsWith(pattern)) {\\n            return false;\\n        }\\n        \\n        return isRepeated(s.substring(pattern.length()), pattern);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3251626,
                "title": "easy-java-2-lines-solution",
                "content": "\\n# Code\\n```java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String concatenated = s+s;\\n        return concatenated.substring(1,concatenated.length()-1).contains(s);\\n    }\\n}\\n```\\n![upvote1.png](https://assets.leetcode.com/users/images/6cf8d222-6eb5-420d-940a-264691c3549a_1677842430.2708967.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String concatenated = s+s;\\n        return concatenated.substring(1,concatenated.length()-1).contains(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94379,
                "title": "simple-python-solution-beat-100-in-49ms",
                "content": "'''\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, str):\\n        \"\"\"\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        ss = (str*2)[1:-1]\\n        return str in ss\\n'''",
                "solutionTags": [],
                "code": "'''\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, str):\\n        \"\"\"\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        ss = (str*2)[1:-1]\\n        return str in ss\\n'''",
                "codeTag": "Java"
            },
            {
                "id": 1182123,
                "title": "python-python3-solution-with-explanation-ans-easy-understanding",
                "content": "**Code:**\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        length = len(s) # compute the length of the string\\n        for i in range(1,length//2+1): # run the loop for length / 2 times\\n            if length % i == 0 and s[:i] * (length//i) == s: if length mod i is equal to zero and the string upto i * length divided by i is equal to s then return True \\n                return True\\n        return False\\n```\\nExample is explained below:\\ns = \"abcabcabcabc\"\\nOutput: True\\n\\nExplanation :\\nStep 1: length = 12\\nStep 2: run the loop length by 2 times from 1\\nWhy we need to run loop from 1 to length //2 times?\\n* s[:i] will take the characters before i.\\t\\t\\n* length //2 times is because of to recude the loop running and we will compute our output with the length // 2 times itself.\\n\\nStep 3: enters the if length % i ==0 and s[:i] * (length //i) ==s:\\n* i:1 =>12 % 1 = 0 and s[:1] =\\'a\\' * 12 // 1(12) == \\'abcabcabcabc\\'\\nTrue and False = False\\n* i:2 =>12 % 2 = 0 and s[:2] =\\'ab\\' * 12 // 2(6) == \\'abcabcabcabc\\'\\nTrue and False = False\\n* i:1 =>12 % 3 = 0 and s[:3] =\\'abc\\' * 12 // 3(4) == \\'abcabcabcabc\\'\\nTrue and True = True => Enter the if returns True.\\n\\n\\n\\n\\n***We rise by lifting others***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        length = len(s) # compute the length of the string\\n        for i in range(1,length//2+1): # run the loop for length / 2 times\\n            if length % i == 0 and s[:i] * (length//i) == s: if length mod i is equal to zero and the string upto i * length divided by i is equal to s then return True \\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826214,
                "title": "c-kmp-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        \\n        int n=s.length();\\n        vector<int> dp(n,0);\\n        \\n        int i=1;\\n        int j=0;\\n        \\n        for(i=1;i<n;)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                j++;\\n                dp[i]=j;\\n                i++;\\n            }\\n            else\\n            {\\n                if(j!=0)\\n                {\\n                    j=dp[j-1];\\n                }\\n                else\\n                {\\n                    dp[i]=0;\\n                    i++;\\n                }\\n            }\\n        }\\n        \\n        return dp[n-1] && (dp[n-1]%(n-dp[n-1])==0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        \\n        int n=s.length();\\n        vector<int> dp(n,0);\\n        \\n        int i=1;\\n        int j=0;\\n        \\n        for(i=1;i<n;)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                j++;\\n                dp[i]=j;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 444086,
                "title": "python-kmp-explained",
                "content": "KMP alg is used to find a substring (word) in a string. If the characters in the word are distinct then you rarely find matches in the string by bruteforce method and it works as O(N). However if the beginning of the word repeats, then we can have something like \\'aaaaaa...aaab\\' where we could find that there is no match with the parent string only at the last character, and KMP algorithm deals with that problem.\\n\\nThis is also the task in this problem, where we need to find if some beginning part of the word composes the word by repeating itself. \\n\\nThat\\'s why we build the table T for the word that contains information where we should return our pointer when we matched first N characters of the word with some other string and the character N + 1 does not match. If we have a word \"patternpatr\" and a string \"patternpat^ternpatr\" then \"t\" does not match with \"r\" and we should return our pointer to the first \"pat\". Normally we have a word like \"abcd\" and if b,c,d do not match like in \"abc^e\" we just return to \"a\" and check if \"e\" is \"a\", so T contains 0 at ^. For \"abcd^a\" if the second \\'a\\' doesn\\'t match we just skip to the next character in the string without any checks and start allover, so T contains -1 at ^.\\n\\nThe numbers in T other than 0 and -1 are rare and are the most interesting for this problem. Because basically they represent the number of characters that repeated the beginning before the pattern stopped reproducing. And they come from a counter, which is called \"pos\" in the code below, which remains hidden, and appears in the table only when the pattern breaks. \\n\\nSo if we have a repeating pattern in the beginning of the word, the numbers of T could look like whatever for this pattern, their purpose is to return us to the right place in this pattern UNTIL we hit the next occurence of the full pattern. After that the counter \"pos\" just increases while the pattern repeats itself.\\n\\nTherefore, if we have a repeating pattern, then in the end \"len(s) - pos\" will be equal to the size of this pattern, because this pattern repeated itself for \"pos\" number of characaters till the end of the word \"s\", and otherwise \"len(s) % (len(s) - pos) !=0\"\\n\\nP. S. Since in Python find() (or \"in\") is standard for strings and it is also O(N), a very elegant solution used by other users is just to check if s in (s+s)[1:-1]. But under the hood one would of course use KMP to find \"s\" in the larger string, so it\\'s still worth understanding why KMP is useful and how it gives us the direct answer in O(N) without any explicit matching of a substring within a larger string.\\n\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        if len(s) <= 1:\\n            return False\\n        T = [-1 for c in s]\\n        pos = 0\\n        for i in range(1, len(s)):\\n            if s[i] == s[pos]:\\n                T[i] = T[pos]\\n            else:\\n                T[i] = pos\\n                pos = T[pos]\\n                while pos >= 0 and s[i] != s[pos]:\\n                    pos = T[pos]\\n            pos += 1\\n        lens = len(s) - pos\\n        if lens == 0 or len(s) % lens != 0 or len(s) == lens:\\n            return False\\n        return True\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        if len(s) <= 1:\\n            return False\\n        T = [-1 for c in s]\\n        pos = 0\\n        for i in range(1, len(s)):\\n            if s[i] == s[pos]:\\n                T[i] = T[pos]\\n            else:\\n                T[i] = pos\\n                pos = T[pos]\\n                while pos >= 0 and s[i] != s[pos]:\\n                    pos = T[pos]\\n            pos += 1\\n        lens = len(s) - pos\\n        if lens == 0 or len(s) % lens != 0 or len(s) == lens:\\n            return False\\n        return True\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818673,
                "title": "python-97-68-faster-two-solutions-one-liner",
                "content": "**Solution 1 :**\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\t# Here we checking that s is present in a new string double of s which after remvoing fast and last element\\n        return s in s[1:] + s[:-1] \\n```\\n\\n**Solution 2 :**\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n,t=len(s),\\'\\'\\n        for i in range(n//2):\\n            t+=s[i]\\n            if t*(n//(i+1))==s: return True\\n        return False\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\t# Here we checking that s is present in a new string double of s which after remvoing fast and last element\\n        return s in s[1:] + s[:-1] \\n```\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n,t=len(s),\\'\\'\\n        for i in range(n//2):\\n            t+=s[i]\\n            if t*(n//(i+1))==s: return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304034,
                "title": "python-93-74-fasters-python-simplest-solution-with-explanation-beg-to-adv-slicing",
                "content": "```python\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:] + s[:-1]\\n```\\n```python\\nExample:\\nTo find if the string has a repeatable substring inside, we can create a new string by duplicating the original string.\\nEx. \"abcabc\" => \"abcabcabcabc\"\\nBy removing the first and last character of the new string we create the string \"bcabcabcabcab\"\\nIf the original string \"abcabc\" is in \"bcabcabcab\", we return true.\\n\\nWhy it works:\\nIf the original string has a repeating substring, the repeating substring can be no larger than 1/2 the length of the original string. I.e \"xyxy\" would be \"xy\"\\nBy repeating the string and removing the first and last character of the new string, I.e \"xyxyxyxy\" => \"yxyxyx\", if the original string \"xyxy\" can be found in \"yxyxyx\", it means that \"xyxy\" has a repeating substring.\\n\\nHowever, this solution doesn\\'t tell us what the repeating substring is, but does solve the question if it exists.\\n```\\n\\n![image](https://assets.leetcode.com/users/images/0840b211-ac16-48de-9bb6-d324748aed00_1658231895.0107276.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:] + s[:-1]\\n```\n```python\\nExample:\\nTo find if the string has a repeatable substring inside, we can create a new string by duplicating the original string.\\nEx. \"abcabc\" => \"abcabcabcabc\"\\nBy removing the first and last character of the new string we create the string \"bcabcabcabcab\"\\nIf the original string \"abcabc\" is in \"bcabcabcab\", we return true.\\n\\nWhy it works:\\nIf the original string has a repeating substring, the repeating substring can be no larger than 1/2 the length of the original string. I.e \"xyxy\" would be \"xy\"\\nBy repeating the string and removing the first and last character of the new string, I.e \"xyxyxyxy\" => \"yxyxyx\", if the original string \"xyxy\" can be found in \"yxyxyx\", it means that \"xyxy\" has a repeating substring.\\n\\nHowever, this solution doesn\\'t tell us what the repeating substring is, but does solve the question if it exists.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351474,
                "title": "java-solution-in-3-lines-with-explanation",
                "content": "```\\npublic boolean repeatedSubstringPattern(String s) {\\n    String doubled = s.repeat(2);\\n\\t// find the occurrence of the s starting from the 1st index\\n    // we cannot use 0 or else we will find the s itself\\n\\tint occurrenceIndex = doubled.indexOf(s, 1);\\n\\t// if found index equals to the length of the string, the s string does not have repeated pattern\\n    // e.g.\\n    // if we have s = `ab`, doubled = `abab`\\n    // occurrenceIndex == 2 which is pointing to the beginning of the s copy\\n    // `abab`\\n    //    ^\\n    // for s = `abab`, doubled = `abababab`\\n    // occurrenceIndex == 2. 2 < s.length(), so that we found the pattern\\n    // `abababab`\\n    //    ^\\n\\treturn occurrenceIndex != s.length();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean repeatedSubstringPattern(String s) {\\n    String doubled = s.repeat(2);\\n\\t// find the occurrence of the s starting from the 1st index\\n    // we cannot use 0 or else we will find the s itself\\n\\tint occurrenceIndex = doubled.indexOf(s, 1);\\n\\t// if found index equals to the length of the string, the s string does not have repeated pattern\\n    // e.g.\\n    // if we have s = `ab`, doubled = `abab`\\n    // occurrenceIndex == 2 which is pointing to the beginning of the s copy\\n    // `abab`\\n    //    ^\\n    // for s = `abab`, doubled = `abababab`\\n    // occurrenceIndex == 2. 2 < s.length(), so that we found the pattern\\n    // `abababab`\\n    //    ^\\n\\treturn occurrenceIndex != s.length();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 369467,
                "title": "simple-java-solution-with-explanation",
                "content": "Thought of this solution from the CTCI 1.9 problem \\nExample: **abcabc**\\nRotate by 1: **c**abcab\\nRotate by 2: **bc**abca\\nRotate by 3: **abc**abc which is equal to the original String indicates that there is a repeatation. \\nSo if you append the duplicate of the String and remove the first and last character it should contain the original string that is provided. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(removed char)a--- bc**abcabc**ab  ---c (removed char)\\n\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String ss = s + s;\\n        return ss.substring(1, ss.length()-1).contains(s);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String ss = s + s;\\n        return ss.substring(1, ss.length()-1).contains(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774294,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution { \\n\\tpublic boolean repeatedSubstringPattern(String s) {\\n\\t\\tString str=s+s;\\n\\t\\tString str1=str.substring(1, str.length()-1); \\n\\t\\treturn str1.contains(s);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution { \\n\\tpublic boolean repeatedSubstringPattern(String s) {\\n\\t\\tString str=s+s;\\n\\t\\tString str1=str.substring(1, str.length()-1); \\n\\t\\treturn str1.contains(s);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399126,
                "title": "c-kmp-algo-t-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> kmp_algo(string s){\\n        int len=0, i=1, n=s.size();\\n        vector<int> kmp(n,0);\\n        while(i<n){\\n            if(s[i]==s[len]){\\n                kmp[i]=len+1;\\n                i++;\\n                len++;\\n            }else{\\n                if(len!=0){\\n                    len=kmp[len-1];\\n                }else{\\n                    kmp[i]=0;\\n                    ++i;\\n                }\\n            }\\n        }\\n        return kmp;\\n    }\\n    \\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        auto kmp = kmp_algo(s);\\n        \\n        int len = n-kmp[n-1];\\n        if(kmp[n-1]%len == 0 && kmp[n-1]!=0) return true;\\n        return false;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kmp_algo(string s){\\n        int len=0, i=1, n=s.size();\\n        vector<int> kmp(n,0);\\n        while(i<n){\\n            if(s[i]==s[len]){\\n                kmp[i]=len+1;\\n                i++;\\n                len++;\\n            }else{\\n                if(len!=0){\\n                    len=kmp[len-1];\\n                }else{\\n                    kmp[i]=0;\\n                    ++i;\\n                }\\n            }\\n        }\\n        return kmp;\\n    }\\n    \\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        auto kmp = kmp_algo(s);\\n        \\n        int len = n-kmp[n-1];\\n        if(kmp[n-1]%len == 0 && kmp[n-1]!=0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856181,
                "title": "javascript-solution-459-one-line-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nlet repeatedSubstringPattern = function(s) {\\n    return s.repeat(2).slice(1, -1).includes(s);\\n};\\n```\\n**Runtime: 64 ms, faster than 99.67% of JavaScript online submissions for Repeated Substring Pattern.**\\n\\n**Memory Usage: 39.5 MB, less than 85.06% of JavaScript online submissions for Repeated Substring Pattern.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nlet repeatedSubstringPattern = function(s) {\\n    return s.repeat(2).slice(1, -1).includes(s);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 333119,
                "title": "python-12-ms-beats-99",
                "content": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        newstr = s[1:] + s[:-1]\\n        return newstr.find(s) != -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        newstr = s[1:] + s[:-1]\\n        return newstr.find(s) != -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 207312,
                "title": "c-1-line-with-explanation",
                "content": "There are 3 major parts in the code.\\nPart 1 ---Double the original string to get a new string:``` s+s```\\nPart 2 ---Scan the new string from the second charactor to the end with the original string: ```substr(1,2*s.size()-1).find(s)```\\nPart 3 ---If you can find it before the beginning of the second half of the new string: ```s.size()-1```,\\nthat means the original string has a repeated pattern, otherwise it doesn\\'t.\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) \\n    {  return (s+s).substr(1,2*s.size()-1).find(s)!=s.size()-1;  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` s+s```\n```substr(1,2*s.size()-1).find(s)```\n```s.size()-1```\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) \\n    {  return (s+s).substr(1,2*s.size()-1).find(s)!=s.size()-1;  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194064,
                "title": "one-line-code-stl-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# **Using find stl**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nadd the string str=s+s; and find s in str if u find it before the half size of str then it will return true (SEARCH FROM INDEX 1);\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nconstant space or zero space\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        return (s+s).find(s,1) < s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        return (s+s).find(s,1) < s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851811,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool can_make(string &key, string &s){\\n        int sub = key.length();\\n        \\n         for(int i{sub}; i < s.length(); i += sub)\\n            if(s.substr(i, sub) != key)\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        int right{1};\\n        string key{s[0]};\\n        \\n        while(right <= (n / 2)){  \\n            if(n % right == 0){\\n                if(can_make(key, s)) // If key can make s\\n                    return true;\\n            }\\n            \\n            key.push_back(s[right]);\\n            \\n            right++;\\n        }\\n        \\n       return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool can_make(string &key, string &s){\\n        int sub = key.length();\\n        \\n         for(int i{sub}; i < s.length(); i += sub)\\n            if(s.substr(i, sub) != key)\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        int right{1};\\n        string key{s[0]};\\n        \\n        while(right <= (n / 2)){  \\n            if(n % right == 0){\\n                if(can_make(key, s)) // If key can make s\\n                    return true;\\n            }\\n            \\n            key.push_back(s[right]);\\n            \\n            right++;\\n        }\\n        \\n       return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236527,
                "title": "repeated-substring-pattern-java-solution-with-explanation",
                "content": "**Approach:**\\n* Loop from i=len/2 i.e half of the string.\\n* Check if a substring of length \\'i\\' can be appended integer no of times to form the given string.(i.e check if len%i == 0.\\n* Take a substring sub from index 0 to i-1.\\n* Append the substring sub len/i times to a string builder st.\\n* if st.toString()==s,return true else i--\\n* Do this till i>=1.\\n![image](https://assets.leetcode.com/users/images/f058ffaf-3b0c-4f42-b831-c53d8a8515eb_1656934628.3738313.jpeg)\\n![image](https://assets.leetcode.com/users/images/22e9fafc-0f00-459c-847c-c5bfe0e699a4_1656934628.399924.jpeg)\\n\\n```\\nclass Solution \\n{\\n    public boolean repeatedSubstringPattern(String s) \\n    {\\n        int len = s.length();\\n        for(int i=len/2;i>=1;i--)\\n        {\\n            if(len%i == 0)\\n            {\\n                int repeats = len/i;\\n                String sub = s.substring(0,i);\\n                StringBuilder st = new StringBuilder();\\n                while(repeats-- > 0)\\n                    st.append(sub);\\n                if(st.toString().equals(s))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean repeatedSubstringPattern(String s) \\n    {\\n        int len = s.length();\\n        for(int i=len/2;i>=1;i--)\\n        {\\n            if(len%i == 0)\\n            {\\n                int repeats = len/i;\\n                String sub = s.substring(0,i);\\n                StringBuilder st = new StringBuilder();\\n                while(repeats-- > 0)\\n                    st.append(sub);\\n                if(st.toString().equals(s))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585318,
                "title": "python-one-liner",
                "content": "```\\n\\ndef repeatedSubstringPattern(s):\\n        return s in (s+s)[1:-1]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\ndef repeatedSubstringPattern(s):\\n        return s in (s+s)[1:-1]",
                "codeTag": "Python3"
            },
            {
                "id": 3938867,
                "title": "python3-beats-98-9-with-explanation-for-o-n",
                "content": "# Intuition\\n\\nShould I concat origibal string twice?\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s think my string s contains of two substring s1 and s2 that means s = (s1)(s2) and I have to check s1==s2 or not.\\n\\nAfter concatinating, my new string will look like (s1s2)(s1s2)\\n\\nnewS = s1s2s1s2\\n\\nLet\\'s remove the first and last character from newS, in order to manipulate the original string. After removing can we say, my newS will look like,\\n\\nnewS = s3s2s1s4 , as s3 and s4 are string after removing character\\n\\nNow let\\'s find out if s exists in newS or not, s=s1s2 can only exist\\nif s2s1 = s1s2\\n\\nNow let\\'s take a step back and think at what condition, s1s2 will be equal to s2s1?? Can I say, when s1=s2 only at that time s1s2=s2s1?\\n\\nthat means if s contains in newS, at that time we can say s1=s2 which means s =s1(s1)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) --> to check contains or not\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:]+s[:len(s)-1]\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:]+s[:len(s)-1]\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938737,
                "title": "c-uses-sieve-divisor-1-line-methods-solving-string-hard-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaybe it is shooting birds with a cannon.\\nUse sieve method to test whether n=s.length is a prime.\\nIf not, use the divisor i, n/i to test whether the string is the pattern.\\n\\nSecond approach doesn\\'t use any cannon and based on the divisors which is also fast.\\n\\nThird approach is a one line solution! \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe following is the demo for sieve method\\n[https://youtu.be/7GGhURLPnIs](https://youtu.be/7GGhURLPnIs)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code using sieve method Beats 95.17% in 11 ms\\n```\\nclass Solution {\\npublic:\\n    //Use sieve method to list a prime table\\n    vector<bool> isPrime;\\n    void sieve(int n){\\n        isPrime.assign(n+1, 1);\\n        isPrime[0]=isPrime[1]=0;\\n        int&& n_sqrt=int(sqrt(n));\\n        for(int&& i=2; i<=n_sqrt; i++){\\n            if (isPrime[i]){\\n                for(int j=i*i ; j<=n; j+=i)\\n                    isPrime[j]=0;\\n            }\\n        }\\n    }\\n    string repeatString(string& s , int k){\\n        string ans=\"\";\\n        for(int i=0; i<k; i++){\\n            ans+=s;\\n        }\\n        return ans;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        if (n==1) return 0;\\n        sieve(n); \\n        char s0=s[0];\\n        if (isPrime[n]){// only divisor 1 & n\\n            return string(n, s0)==s;\\n        }\\n        int sqrt_n=sqrt(n);\\n        for(int i=1; i<=sqrt_n; i++){\\n            if (n%i==0){\\n                if (s0==s[i]){\\n                    string ss=s.substr(0, i);\\n                    if (s==repeatString(ss, n/i)) \\n                        return 1;\\n                }\\n                if (s[n/i]==s0){\\n                    string ss=s.substr(0, n/i);\\n                    if (s==repeatString(ss, i))\\n                        return 1;\\n                }              \\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n# Using divisor method Beats 95.17% in 11 ms\\n```\\n    string repeatString(string& s , int k){\\n        string ans=\"\";\\n        for(int i=0; i<k; i++){\\n            ans+=s;\\n        }\\n        return ans;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        if (n==1) return 0;\\n        char s0=s[0];\\n        int d=0, k;\\n        int sqrt_n=sqrt(n);\\n        for(int i=1; i<=sqrt_n; i++){\\n            if (n%i==0){\\n                if (s0==s[i]){\\n                    string ss=s.substr(0, i);\\n                    if (s==repeatString(ss, n/i)) \\n                        return 1;\\n                }\\n                if (s[n/i]==s0 && i!=1){\\n                    string ss=s.substr(0, n/i);\\n                    if (s==repeatString(ss, i))\\n                        return 1;\\n                }              \\n            }\\n        }\\n        return 0;\\n    }\\n```\\n# One line solution\\n```\\nreturn (s+s).substr(1, s.size()*2-2).find(s)!=-1;\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Use sieve method to list a prime table\\n    vector<bool> isPrime;\\n    void sieve(int n){\\n        isPrime.assign(n+1, 1);\\n        isPrime[0]=isPrime[1]=0;\\n        int&& n_sqrt=int(sqrt(n));\\n        for(int&& i=2; i<=n_sqrt; i++){\\n            if (isPrime[i]){\\n                for(int j=i*i ; j<=n; j+=i)\\n                    isPrime[j]=0;\\n            }\\n        }\\n    }\\n    string repeatString(string& s , int k){\\n        string ans=\"\";\\n        for(int i=0; i<k; i++){\\n            ans+=s;\\n        }\\n        return ans;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        if (n==1) return 0;\\n        sieve(n); \\n        char s0=s[0];\\n        if (isPrime[n]){// only divisor 1 & n\\n            return string(n, s0)==s;\\n        }\\n        int sqrt_n=sqrt(n);\\n        for(int i=1; i<=sqrt_n; i++){\\n            if (n%i==0){\\n                if (s0==s[i]){\\n                    string ss=s.substr(0, i);\\n                    if (s==repeatString(ss, n/i)) \\n                        return 1;\\n                }\\n                if (s[n/i]==s0){\\n                    string ss=s.substr(0, n/i);\\n                    if (s==repeatString(ss, i))\\n                        return 1;\\n                }              \\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\n    string repeatString(string& s , int k){\\n        string ans=\"\";\\n        for(int i=0; i<k; i++){\\n            ans+=s;\\n        }\\n        return ans;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        if (n==1) return 0;\\n        char s0=s[0];\\n        int d=0, k;\\n        int sqrt_n=sqrt(n);\\n        for(int i=1; i<=sqrt_n; i++){\\n            if (n%i==0){\\n                if (s0==s[i]){\\n                    string ss=s.substr(0, i);\\n                    if (s==repeatString(ss, n/i)) \\n                        return 1;\\n                }\\n                if (s[n/i]==s0 && i!=1){\\n                    string ss=s.substr(0, n/i);\\n                    if (s==repeatString(ss, i))\\n                        return 1;\\n                }              \\n            }\\n        }\\n        return 0;\\n    }\\n```\n```\\nreturn (s+s).substr(1, s.size()*2-2).find(s)!=-1;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545887,
                "title": "shortest-and-best-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public static boolean repeatedSubstringPattern(String s) {\\n        String str = s + s;\\n        String str1 = str.substring(1, str.length() - 1);\\n        return str1.contains(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean repeatedSubstringPattern(String s) {\\n        String str = s + s;\\n        String str1 = str.substring(1, str.length() - 1);\\n        return str1.contains(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892885,
                "title": "c-easy-3-solutions-o-n",
                "content": "### 3 different solutions\\n\\n<br>\\n\\n1. Doubling the array (One liner)\\n\\n```\\n\\tbool repeatedSubstringPattern(string s) {\\n        return (s+s).substr(1, (s.size()*2) - 2).find(s)!=-1;\\n\\t}\\n```\\n<br>\\n\\n2. Comparison by appending all possible substring of length <= n/2\\n\\n```\\nbool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        string s1 = \"\", s2 = \"\";\\n        for(int i=1; i<=n/2; i++) {\\n            if (n%i == 0) {\\n                s1 = s.substr(0, i);\\n                s2 = \"\";\\n                for(int j=0; j<n/i; j++) {\\n                    s2 += s1;\\n                }\\n                \\n                if(s==s2) return true;\\n            }\\n        }\\n\\t\\treturn false;\\n    }\\n```\\n\\n<br>\\n\\n3. Using KMP \"lps\" table as array\\n\\n```\\nbool repeatedSubstringPattern(string s) {\\n\\tint n = s.size();\\n\\n\\tif(n==1) return false;\\n\\n\\tvector<int> lps(n, 0);\\n\\n\\tint j=0;\\n\\tfor(int i=1; i<n; i++) {\\n\\t\\tif (s[i]==s[j]) {\\n\\t\\t\\tlps[i] = j+1;\\n\\t\\t\\tj++;\\n\\t\\t} else {\\n\\t\\t\\twhile(j>0) {\\n\\t\\t\\t\\tj = (j>0) ? lps[j-1] : 0;\\n\\t\\t\\t\\tif (s[i]==s[j]) {\\n\\t\\t\\t\\t\\tlps[i] = j+1;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (j==0) lps[i]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (lps[n-1]>0 && n%(n-lps[n-1]) == 0 ) {\\n\\t\\treturn true;\\n\\t} else {\\n\\t\\treturn false;\\n\\t}\\n}\\n```\\n\\nPlease do upvote if you find this helpful.\\nFeel free to comment down your queries.",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n\\tbool repeatedSubstringPattern(string s) {\\n        return (s+s).substr(1, (s.size()*2) - 2).find(s)!=-1;\\n\\t}\\n```\n```\\nbool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        string s1 = \"\", s2 = \"\";\\n        for(int i=1; i<=n/2; i++) {\\n            if (n%i == 0) {\\n                s1 = s.substr(0, i);\\n                s2 = \"\";\\n                for(int j=0; j<n/i; j++) {\\n                    s2 += s1;\\n                }\\n                \\n                if(s==s2) return true;\\n            }\\n        }\\n\\t\\treturn false;\\n    }\\n```\n```\\nbool repeatedSubstringPattern(string s) {\\n\\tint n = s.size();\\n\\n\\tif(n==1) return false;\\n\\n\\tvector<int> lps(n, 0);\\n\\n\\tint j=0;\\n\\tfor(int i=1; i<n; i++) {\\n\\t\\tif (s[i]==s[j]) {\\n\\t\\t\\tlps[i] = j+1;\\n\\t\\t\\tj++;\\n\\t\\t} else {\\n\\t\\t\\twhile(j>0) {\\n\\t\\t\\t\\tj = (j>0) ? lps[j-1] : 0;\\n\\t\\t\\t\\tif (s[i]==s[j]) {\\n\\t\\t\\t\\t\\tlps[i] = j+1;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (j==0) lps[i]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (lps[n-1]>0 && n%(n-lps[n-1]) == 0 ) {\\n\\t\\treturn true;\\n\\t} else {\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1761482,
                "title": "python-two-approaches-simple-and-easy",
                "content": "Approach 1:\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        N = len(s)\\n        for idx in range(1, N//2+1):\\n            if N%idx==0:\\n                subString = s[:idx]\\n                if subString*(N//idx) == s:\\n                    return True\\n        return False\\n```\\n\\nApproach 2:\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        newS = (s+s)[1:-1]\\n        return s in newS\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        N = len(s)\\n        for idx in range(1, N//2+1):\\n            if N%idx==0:\\n                subString = s[:idx]\\n                if subString*(N//idx) == s:\\n                    return True\\n        return False\\n```\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        newS = (s+s)[1:-1]\\n        return s in newS\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325804,
                "title": "simple-c-solution-with-detailed-explanation",
                "content": "``` \\n    bool repeatedSubstringPattern(string s) {\\n        if (s == \"\") {\\n            return false;\\n        }\\n        string doubleS = s + s;\\n        return doubleS.find(s, 1) < s.size();\\n    }\\n```\\nIf the input string length is 0, then it mens that there\\'s no way for it to be constructed with repeated substring, and we will return false.\\n\\nFor an input string s with length n (n >= 1), we can represent it as s = s[0]s[1]s[2]...s[n-1]. For any m in the range of 0 and n-1, s[m] is a char indexed at m in the input string s.\\n\\nWe define a rotation of the input string by removing the first char from it and concatenating the removed char to the end of the input string.\\n\\nFor example a rotation of the string s is s\\' = s[1]s[2]...s[n-1]s[0]. Two rotations of string s is to remove first two chars from s and concatenate them to the end of the string (i.e. s\\'\\' = s[2]s[3]...s[n-1]s[0]s[1]).\\n\\nWe can easily see that s is the same as itself after 0 or n times of rotations. What we will do is to prove that if string s\\' which is generated by s after m times (0 < m < n) of rotations is the same as s then s is composed by n/m substrings s[0]s[1]...s[m-1].\\n\\nIf the input string is s = s[0]s[1]s[2]...s[n-1], after m times (e.g. m = 3) of rotations the new string s\\' = s[3]s[4]s[5]...s[n-1]s[0]s[1]s[2].\\n\\nIf s = s\\' then\\ns[0]s[1]s[2]s[3]s[4]s[5]...s[n-6]s[n-5]s[n-4]s[n-3]s[n-2]s[n-1] is the same as\\ns[3]s[4]s[5]s[6]s[7]s[8]...s[n-3]s[n-2]s[n-1]s[0]s[1]s[2]\\n\\nso\\ns[0]s[1]s[2] = s[n-3]s[n-2]s[n-1]\\ns[3]s[4]s[5] = s[0]s[1]s[2]\\ns[6]s[7]s[8] = s[3]s[4]s[5]\\n.\\n.\\n.\\ns[n-3]s[n-2]s[n-1] = s[n-6]s[n-5]s[n-4]\\n\\nso\\ns[0]s[1]s[2] = s[3]s[4]s[5] = s[6]s[7]s[8] = ... = s[n-6]s[n-5]s[n-4] = s[n-3]s[n-2]s[n-1]\\n\\nso string s consists of n/m substrings s[0]s[1]...s[m-1], in the above proof m = 3.\\n\\nWith the above proof, if we can find a rotation m which is larger than 0 and less than n then the input string consists of repeated substrings.\\n\\nWe can concatenate the input string s which length is n with itself to form a new string str = s+s, if we can find a substring s in str which is indexed larger than 0 and lower than n then it means s can be the same as itself after m times of rotations where 0<m<n, then s must consist of repeated substrings.\\n",
                "solutionTags": [],
                "code": "``` \\n    bool repeatedSubstringPattern(string s) {\\n        if (s == \"\") {\\n            return false;\\n        }\\n        string doubleS = s + s;\\n        return doubleS.find(s, 1) < s.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1016467,
                "title": "kmp",
                "content": "```\\n/* When we finish creating the lps array, In this scenario, the last value will contain the Length of the largest substring. If we are deducting it from \\n   the length of the entire strin, we will get the length of the smallest substring pattern. which \\n   is 2 for String ABABAB. Suppose the string is ABCABCABC. ABCABCABC --> KMP Table will be : \\n   0 0 0 1 2 3 4 5 6. The value of the smallest substring will be 3 (ABC --> 9 (Length of the Entire \\n   String) - 6 (Last Value of the LPS Array)). */\\n\\n\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        if(null == s || s.trim().length() == 0){\\n            return false;\\n        }\\n        s = s.trim();\\n        int strLen = s.length();\\n        int lps[] = new int[strLen];\\n        createLPSArr(s, lps);\\n        int patternLen = strLen - lps[lps.length - 1];\\n        if(patternLen == strLen){\\n            return false;\\n        }\\n        if(s.length() % patternLen != 0){\\n            return false;\\n        }\\n        return true;\\n    }\\n    private void createLPSArr(String pattern, int[] lps){\\n        int patternLength = pattern.length();\\n        int i = 1;\\n        int j = 0;\\n        while(i < patternLength){\\n            if(pattern.charAt(i) == pattern.charAt(j)){\\n                j++;\\n                lps[i] = j;\\n                i++;\\n            }else {\\n                if(j == 0){\\n                    i++;\\n                }else{\\n                    j = lps[j-1];\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* When we finish creating the lps array, In this scenario, the last value will contain the Length of the largest substring. If we are deducting it from \\n   the length of the entire strin, we will get the length of the smallest substring pattern. which \\n   is 2 for String ABABAB. Suppose the string is ABCABCABC. ABCABCABC --> KMP Table will be : \\n   0 0 0 1 2 3 4 5 6. The value of the smallest substring will be 3 (ABC --> 9 (Length of the Entire \\n   String) - 6 (Last Value of the LPS Array)). */\\n\\n\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        if(null == s || s.trim().length() == 0){\\n            return false;\\n        }\\n        s = s.trim();\\n        int strLen = s.length();\\n        int lps[] = new int[strLen];\\n        createLPSArr(s, lps);\\n        int patternLen = strLen - lps[lps.length - 1];\\n        if(patternLen == strLen){\\n            return false;\\n        }\\n        if(s.length() % patternLen != 0){\\n            return false;\\n        }\\n        return true;\\n    }\\n    private void createLPSArr(String pattern, int[] lps){\\n        int patternLength = pattern.length();\\n        int i = 1;\\n        int j = 0;\\n        while(i < patternLength){\\n            if(pattern.charAt(i) == pattern.charAt(j)){\\n                j++;\\n                lps[i] = j;\\n                i++;\\n            }else {\\n                if(j == 0){\\n                    i++;\\n                }else{\\n                    j = lps[j-1];\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827897,
                "title": "c-24ms-o-n-find-prime-divisors-and-compare-explained",
                "content": "Firstly I should say this method is ristricted by the condition `string length will not exceed 10000`.\\n\\nSo, if we are able to find a repeated substring pattern in a string, the length of string `N` must either:\\n- N is **NOT** a prime number (is divisible by one or more integers that 2<= d < N)\\n- N is a prime number, and the string contains only one character that repeated N times\\n\\nIf we can find a pattern that is repeated, say, 6 times, we can also treat the string has patterns that repeat 2 or 3 times. Therefore, we only need to check **prime divisors**. \\n- N is divisible by one or more prime numbers that < 101 (since 101^2 > 10000)\\n- N is a prime number, and the string contains only one character that repeated N times\\n\\nSo we only need to check at most 25 times to find all the candidate divisions. Also since 2\\\\*3\\\\*5\\\\*7\\\\*11\\\\*13>10000, the number of candidates is at most 5.\\n\\nThen for each candidate `d`, we divide the string into `d` sections, and compare section 2 to section 1, then compare section 3 to section 2, and so on. If we find any unmatched character, quit the loop and try next candidate. If we successfully processed to the end of the string, a pattern is found.\\nWe use two pointers to do this comparison.\\n\\nThe worst case time complexity is O(25+5n), ie O(n).\\n\\n```cpp\\nbool repeatedSubstringPattern(string s) {\\n    const int N = s.size();\\n    const vector<int> primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\\n                             43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\\n    vector<int> divisors;\\n    int prod = 1;\\n    for (int p : primes) {\\n        if (prod*p > N) break;\\n        if (N%p == 0) {\\n            divisors.push_back(p);\\n            prod *= p;\\n        }\\n    }\\n\\n    for (int d : divisors) {\\n        int l = 0, r = N/d;\\n        for (; r < N; ++l, ++r) {\\n            if (s[l] != s[r]) break;\\n        }\\n        if (r == N) return true;\\n    }\\n    return false;\\n}\\n```\\n\\n----\\nWhat if the string length can be much much longer, or unlimited?\\nThen the KMP method might be a wiser choice. :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nbool repeatedSubstringPattern(string s) {\\n    const int N = s.size();\\n    const vector<int> primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\\n                             43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\\n    vector<int> divisors;\\n    int prod = 1;\\n    for (int p : primes) {\\n        if (prod*p > N) break;\\n        if (N%p == 0) {\\n            divisors.push_back(p);\\n            prod *= p;\\n        }\\n    }\\n\\n    for (int d : divisors) {\\n        int l = 0, r = N/d;\\n        for (; r < N; ++l, ++r) {\\n            if (s[l] != s[r]) break;\\n        }\\n        if (r == N) return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 541051,
                "title": "python-solution-with-in-depth-explanation",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        #the length of the substring has to be a divsor\\n        #of the original string\\n        \\n        #start at the half way mark and see if i to the \\n        #half way mark matches the rest of the string\\n        \\n        length = len(s)\\n        \\n        for i in range(length//2 , 0, -1):   \\n            if(length % i == 0):\\n                string = s[:i]\\n                times = length//i\\n                ns = \"\"\\n                for j in range(0,times):\\n                    ns+=string\\n                if(ns == s):\\n                    return True\\n        return False\\n\\'\\'\\'\\n\\nIn order to obtain our solution, what we first have to realize is that our substring length HAS to be easily divisible by the original string length. What this means is that our substring has to be a length that is a multiple of the original sting length (i.e. original string length = 9, which means our substring length has to be of length 3 (since 3 is the only divisible number by 9 --another example -- original string length = 4, substring  length has to be 2)\\n\\nThe easiest way to obtain a divsor of the original string is to start at the half way point. Why we start at the half way point is because we will build our substring starting at index 0, to the halfway point and compare this with the rest of the string. We decrement by -1 in the case where the halfway point is NOT divisble by the original string length (i.e. string length = 9, half = 4 which is not a divisor of 9, decrement by -1 to get 3 which will be the length of the substring)\\n\\n\"string = s[:i]\" will build our substring to match on the rest of the original string. We need to know how many times to mutiply this substring in order to get the length of our original string (so we can compare them) so we divide the length of our original string by the length of our substring to get the number of times we need to \"clone\" our string. This is what the second for loop is for.\\n\\nAfter the second for loop, we should have a new substring that is of length of the original string. We now compare this substring to see if it matches the original string. If it does, then we return true. \\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        #the length of the substring has to be a divsor\\n        #of the original string\\n        \\n        #start at the half way mark and see if i to the \\n        #half way mark matches the rest of the string\\n        \\n        length = len(s)\\n        \\n        for i in range(length//2 , 0, -1):   \\n            if(length % i == 0):\\n                string = s[:i]\\n                times = length//i\\n                ns = \"\"\\n                for j in range(0,times):\\n                    ns+=string\\n                if(ns == s):\\n                    return True\\n        return False\\n\\'\\'\\'\\n\\nIn order to obtain our solution, what we first have to realize is that our substring length HAS to be easily divisible by the original string length. What this means is that our substring has to be a length that is a multiple of the original sting length (i.e. original string length = 9, which means our substring length has to be of length 3 (since 3 is the only divisible number by 9 --another example -- original string length = 4, substring  length has to be 2)\\n\\nThe easiest way to obtain a divsor of the original string is to start at the half way point. Why we start at the half way point is because we will build our substring starting at index 0, to the halfway point and compare this with the rest of the string. We decrement by -1 in the case where the halfway point is NOT divisble by the original string length (i.e. string length = 9, half = 4 which is not a divisor of 9, decrement by -1 to get 3 which will be the length of the substring)\\n\\n\"string = s[:i]\" will build our substring to match on the rest of the original string. We need to know how many times to mutiply this substring in order to get the length of our original string (so we can compare them) so we divide the length of our original string by the length of our substring to get the number of times we need to \"clone\" our string. This is what the second for loop is for.\\n\\nAfter the second for loop, we should have a new substring that is of length of the original string. We now compare this substring to see if it matches the original string. If it does, then we return true. \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 479942,
                "title": "python-easy-solution",
                "content": "Let say s consists of n sub strings a, that is, s = n* a. So for s+s, which is 2n * a, there must be at least one s in (s+s)[1:-1].\\n```\\ndef repeatedSubstringPattern(self, s: str) -> bool:\\n        return (s + s)[1:-1].find(s) != -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef repeatedSubstringPattern(self, s: str) -> bool:\\n        return (s + s)[1:-1].find(s) != -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 140743,
                "title": "java-one-liner",
                "content": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        return ((s+s).substring(1, 2*s.length()-1).contains(s)); \\n    }\\n}\\n```\\nUpdate : Thanks to [liweiweiwei](https://leetcode.com/liweiweiwei/)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        return ((s+s).substring(1, 2*s.length()-1).contains(s)); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020376,
                "title": "2-line-python-solution-briefly-explained",
                "content": "# Approach\\nThis Python code defines a class `Solution` with a method `repeatedSubstringPattern` that checks if a given string `s` can be formed by repeating a substring within itself.\\n\\nHere\\'s a brief explanation of the code:\\n\\n1. `ss = (s + s)[1:-1]`: This line creates a new string `ss` by concatenating the input string `s` with itself (doubling it). `[1:-1]` slices this doubled string, removing the first and last characters. This effectively removes the first character of `s` and the last character of `s` from `ss`.\\n\\n2. `return s in ss`: This line checks if the original string `s` is a substring of `ss`. If it is, that means `s` can be formed by repeating a substring within itself, so the method returns `True`. Otherwise, it returns `False`.\\n\\nIn essence, this code checks if `s` can be constructed by repeating a portion of itself, and it does this by creating a new string `ss` where `s` is doubled and the first and last characters are removed. Then, it checks if `s` is a substring of `ss`. If it is, it returns `True`; otherwise, it returns `False`.\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        ss = (s+s)[1:-1]\\n        return s in ss\\n```\\n\\n**Please upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        ss = (s+s)[1:-1]\\n        return s in ss\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938585,
                "title": "beats-100-js-ts-java-c-c-c-php-python-python3-kotlin",
                "content": "---\\n![header_.png](https://assets.leetcode.com/users/images/ab4510d5-90e7-4616-b1e1-aac91ec90eea_1692159981.2067795.png)\\n\\n---\\n**Approach**\\nTo solve this problem, you can use a sliding window approach to check if the string `s` can be constructed by repeating a substring. Here\\'s an approach to solve this problem:\\n\\n1. Start with a window size of 1 and try to find a repeated substring within the given string `s`. Increase the window size until you reach half the length of the string. The reason for considering only half the length is that if the repeated substring is longer than half of the string, it cannot be repeated multiple times to form the original string.\\n\\n2. For each window size, check if the string `s` can be formed by repeating the substring of that size. If it can, return `true`.\\n\\n3. If you can\\'t find a repeated substring for all window sizes, return `false`.\\n\\n**Time Complexity**:\\nIn the worst case, you would need to check for repeated substrings for all possible window sizes from 1 to n/2. For each window size, you are comparing the substring with the original string, which takes O(n) time. Therefore, the overall time complexity of this approach is O(n^2).\\n\\n- Keep in mind that this is not the most efficient approach, but it\\'s simple and works within the given constraints. There are more optimized algorithms that can solve this problem in linear time complexity, but they are more complex to implement.\\n\\n---\\n```Javascript []\\nvar repeatedSubstringPattern = function(s) {\\n    const n = s.length;\\n    \\n    for (let len = 1; len <= n / 2; len++) {\\n        if (n % len === 0) {\\n            const substring = s.slice(0, len);\\n            let repeated = \\'\\';\\n            \\n            for (let i = 0; i < n / len; i++) {\\n                repeated += substring;\\n            }\\n            \\n            if (repeated === s) {\\n                return true;\\n            }\\n        }\\n    }\\n    \\n    return false;\\n};\\n```\\n```Typescript []\\nfunction repeatedSubstringPattern(s: string): boolean {\\n    const n = s.length;\\n    \\n    for (let len = 1; len <= n / 2; len++) {\\n        if (n % len === 0) {\\n            const repeatedSubstring = s.slice(0, len);\\n            let formedString = \"\";\\n            \\n            for (let i = 0; i < n / len; i++) {\\n                formedString += repeatedSubstring;\\n            }\\n            \\n            if (formedString === s) {\\n                return true;\\n            }\\n        }\\n    }\\n    \\n    return false;\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        \\n        for length in range(1, n // 2 + 1):\\n            if n % length == 0:  # Check only if length divides n\\n                substring = s[:length]\\n                times = n // length\\n                if substring * times == s:\\n                    return True\\n                \\n        return False\\n```\\n```Python []\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        n = len(s)\\n        for length in range(1, n // 2 + 1):  # Possible substring lengths\\n            if n % length == 0:  # Check if it\\'s a valid length for repetition\\n                substring = s[:length]\\n                if substring * (n // length) == s:  # Check if repetition works\\n                    return True\\n        return False\\n```\\n```Kotlin []\\nclass Solution {\\n    fun repeatedSubstringPattern(s: String): Boolean {\\n        val n = s.length\\n        \\n        for (i in 1..n / 2) {\\n            if (n % i == 0) {\\n                val substring = s.substring(0, i)\\n                val repeatedString = buildString { repeat(n / i) { append(substring) } }\\n                \\n                if (repeatedString == s) {\\n                    return true\\n                }\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n```\\n```Java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n\\n        for (int len = 1; len <= n / 2; len++) {\\n            if (n % len == 0) {\\n                String substring = s.substring(0, len);\\n                StringBuilder repeated = new StringBuilder();\\n\\n                for (int i = 0; i < n / len; i++) {\\n                    repeated.append(substring);\\n                }\\n\\n                if (repeated.toString().equals(s)) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n```PHP []\\nclass Solution {\\n    function repeatedSubstringPattern($s) {\\n        $n = strlen($s);\\n        \\n        // Iterate through possible substring lengths\\n        for ($len = 1; $len <= $n / 2; $len++) {\\n            if ($n % $len == 0) {  // Check if the length is a divisor of n\\n                $sub = substr($s, 0, $len);  // Get the current potential substring\\n                \\n                // Construct the new string using the current substring\\n                $newString = \"\";\\n                for ($i = 0; $i < $n / $len; $i++) {\\n                    $newString .= $sub;\\n                }\\n                \\n                // If the new string is equal to the original string, return true\\n                if ($newString == $s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;  // If no such substring found\\n    }\\n}\\n```\\n```C []\\n#include <stdbool.h>\\n#include <string.h>\\n\\nbool repeatedSubstringPattern(char *s) {\\n    int n = strlen(s);\\n    \\n    // Check divisors of n\\n    for (int i = 1; i <= n / 2; i++) {\\n        if (n % i == 0) {\\n            int numRepeats = n / i;\\n            \\n            // Create the potential substring\\n            char substring[i + 1];\\n            strncpy(substring, s, i);\\n            substring[i] = \\'\\\\0\\';\\n            \\n            // Construct the repeated string\\n            char repeatedString[n + 1];\\n            repeatedString[0] = \\'\\\\0\\';\\n            for (int j = 0; j < numRepeats; j++) {\\n                strcat(repeatedString, substring);\\n            }\\n            \\n            // Check if the constructed string matches the original string\\n            if (strcmp(repeatedString, s) == 0) {\\n                return true;\\n            }\\n        }\\n    }\\n    \\n    return false;\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        \\n        for (int len = 1; len <= n / 2; len++) {\\n            if (n % len == 0) {\\n                string substring = s.substr(0, len);\\n                string constructed = \"\";\\n                \\n                for (int i = 0; i < n / len; i++) {\\n                    constructed += substring;\\n                }\\n                \\n                if (constructed == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        int n = s.Length;\\n        \\n        for (int len = 1; len <= n / 2; len++) {\\n            if (n % len == 0) {\\n                string substring = s.Substring(0, len);\\n                StringBuilder sb = new StringBuilder();\\n\\n                for (int i = 0; i < n / len; i++) {\\n                    sb.Append(substring);\\n                }\\n\\n                if (sb.ToString() == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n---\\n![download.jpg](https://assets.leetcode.com/users/images/5196fec2-1dd4-4b82-9700-36c5a0e72623_1692159956.9446952.jpeg)\\n\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#",
                    "JavaScript",
                    "Kotlin",
                    "PHP",
                    "TypeScript"
                ],
                "code": "```Javascript []\\nvar repeatedSubstringPattern = function(s) {\\n    const n = s.length;\\n    \\n    for (let len = 1; len <= n / 2; len++) {\\n        if (n % len === 0) {\\n            const substring = s.slice(0, len);\\n            let repeated = \\'\\';\\n            \\n            for (let i = 0; i < n / len; i++) {\\n                repeated += substring;\\n            }\\n            \\n            if (repeated === s) {\\n                return true;\\n            }\\n        }\\n    }\\n    \\n    return false;\\n};\\n```\n```Typescript []\\nfunction repeatedSubstringPattern(s: string): boolean {\\n    const n = s.length;\\n    \\n    for (let len = 1; len <= n / 2; len++) {\\n        if (n % len === 0) {\\n            const repeatedSubstring = s.slice(0, len);\\n            let formedString = \"\";\\n            \\n            for (let i = 0; i < n / len; i++) {\\n                formedString += repeatedSubstring;\\n            }\\n            \\n            if (formedString === s) {\\n                return true;\\n            }\\n        }\\n    }\\n    \\n    return false;\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        \\n        for length in range(1, n // 2 + 1):\\n            if n % length == 0:  # Check only if length divides n\\n                substring = s[:length]\\n                times = n // length\\n                if substring * times == s:\\n                    return True\\n                \\n        return False\\n```\n```Python []\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        n = len(s)\\n        for length in range(1, n // 2 + 1):  # Possible substring lengths\\n            if n % length == 0:  # Check if it\\'s a valid length for repetition\\n                substring = s[:length]\\n                if substring * (n // length) == s:  # Check if repetition works\\n                    return True\\n        return False\\n```\n```Kotlin []\\nclass Solution {\\n    fun repeatedSubstringPattern(s: String): Boolean {\\n        val n = s.length\\n        \\n        for (i in 1..n / 2) {\\n            if (n % i == 0) {\\n                val substring = s.substring(0, i)\\n                val repeatedString = buildString { repeat(n / i) { append(substring) } }\\n                \\n                if (repeatedString == s) {\\n                    return true\\n                }\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n```\n```Java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n\\n        for (int len = 1; len <= n / 2; len++) {\\n            if (n % len == 0) {\\n                String substring = s.substring(0, len);\\n                StringBuilder repeated = new StringBuilder();\\n\\n                for (int i = 0; i < n / len; i++) {\\n                    repeated.append(substring);\\n                }\\n\\n                if (repeated.toString().equals(s)) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\n```PHP []\\nclass Solution {\\n    function repeatedSubstringPattern($s) {\\n        $n = strlen($s);\\n        \\n        // Iterate through possible substring lengths\\n        for ($len = 1; $len <= $n / 2; $len++) {\\n            if ($n % $len == 0) {  // Check if the length is a divisor of n\\n                $sub = substr($s, 0, $len);  // Get the current potential substring\\n                \\n                // Construct the new string using the current substring\\n                $newString = \"\";\\n                for ($i = 0; $i < $n / $len; $i++) {\\n                    $newString .= $sub;\\n                }\\n                \\n                // If the new string is equal to the original string, return true\\n                if ($newString == $s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;  // If no such substring found\\n    }\\n}\\n```\n```C []\\n#include <stdbool.h>\\n#include <string.h>\\n\\nbool repeatedSubstringPattern(char *s) {\\n    int n = strlen(s);\\n    \\n    // Check divisors of n\\n    for (int i = 1; i <= n / 2; i++) {\\n        if (n % i == 0) {\\n            int numRepeats = n / i;\\n            \\n            // Create the potential substring\\n            char substring[i + 1];\\n            strncpy(substring, s, i);\\n            substring[i] = \\'\\\\0\\';\\n            \\n            // Construct the repeated string\\n            char repeatedString[n + 1];\\n            repeatedString[0] = \\'\\\\0\\';\\n            for (int j = 0; j < numRepeats; j++) {\\n                strcat(repeatedString, substring);\\n            }\\n            \\n            // Check if the constructed string matches the original string\\n            if (strcmp(repeatedString, s) == 0) {\\n                return true;\\n            }\\n        }\\n    }\\n    \\n    return false;\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        \\n        for (int len = 1; len <= n / 2; len++) {\\n            if (n % len == 0) {\\n                string substring = s.substr(0, len);\\n                string constructed = \"\";\\n                \\n                for (int i = 0; i < n / len; i++) {\\n                    constructed += substring;\\n                }\\n                \\n                if (constructed == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        int n = s.Length;\\n        \\n        for (int len = 1; len <= n / 2; len++) {\\n            if (n % len == 0) {\\n                string substring = s.Substring(0, len);\\n                StringBuilder sb = new StringBuilder();\\n\\n                for (int i = 0; i < n / len; i++) {\\n                    sb.Append(substring);\\n                }\\n\\n                if (sb.ToString() == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2003734,
                "title": "java-very-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String a1=s+s;\\n        String a2=a1.substring(1,a1.length()-1);\\n        if(a2.contains(s)) return true;\\n        else return false;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String a1=s+s;\\n        String a2=a1.substring(1,a1.length()-1);\\n        if(a2.contains(s)) return true;\\n        else return false;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1868705,
                "title": "python-beats-94",
                "content": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        ds = (s+s)[1:-1]\\n        print (ds)\\n        \\n        return s in ds\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        ds = (s+s)[1:-1]\\n        print (ds)\\n        \\n        return s in ds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806593,
                "title": "simple-java-solution-better-than-88-of-solutions",
                "content": "# Logic :\\nIf the given string is made up of repeated substrings, then the lengths of those repeated substrings will be a factor of the length of the given string.\\n\\n#### Example :\\n\\nString of length 10.\\nxxxxxxxxxx\\n\\nThe factors of 10 = 5, 2, 1.\\n\\nSo, the repeated string can be of length 5, 2, 1.\\nxxxxx xxxxx\\nxx xx xx xx xx\\nx x x x x x x x x x.\\n\\nabcdeabcde, \"abcde\" is repeated.\\nababababab, \"ab\" is repeated.\\naaaaaaaaaaa, \"a\" is repeated.\\n\\n# Solution :\\n* Loop through the factors of the length of the given string.\\n* Using Sliding Window Approach, find out all the substrings taking the factors as the lengths of substrings. These substrings start after the previous substring has ended.\\n* Find out if all the substrings are equal, return true if such repetition is found.\\n* Return false, if no such repetition is found.\\n\\nThe solution is more efficient if we take the factors in descending order.\\n\\n#### Implementation :\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) \\n    {\\n        int len = s.length();\\n        int div=2;\\n        while(div<=len)\\n        {\\n            if(len%div==0)\\n            {\\n                int windowSize = len/div;\\n                // window size is equal to the factor\\n                String firstSubString = s.substring(0,windowSize);\\n                int start = windowSize;\\n                boolean substringRepeated = false;\\n                // Loop through all the remaining substrings\\n                while(start<len)\\n                {\\n                    String nextSubString = s.substring(start,start+windowSize);\\n                    start += windowSize;\\n                    if(firstSubString.equals(nextSubString)==false)\\n                    {\\n                        substringRepeated = false;\\n                        break;\\n                    }\\n                    substringRepeated = true;\\n                }\\n                if(substringRepeated)\\n                {\\n                    return true;\\n                }\\n            }\\n            div++;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nThis Solution takes around 10ms, and is better than around 88% of all Java Submissions.\\n\\nThis is my first time posting a solution on LeetCode. Please excuse any grammatical errors.",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) \\n    {\\n        int len = s.length();\\n        int div=2;\\n        while(div<=len)\\n        {\\n            if(len%div==0)\\n            {\\n                int windowSize = len/div;\\n                // window size is equal to the factor\\n                String firstSubString = s.substring(0,windowSize);\\n                int start = windowSize;\\n                boolean substringRepeated = false;\\n                // Loop through all the remaining substrings\\n                while(start<len)\\n                {\\n                    String nextSubString = s.substring(start,start+windowSize);\\n                    start += windowSize;\\n                    if(firstSubString.equals(nextSubString)==false)\\n                    {\\n                        substringRepeated = false;\\n                        break;\\n                    }\\n                    substringRepeated = true;\\n                }\\n                if(substringRepeated)\\n                {\\n                    return true;\\n                }\\n            }\\n            div++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154854,
                "title": "java-just-one-line",
                "content": "```\\nclass Solution {\\n    public static boolean repeatedSubstringPattern(String s) {\\n\\n        return (s.substring(1) + s.substring(0, s.length() - 1)).contains(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean repeatedSubstringPattern(String s) {\\n\\n        return (s.substring(1) + s.substring(0, s.length() - 1)).contains(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897535,
                "title": "beats-100-well-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        \\n        // the idea is to find the occurence of some of \\n        // the substring within the string.\\n        \\n        // concatenate 2 strings together.\\n        string double_string = s+s;\\n        \\n        // remove the first element and also the last one\\n        double_string = double_string.substr(1);\\n        double_string.pop_back();\\n        \\n        // if still you find s in this string, then\\n        // there are more than 1 duplications, because\\n        // now it has been joined by another same string\\n        // but first and last elements are gone.\\n        return double_string.find(s) != -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        \\n        // the idea is to find the occurence of some of \\n        // the substring within the string.\\n        \\n        // concatenate 2 strings together.\\n        string double_string = s+s;\\n        \\n        // remove the first element and also the last one\\n        double_string = double_string.substr(1);\\n        double_string.pop_back();\\n        \\n        // if still you find s in this string, then\\n        // there are more than 1 duplications, because\\n        // now it has been joined by another same string\\n        // but first and last elements are gone.\\n        return double_string.find(s) != -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441605,
                "title": "kmp-o-n",
                "content": "```cpp\\nclass Solution {\\nprivate:\\n    vector<int> getPrefix(const string& p) {\\n        int n = p.size();\\n        vector<int> prefix(n, 0);\\n        for (int i=1; i<n; i++) {\\n            int j = prefix[i-1];\\n            while (j and p[i] != p[j]) j = prefix[j-1];\\n            prefix[i] = p[i] == p[j] ? j+1 : prefix[i];\\n        }\\n        return prefix;\\n    }\\npublic:\\n    bool repeatedSubstringPattern(const string& s) {\\n        auto prefix = getPrefix(s);\\n        int n = s.length(), last = prefix.back(), size = n - last;\\n        return last and !(last % size);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    vector<int> getPrefix(const string& p) {\\n        int n = p.size();\\n        vector<int> prefix(n, 0);\\n        for (int i=1; i<n; i++) {\\n            int j = prefix[i-1];\\n            while (j and p[i] != p[j]) j = prefix[j-1];\\n            prefix[i] = p[i] == p[j] ? j+1 : prefix[i];\\n        }\\n        return prefix;\\n    }\\npublic:\\n    bool repeatedSubstringPattern(const string& s) {\\n        auto prefix = getPrefix(s);\\n        int n = s.length(), last = prefix.back(), size = n - last;\\n        return last and !(last % size);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350305,
                "title": "javascript-beats-both-100-1-line",
                "content": "```\\n\\n```var repeatedSubstringPattern = function(s) {\\n    return (s+s).substring(1, s.length*2-1).indexOf(s) != -1;\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 135210,
                "title": "python-common-o-n-solution",
                "content": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool \\n        \"\"\"\\n        for i in range(1, len(s)):\\n            if len(s) % i == 0 and int(len(s)/i) * s[:i] == s:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool \\n        \"\"\"\\n        for i in range(1, len(s)):\\n            if len(s) % i == 0 and int(len(s)/i) * s[:i] == s:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94349,
                "title": "z-function-o-n-solution",
                "content": "To solve this problem there was used z-function algorithm. Which calculates for each position how many characters starting from this position matches the prefix. Algorithm works in O(n) time;\\nTo check if there all characters are period we should check two conditions:\\n1) the length of prefix + zfunction value must be equal to the size of str. ( it will guarantee that exactly all elements exists in period\\n2) does characters between (i -- i+z[i]) and prefix covers all characters.\\n\\nI feel that there exists more elegant check for periods by using the z-function.  Any ideas about that?\\n\\n```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int n = str.length();\\n        int z[] = zFunction(str.toCharArray());\\n        \\n        for (int i=0; i<z.length; i++) {\\n            if (i+z[i]==n && z[i]*2>=str.length()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private int [] zFunction(char c[]) {\\n        int n = c.length;\\n        int z[] = new int[n];\\n        \\n        int left = 0;\\n        int mostRight = 0;\\n        \\n        for (int i=1; i<n; i++) {\\n            if (i<=mostRight) {\\n                z[i] = Math.min(mostRight-i+1, z[i-left]);\\n            } \\n            while (i+z[i]<n && c[i+z[i]] == c[z[i]]) {\\n                z[i]++;\\n            }\\n            if (i+z[i]-1>mostRight) {\\n                mostRight = i+z[i]-1;\\n                left = i;\\n            }\\n        }\\n        return z;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean repeatedSubstringPattern(String str) {\\n        int n = str.length();\\n        int z[] = zFunction(str.toCharArray());\\n        \\n        for (int i=0; i<z.length; i++) {\\n            if (i+z[i]==n && z[i]*2>=str.length()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private int [] zFunction(char c[]) {\\n        int n = c.length;\\n        int z[] = new int[n];\\n        \\n        int left = 0;\\n        int mostRight = 0;\\n        \\n        for (int i=1; i<n; i++) {\\n            if (i<=mostRight) {\\n                z[i] = Math.min(mostRight-i+1, z[i-left]);\\n            } \\n            while (i+z[i]<n && c[i+z[i]] == c[z[i]]) {\\n                z[i]++;\\n            }\\n            if (i+z[i]-1>mostRight) {\\n                mostRight = i+z[i]-1;\\n                left = i;\\n            }\\n        }\\n        return z;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94415,
                "title": "repeated-substring-pattern-simple-java-solution-using-kmp",
                "content": "```\\npublic class Solution {\\n    /* KMP pattern table construction part */\\n    public boolean repeatedSubstringPattern(String str) {\\n        int n = str.length(), cur = 0, j = 1;\\n        int[] pattern = new int[n];\\n        pattern[0] = 0;\\n        \\n        while( j<n ) {\\n            if( str.charAt(cur) == str.charAt(j) ) {\\n                pattern[j++] = ++cur;\\n            }\\n            else {\\n                if( cur == 0 )  pattern[j++] = 0;\\n                else cur = pattern[cur-1]; /* start from beginning of current matching pattern */\\n            }\\n        }\\n        \\n        return (pattern[n-1] > 0 && n%(n-pattern[n-1]) == 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /* KMP pattern table construction part */\\n    public boolean repeatedSubstringPattern(String str) {\\n        int n = str.length(), cur = 0, j = 1;\\n        int[] pattern = new int[n];\\n        pattern[0] = 0;\\n        \\n        while( j<n ) {\\n            if( str.charAt(cur) == str.charAt(j) ) {\\n                pattern[j++] = ++cur;\\n            }\\n            else {\\n                if( cur == 0 )  pattern[j++] = 0;\\n                else cur = pattern[cur-1]; /* start from beginning of current matching pattern */\\n            }\\n        }\\n        \\n        return (pattern[n-1] > 0 && n%(n-pattern[n-1]) == 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939992,
                "title": "o-n-sqrt-n-solution-c-sliding-window",
                "content": "# Intuition\\nThe size of repeatating string will always be divible by the total size.\\n# Approach\\nWe will check for all the mutiples of N (size of string).\\nAlso, let say we checked for the window size 8 and it was false, \\nthen obviously it will be false for it\\'s other factors like (4 , 2 , 1). \\n\\n# Complexity\\n- Time complexity: O(N* sqrt(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) to store this vector of indexes\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // this function will tkae O(N) time \\n    // as we will traverse every index only once\\n    bool check(string &s, int window, int &n) {\\n        vector<int> idxs; // starting index of all the parts \\n        for(int i=0;i<n;i+=window) {\\n            idxs.emplace_back(i);\\n        }\\n        int idx = idxs.back(), cnt=0;\\n        while(idx + cnt < n) {\\n            for(auto &i : idxs) \\n            if(s[i+cnt] != s[idx+cnt]) return false;\\n            cnt++;\\n        }\\n        return true;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        if(n==1) return false;\\n        for(int i=2;i*i<=n;i++) { // O(sqrt(N))\\n            if(n%(n/i) == 0   && check(s,n/i,n))\\n                return true; \\n            if(n%i ==0 && (n/i)%i != 0 && check(s,i,n)) \\n                return true;\\n        }\\n\\n        return check(s,1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sliding Window",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // this function will tkae O(N) time \\n    // as we will traverse every index only once\\n    bool check(string &s, int window, int &n) {\\n        vector<int> idxs; // starting index of all the parts \\n        for(int i=0;i<n;i+=window) {\\n            idxs.emplace_back(i);\\n        }\\n        int idx = idxs.back(), cnt=0;\\n        while(idx + cnt < n) {\\n            for(auto &i : idxs) \\n            if(s[i+cnt] != s[idx+cnt]) return false;\\n            cnt++;\\n        }\\n        return true;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n        if(n==1) return false;\\n        for(int i=2;i*i<=n;i++) { // O(sqrt(N))\\n            if(n%(n/i) == 0   && check(s,n/i,n))\\n                return true; \\n            if(n%i ==0 && (n/i)%i != 0 && check(s,i,n)) \\n                return true;\\n        }\\n\\n        return check(s,1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939601,
                "title": "c-full-explanation-simplest-solution",
                "content": "# Introduction:\\nThe given solution addresses the problem of determining whether a given string can be constructed by taking a substring of itself and appending multiple copies of that substring together.\\n\\n**Step 1: Concatenation**\\n\\nFirst, the solution concatenates the input string str with itself, effectively creating a new string where the original str is repeated twice. For example, if str is \"abc\", then (str + str) becomes \"abcabc\".\\n**Step 2: Searching for Substring**\\n2.The solution uses the .find() method, a string method in C++, to search for the first occurrence of the original str substring within the concatenated string. This search starts from index 1. The search is started from index 1 to exclude the original string itself from being found, as we are interested in finding repeated substrings.\\n\\n**Step 3: Comparison with Length**\\n3. After finding the substring, the solution compares the index of the found substring with the length of the original string str.\\n\\n**Step 4: Decision Making**\\n4. If the index of the found substring is less than the length of the original string, this implies that a repeated substring was found within the concatenated string after the first occurrence. This indicates that the original string can be constructed by appending multiple copies of a substring.\\n\\n\\nTime Complexity:**O(n)**\\nSpace Complexity: **O(n)**\\n**The solution has a linear time complexity and linear space.**\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string str) {\\n        return (str + str).find(str, 1) < str.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string str) {\\n        return (str + str).find(str, 1) < str.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938810,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        ds=(s+s)[1:-1]\\n        return s in ds\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        ds=(s+s)[1:-1]\\n        return s in ds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137907,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string temp= s+s;\\n        return temp.substr(1,temp.size()-2).find(s) != -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string temp= s+s;\\n        return temp.substr(1,temp.size()-2).find(s) != -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543091,
                "title": "c-easy-solution-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n       string mix=s+s;  //Adding string with it self\\n\\n       for(int i=1;i<n;i++)\\n       {\\n         string str=mix.substr(i,n);\\n         if(str==s) \\n              return true;\\n       }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n       string mix=s+s;  //Adding string with it self\\n\\n       for(int i=1;i<n;i++)\\n       {\\n         string str=mix.substr(i,n);\\n         if(str==s) \\n              return true;\\n       }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479599,
                "title": "python-c-java-beginner-level-2line-solution-as-simple-as-u-think-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q459. Repeated Substring Pattern***\\nGiven a string `s`, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        s_fold=s[1:]+s[:-1]\\n        return s in s_fold\\n```\\n**Runtime:**  55 ms\\t\\n**Memory Usage:**  14.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n     String str=s+s;\\n        return str.substring(1,str.length()-1).contains(s);\\n    }\\n}\\n```\\n**Runtime:**  91 ms\\t\\t\\n**Memory Usage:**  49.8 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string str=s+s;\\n        return str.substr(1,str.size()-2).find(s)!=-1;\\n    }\\n};\\n```\\n**Runtime:** 34 ms\\t\\n**Memory Usage:**  16.5 MB\\t\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        s_fold=s[1:]+s[:-1]\\n        return s in s_fold\\n```\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n     String str=s+s;\\n        return str.substring(1,str.length()-1).contains(s);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string str=s+s;\\n        return str.substr(1,str.size()-2).find(s)!=-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376770,
                "title": "c-comments-3-methods-with-without-function-faster-than-95",
                "content": "Without function \\n```\\nclass Solution\\n{\\npublic:\\n\\tbool repeatedSubstringPattern(string s){\\n\\t\\tint n = s.size();\\n\\t\\tfor (int i = 1; i < n; i++){\\n\\t\\t// to check if the string can be repeated to get the required string length\\n\\t\\t\\tif (n % i == 0){\\n\\t\\t\\t// getting the substring from 0 to i;\\n\\t\\t\\t\\tstring curr = s.substr(0, i);\\n\\t\\t\\t\\tbool flag = true;\\n\\t\\t\\t\\tfor (int j = i; j < n; j += curr.size()){\\n\\t\\t\\t\\t\\tif (curr != s.substr(j, i)){\\n\\t\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (flag)           return true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n};\\n```\\nWith function\\n```\\nclass Solution {\\npublic:\\n    string repeat(string s, int n){\\n        string k = \"\";\\n        for(int i=0; i<n; i++)            k+=s;\\n        return k;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n\\t\\tint n = s.size();\\n        for(int i=n/2; i>=1; i--){\\n            if(n%i==0){\\n                if((repeat(s.substr(0, i), n/i)==s))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nUsing KMP\\n```\\nvoid computeLPSArray(char str[], int M, int lps[])\\n{\\n    // length of the previous longest prefix suffix\\n    int len = 0;\\n    int i;  \\n    lps[0] = 0; // lps[0] is always 0\\n    i = 1;\\n  \\n    // the loop calculates lps[i] for i = 1 to M-1\\n    while (i < M) {\\n        if (str[i] == str[len]) {\\n            len++;\\n            lps[i] = len;\\n            i++;\\n        }\\n        else // (pat[i] != pat[len])\\n        {\\n            if (len != 0) {\\n                // This is tricky. Consider the example\\n                // AAACAAAA and i = 7.\\n                len = lps[len - 1];\\n  \\n                // Also, note that we do not increment i\\n                // here\\n            }\\n            else // if (len == 0)\\n            {\\n                lps[i] = 0;\\n                i++;\\n            }\\n        }\\n    }\\n}\\n  \\n// Returns true if str is repetition of one of its\\n// substrings else return false.\\nbool isRepeat(char str[])\\n{\\n    // Find length of string and create an array to\\n    // store lps values used in KMP\\n    int n = strlen(str);\\n    int lps[n];\\n  \\n    // Preprocess the pattern (calculate lps[] array)\\n    computeLPSArray(str, n, lps);\\n  \\n    // Find length of longest suffix which is also\\n    // prefix of str.\\n    int len = lps[n - 1];\\n  \\n    // If there exist a suffix which is also prefix AND\\n    // Length of the remaining substring divides total\\n    // length, then str[0..n-len-1] is the substring that\\n    // repeats n/(n-len) times (Readers can print substring\\n    // and value of n/(n-len) for more clarity.\\n    return (len > 0 && n % (n - len) == 0) ? true : false;\\n}\\n// kmp is from gfg\\n```\\nPlease upvote if you found it useful :)",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tbool repeatedSubstringPattern(string s){\\n\\t\\tint n = s.size();\\n\\t\\tfor (int i = 1; i < n; i++){\\n\\t\\t// to check if the string can be repeated to get the required string length\\n\\t\\t\\tif (n % i == 0){\\n\\t\\t\\t// getting the substring from 0 to i;\\n\\t\\t\\t\\tstring curr = s.substr(0, i);\\n\\t\\t\\t\\tbool flag = true;\\n\\t\\t\\t\\tfor (int j = i; j < n; j += curr.size()){\\n\\t\\t\\t\\t\\tif (curr != s.substr(j, i)){\\n\\t\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (flag)           return true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string repeat(string s, int n){\\n        string k = \"\";\\n        for(int i=0; i<n; i++)            k+=s;\\n        return k;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n\\t\\tint n = s.size();\\n        for(int i=n/2; i>=1; i--){\\n            if(n%i==0){\\n                if((repeat(s.substr(0, i), n/i)==s))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nvoid computeLPSArray(char str[], int M, int lps[])\\n{\\n    // length of the previous longest prefix suffix\\n    int len = 0;\\n    int i;  \\n    lps[0] = 0; // lps[0] is always 0\\n    i = 1;\\n  \\n    // the loop calculates lps[i] for i = 1 to M-1\\n    while (i < M) {\\n        if (str[i] == str[len]) {\\n            len++;\\n            lps[i] = len;\\n            i++;\\n        }\\n        else // (pat[i] != pat[len])\\n        {\\n            if (len != 0) {\\n                // This is tricky. Consider the example\\n                // AAACAAAA and i = 7.\\n                len = lps[len - 1];\\n  \\n                // Also, note that we do not increment i\\n                // here\\n            }\\n            else // if (len == 0)\\n            {\\n                lps[i] = 0;\\n                i++;\\n            }\\n        }\\n    }\\n}\\n  \\n// Returns true if str is repetition of one of its\\n// substrings else return false.\\nbool isRepeat(char str[])\\n{\\n    // Find length of string and create an array to\\n    // store lps values used in KMP\\n    int n = strlen(str);\\n    int lps[n];\\n  \\n    // Preprocess the pattern (calculate lps[] array)\\n    computeLPSArray(str, n, lps);\\n  \\n    // Find length of longest suffix which is also\\n    // prefix of str.\\n    int len = lps[n - 1];\\n  \\n    // If there exist a suffix which is also prefix AND\\n    // Length of the remaining substring divides total\\n    // length, then str[0..n-len-1] is the substring that\\n    // repeats n/(n-len) times (Readers can print substring\\n    // and value of n/(n-len) for more clarity.\\n    return (len > 0 && n % (n - len) == 0) ? true : false;\\n}\\n// kmp is from gfg\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353429,
                "title": "one-liner-c-solution-beats-97-percent-c-solutions-clear-and-crisp-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/73a3e741-ee3f-4145-9007-cd17b659a232_1659157603.8087559.png)\\n\\n\\n```\\nbool repeatedSubstringPattern(string s){\\n        return (s + s).substr(1, 2*s.length() - 2).find(s) != string :: npos;\\n    }\\n```\\n\\n**Explanation**\\n\\n![image](https://assets.leetcode.com/users/images/dd75d6e2-9828-4331-8b72-225485ad2687_1659158060.4675162.png)\\n\\n**We exclude first character and last character while searching of s in s+ s, because as we added the given string twice, then if there is a possibility of a pattern, then we can find the same s in s + s after excluding first and last characters of s + s**.\\n\\nPlease do upvote if you understood the solution!!",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nbool repeatedSubstringPattern(string s){\\n        return (s + s).substr(1, 2*s.length() - 2).find(s) != string :: npos;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2350001,
                "title": "python-one-liner-solution-96-tc-o-n",
                "content": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n\\treturn s in s[1:]+s[:-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n\\treturn s in s[1:]+s[:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250534,
                "title": "python-one-liner-faster-than-97-easy",
                "content": "METHOD USED:-If a string is made of repetitive substring, then you\\'ll find the string in a concatenated string with itself where first and last char is deleted.\\n\\nIF THIS HELP U KINDLY UPVOTE THIS TO HELP OTHERS TO GET THIS SOLUTION\\nIF U DONT GET IT KINDLY COMMENT AND FEEL FREE TO ASK\\nAND CORRECT MEIF I AM WRONG\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:]+s[:-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:]+s[:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239737,
                "title": "java-3-lines-with-clear-explanation-and-how-i-figure-it-out",
                "content": "first the solution\\n\\n```\\n     public boolean repeatedSubstringPattern(String s) {\\n            String ss = s + s;\\n            ss = ss.substring(1, ss.length() - 1);\\n            return ss.contains(s);\\n     }\\n```\\n\\n### how I figure it out?\\n\\nthis question is a proof question, you have to proof **P** (here is s contains multi substring) is true.\\n\\nbut maybe it\\'s hard to proof **P is true** directly.\\n\\nso we can use this logic below.\\n\\n>\\n> if P is true , then Q is true.\\n> if Q is false, then P must be false\\n\\nnow if **Q** is easy to proof, we will proof **P**.\\n\\nso for this question, what about the **Q**?\\n\\n\\n> suppose s contains multi substring.\\n> so s == xx\\n> then ss == xxxx\\n> then ss must conatins s, and s must exist in the middle of ss (except the first X and last X)\\n> in order to exclude the first and last X\\n> we use ss.substring(1, ss.length() -1);\\n\\n\\nnow we figure out the **Q**\\n\\n> ss must conatins s, and s must exist in the middle of ss (except the first X and last X)\\n\\nand **Q** is easy to proof. \\n\\nand we can proof **P**\\n\\nthat\\'s all",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n     public boolean repeatedSubstringPattern(String s) {\\n            String ss = s + s;\\n            ss = ss.substring(1, ss.length() - 1);\\n            return ss.contains(s);\\n     }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1904957,
                "title": "beginner-friendly-javascript-solution",
                "content": "We have removed 1st land lst character form str, now we are checking if s present in it ;\\nif pattern is there s+s can form new string str that includes s\\n\\n```\\nvar repeatedSubstringPattern = function(s) {\\n    let str = s+s\\n    return str.substring(1, str.length-1).includes(s)\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar repeatedSubstringPattern = function(s) {\\n    let str = s+s\\n    return str.substring(1, str.length-1).includes(s)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1774418,
                "title": "python-3-easy-solution",
                "content": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        sub = \\'\\'\\n        for i in range(n // 2):\\n            sub += s[i]\\n            k, r = divmod(n, i + 1)\\n            if r == 0 and sub * k == s:\\n                return True\\n        \\n        return False",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        sub = \\'\\'\\n        for i in range(n // 2):\\n            sub += s[i]\\n            k, r = divmod(n, i + 1)\\n            if r == 0 and sub * k == s:\\n                return True\\n        \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1751481,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string a=\"\",c;\\n        for(int i=0;i<s.length()/2;i++) //till half of the string since thats the max substring\\n        {\\n            a+=s[i]; //substring\\n            c=a;\\n            if(s.length()%c.length()==0) //checking if length of s is a multiple of length of subsrting\\n            {\\n                int n=s.length()/c.length(); //number of time suubstring need to be repeated\\n                while(n>1)\\n                {c+=a;n--;} //making the repeated substring\\n                if(c==s)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string a=\"\",c;\\n        for(int i=0;i<s.length()/2;i++) //till half of the string since thats the max substring\\n        {\\n            a+=s[i]; //substring\\n            c=a;\\n            if(s.length()%c.length()==0) //checking if length of s is a multiple of length of subsrting\\n            {\\n                int n=s.length()/c.length(); //number of time suubstring need to be repeated\\n                while(n>1)\\n                {c+=a;n--;} //making the repeated substring\\n                if(c==s)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630190,
                "title": "java-solution-with-comments",
                "content": "Logic of code:\\ns=abc\\nss= abcabc\\nbcab does not contain abc\\n\\ns=abab\\nss=abababab\\nb**abab**a contains abab\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) \\n    {\\n        boolean ans;\\n        String ss =s+s;\\n        \\n        ans=(ss.substring(1,ss.length()-1).contains(s));\\n        return ans;\\n    }\\n}\\n```\\n\\nHere `(ss.substring(1,ss.length()-1)` means removing 1st and last character of concatenated string",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) \\n    {\\n        boolean ans;\\n        String ss =s+s;\\n        \\n        ans=(ss.substring(1,ss.length()-1).contains(s));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594547,
                "title": "short-and-simple-c-solution",
                "content": "```\\n bool repeatedSubstringPattern(string s) {\\n        string str=s+s;\\n        string str2=str.substr(1,2*s.size()-2);\\n        if(str2.find(s)!=-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n bool repeatedSubstringPattern(string s) {\\n        string str=s+s;\\n        string str2=str.substr(1,2*s.size()-2);\\n        if(str2.find(s)!=-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1554697,
                "title": "python-easy-solution-to-understand",
                "content": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        i=1\\n        while(i!=(len(s)//2)+1):\\n            x=s[:i]\\n            i=i+1\\n            y=s.count(x)\\n            #print(x,y)\\n            if(y*len(x)==len(s)):\\n                return(True)\\n            \\n        return(False)\\n```\\nIf u understood the code plz..UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        i=1\\n        while(i!=(len(s)//2)+1):\\n            x=s[:i]\\n            i=i+1\\n            y=s.count(x)\\n            #print(x,y)\\n            if(y*len(x)==len(s)):\\n                return(True)\\n            \\n        return(False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357812,
                "title": "brute-force-20ms-cpp-solution",
                "content": "//All test cases will pass\\n\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        for(int len = 1; len<s.length(); len++){\\n            if(len>(s.length()/2)) break;\\n            if(s.length()%len) continue;\\n            int i;\\n            string str = s.substr(0,len);\\n            for(i=len; i<s.length(); i+=len){\\n                string temp = s.substr(i,len);\\n                if(temp!=str) break;\\n            }\\n            if(i==s.length()) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        for(int len = 1; len<s.length(); len++){\\n            if(len>(s.length()/2)) break;\\n            if(s.length()%len) continue;\\n            int i;\\n            string str = s.substr(0,len);\\n            for(i=len; i<s.length(); i+=len){\\n                string temp = s.substr(i,len);\\n                if(temp!=str) break;\\n            }\\n            if(i==s.length()) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285707,
                "title": "python-1-line-code-faster-than-95-33",
                "content": "Runtime: 28 ms, faster than 95.33% of Python3 online submissions for Repeated Substring Pattern.\\nMemory Usage: 14.3 MB, less than 80.00% of Python3 online submissions for Repeated Substring Pattern.\\n\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:]+s[:-1]",
                "solutionTags": [],
                "code": "Runtime: 28 ms, faster than 95.33% of Python3 online submissions for Repeated Substring Pattern.\\nMemory Usage: 14.3 MB, less than 80.00% of Python3 online submissions for Repeated Substring Pattern.\\n\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in s[1:]+s[:-1]",
                "codeTag": "Python3"
            },
            {
                "id": 1186619,
                "title": "python-3-simple-one-line-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        ## if s is composed of n copies of substring m where n >=2\\n        ## In the case where n = 2, \\n        ## s = m+m\\n        ## s+s = m+m+m+m\\n        ## In addition,\\n        ## make sure s cannot be matched in the head.\\n        ## make sure s cannot be matched at the tail.\\n        ## Chop off the first charcter of s. Call it s\\'\\n        ## Chop off the last character of s. Call it s\\'\\'\\n        ## s\\' = m\\' + m where m\\' is m minus first character\\n        ## s\\'\\' = m + m\\'\\' where m\\'\\' is m minus last character\\n        ## s\\' + s\\'\\' = m\\' + m + m + m\\'\\' = m\\' + s + m\\'\\'\\n        ## Note: if we just use s + s instead of s\\' + s\\'\\', it won\\'t work because s is always in s + s\\n        return s in s[1:]+s[:-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        ## if s is composed of n copies of substring m where n >=2\\n        ## In the case where n = 2, \\n        ## s = m+m\\n        ## s+s = m+m+m+m\\n        ## In addition,\\n        ## make sure s cannot be matched in the head.\\n        ## make sure s cannot be matched at the tail.\\n        ## Chop off the first charcter of s. Call it s\\'\\n        ## Chop off the last character of s. Call it s\\'\\'\\n        ## s\\' = m\\' + m where m\\' is m minus first character\\n        ## s\\'\\' = m + m\\'\\' where m\\'\\' is m minus last character\\n        ## s\\' + s\\'\\' = m\\' + m + m + m\\'\\' = m\\' + s + m\\'\\'\\n        ## Note: if we just use s + s instead of s\\' + s\\'\\', it won\\'t work because s is always in s + s\\n        return s in s[1:]+s[:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127925,
                "title": "my-python-solution",
                "content": "Hi guys here\\'s what I came up with. Cheers!\\n\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        \\n        for i in range(len(s)//2):\\n            floor, remainder = divmod(len(s), i + 1)\\n            if remainder == 0:\\n                if s[:i+1] * floor == s:\\n                    return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        \\n        for i in range(len(s)//2):\\n            floor, remainder = divmod(len(s), i + 1)\\n            if remainder == 0:\\n                if s[:i+1] * floor == s:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113021,
                "title": "python-easy-solution",
                "content": "Runtime: 16 ms, faster than 100.00% of Python3.\\nMemory Usage: 14.3 MB, less than 65.04% of Python3.\\n\\nThis is based on the observation that a string is periodic if and only if it is equal to a nontrivial rotation of itself.\\n\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        i = (s+s).find(s,1,-1)\\n        \\n        if i>0:\\n            return True\\n        else:\\n            return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        i = (s+s).find(s,1,-1)\\n        \\n        if i>0:\\n            return True\\n        else:\\n            return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826771,
                "title": "java-simple-solution-with-substring",
                "content": "This solution is intended to verify if a substring of `s + s` contains `s`. The new substring will be created from index `1` to `length() - 1`.\\n\\n`aba` + `aba` becomes `abaaba` and the substring will be `baab`,  then we can check if this new substring contains `aba`, if not then return false.\\n\\n`abab` + `abab` becomes `abababab` and the substring will be `bababa` wich contains `s`, then return true.\\n\\n```java\\n    public boolean repeatedSubstringPattern(String s) {\\n        String str = s + s;\\n        return str.substring(1, str.length() - 1).contains(s);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```java\\n    public boolean repeatedSubstringPattern(String s) {\\n        String str = s + s;\\n        return str.substring(1, str.length() - 1).contains(s);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 452275,
                "title": "java-9ms-non-bruteforce-solution-using-gcd-100-less-memory-81-faster-runtime",
                "content": "\\nTo find repeating substring, information about the frequency of each character helps a lot.\\n\\nLet\\'s take `babbaaabbbbabbaaabbbbabbaaabbb` as an example, \\nthe frequencies of each character are\\n\\n```txt\\na : 12\\nb : 18\\n```\\n\\nOf those frequences, `min = 12`, `max = 18`.\\n\\nThere are few obvious cases that can be eliminated\\n1. if `max` equals the string length, we can infer that there is only one unique character in the string, so if the length is greater than 1, the string repeats n times. Example: `aaaaa`.\\n2.  If `min` is equal to 1, there is a character that occurs only once, which is not possible if a repetition exists. Example: `abcabcd`.\\n\\nIf we calculate the GCD of `min`, `max` we can know the upper bound on the number of possible repetitions. If GCD equals 1, it means that no common divisor is found and hence no repetitions are possible.\\n\\n`GCD(min, max) = GCD(12, 18) = 6`\\n\\nIf there are 6 possible repetitions, then the pattern size should be equal to `string.length / 6 => 30 / 6 = 5` \\nPattern size 5, `babba` is not the pattern that\\'s repeating, so we move on to the multiples of 6 `[3, 2]`\\n\\nIf there are 3 repetitions, then the pattern size will be equal to `string.length / 3 => 30 / 3 = 10`\\nPattern size 10 `babbaaabbb` is the repeating pattern.\\n\\n\\n```java\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        int[] c = new int[26];\\n        \\n        // count frequency of each character\\n        for (int i=0; i<s.length(); i++) {\\n            c[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        // calculate max, min frequency\\n        for (int i=0; i<c.length; i++) {\\n            if (c[i] > 0) {\\n                if (c[i] < min) {\\n                    min = c[i];\\n                }\\n                if (c[i] > max) {\\n                    max = c[i];\\n                }\\n            }\\n        }\\n        \\n        // if a character frequency == string length,\\n        // there is only one unique character in the entire string\\n        if (max == s.length()) {\\n            return max > 1;\\n        }\\n        \\n        // min must be >= 2 for repetition to occur\\n        if (min <= 1) {\\n            return false;\\n        }\\n        \\n        // GCD gives an upper bound on the possible number of repetitions\\n        int repeatCount = GCD(min, max);\\n        \\n        // If no common divisor > 1, repetition not possible\\n        if (repeatCount == 1) {\\n            return false;\\n        }\\n        \\n        List<Integer> multiples = new ArrayList<Integer>();\\n        multiples.add(repeatCount);\\n        multiples.addAll(getMultiples(repeatCount));\\n        \\n        // for each multiple of GCD, check if pattern repeats\\n        for (int i : multiples) {\\n            if (isRepeating(s, i)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int GCD(int a, int b) {\\n        return a == 0 ? b : GCD(b%a, a);\\n    }\\n    \\n    List<Integer> getMultiples(int n) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        for (int i=n/2; i>=2; i--) {\\n            if (n % i == 0) {\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    boolean isRepeating(String s, int repeatCount) {\\n        int patternLength = s.length()/repeatCount;\\n        String pattern = s.substring(0, patternLength);\\n        for (int i=1;i<repeatCount; i++) {\\n            int begin = patternLength * i;\\n            int end = begin + patternLength;\\n            if (!s.substring(begin, end).equals(pattern)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```txt\\na : 12\\nb : 18\\n```\n```java\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        int[] c = new int[26];\\n        \\n        // count frequency of each character\\n        for (int i=0; i<s.length(); i++) {\\n            c[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        // calculate max, min frequency\\n        for (int i=0; i<c.length; i++) {\\n            if (c[i] > 0) {\\n                if (c[i] < min) {\\n                    min = c[i];\\n                }\\n                if (c[i] > max) {\\n                    max = c[i];\\n                }\\n            }\\n        }\\n        \\n        // if a character frequency == string length,\\n        // there is only one unique character in the entire string\\n        if (max == s.length()) {\\n            return max > 1;\\n        }\\n        \\n        // min must be >= 2 for repetition to occur\\n        if (min <= 1) {\\n            return false;\\n        }\\n        \\n        // GCD gives an upper bound on the possible number of repetitions\\n        int repeatCount = GCD(min, max);\\n        \\n        // If no common divisor > 1, repetition not possible\\n        if (repeatCount == 1) {\\n            return false;\\n        }\\n        \\n        List<Integer> multiples = new ArrayList<Integer>();\\n        multiples.add(repeatCount);\\n        multiples.addAll(getMultiples(repeatCount));\\n        \\n        // for each multiple of GCD, check if pattern repeats\\n        for (int i : multiples) {\\n            if (isRepeating(s, i)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int GCD(int a, int b) {\\n        return a == 0 ? b : GCD(b%a, a);\\n    }\\n    \\n    List<Integer> getMultiples(int n) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        for (int i=n/2; i>=2; i--) {\\n            if (n % i == 0) {\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    boolean isRepeating(String s, int repeatCount) {\\n        int patternLength = s.length()/repeatCount;\\n        String pattern = s.substring(0, patternLength);\\n        for (int i=1;i<repeatCount; i++) {\\n            int begin = patternLength * i;\\n            int end = begin + patternLength;\\n            if (!s.substring(begin, end).equals(pattern)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372713,
                "title": "o-n-with-z-function",
                "content": "z[i] represent the length of common prefix between s and s[i:]. The Z array could be calculated in O(N) time.\\n\\nSee https://cp-algorithms.com/string/z-function.html for more information\\n\\n```cpp\\n    bool repeatedSubstringPattern(string s) {\\n        vector<int> z(s.size());\\n        int l = 0, r = 0;\\n        for (int i=1; i<s.size(); ++i) {\\n            if (i <= r) {\\n                z[i] = min(r - i + 1, z[i - l]);\\n                if (i + z[i] - 1 < r) continue;\\n            }\\n            while (i + z[i] < s.size() && s[i + z[i]] == s[z[i]]) ++z[i];\\n            if (i + z[i] - 1 > r) {\\n                r = i + z[i] - 1;\\n                l = i;\\n            }\\n        }\\n        for (int i = 1; i < s.size(); ++i)\\n            if (s.size() % i == 0 && z[i] + i == s.size()) return true;\\n        return false;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```cpp\\n    bool repeatedSubstringPattern(string s) {\\n        vector<int> z(s.size());\\n        int l = 0, r = 0;\\n        for (int i=1; i<s.size(); ++i) {\\n            if (i <= r) {\\n                z[i] = min(r - i + 1, z[i - l]);\\n                if (i + z[i] - 1 < r) continue;\\n            }\\n            while (i + z[i] < s.size() && s[i + z[i]] == s[z[i]]) ++z[i];\\n            if (i + z[i] - 1 > r) {\\n                r = i + z[i] - 1;\\n                l = i;\\n            }\\n        }\\n        for (int i = 1; i < s.size(); ++i)\\n            if (s.size() % i == 0 && z[i] + i == s.size()) return true;\\n        return false;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 298224,
                "title": "java-intuitive-proof",
                "content": "```java\\nclass Solution {\\n    \\n\\n    // [a b] [a b] : given a string with repeated pattern\\n    // [a b] [a b] [a b] [a b] : double it\\n    // b [a b] [a b] a : break first and last chunk\\n    // The final string should contain original string\\n    \\n    // [a b c] : given a string without repeated pattern\\n    // [a b c] [a b c] : double it\\n    // b c a b : break first and last chunk\\n    // The final string does not contain original string\\n\\n    public boolean repeatedSubstringPattern(String s) {\\n        String s2 = s + s;\\n        return s2.substring(1, s2.length() - 1).contains(s);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n\\n    // [a b] [a b] : given a string with repeated pattern\\n    // [a b] [a b] [a b] [a b] : double it\\n    // b [a b] [a b] a : break first and last chunk\\n    // The final string should contain original string\\n    \\n    // [a b c] : given a string without repeated pattern\\n    // [a b c] [a b c] : double it\\n    // b c a b : break first and last chunk\\n    // The final string does not contain original string\\n\\n    public boolean repeatedSubstringPattern(String s) {\\n        String s2 = s + s;\\n        return s2.substring(1, s2.length() - 1).contains(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184558,
                "title": "concise-javascript-solution",
                "content": "```\\nvar repeatedSubstringPattern = function(s) {\\n    if (s.length === 0 || s.length === 1) return false;\\n    for (let i = 1; i <= s.length / 2; i++) {\\n        if (s.length % i === 0 && s.slice(0, i).repeat(s.length / i) === s) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar repeatedSubstringPattern = function(s) {\\n    if (s.length === 0 || s.length === 1) return false;\\n    for (let i = 1; i <= s.length / 2; i++) {\\n        if (s.length % i === 0 && s.slice(0, i).repeat(s.length / i) === s) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94428,
                "title": "java-one-liner-no-regexp",
                "content": "```\\npublic boolean repeatedSubstringPattern(String str) {\\n    return (str + str).indexOf(str, 1) < str.length();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean repeatedSubstringPattern(String str) {\\n    return (str + str).indexOf(str, 1) < str.length();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94380,
                "title": "1-line-c-solution-return-s-s-find-s-1-s-size-with-proof",
                "content": "```\\n    bool repeatedSubstringPattern(string& s) { return (s+s).find(s,1) < s.size(); }\\n```\\nSince neither `string::find` nor `std::strstr` specify complexity, the algorithm is up to whatever their implementation is. (e.g., `O(N)` time and space if using KMP, where `N = s.size()`)\\n\\nWhy condition `return (s+s).find(s,1) < s.size()` is equivalent to substring repetition?\\n**Proof:** Let `N = s.size()` and `L := (s+s).find(s,1)`, actually we can prove that **the following 2 statements are equivalent:**\\n1. `0 < L < N`;\\n2. `N%L == 0` and `s[i] == s[i%L]` is true for any `i` in `[0, N)`. (which means `s.substr(0,L)` is the repetitive substring)\\n\\nConsider function `char f(int i) { return s[i%N]; }`, obviously it has a period `N`.\\n\\n**\"1 => 2\"**: From condition 1, we have for any `i` in `[0,N)`\\n* `s[i] == (s+s)[i+L] == s[(i+L)%N]`, \\nwhich means `L` is also a positive period of function `f`. Note that `N == L*(N/L)+N%L`, so we have\\n* `f(i) == f(i+N) == f(i+L*(N/L)+N%L) == f(i+N%L)`,\\nwhich means `N%L` is also a period of `f`. Note that `N%L < L` but `L := (s+s).find(s,1)` is the minimum positive period of function `f`, so we must have `N%L == 0`. Note that `i == L*(i/L)+i%L`, so we have\\n* `s[i] == f(i) == f(L*(i/L)+i%L) == f(i%L) == s[i%L]`,\\nso condition 2 is obtained.\\n\\n**\"2=>1\"**: If condition 2 holds, for any `i` in `[0,N)`, note that `N%L == 0`, we have\\n* `(s+s)[i+L] == s[(i+L)%N] == s[((i+L)%N)%L] == s[(i+L)%L] == s[i]`,\\nwhich means `(s+s).substr(L,N) == s`, so condition 1 is obtained.",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n    bool repeatedSubstringPattern(string& s) { return (s+s).find(s,1) < s.size(); }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94502,
                "title": "easy-and-fast-python",
                "content": "    def repeatedSubstringPattern(self, s):\\n        n = len(s)\\n        return any(n / d * s[:d] == s\\n                   for d in range(1, n)\\n                   if n % d == 0)\\n\\nI just try all possible divisors. Submitted three times, accepted in 78, 68 and 89 ms, average 78.3 ms.\\n\\nHere's an optimized version, accepted in 39, 62 and 45 ms, average 48.7 ms.\\n\\n    def repeatedSubstringPattern(self, s):\\n        n = len(s)\\n        d = 1\\n        while d * d <= n:\\n            if n % d == 0:\\n                for m in {d, n/d}:\\n                    if m > 1 and m * s[:n/m] == s:\\n                        return True\\n            d += 1\\n        return False\\n\\nFor comparison, I also tested @protein-graph's [KMP O(n) solution](https://discuss.leetcode.com/topic/67640/python-kmp-o-n) (the only Python solution posted so far) which got accepted in 185, 235 and 185 ms, average 201.7 ms.\\n\\nThe baseline (the time not caused by our solution but by the judge) is about 38 ms, as determined by the below cheat which got accepted in 42, 33 and 39 ms. Subtracting that, my solutions averaged 40.3 ms and 10.7 ms, and @protein-graph's averaged 163.7 ms.\\n```\\nclass Solution(object):\\n    answers = [False, False, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, False, False, False, False, False, False, False, False, False, False, True, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, False, True, False, False, False, False, False, False, True, False, False, True, True, True, True, True, False, True, False, True, False, True]\\n    def repeatedSubstringPattern(self, s):\\n        return self.answers.pop()\\n```\\n<br>\\nJust another way to write my optimized solution:\\n\\n    def repeatedSubstringPattern(self, s):\\n        n = len(s)\\n        return any(m > 1 and m * s[:n/m] == s\\n                   for d in range(1, int(n**0.5+2))\\n                   if n % d == 0\\n                   for m in {d, n/d})\\n\\nGot accepted in 45, 38 and 72 ms.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    answers = [False, False, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, False, False, False, False, False, False, False, False, False, False, True, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, False, True, False, False, False, False, False, False, True, False, False, True, True, True, True, True, False, True, False, True, False, True]\\n    def repeatedSubstringPattern(self, s):\\n        return self.answers.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939921,
                "title": "easy-explanation-by-creating-repetitions",
                "content": "# Intuition\\nWe can solve this problem by iterating through possible substrings of the input string and checking if they can be repeated to form the original string.\\n\\n# Approach\\nThis function iterates through possible substring lengths from 1 to `n//2` (since a substring\\'s length cannot exceed half of the original string\\'s length). For each length, it checks if the original string can be formed by repeating that substring. If such a substring is found, the function returns `True`, indicating that the string can be constructed as described. If no such substring is found for all possible lengths, the function returns `False`\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n=len(s)\\n        for i in range(1,n//2+1):\\n            if n%i == 0:\\n                substring = s[:i]\\n                repetitions = n // i\\n                constructed_substring= substring * repetitions\\n\\n                if constructed_substring == s:\\n                    return True\\n        return False\\n\\n\\n                    \\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python3",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n=len(s)\\n        for i in range(1,n//2+1):\\n            if n%i == 0:\\n                substring = s[:i]\\n                repetitions = n // i\\n                constructed_substring= substring * repetitions\\n\\n                if constructed_substring == s:\\n                    return True\\n        return False\\n\\n\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771595,
                "title": "easy-c-solution-handwritten-image-explanation-simple-brute-force-approach",
                "content": "# Explanation \\n![sol.jpg](https://assets.leetcode.com/users/images/b180d6a3-ee1d-43f8-99db-fe593a619c82_1689481783.411159.jpeg) \\n**Correction :** We do not need to maintain int end as we can just increment start = start + len.\\n**Note :** substr(start, length) has first argument as starting position of susbstring and second argument as length of the substring.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length(), i = n%2!=0 ? (n+1)/2 : n/2;\\n        if(n==1)    return false;\\n        bool flag = true;\\n        while(i<n){\\n            int start = 0, len = n-i;\\n            string temp = s.substr(i, len);\\n            flag = true;\\n            while(start+len < n){\\n                string val = s.substr(start, len);\\n                if(val != temp){\\n                    flag = false;\\n                    break;\\n                }\\n                start += len;\\n            }\\n            if(flag == true)    break;\\n            i++;\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length(), i = n%2!=0 ? (n+1)/2 : n/2;\\n        if(n==1)    return false;\\n        bool flag = true;\\n        while(i<n){\\n            int start = 0, len = n-i;\\n            string temp = s.substr(i, len);\\n            flag = true;\\n            while(start+len < n){\\n                string val = s.substr(start, len);\\n                if(val != temp){\\n                    flag = false;\\n                    break;\\n                }\\n                start += len;\\n            }\\n            if(flag == true)    break;\\n            i++;\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363969,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        return (s+s).find(s,1)<s.size();\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        if not s:\\n            return False   \\n        ss = (s + s)[1:-1]\\n        return ss.find(s) != -1\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int len = s.length();\\n\\n        for (int i = len / 2; i > 0; i--) {\\n            if (len % i == 0 && s.charAt(i - 1) == s.charAt(len - 1)) {\\n                String ss = s.substring(0, i);\\n                int repeat = len / i;\\n\\n                if (ss.repeat(repeat).equals(s)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        return (s+s).find(s,1)<s.size();\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        if not s:\\n            return False   \\n        ss = (s + s)[1:-1]\\n        return ss.find(s) != -1\\n```\n```Java []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int len = s.length();\\n\\n        for (int i = len / 2; i > 0; i--) {\\n            if (len % i == 0 && s.charAt(i - 1) == s.charAt(len - 1)) {\\n                String ss = s.substring(0, i);\\n                int repeat = len / i;\\n\\n                if (ss.repeat(repeat).equals(s)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278680,
                "title": "459-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define a function repeatedSubstringPattern that takes a string s as input and returns a boolean value.\\n2. Calculate the length of the string s and store it in variable n.\\n3. Iterate over all possible substring lengths, i, such that i is a factor of n.\\n4. Check if i evenly divides n. If not, skip to the next iteration.\\n5. Check if the substring of length i repeated n // i times equals the original string s.\\n6. If it does, return True.\\n7. If no repeated substring is found, return False.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def repeatedSubstringPattern(self, s: str) -> bool:\\n    # calculate the length of the string\\n    n = len(s)\\n    # try only those substring lengths that are factors of the length of the string\\n    for i in range(1, n // 2 + 1):\\n        if n % i == 0:\\n            # check only those substrings that start at the beginning of the string\\n            if s[:i] * (n // i) == s:\\n                return True\\n    \\n    return False\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n  def repeatedSubstringPattern(self, s: str) -> bool:\\n    # calculate the length of the string\\n    n = len(s)\\n    # try only those substring lengths that are factors of the length of the string\\n    for i in range(1, n // 2 + 1):\\n        if n % i == 0:\\n            # check only those substrings that start at the beginning of the string\\n            if s[:i] * (n // i) == s:\\n                return True\\n    \\n    return False\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276697,
                "title": "typescript-doubled-string-solution",
                "content": "# Code\\n```\\nfunction repeatedSubstringPattern(s: string): boolean {\\n    return s.repeat(2).slice(1, -1).includes(s);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction repeatedSubstringPattern(s: string): boolean {\\n    return s.repeat(2).slice(1, -1).includes(s);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3250630,
                "title": "easy-single-loop-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n  let sub = \"\";\\n  for (let i = 0; i < Math.floor(s.length / 2); i++) {\\n    sub += s[i];\\n    if (sub.repeat(s.length / sub.length) === s) return true;\\n  }\\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n  let sub = \"\";\\n  for (let i = 0; i < Math.floor(s.length / 2); i++) {\\n    sub += s[i];\\n    if (sub.repeat(s.length / sub.length) === s) return true;\\n  }\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3149595,
                "title": "repeated-substring-pattern",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the substring have to be repeated the length of the substring should be less than or equals to half of the length and thus create the possible substring and try to create the copies by extracting the length to the required length..\\n\\ns1=\"abab\"\\n\\nFirst form the substring they are \"a\" and \"ab\"\\nnow repeat  the pattern till it equals the length of the resultant lenght and thus it gives as..\\n \"aaaa\"\\n    and \"abab\"\\n\\n Hence we should return True as it is possible to create the string....\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        stringlen=len(s)\\n        \\n        for i in range(0,len(s)//2):\\n            string=s[0:i+1]\\n            length=len(string)\\n            required=len(s)//length\\n            if(string*required==s):\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        stringlen=len(s)\\n        \\n        for i in range(0,len(s)//2):\\n            string=s[0:i+1]\\n            length=len(string)\\n            required=len(s)//length\\n            if(string*required==s):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094859,
                "title": "clean-work-98-faster-94-in-memory",
                "content": "**Hi Guys! \\nCheck my approach and please upvote, if you found it useful**\\n\\n**Main Hint**\\n  Don\\'t check every piece of the string. Let ```s.length()=28```, we should check only substrings those are length of its are 1,2,4,7,14.\\n\\n**Main piece of my code**\\n```\\nint size = s.length();\\n// i = count of the pieces of the s\\nfor(int i=2;i<=size/2;i++){\\n    //count of the pieces of the s can be only divisor of its size\\n    if(size%i==0){\\n        \\n        int count = 0;\\n        String str = s.substring(0,size/i);\\n        //whenever any piece of s don\\'t equals to str then breaks loop\\n        //if all of pieces of s equals to str then returns true\\n        for(int j=size/i;j<size;j+=size/i){\\n            if(s.substring(j,j+size/i).equals(str)){\\n                count++;\\n            }else{\\n                count=0;\\n                break;\\n            }\\n        }\\n\\n        if(count==i-1) return true;\\n}\\n```\\n\\nif ```s.length()==1``` or ```s.length()==2``` it does match the code, so we check its at the beginning.\\nAnd in this code we didn\\'t check the case ```i=size``` because of decreasing loop steps. So we also check it at the end.\\n   \\n\\n#My Code\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n\\n        if(s.length()==1) return false;\\n        if(s.length()==2) return s.substring(0,1).equals(s.substring(1));\\n\\n        int size = s.length();\\n        for(int i=2;i<=size/2;i++){\\n            if(size%i==0){\\n                String str = s.substring(0,size/i);\\n                int count = 0;\\n\\n                for(int j=size/i;j<size;j+=size/i){\\n                    if(s.substring(j,j+size/i).equals(str)){\\n                        count++;\\n                    }else{\\n                        count=0;\\n                        break;\\n                    }\\n                }\\n\\n                if(count==i-1) return true;\\n            }\\n        }\\n\\n        int a = s.charAt(0);\\n        for(char ch : s.toCharArray()){\\n            if(a!=ch) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# Result \\n\\n![image.png](https://assets.leetcode.com/users/images/11ad1af6-0a44-43a0-8395-6ca27bf8fcb4_1674581037.8360991.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```s.length()=28```\n```\\nint size = s.length();\\n// i = count of the pieces of the s\\nfor(int i=2;i<=size/2;i++){\\n    //count of the pieces of the s can be only divisor of its size\\n    if(size%i==0){\\n        \\n        int count = 0;\\n        String str = s.substring(0,size/i);\\n        //whenever any piece of s don\\'t equals to str then breaks loop\\n        //if all of pieces of s equals to str then returns true\\n        for(int j=size/i;j<size;j+=size/i){\\n            if(s.substring(j,j+size/i).equals(str)){\\n                count++;\\n            }else{\\n                count=0;\\n                break;\\n            }\\n        }\\n\\n        if(count==i-1) return true;\\n}\\n```\n```s.length()==1```\n```s.length()==2```\n```i=size```\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n\\n        if(s.length()==1) return false;\\n        if(s.length()==2) return s.substring(0,1).equals(s.substring(1));\\n\\n        int size = s.length();\\n        for(int i=2;i<=size/2;i++){\\n            if(size%i==0){\\n                String str = s.substring(0,size/i);\\n                int count = 0;\\n\\n                for(int j=size/i;j<size;j+=size/i){\\n                    if(s.substring(j,j+size/i).equals(str)){\\n                        count++;\\n                    }else{\\n                        count=0;\\n                        break;\\n                    }\\n                }\\n\\n                if(count==i-1) return true;\\n            }\\n        }\\n\\n        int a = s.charAt(0);\\n        for(char ch : s.toCharArray()){\\n            if(a!=ch) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938049,
                "title": "fastest-solution-fully-explained-o-n-2-java",
                "content": "\\n# Approach :\\n```\\n1. The substring that will be repeated should repeat at least 2 times\\n   otherwise every string will be considered as a repeated substring.\\n2. Since the number of repetitions is between n times (size of the \\n   string) to 2 times so the size of a valid repeating substring \\n   would lie between[ 1, n / 2 ].\\n3. A substring of size \\u201D i \\u201D will only be a repeated substring if \\n   size % i == 0.\\n4. Now following which we have two methods whether current substring\\n   of size suppose k is a repeated substring or not\\n\\n\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public boolean repeatedSubstringPattern(String s) \\n    {\\n        //String part=\"\";\\n        for(int i=1;i<=s.length()/2;i++)\\n        {\\n            if(s.length()%i==0)//check if equal parts can be formed\\n            {\\n                String part=s.substring(0,i);\\n                int j=i;\\n                while(j<s.length() && s.substring(j,j+i).equals(part))\\n                  j+=i;\\n                if(j==s.length())\\n                  return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\n1. The substring that will be repeated should repeat at least 2 times\\n   otherwise every string will be considered as a repeated substring.\\n2. Since the number of repetitions is between n times (size of the \\n   string) to 2 times so the size of a valid repeating substring \\n   would lie between[ 1, n / 2 ].\\n3. A substring of size \\u201D i \\u201D will only be a repeated substring if \\n   size % i == 0.\\n4. Now following which we have two methods whether current substring\\n   of size suppose k is a repeated substring or not\\n\\n\\n```\n```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\n```\\nclass Solution \\n{\\n    public boolean repeatedSubstringPattern(String s) \\n    {\\n        //String part=\"\";\\n        for(int i=1;i<=s.length()/2;i++)\\n        {\\n            if(s.length()%i==0)//check if equal parts can be formed\\n            {\\n                String part=s.substring(0,i);\\n                int j=i;\\n                while(j<s.length() && s.substring(j,j+i).equals(part))\\n                  j+=i;\\n                if(j==s.length())\\n                  return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854402,
                "title": "kotlin-smart-solution-one-liner-with-detailed-explanation",
                "content": "# Intuition\\nGiven that the string `S` was formed by a pattern `P`, if we create `S1 = S + S` and we removed the first and the last letter of `S1` (`S2 = S1[1:-1]`), `S` can still be found in `S1`.\\n\\nFor example:\\n\\n```\\n// the pattern\\nP = \"ab\"\\n// the input\\nS = \"ababab\"\\n\"ababab\" + \"ababab\" = \"abababababab\" minus first and last character = \"bababababa\"\\nand \"bababababa\" still contains \"ababab\".\\n```\\n\\n![a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg](https://assets.leetcode.com/users/images/88128a41-c894-49cb-9bf3-c816e5ad7606_1669571545.9509563.jpeg)\\n\\n# Approach\\n\\nGiven the String `S` is formed by the pattern `P` repeated`n` times (`S=P*n`), then `S1=P*n+P*n -> S1 = P*2n`, then by removing the first and the last letter, we remove the first and th last `P` (`S2=P*2n - 2P`). If `P` exist, then `S` must have been created when adding `S.substring(1,S.size-1)` to `S.substring(0,S.size-2)`.\\n\\n```\\nP = \"cd\"\\nS=\"cdcd\"\\nS1 = \"cdcd\" + \"cdcd\" (S+S) . S1 contains twice S and four times P.\\nS2 = \"dcdcdc\" (S2 removed the first and the last pattern P)\\nif P exist, S was formed again by combining S.substring(1,S.size-1)+S.substring(0,S.size-2)\\n```\\n\\nThe following example showcase if there is no `P` in `S`, then `S2` does not contain `S`.\\n\\n```\\nS=\"abc\"\\nS1 = \"abcabc\"\\nS2= \"bcab\" \\n```\\n\\n\\n# Complexity\\n- Time complexity: `O(N)`\\n\\n- Space complexity: `O(N)`\\n\\n# Code\\n```\\nclass Solution {\\n    fun repeatedSubstringPattern(s: String): Boolean = when (s.length){\\n        0,1 -> false\\n        2 -> s.get(0) == s.get(1)\\n        else ->  \"${s.substring(1)}${s.substring(0,s.length-2)}\".contains(s)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n// the pattern\\nP = \"ab\"\\n// the input\\nS = \"ababab\"\\n\"ababab\" + \"ababab\" = \"abababababab\" minus first and last character = \"bababababa\"\\nand \"bababababa\" still contains \"ababab\".\\n```\n```\\nP = \"cd\"\\nS=\"cdcd\"\\nS1 = \"cdcd\" + \"cdcd\" (S+S) . S1 contains twice S and four times P.\\nS2 = \"dcdcdc\" (S2 removed the first and the last pattern P)\\nif P exist, S was formed again by combining S.substring(1,S.size-1)+S.substring(0,S.size-2)\\n```\n```\\nS=\"abc\"\\nS1 = \"abcabc\"\\nS2= \"bcab\" \\n```\n```\\nclass Solution {\\n    fun repeatedSubstringPattern(s: String): Boolean = when (s.length){\\n        0,1 -> false\\n        2 -> s.get(0) == s.get(1)\\n        else ->  \"${s.substring(1)}${s.substring(0,s.length-2)}\".contains(s)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684930,
                "title": "python-easy-explained-two-lines",
                "content": "1. Create a string by use of substring starting from 1 to last index and 0th to last but 1 index.\\n2. Check if the given string s is present in the above created new string and return True if present.\\n\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        combined = \"\".join( (s[1:], s[:-1]) )\\n        return s in combined\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        combined = \"\".join( (s[1:], s[:-1]) )\\n        return s in combined\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431263,
                "title": "yet-another-linear-o-n-python-solution-with-kmp",
                "content": "In the previous [post](https://leetcode.com/problems/repeated-substring-pattern/discuss/2425393/Yet-another-Python-solutions-O(n-*-sqrt(n))) I found a solution with complexity O(N * sqrt(N)) which is not in comparison with many other offered solutions with complexity O(N^2). Here I show a difficult but elegant solution by the use of [KMP algorithm](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm). And to be precise, I use only one part of the algorithm ```prefix function()```\\n\\nShort theory: KMP algorithm finds a pattern in the text in linear time O(N). I encourage everyone to analyze it and remember it by heart because it is used in many applications with strings. The algorithm is so powerful and it takes into account, that while we compare each character of the pattern with the characters in the text, we can reuse partially that information. \\nLater I will create a post with details, about how the algorithm works, and post it here.\\n\\nExamples: \\n1) for a string of lenght 9  ```\\'abcabcabc\\'```    the prefix function is: [0, 0, 0, 1, 2, 3, 4, 5, 6]\\n2) for a string of lenght 10 ```\\'abcabrcabc\\'``` the prefix function is:  [0, 0, 0, 1, 2, 0, 0, 1, 2, 3]\\n3) for a string of lenght 10 ```\\'abcabcabcd\\'``` the prefix function is: [0, 0, 0, 1, 2, 3, 4, 5, 6, 0]\\n\\nIn example 1) the pattern ```\\'abc\\'``` is repeated 3 time, in 2) and 3) no patterns\\nAs soon as there are repeated patterns, the prefix functions would increase. And its minimum values is if half of the length of the string because the minimum number of pattern repetitions is 2. The next property: the last element of the ```array s``` is the length of the longest border (when the prefix and the suffix of the string are the same). If we find the difference between the length of the string and the last value of the ```array s``` we find the length of the repeated pattern. And to check if it is a true repeated pattern, the last value of the ```array s``` should be a multiple of the pattern. \\nI would recommend to watch lectures [prefix function](https://www.coursera.org/learn/algorithms-on-strings/lecture/exytr/prefix-function) and [compute prefix](https://www.coursera.org/learn/algorithms-on-strings/lecture/5lDsK/computing-prefix-function).\\n\\n*Please upvote if you like for motivation and karma :)*\\n\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, p: str) -> bool:\\n    \\n        s = [0] * len(p)\\n        border = 0\\n\\n        for i in range(1, len(p)):\\n\\n            while border > 0 and p[i] != p[border]:\\n                border = s[border - 1]\\n\\n            if p[border] == p[i]:\\n                border += 1\\n            else:\\n                border = 0\\n\\n            s[i] = border\\n\\n        return s[-1] and s[-1] % (len(s) - s[-1]) == 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```prefix function()```\n```\\'abcabcabc\\'```\n```\\'abcabrcabc\\'```\n```\\'abcabcabcd\\'```\n```\\'abc\\'```\n```array s```\n```array s```\n```array s```\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, p: str) -> bool:\\n    \\n        s = [0] * len(p)\\n        border = 0\\n\\n        for i in range(1, len(p)):\\n\\n            while border > 0 and p[i] != p[border]:\\n                border = s[border - 1]\\n\\n            if p[border] == p[i]:\\n                border += 1\\n            else:\\n                border = 0\\n\\n            s[i] = border\\n\\n        return s[-1] and s[-1] % (len(s) - s[-1]) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152794,
                "title": "c-3-easier-solutions-without-kmp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        \\n        for(int l = n/2;l>0;l--){\\n            int i = 0;\\n            while(i+l<n && s[i]==s[i+l]) i++;\\n            \\n            if(i+l==n) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        for(int l = n/2;l>0;l--){\\n            if(n%l==0)\\n                if(s.substr(0,n-l)==s.substr(l)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        return (s+s).substr(1,2*s.size()-2).find(s)!=-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        \\n        for(int l = n/2;l>0;l--){\\n            int i = 0;\\n            while(i+l<n && s[i]==s[i+l]) i++;\\n            \\n            if(i+l==n) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        for(int l = n/2;l>0;l--){\\n            if(n%l==0)\\n                if(s.substr(0,n-l)==s.substr(l)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        return (s+s).substr(1,2*s.size()-2).find(s)!=-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977772,
                "title": "c-kmp-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(const string &s) {\\n\\t    vector<int> kmp(s.size(), 0);\\n\\t    for (int i = 0, j = 1; j < s.size(); j++) {\\n\\t\\t    while (i > 0 and s[i] != s[j])\\n\\t\\t\\t    i = kmp[i - 1];\\n\\t\\t    if (s[i] == s[j])\\n\\t\\t\\t    kmp[j] = ++i;\\n\\t    }\\n\\t    return kmp.back() and kmp.back() % (s.size() - kmp.back()) == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(const string &s) {\\n\\t    vector<int> kmp(s.size(), 0);\\n\\t    for (int i = 0, j = 1; j < s.size(); j++) {\\n\\t\\t    while (i > 0 and s[i] != s[j])\\n\\t\\t\\t    i = kmp[i - 1];\\n\\t\\t    if (s[i] == s[j])\\n\\t\\t\\t    kmp[j] = ++i;\\n\\t    }\\n\\t    return kmp.back() and kmp.back() % (s.size() - kmp.back()) == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904955,
                "title": "beginner-friendly-java-solution",
                "content": "We have removed 1st land lst character form str, now we are checking if s present in it ;\\nif pattern is there s+s can form new string str that contains s\\n\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String str = s+s;\\n        return str.substring(1, str.length()-1).contains(s);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        String str = s+s;\\n        return str.substring(1, str.length()-1).contains(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716110,
                "title": "python-1-liner-faster-than-96-28ms",
                "content": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s*2)[1:-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s*2)[1:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299864,
                "title": "java-simplest-solution-with-proper-explaination",
                "content": "```\\n    public boolean repeatedSubstringPattern(String s) {\\n        String k =s+s;     // 1.\\n        k=k.substring(1,k.length()-1);  //2.\\n        if(k.contains(s))    //3.\\n            return true;\\n        return false;    //4.\\n       \\n    }\\n```\\n1. Rotation method i.e if we concatenate string with itself it will form a rotation of that string ( \"abab\" + \"abab\" -> \"abababab\"  , \"aba\"+\"aba\"->\"abaaba\"). \\n2.  Now remove the first and last letter from the new generated string. It will help to remove the ambigous substring as we need to search for the the original string in this new string. \\n3.  Now check for the original string in new string, if it is present then it means the new generated string is the repetition of the substring of original string. (\"bababa\", from index 1 to 4 we can find the original string therefore returned true)\\n4.  Whereas in \"baab\" the original string \"aba\" is not to be found hence returned false.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean repeatedSubstringPattern(String s) {\\n        String k =s+s;     // 1.\\n        k=k.substring(1,k.length()-1);  //2.\\n        if(k.contains(s))    //3.\\n            return true;\\n        return false;    //4.\\n       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076920,
                "title": "javascript-one-liner",
                "content": "```javascript\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    return s.repeat(2).slice(1,-1).indexOf(s) !== -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar repeatedSubstringPattern = function(s) {\\n    return s.repeat(2).slice(1,-1).indexOf(s) !== -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 840400,
                "title": "c-faster-than-96",
                "content": "Runtime: 76 ms, faster than 96.19% of C# online submissions for Repeated Substring Pattern.\\nMemory Usage: 30.1 MB, less than 99.59% of C# online submissions for Repeated Substring Pattern.\\n```\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        int len = s.Length;\\n        if(len < 2)\\n            return false;\\n        \\n        for(int i=2; i<=len/2; i++)\\n            if(len % i == 0)\\n                if(CheckConcatenation(s, i))\\n                    return true;\\n\\n        //check if all characters are the same\\n        char first=s[0];\\n        for(int i=1; i<len; i++)\\n            if(s[i] != first)\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    private bool CheckConcatenation(string s, int multi)\\n    {\\n        int div = s.Length / multi;\\n        for(int i=0; i<div; i++)\\n        {\\n            char first = s[i];\\n            for(int j=1; j<multi; j++)\\n                if(s[i+j*div] != first)\\n                    return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        int len = s.Length;\\n        if(len < 2)\\n            return false;\\n        \\n        for(int i=2; i<=len/2; i++)\\n            if(len % i == 0)\\n                if(CheckConcatenation(s, i))\\n                    return true;\\n\\n        //check if all characters are the same\\n        char first=s[0];\\n        for(int i=1; i<len; i++)\\n            if(s[i] != first)\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    private bool CheckConcatenation(string s, int multi)\\n    {\\n        int div = s.Length / multi;\\n        for(int i=0; i<div; i++)\\n        {\\n            char first = s[i];\\n            for(int j=1; j<multi; j++)\\n                if(s[i+j*div] != first)\\n                    return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827791,
                "title": "c-repeated-substring-pattern-easy-maintain-the-length-window",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n\\t\\t// This loop takes care of the length of substring(1-n/2) (for minimum 2 repeated substring , length=n/2)\\n        for(int l=1;l<=n/2;l++){\\n\\t\\t// i= starting index of previous substring ,j=starting index of current substring\\n            int i=0,j=i+l;\\n           // match the corresponding index of two substrings\\n            while(i<n && j<n && s[i]==s[j]){\\n                i++;j++;\\n            }\\n\\t\\t\\t// if the current length divides the string length , then thr substring can be repeated to form the given string\\n            if(j==n && n%l==0)\\n                return true;\\n        }return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n=s.size();\\n\\t\\t// This loop takes care of the length of substring(1-n/2) (for minimum 2 repeated substring , length=n/2)\\n        for(int l=1;l<=n/2;l++){\\n\\t\\t// i= starting index of previous substring ,j=starting index of current substring\\n            int i=0,j=i+l;\\n           // match the corresponding index of two substrings\\n            while(i<n && j<n && s[i]==s[j]){\\n                i++;j++;\\n            }\\n\\t\\t\\t// if the current length divides the string length , then thr substring can be repeated to form the given string\\n            if(j==n && n%l==0)\\n                return true;\\n        }return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827070,
                "title": "python-o-n-practice-kmp",
                "content": "Using KMP, `dfa[i]` helps us find out the length of longest prefix that equals to the suffix in `s[:i]`. aka. if `dfa[i] == d`, then `s[:d] == s[i-d:i]`.\\nIn this case, a valid `s` should be a substring `p` repeated by `k` times (`k >1`). So that `dfa[n-1] == len(p) * (k-1)`. We can check this by `dfa[n-1] != 0 and dfa[n-1] % (n-dfa[n-1]) == 0`. And necessity is easy to prove: if  `dfa[n-1] == len(p) * (k-1)`, `s[:(k-1)p]` == `s[p:]` then s is a `p` repeated by `k` times.\\n```\\ndef repeatedSubstringPattern(s):\\n\\tn = len(s)\\n\\tdfa = [0] * n\\n\\td = 0\\n\\tfor i in range(1, n):\\n\\t\\twhile d and s[i] != s[d]:\\n\\t\\t\\td = dfa[d-1]\\n\\t\\td += s[i] == s[d]\\n\\t\\tdfa[i] = d\\n\\tpat = dfa[n-1]\\n\\treturn pat != 0 and (pat % (n-pat) == 0)\\n```\\nActually running time is much more than `return s in (s+s)[1:-1]` but time complexity is `O(n)`.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef repeatedSubstringPattern(s):\\n\\tn = len(s)\\n\\tdfa = [0] * n\\n\\td = 0\\n\\tfor i in range(1, n):\\n\\t\\twhile d and s[i] != s[d]:\\n\\t\\t\\td = dfa[d-1]\\n\\t\\td += s[i] == s[d]\\n\\t\\tdfa[i] = d\\n\\tpat = dfa[n-1]\\n\\treturn pat != 0 and (pat % (n-pat) == 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 827014,
                "title": "c-gcd-of-frequencies-based-solution-explained-100-time-100-space",
                "content": "I know the problem is somehow trivial, checking in a loop if your first character matches the following character, otherwise increasing the step and so on.\\n\\nAnd as any respectable OCD-led engineer, I wanted to optimise it.\\n\\nSo I started to think what I could have done before to improve and avoid wasteful attempts.\\n\\nAnd I decided first of all to get the frequency of all the characters, then take all those frequencies and compute the GCD of them with the always handy [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm), setting the initial value of `base` to the overall length of the string itself, then reducing it while using all the non-`0` frequencies I found.\\n\\nSay for example my frequencies for `\\'a\\'`, `\\'b\\'` and `\\'c\\'`, were, respectively, `6`, `15` and `18`: I would have known that the `base` tiniest repetition of all the character an even amount of time (in proportion to their distribution in the string) would have had length `3` (the GCD of those 3 frequencies); and later on we can assume that the tiniest substring we can start looking for it has to be equal to the overall string length (`6 + 15 + 18 == 39` in the example above) divided by this amount of repetitions (so the smallest possible pattern, if any such existed, would have been `39 / 3 == 13`).\\n\\nFurthermore, if performing my GCD reduction would have resulted in `base == 1`, that would have told me that it was not possible to split the string into any sub-part of repeated characters, since the frequencies would have been prime compared to each other (ie: in the above example, getting for example `4`, `15` and `18`).\\n\\nSo, in a lot of cases, my pre-parse of the string already pays off its own cost, saving more hussle later on - I call it a win already!\\n\\nBut there is more: when we actually start to grind down and actually check for repeated patterns, instead of blindly trying in bits of `1`, `2`, etc..., we just move on in more sensible steps of `step` size, having computed it (initially) as `sLen / base` .\\n\\nThat is not trivial either, since in some more advanced tests, I obtained an initial `step` value of `5` or more, so definitely a lot of saved computation compared to going and testing our luck with all the numbers in the `1 - s.size() / 2` range.\\n\\nNow, the last part is probably the easiest one: we initialise our `isRepeated` boolean to `true` because we feel optimistic (and because it is much less of a pain to check for mismatches in this kind of problem) and start looping:\\n* the outer loop will just go from `0` to `step` (excluded), that is to say with, say, `step == 13`, we would loop with `i` taking `0`, `1`, ... , `11` and `12` as values;\\n* the inner loop would compare the same character across all the supposed subpatterns, so, in our initial example, it will check in the first run if th characters in positions `0`, `13` and `26` all had the same value, then `1`, `14` and `27`, and so on;\\n* if any mismatch was found, we would flag `isRepeated` as `false`, break out of both loops;\\n* regardless of the reasonm once we are out of both loops we check; if `isRepeated` is `true`, then we also exit the while loop at once, otherwise we increase the `step` by `subStrLen`, all the time that we need so that `step` is still a valid divisor of `sLen` and then assign to `isRepeated` a value depending whether or not it has grown past half of the initial string length - if so, we are done checking and we exit.\\n\\nAt the end of it all, we just return the final value of `isRepeated` and we are done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // euclidean algorithm here, if you wonder\\n\\tint gcd(int a, int b) {\\n        return b ? gcd(b, a % b) : a;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        int chars[26], sLen = s.size(), base = sLen;\\n        for (auto &c: chars) c = 0;\\n        for (char c: s) chars[c - \\'a\\']++;\\n        for (int i: chars) if (i) base = gcd(base, i);\\n        // exit: no repeated substrings\\n        if (base == 1) return false;\\n        int subStrLen = sLen / base, step = subStrLen;\\n        // our result variable to be checked\\n        bool isRepeated = true;\\n        while (isRepeated) {\\n            for (int i = 0; i < step; i++) {\\n                for (int j = i; j < sLen; j += step) if (s[i] != s[j]) {\\n                    isRepeated = false;\\n                    break;\\n                }\\n                // if it is not a valid sequence, we exit here\\n                if (!isRepeated) break;\\n            }\\n            // if it is instead a valid sequence, here we exit for good\\n            if (isRepeated) break;\\n            // otherwise we try with a bigger step that is still a divisor of sLen\\n            do {\\n                step += subStrLen;\\n            } while (step <= sLen / 2 && sLen % step);\\n            // we reset isRepeated for another go\\n            isRepeated = step <= sLen / 2;\\n        }\\n        return isRepeated;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // euclidean algorithm here, if you wonder\\n\\tint gcd(int a, int b) {\\n        return b ? gcd(b, a % b) : a;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        int chars[26], sLen = s.size(), base = sLen;\\n        for (auto &c: chars) c = 0;\\n        for (char c: s) chars[c - \\'a\\']++;\\n        for (int i: chars) if (i) base = gcd(base, i);\\n        // exit: no repeated substrings\\n        if (base == 1) return false;\\n        int subStrLen = sLen / base, step = subStrLen;\\n        // our result variable to be checked\\n        bool isRepeated = true;\\n        while (isRepeated) {\\n            for (int i = 0; i < step; i++) {\\n                for (int j = i; j < sLen; j += step) if (s[i] != s[j]) {\\n                    isRepeated = false;\\n                    break;\\n                }\\n                // if it is not a valid sequence, we exit here\\n                if (!isRepeated) break;\\n            }\\n            // if it is instead a valid sequence, here we exit for good\\n            if (isRepeated) break;\\n            // otherwise we try with a bigger step that is still a divisor of sLen\\n            do {\\n                step += subStrLen;\\n            } while (step <= sLen / 2 && sLen % step);\\n            // we reset isRepeated for another go\\n            isRepeated = step <= sLen / 2;\\n        }\\n        return isRepeated;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826598,
                "title": "repeated-substring-pattern-easy-to-understand-5-liner-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        for(int i=1;i<=n/2;i++)\\n            if(n%i == 0 && s.substr(i) == s.substr(0,n-i))\\n                return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        for(int i=1;i<=n/2;i++)\\n            if(n%i == 0 && s.substr(i) == s.substr(0,n-i))\\n                return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826417,
                "title": "rust-oneliner",
                "content": "```rust\\nimpl Solution {\\n    pub fn repeated_substring_pattern(s: String) -> bool {\\n        return (s.clone() + &s)[1..s.len()*2-1].contains(&s);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn repeated_substring_pattern(s: String) -> bool {\\n        return (s.clone() + &s)[1..s.len()*2-1].contains(&s);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697405,
                "title": "python3-one-line",
                "content": "# Example:\\n`abab` can be found in \"~~a~~b**abab**a~~b~~\"\\n`abc` cannot be found in \"~~a~~bcab~~c~~\"\\n\\n\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return (s*2)[1:-1].find(s) != -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return (s*2)[1:-1].find(s) != -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442557,
                "title": "javascript-easy-to-read",
                "content": "```javascript\\nvar repeatedSubstringPattern = function(s) { \\n    let median = Math.floor(s.length / 2);\\n    let cur;\\n    let multiple;\\n    \\n    for (let i = 1; i <= median; i++) {\\n        cur = s.slice(0, i);\\n        multiple = Math.floor(s.length / cur.length);\\n        \\n        if (cur.repeat(multiple) === s) {\\n            return true;\\n        }\\n    }\\n    \\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar repeatedSubstringPattern = function(s) { \\n    let median = Math.floor(s.length / 2);\\n    let cur;\\n    let multiple;\\n    \\n    for (let i = 1; i <= median; i++) {\\n        cur = s.slice(0, i);\\n        multiple = Math.floor(s.length / cur.length);\\n        \\n        if (cur.repeat(multiple) === s) {\\n            return true;\\n        }\\n    }\\n    \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399870,
                "title": "swift-simple-solution",
                "content": "```\\n    func repeatedSubstringPattern(_ s: String) -> Bool {\\n        var newstr = s + s\\n        newstr.removeLast()\\n        newstr.removeFirst()\\n        return newstr.contains(s) ? true : false\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    func repeatedSubstringPattern(_ s: String) -> Bool {\\n        var newstr = s + s\\n        newstr.removeLast()\\n        newstr.removeFirst()\\n        return newstr.contains(s) ? true : false\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218996,
                "title": "another-solution-and-explanation",
                "content": "Many people have shared the clever idea of concatenating the input string. The nitpick about this clever idea is that it needs to construct a new string, which has space complexity of `O(n)`. So I would like to add one in the following with strict `O(n)` time and `O(1)` space.\\n\\nThe idea is to traverse all possible patterns. Suppose the string `s` is of length `n`, then the pattern can at most have `n/2` characters and should start with `s[0]`. Moreover, the length of the pattern should be divisible by `n`. Given the pattern `s[0:l)`, we check whether the remaining `s[l:l+1), ..., s[n-l:n)` are all equal to it.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        for (int l = 1; l <= n / 2; l++) {\\n            if (n % l) {\\n                continue;\\n            }\\n            string pattern = s.substr(0, l);\\n            int i = l;\\n            for (; i < n; i += l) {\\n                if (s.substr(i, l) != pattern) {\\n                    break;\\n                }\\n            }\\n            if (i == n) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n        for (int l = 1; l <= n / 2; l++) {\\n            if (n % l) {\\n                continue;\\n            }\\n            string pattern = s.substr(0, l);\\n            int i = l;\\n            for (; i < n; i += l) {\\n                if (s.substr(i, l) != pattern) {\\n                    break;\\n                }\\n            }\\n            if (i == n) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212154,
                "title": "kotlin-1-line-without-explanation",
                "content": "```\\n//https://leetcode.com/problems/repeated-substring-pattern/\\n\\nclass Solution {\\n  fun repeatedSubstringPattern(s: String) = (1..s.length / 2).any { s.length % it == 0 && s.take(it).repeat(s.length / it) == s}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//https://leetcode.com/problems/repeated-substring-pattern/\\n\\nclass Solution {\\n  fun repeatedSubstringPattern(s: String) = (1..s.length / 2).any { s.length % it == 0 && s.take(it).repeat(s.length / it) == s}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180439,
                "title": "java-1-line-with-simple-explanation",
                "content": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        return s.concat(s).indexOf(s, 1) < s.length();\\n    }\\n}\\n```\\n```(s + s).indexOf(s, 1)``` can be less than ```s.length()``` only if ```s``` is a repeated pattern. Actually, in this case ```indexOf(s, 1)``` is the length of the pattern and it\\'s always less than or equal to ```s.length() / 2```.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        return s.concat(s).indexOf(s, 1) < s.length();\\n    }\\n}\\n```\n```(s + s).indexOf(s, 1)```\n```s.length()```\n```s```\n```indexOf(s, 1)```\n```s.length() / 2```",
                "codeTag": "Java"
            },
            {
                "id": 168141,
                "title": "java-o-n-solution-kmp-with-explanation",
                "content": "At each index we store the position 1 after the found pattern starting from the left, naturally this means the position after it will also be the length of the found pattern since we start from 0.  The reason we store +1 the position is that we already know this letter was matched, so there\\'s no point in checking the letter again, we should check the letter after it. \\n\\nWe have two pointers j=0 and i=1, if the characters are equal to advance them and assign dp[i]=j+1 (point to character after j since we already know character j matches).\\n\\nIf they aren\\'t equal and j was already reset all the way (j==0).  We give up on the letter i  and advance i to the next letter. \\n\\nIf it\\'s not equal we backtrack j to j = dp[j-1].  dp[j] gives the position after the match of this character, this character didn\\'t match so going back dp[j] is not a correct choice, we need to choose the letter before it.  We try dp[j-1] then check if it matches in the next iteration. j-1 will never be negative because if j==0 we would have hit the branch before it.\\n\\nFor example:\\na b a a b a b a a b\\n0 0 1 1 2 3 2 3 4 5\\nabaab is of length 5, so we know that it\\'s a repeated substring if the last index is more than 0 (means at least one character was matched, and we know it\\'s repeated if the length is divisble by the (length - substring length) since it means we repeated the substring that many times. In this case length = 10 %(10-5) == 0   10/5 = 2 because abaababaab consists of 2 abaab \\'s\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int [] dp = new int[s.length()];\\n        int i = 1;\\n        int j = 0;\\n        while(i<s.length()){\\n            if(s.charAt(i)==s.charAt(j)){\\n                dp[i]=++j;\\n                ++i;\\n            }\\n            else if(j==0){\\n                ++i;\\n            }\\n            else{\\n                j=dp[j-1];\\n            }\\n        }\\n        return dp[s.length()-1]>0 && s.length()%(s.length()-dp[s.length()-1])==0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int [] dp = new int[s.length()];\\n        int i = 1;\\n        int j = 0;\\n        while(i<s.length()){\\n            if(s.charAt(i)==s.charAt(j)){\\n                dp[i]=++j;\\n                ++i;\\n            }\\n            else if(j==0){\\n                ++i;\\n            }\\n            else{\\n                j=dp[j-1];\\n            }\\n        }\\n        return dp[s.length()-1]>0 && s.length()%(s.length()-dp[s.length()-1])==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94343,
                "title": "5-java-solutions",
                "content": "1. Regular Expression\\n```\\npublic boolean repeatedSubstringPattern(String s) {\\n    return s.matches(\"^([a-z]+)\\\\\\\\1{1,}$\");\\n}\\n```\\n2. Use char array\\n```\\npublic boolean repeatedSubstringPattern(String s) {\\n    int len = s.length();\\n    char[] sc = s.toCharArray();\\n    for (int i = len / 2; i > 0; i--) {\\n        if (len % i != 0) continue;\\n        boolean find = true;\\n        for (int j = i; j < len; j++) {\\n            if (sc[j] != sc[j % i]) {\\n                find = false;\\n                break;\\n            }\\n        }\\n        if (find) return true;\\n    }\\n    return false;\\n}\\n```\\n3. StringBuilder\\n```\\npublic boolean repeatedSubstringPattern(String s) {\\n    int len = s.length();\\n    char[] sc = s.toCharArray();\\n    for (int i = len / 2; i > 0; i--) {\\n        if (len % i != 0) continue;\\n        boolean find = true;\\n        for (int j = i; j < len; j++) {\\n            if (sc[j] != sc[j % i]) {\\n                find = false;\\n                break;\\n            }\\n        }\\n        if (find) return true;\\n    }\\n    return false;\\n}\\n```\\n4. Concatinate 2 strings\\nBasic Idea:\\n1) First char of input string is first char of repeated substring\\n2) Last char of input string is last char of repeated substring\\n3) Let S1 = S + S (where S in input string)\\n4) Remove 1 and last char of S1. Let this be S2\\n5) If S exists in S2 then return true else false\\n6) Let i be index in S2 where S starts then repeated substring length i + 1 and repeated substring S[0: i+1]\\n```\\npublic boolean repeatedSubstringPattern(String str) {\\n    String s = str + str;\\n    return s.substring(1, s.length() - 1).contains(str);\\n}\\n```\\n5. KMP Solution\\n```\\npublic boolean repeatedSubstringPattern(String str) {\\n    int len = str.length();\\n    int last = computePrefix(str.toCharArray())[len - 1];\\n    return last > 0 && (len % (len - last) == 0);\\n}\\nprivate int[] computePrefix(char[] pattern) {\\n    int len = pattern.length, left = 0, right = 1;\\n    int[] ret = new int[len];\\n    ret[0] = 0;\\n    while (right < pattern.length) {\\n        if (pattern[right] == pattern[left])\\n            ret[right++] = ++left;\\n        else if (left == 0)\\n            ret[right++] = 0;\\n        else\\n            left = ret[left - 1];\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean repeatedSubstringPattern(String s) {\\n    return s.matches(\"^([a-z]+)\\\\\\\\1{1,}$\");\\n}\\n```\n```\\npublic boolean repeatedSubstringPattern(String s) {\\n    int len = s.length();\\n    char[] sc = s.toCharArray();\\n    for (int i = len / 2; i > 0; i--) {\\n        if (len % i != 0) continue;\\n        boolean find = true;\\n        for (int j = i; j < len; j++) {\\n            if (sc[j] != sc[j % i]) {\\n                find = false;\\n                break;\\n            }\\n        }\\n        if (find) return true;\\n    }\\n    return false;\\n}\\n```\n```\\npublic boolean repeatedSubstringPattern(String s) {\\n    int len = s.length();\\n    char[] sc = s.toCharArray();\\n    for (int i = len / 2; i > 0; i--) {\\n        if (len % i != 0) continue;\\n        boolean find = true;\\n        for (int j = i; j < len; j++) {\\n            if (sc[j] != sc[j % i]) {\\n                find = false;\\n                break;\\n            }\\n        }\\n        if (find) return true;\\n    }\\n    return false;\\n}\\n```\n```\\npublic boolean repeatedSubstringPattern(String str) {\\n    String s = str + str;\\n    return s.substring(1, s.length() - 1).contains(str);\\n}\\n```\n```\\npublic boolean repeatedSubstringPattern(String str) {\\n    int len = str.length();\\n    int last = computePrefix(str.toCharArray())[len - 1];\\n    return last > 0 && (len % (len - last) == 0);\\n}\\nprivate int[] computePrefix(char[] pattern) {\\n    int len = pattern.length, left = 0, right = 1;\\n    int[] ret = new int[len];\\n    ret[0] = 0;\\n    while (right < pattern.length) {\\n        if (pattern[right] == pattern[left])\\n            ret[right++] = ++left;\\n        else if (left == 0)\\n            ret[right++] = 0;\\n        else\\n            left = ret[left - 1];\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94410,
                "title": "java-solution-using-prime-numbers-beats-97-59-16ms",
                "content": "The idea is the same as @fabrizio3 and @prateek470 with slight optimizations. \\nPls. go through this solution first https://discuss.leetcode.com/topic/67992/java-simple-solution-with-explanation\\nWe can use the premise that if the we checked for i == 2 then we do not need to check to 4, 8, and so on. So, in turn we just need to check for prime numbers i.e. 2, 3, 5, 7, etc. We can hard code the first few prime numbers or write a code to generate those as well.\\n```\\nint[] primes = {};//array of primes\\nint l = s.length();\\nif (l == 0) {\\n    return false;\\n}\\nint index = 0;\\nint count;\\nwhile (index < primes.length) {\\n    count = primes[index];\\n    if (l % count == 0) {\\n        int len = l / count;\\n        //System.out.println(\"Len is: \" + len);\\n        String subS = s.substring(0, len);\\n        //System.out.println(subS);\\n        int i;\\n        for (i = 1; i < count; i++) {\\n            if (!subS.equals(s.substring(i * len, len + len * i))) {\\n                break;\\n            }\\n        }\\n        if (i == count) {\\n            return true;\\n        }\\n    }\\n    index++;\\n}\\nreturn false;",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String"
                ],
                "code": "The idea is the same as @fabrizio3 and @prateek470 with slight optimizations. \\nPls. go through this solution first https://discuss.leetcode.com/topic/67992/java-simple-solution-with-explanation\\nWe can use the premise that if the we checked for i == 2 then we do not need to check to 4, 8, and so on. So, in turn we just need to check for prime numbers i.e. 2, 3, 5, 7, etc. We can hard code the first few prime numbers or write a code to generate those as well.\\n```\\nint[] primes = {};//array of primes\\nint l = s.length();\\nif (l == 0) {\\n    return false;\\n}\\nint index = 0;\\nint count;\\nwhile (index < primes.length) {\\n    count = primes[index];\\n    if (l % count == 0) {\\n        int len = l / count;\\n        //System.out.println(\"Len is: \" + len);\\n        String subS = s.substring(0, len);\\n        //System.out.println(subS);\\n        int i;\\n        for (i = 1; i < count; i++) {\\n            if (!subS.equals(s.substring(i * len, len + len * i))) {\\n                break;\\n            }\\n        }\\n        if (i == count) {\\n            return true;\\n        }\\n    }\\n    index++;\\n}\\nreturn false;",
                "codeTag": "Unknown"
            },
            {
                "id": 94469,
                "title": "python-regular-expression-solution",
                "content": "    def repeatedSubstringPattern(self, str):\\n        \"\"\"\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        import re\\n        return bool(re.match(r\"^([a-z]+)\\\\1+$\", str))",
                "solutionTags": [],
                "code": "    def repeatedSubstringPattern(self, str):\\n        \"\"\"\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        import re\\n        return bool(re.match(r\"^([a-z]+)\\\\1+$\", str))",
                "codeTag": "Python3"
            },
            {
                "id": 94393,
                "title": "python-kmp-o-n",
                "content": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, str):\\n        \"\"\"\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        def computeLPS(str):\\n            lps=[0]*len(str)\\n            i=1\\n            length=0\\n            \\n            while i<len(str):\\n                if str[i]==str[length]:\\n                    length+=1\\n                    lps[i]=length\\n                    i+=1\\n                else:\\n                    if length:\\n                        length=lps[length-1]\\n                    else:\\n                        lps[i]=0\\n                        i+=1\\n            return lps \\n        \\n        lps = computeLPS(str)\\n        n = len(str)\\n        lenn = lps[-1]\\n        if lenn and n%(n-lenn)==0:\\n            return True \\n        else:\\n            return False \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, str):\\n        \"\"\"\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        def computeLPS(str):\\n            lps=[0]*len(str)\\n            i=1\\n            length=0\\n            \\n            while i<len(str):\\n                if str[i]==str[length]:\\n                    length+=1\\n                    lps[i]=length\\n                    i+=1\\n                else:\\n                    if length:\\n                        length=lps[length-1]\\n                    else:\\n                        lps[i]=0\\n                        i+=1\\n            return lps \\n        \\n        lps = computeLPS(str)\\n        n = len(str)\\n        lenn = lps[-1]\\n        if lenn and n%(n-lenn)==0:\\n            return True \\n        else:\\n            return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941892,
                "title": "optimized-solution-in-cpp-83-runtime-87-memory",
                "content": "# Intuition\\nIf such a substring exists, repeated concatenation of which gives `s`, it must:\\n1. Be a prefix of `s`\\n2. Have a length which is a divisor of length of `s` i.e. `s.size()`\\n\\nSo we only need to check prefixes of `s` which have lengths which are divisors of`s.size()`, also if a prefix of length `l` gets rejected, then all divisors of `l` get rejected too.\\n# Approach\\nFirstly, if length of `s` is `1`, we return false, otherwise:\\nWe first start by finding all the divisors of `s.size()` except `s.size()` and store them in decreasing order using a set:\\n```\\nset<int,greater<int>>divs;\\nint n=s.size();\\nfor(int i=2;i*i<=n;i++)\\n{\\n    if(n%i==0)\\n    {\\n        divs.insert(n/i);\\n        divs.insert(i);\\n    }\\n}\\ndivs.insert(1);\\n```\\nWe now check prefixes in decreasing order of their lengths:\\nIf the current prefix keeps appearing continously in `s` till the last index, we return true, else, we remove all divisors of the length of the current prefix from the set:\\n```\\nfor(auto i:divs)\\n{\\n    int j=0;\\n    while(j+2*i<=n&&s.substr(j,i)==s.substr(j+i,i))\\n    {\\n        j+=i;\\n    }\\n    if(j==n-i)\\n    {\\n        return true;\\n    }\\n    for(int j=2;j*j<=i;j++)\\n    {\\n        if(i%j==0)\\n        {\\n            divs.erase(j);\\n            divs.erase(i/j);\\n        }\\n}\\n```\\nIf none of the elements of the set give the required substring, we simply return false.\\n# Complexity\\n- Time complexity:$$O(n.\\u221An)$$\\n`n=s.size()` can have a maximum of 2\\u221An divisors and each of the loop checking if the prefix is a valid substring runs for a max n times (in case of divisor=1).\\n\\n- Space complexity:$$O(n)$$\\nSelf-explanatory -.- \\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool repeatedSubstringPattern(string s) \\n    {\\n        if(s.size()==1)\\n        {\\n            return false;\\n        }\\n        set<int,greater<int>>divs;\\n        int n=s.size();\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            {\\n                divs.insert(n/i);\\n                divs.insert(i);\\n            }\\n        }\\n        divs.insert(1);\\n        n=s.size();\\n        for(auto i:divs)\\n        {\\n            int j=0;\\n            while(j+2*i<=n&&s.substr(j,i)==s.substr(j+i,i))\\n            {\\n                j+=i;\\n            }\\n            if(j==n-i)\\n            {\\n                return true;\\n            }\\n            for(int j=2;j*j<=i;j++)\\n            {\\n                if(i%j==0)\\n                {\\n                    divs.erase(j);\\n                    divs.erase(i/j);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nset<int,greater<int>>divs;\\nint n=s.size();\\nfor(int i=2;i*i<=n;i++)\\n{\\n    if(n%i==0)\\n    {\\n        divs.insert(n/i);\\n        divs.insert(i);\\n    }\\n}\\ndivs.insert(1);\\n```\n```\\nfor(auto i:divs)\\n{\\n    int j=0;\\n    while(j+2*i<=n&&s.substr(j,i)==s.substr(j+i,i))\\n    {\\n        j+=i;\\n    }\\n    if(j==n-i)\\n    {\\n        return true;\\n    }\\n    for(int j=2;j*j<=i;j++)\\n    {\\n        if(i%j==0)\\n        {\\n            divs.erase(j);\\n            divs.erase(i/j);\\n        }\\n}\\n```\n```\\nclass Solution \\n{\\npublic:\\n    bool repeatedSubstringPattern(string s) \\n    {\\n        if(s.size()==1)\\n        {\\n            return false;\\n        }\\n        set<int,greater<int>>divs;\\n        int n=s.size();\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            {\\n                divs.insert(n/i);\\n                divs.insert(i);\\n            }\\n        }\\n        divs.insert(1);\\n        n=s.size();\\n        for(auto i:divs)\\n        {\\n            int j=0;\\n            while(j+2*i<=n&&s.substr(j,i)==s.substr(j+i,i))\\n            {\\n                j+=i;\\n            }\\n            if(j==n-i)\\n            {\\n                return true;\\n            }\\n            for(int j=2;j*j<=i;j++)\\n            {\\n                if(i%j==0)\\n                {\\n                    divs.erase(j);\\n                    divs.erase(i/j);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941109,
                "title": "most-optimal-solution-using-kmp-knuth-morris-pratt-algorithm",
                "content": "\\n\\n# Approach\\nIn this solution, we calculate the Longest Prefix which is also a Suffix (lps) array using the KMP algorithm. The key observation is that if a string can be divided into multiple copies of a substring, the entire string\\'s length minus the last value in the lps array gives the length of the repeating substring. We then check if the given string length is divisible by the pattern length to determine if it can be constructed using repeated substrings.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        vector<int> lps(n, 0);  \\n        int len = 0;  \\n        for (int i = 1; i < n; ++i) {\\n            while (len > 0 && s[i] != s[len]) {\\n                len = lps[len - 1];\\n            }\\n            if (s[i] == s[len]) {\\n                ++len;\\n            }\\n            lps[i] = len;\\n        }\\n        int patternLen = n - lps[n - 1];\\n        return (patternLen != n && n % patternLen == 0);\\n    }\\n};\\n\\n```\\n```JAVA []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n        int[] lps = new int[n];\\n        \\n        int len = 0;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            while (len > 0 && s.charAt(i) != s.charAt(len)) {\\n                len = lps[len - 1];\\n            }\\n            if (s.charAt(i) == s.charAt(len)) {\\n                ++len;\\n            }\\n            lps[i] = len;\\n        }\\n        \\n        int patternLen = n - lps[n - 1];\\n        \\n        return patternLen != n && n % patternLen == 0;\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        lps = [0] * n\\n        \\n        len = 0\\n        \\n        for i in range(1, n):\\n            while len > 0 and s[i] != s[len]:\\n                len = lps[len - 1]\\n            if s[i] == s[len]:\\n                len += 1\\n            lps[i] = len\\n        \\n        pattern_len = n - lps[n - 1]\\n        \\n        return pattern_len != n and n % pattern_len == 0\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "String",
                    "String Matching"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        vector<int> lps(n, 0);  \\n        int len = 0;  \\n        for (int i = 1; i < n; ++i) {\\n            while (len > 0 && s[i] != s[len]) {\\n                len = lps[len - 1];\\n            }\\n            if (s[i] == s[len]) {\\n                ++len;\\n            }\\n            lps[i] = len;\\n        }\\n        int patternLen = n - lps[n - 1];\\n        return (patternLen != n && n % patternLen == 0);\\n    }\\n};\\n\\n```\n```JAVA []\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n        int[] lps = new int[n];\\n        \\n        int len = 0;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            while (len > 0 && s.charAt(i) != s.charAt(len)) {\\n                len = lps[len - 1];\\n            }\\n            if (s.charAt(i) == s.charAt(len)) {\\n                ++len;\\n            }\\n            lps[i] = len;\\n        }\\n        \\n        int patternLen = n - lps[n - 1];\\n        \\n        return patternLen != n && n % patternLen == 0;\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        n = len(s)\\n        lps = [0] * n\\n        \\n        len = 0\\n        \\n        for i in range(1, n):\\n            while len > 0 and s[i] != s[len]:\\n                len = lps[len - 1]\\n            if s[i] == s[len]:\\n                len += 1\\n            lps[i] = len\\n        \\n        pattern_len = n - lps[n - 1]\\n        \\n        return pattern_len != n and n % pattern_len == 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939399,
                "title": "easy-to-understand-solution-for-daily-challenge-with-comments",
                "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        \\n        int n = s.length();\\n        \\n        for(int i=0;i<floor(n/2);i++){\\n            \\n            string str = s.substr(0,i+1);\\n            \\n            // now try to match this string with the remaining string\\n            int j = i+1;\\n            int itr = 0;\\n            bool flag=true;\\n            while(j<n){\\n                // trying to check each character of the string with pattern , if they are matching then the pattern string (str) is a valid answer till now\\n                if(str[itr]==s[j]){\\n                    itr++;\\n                }\\n                else{\\n                    flag=false;\\n                    break;\\n                }\\n                \\n                // setting the index of pattern string to 0 again since whole pattern string has matched once\\n                if(itr==str.length()){\\n                    itr=0;\\n                }\\n                j++;\\n            }\\n            \\n            /* for matching two conditions have to be true \\n             1) flag should be true which means the string pattern has matched properly with respect to whole remaining string indicating the pattern when concatenated can form thw whole of the remaining string\\n             2) the length of whole string should be a multiple of pattern\\'s length \\n            */\\n            if(flag && n%str.length()==0){\\n                return true;\\n            }\\n        }\\n        \\n        \\n        return false;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        \\n        int n = s.length();\\n        \\n        for(int i=0;i<floor(n/2);i++){\\n            \\n            string str = s.substr(0,i+1);\\n            \\n            // now try to match this string with the remaining string\\n            int j = i+1;\\n            int itr = 0;\\n            bool flag=true;\\n            while(j<n){\\n                // trying to check each character of the string with pattern , if they are matching then the pattern string (str) is a valid answer till now\\n                if(str[itr]==s[j]){\\n                    itr++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3938819,
                "title": "c-solution-for-repeated-substring-pattern-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea behind the solution is to consider all possible substring lengths that could potentially form the repeated pattern. For each candidate substring length, we check if it can be used to construct the entire string by appending multiple copies of it together.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We iterate through the possible substring lengths from 1 to half the length of the input string (n / 2). This is because a substring of length greater than half the length of the string cannot be used to form a repeated pattern.\\n\\n1. For each substring length (len), we check if the length of the input string is divisible by len. If it is, then it\\'s possible that a repeated pattern of length len could form the entire string.\\n\\n1. We extract the candidate substring of length len from the beginning of the input string.\\n\\n1. We construct a new string by repeating the candidate substring the necessary number of times (n / len times).\\n\\n1. We compare the newly constructed string with the original input string. If they match, then the input string can be formed by repeating the candidate substring, and we return true.\\n\\n1. If no candidate substring length leads to a match, we return false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution can be analyzed as follows:\\n\\n- We iterate through possible substring lengths from 1 to n / 2, where n is the length of the input string. This takes O(n) time.\\n- For each candidate substring length, we construct a new string by repeating the substring n / len times. Constructing this new string takes O(n) time in the worst case.\\n- Comparing the newly constructed string with the input string also takes O(n) time.\\n- Therefore, the overall time complexity is approximately O(n^2) in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is determined by the space used for the candidate substring and the space used for constructing the new string. Both of these can take up to O(n) space in the worst case (when the candidate substring is the entire string itself).\\n\\nHence, the overall space complexity is O(n).\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        int n = s.Length;\\n    \\n        for (int len = 1; len <= n / 2; len++) {\\n            if (n % len == 0) {\\n                string sub = s.Substring(0, len);\\n                StringBuilder sb = new StringBuilder();\\n                \\n                for (int i = 0; i < n / len; i++) {\\n                    sb.Append(sub);\\n                }\\n                \\n                if (sb.ToString() == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool RepeatedSubstringPattern(string s) {\\n        int n = s.Length;\\n    \\n        for (int len = 1; len <= n / 2; len++) {\\n            if (n % len == 0) {\\n                string sub = s.Substring(0, len);\\n                StringBuilder sb = new StringBuilder();\\n                \\n                for (int i = 0; i < n / len; i++) {\\n                    sb.Append(sub);\\n                }\\n                \\n                if (sb.ToString() == s) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690488,
                "title": "very-easy-to-understand-but-21-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        StringBuilder str = new StringBuilder();\\n\\n        for (int i = 0; i < s.length() / 2; i++) {\\n            str.append(s.charAt(i));\\n            if (s.endsWith(str.toString())) if (s.split(str.toString()).length == 0) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        StringBuilder str = new StringBuilder();\\n\\n        for (int i = 0; i < s.length() / 2; i++) {\\n            str.append(s.charAt(i));\\n            if (s.endsWith(str.toString())) if (s.split(str.toString()).length == 0) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607437,
                "title": "simplest-3-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string tmp=s+s;\\n        if(tmp.substr(1,tmp.size()-2).find(s)==-1) return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        string tmp=s+s;\\n        if(tmp.substr(1,tmp.size()-2).find(s)==-1) return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534851,
                "title": "python-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        # n = len(s)\\n        # for i in range(n - 1):\\n        #     s0 = s[:i + 1]\\n        #     if s0 * (n // (i + 1)) == s:\\n        #         return True\\n        \\n        # return False\\n\\n\\n        return True if s in (s + s)[1:-1] else False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def repeatedSubstringPattern(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        # n = len(s)\\n        # for i in range(n - 1):\\n        #     s0 = s[:i + 1]\\n        #     if s0 * (n // (i + 1)) == s:\\n        #         return True\\n        \\n        # return False\\n\\n\\n        return True if s in (s + s)[1:-1] else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101183,
                "title": "one-line-solution",
                "content": "# Approach 1\\nUsing regular expression with group reference.\\n\\n# Complexity\\n- Time complexity: between $$O(n)$$ and $$O(n^2)$$ - depends on implementation of regular expression module.\\n\\n- Space complexity: between $$O(1)$$ and $$O(n)$$ - depends on implementation of regular expression module.\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return re.search(r\\'^(.+)\\\\1+$\\', s)\\n```\\n\\n# Approach 2\\nSearching string in cut double string.\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s + s)[1:-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return re.search(r\\'^(.+)\\\\1+$\\', s)\\n```\n```\\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n        return s in (s + s)[1:-1]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570295,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1568215,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1569122,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1778080,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1576980,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 2023441,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1649332,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 2023338,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1679794,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1687043,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1570295,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1568215,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1569122,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1778080,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1576980,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 2023441,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1649332,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 2023338,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1679794,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1687043,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "A super problem on strinng matching.\\nFor an interview, I would tell the brute force solution first to interviewer but wont implement it. Then will head to string rotation approach and will implement it.  I have to decide if I should even discuss KMP approach during interview. Maybe someday when I am so confident I would dare to talk the KMP approach. Rabin Karp, though its good to have in the knowlege book I won\\'t use it in interview.\\n\\n3 good approaches from LC: (Read LC properly before or after reading below notes)\\nCode: LC\\n1. **String rotation OR Concatenation** \\nThis approach will come up to mind if you have done **string rotation problems**.\\n\\n\\t**Intution:** (orginal: https://leetcode.com/problems/repeated-substring-pattern/discuss/94344/Simple-Java-solution-2-lines/327797)\\nIf your string S contains a repeating substring, then this means you can \"shift and wrap around\" your string some number of times and have it match the original string.\\nExample: abcabc\\nShift once: cabcab\\nShift twice: bcabca\\nShift three times: abcabc\\nNow the string matches the original string, so you know there is a repeated substring.\\n\\n\\tTo avoid doing this weird wraparound and using modulo, you can just create a new string SS that is the original string concatenated with itself, and check if this new string contains the original string (shifted some number of times). However, you don\\'t want it to match with the first half (S) and the second half (S), so you remove the first and last characters.\\n\\n\\tA similar idea is presented in CTCI problem 1.9, but I think this problem is much more interesting.\\n\\tNote: how to get this inution is, when you notice that there should be repetitions of a chunk of chars for a valid answer, doesn\\'t that make you think \"since we have repetitions can\\'t we rotate these chunks (or even char by char)  like a cycle?\"\\n\\n2. **Rabin Karp**:\\n\\n\\n3. **KMP algorithm**:\\nThis approach will come up to mind if you have done string prefix problems. like *strstr*.\\n**Intuition:**\\n\\t* For a substring to build the string if repeated over n times, then the **substring MUST be a prefix** of the string (visualize the logic). This is where we start to move towards MPS thought process.\\n\\t* Now we need prefix to be repeated. But you remember that **PREFIX REPEATITION = KMP**. So build a prefix lookup table.\\n\\t* If prefix is repeated multiple times in the input string, then the last value in lookup table MUST have a big number (again visualize). To get the correct substring, do n - this value (say l). \\n\\t* Check if any bad characters (non part of repeating substring) had come inside the input string: check if n - l divides n properly. \\nThe last two points need practise and clear head to come up in an interview\\nGood explanation and code: https://leetcode.com/problems/repeated-substring-pattern/discuss/94397/C++-O(n)-using-KMP-32ms-8-lines-of-code-with-brief-explanation.\\n\\n4. **Brute force** : (paru)\\n\\t* Get all substrings\\n\\t* We don\\'t need all substrings, we need only prefix substrings (visualize logic)\\n\\t* For each prefix, check if it matches repeatedly until end of input string. This is O(n * n) (ie, n prefix * n character matching)\\n\\t* But we don\\'t need to check for all prefix, we only need prefixes with lengths till half of input string length. Else if repeated, will exceed input string length. O(n/2 * n) = O(n * n)\\n\\t* Good observation to discuss to interviewer at last: only if the input string length is a non-prime number, we could have a possible substring that properly divides the input string. An exception would be when all characters are same. So the algo steps would be: check if prime length, if yes check all chars same. If not prime, get all prefix substrings and check individually as mentioned above.\\n\\n**A note on KMP:**\\nI think if the candidate knows what problem KMP tries to solve (for a string, at each char is there any prefix matching current suffix, then find the biggest prefix), when to use it (when prefix repetitions happen in a string), how to implement it (using a look up table) and apply this knowledge whenever \\nthe same problem arises in an interview question, he should get a STRONG HIRE. So it could be expected from a candidate.\\n\\nI would like to add my experience here.\\nI was doing LC \"Reapeating substring pattern\" today. What I understood is, if I could reach upto the point \"for a string to be valid in this problem I need any prefix to be repeated till the end of string length without any unwanted characters (ie, not part of repetition) in between repetitions\", the \"prefix repeatition\" could signal me to try out KMP. This only comes from my previous experience of using KMP in Leetcode strstr().\\n\\nNow once you enter the KMP thought process, you must realize that the last value in the lookup table mus a non 0 and it must be greater than half the input string length (visualize lookup for abcabcabc and abcabc)..\\nAlso visualize the ratio between the last value of loopkup table and the repeated substring length for diff eg like for n=9, 8:1, 7:2, 6:3, etc. Only 1 and 3 divides fully.\\n\\nTime complexity of kmp strstr: https://qr.ae/pNloVX\\n\\nPrefix lookup table explanation: https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation/827758?page=4&orderBy=newest_to_oldest \"Clean KMP solution...\" by @myfavcat.\\n\\nA knowledge point on Pallindrome: The second half of a pallindrome, if **reversed**, forms a repetition of the first half. And \"first\" half means a prefix of original string. So pallindrome is a variation of prefix repetition. This forms the basis of https://leetcode.com/problems/shortest-palindrome/ \\n\\nWrite down logic for KMP in strstr later"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Isn't rabin karp same as naive matching but extra overhead of hashing?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Thinks so much for this post!"
                    },
                    {
                        "username": "jatindigra",
                        "content": "I loved this read !! thanks so much !"
                    },
                    {
                        "username": "dvvalabs",
                        "content": "It is easy only if you know it. Only brute force solution is easy."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "idk"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That\\'s a pretty good reason for a problem to be marked easy. the O(n) solution is quite clever though, be sure to check out the tutorial, it\\'s a trick you can use in other problems as well. "
                    },
                    {
                        "username": "Hermits",
                        "content": "\"abaababaab\""
                    },
                    {
                        "username": "Subh001",
                        "content": "if  s length is even number its true else false , in this way it passed 73 test case.....XD"
                    },
                    {
                        "username": "user1247lh",
                        "content": "[@sleep_404](/sleep_404) lol"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) He\\'s just saying, the testcases are crap, even with a very wrong logic It should not pass that much testcase."
                    },
                    {
                        "username": "sleep_404",
                        "content": "it\\'d fail for an odd numbered substring that occurs odd number of times though.\\nLike, \\'bab\\'*5 = 15 characters"
                    },
                    {
                        "username": "mercer80",
                        "content": "![image](https://assets.leetcode.com/users/images/a42cee30-15be-4992-aa71-07bb8adb669c_1656832963.0830936.jpeg)\\n"
                    },
                    {
                        "username": "leetstreet",
                        "content": "[@Gauravkr007](/Gauravkr007) ababab + ababab => abababababab => trim => bababababa => [ababab in bababababa] = True"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Abishek_tvs](/Abishek_tvs) Not Working for TestCase \"ababab\"."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "It works \\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Nice solution! It worked, but i wonder why we are removing first and last character \\uD83E\\uDD14?"
                    },
                    {
                        "username": "IstebsharulBari",
                        "content": "this is not working for ababab\\n"
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "It\\'s not working for odd length string"
                    },
                    {
                        "username": "Abishek_tvs",
                        "content": "[@raniv_tiwari_](/raniv_tiwari_) No, If u remove first and last letter its baba\\nNow ab is still the substring of baba so its TRUE"
                    },
                    {
                        "username": "raniv_tiwari_",
                        "content": "for ababab ...its notr woring\\n"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "How is this an easy question?\\uD83D\\uDE2D"
                    },
                    {
                        "username": "psionl0",
                        "content": "A brute force solution is pretty basic. If you wanted an optimized solution then this would be a much harder problem."
                    },
                    {
                        "username": "jgialis",
                        "content": "Easy only cus the brute force solution is accepted.."
                    },
                    {
                        "username": "Emily50",
                        "content": "How?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@ashish15678]yes brute force is accepted as it will have 0(N)*sqrt(N) approach  Sqrt(N) instead of N beacause every number has 2(root(N)) multiples."
                    },
                    {
                        "username": "ashish15678",
                        "content": "it is accepted??\\nplease help\\n\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an easy problem, look at the constraint \"1 <= s.length <= 10^4\"\nPerhaps one finds the prime numbers <=100=sqrt(10^4), Use them to find the divisors for s.length and try to test appending multiple copies!\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@deCodeIt](/deCodeIt) Maybe it is shooting birds with a cannon. But it works!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Finding prime factors is an overkill, simply run a loop and check if the current iteration value i divides string length with 0 remainder and proceed with your maths."
                    },
                    {
                        "username": "rreocode",
                        "content": "How is \"abaababaab\" True?\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "\"abaababaab\" = \"abaab\" + \"abaab\""
                    },
                    {
                        "username": "dvs1117",
                        "content": "abaab, abaab are two repeated sub strings"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "[@ajinkode](/ajinkode) Try string rotation method"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "abaab, abaab... If you are getting wrong answers I would suggest you should go with string rotation method"
                    },
                    {
                        "username": "kazirasel2005",
                        "content": "[@ajinkode](/ajinkode)  Me also.....\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "My code failed for the same test case"
                    },
                    {
                        "username": "rreocode",
                        "content": "oh. \"abaab\", \"abaab\""
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "how can test case `aba` return `false` but test case `bb` return `true`?"
                    },
                    {
                        "username": "jffiorillo",
                        "content": "`aba` can\\'t be formed by any substring (`a` or `ab`). In the order hand, `bb` can be formed by the substring `b` twice."
                    }
                ]
            },
            {
                "id": 1566967,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 1574637,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023333,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023695,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023554,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023470,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023325,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023700,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023692,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023479,
                "content": [
                    {
                        "username": "koolkaps7",
                        "content": "return (str + str).find(str, 1) < str.size();"
                    },
                    {
                        "username": "adityaleetcode",
                        "content": "My code is failing for input \"bb\", but in the example \"aba\" shown as False!! In that case if you consider one character as substring string then \"aba\" also True."
                    },
                    {
                        "username": "dimitryku",
                        "content": "if substring is \"a\", than you can not make \"aba\", since you have not \"b\" in your substring. If substring is \"ab\" than you can not make \"aba\", since you can do \"abab\", \"ababab\" etc only. So it is False. \"bb\" can be made from \"b\", so it is True."
                    },
                    {
                        "username": "bhati25",
                        "content": "Just a tip use KMP algo. "
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/F1irIhD\"><img src=\"https://i.imgur.com/F1irIhD.jpg\" title=\"source: imgur.com\"  width=\"400px\"/></a>"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this question should be a medium... I feel like only the brute force method is easy/intuitive"
                    },
                    {
                        "username": "s3stan",
                        "content": "\\nOne joy on Monday morning - green on LeetCode"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Brute force solution: \\nUse a sliding window technique, try every window size of substring then move the window by the substring length."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This problem is easy to solve and hard to optimize:\nHere are few condition which can be used to optimize the code:\n\nFor **Naive string matching** which involve construction of substring and comparison of those substring the one can reduce his number iteration by:\nHere str is the substring of s which can be repeated to form s (possible answer)\n\n1. Check whether it is possible to create n(*an integer*) substring of size =  str.length for which use the condition:\n    **if (s.length % str.length == 0)**\n2. Before making substring from s check whether the substrings first and last letter are same.\n\nBut these all things will optimize the code to much extent but the real optimization would to use better string matching or pattern matching algorithm:\n**Robin karp Algorithm**: which involve sort of hashing(*converting the string into number to reduce the comparison time*) and sliding window(* as while applying this approach one would be hashing every window of size str.length)\nBut the issue with this algo is its time complexity is $$O(mn)$$\nwhich is not good in term of optimization.\n\n**KMP algorithm**: This algo is little bit difficult to code and understand (I write about it this comment would become an article\nand no one like to read article)\nThe best part about this algo is its time complexity is $$O(m + n)$$.\n\n🚀 Next Level Coding: Now, I get it, this isn't a walk in the park. But trust me, the rewards are worth it. It's like leveling up in the coding universe.\n\nI know it is a bit difficult to implement but you would be able to do it."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "Just hardcoded this and beats 94% in runtime xD"
                    },
                    {
                        "username": "dan_cho",
                        "content": "I saw your solution, It\\'s really hard to even think about that hardcode solution... LOL"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "If you\\'re thinking about PRIME FACTORS and finding all divisors, STOP!\\n\\nKeep it Simple.\\nJust iterate from length `1 ... (N/2)` ( where N is the length of original string ) and check if the current iteration value `i` divides `N` completely i.e. `i % N == 0`, voila you got one of your divisors else continue to next iteration.\\nTime to check if a substring of this length ( starting at 0 ) is able to partition the entire string correctly or not.\\nIf yes, you got the answer, otherwise continue with next iteration."
                    },
                    {
                        "username": "akash_vannam",
                        "content": "I tried to check for factors/divisors of length. It should be O(nrootn). But its giving me TLE. \nHere's my code. Please tell me whats wrong..\n\n\n\nclass Solution {\npublic:\n    bool is_pattern(string &s, string &subs)\n    {\n        int n = s.length(), m = subs.length();\n        for(int i = m; i < n; i++)\n        {\n            if(s[i] != subs[i%m]) return false;\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\n        }\n        return true;\n    }\n\n    bool repeatedSubstringPattern(string s) {\n        int n = s.length();\n        if(n == 1) return false;\n        cout<<n<<endl;\n        bool allsame = true;\n        for(int i = 1; i < n; i++)\n        {\n            if(s[i] != s[i-1]) \n            {\n                allsame = false;\n                break;\n            }\n        }\n        if(allsame) return true;\n        for(int i = 2; i*i <= n; i++)\n        {\n            if((n%i) == 0)\n            {\n                int j = n/i;\n                string subs1 = s.substr(0,i);\n                string subs2 = s.substr(0,j);\n\n                // cout<<subs1<<\" \"<<subs2<<endl;\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\n            }\n        } \n        return false;\n    }\n};"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "nice explanation\\n"
                    }
                ]
            },
            {
                "id": 2023312,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 2023311,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 1950886,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 1576628,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 2023355,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 2063615,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 2061272,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 2031711,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 2031157,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 2028132,
                "content": [
                    {
                        "username": "yashy_",
                        "content": "finally an easy monday :)"
                    },
                    {
                        "username": "c4tdog",
                        "content": "heh, first easy after 41 days \\uD83D\\uDE0A"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "why is \"a\" false?  "
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@sleep_404](/sleep_404) This is an edge case, there is no substring smaller than the string itself."
                    },
                    {
                        "username": "sleep_404",
                        "content": "there are no copies of even a single character involved"
                    },
                    {
                        "username": "narekGev",
                        "content": "return (s + s).substr(1, s.size()*2 - 2).find(s) != string::npos;"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "hol\\' up\\nthis isnt easy"
                    },
                    {
                        "username": "user2134Fq",
                        "content": "\"abaababaab\"\\nHow does it contains a repeated substring pattern?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    },
                    {
                        "username": "madpoly",
                        "content": "surprised its marked as easy. Found it quite tricky but not undoable. Basically optimized it and only check if its divisible and return false if my substring is greater than 1/2 of source string which means you cant divide it into even parts."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I am getting a timelimit exeeded error on last testcase 129 and the intersting thing is the input is empty. can anyone tell me what to do?"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "just give this code   \n\n\nif not s : return False\n\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Impossible, all valid testcases have to be at least size 1."
                    },
                    {
                        "username": "Gracemann280",
                        "content": " `\\n\\ncheck if length generated substring divides length whole string \\nthen check if the that subtring can generate the string \\nclass Solution:\\n    def repeatedSubstringPattern(self, s: str) -> bool:\\n\\n        n=len(s)\\n\\n        for length in range(1,n//2+1):\\n\\n            if n%length==0:\\n\\n\\n                if s[:length]*(n//length)==s:\\n                    return True\\n        return False\\n`"
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "check the start and the end of the string, if matches check the pattern. "
                    }
                ]
            },
            {
                "id": 2027154,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2025212,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024590,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024573,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024494,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024390,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024337,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024267,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024264,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024257,
                "content": [
                    {
                        "username": "user5154h",
                        "content": "why does \\'ababba\\' retuns false ?\\n\\nit has 2 ab so it should return true"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "user5154h",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  ok thanks"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "no. You have to make the original string by concatenating a substring that is present in the original string.\\nhere ababba is the original string. if we consider ab as a substring, even if we concatenate ab 3 times it still can\\'t make the original string again. thus answer becomes false.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "s3stan",
                        "content": "We cannot make ab ba. Now, if there was ababab, then yes, it should have been true here.\\nIf it is possible to get the full string from the substring then it will be true."
                    },
                    {
                        "username": "DimSonikku",
                        "content": "Why does testcase 129 give time limit exceeded?\nEdit: it passed testcase 129(although the codes perfomance is poor) after i removed the while loop and added a check \nif s.Length % substring.Length == 0, so that it would skip some useless iterations\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub, res;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            res = \"\";\n            sub = s.Substring(0, i+1);\n            while(res.Length < s.Length) \n                res += sub;\n            if (res == s)\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n```\npublic class Solution \n{\n    public bool RepeatedSubstringPattern(string s) \n    {\n        if (s.Length < 2)\n            return false;\n        string sub;\n        for (int i = 0; i < s.Length/2; i++)\n        {\n            if (s.Length%s.Substring(0, i+1).Length == 0)\n            {\n            sub = s.Substring(0, i+1);\n            sub = String.Concat(Enumerable.Repeat(sub, s.Length/sub.Length));\n            if (sub == s)\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) thank you for the help, i will try to do something about this"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "It might be giving Time limit Exceeded error because your logic is running 0(n^2) times"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) tried checking if its null, still gives time limit exceeded"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Cant paste it, because cant copy it, its nothing. It says: \"s =\" and i cant copy what comes after \"=\", even using the copy button that is next to this testcase."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@DimSonikku](/DimSonikku) what\\'s the testcase 129 paste it here\\n"
                    },
                    {
                        "username": "DimSonikku",
                        "content": "[@ronitroushan21102](/ronitroushan21102) Yes, this code passes every other testcase, except for 129"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "testcase 129?\\n\\n"
                    },
                    {
                        "username": "dipak2000",
                        "content": "Can we do This question using LPS(longest prefix suffix) method which is used in KMP algorithm?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, it\\'s possible give it a go"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "Pleasse someone tell why i got tle \\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> factorize(int n){\\n        unordered_map<int, int>mp;\\n        for(int i=1; i*i<=n; i++){\\n            if(n%i == 0){\\n                mp[i] = 1;\\n                mp[n/i] = 1;  \\n            }\\n        }\\n        return mp;\\n    }\\n    bool repeatedSubstringPattern(string s) {\\n        if(s == \"\"){\\n            return false;\\n        }\\n        int n = s.length(), i, j;\\n        \\n        if(n == 1)return false;\\n        vector<int>f(26, 0);\\n        for(i=0; i<n; i++){\\n            f[s[i] - \\'a\\'] ++;\\n        }\\n        for(i=0; i<n; i++){\\n            if(f[s[i] - \\'a\\'] == 1) return false;\\n        }\\n        //unordered_map<int, int>mp = factorize(n);\\n        string temp = \"\";\\n        for(i=0; i<n/2; i++){\\n            temp.push_back(s[i]);\\n            if(n%(i+1) == 0){\\n                //cout<<i<<\" \";\\n                string check = \"\";\\n                for(j=0; j<n/(i+1); j++){\\n                    check = check + temp;\\n                }\\n                 //out<<temp<<\" \"<<check<<endl;\\n                if(s == check){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "xunil_revol",
                        "content": "[@mstuebs](/mstuebs) still same result\\n"
                    },
                    {
                        "username": "mstuebs",
                        "content": "You are looping through each char individually. To speed up, consider using the built-in C++ string comparison functions. "
                    },
                    {
                        "username": "SG-C",
                        "content": "this should be labeled medium "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "it is easy if you know kmp, first check its prefixing algorithm\\nyou will like this problem"
                    },
                    {
                        "username": "Emily50",
                        "content": "Why O(n^2) solution makes TLE?"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "In complexity analysis, \"10^7\" (10 million) is used as a reference to estimate the efficiency of algorithms based on input size .In the question constraints are given as 10^4  so if you use 0(n^2) complexity that will be (10^4)*2 that will lead to TLE.\\n\\nYou have to find 0(NlogN) , 0(N), solution\\nIn this problem It will also Accept 0(N*sqrt(N)) solution\\n\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What\\'s your thought process with your solution?"
                    },
                    {
                        "username": "BIPIN21CSB0B09",
                        "content": "how to approach this problem?\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "String rotation or dynamic programming. Either will get you there regardless of time complexity"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Why is my O(n^2) solution giving me TLE\n\n` function repeatedSubstringPattern(s: string): boolean {`\n   \n   ` let subString=\"\";`\n \n` for(let i=0;i<s.length;i++){`\n`    subString+=s.charAt(i);`\n   ` if(checkValidity(subString,s)){`\n      ` return true`\n `   }`\n` }`\n\n`return false;`\n\n};\n\n\n`function checkValidity(subStr:string,s:string){`\n`   if(subStr.length==s.length){`\n`      return false;`\n`   }`\n`  const n=s.length;`\n`  let resultLength=n;`\n`  let subString=\"\"`\n`  for(let i=0;i<s.length;i++){`\n   `  subString+=s.charAt(i);`\n    ` if(subString===subStr){`\n        `resultLength-=subStr.length;`\n      `  subString=\"\";`\n    ` }`\n ` }`\n ` return resultLength==0;`\n\n`}`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use 3 backticks to format your code better:\\n\\nyou can use slice to get a subString in one go, instead of doing it per char. and you can add the whole subString to itself rather than per char, thats a lot faster. \\n\\nAlso you can think about what it means if you can build s from copies of subString. Can you do a quick check beforehand based on the length, so that you only have to check a fraction of all the posibillities? \\n"
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone please explain why s=\"abaababaab\" expects output to be True? (testcase 78)"
                    },
                    {
                        "username": "ramanchik",
                        "content": "\"abaab\" + \"abaab\" "
                    },
                    {
                        "username": "Galileo_Apprentice",
                        "content": "Can anyone explain in testcase 78/129\\ns=\"abaababaab\", why is the expected answer True?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Simple. Split middle \"abaab\" AND \"abaab\"."
                    }
                ]
            },
            {
                "id": 2024211,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2024144,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2024077,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2024065,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2024061,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2023983,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2023959,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2023930,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2023835,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2023827,
                "content": [
                    {
                        "username": "akash_vannam",
                        "content": "Someone HELP!!!!\\n\\n\\nsubs = prefix of string s;\\nn = s.length(), m = subs.length()\\nOne necessary condition of subs to build s is that m must divide n.\\nFinding all the factors is O(rootn) time and checking if its a pattern is O(n) time.\\nOverall time complexity is O(nrootn)  < O(n2)\\nIf n^2 solutions are accepted then nrootn must surely be accepted.\\nBut it\\'s giving me TLE!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool is_pattern(string &s, string &subs)\\n    {\\n        int n = s.length(), m = subs.length();\\n        for(int i = m; i < n; i++)\\n        {\\n            if(s[i] != subs[i%m]) return false;\\n            cout<<s[i]<<\" \"<<subs[i%m]<<endl;\\n        }\\n        return true;\\n    }\\n\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.length();\\n        if(n == 1) return false;\\n        cout<<n<<endl;\\n        bool allsame = true;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] != s[i-1]) \\n            {\\n                allsame = false;\\n                break;\\n            }\\n        }\\n        if(allsame) return true;\\n        for(int i = 2; i*i <= n; i++)\\n        {\\n            if((n%i) == 0)\\n            {\\n                int j = n/i;\\n                string subs1 = s.substr(0,i);\\n                string subs2 = s.substr(0,j);\\n\\n                // cout<<subs1<<\" \"<<subs2<<endl;\\n                if(is_pattern(s,subs1) or is_pattern(s,subs2)) return true;\\n            }\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Your function `is_pattern()` is too slow because it compares every char individually. \\nIf you compare *each chunk as a whole* to the substring, it will be sufficient to pass. This is your code:\\n```\\n    for(int i = m; i < n; i++)\\n    {\\n          if(s[i] != subs[i%m]) return false;\\n     }\\n```\\nReplace it with this:\\n```\\n    for(int i = m; i < n; i += m)\\n    {\\n        string investigated_substring = s.substr(i,i+m);\\n        if(investigated_substring != subs) return false;\\n    }\\n```"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "So Happy to solve this ...After ages 1 easy quetion."
                    },
                    {
                        "username": "s3stan",
                        "content": "And a simple task helps to gain new knowledge"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Well leetcode , provide more problems this week like this easy one"
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is easy only because we don\\'t have to code the KMP algorithm. We can use a library function for that. The trick about concatenating the string onto itself is not something that somebody would invent in an interview situation but even then you can get away without doing it. Brute force will pass all test cases."
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "why this not working, can anyone explain?\\n```\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        int n = s.size();\\n\\n        for (int l = n / 2; l >= 1 && n % l == 0; l--) {\\n            string pattern = s.substr(0, l);\\n            string new_s = \"\";\\n            int times = n / l;\\n\\n            while (times--) {\\n                new_s += pattern;\\n            }\\n\\n            cout << new_s << endl;\\n            if (s == new_s) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "bhaiya ! you made mistake in your test condition of for loop :\\ngeneral => for loop : for(int i=0;i<n;i++) \\nthis above code says that  \\' i \\' should always satisfy condition  i<n else loop will break, this is the test ondition\\nbut , your loop is like i>=1 and always satisfy n%i==0 \\nso this may be cause why your code is not working as you expected ..."
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "After a long time I got to see easy question on LeetCode Streak   "
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "why ababba return false"
                    },
                    {
                        "username": "andykimchris",
                        "content": "You can\\'t replicate the string from any substring i.e \"aba\" and \"ab\" don\\'t align with \"bb\" or \"bba\". \\nbbabba or abaaba can."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'ababab' for example"
                    },
                    {
                        "username": "MdFaizan034",
                        "content": "how is \"aba\" false."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@mina2025](/mina2025) then you don't have the 'b' you need all the letters, using just 'a' would give 'aaa'"
                    },
                    {
                        "username": "mina2025",
                        "content": "[@Mister_CK](/Mister_CK) Why not use \\'a\\' substring to create the last \\'a\\' in \\'aba\\' just like in \\'bb\\' example?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there is no subString that you can repeat to create it. 'ab' would return 'abab' for example"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Observe that the string length should be multiple of the assumed substr !\\n[My solution here](https://leetcode.com/problems/repeated-substring-pattern/solutions/3940188/solved-only-using-arrays-easy-approach-simple-understanding-my-solution-accepted/)"
                    }
                ]
            },
            {
                "id": 2023816,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023815,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023791,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023782,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023745,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023588,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023530,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023522,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023400,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023348,
                "content": [
                    {
                        "username": "DeepakPalUPres",
                        "content": "class Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\n        // cout<<s;\\n        string str=s;\\n        int n=str.size()/2;\\n        while(n--)\\n        {\\n            reverse(str.begin()+1,str.end());\\n            reverse(str.begin(),str.end());\\n            if(str==s)\\n            return true;\\n        }\\n        // if(str.substr(1,str.size()-2).find(s)!=-1)\\n        // return true;\\n        return false;\\n    }\\n};\\n why this code is giving TLE ? \\nis the last executed input vilid ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very nice and simple string checking problem.\nAs a quick fail-fast tip, check if and only if the proposed window interval length divides the length of string s."
                    },
                    {
                        "username": "dark_coder_47",
                        "content": "finally monday easy\\n"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "finally....... an easy question!"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I solved this using DP. Not the fastest over string rotation, but it works."
                    },
                    {
                        "username": "karanbangia14",
                        "content": "i am confused \"abcd\" is  a substring of \"abcd\", then in this case ideally all strings can be repeated, is there something else i should consider?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re missing the word \"multiple\" in the problem description, you need at least two copies of the subString:\\nGiven a string s, check if it can be constructed by taking a substring of it and appending `MULTIPLE` copies of the substring together."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "just check all the characters are repeated same time use maps brute force"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "No bro map solution won\\'t work \\nTake a example  \"abba\"\\nHere if we use map It will give TRUE as freq of a and b is 2.\\nBut answer is false. as   ab != ba"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "not at all easy"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "make it a string week, atleast then i will learn more string algos\\uD83D\\uDE29"
                    },
                    {
                        "username": "Braderbell",
                        "content": "makes me happy that it\\'s not a LeetCode hard graph problem again"
                    }
                ]
            },
            {
                "id": 2023337,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 2023332,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 1980883,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 1962710,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 1941386,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 1931546,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 1922424,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 1901039,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 1805079,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            },
            {
                "id": 1782308,
                "content": [
                    {
                        "username": "sober_junkie",
                        "content": "the 2nd method in the editorial runs on voodoo"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Finally.. a problem I can read in one go\\n"
                    },
                    {
                        "username": "itbaaN",
                        "content": "guys can u tell me why the test case that starts with \"qtpddbuotbbqcwivrf......\"(10000 letters) is returning false.\\ni have debug my code and i think its working fine bc i did find a pattern in this input (pattern repeated after each 100 letters). My code is giving me true bc there is a pattern in the string but for some reason the answer is false.\\n\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "babbabbabbabbab -> is 15 characters how can it be that it\\'s repeated?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "that is because it is a pattern of bab"
                    },
                    {
                        "username": "mahesh105",
                        "content": "[@user9962Xz](/user9962Xz) Yes, check for each length 1->(n/2)\\n"
                    },
                    {
                        "username": "user9962Xz",
                        "content": "oh, \"bab\""
                    },
                    {
                        "username": "eduard92",
                        "content": "This problem doesn\\'t feel easy to me, if it accepts brute force, checking each substring against the whole string it might justify the tag, but in the real world nobody implements like that."
                    },
                    {
                        "username": "abhinavchandel_01",
                        "content": "\"ababababababaababababababaababababababa\" \\n\\nclass Solution {\\npublic:\\n    bool repeatedSubstringPattern(string s) {\\n        deque<int>dq;\\n        for( int i = 0 ; i < s.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n\\n        if(dq.size() > s.size()/2) return false;\\n        int prevSize = dq.size();\\n        for( int i = 0 ; i < s.size()-dq.size() ;i++){\\n            if( !dq.empty() && s[i] == dq.front()){\\n                dq.pop_front();\\n            }\\n            dq.push_back(s[i]);\\n        }\\n        if( prevSize != dq.size()) return false;\\n        return true;\\n    }\\n};\\n\\n\\ni have written o(n) solution using deque  it passess 127 test cases  out of 129 \\n\"ababababababaababababababaababababababa\"  in this test case i found bababa as residue in deque ... plzzz reply \\n\\n"
                    },
                    {
                        "username": "Vide_Walter",
                        "content": "So, I did it in this way: \\nfor each i = (string.length)/2 to i = 1 check if length%i == 0, if yes take the first i characters (using substr method) and append them length/i times to make a new string and check whether the string formed is equal to the input string.\\nBut I have a doubt in it I think the time complexity of this solution is O(N^2) because of the inner substr method and for appending operations. But the T.C by this method is given as O(N) on various blogs and platforms.\\nplease clarify help would be greatly appreciated \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "\"abaababaab\" this case is returning false by this method"
                    },
                    {
                        "username": "DimanNe",
                        "content": "This should be marked as HARD.\n\nNone of the solutions (apart from the brute-force one) is EASY. But it is unlikely that Google will be OK with the brute-force one."
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Duplicate the string and store it\\nUse substring (start index ,last index of string)"
                    },
                    {
                        "username": "AndyYangMa",
                        "content": "Why cannot use string1.equals(string2) in Java. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Depth of N-ary Tree",
        "question_content": "<p>Given a n-ary tree, find its maximum depth.</p>\n\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n\n<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>Output:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The total number of nodes is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li>The depth of the n-ary tree is less than or equal to <code>1000</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 183060,
                "title": "java-bfs-iterative-solution",
                "content": "    public int maxDepth(Node root) {\n        if(root == null) return 0;\n        \n        Queue<Node> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int depth = 0;\n        \n        while(!queue.isEmpty())\n        {\n            int size = queue.size();\n            \n            for(int i = 0; i < size; i++)\n            {\n                Node current = queue.poll();\n                for(Node child: current.children) queue.offer(child);\n            }\n            \n            depth++;\n        }\n        \n        return depth;\n    }",
                "solutionTags": [],
                "code": "    public int maxDepth(Node root) {\n        if(root == null) return 0;\n        Queue<Node> queue = new LinkedList<>();\n        queue.offer(root);\n        int depth = 0;\n        while(!queue.isEmpty())\n        {\n            int size = queue.size();\n            for(int i = 0; i < size; i++)\n            {\n                Node current = queue.poll();\n                for(Node child: current.children) queue.offer(child);\n            }\n            depth++;\n        }\n        return depth;\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 167010,
                "title": "dfs-bfs-solutions-in-c",
                "content": "Recursive DFS:\\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == nullptr) return 0;\\n        int depth = 0;\\n        for (auto child : root->children) depth = max(depth, maxDepth(child));\\n        return 1 + depth;\\n    }\\n};\\n```\\n\\nRecursive DFS without raw loops:\\n```\\nclass Solution {\\npublic:\\n    static int maxDepth(Node* root) {\\n        if (root == nullptr) return 0;\\n        return 1 + transform_reduce(begin(root->children), end(root->children), 0, [](int acc, int d) { return max(acc, d); }, [](auto* node) { return maxDepth(node); });\\n    }\\n};\\n```\\n\\nRecursive DFS one-liner:\\n```\\nclass Solution {\\npublic:\\n    static int maxDepth(Node* root) {\\n        return root ? 1 + transform_reduce(begin(root->children), end(root->children), 0, [](int acc, int d) { return max(acc, d); }, [](auto* node) { return maxDepth(node); }) : 0;\\n    }\\n};\\n```\\n\\nBFS:\\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == nullptr) return 0;\\n        queue<Node*> q; q.push(root);\\n        int depth = 0;\\n        while (!q.empty()) {\\n            depth += 1;\\n            int breadth = q.size();\\n            for (int _ = 0; _ < breadth; ++_) {\\n                auto node = q.front(); q.pop();\\n                for (auto child : node->children) if (child) q.push(child);\\n            }\\n        }\\n        return depth;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == nullptr) return 0;\\n        int depth = 0;\\n        for (auto child : root->children) depth = max(depth, maxDepth(child));\\n        return 1 + depth;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    static int maxDepth(Node* root) {\\n        if (root == nullptr) return 0;\\n        return 1 + transform_reduce(begin(root->children), end(root->children), 0, [](int acc, int d) { return max(acc, d); }, [](auto* node) { return maxDepth(node); });\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    static int maxDepth(Node* root) {\\n        return root ? 1 + transform_reduce(begin(root->children), end(root->children), 0, [](int acc, int d) { return max(acc, d); }, [](auto* node) { return maxDepth(node); }) : 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == nullptr) return 0;\\n        queue<Node*> q; q.push(root);\\n        int depth = 0;\\n        while (!q.empty()) {\\n            depth += 1;\\n            int breadth = q.size();\\n            for (int _ = 0; _ < breadth; ++_) {\\n                auto node = q.front(); q.pop();\\n                for (auto child : node->children) if (child) q.push(child);\\n            }\\n        }\\n        return depth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275725,
                "title": "python-dfs-solution-with-explanation",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, children):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        # Base case\\n        if root == None:\\n            return 0\\n        # Depth level of the tree\\n        depth = 0\\n        \\n        # Loops through children array\\n        for child in root.children:\\n            # Compares current depth of depth with a new level of depth \\n            # Sets the biggest value to variable depth\\n            depth = max(depth, self.maxDepth(child))\\n        \\n        # As going deeper into the tree increases depth by 1\\n        print (\\'root \\' + str(root.val) + \\' depth \\' + str(depth + 1))\\n        return depth + 1 \\n    \\n    # So for the first test case it\\'ll look like\\n    # first call is the call with root 1\\n    # depth = 0 -> second call with child 3 -> \\n    # it has 2 children so there\\'ll be two calls from for loop\\n    # call with child 5 -> sets the for loop with child of 5 which is None (Null)\\n    # this call hits base case and returns 0\\n    # the same happens with child 6\\n    # call to child 6 from the for loop -> child of 6 is None -> returns 0\\n    # depth = max(0, 0) -> depth = 0\\n    # return to one level higher -> call to child 5 reaches return statement ->\\n    # depth = 1\\n    # call to child 6 reaches return statement and it returns 1 ->\\n    # current depth is 1 because child 5 set it -> max(1, 1) -> depth = 1\\n    # return to one more level higher\\n    # call to child 3 reaches return statement ->\\n    # depth was equal to 1 now it becomes 2 (depth + 1)\\n    # now it\\'s turn to children 2 and 4 to be called\\n    # the story is exactly the same as with 5 and 6 only depth is now 2 ->\\n    # both 2 and 4 return depth 1 that\\'s why it\\'s rejected by max(2, 1)\\n    # depth remains 2\\n    # and finally everything returns to the very first call with root 1 \\n    # it reaches return statement and returns 2+1=3\\n```\\n\\nI hope it\\'ll help! \\nRecursion is difficult for me. It usually takes hours to solve a problem or wrap my head around a solution that other people post.",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, children):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        # Base case\\n        if root == None:\\n            return 0\\n        # Depth level of the tree\\n        depth = 0\\n        \\n        # Loops through children array\\n        for child in root.children:\\n            # Compares current depth of depth with a new level of depth \\n            # Sets the biggest value to variable depth\\n            depth = max(depth, self.maxDepth(child))\\n        \\n        # As going deeper into the tree increases depth by 1\\n        print (\\'root \\' + str(root.val) + \\' depth \\' + str(depth + 1))\\n        return depth + 1 \\n    \\n    # So for the first test case it\\'ll look like\\n    # first call is the call with root 1\\n    # depth = 0 -> second call with child 3 -> \\n    # it has 2 children so there\\'ll be two calls from for loop\\n    # call with child 5 -> sets the for loop with child of 5 which is None (Null)\\n    # this call hits base case and returns 0\\n    # the same happens with child 6\\n    # call to child 6 from the for loop -> child of 6 is None -> returns 0\\n    # depth = max(0, 0) -> depth = 0\\n    # return to one level higher -> call to child 5 reaches return statement ->\\n    # depth = 1\\n    # call to child 6 reaches return statement and it returns 1 ->\\n    # current depth is 1 because child 5 set it -> max(1, 1) -> depth = 1\\n    # return to one more level higher\\n    # call to child 3 reaches return statement ->\\n    # depth was equal to 1 now it becomes 2 (depth + 1)\\n    # now it\\'s turn to children 2 and 4 to be called\\n    # the story is exactly the same as with 5 and 6 only depth is now 2 ->\\n    # both 2 and 4 return depth 1 that\\'s why it\\'s rejected by max(2, 1)\\n    # depth remains 2\\n    # and finally everything returns to the very first call with root 1 \\n    # it reaches return statement and returns 2+1=3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152659,
                "title": "java-solution-with-explain-same-logic-with-maximum-depth-of-binary-tree",
                "content": "This question is same as the binary one.\\nFirst, let\\'s review the 104. Maximum Depth of Binary Tree\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int maxDepth(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int left = maxDepth(root.left);\\n        int right = maxDepth(root.right);\\n        return Math.max(left, right) + 1;\\n    }\\n}\\n```\\nFor current node, the maximum depth of this node is Math.max(node.left.depth, node.right.depth).\\nSo, what is the depth of node.left and node.right? You can put node.left as node. The recursive  method has been built.\\n\\nNow, for this question, there are not only left and right, but there are children. So, only change left, right as a children for loop.\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val,List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        int max = 0;\\n        for (Node child : root.children) { //replace left&right to for loop\\n            int value = maxDepth(child);\\n            \\n            if (value > max) {\\n                max = value;\\n            }\\n        }\\n        return max +1;\\n    }\\n}\\n```\\nActually, this code also works for binary tree.",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int maxDepth(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int left = maxDepth(root.left);\\n        int right = maxDepth(root.right);\\n        return Math.max(left, right) + 1;\\n    }\\n}\\n```\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val,List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        int max = 0;\\n        for (Node child : root.children) { //replace left&right to for loop\\n            int value = maxDepth(child);\\n            \\n            if (value > max) {\\n                max = value;\\n            }\\n        }\\n        return max +1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330666,
                "title": "3-python-solutions-recursion-bfs-dfs",
                "content": "2-line Recursion. In most tree problems, try recursion first.\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        return 1 + max(map(self.maxDepth, root.children or [None]))\\n```\\n\\t\\nBFS (use a queue, the last level we see will be the depth)\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        queue = []\\n        if root: queue.append((root, 1))\\n        depth = 0\\n        for (node, level) in queue:\\n            depth = level\\n            queue += [(child, level+1) for child in node.children]\\n        return depth\\n```\\n\\nDFS (use a stack, use max to update depth)\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        stack = []\\n        if root: stack.append((root, 1))\\n        depth = 0\\n        while stack:\\n            (node, d) = stack.pop()\\n            depth = max(depth, d)\\n            for child in node.children:\\n                stack.append((child, d+1))\\n        return depth\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        return 1 + max(map(self.maxDepth, root.children or [None]))\\n```\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        queue = []\\n        if root: queue.append((root, 1))\\n        depth = 0\\n        for (node, level) in queue:\\n            depth = level\\n            queue += [(child, level+1) for child in node.children]\\n        return depth\\n```\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        stack = []\\n        if root: stack.append((root, 1))\\n        depth = 0\\n        while stack:\\n            (node, d) = stack.pop()\\n            depth = max(depth, d)\\n            for child in node.children:\\n                stack.append((child, d+1))\\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723210,
                "title": "simple-c-solution-very-easy-to-understand-dfs-recursive",
                "content": "```\\n// DFS Recursive\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root==NULL)\\n            return 0;\\n        int max_depth = 1;\\n        for(int i=0;i<root->children.size();i++){\\n            max_depth = max(max_depth, 1 + maxDepth(root->children[i]));\\n        }\\n        return max_depth;\\n    }\\n};\\n```\\nFeel free to ask any question in the **comment** section.\\nIf you like this solution, do **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n// DFS Recursive\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root==NULL)\\n            return 0;\\n        int max_depth = 1;\\n        for(int i=0;i<root->children.size();i++){\\n            max_depth = max(max_depth, 1 + maxDepth(root->children[i]));\\n        }\\n        return max_depth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151804,
                "title": "solution-python-c-simple-with-explanation",
                "content": "In question 104, Maximum Depth of Binary Tree, to find the maximum of a binary tree we all know:\\n```\\nclass Solution:\\n    def maxDepth(self, root):\\n        if not root:\\n            return 0\\n        return max(self.maxDepth(root.left),self.maxDepth(root.right)) + 1\\n```\\n\\nSo similarly, for a N-ary Tree, instead of comparing depth between only left and right child nodes, we simply iterate all child nodes by ```(self.maxDepth(node) for node in root.children)``` and return the ``` max_depth``` on the current node by the fucntion ```max(child1, child2, ...)```. Eventually we will get the maximum depth for the root.\\n\\n<b>Python</b>\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        return max(self.maxDepth(node) for node in root.children) + 1\\n```\\n\\n36 / 36 test cases passed.\\nStatus: Accepted\\nRuntime: 102 ms\\n\\n<b>C++</b>\\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n    if (!root) return 0;\\n    int res = 1;\\n    for(Node* child : root->children) \\n        res = max(res, maxDepth(child) + 1);\\n    return res;\\n    }\\n};\\n```\\n36 / 36 test cases passed.\\nStatus: Accepted\\nRuntime: 40 ms",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root):\\n        if not root:\\n            return 0\\n        return max(self.maxDepth(root.left),self.maxDepth(root.right)) + 1\\n```\n```(self.maxDepth(node) for node in root.children)```\n``` max_depth```\n```max(child1, child2, ...)```\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        return max(self.maxDepth(node) for node in root.children) + 1\\n```\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n    if (!root) return 0;\\n    int res = 1;\\n    for(Node* child : root->children) \\n        res = max(res, maxDepth(child) + 1);\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 266547,
                "title": "4-solutions-in-python-from-easy-to-hard",
                "content": "```python\\nclass Solution1(object):\\n    def maxDepth(self, root):\\n        if not root: return 0 #base case 1\\n        if not root.children: return 1 #base case 2\\n        heights = [] #hold all the heights of root\\'s children \\n        for node in root.children:\\n            heights.append(self.maxDepth(node))\\n        return max(heights) + 1\\n\\n\\n#Simplify solution 1\\nclass Solution2(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        height = [self.maxDepth(node) for node in root.children]\\n        return max(height) + 1\\n\\n\\n#improve it one more step\\nclass Solution3(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if not root: return 0\\n        if not root.children: return 1\\n        return max(self.maxDepth(node) for node in root.children) + 1   \\n\\n\\n#Compare the heights in a loop\\nclass Solution4(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        height = 0\\n        for node in root.children:\\n            height = max(self.maxDepth(node), height)\\n        return height + 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution1(object):\\n    def maxDepth(self, root):\\n        if not root: return 0 #base case 1\\n        if not root.children: return 1 #base case 2\\n        heights = [] #hold all the heights of root\\'s children \\n        for node in root.children:\\n            heights.append(self.maxDepth(node))\\n        return max(heights) + 1\\n\\n\\n#Simplify solution 1\\nclass Solution2(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        height = [self.maxDepth(node) for node in root.children]\\n        return max(height) + 1\\n\\n\\n#improve it one more step\\nclass Solution3(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if not root: return 0\\n        if not root.children: return 1\\n        return max(self.maxDepth(node) for node in root.children) + 1   \\n\\n\\n#Compare the heights in a loop\\nclass Solution4(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        height = 0\\n        for node in root.children:\\n            height = max(self.maxDepth(node), height)\\n        return height + 1",
                "codeTag": "Java"
            },
            {
                "id": 658460,
                "title": "javascript-3-solutions",
                "content": "**DFS Recursion:**\\n```\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    let max = 0;\\n    for(let child of root.children) {\\n       max = Math.max(max, maxDepth(child));\\n    }\\n    return max + 1;\\n}\\n```\\n**DFS Recursion with helper function:**\\n```\\n\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    let max = -1;\\n    \\n    const helper = (node, depth) => {\\n        if(depth > max) max = depth;\\n        for(let c of node.children){\\n            helper(c, depth + 1);\\n        }\\n    }\\n    \\n    helper(root, 1)\\n    return max;\\n};\\n```\\n**BFS:**\\n```\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    // Note: it is not advised to use array as queue\\n    let queue = [], depthCount = 0;\\n    queue.push(root);\\n    \\n    while(queue.length > 0){\\n        let len = queue.length;\\n        \\n        for(let i = 0; i < len; i++){\\n            let node = queue.shift();\\n            for(let child of node.children) queue.push(child);\\n        }\\n        depthCount++;\\n    }\\n    return depthCount;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    let max = 0;\\n    for(let child of root.children) {\\n       max = Math.max(max, maxDepth(child));\\n    }\\n    return max + 1;\\n}\\n```\n```\\n\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    let max = -1;\\n    \\n    const helper = (node, depth) => {\\n        if(depth > max) max = depth;\\n        for(let c of node.children){\\n            helper(c, depth + 1);\\n        }\\n    }\\n    \\n    helper(root, 1)\\n    return max;\\n};\\n```\n```\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    // Note: it is not advised to use array as queue\\n    let queue = [], depthCount = 0;\\n    queue.push(root);\\n    \\n    while(queue.length > 0){\\n        let len = queue.length;\\n        \\n        for(let i = 0; i < len; i++){\\n            let node = queue.shift();\\n            for(let child of node.children) queue.push(child);\\n        }\\n        depthCount++;\\n    }\\n    return depthCount;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 255481,
                "title": "python-2-node-n-node-559",
                "content": "# 104. Maximum Depth of Binary Tree\\n\\nTime: O(N) Proportional to input nodes, Iterates all nodes once.\\nSpace: O(H) Maximum nodes within the temporary call stack\\n\\n**Base Case**: \\u5F53Node\\u4E3A\\u7A7A\\u7684\\u65F6\\u5019\\uFF0C\\u8FD4\\u56DE\\u9AD8\\u5EA6\\u4E3A0\\n\\n**Recursive Rule\\u7CBE\\u786E\\u7248\\u672C** : \\n\\u4F20\\u9012\\uFF1A \\u5DE6\\u53F3\\u5B69\\u5B50\\n\\u5411\\u4E0B\\u7D22\\u53D6\\uFF1A\\u4E0B\\u4E00\\u5C42\\u7684\\u5DE6\\u5B50\\u6811\\u548C\\u53F3\\u5B50\\u6811\\u7D22\\u53D6**\\u6700\\u9AD8\\u6DF1\\u5EA6**\\n\\u5411\\u4E0A\\u8FD4\\u56DE\\uFF1A\\u9009\\u62E9\\u66F4\\u9AD8\\u7684\\u6DF1\\u5EA6**\\u5E76\\u4E14**\\u52A0\\u4E0A\\u5F53\\u524D\\u5C42\\u6570\\u7684\\u9AD8\\u5EA6 (+1) \\u3002\\u6700\\u7EC8\\u8FD4\\u56DE\\u3002\\n\\n**Recursive Rule\\u8BF4\\u4EBA\\u8BDD**: \\n\\u8C01\\u9AD8\\u53D6\\u8C01\\uFF0C\\u5E76\\u52A0\\u4E00\\n\\n\\n```python\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        left = self.maxDepth(root.left)\\n        right= self.maxDepth(root.right)\\n        return max(left, right) + 1\\n```\\n\\n<br><br><br>\\n\\n# 559. Maximum Depth of N-ary Tree\\n\\n**Base Case**: \\n\\u5F53Node\\u4E3A\\u7A7A\\u7684\\u65F6\\u5019\\uFF0C\\u8FD4\\u56DE\\u9AD8\\u5EA6\\u4E3A0\\n\\u5982\\u679C\\u9700\\u8981\\u63D0\\u524DDereference node.children\\uFF0C\\u90A3\\u4E48\\u540C\\u65F6\\u4E5F\\u8981\\u7ED9node.children\\u505A\\u4E00\\u4E2Abasecase\\uFF0C\\u8FD4\\u56DE\\u9AD8\\u5EA61\\n\\n**Recursive Rule\\u7CBE\\u786E\\u7248\\u672C** : \\n\\u4F20\\u9012\\uFF1A root.children\\n\\u5411\\u4E0B\\u7D22\\u53D6\\uFF1A\\u4E0B\\u4E00\\u5C42\\u7684\\u6240\\u6709\\u5B69\\u5B50\\u7684**\\u6700\\u9AD8\\u6DF1\\u5EA6**\\n\\u5411\\u4E0A\\u8FD4\\u56DE\\uFF1A\\u9009\\u62E9\\u66F4\\u9AD8\\u7684\\u6DF1\\u5EA6**\\u5E76\\u4E14**\\u52A0\\u4E0A\\u5F53\\u524D\\u5C42\\u6570\\u7684\\u9AD8\\u5EA6 (+1) \\u3002\\u6700\\u7EC8\\u8FD4\\u56DE\\u3002\\n\\n**Recursive Rule\\u8BF4\\u4EBA\\u8BDD**: \\n\\u8C01\\u9AD8\\u53D6\\u8C01\\uFF0C\\u5E76\\u52A0\\u4E00\\n\\n## \\u6362\\u6C64\\u4E0D\\u6362\\u836F\\u505A\\u6CD5\\n\\nTime: O(N) Proportional to input nodes, Iterates all nodes once.\\nSpace: O(H * Tempoaray List Space)) Maximum nodes within the temporary call stack, along with a list initialized on each level of call stack.\\n\\n\\u6362\\u6C64\\u4E0D\\u6362\\u836F\\u505A\\u6CD5\\uFF0C\\u5229\\u7528104\\u7684\\u601D\\u7EF4\\uFF0C104\\u6BCF\\u5C42\\u6BD4\\u5BF9\\u5DE6\\u53F3\\u5B69\\u5B50\\uFF0C\\u90A3\\u4E48\\u6211\\u4EEC\\u5728\\u6BCF\\u4E00\\u5C42\\u521B\\u5EFA\\u4E00\\u4E2A\\u4E34\\u65F6\\u7684List\\u7528\\u6765\\u4FDD\\u5B58\\u5F53\\u524DNode\\u7684\\u6240\\u6709\\u5B50\\u5B69\\u5B50\\u4F20\\u9012\\u4E0A\\u6765\\u7684\\u9AD8\\u5EA6\\uFF0C\\u53D6\\u5176\\u6700\\u5927\\u8FD4\\u56DE\\n\\n```python\\n# Readable\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        height = []\\n        for node in root.children:\\n            height.append(self.maxDepth(node))\\n        return max(height) + 1\\n\\n#Pythonic\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        height = [self.maxDepth(node) for node in root.children]\\n        return max(height) + 1\\n```\\n\\n## \\u5229\\u7528\\u53D8\\u91CF\\u4EE3\\u66FF\\u6BCF\\u5C42\\u7684Temporary List\\n\\nTime: O(N) Proportional to input nodes, Iterates all nodes once.\\nSpace: O(H) Maximum nodes within the temporary call stack\\n\\n\\u6362\\u4E86\\u70B9\\u836F\\uFF0C\\u5176\\u5B9E\\u4E5F\\u4E00\\u6837\\uFF0C\\u5C31\\u662F\\u6BCF\\u5C42\\u4E0D\\u9700\\u8981List\\uFF0C\\u7528\\u4E00\\u4E2A\\u53D8\\u91CF\\u4EE3\\u66FF\\u5373\\u53EF\\u3002\\n\\n```python\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        height = 0\\n        for node in root.children:\\n            height = max(self.maxDepth(node), height)\\n        return height + 1\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        left = self.maxDepth(root.left)\\n        right= self.maxDepth(root.right)\\n        return max(left, right) + 1\\n```\n```python\\n# Readable\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        height = []\\n        for node in root.children:\\n            height.append(self.maxDepth(node))\\n        return max(height) + 1\\n\\n#Pythonic\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        height = [self.maxDepth(node) for node in root.children]\\n        return max(height) + 1\\n```\n```python\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        height = 0\\n        for node in root.children:\\n            height = max(self.maxDepth(node), height)\\n        return height + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339873,
                "title": "java-1ms-solution-dfs-faster-than-99-8-lines",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root==null) return 0;\\n        int max_depth = 0;\\n        for(Node child: root.children) {\\n            max_depth = Math.max(max_depth, maxDepth(child));\\n        }\\n        return 1 + max_depth;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxDepth(Node root) {\\n        if(root==null) return 0;\\n        int max_depth = 0;\\n        for(Node child: root.children) {\\n            max_depth = Math.max(max_depth, maxDepth(child));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 169244,
                "title": "bfs-python-check-all-the-nodes-per-level-99",
                "content": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if root == None:\\n            return 0\\n        depth = 0\\n        stack = [root]\\n        while stack:\\n            next_level = []\\n            while stack:\\n                node = stack.pop()\\n                if node.children:\\n                    next_level += node.children\\n            stack = next_level\\n            depth += 1\\n        return depth\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if root == None:\\n            return 0\\n        depth = 0\\n        stack = [root]\\n        while stack:\\n            next_level = []\\n            while stack:\\n                node = stack.pop()\\n                if node.children:\\n                    next_level += node.children\\n            stack = next_level\\n            depth += 1\\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470308,
                "title": "java-simple-dfs-solution-with-comments-100-fast-and-100-less-space",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        \\n        if(root == null) {\\n            return 0;\\n        }\\n        \\n        //already height is 1 if node is not null\\n        int height = 1;\\n        \\n        for(Node node : root.children) {\\n            \\n\\t\\t\\t//track max height.\\n            height = Math.max(height, 1+maxDepth(node)); //1+maxDepth(node) will calculate depth recursively.\\n        }\\n        \\n        return height;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        \\n        if(root == null) {\\n            return 0;\\n        }\\n        \\n        //already height is 1 if node is not null\\n        int height = 1;\\n        \\n        for(Node node : root.children) {\\n            \\n\\t\\t\\t//track max height.\\n            height = Math.max(height, 1+maxDepth(node)); //1+maxDepth(node) will calculate depth recursively.\\n        }\\n        \\n        return height;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374244,
                "title": "javascript-recursive-solution",
                "content": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n/**\\n * @param {Node} root\\n * @return {number}\\n */\\nvar maxDepth = function(root) {\\n    if (root == null) {\\n        return 0;\\n    }\\n    \\n    let max = 0;\\n    for (let child of root.children) {\\n        max = Math.max(max, maxDepth(child));\\n    }\\n    \\n    return max + 1;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n/**\\n * @param {Node} root\\n * @return {number}\\n */\\nvar maxDepth = function(root) {\\n    if (root == null) {\\n        return 0;\\n    }\\n    \\n    let max = 0;\\n    for (let child of root.children) {\\n        max = Math.max(max, maxDepth(child));\\n    }\\n    \\n    return max + 1;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 684633,
                "title": "simple-easy-solution-using-dfs-by-python-3",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n\\n        depth = 1\\n        if root.children:\\n            depth += max(self.maxDepth(child) for child in root.children)\\n        return depth\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n\\n        depth = 1\\n        if root.children:\\n            depth += max(self.maxDepth(child) for child in root.children)\\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148544,
                "title": "java-top-down-dfs-solutions",
                "content": "Top Down\\n```JAVA\\nprivate int max = 0;\\npublic int maxDepth(Node root) {\\n    if (root == null) return 0;\\n    maxDepth(root, 1);\\n    return max;\\n} \\n    \\npublic void maxDepth(Node node, int depth) {\\n    if (node == null) return;\\n    max = Math.max(max, depth);\\n    for (Node child : node.children){\\n        maxDepth(child, depth+1);\\n    }\\n}",
                "solutionTags": [],
                "code": "Top Down\\n```JAVA\\nprivate int max = 0;\\npublic int maxDepth(Node root) {\\n    if (root == null) return 0;\\n    maxDepth(root, 1);\\n    return max;\\n} \\n    \\npublic void maxDepth(Node node, int depth) {\\n    if (node == null) return;\\n    max = Math.max(max, depth);\\n    for (Node child : node.children){\\n        maxDepth(child, depth+1);\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 952462,
                "title": "python-bfs-iterative-beats-92",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        \\n        nodes = deque()\\n        nodes.append((root, 1))\\n        maxx = 0\\n        while nodes:\\n            cur, val = nodes.popleft()\\n            maxx = val\\n            if cur.children:\\n                for child in cur.children:\\n                    nodes.append((child, val+1))\\n        return maxx\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        \\n        nodes = deque()\\n        nodes.append((root, 1))\\n        maxx = 0\\n        while nodes:\\n            cur, val = nodes.popleft()\\n            maxx = val\\n            if cur.children:\\n                for child in cur.children:\\n                    nodes.append((child, val+1))\\n        return maxx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044279,
                "title": "java-all-approach-recursive-iterative-dfs-iterative-bfs",
                "content": "**Recursive**\\n```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if (root == null) return 0;\\n        int max = 0;\\n        for (Node child : root.children)\\n            max = Math.max(max, maxDepth(child));\\n        return max +1;\\n    }\\n}\\n```\\n\\n**Iterative BFS**\\n```\\nclass Solution {\\n     public int maxDepth(Node root) {\\n         if (root == null) return 0;\\n        \\n         Queue<Node> queue = new LinkedList<>();\\n         queue.offer(root);\\n         int level = 0;\\n         while (!queue.isEmpty()){\\n            int size = queue.size();\\n             for (int i=0;i<size;i++){\\n                 Node node = queue.poll();\\n                 for(Node n: node.children)\\n                     queue.offer(n);\\n             }\\n             level++;\\n         }\\n         return level;\\n     }\\n}\\n```\\n**Iterative DFS**\\n\\n```\\n     \\tpublic int maxDepth(Node root) {\\n         if(root == null) return 0;\\n         \\n         Stack<Node> stack = new Stack<>();\\n         Stack<Integer> depth = new Stack<>();\\n         stack.push(root);\\n         depth.push(1);\\n         int max = 1;\\n        \\n         while(!stack.isEmpty()) {\\n             Node n = stack.pop();\\n             int d = depth.pop();\\n            \\n             for(Node node: n.children) {\\n                 max = Math.max(d + 1, maxDepth);\\n                 stack.push(node);\\n                 depth.push(d + 1);\\n             }\\n         }\\n        return max;\\n     }\\n }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if (root == null) return 0;\\n        int max = 0;\\n        for (Node child : root.children)\\n            max = Math.max(max, maxDepth(child));\\n        return max +1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n     public int maxDepth(Node root) {\\n         if (root == null) return 0;\\n        \\n         Queue<Node> queue = new LinkedList<>();\\n         queue.offer(root);\\n         int level = 0;\\n         while (!queue.isEmpty()){\\n            int size = queue.size();\\n             for (int i=0;i<size;i++){\\n                 Node node = queue.poll();\\n                 for(Node n: node.children)\\n                     queue.offer(n);\\n             }\\n             level++;\\n         }\\n         return level;\\n     }\\n}\\n```\n```\\n     \\tpublic int maxDepth(Node root) {\\n         if(root == null) return 0;\\n         \\n         Stack<Node> stack = new Stack<>();\\n         Stack<Integer> depth = new Stack<>();\\n         stack.push(root);\\n         depth.push(1);\\n         int max = 1;\\n        \\n         while(!stack.isEmpty()) {\\n             Node n = stack.pop();\\n             int d = depth.pop();\\n            \\n             for(Node node: n.children) {\\n                 max = Math.max(d + 1, maxDepth);\\n                 stack.push(node);\\n                 depth.push(d + 1);\\n             }\\n         }\\n        return max;\\n     }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840332,
                "title": "c-bfs-vs-dfs-solutions-compared-and-explained-100-time-80-space",
                "content": "First approach, in pure BFS style, we first of all check if the tree is empty (in which case its height is of course `0`); if not, we create a queue and populate it initially with `root->children`; we also create a counter variable `level`, initially set to `1` (if we are here, it means we have at least a valid root).\\n\\nWe then start looping while `len` (set to match the length of our queue at each iteration) is not `0` - ie: there are still elements in the queue.\\n\\nInside the loop, we have a for loop running `len` times, one for each member of the current level of the tree (taken and popped from the front one by one), and add its children, if any, to end the next queue; after having updated the queue itself, we update consequently `len` and increase `level` by `1`.\\n\\nAfter the loop, we just return `len` :)\\n\\nThe BFS code, which run up to 90% Time and 80% Space:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        // edge case: empty tree\\n        if (!root) return 0;\\n        // support variables\\n        int level = 1, len;\\n        Node *curr;\\n        // preparing for a BFS\\n        queue<Node*> q;\\n        for (auto n: root->children) q.push(n);\\n        len = q.size();\\n        while (len) {\\n            // updating q with a new layer of items\\n            for (int i = 0; i < len; i++) {\\n                curr = q.front();\\n                q.pop();\\n                // adding new children to the queue\\n                for (auto n: curr->children) q.push(n);\\n            }\\n            // updating len and level\\n            len = q.size();\\n            level++;\\n        }\\n        return level;\\n    }\\n};\\n```\\n\\nIn my alternative going for a DFS, I just declared a `maxLevel` class variable, initially set to `0`, to track how deep we go; in the main function, I just invoke my helper `dfs` and then return this variable.\\n\\nIn `dfs` first of all I check if I have a root - if not, I exit; otherwise I update both `maxLevel` and the function\\'s optional second parameter `currLevel` in one fell swoop and finally I call `dfs` again on each child, with the updated value of `currLevel` I just increased in the above line.\\n\\nDFS version that \\\\*SPOILER\\\\* is much more compact and quicker (100% Time), also apparently using a bit less memory:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxLevel = 0;\\n    void dfs(Node* root, int currLevel = 1) {\\n        // exit condition\\n        if (!root) return;\\n        // updating both maxLevel and currLevel at the same time\\n        maxLevel = max(maxLevel, currLevel++);\\n        // recursing all the way down!\\n        for (auto n: root->children) dfs(n, currLevel);\\n    }\\n    int maxDepth(Node* root) {\\n        dfs(root);\\n        return maxLevel;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        // edge case: empty tree\\n        if (!root) return 0;\\n        // support variables\\n        int level = 1, len;\\n        Node *curr;\\n        // preparing for a BFS\\n        queue<Node*> q;\\n        for (auto n: root->children) q.push(n);\\n        len = q.size();\\n        while (len) {\\n            // updating q with a new layer of items\\n            for (int i = 0; i < len; i++) {\\n                curr = q.front();\\n                q.pop();\\n                // adding new children to the queue\\n                for (auto n: curr->children) q.push(n);\\n            }\\n            // updating len and level\\n            len = q.size();\\n            level++;\\n        }\\n        return level;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxLevel = 0;\\n    void dfs(Node* root, int currLevel = 1) {\\n        // exit condition\\n        if (!root) return;\\n        // updating both maxLevel and currLevel at the same time\\n        maxLevel = max(maxLevel, currLevel++);\\n        // recursing all the way down!\\n        for (auto n: root->children) dfs(n, currLevel);\\n    }\\n    int maxDepth(Node* root) {\\n        dfs(root);\\n        return maxLevel;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148882,
                "title": "python-4-lines-bfs-1-line-dfs-solutions",
                "content": "* BFS\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        q, level = root and [root], 0\\n        while q:\\n            q, level = [child for node in q for child in node.children if child], level + 1\\n        return level \\n```\\n* DFS\\n```\\nclass Solution(object):\\n    def maxDepth(self, root, level = 1):\\n        return max(root and [self.maxDepth(child, level + 1) for child in root.children] + [level] or [0])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        q, level = root and [root], 0\\n        while q:\\n            q, level = [child for node in q for child in node.children if child], level + 1\\n        return level \\n```\n```\\nclass Solution(object):\\n    def maxDepth(self, root, level = 1):\\n        return max(root and [self.maxDepth(child, level + 1) for child in root.children] + [level] or [0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557851,
                "title": "3-sol-bfs-dfs-easy-to-understand-faster-simple-python-solution",
                "content": "```\\n    def iterative_bfs(self, root):\\n        if not root: return 0\\n        stack = [root]\\n        out = 0\\n        while len(stack):\\n            temp = []\\n            while len(stack):\\n                ele = stack.pop()\\n                for node in ele.children:\\n                    temp.append(node)\\n            stack = temp\\n            out += 1\\n            \\n        return out\\n            \\n    \\n    def iterative_dfs(self, root):\\n        if not root: return 0\\n        stack = [[root, 0]]\\n        out = 1\\n        while len(stack):\\n            top, level = stack.pop()\\n            for node in top.children:\\n                stack.append([node, level + 1])\\n            out = max(out, 1 + level)\\n        return out\\n    \\n    def recursive(self, root):\\n        def rec(root):\\n            if root:\\n                curr = 1\\n                for node in root.children:\\n                    curr = max(curr, 1 + rec(node))\\n                return curr\\n            return 0\\n        return rec(root)\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    def iterative_bfs(self, root):\\n        if not root: return 0\\n        stack = [root]\\n        out = 0\\n        while len(stack):\\n            temp = []\\n            while len(stack):\\n                ele = stack.pop()\\n                for node in ele.children:\\n                    temp.append(node)\\n            stack = temp\\n            out += 1\\n            \\n        return out\\n            \\n    \\n    def iterative_dfs(self, root):\\n        if not root: return 0\\n        stack = [[root, 0]]\\n        out = 1\\n        while len(stack):\\n            top, level = stack.pop()\\n            for node in top.children:\\n                stack.append([node, level + 1])\\n            out = max(out, 1 + level)\\n        return out\\n    \\n    def recursive(self, root):\\n        def rec(root):\\n            if root:\\n                curr = 1\\n                for node in root.children:\\n                    curr = max(curr, 1 + rec(node))\\n                return curr\\n            return 0\\n        return rec(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 222144,
                "title": "javascript-bfs",
                "content": "```\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    let depth = 0;\\n    let queue = [];\\n    queue.push(root);\\n\\n    while (queue.length){\\n      let queueSize = queue.length;\\n\\n      for(let i = 0; i < queueSize; i++){\\n        let node = queue.shift();\\n        queue.push(...node.children);\\n      }\\n\\n      depth++;\\n    }\\n\\n    return depth;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxDepth = function(root) {\\n    if(!root) return 0;\\n    let depth = 0;\\n    let queue = [];\\n    queue.push(root);\\n\\n    while (queue.length){\\n      let queueSize = queue.length;\\n\\n      for(let i = 0; i < queueSize; i++){\\n        let node = queue.shift();\\n        queue.push(...node.children);\\n      }\\n\\n      depth++;\\n    }\\n\\n    return depth;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3326128,
                "title": "what-about-minimum-depth-of-n-ary-tree",
                "content": "# **I Have Tried To Do The Code For Minimum Depth Or N-ary Tree**\\n\\n```\\nclass Solution {\\npublic:\\n\\tint minDepth(Node* root) {\\n\\t\\tif (!root) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tif (root->children.empty()) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint min_depth = 0;\\n\\t\\tfor (auto child : root->children) {\\n\\t\\t\\tmin_depth = min(min_depth, minDepth(child));\\n\\t\\t}\\n\\n\\t\\treturn min_depth + 1;\\n\\t}\\n};\\n\\n```\\n\\n### Don\\'t Forget To Give Some Suggestions, Point Out Mistakes And Comments.\\n\\n#### Put The Comment If You Find Out Some Kind Of Error In The Code.\\n\\n### **Thanks You :)**\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minDepth(Node* root) {\\n\\t\\tif (!root) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tif (root->children.empty()) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint min_depth = 0;\\n\\t\\tfor (auto child : root->children) {\\n\\t\\t\\tmin_depth = min(min_depth, minDepth(child));\\n\\t\\t}\\n\\n\\t\\treturn min_depth + 1;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545916,
                "title": "go-recursive-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Maximum Depth of N-ary Tree.\\nMemory Usage: 3.3 MB, less than 100.00% of Go online submissions for Maximum Depth of N-ary Tree.\\n```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Children []*Node\\n * }\\n */\\n\\nfunc maxDepth(root *Node) int {\\n    if root == nil {\\n        return 0\\n    }\\n    m := 1\\n    for _, v := range root.Children {\\n        m = max(m, maxDepth(v)+1)\\n    }\\n    return m\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Children []*Node\\n * }\\n */\\n\\nfunc maxDepth(root *Node) int {\\n    if root == nil {\\n        return 0\\n    }\\n    m := 1\\n    for _, v := range root.Children {\\n        m = max(m, maxDepth(v)+1)\\n    }\\n    return m\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 334674,
                "title": "javascript-js-one-line-recursive-solution",
                "content": "if `root` is null, return `0`\\nelse return max of its children\\'s `maxDepth + 1`\\n```\\nvar maxDepth = function (root) {\\n  return root ? root.children.reduce((r, n) => Math.max(r, maxDepth(n)), 0) + 1 : 0;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "if `root` is null, return `0`\\nelse return max of its children\\'s `maxDepth + 1`\\n```\\nvar maxDepth = function (root) {\\n  return root ? root.children.reduce((r, n) => Math.max(r, maxDepth(n)), 0) + 1 : 0;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3298776,
                "title": "559-time-95-76-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Check if the root node is None. If it is, return 0 as the maximum depth since there are no nodes in the tree.\\n2. Create a variable called max_depth and set it to 0. This variable will keep track of the maximum depth of the tree.\\n3. Iterate through each child node of the root node.\\n4. Recursively call the maxDepth function on each child node to get the maximum depth of that subtree.\\n5. Compare the maximum depth of the current subtree to the current max_depth variable. If the maximum depth is greater than max_depth, set max_depth to the maximum depth of the current subtree.\\n6. Return max_depth plus 1, since we need to count the root node itself in the depth calculation.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a Node.\\n# class Node:\\n#     def __init__(self, val=None, children=None):\\n#         self.val = val\\n#         self.children = children if children is not None else []\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        max_depth = 0\\n        for child in root.children:\\n            max_depth = max(max_depth, self.maxDepth(child))\\n        return max_depth + 1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a Node.\\n# class Node:\\n#     def __init__(self, val=None, children=None):\\n#         self.val = val\\n#         self.children = children if children is not None else []\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        max_depth = 0\\n        for child in root.children:\\n            max_depth = max(max_depth, self.maxDepth(child))\\n        return max_depth + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090004,
                "title": "python-one-liner",
                "content": "```\\ndef maxDepth(self, root: \\'Node\\') -> int:\\n        return max([0] + [self.maxDepth(c) for c in root.children]) + 1 if root else 0\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef maxDepth(self, root: \\'Node\\') -> int:\\n        return max([0] + [self.maxDepth(c) for c in root.children]) + 1 if root else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1985642,
                "title": "python-easy-solution-faster-than-94-submits",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        \\n        if not root : return 0\\n        \\n        if root.children :\\n            return 1 + max([self.maxDepth(x) for x in root.children])\\n        else :\\n            return 1 \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        \\n        if not root : return 0\\n        \\n        if root.children :\\n            return 1 + max([self.maxDepth(x) for x in root.children])\\n        else :\\n            return 1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061186,
                "title": "simple-c-solution-using-dfs",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    int maxDepth(Node* root) {\\n        if(!root) return 0;\\n        \\n        int max=0;\\n        for(auto child: root->children){\\n            int height = maxDepth(child);\\n            if(height>max) max=height;\\n        }\\n        return 1+max;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    int maxDepth(Node* root) {\\n        if(!root) return 0;\\n        \\n        int max=0;\\n        for(auto child: root->children){\\n            int height = maxDepth(child);\\n            if(height>max) max=height;\\n        }\\n        return 1+max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358352,
                "title": "python-recursive-solution-top-down-and-bottom-up",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val, children):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\n#   Bottom-Up approach\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if root is None:\\n            return 0\\n        maxDepthOfChildren = 0\\n        for child in root.children:\\n            depth = self.maxDepth(child)\\n            maxDepthOfChildren = max(maxDepthOfChildren, depth)\\n        return maxDepthOfChildren + 1\\n    \\n    \\n    \\n    \\n#   Top-Down approach\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if root is None:\\n            return 0\\n        return self.maxDepthHelper(root, 1, 1)\\n    \\n    def maxDepthHelper(self, root, depth, maxDepth):\\n        if root is None:\\n            return maxDepth\\n        maxDepth = max(depth, maxDepth)\\n        for child in root.children:\\n            maxDepth = self.maxDepthHelper(child, depth + 1, maxDepth)\\n        return maxDepth\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val, children):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\n#   Bottom-Up approach\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if root is None:\\n            return 0\\n        maxDepthOfChildren = 0\\n        for child in root.children:\\n            depth = self.maxDepth(child)\\n            maxDepthOfChildren = max(maxDepthOfChildren, depth)\\n        return maxDepthOfChildren + 1\\n    \\n    \\n    \\n    \\n#   Top-Down approach\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if root is None:\\n            return 0\\n        return self.maxDepthHelper(root, 1, 1)\\n    \\n    def maxDepthHelper(self, root, depth, maxDepth):\\n        if root is None:\\n            return maxDepth\\n        maxDepth = max(depth, maxDepth)\\n        for child in root.children:\\n            maxDepth = self.maxDepthHelper(child, depth + 1, maxDepth)\\n        return maxDepth\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561519,
                "title": "c-3-solutions-recursive-iterative-level-order-traversal-clean-code",
                "content": "### Solution 1: recursive\\n\\n```\\n    static int maxDepth(const Node* root) {\\n        if (!root) return 0;\\n        int max_child = 0;\\n        for (const Node* child : root->children) {\\n            max_child = max(max_child, maxDepth(child));\\n        }\\n        return 1 + max_child;\\n    }\\n```\\n\\n### Solution 2: iterative DFS/BFS\\n\\nThis is the DFS solution, but we could just replace the ```stack``` with a ```queue``` and we would have a BFS solution.\\n\\n```\\n    static int maxDepth(const Node* root) {\\n        if (!root) return 0;\\n        \\n        stack<pair<const Node*, int>> st;\\n        st.push({root, 1});\\n        int ans = 1;\\n        while (!empty(st)) {\\n            const auto [node, depth] = st.top(); st.pop();\\n            ans = max(ans, depth);\\n            for (const Node* child : node->children) {\\n                st.push({child, depth + 1});\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n### Solution 3: level order traversal (BFS)\\n\\nThis was inspired by a submission from @pan_vis98.\\n\\n```\\n    static int maxDepth(const Node* root) {\\n        if (!root) return 0;\\n        \\n        queue<const Node*> q;\\n        q.push(root);\\n        int ans = 0;\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            while (q_size--) {\\n                const Node* node = q.front(); q.pop();\\n                \\n                for (const Node* child : node->children) {\\n                    q.push(child);\\n                }\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n```\\n\\n_As always: Feedback, questions, and comments are welcome. Please upvote if you like this post._\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    static int maxDepth(const Node* root) {\\n        if (!root) return 0;\\n        int max_child = 0;\\n        for (const Node* child : root->children) {\\n            max_child = max(max_child, maxDepth(child));\\n        }\\n        return 1 + max_child;\\n    }\\n```\n```stack```\n```queue```\n```\\n    static int maxDepth(const Node* root) {\\n        if (!root) return 0;\\n        \\n        stack<pair<const Node*, int>> st;\\n        st.push({root, 1});\\n        int ans = 1;\\n        while (!empty(st)) {\\n            const auto [node, depth] = st.top(); st.pop();\\n            ans = max(ans, depth);\\n            for (const Node* child : node->children) {\\n                st.push({child, depth + 1});\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\n    static int maxDepth(const Node* root) {\\n        if (!root) return 0;\\n        \\n        queue<const Node*> q;\\n        q.push(root);\\n        int ans = 0;\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            while (q_size--) {\\n                const Node* node = q.front(); q.pop();\\n                \\n                for (const Node* child : node->children) {\\n                    q.push(child);\\n                }\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1172377,
                "title": "100-faster-98-45-less-space-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int height(Node* root){\\n        if(root == NULL)return 0;\\n        int maxht = 1;\\n        for(Node* child: root->children){\\n            maxht = max(maxht, height(child)+1);\\n        }\\n        return maxht;\\n    }\\n    \\n    int maxDepth(Node* root) {\\n        Node* ans = root;\\n        return height(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int height(Node* root){\\n        if(root == NULL)return 0;\\n        int maxht = 1;\\n        for(Node* child: root->children){\\n            maxht = max(maxht, height(child)+1);\\n        }\\n        return maxht;\\n    }\\n    \\n    int maxDepth(Node* root) {\\n        Node* ans = root;\\n        return height(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318921,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == NULL)\\n            return 0;\\n\\n        int maxChildDepth = 0;\\n        for (Node* child : root->children)\\n        {\\n            int childDepth = maxDepth(child);\\n            if (childDepth > maxChildDepth)\\n                maxChildDepth = childDepth;\\n        }\\n        return 1 + maxChildDepth;       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == NULL)\\n            return 0;\\n\\n        int maxChildDepth = 0;\\n        for (Node* child : root->children)\\n        {\\n            int childDepth = maxDepth(child);\\n            if (childDepth > maxChildDepth)\\n                maxChildDepth = childDepth;\\n        }\\n        return 1 + maxChildDepth;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106427,
                "title": "java-0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n         if(root==null) return 0;\\n         \\n         int max=0;\\n      \\n          for(Node c: root.children){\\n              max = Math.max(max, maxDepth(c));\\n              }\\n        return 1+max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n         if(root==null) return 0;\\n         \\n         int max=0;\\n      \\n          for(Node c: root.children){\\n              max = Math.max(max, maxDepth(c));\\n              }\\n        return 1+max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997742,
                "title": "javascript-solution-beats-88-97-recursive-approach",
                "content": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node|null} root\\n * @return {number}\\n */\\nvar maxDepth = function(root) {\\n    if (root == null)\\n        return 0;\\n    \\n    let maximumDepth = 0;\\n    for (let node of root.children){\\n        maximumDepth = Math.max(maximumDepth, maxDepth(node));\\n    }\\n    return maximumDepth + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node|null} root\\n * @return {number}\\n */\\nvar maxDepth = function(root) {\\n    if (root == null)\\n        return 0;\\n    \\n    let maximumDepth = 0;\\n    for (let node of root.children){\\n        maximumDepth = Math.max(maximumDepth, maxDepth(node));\\n    }\\n    return maximumDepth + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2354757,
                "title": "java-trees",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root==null) return 0;\\n\\n        int max=0;\\n        for(Node child:root.children)\\n            max=Math.max(max,maxDepth(child));\\n\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root==null) return 0;\\n\\n        int max=0;\\n        for(Node child:root.children)\\n            max=Math.max(max,maxDepth(child));\\n\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723779,
                "title": "c-simple-and-short",
                "content": "**plz Upvote If You Like It :**\\n```\\nclass Solution {\\npublic:\\n    int height(Node* root){\\n        if(!root){\\n            return 0;\\n        }\\n        int maxHeight = 0;\\n        for(auto child : root->children){\\n            maxHeight = max(height(child),maxHeight);\\n        }\\n        return maxHeight + 1;\\n    }\\n    int maxDepth(Node* root) {\\n        return height(root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int height(Node* root){\\n        if(!root){\\n            return 0;\\n        }\\n        int maxHeight = 0;\\n        for(auto child : root->children){\\n            maxHeight = max(height(child),maxHeight);\\n        }\\n        return maxHeight + 1;\\n    }\\n    int maxDepth(Node* root) {\\n        return height(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629671,
                "title": "python-o-n-by-dfs-90-w-comment",
                "content": "Python O(n) by DFS\\n\\n---\\n\\n**Implementation** by DFS:\\n\\n```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        \\n        if root is None:\\n            # empty node or empty tree\\n            return 0\\n    \\n        else:\\n            # DFS to choose the longest path\\n            \\n            if root.children:\\n                # current node has subtrees\\n                return max( self.maxDepth(child) for child in root.children ) + 1\\n            \\n            else:\\n                # current node is leaf node\\n                return 1\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #111 Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree)\\n\\n[Leetcode #104 Maximum Depth of Binary Tree ](https://leetcode.com/problems/maximum-depth-of-binary-tree)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        \\n        if root is None:\\n            # empty node or empty tree\\n            return 0\\n    \\n        else:\\n            # DFS to choose the longest path\\n            \\n            if root.children:\\n                # current node has subtrees\\n                return max( self.maxDepth(child) for child in root.children ) + 1\\n            \\n            else:\\n                # current node is leaf node\\n                return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546927,
                "title": "c-bfs-and-dfs-solutions",
                "content": "**BFS solution**\\n```\\npublic class Solution {\\n    public int MaxDepth(Node root) {\\n        \\n        if(root == null)\\n            return 0;\\n        \\n        Queue<Node> queue = new Queue<Node>();\\n        queue.Enqueue(root);\\n        int depth = 0;\\n        while(queue.Count > 0)\\n        {\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++)\\n            {\\n                Node curr = queue.Dequeue();           \\n                foreach(Node node in curr.children)\\n                    queue.Enqueue(node);\\n            }\\n            depth++;\\n        }\\n        \\n        return depth;\\n    }\\n}\\n```\\n\\n**DFS solution version 1**\\n```\\npublic class Solution\\n{\\n    public int MaxDepth(Node root)\\n    {\\n        if (root == null)\\n            return 0;\\n\\n        List<int> depth = new List<int>(); // store children\\'s depths in a list, root\\'s maximum depth will be Max(children\\'s depths) + 1\\n        foreach (Node node in root.children)\\n        {\\n            int currDepth = MaxDepth(node);\\n            depth.Add(currDepth);\\n        }\\n\\n        return depth.Count == 0 ? 1 : depth.Max() + 1;\\n    }\\n}\\n```\\n**DFS solution version 2**\\n```\\npublic class Solution\\n{\\n    public int MaxDepth(Node root)\\n    {\\n        if (root == null)\\n            return 0;\\n\\n        int depth = 0; \\n\\n        foreach (Node node in root.children)\\n        {\\n            int currDepth = MaxDepth(node);\\n            depth = Math.Max(depth, currDepth); // // maximum depth of current root node\\'s children layer\\n        }\\n\\n        return depth + 1; // maximum depth of current layer\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxDepth(Node root) {\\n        \\n        if(root == null)\\n            return 0;\\n        \\n        Queue<Node> queue = new Queue<Node>();\\n        queue.Enqueue(root);\\n        int depth = 0;\\n        while(queue.Count > 0)\\n        {\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++)\\n            {\\n                Node curr = queue.Dequeue();           \\n                foreach(Node node in curr.children)\\n                    queue.Enqueue(node);\\n            }\\n            depth++;\\n        }\\n        \\n        return depth;\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int MaxDepth(Node root)\\n    {\\n        if (root == null)\\n            return 0;\\n\\n        List<int> depth = new List<int>(); // store children\\'s depths in a list, root\\'s maximum depth will be Max(children\\'s depths) + 1\\n        foreach (Node node in root.children)\\n        {\\n            int currDepth = MaxDepth(node);\\n            depth.Add(currDepth);\\n        }\\n\\n        return depth.Count == 0 ? 1 : depth.Max() + 1;\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int MaxDepth(Node root)\\n    {\\n        if (root == null)\\n            return 0;\\n\\n        int depth = 0; \\n\\n        foreach (Node node in root.children)\\n        {\\n            int currDepth = MaxDepth(node);\\n            depth = Math.Max(depth, currDepth); // // maximum depth of current root node\\'s children layer\\n        }\\n\\n        return depth + 1; // maximum depth of current layer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472341,
                "title": "javascript-with-dfs-and-bfs",
                "content": "**Setup**\\n```\\nif (!root) return 0    \\nlet depth = 1\\n\\n// Enter DFS or BFS method here\\n\\nreturn depth\\n```\\n    \\n**DFS method** (recursive)\\n```\\n const dfs = (node, level) => {\\n\\t if (node) {\\n\\t\\t if (level > depth) depth = level\\n\\n\\t\\t if (node.children.length) {\\n\\t\\t\\t node.children.forEach(vertex => dfs(vertex, level + 1))\\n\\t\\t }\\n\\t }\\n }\\n\\n dfs(root, 1)\\n```\\n    \\n**BFS method** (iterative)\\nBecause `Array.shift` has to move the entire array over after removing the first element, its inefficient. For the purposes of this demonstration, lets just say we have `O(1)` for all operations if we used a double-ended queue, otherwise if we just use a standard JS array its `O(n)`.\\n```\\nconst queue = [{ node: root, level: 1 }]\\n\\nwhile (queue.length) {\\n\\tconst { node, level } = queue.shift()\\n\\n\\tif (level > depth) depth = level\\n\\n\\tif (node.children.length) {\\n\\t\\tnode.children.forEach(vertex => queue.push({\\n\\t\\t\\tnode: vertex,\\n\\t\\t\\tlevel: level + 1\\n\\t\\t}))\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nif (!root) return 0    \\nlet depth = 1\\n\\n// Enter DFS or BFS method here\\n\\nreturn depth\\n```\n```\\n const dfs = (node, level) => {\\n\\t if (node) {\\n\\t\\t if (level > depth) depth = level\\n\\n\\t\\t if (node.children.length) {\\n\\t\\t\\t node.children.forEach(vertex => dfs(vertex, level + 1))\\n\\t\\t }\\n\\t }\\n }\\n\\n dfs(root, 1)\\n```\n```\\nconst queue = [{ node: root, level: 1 }]\\n\\nwhile (queue.length) {\\n\\tconst { node, level } = queue.shift()\\n\\n\\tif (level > depth) depth = level\\n\\n\\tif (node.children.length) {\\n\\t\\tnode.children.forEach(vertex => queue.push({\\n\\t\\t\\tnode: vertex,\\n\\t\\t\\tlevel: level + 1\\n\\t\\t}))\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238408,
                "title": "python-solution",
                "content": "Depth first search. Time complexity: `O(n)`, space complexity: `O(h)`, where `n` and `h` are the number of nodes and height of the tree, respectively.\\n\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0\\n            res = 0\\n            for child in root.children:\\n                res = max(dfs(child), res)\\n            return res+1\\n        return dfs(root)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0\\n            res = 0\\n            for child in root.children:\\n                res = max(dfs(child), res)\\n            return res+1\\n        return dfs(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175427,
                "title": "python-dfs-dfs-stack-bfs-solutions",
                "content": "```from collections import deque\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if not root:\\n            return 0\\n        self.level = 1\\n        # self.dfs(root, 1)\\n        self.dfs_stack(root)\\n        # self.bfs(root)\\n        return self.level\\n        \\n    def dfs(self, root, level):\\n        if level > self.level:\\n            self.level = level\\n        for child in root.children:\\n            self.dfs(child, level + 1)\\n            \\n    def dfs_stack(self, root):\\n        stack = []\\n        stack.append((root, 1))\\n        while stack:\\n            node, level = stack.pop()\\n            if level > self.level:\\n                self.level = level\\n            for child in node.children:\\n                stack.append((child, level + 1))\\n        \\n    \\n    def bfs(self, root):\\n        queue = deque()\\n        queue.append((root, 1))\\n        while queue:\\n            node, level = queue.popleft()\\n            if level > self.level:\\n                self.level = level\\n            for child in node.children:\\n                queue.append((child, level + 1))",
                "solutionTags": [],
                "code": "```from collections import deque\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if not root:\\n            return 0\\n        self.level = 1\\n        # self.dfs(root, 1)\\n        self.dfs_stack(root)\\n        # self.bfs(root)\\n        return self.level\\n        \\n    def dfs(self, root, level):\\n        if level > self.level:\\n            self.level = level\\n        for child in root.children:\\n            self.dfs(child, level + 1)\\n            \\n    def dfs_stack(self, root):\\n        stack = []\\n        stack.append((root, 1))\\n        while stack:\\n            node, level = stack.pop()\\n            if level > self.level:\\n                self.level = level\\n            for child in node.children:\\n                stack.append((child, level + 1))\\n        \\n    \\n    def bfs(self, root):\\n        queue = deque()\\n        queue.append((root, 1))\\n        while queue:\\n            node, level = queue.popleft()\\n            if level > self.level:\\n                self.level = level\\n            for child in node.children:\\n                queue.append((child, level + 1))",
                "codeTag": "Java"
            },
            {
                "id": 172097,
                "title": "c-simple-recursive-solution",
                "content": "```\\n    int maxDepth(Node* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        \\n        vector<Node*> child;\\n        if (root) {\\n            child = root->children;\\n        }\\n\\t\\t\\t\\t\\n        int maxVal = 1;\\n        for (int i = 0; i < child.size(); i++) {\\n            if (child[i]) {\\n                int depth = 1+maxDepth(child[i]);\\n                maxVal = max(depth, maxVal);\\n            }\\n        }\\n        \\n        return maxVal;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxDepth(Node* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        \\n        vector<Node*> child;\\n        if (root) {\\n            child = root->children;\\n        }\\n\\t\\t\\t\\t\\n        int maxVal = 1;\\n        for (int i = 0; i < child.size(); i++) {\\n            if (child[i]) {\\n                int depth = 1+maxDepth(child[i]);\\n                maxVal = max(depth, maxVal);\\n            }\\n        }\\n        \\n        return maxVal;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3331747,
                "title": "6-lines-awesome-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        maxdepth=0\\n        for child in root.children:\\n            maxdepth=max(self.maxDepth(child),maxdepth)\\n        return maxdepth+1\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        maxdepth=0\\n        for child in root.children:\\n            maxdepth=max(self.maxDepth(child),maxdepth)\\n        return maxdepth+1\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991266,
                "title": "c-very-easy-and-straightforward-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/bee63fd6-f560-4cc4-8a4a-85c5a8682f67_1672734427.6673162.png)\\n\\n**n==Number of Node\\nd==depth of the Tree\\nT->O(n) && S->O(d)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint depth(Node* curr){\\n\\t\\t\\t\\tif(!curr) return 0;\\n\\t\\t\\t\\tint d = 0;\\n\\t\\t\\t\\tfor(auto child : curr->children) d = max(d , depth(child) + 1);\\n\\t\\t\\t\\treturn d;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint maxDepth(Node* root) {\\n\\t\\t\\t\\tif(!root) return 0;\\n\\t\\t\\t\\treturn depth(root) + 1;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint depth(Node* curr){\\n\\t\\t\\t\\tif(!curr) return 0;\\n\\t\\t\\t\\tint d = 0;\\n\\t\\t\\t\\tfor(auto child : curr->children) d = max(d , depth(child) + 1);\\n\\t\\t\\t\\treturn d;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2606873,
                "title": "java-simple-recursive-and-iterative-solution",
                "content": "**Recursive Solution..**\\n```\\npublic int maxDepth(Node root) {\\n\\tif (root == null) return 0;\\n\\tint depth = 0;\\n\\tif (root.children != null && !root.children.isEmpty()) {\\n\\t\\tfor (Node child : root.children) {\\n\\t\\t\\tdepth = Math.max(depth, maxDepth(child));\\n\\t\\t}\\n\\t}\\n\\treturn depth + 1;\\n}\\n```\\n---\\n**Iterative Solution...**\\n\\n```\\npublic int maxDepth(Node root) {\\n\\tint depth = 0;\\n\\tif (root == null) return depth;\\n\\tDeque<Node> queue = new ArrayDeque<>();\\n\\tqueue.add(root);\\n\\twhile (!queue.isEmpty()) {\\n\\t\\tint level_size = queue.size();\\n\\t\\tfor (int i = 0; i < level_size; i++) {\\n\\t\\t\\tNode node = queue.poll();\\n\\t\\t\\tif (node != null && node.children != null && !node.children.isEmpty()) {\\n\\t\\t\\t\\tfor (Node child : node.children) {\\n\\t\\t\\t\\t\\tqueue.offer(child);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdepth += 1;\\n\\t}\\n\\treturn depth;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\npublic int maxDepth(Node root) {\\n\\tif (root == null) return 0;\\n\\tint depth = 0;\\n\\tif (root.children != null && !root.children.isEmpty()) {\\n\\t\\tfor (Node child : root.children) {\\n\\t\\t\\tdepth = Math.max(depth, maxDepth(child));\\n\\t\\t}\\n\\t}\\n\\treturn depth + 1;\\n}\\n```\n```\\npublic int maxDepth(Node root) {\\n\\tint depth = 0;\\n\\tif (root == null) return depth;\\n\\tDeque<Node> queue = new ArrayDeque<>();\\n\\tqueue.add(root);\\n\\twhile (!queue.isEmpty()) {\\n\\t\\tint level_size = queue.size();\\n\\t\\tfor (int i = 0; i < level_size; i++) {\\n\\t\\t\\tNode node = queue.poll();\\n\\t\\t\\tif (node != null && node.children != null && !node.children.isEmpty()) {\\n\\t\\t\\t\\tfor (Node child : node.children) {\\n\\t\\t\\t\\t\\tqueue.offer(child);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdepth += 1;\\n\\t}\\n\\treturn depth;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2582321,
                "title": "c-easy-fast-and-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxi=0;\\n    void solve(Node* root, int d)\\n    {\\n        if(!root)\\n        return;\\n        \\n        d++;\\n        maxi=max(maxi,d);\\n        \\n        for(auto r:root->children)\\n        solve(r,d);\\n    }\\n    \\n    int maxDepth(Node* root) {\\n        solve(root,0);\\n        return maxi;\\n    }\\n};\\n```\\nUpvote if it helps !",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi=0;\\n    void solve(Node* root, int d)\\n    {\\n        if(!root)\\n        return;\\n        \\n        d++;\\n        maxi=max(maxi,d);\\n        \\n        for(auto r:root->children)\\n        solve(r,d);\\n    }\\n    \\n    int maxDepth(Node* root) {\\n        solve(root,0);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630034,
                "title": "readable-5-line-efficient-solution-in-c-with-explanation",
                "content": "```\\n// in binary tree we return  1 + max( left_child_depth, right_child_depth)\\n// here i am doing same\\n// return 1 + max( child1_depth , child2_depth, child3_depth ........)\\n\\n\\n\\n int maxDepth(Node* root) \\n    {\\n        if(root==NULL)      return 0;\\n        \\n        int d=0;\\n        \\n        for(int i=0;i<root->children.size();i++)\\n            d=max(d,maxDepth(root->children[i]));\\n        \\n        return 1+d;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// in binary tree we return  1 + max( left_child_depth, right_child_depth)\\n// here i am doing same\\n// return 1 + max( child1_depth , child2_depth, child3_depth ........)\\n\\n\\n\\n int maxDepth(Node* root) \\n    {\\n        if(root==NULL)      return 0;\\n        \\n        int d=0;\\n        \\n        for(int i=0;i<root->children.size();i++)\\n            d=max(d,maxDepth(root->children[i]));\\n        \\n        return 1+d;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1602166,
                "title": "c-code",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        int height = 0;\\n        if(root == NULL)\\n        {\\n            return 0;\\n        }\\n        for(Node*child : root->children)\\n        {\\n            int childheight = maxDepth(child);\\n            height = max(height , childheight);\\n        }\\n        return height+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        int height = 0;\\n        if(root == NULL)\\n        {\\n            return 0;\\n        }\\n        for(Node*child : root->children)\\n        {\\n            int childheight = maxDepth(child);\\n            height = max(height , childheight);\\n        }\\n        return height+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564925,
                "title": "c-94-95-faster-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root == nullptr){\\n            return 0;\\n        }\\n        int max_val = 0;\\n        for(auto x: root->children){\\n            max_val = max(max_val, maxDepth(x));\\n        }\\n        \\n        return max_val + 1;\\n    }\\n};\\n```\\n\\n**Result-**\\n```\\nRuntime: 12 ms, faster than 94.95% of C++ online submissions for Maximum Depth of N-ary Tree.\\nMemory Usage: 10.8 MB, less than 70.40% of C++ online submissions for Maximum Depth of N-ary Tree.\\n```\\n",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root == nullptr){\\n            return 0;\\n        }\\n        int max_val = 0;\\n        for(auto x: root->children){\\n            max_val = max(max_val, maxDepth(x));\\n        }\\n        \\n        return max_val + 1;\\n    }\\n};\\n```\n```\\nRuntime: 12 ms, faster than 94.95% of C++ online submissions for Maximum Depth of N-ary Tree.\\nMemory Usage: 10.8 MB, less than 70.40% of C++ online submissions for Maximum Depth of N-ary Tree.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507948,
                "title": "c-easy-recursive-code",
                "content": "We iterate over all the child nodes of the root and check the maximum height from every node.\\nSimple recursive Code:\\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root == NULL)return 0;\\n        int depth = 0;\\n        \\n        for(auto &i:root->children){\\n            depth = max(depth, maxDepth(i));\\n        }\\n        return 1+depth;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root == NULL)return 0;\\n        int depth = 0;\\n        \\n        for(auto &i:root->children){\\n            depth = max(depth, maxDepth(i));\\n        }\\n        return 1+depth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492897,
                "title": "c-solution",
                "content": "```\\nint maxDepth(Node* root) {\\n        if(!root) return 0;\\n        int depth=0;\\n        for(auto i:root->children)\\n        {\\n            depth=max(depth,maxDepth(i));\\n        }\\n        return depth+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nint maxDepth(Node* root) {\\n        if(!root) return 0;\\n        int depth=0;\\n        for(auto i:root->children)\\n        {\\n            depth=max(depth,maxDepth(i));\\n        }\\n        return depth+1;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1343765,
                "title": "c-recursive-solution-by-kushalatolia",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root == NULL)\\n            return 0;\\n        int ans = 0;\\n        for(auto i:root->children)\\n        {\\n            ans = max(ans,maxDepth(i));\\n        }\\n        return  1 + ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root == NULL)\\n            return 0;\\n        int ans = 0;\\n        for(auto i:root->children)\\n        {\\n            ans = max(ans,maxDepth(i));\\n        }\\n        return  1 + ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927102,
                "title": "python-simple-recursion-beats-91",
                "content": "```python\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root: return 0\\n        if root.children:\\n            return max(self.maxDepth(childNode)+1 for childNode in root.children)\\n        return 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root: return 0\\n        if root.children:\\n            return max(self.maxDepth(childNode)+1 for childNode in root.children)\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875657,
                "title": "python-dfs",
                "content": "```\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if not root: return 0\\n        def f(root):\\n            if not root.children: return 1\\n            h = -1\\n            for v in root.children:\\n                h = max(h, f(v))\\n            return 1 + h\\n        return f(root)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        if not root: return 0\\n        def f(root):\\n            if not root.children: return 1\\n            h = -1\\n            for v in root.children:\\n                h = max(h, f(v))\\n            return 1 + h\\n        return f(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 859405,
                "title": "javascript-very-simple-recursive-logic-w-comments",
                "content": "```\\n/**\\n * @param {Node} root\\n * @return {number}\\n */\\nvar maxDepth = function (root) {\\n    // base case : return 0, since this node has no depth\\n    if (!root) return 0;\\n    // max depth of all children\\n    let max = 0;\\n    // iterate thru children\\n    for (let child of root.children) {\\n        // set max if max\\n        max = Math.max(max, maxDepth(child));\\n    }\\n    // return 1 + max depth of all children (1 is because this node has depth)\\n    return 1 + max;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Node} root\\n * @return {number}\\n */\\nvar maxDepth = function (root) {\\n    // base case : return 0, since this node has no depth\\n    if (!root) return 0;\\n    // max depth of all children\\n    let max = 0;\\n    // iterate thru children\\n    for (let child of root.children) {\\n        // set max if max\\n        max = Math.max(max, maxDepth(child));\\n    }\\n    // return 1 + max depth of all children (1 is because this node has depth)\\n    return 1 + max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 619747,
                "title": "c-recursively-as-well-as-bfs-solution-to-calculate-max-depth",
                "content": "Recursive:\\n\\n```csharp\\npublic int MaxDepth(Node root) \\n{\\n\\treturn findMaxDepth(root, 1);\\n}\\n\\nprivate int findMaxDepth(Node node, int currentDepth)\\n{\\n\\tint maxDepth = currentDepth;\\n\\n\\tif(node == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tforeach(var child in node.children)\\n\\t{\\n\\t\\tint depth = findMaxDepth(child, currentDepth + 1);\\n\\t\\tmaxDepth = Math.Max(maxDepth, depth);\\n\\t}\\n\\n\\treturn maxDepth;\\n}\\n```\\n\\nBFS:\\n```csharp\\npublic int MaxDepth(Node root) \\n{\\t\\n\\tif(root == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tQueue<Node> queue = new Queue<Node>();\\n\\tqueue.Enqueue(root);\\n\\tint depth = 0;\\n\\n\\twhile(queue.Count > 0)\\n\\t{\\n\\t\\tint count = queue.Count;\\n\\t\\tfor(int i = 0; i < count; i++)\\n\\t\\t{\\n\\t\\t\\tNode current = queue.Dequeue();\\n\\t\\t\\tforeach(var children in current.children)\\n\\t\\t\\t{\\n\\t\\t\\t\\tqueue.Enqueue(children);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tdepth++;\\n\\t}\\n\\treturn depth;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MaxDepth(Node root) \\n{\\n\\treturn findMaxDepth(root, 1);\\n}\\n\\nprivate int findMaxDepth(Node node, int currentDepth)\\n{\\n\\tint maxDepth = currentDepth;\\n\\n\\tif(node == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tforeach(var child in node.children)\\n\\t{\\n\\t\\tint depth = findMaxDepth(child, currentDepth + 1);\\n\\t\\tmaxDepth = Math.Max(maxDepth, depth);\\n\\t}\\n\\n\\treturn maxDepth;\\n}\\n```\n```csharp\\npublic int MaxDepth(Node root) \\n{\\t\\n\\tif(root == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tQueue<Node> queue = new Queue<Node>();\\n\\tqueue.Enqueue(root);\\n\\tint depth = 0;\\n\\n\\twhile(queue.Count > 0)\\n\\t{\\n\\t\\tint count = queue.Count;\\n\\t\\tfor(int i = 0; i < count; i++)\\n\\t\\t{\\n\\t\\t\\tNode current = queue.Dequeue();\\n\\t\\t\\tforeach(var children in current.children)\\n\\t\\t\\t{\\n\\t\\t\\t\\tqueue.Enqueue(children);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tdepth++;\\n\\t}\\n\\treturn depth;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 548337,
                "title": "python-simple-solution-36-ms-15mb",
                "content": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        self.maxdepth = 0\\n\\n        def helper(node, depth):\\n            if node:  \\n                depth += 1\\n                for child in node.children:\\n                    helper(child, depth)\\n            if depth > self.maxdepth:\\n                self.maxdepth = depth\\n\\n        helper(root, 0)\\n        return self.maxdepth\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: int\\n        \"\"\"\\n        self.maxdepth = 0\\n\\n        def helper(node, depth):\\n            if node:  \\n                depth += 1\\n                for child in node.children:\\n                    helper(child, depth)\\n            if depth > self.maxdepth:\\n                self.maxdepth = depth\\n\\n        helper(root, 0)\\n        return self.maxdepth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323811,
                "title": "java-bfs-iterative",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        int result = 0;\\n        \\n        if (root == null) {\\n            return result;\\n        }\\n        \\n        Queue<Node> q = new LinkedList<>();\\n        q.add(root);\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Node cur = q.remove();\\n                \\n                for (Node n : cur.children) {\\n                    if (n != null) {\\n                        q.add(n);\\n                    }\\n                }\\n            }\\n            result++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        int result = 0;\\n        \\n        if (root == null) {\\n            return result;\\n        }\\n        \\n        Queue<Node> q = new LinkedList<>();\\n        q.add(root);\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Node cur = q.remove();\\n                \\n                for (Node n : cur.children) {\\n                    if (n != null) {\\n                        q.add(n);\\n                    }\\n                }\\n            }\\n            result++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158833,
                "title": "python-bfs-with-explanation",
                "content": "I learned this method a while back from someone else (don\\'t remember who) and thought  it was quite clever and easy to understand for beginners.  The solution uses \\'X\\' to indicate the end of all nodes on a level in the queue.  The \\'X\\' gets added only after all the nodes from the same level are enqueued. \\n\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        \\n        max_depth = 0\\n        q = [root, \\'X\\']\\n        while len(q) >0:\\n            node = q.pop(0)\\n            if node == \\'X\\': \\n                max_depth += 1\\n                if len(q): q.append(\\'X\\')\\n                continue\\n            if node and node.children: \\n                for c in node.children: \\n                    q.append(c)\\n            \\n        return max_depth\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root: return 0\\n        if not root.children: return 1\\n        \\n        max_depth = 0\\n        q = [root, \\'X\\']\\n        while len(q) >0:\\n            node = q.pop(0)\\n            if node == \\'X\\': \\n                max_depth += 1\\n                if len(q): q.append(\\'X\\')\\n                continue\\n            if node and node.children: \\n                for c in node.children: \\n                    q.append(c)\\n            \\n        return max_depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150397,
                "title": "simple-solution-3-lines-python-code-beats-99",
                "content": "```python\\nif root is None: return 0\\nif root.children is None or root.children == []: return 1\\nreturn max(map(self.maxDepth, root.children)) + 1\\n```",
                "solutionTags": [],
                "code": "```python\\nif root is None: return 0\\nif root.children is None or root.children == []: return 1\\nreturn max(map(self.maxDepth, root.children)) + 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2842261,
                "title": "easiest-solution-c-plus-plus-easy-to-understand-recursion-only-4-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void solve(Node* root,int a,int &ans){\\n        if(root==NULL) return;\\n        a++;\\n        ans=max(ans,a);\\n        for(Node* i:root->children) solve(i,a,ans);\\n    }\\n    int maxDepth(Node* root) {\\n        int ans = 0;\\n        solve(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void solve(Node* root,int a,int &ans){\\n        if(root==NULL) return;\\n        a++;\\n        ans=max(ans,a);\\n        for(Node* i:root->children) solve(i,a,ans);\\n    }\\n    int maxDepth(Node* root) {\\n        int ans = 0;\\n        solve(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819538,
                "title": "java",
                "content": "If you like it pls upvote\\n```\\n\\n public int maxDepth(Node root) {\\n if(root == null) return 0;\\n Stack<Node> stack = new Stack<>();\\n Stack<Integer> num = new Stack<>();\\n stack.push(root);\\n num.push(1);\\n int depth = 1;\\n\\n while (!stack.empty()) {\\n  Node node = stack.pop();\\n  int count = num.pop();\\n\\n  if (node.children != null) {\\n   for (Node nod : node.children) {\\n     stack.push(nod);\\n     depth = Math.max(count + 1, depth);\\n     num.push(count + 1);\\n   }\\n  }\\n }\\n\\n return depth;\\n }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n\\n public int maxDepth(Node root) {\\n if(root == null) return 0;\\n Stack<Node> stack = new Stack<>();\\n Stack<Integer> num = new Stack<>();\\n stack.push(root);\\n num.push(1);\\n int depth = 1;\\n\\n while (!stack.empty()) {\\n  Node node = stack.pop();\\n  int count = num.pop();\\n\\n  if (node.children != null) {\\n   for (Node nod : node.children) {\\n     stack.push(nod);\\n     depth = Math.max(count + 1, depth);\\n     num.push(count + 1);\\n   }\\n  }\\n }\\n\\n return depth;\\n }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555808,
                "title": "java-dfs-fast",
                "content": "```\\n\\tpublic int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int max = 0;\\n        for(Node node : root.children) {\\n            max = Math.max(max, maxDepth(node));\\n        }\\n        return 1 + max;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n\\tpublic int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int max = 0;\\n        for(Node node : root.children) {\\n            max = Math.max(max, maxDepth(node));\\n        }\\n        return 1 + max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2274121,
                "title": "java-fast-recursive-solution-0ms",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root==null)\\n            return 0;\\n        if(root.children.size()==0)\\n            return 1;\\n        int height = 0;\\n        for(Node child : root.children) {\\n            int recAns = maxDepth(child);\\n            height = Math.max(height,recAns);\\n        }\\n        return height+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root==null)\\n            return 0;\\n        if(root.children.size()==0)\\n            return 1;\\n        int height = 0;\\n        for(Node child : root.children) {\\n            int recAns = maxDepth(child);\\n            height = Math.max(height,recAns);\\n        }\\n        return height+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209188,
                "title": "c-dfs-beats-84",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root==NULL)\\n            return 0;\\n        \\n        if(root->children.size()==0)\\n            return 1;\\n        \\n        vector<int> v(root->children.size(),1);\\n        int i=0;\\n        for(auto x:root->children)\\n        {\\n            v[i++]+=maxDepth(x);\\n        }\\n        return *max_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root==NULL)\\n            return 0;\\n        \\n        if(root->children.size()==0)\\n            return 1;\\n        \\n        vector<int> v(root->children.size(),1);\\n        int i=0;\\n        for(auto x:root->children)\\n        {\\n            v[i++]+=maxDepth(x);\\n        }\\n        return *max_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163226,
                "title": "c-recursive-bfs-pre-order",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(!root) return 0;\\n        int mx = 0;\\n        for(Node* n : root->children) mx = max(mx, maxDepth(n));\\n        return mx + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(!root) return 0;\\n        int mx = 0;\\n        for(Node* n : root->children) mx = max(mx, maxDepth(n));\\n        return mx + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983953,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/1c6b3bdd-4384-4ab5-9306-32ecc67d521c_1650981563.7521918.png)\\n\\n```\\nint maxDepth(struct Node* root) {\\n    if (!root) return 0;\\n    if (root->numChildren == 0) return 1;\\n    int max = 0;\\n    for (int i = 0; i < root->numChildren; i++) {\\n        int tmp = maxDepth(root->children[i]) + 1;\\n        max = tmp > max ? tmp : max;\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxDepth(struct Node* root) {\\n    if (!root) return 0;\\n    if (root->numChildren == 0) return 1;\\n    int max = 0;\\n    for (int i = 0; i < root->numChildren; i++) {\\n        int tmp = maxDepth(root->children[i]) + 1;\\n        max = tmp > max ? tmp : max;\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1872600,
                "title": "maximum-depth-of-n-ary-tree-solution-java",
                "content": "class Solution {\\n  public int maxDepth(Node root) {\\n    if (root == null)\\n      return 0;\\n\\n    int ans = 0;\\n\\n    for (Node child : root.children)\\n      ans = Math.max(ans, maxDepth(child));\\n\\n    return 1 + ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n  public int maxDepth(Node root) {\\n    if (root == null)\\n      return 0;\\n\\n    int ans = 0;\\n\\n    for (Node child : root.children)\\n      ans = Math.max(ans, maxDepth(child));\\n\\n    return 1 + ans;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1779469,
                "title": "n-ary-tree-easy-aprroach-c-simple-explanantion",
                "content": "```\\n/* N ary Tree can have any number of children where as binary can have atmost 2 child.\\n   Find Height of each children of root \\n   find maximum height among its children\\n   Return maximum + 1\\n              root\\n            / | \\\\ \\\\\\n           5  8  9 10\\n          |   \\\\  \\\\  \\\\\\n          6    7  5  11\\n              /   \\\\  \\n             5     8\\n             \\\\\\n             11\\n    Maximum Height will be 5\\n*/\\n```\\n```\\nUpVote If You Like It \\n```\\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* ptr) {\\n        if (!ptr)            //Base condition\\n            return 0;\\n \\n    // Check for all children and find\\n    // the maximum depth\\n    int maxdepth = 0;\\n        vector<Node*>::iterator it;\\n    for (it = ptr->children.begin();it != ptr->children.end(); it++)\\n        maxdepth = max(maxdepth, maxDepth(*it));\\n \\n    return maxdepth + 1 ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\n/* N ary Tree can have any number of children where as binary can have atmost 2 child.\\n   Find Height of each children of root \\n   find maximum height among its children\\n   Return maximum + 1\\n              root\\n            / | \\\\ \\\\\\n           5  8  9 10\\n          |   \\\\  \\\\  \\\\\\n          6    7  5  11\\n              /   \\\\  \\n             5     8\\n             \\\\\\n             11\\n    Maximum Height will be 5\\n*/\\n```\n```\\nUpVote If You Like It \\n```\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* ptr) {\\n        if (!ptr)            //Base condition\\n            return 0;\\n \\n    // Check for all children and find\\n    // the maximum depth\\n    int maxdepth = 0;\\n        vector<Node*>::iterator it;\\n    for (it = ptr->children.begin();it != ptr->children.end(); it++)\\n        maxdepth = max(maxdepth, maxDepth(*it));\\n \\n    return maxdepth + 1 ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723410,
                "title": "beginner-friendly-javascript-solution",
                "content": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node|null} root\\n * @return {number}\\n */\\nvar maxDepth = function(root) {\\n    if(root == null)    return 0;\\n    let max = 0;\\n    for(let child of root.children){\\n        max = Math.max(max, maxDepth(child));\\n    }\\n    return max+1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node|null} root\\n * @return {number}\\n */\\nvar maxDepth = function(root) {\\n    if(root == null)    return 0;\\n    let max = 0;\\n    for(let child of root.children){\\n        max = Math.max(max, maxDepth(child));\\n    }\\n    return max+1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1506608,
                "title": "c-easy-logic-recursive-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int max_height = 0;\\n    void solve(Node* root, int height){\\n        int size = root->children.size();\\n        if(size){\\n            height++;\\n            for(int i=0; i<size; i++){\\n                solve(root->children[i], height);\\n            }\\n        }\\n        else{\\n            max_height = max(height, max_height);\\n        }\\n    }\\n    \\n    int maxDepth(Node* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        int height = 1;\\n        solve(root, height);\\n        return max_height;\\n    }\\n};\\n```\\n**If you learn from this code then please upvote this.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int max_height = 0;\\n    void solve(Node* root, int height){\\n        int size = root->children.size();\\n        if(size){\\n            height++;\\n            for(int i=0; i<size; i++){\\n                solve(root->children[i], height);\\n            }\\n        }\\n        else{\\n            max_height = max(height, max_height);\\n        }\\n    }\\n    \\n    int maxDepth(Node* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        int height = 1;\\n        solve(root, height);\\n        return max_height;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470196,
                "title": "c-sol-with-null-marker",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(!root) return 0;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(nullptr);\\n        int count=1;\\n        while(root){\\n            Node* front = q.front();\\n            q.pop();\\n            if(front==nullptr){\\n                q.push(nullptr);\\n                if(q.size()==1) break;\\n                count++;\\n            }else{\\n                for(int i=0;i<front->children.size();i++){\\n                    q.push(front->children[i]);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(!root) return 0;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(nullptr);\\n        int count=1;\\n        while(root){\\n            Node* front = q.front();\\n            q.pop();\\n            if(front==nullptr){\\n                q.push(nullptr);\\n                if(q.size()==1) break;\\n                count++;\\n            }else{\\n                for(int i=0;i<front->children.size();i++){\\n                    q.push(front->children[i]);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376795,
                "title": "python3-bfs-dfs",
                "content": "```\\n#     DFS\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:return 0\\n        depth=0\\n        for child in root.children:\\n            depth=max(depth,self.maxDepth(child))\\n        return depth+1\\n    \\n    \\n#     BFS\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:return 0\\n        depth=0\\n        q=deque()\\n        q.append((root,1))\\n        while q:\\n            curr_node,curr_level=q.popleft()\\n            depth=curr_level\\n            for child in curr_node.children:\\n                q.append((child,depth+1))\\n        return depth",
                "solutionTags": [],
                "code": "```\\n#     DFS\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:return 0\\n        depth=0\\n        for child in root.children:\\n            depth=max(depth,self.maxDepth(child))\\n        return depth+1\\n    \\n    \\n#     BFS\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:return 0\\n        depth=0\\n        q=deque()\\n        q.append((root,1))\\n        while q:\\n            curr_node,curr_level=q.popleft()\\n            depth=curr_level\\n            for child in curr_node.children:\\n                q.append((child,depth+1))\\n        return depth",
                "codeTag": "Python3"
            },
            {
                "id": 1323720,
                "title": "straightforward-bfs-in-python-beating-98-submissions",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        depth = 0\\n        if not root:\\n            return depth\\n        \\n        level = [root]\\n        \\n        while level:\\n            depth += 1\\n            level = [c for n in level for c in n.children if c]\\n            \\n        return depth\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        depth = 0\\n        if not root:\\n            return depth\\n        \\n        level = [root]\\n        \\n        while level:\\n            depth += 1\\n            level = [c for n in level for c in n.children if c]\\n            \\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220361,
                "title": "c-easy-to-understand-recursive-straight-forward-solution-99-43-faster-code",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)**\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        int depth;\\n    if(root==NULL)\\n    return 0;\\n    int maximumDepth=1;\\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            maximumDepth=max(maximumDepth,maxDepth(root->children[i])+1);\\n        }\\n    return maximumDepth;\\n    }\\n    \\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        int depth;\\n    if(root==NULL)\\n    return 0;\\n    int maximumDepth=1;\\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            maximumDepth=max(maximumDepth,maxDepth(root->children[i])+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1196070,
                "title": "easy-simple-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxH=0;\\n    int calculate(Node* root,int count)\\n    {\\n        if(!root)\\n            return maxH;\\n        count++;\\n        maxH=max(maxH,count);\\n        for(auto i:root->children)\\n        {\\n            calculate(i,count);\\n        }\\n        return maxH;\\n    }\\n    int maxDepth(Node* root) {\\n        if(!root)\\n            return 0;\\n        return calculate(root,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxH=0;\\n    int calculate(Node* root,int count)\\n    {\\n        if(!root)\\n            return maxH;\\n        count++;\\n        maxH=max(maxH,count);\\n        for(auto i:root->children)\\n        {\\n            calculate(i,count);\\n        }\\n        return maxH;\\n    }\\n    int maxDepth(Node* root) {\\n        if(!root)\\n            return 0;\\n        return calculate(root,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179877,
                "title": "python-3-liner",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root: return 0\\n        if not len(root.children): return 1\\n        return 1 + max([self.maxDepth(child) for child in root.children])\\n```\\n\\nPretty straight forward recursive-dfs solution.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root: return 0\\n        if not len(root.children): return 1\\n        return 1 + max([self.maxDepth(child) for child in root.children])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025091,
                "title": "python-recursion-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.level = 0\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        def depth(node, level):\\n            if level > self.level:\\n                self.level = level\\n            if node:\\n                for n in node.children:\\n                    depth(n, level+1)\\n        if root:\\n            depth(root, 1)\\n        return self.level\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.level = 0\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        def depth(node, level):\\n            if level > self.level:\\n                self.level = level\\n            if node:\\n                for n in node.children:\\n                    depth(n, level+1)\\n        if root:\\n            depth(root, 1)\\n        return self.level\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990854,
                "title": "java",
                "content": "``` \\npublic int maxDepth(Node root) {\\n        \\n        if(root==null) return 0;\\n        int depth=0;\\n        for(Node node:root.children){\\n           depth=Math.max(depth,maxDepth(node));\\n        }\\n        // Collections.sort(vals);\\n        return depth+1;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "``` \\npublic int maxDepth(Node root) {\\n        \\n        if(root==null) return 0;\\n        int depth=0;\\n        for(Node node:root.children){\\n           depth=Math.max(depth,maxDepth(node));\\n        }\\n        // Collections.sort(vals);\\n        return depth+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 881868,
                "title": "c-explanation-with-clear-idea-3-ideas",
                "content": "# Idea 1:\\n```\\n/*\\n * 1. Idea:\\n * max depth of the tree = max(depth of 1st sub-tree + 1, depth of 2nd sub-tree + 1, ..., depth of Nth sub-tree + 1)\\n *                       = max(depth of sub-trees) + 1\\n *\\n * 2. Algorithm\\n * TC = O(N) with N is number of nodes of the tree.\\n * SC = O(H) with H is height (depth) of the tree.\\n *    In the bad case, SC = O(N)\\n *    In the best case, SC = O(logN)\\n */\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == NULL)\\n            return 0;\\n        \\n        int depthSubtree = 0;\\n        for (int i = 0, N = root->children.size(); i < N; i++)\\n            depthSubtree = max(depthSubtree, maxDepth(root->children[i]));\\n\\n        return ++depthSubtree;\\n    }\\n};\\n```\\n\\n# Idea 2\\n\\n```\\n/*\\n * 1. Idea:\\n * Tracking the current depth we are in.\\n * - when visting a node, the current depth should be increased by 1.\\n * - when leaving the node, the current depth should be descreased by 1.\\n * - if the visiting node doesn\\'t have children nodes, update the current depth to maximum depth.\\n *\\n * 2. Algorithm\\n * TC = O(N) with N is number of nodes of the tree.\\n * SC = O(H) with H is height (depth) of the tree.\\n *    In the bad case, SC = O(N)\\n *    In the best case, SC = O(logN)\\n */\\nclass Solution {\\nprivate:\\n    void traversal(Node* root, int& currDepth, int& answer) {\\n        if (root == NULL)\\n            return;\\n\\n        currDepth++;\\n        int numChildren = root->children.size();\\n        for (int i = 0; i < numChildren; i++)\\n            traversal(root->children[i], currDepth, answer);\\n        if (numChildren == 0)\\n            answer = max(answer, currDepth);\\n        currDepth--;\\n    }\\n\\npublic:\\n    int maxDepth(Node* root) {\\n        int currDepth = 0, answer = 0;\\n        traversal(root, currDepth, answer);\\n        return answer;\\n    }\\n};\\n```\\n\\n# Idea 3\\n```\\n/*\\n * 1. Idea:\\n * Not good but we can reuse node\\'s value to mark depth of the node.\\n * First, create a queue to store the nodes will be visited (initialize the queue with the root node)\\n * After that, check front node until queue empty. For each front node, if there is no children, update the node\\'s value to max depth.\\n * If the front node has some children, push its children to the queue with children\\'s value = parent\\'s value + 1\\n * Before visit next node, remember to dequeue the current front node.\\n *\\n * 2. Algorithm\\n * TC = O(N) with N is number of nodes of the tree.\\n * SC = O(N) with N is number of nodes of the tree.\\n */\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == NULL)\\n            return 0;\\n        \\n        int maximumDepth = 0;\\n        queue<Node*> q;\\n        root->val = 1;\\n        q.push(root);\\n        while (!q.empty()) {\\n            Node* node = q.front();\\n            int numChildren = node->children.size();\\n            for (int i = 0; i < numChildren; i++) {\\n                node->children[i]->val = node->val + 1;\\n                q.push(node->children[i]);\\n            }\\n            if (numChildren == 0)\\n                maximumDepth = max(maximumDepth, node->val);\\n            q.pop();\\n        }\\n        return maximumDepth;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * 1. Idea:\\n * max depth of the tree = max(depth of 1st sub-tree + 1, depth of 2nd sub-tree + 1, ..., depth of Nth sub-tree + 1)\\n *                       = max(depth of sub-trees) + 1\\n *\\n * 2. Algorithm\\n * TC = O(N) with N is number of nodes of the tree.\\n * SC = O(H) with H is height (depth) of the tree.\\n *    In the bad case, SC = O(N)\\n *    In the best case, SC = O(logN)\\n */\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == NULL)\\n            return 0;\\n        \\n        int depthSubtree = 0;\\n        for (int i = 0, N = root->children.size(); i < N; i++)\\n            depthSubtree = max(depthSubtree, maxDepth(root->children[i]));\\n\\n        return ++depthSubtree;\\n    }\\n};\\n```\n```\\n/*\\n * 1. Idea:\\n * Tracking the current depth we are in.\\n * - when visting a node, the current depth should be increased by 1.\\n * - when leaving the node, the current depth should be descreased by 1.\\n * - if the visiting node doesn\\'t have children nodes, update the current depth to maximum depth.\\n *\\n * 2. Algorithm\\n * TC = O(N) with N is number of nodes of the tree.\\n * SC = O(H) with H is height (depth) of the tree.\\n *    In the bad case, SC = O(N)\\n *    In the best case, SC = O(logN)\\n */\\nclass Solution {\\nprivate:\\n    void traversal(Node* root, int& currDepth, int& answer) {\\n        if (root == NULL)\\n            return;\\n\\n        currDepth++;\\n        int numChildren = root->children.size();\\n        for (int i = 0; i < numChildren; i++)\\n            traversal(root->children[i], currDepth, answer);\\n        if (numChildren == 0)\\n            answer = max(answer, currDepth);\\n        currDepth--;\\n    }\\n\\npublic:\\n    int maxDepth(Node* root) {\\n        int currDepth = 0, answer = 0;\\n        traversal(root, currDepth, answer);\\n        return answer;\\n    }\\n};\\n```\n```\\n/*\\n * 1. Idea:\\n * Not good but we can reuse node\\'s value to mark depth of the node.\\n * First, create a queue to store the nodes will be visited (initialize the queue with the root node)\\n * After that, check front node until queue empty. For each front node, if there is no children, update the node\\'s value to max depth.\\n * If the front node has some children, push its children to the queue with children\\'s value = parent\\'s value + 1\\n * Before visit next node, remember to dequeue the current front node.\\n *\\n * 2. Algorithm\\n * TC = O(N) with N is number of nodes of the tree.\\n * SC = O(N) with N is number of nodes of the tree.\\n */\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (root == NULL)\\n            return 0;\\n        \\n        int maximumDepth = 0;\\n        queue<Node*> q;\\n        root->val = 1;\\n        q.push(root);\\n        while (!q.empty()) {\\n            Node* node = q.front();\\n            int numChildren = node->children.size();\\n            for (int i = 0; i < numChildren; i++) {\\n                node->children[i]->val = node->val + 1;\\n                q.push(node->children[i]);\\n            }\\n            if (numChildren == 0)\\n                maximumDepth = max(maximumDepth, node->val);\\n            q.pop();\\n        }\\n        return maximumDepth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799360,
                "title": "plain-python-recursion",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root is None:\\n            return 0\\n        elif not root.children:\\n            return 1\\n        else:\\n            return 1 + max(map(self.maxDepth, root.children))\\n",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root is None:\\n            return 0\\n        elif not root.children:\\n            return 1\\n        else:\\n            return 1 + max(map(self.maxDepth, root.children))\\n",
                "codeTag": "Java"
            },
            {
                "id": 790351,
                "title": "recursive-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int depth = 0;\\n    int maxDepth(Node* root) {\\n        helper(root, 1);\\n        return depth;\\n    }\\n    \\n    void helper(Node* node, int d) {\\n        if (!node) return ;\\n        if (node->children.empty()) {\\n            if (depth < d) depth = d;\\n        } else {\\n            for (size_t i = 0; i < node->children.size(); i++) {\\n                helper(node->children[i], d + 1);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int depth = 0;\\n    int maxDepth(Node* root) {\\n        helper(root, 1);\\n        return depth;\\n    }\\n    \\n    void helper(Node* node, int d) {\\n        if (!node) return ;\\n        if (node->children.empty()) {\\n            if (depth < d) depth = d;\\n        } else {\\n            for (size_t i = 0; i < node->children.size(); i++) {\\n                helper(node->children[i], d + 1);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765324,
                "title": "simplest-fastest-0ms-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        \\n        if(root == null){\\n            return 0;\\n        }\\n\\n        int max = 0;\\n        for(int i=0; i<root.children.size(); i++){\\n            int depth = maxDepth(root.children.get(i));\\n            max = Math.max(max, depth);\\n        }\\n    \\n        return max + 1;    \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int maxDepth(Node root) {\\n        \\n        if(root == null){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 764373,
                "title": "go-golang-bfs-and-dfs-solutions",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Maximum Depth of N-ary Tree.\\nMemory Usage: 3.5 MB, less than 16.67% of Go online submissions for Maximum Depth of N-ary Tree.\\n\\n```go\\nfunc maxDepth(root *Node) int {\\n    if root == nil { return 0 }\\n    queue, ans := []*Node{ root }, 0\\n    for len(queue) > 0 {\\n        n := len(queue)\\n        for i := 0; i < n; i++ {\\n            pop := queue[0]\\n            queue = queue[1:]\\n            for _, v := range pop.Children { queue = append(queue, v) }\\n        }\\n        ans++\\n    }\\n    return ans\\n}\\n```\\n\\n>Runtime: 0 ms, faster than 100.00% of Go online submissions for Maximum Depth of N-ary Tree.\\nMemory Usage: 3.4 MB, less than 16.67% of Go online submissions for Maximum Depth of N-ary Tree.\\n\\n```go\\nfunc maxDepth(root *Node) int {\\n    if root == nil { return 0 }\\n    ans := 0\\n    for _, child := range root.Children { ans = max(ans, maxDepth(child)) }\\n    return ans + 1\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc maxDepth(root *Node) int {\\n    if root == nil { return 0 }\\n    queue, ans := []*Node{ root }, 0\\n    for len(queue) > 0 {\\n        n := len(queue)\\n        for i := 0; i < n; i++ {\\n            pop := queue[0]\\n            queue = queue[1:]\\n            for _, v := range pop.Children { queue = append(queue, v) }\\n        }\\n        ans++\\n    }\\n    return ans\\n}\\n```\n```go\\nfunc maxDepth(root *Node) int {\\n    if root == nil { return 0 }\\n    ans := 0\\n    for _, child := range root.Children { ans = max(ans, maxDepth(child)) }\\n    return ans + 1\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 761481,
                "title": "java-dfs-4-lines",
                "content": "```\\n    public int maxDepth(Node root) {\\n        if (root == null || root.children == null) return root == null ? 0 : 1;\\n        int res = 1;\\n        for (Node node : root.children) res = Math.max(res, maxDepth(node) + 1);\\n        return res;\\n    }    \\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int maxDepth(Node root) {\\n        if (root == null || root.children == null) return root == null ? 0 : 1;\\n        int res = 1;\\n        for (Node node : root.children) res = Math.max(res, maxDepth(node) + 1);\\n        return res;\\n    }    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 757546,
                "title": "swift-easy-iterative-and-recursive-solution",
                "content": "```\\nclass Solution {\\n//Iterative\\n    func maxDepth(_ root: Node?) -> Int {\\n        guard let root = root else { return 0 }\\n        var stack: [(node: Node, level: Int)] = [(root, 1)]\\n        var maxLevel = 1\\n        \\n        while !stack.isEmpty {\\n            let parent = stack.popLast()\\n            maxLevel = max(maxLevel, parent!.level)\\n            \\n            parent!.node.children.forEach { \\n                stack.append(($0, parent!.level+1))\\n            }\\n            \\n        }\\n        return maxLevel\\n    }\\n//Recursive    \\n    func maxDepth(_ root: Node?) -> Int {\\n        guard let root = root else { return 0 }\\n        var tempMax = 0\\n        root.children.forEach {\\n            tempMax = max(tempMax, maxDepth($0))\\n        }\\n        return tempMax + 1\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n//Iterative\\n    func maxDepth(_ root: Node?) -> Int {\\n        guard let root = root else { return 0 }\\n        var stack: [(node: Node, level: Int)] = [(root, 1)]\\n        var maxLevel = 1\\n        \\n        while !stack.isEmpty {\\n            let parent = stack.popLast()\\n            maxLevel = max(maxLevel, parent!.level)\\n            \\n            parent!.node.children.forEach { \\n                stack.append(($0, parent!.level+1))\\n            }\\n            \\n        }\\n        return maxLevel\\n    }\\n//Recursive    \\n    func maxDepth(_ root: Node?) -> Int {\\n        guard let root = root else { return 0 }\\n        var tempMax = 0\\n        root.children.forEach {\\n            tempMax = max(tempMax, maxDepth($0))\\n        }\\n        return tempMax + 1\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752291,
                "title": "python-bfs-with-expression-assignment",
                "content": "BFS:\\n\\n```\\ndef maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        q, MAX = deque(), 1\\n        q.append((root, 1))\\n        while q:\\n            n, l = q.popleft()\\n            q += [(chi, l + 1) for chi in n.children if (MAX := l + 1)]\\n        return MAX\\n```\\n\\nDFS:\\n```\\ndef maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        MAX = 1\\n        for chi in root.children:\\n            MAX = max(self.maxDepth(chi) + 1, MAX)\\n        return MAX\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        q, MAX = deque(), 1\\n        q.append((root, 1))\\n        while q:\\n            n, l = q.popleft()\\n            q += [(chi, l + 1) for chi in n.children if (MAX := l + 1)]\\n        return MAX\\n```\n```\\ndef maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0\\n        MAX = 1\\n        for chi in root.children:\\n            MAX = max(self.maxDepth(chi) + 1, MAX)\\n        return MAX\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 724575,
                "title": "simple-faster-c-recursive-solution-dfs",
                "content": "class Solution {\\npublic:\\n\\n    int maxDepth(Node* root) {\\n        if (root) {\\n            vector<Node*> v = root->children;\\n            int maxiDepth = 0;\\n            for (int i = 0; i < v.size(); i++) {\\n                maxiDepth = max(maxDepth(v[i]), maxiDepth);\\n            }\\n            return 1 + maxiDepth;\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxDepth(Node* root) {\\n        if (root) {\\n            vector<Node*> v = root->children;\\n            int maxiDepth = 0;\\n            for (int i = 0; i < v.size(); i++) {\\n                maxiDepth = max(maxDepth(v[i]), maxiDepth);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 711921,
                "title": "python-solution",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root==None:\\n            return 0\\n        queue=[]\\n        queue.append(root)\\n        depth=0\\n        while(len(queue)!=0):\\n            l=len(queue)\\n            for i in range(l):\\n                cur=queue.pop(0)\\n                for nodes in cur.children:\\n                    queue.append(nodes)\\n            depth+=1\\n        return depth\\n                \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root==None:\\n            return 0\\n        queue=[]\\n        queue.append(root)\\n        depth=0\\n        while(len(queue)!=0):\\n            l=len(queue)\\n            for i in range(l):\\n                cur=queue.pop(0)\\n                for nodes in cur.children:\\n                    queue.append(nodes)\\n            depth+=1\\n        return depth\\n                \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 641871,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0;\\n        \\n        max_depth = 0\\n        for child in root.children:\\n            max_depth = max(max_depth, self.maxDepth(child))\\n        return 1 + max_depth\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:\\n            return 0;\\n        \\n        max_depth = 0\\n        for child in root.children:\\n            max_depth = max(max_depth, self.maxDepth(child))\\n        return 1 + max_depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581015,
                "title": "ruby-simple-solution-but-faster-and-less-memory",
                "content": "using `map` and `flatten`\\n\\n```ruby\\ndef maxDepth(root, depth = 1)\\n  return 0 unless root\\n  children = root.children\\n  while !children.empty?\\n    children = children.map(&:children).flatten\\n    depth += 1\\n  end\\n  depth\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef maxDepth(root, depth = 1)\\n  return 0 unless root\\n  children = root.children\\n  while !children.empty?\\n    children = children.map(&:children).flatten\\n    depth += 1\\n  end\\n  depth\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 443262,
                "title": "c-beats-100-on-speed-with-explanation",
                "content": "```\\nclass Solution {\\n\\n// Recrusive solution. If we can go deeper into the node\\'s children vector\\n// (i.e. another node below it exists) then we go in. We track the maximum depth\\n// throughout the entire process, where level is the depth at a given node.\\n\\n    void setDepth(Node* root, int& maxDepth, int level) {\\n        if (!root) return;\\n        maxDepth = max(maxDepth, level);\\n        for (int i{}; i < root->children.size(); ++i) {\\n            if (root->children[i]) {\\n                setDepth(root->children[i], maxDepth, level + 1);\\n            }\\n        }\\n        return;\\n    }\\n\\t\\npublic:\\n    int maxDepth(Node* root) {\\n        int maxDepth{0};\\n\\t\\t// Level starts at 1 (1 node deep)\\n        setDepth(root, maxDepth, 1);\\n        return maxDepth;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\n// Recrusive solution. If we can go deeper into the node\\'s children vector\\n// (i.e. another node below it exists) then we go in. We track the maximum depth\\n// throughout the entire process, where level is the depth at a given node.\\n\\n    void setDepth(Node* root, int& maxDepth, int level) {\\n        if (!root) return;\\n        maxDepth = max(maxDepth, level);\\n        for (int i{}",
                "codeTag": "Java"
            },
            {
                "id": 438353,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n \\n        if root is None:\\n            return 0\\n        \\n        m = 0\\n\\n        for i in root.children:\\n            k = self.maxDepth(i)\\n            if k > m:\\n                m = k\\n        return 1 + m\\n      \\n```\\n\\n![image](https://assets.leetcode.com/users/ghisloti_duarte_de_souza/image_1574810463.png)\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n \\n        if root is None:\\n            return 0\\n        \\n        m = 0\\n\\n        for i in root.children:\\n            k = self.maxDepth(i)\\n            if k > m:\\n                m = k\\n        return 1 + m\\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 422575,
                "title": "java-old-school-and-simple-syntax-beats-100",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        \\n        if (root == null) return 0;\\n        if (root.children == null) return 1;\\n        \\n        int max = 0;\\n        for(Node n : root.children){\\n            int depth = maxDepth(n);\\n            if(depth > max) max = depth;\\n        }\\n        \\n        return max + 1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        \\n        if (root == null) return 0;\\n        if (root.children == null) return 1;\\n        \\n        int max = 0;\\n        for(Node n : root.children){\\n            int depth = maxDepth(n);\\n            if(depth > max) max = depth;\\n        }\\n        \\n        return max + 1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408706,
                "title": "simplest-solution-c",
                "content": "```\\nint maxDepth(Node* root) {\\n        if(!root) return 0;\\n        int depth = 0;\\n        for(auto it : root->children)\\n            depth = max(depth, maxDepth(it));\\n        return depth+1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxDepth(Node* root) {\\n        if(!root) return 0;\\n        int depth = 0;\\n        for(auto it : root->children)\\n            depth = max(depth, maxDepth(it));\\n        return depth+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405017,
                "title": "java-easy-1ms-recursive-solution",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        return maxDepth(root, 0);\\n    }\\n    public int maxDepth(Node root, int currentDepth){\\n        if (root==null)return currentDepth;\\n        currentDepth++;        \\n        int max = currentDepth;\\n        for (Node child: root.children) \\n            max = Math.max(max, maxDepth(child, currentDepth));\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        return maxDepth(root, 0);\\n    }\\n    public int maxDepth(Node root, int currentDepth){\\n        if (root==null)return currentDepth;\\n        currentDepth++;        \\n        int max = currentDepth;\\n        for (Node child: root.children) \\n            max = Math.max(max, maxDepth(child, currentDepth));\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 390130,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int max = 0;\\n        \\n        for(Node temp : root.children){\\n            max = Math.max(maxDepth(temp),max);\\n        }\\n        \\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int max = 0;\\n        \\n        for(Node temp : root.children){\\n            max = Math.max(maxDepth(temp),max);\\n        }\\n        \\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 368223,
                "title": "bfs-and-dfs-very-easy-to-understand",
                "content": "**BFS**\\n```java\\npublic int maxDepth(Node root) {\\n        if(root==null) return 0;\\n        Queue<Node> queue = new LinkedList<Node>();\\n        int level=0;\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            int size=queue.size();\\n            level++;\\n            for(int i=0;i<size;i++){\\n                Node node=queue.poll();\\n                for(Node nextNode : node.children){\\n                    queue.offer(nextNode);\\n                }\\n            }\\n        }\\n        return level;\\n    }\\n    \\n    public int maxDepth(Node root) {\\n        return dfs(root);\\n    }\\n```\\n\\n**DFS**\\n**Similar to getting a binary height**\\n```java\\n private int dfs(Node root){\\n        int max=0;\\n        if(root==null) return 0;\\n        else if(root!=null && root.children.size()==0) return 1;\\n        else if(root!=null && root.children.size() > 0){\\n            for(Node node : root.children){\\n                int num=dfs(node);\\n                if(num>max) max=num;\\n            }\\n        }\\n        return max+1;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```java\\npublic int maxDepth(Node root) {\\n        if(root==null) return 0;\\n        Queue<Node> queue = new LinkedList<Node>();\\n        int level=0;\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            int size=queue.size();\\n            level++;\\n            for(int i=0;i<size;i++){\\n                Node node=queue.poll();\\n                for(Node nextNode : node.children){\\n                    queue.offer(nextNode);\\n                }\\n            }\\n        }\\n        return level;\\n    }\\n    \\n    public int maxDepth(Node root) {\\n        return dfs(root);\\n    }\\n```\n```java\\n private int dfs(Node root){\\n        int max=0;\\n        if(root==null) return 0;\\n        else if(root!=null && root.children.size()==0) return 1;\\n        else if(root!=null && root.children.size() > 0){\\n            for(Node node : root.children){\\n                int num=dfs(node);\\n                if(num>max) max=num;\\n            }\\n        }\\n        return max+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 357152,
                "title": "c-recursive",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int maxDepth( Node* root ) {\\n        if( !root ) return 0;\\n        int maxHeight = 0;\\n        for( auto node : root->children ) {\\n            maxHeight = max( maxHeight, maxDepth( node ) );\\n        }\\n        return 1 + maxHeight;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int maxDepth( Node* root ) {\\n        if( !root ) return 0;\\n        int maxHeight = 0;\\n        for( auto node : root->children ) {\\n            maxHeight = max( maxHeight, maxDepth( node ) );\\n        }\\n        return 1 + maxHeight;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352991,
                "title": "simple-recursive-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root==NULL){return 0;}\\n        int m = 0;\\n        for(int i=0;i<root->children.size();i++){\\n            m = max(m,maxDepth(root->children[i]));\\n        }\\n        return 1+m;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root==NULL){return 0;}\\n        int m = 0;\\n        for(int i=0;i<root->children.size();i++){\\n            m = max(m,maxDepth(root->children[i]));\\n        }\\n        return 1+m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313168,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:return 0\\n        self.max_level = 0\\n        def dfs(node, level):\\n            self.max_level = max(self.max_level, level)\\n            if not node.children:return\\n            for child in node.children:\\n                dfs(child, level+1)\\n        dfs(root, 1)\\n        return (self.max_level)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if not root:return 0\\n        self.max_level = 0\\n        def dfs(node, level):\\n            self.max_level = max(self.max_level, level)\\n            if not node.children:return\\n            for child in node.children:\\n                dfs(child, level+1)\\n        dfs(root, 1)\\n        return (self.max_level)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 237081,
                "title": "javascript",
                "content": "**\\u65B9\\u6CD51:** \\u5C42\\u5E8F\\u904D\\u5386\\n**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u5148\\u5C42\\u5E8F\\u904D\\u5386, \\u7136\\u540E\\u4E0D\\u65AD\\u5224\\u65AD\\u5C42\\u6B21\\u5373\\u53EF.\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar maxDepth = function(root) {\\n  let r = 0;\\n  const levelOrder = (node, level=1) => {\\n    if (!node) return;\\n    if (level > r) r = level;\\n    node.children.forEach(_c => levelOrder(_c, level + 1));\\n  }\\n  levelOrder(root);\\n  \\n  return r;\\n};\\n```\\n\\n**\\u65B9\\u6CD52:** \\u9012\\u5F52\\u5224\\u65AD\\n**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u4E0D\\u65AD\\u5BF9children\\u8FDB\\u884C\\u9012\\u5F52\\u5904\\u7406.\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar maxDepth = function(root) {\\n  if (!root) return 0;\\n  let max = 1;\\n  for (let i = 0; i < root.children.length; i++) {\\n    max = Math.max(max, maxDepth(root.children[i]) + 1);\\n  }\\n  return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxDepth = function(root) {\\n  let r = 0;\\n  const levelOrder = (node, level=1) => {\\n    if (!node) return;\\n    if (level > r) r = level;\\n    node.children.forEach(_c => levelOrder(_c, level + 1));\\n  }\\n  levelOrder(root);\\n  \\n  return r;\\n};\\n```\n```\\nvar maxDepth = function(root) {\\n  if (!root) return 0;\\n  let max = 1;\\n  for (let i = 0; i < root.children.length; i++) {\\n    max = Math.max(max, maxDepth(root.children[i]) + 1);\\n  }\\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 234734,
                "title": "javascript-simple-two-line-solution",
                "content": "```\\n\\tif(!root) return 0;\\n    return root.children.reduce((acc, child) => Math.max(acc, maxDepth(child)), 0) + 1;\\n```",
                "solutionTags": [],
                "code": "```\\n\\tif(!root) return 0;\\n    return root.children.reduce((acc, child) => Math.max(acc, maxDepth(child)), 0) + 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 233867,
                "title": "c-one-line",
                "content": "```\\npublic class Solution {\\n    public int MaxDepth(Node root) {\\n        return root == null ? 0 : root.children.DefaultIfEmpty().Max(MaxDepth) + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxDepth(Node root) {\\n        return root == null ? 0 : root.children.DefaultIfEmpty().Max(MaxDepth) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226453,
                "title": "java-solution-faster-than-100-easy-to-understand",
                "content": "This is a recursive solution that uses a helper function. I think it\\'s a pretty straightforward solution but feel free to ask questions. Thanks!\\n\\n```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        int max = maximumDepth(root);\\n        return max; \\n    }\\n    \\n    public int maximumDepth(Node root){\\n        if(root == null) return 0;\\n        if(root.children.size() == 0) return 1;\\n        \\n        int max = 0;\\n        for(int i = 0; i < root.children.size(); i++){\\n            max = Math.max(max, maximumDepth(root.children.get(i)));\\n        }\\n        \\n        return 1 + max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        int max = maximumDepth(root);\\n        return max; \\n    }\\n    \\n    public int maximumDepth(Node root){\\n        if(root == null) return 0;\\n        if(root.children.size() == 0) return 1;\\n        \\n        int max = 0;\\n        for(int i = 0; i < root.children.size(); i++){\\n            max = Math.max(max, maximumDepth(root.children.get(i)));\\n        }\\n        \\n        return 1 + max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200326,
                "title": "python-93-solution",
                "content": "```\\nclass Solution(object):        \\n    def maxDepth(self, root):\\n        if root is None:\\n            return 0\\n    \\n        MaxVal = 1\\n        for child in root.children:\\n            depthCount = self.maxDepth(child) + 1\\n            MaxVal = max(MaxVal, depthCount)\\n            \\n    \\n        return MaxVal\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):        \\n    def maxDepth(self, root):\\n        if root is None:\\n            return 0\\n    \\n        MaxVal = 1\\n        for child in root.children:\\n            depthCount = self.maxDepth(child) + 1\\n            MaxVal = max(MaxVal, depthCount)\\n            \\n    \\n        return MaxVal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168030,
                "title": "java-8-streams-simple-solution",
                "content": "Simple recursive solution using Java 8 Stream API:\\n```\\npublic int maxDepth(Node root) {\\n         if (root == null) {\\n                return 0;\\n            }\\n            if (root.children == null ) {\\n                return 1;\\n            }\\n\\n            return 1 + root.children.stream()\\n                    .mapToInt(this::maxDepth)\\n                    .max()\\n                    .orElse(0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxDepth(Node root) {\\n         if (root == null) {\\n                return 0;\\n            }\\n            if (root.children == null ) {\\n                return 1;\\n            }\\n\\n            return 1 + root.children.stream()\\n                    .mapToInt(this::maxDepth)\\n                    .max()\\n                    .orElse(0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165681,
                "title": "concise-bfs-and-dfs-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        return recurse(root);\\n    }\\n    \\n    public int recurse(Node root) {\\n        if(root == null) return 0;\\n        if( root.children == null) return 1;\\n        \\n\\t\\t\\t int max=0;\\n        for(Node each: root.children)\\n            max = Math.max(max, recurse(each));\\n            \\n        return 1+max;\\n    }\\n}\\n\\n    public int traverseBFS(Node root) {\\n        if(root == null) return 0;\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        int count =0, size=0;\\n        \\n        while(queue.size() > 0) {\\n            size = queue.size();\\n            \\n            for( int i=0; i< size; i++) {\\n                Node temp = queue.poll();\\n\\n                if(temp.children != null)\\n                    for( Node each : temp.children)\\n                        queue.add(each);\\n            }\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        return recurse(root);\\n    }\\n    \\n    public int recurse(Node root) {\\n        if(root == null) return 0;\\n        if( root.children == null) return 1;\\n        \\n\\t\\t\\t int max=0;\\n        for(Node each: root.children)\\n            max = Math.max(max, recurse(each));\\n            \\n        return 1+max;\\n    }\\n}\\n\\n    public int traverseBFS(Node root) {\\n        if(root == null) return 0;\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        int count =0, size=0;\\n        \\n        while(queue.size() > 0) {\\n            size = queue.size();\\n            \\n            for( int i=0; i< size; i++) {\\n                Node temp = queue.poll();\\n\\n                if(temp.children != null)\\n                    for( Node each : temp.children)\\n                        queue.add(each);\\n            }\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148927,
                "title": "python-1-liner-in-dfs",
                "content": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        return 1 + max([self.maxDepth(n) for n in root.children] + [0]) if root else 0 \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        return 1 + max([self.maxDepth(n) for n in root.children] + [0]) if root else 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866117,
                "title": "dfs-using-stack-detailed-explanation",
                "content": "# Approach\\n1. The function uses a stack to traverse the tree nodes. A stack is a data structure that follows the `Last-In-First-Out` (`LIFO`) principle, meaning the last element added is the first one to be removed.\\n\\n2. First, it initializes an empty stack.\\n\\n3. It checks if the `root` node is not None (i.e., it exists). If it does, the root node and its depth (which is initially `1`) are added to the stack as a tuple: `stack += [(root, 1)]`. This sets up the starting point for the tree traversal.\\n\\n4. It also initializes a variable `maxDepth` to `0`, which will be used to keep track of the `maximum depth` encountered so far.\\n\\n5. The function enters a `while` loop that continues as long as there are elements in the stack.\\n\\n6. Inside the loop, it pops the top element from the `stack`, which is a tuple containing a node and its depth: `node, depth = stack.pop()`. This is essentially taking the last added node from the stack to process its depth.\\n\\n7. It compares the `current depth` with the `maxDepth` variable and updates maxDepth with the maximum value: `maxDepth = max(maxDepth, depth)`. This ensures that maxDepth always stores the `maximum depth` encountered during the traversal.\\n\\n8. The function then iterates over the `children` of the current node in the loop `for child in node.children:`. For each child, it calculates its depth as `depth + 1` and adds the child and its new depth as a tuple to the stack.\\n\\n9. The loop continues until all nodes are visited.\\n\\n10. After the loop, the function returns the calculated `maxDepth`, representing the maximum depth of the tree.\\n\\n- #### Time Complexity:\\n\\n1. The time complexity of this DFS algorithm depends on the number of nodes in the tree.\\n2. In the `worst` case, the algorithm visits all nodes exactly once, as it traverses the entire tree.\\n3. Therefore, the time complexity is $O(N)$, where `N` is the number of nodes in the tree.\\n\\n- #### Space Complexity:\\n\\n1. The space complexity is determined by the stack used for `DFS` traversal.\\n2. In the `worst` case, the stack can hold all the nodes in the longest path from the root to a leaf. This happens when the tree is `skewed` (essentially forming a linked list).\\n3. Therefore, the space complexity of the algorithm is $O(H)$, where `H` is the height of the tree. In the worst case (`skewed tree`), `H` can be equal to `N` (`number of nodes`), resulting in a space complexity of $O(N)$.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        stack = []\\n        if root:\\n            stack += [(root,1)]\\n        maxDepth = 0\\n        while stack:\\n            node,depth = stack.pop()\\n            maxDepth = max(maxDepth, depth)\\n            for child in node.children:\\n                stack += (child,depth+1),\\n        return maxDepth\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        stack = []\\n        if root:\\n            stack += [(root,1)]\\n        maxDepth = 0\\n        while stack:\\n            node,depth = stack.pop()\\n            maxDepth = max(maxDepth, depth)\\n            for child in node.children:\\n                stack += (child,depth+1),\\n        return maxDepth\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865955,
                "title": "bfs-iterative-solution-beats-100-runtime-detailed-explanation",
                "content": "# Performance\\n![image.png](https://assets.leetcode.com/users/images/1faec166-08ed-4304-a46b-67016843af66_1691220098.4566412.png)\\n\\n# Approach\\nHere\\'s the explanation:\\n\\n1. The code starts by creating an empty list named `queue`. This list will be used to perform a `\"breadth-first search\"` traversal of the tree nodes.\\n\\n2. Next, there is an `if` statement: `if root:`. It checks if the root node exists (i.e., it\\'s not None). If it exists, the code adds a tuple containing the root `node` and its `depth` (which is initially `1`) to the queue. This tuple represents the current node and its depth in the tree.\\n\\n3. The code then initializes a variable `maxDepth` to `0`. This variable will be used to keep track of the maximum depth found during the traversal.\\n\\n4. The code enters a loop using a for loop: `for (node, depth) in queue:`. This loop will iterate over each element `(node, depth)` in the `queue` list.\\n\\n5. Inside the loop, the code updates the `maxDepth` variable to the `current depth`. This effectively keeps track of the deepest depth found so far.\\n\\n6. The code then updates the `queue` list with new tuples. It uses a generator expression inside `queue += ...` to add elements to the `queue`. This step is crucial for the breadth-first search traversal. It iterates over each `child node` of the `current node`, and for each child, it creates a new tuple with the child node and its `depth` incremented by `1`. This is how the traversal progresses to deeper levels in the tree.\\n\\n7. The loop continues until all nodes in the `queue` have been processed. The process of adding child nodes and their depths to the queue continues, effectively exploring the tree in a breadth-first manner.\\n\\n8. Once the loop ends, the function returns the value of `maxDepth`, which represents the maximum depth of the tree (i.e., the longest path from the root to a leaf node).\\n\\nIn summary, this function performs a `breadth-first search` on a tree structure starting from the root node and finds the `maximum depth` of the tree. The maximum depth is the longest path from the root node to any leaf node.\\n\\n# Complexity\\n- #### Time Complexity:\\n\\n1. Enqueuing the `root` node: $O(1)$\\n2. The loop iterates through the queue until it becomes empty. In the worst case, it can iterate through all the nodes of the N-ary tree, which results in $O(N)$ iterations.\\n3. For each node, it iterates through its children to add them to the queue. In the `worst` case, where each node has a large number of children, this step would take $O(M)$ time per node. Since we perform this operation for each node, the total `time complexity` for this step is $O(N * M)$.\\n\\nSo the overall `time complexity` of the function is $O(N * M)$ in the `worst` case.\\n\\n- #### Space Complexity:\\n\\n1. The queue is used to store tuples of `(node, depth)`. In the `worst` case, the queue can store all the `nodes` in the tree, which results in a space complexity of $O(N)$.\\n2. Apart from the queue, the function uses a few variables (e.g., `maxDepth`), but they have constant space usage.\\n\\nSo the overall `space complexity` is $O(N)$ in the `worst` case.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        queue = []\\n        if root:\\n            queue += [(root,1)]\\n        maxDepth = 0\\n        for (node,depth) in queue:\\n            maxDepth=depth\\n            queue += ((child,depth+1) for child in node.children)\\n        return maxDepth\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        queue = []\\n        if root:\\n            queue += [(root,1)]\\n        maxDepth = 0\\n        for (node,depth) in queue:\\n            maxDepth=depth\\n            queue += ((child,depth+1) for child in node.children)\\n        return maxDepth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865642,
                "title": "recursive-sollution-o-n-detailed-explanation",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/ebf37284-fa9c-4a2a-9807-df05441c083c_1691216474.9388244.png)\\n\\n# Approach\\nLet me explain how it works step by step:\\n\\n1. First, we check if the tree has a `root` or not. If there is no root (which means the tree is empty), we conclude that the depth of the tree is `0`, because there are no branches or levels.\\n\\n2. If the tree has a root, we initialize a variable called `depth` to `1`. This means, at least, there is one level (the root level) in the tree.\\n\\n3. Now, we start exploring the branches of the `root`. We look at each branch one by one.\\n\\n4. For each branch, we call the `maxDepth` function again. But this time, we pass that branch as the new root. This is like exploring the sub-branches and the sub-branches of sub-branches, until we reach the end of each branch.\\n\\n5. When we explore each branch, we get a number, and that number tells us how deep that branch goes (the number of levels it has). We add `1` to this number because we are considering the current branch\\'s level as well.\\n\\n6. We compare this number with the current depth value, which is the maximum depth we have found so far. If the number we got from the current branch is greater than the current depth, we update `depth` to be that number.\\n\\n7. We repeat this process for each branch. So, we go through all the branches, explore their sub-branches, and keep updating `depth` if we find a deeper branch.\\n\\n8. Once we finish exploring all the branches, the depth variable will hold the maximum number of levels we found in the entire tree.\\n\\n9. Finally, we return this `maximum depth` value, which gives us the answer: How deep the tree goes, or in other words, its `maximum depth (height)`.\\n\\nIn summary, the `maxDept`h function explores the tree\\'s branches and sub-branches, recursively finding the `deepest path` possible, and returns the maximum number of levels in the tree, giving us its `height`.\\n\\n- #### Time complexity:\\nThe time complexity of the code is $$O(N)$$, where `N` is the number of nodes in the tree. This is because, in the worst-case scenario, we may have to visit all nodes of the tree once.\\n\\n- #### Space complexity:\\nThe space complexity of the code is $$O(H)$$, where `H` is the maximum height (depth) of the tree. This is because the function uses recursion, and the maximum depth of the call stack will be equal to the height of the tree. In other words, the function will create a new call frame for each level of the tree it explores. If the tree is well-balanced (i.e., has a smaller height), the space complexity will be relatively low. However, if the tree is unbalanced (i.e., skewed), the space complexity could be higher.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root:\\n            return 0\\n        depth = 1\\n        for node in root.children:\\n            curr = self.maxDepth(node)+1\\n            depth = max(depth, curr)\\n        return depth\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root:\\n            return 0\\n        depth = 1\\n        for node in root.children:\\n            curr = self.maxDepth(node)+1\\n            depth = max(depth, curr)\\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729516,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public int helper(Node root, int cur){\\n        if(root!=null){\\n            if(root.children.Count==0)\\n                return cur;\\n            int tmp,max=-1;\\n            for(int i=0;i<root.children.Count;i++){\\n                tmp=helper(root.children[i],cur+1);\\n                if(tmp>max)\\n                    max=tmp;\\n            }\\n            return max;\\n        } else\\n            return cur;\\n    }\\n    public int MaxDepth(Node root) {\\n        return root==null?0: helper(root,1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int helper(Node root, int cur){\\n        if(root!=null){\\n            if(root.children.Count==0)\\n                return cur;\\n            int tmp,max=-1;\\n            for(int i=0;i<root.children.Count;i++){\\n                tmp=helper(root.children[i],cur+1);\\n                if(tmp>max)\\n                    max=tmp;\\n            }\\n            return max;\\n        } else\\n            return cur;\\n    }\\n    public int MaxDepth(Node root) {\\n        return root==null?0: helper(root,1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641746,
                "title": "c-bfs-simple",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (!root) return 0;\\n\\n        int levels = 0;\\n        queue<Node*> Q; Q.push(root);\\n\\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            levels++;\\n            for (int _ = 0; _ < size; _++) {\\n                Node* curr = Q.front(); Q.pop();\\n                for (Node*& child : curr->children) Q.push(child);\\n            }\\n        }\\n\\n        return levels;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Queue"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if (!root) return 0;\\n\\n        int levels = 0;\\n        queue<Node*> Q; Q.push(root);\\n\\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            levels++;\\n            for (int _ = 0; _ < size; _++) {\\n                Node* curr = Q.front(); Q.pop();\\n                for (Node*& child : curr->children) Q.push(child);\\n            }\\n        }\\n\\n        return levels;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155533,
                "title": "python-simple-bfs-beats-tc-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(V+E)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(|V|)$$\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root==None:\\n            return 0\\n        que=Deque()\\n        que.append(root)\\n        count=0\\n        while(que):\\n            n=len(que)\\n            for _ in range(n):\\n                cur=que.popleft()\\n                for i in cur.children:\\n                    que.append(i)\\n            count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root==None:\\n            return 0\\n        que=Deque()\\n        que.append(root)\\n        count=0\\n        while(que):\\n            n=len(que)\\n            for _ in range(n):\\n                cur=que.popleft()\\n                for i in cur.children:\\n                    que.append(i)\\n            count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918104,
                "title": "100-beats-easy-step-java",
                "content": "- 38/38 cases passed (0 ms)\\n- Your runtime beats 100 % of java submissions\\n- Your memory usage beats 86.23 % of java submissions (42.4 MB)\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    int trav(Node n, int p){\\n        if(n==null)return p;\\n        int max=p;\\n        for(int i=0;i<n.children.size();i++)\\n            max=Math.max(max, trav(n.children.get(i), p+1));\\n        \\n        return max;\\n    }\\n\\n\\n    public int maxDepth(Node root) {\\n        if(root==null) return 0;\\n        return trav(root,1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    int trav(Node n, int p){\\n        if(n==null)return p;\\n        int max=p;\\n        for(int i=0;i<n.children.size();i++)\\n            max=Math.max(max, trav(n.children.get(i), p+1));\\n        \\n        return max;\\n    }\\n\\n\\n    public int maxDepth(Node root) {\\n        if(root==null) return 0;\\n        return trav(root,1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772897,
                "title": "golang-solution-clean-concise-bfs",
                "content": "```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Children []*Node\\n * }\\n */\\n\\nfunc maxDepth(root *Node) int {\\n    if root == nil {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tqueue := []*Node{root}\\n\\tvar depth int\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tfor _, node := range queue {\\t\\t\\t\\n\\t\\t\\tqueue = queue[1:]\\n\\t\\t\\tif node.Children != nil {\\n\\t\\t\\t\\tfor _, child := range node.Children {\\n\\t\\t\\t\\t\\tqueue = append(queue, child)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdepth++\\n\\t}\\n\\n\\treturn depth\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Children []*Node\\n * }\\n */\\n\\nfunc maxDepth(root *Node) int {\\n    if root == nil {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tqueue := []*Node{root}\\n\\tvar depth int\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tfor _, node := range queue {\\t\\t\\t\\n\\t\\t\\tqueue = queue[1:]\\n\\t\\t\\tif node.Children != nil {\\n\\t\\t\\t\\tfor _, child := range node.Children {\\n\\t\\t\\t\\t\\tqueue = append(queue, child)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdepth++\\n\\t}\\n\\n\\treturn depth\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2710737,
                "title": "easy-c-solution-dfs",
                "content": "```\\n\\tint ans = INT_MIN;\\n    void solve(Node* root,int depth)\\n    {\\n        if(!root)\\n            return;\\n        ans = max(ans,depth);\\n        \\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            solve(root->children[i],depth+1);  // move to root\\'s children and increase depth by 1\\n        }\\n    }\\n    \\n    int maxDepth(Node* root) {\\n        if(!root)\\n            return 0;\\n        solve(root,1);\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\tint ans = INT_MIN;\\n    void solve(Node* root,int depth)\\n    {\\n        if(!root)\\n            return;\\n        ans = max(ans,depth);\\n        \\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            solve(root->children[i],depth+1);  // move to root\\'s children and increase depth by 1\\n        }\\n    }\\n    \\n    int maxDepth(Node* root) {\\n        if(!root)\\n            return 0;\\n        solve(root,1);\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2710372,
                "title": "ruby-with-recursion-from-junior",
                "content": "```\\ndef maxDepth(root)\\n    return 0 unless root\\n    @max, k = 1, 1\\n    walker(root,k)\\n    @max\\nend\\n\\ndef walker(root,k)\\n    @max = k unless k <= @max\\n    root.children.each { |child| walker(child,k+1)}\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef maxDepth(root)\\n    return 0 unless root\\n    @max, k = 1, 1\\n    walker(root,k)\\n    @max\\nend\\n\\ndef walker(root,k)\\n    @max = k unless k <= @max\\n    root.children.each { |child| walker(child,k+1)}\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2672301,
                "title": "python-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root == None:\\n            return 0\\n        else:\\n            depth = 0\\n            nodes_queue = [root]\\n            next_nodes_queue = []\\n            while(nodes_queue):\\n                node_out = nodes_queue.pop(0)\\n                for child in node_out.children:\\n                    next_nodes_queue.append(child)\\n                if nodes_queue == []:\\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\\n                    depth += 1\\n            return depth\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root == None:\\n            return 0\\n        else:\\n            depth = 0\\n            nodes_queue = [root]\\n            next_nodes_queue = []\\n            while(nodes_queue):\\n                node_out = nodes_queue.pop(0)\\n                for child in node_out.children:\\n                    next_nodes_queue.append(child)\\n                if nodes_queue == []:\\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\\n                    depth += 1\\n            return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662396,
                "title": "recursive-java-easy-solution",
                "content": "```\\nclass Solution {\\n    static int maxcount ;\\n    void maxheight(Node root,int height){\\n        if(root!=null){\\n            height++;\\n            if((root.children).isEmpty()){\\n            if(height>maxcount){\\n                maxcount = height;\\n            }\\n        }\\n        \\n        for(Node child : root.children){\\n            maxheight(child,height);\\n        }\\n        }\\n        \\n    }\\n    public int maxDepth(Node root) {\\n        maxcount = 0;\\n        int height = 0;\\n        maxheight(root,height);\\n        return maxcount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    static int maxcount ;\\n    void maxheight(Node root,int height){\\n        if(root!=null){\\n            height++;\\n            if((root.children).isEmpty()){\\n            if(height>maxcount){\\n                maxcount = height;\\n            }\\n        }\\n        \\n        for(Node child : root.children){\\n            maxheight(child,height);\\n        }\\n        }\\n        \\n    }\\n    public int maxDepth(Node root) {\\n        maxcount = 0;\\n        int height = 0;\\n        maxheight(root,height);\\n        return maxcount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639215,
                "title": "1-line-python-easy-using-dfs",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        return max(self.maxDepth(child) for child in root.children or [0]) + 1 if root else 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        return max(self.maxDepth(child) for child in root.children or [0]) + 1 if root else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568677,
                "title": "java-recursive-short-and-intuitive",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if (root == null) return 0;\\n        List<Node> children = root.children;\\n        int max = 0;\\n        for (Node node : children) {\\n            max = Math.max(max, maxDepth(node));\\n        }\\n        return 1 + max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if (root == null) return 0;\\n        List<Node> children = root.children;\\n        int max = 0;\\n        for (Node node : children) {\\n            max = Math.max(max, maxDepth(node));\\n        }\\n        return 1 + max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547270,
                "title": "very-easy-one-liner-implementations",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        def dfs(node):\\n            if not node:\\n                return 0\\n            return 1+max([dfs(child) for child in node.children if node.children],default=0)\\n        return dfs(root)\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        def dfs(node):\\n            if not node:\\n                return 0\\n            return 1+max([dfs(child) for child in node.children if node.children],default=0)\\n        return dfs(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535053,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        queue<Node*>q;\\n        if(root==NULL)return 0;\\n        q.push(root);\\n        int c=0;\\n        while(!q.empty()){\\n            int s=q.size();\\n            for(int i=0;i<s;i++){\\n                Node* a=q.front();\\n                q.pop();\\n                for(auto j:a->children){\\n                    q.push(j);\\n                }\\n            }\\n            c++;\\n            \\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        queue<Node*>q;\\n        if(root==NULL)return 0;\\n        q.push(root);\\n        int c=0;\\n        while(!q.empty()){\\n            int s=q.size();\\n            for(int i=0;i<s;i++){\\n                Node* a=q.front();\\n                q.pop();\\n                for(auto j:a->children){\\n                    q.push(j);\\n                }\\n            }\\n            c++;\\n            \\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506696,
                "title": "easy-shoort-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n    public int maxDepth(Node root) {\\n        dfs(root, 1);\\n        return max;\\n    }\\n    \\n    int max = 0;\\n    \\n    private void dfs(Node root, int lvl){\\n        if(root == null) return ;\\n        \\n        max = Math.max(max, lvl);\\n        \\n        for(Node node: root.children) dfs(node, lvl+1);\\n        \\n        return ;\\n    }\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2504549,
                "title": "simple-pyhton-solution-faster-bfs-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if(root==None):\\n            return 0\\n        \\n        q=collections.deque()\\n        q.append(root)\\n        level=0\\n        while(q):\\n            level+=1\\n            for i in range(len(q)):\\n                node=q.popleft()\\n                for i in node.children:\\n                    q.append(i)\\n        return level\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if(root==None):\\n            return 0\\n        \\n        q=collections.deque()\\n        q.append(root)\\n        level=0\\n        while(q):\\n            level+=1\\n            for i in range(len(q)):\\n                node=q.popleft()\\n                for i in node.children:\\n                    q.append(i)\\n        return level\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346441,
                "title": "java-bfs-solution",
                "content": "\\n\\tpublic int maxDepth(Node root) {\\n        int depth = 0;\\n        \\n        if (root == null)\\n            return 0;\\n        \\n        Deque<Node> queue = new ArrayDeque<>();\\n        \\n        queue.addLast(root);\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                Node cur = queue.pollFirst();\\n                for (Node node : cur.children)\\n                    queue.addLast(node);\\n            }\\n            depth++;\\n        }\\n        \\n        return depth;\\n    }",
                "solutionTags": [],
                "code": "\\n\\tpublic int maxDepth(Node root) {\\n        int depth = 0;\\n        \\n        if (root == null)\\n            return 0;\\n        \\n        Deque<Node> queue = new ArrayDeque<>();\\n        \\n        queue.addLast(root);\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                Node cur = queue.pollFirst();\\n                for (Node node : cur.children)\\n                    queue.addLast(node);\\n            }\\n            depth++;\\n        }\\n        \\n        return depth;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2266146,
                "title": "java-0-ms-100-faster-5-line-code-no-helper-fun-simple-recursion",
                "content": "\\'\\'\\'\\npublic int maxDepth(Node root) {\\n        if(root == null){return 0;}\\n        if(root.children.size() == 0){return 1;}\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<root.children.size();i++){\\n            max = Math.max(max,maxDepth(root.children.get(i)));\\n        }\\n        return 1+max;   \\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "\\'\\'\\'\\npublic int maxDepth(Node root) {\\n        if(root == null){return 0;}\\n        if(root.children.size() == 0){return 1;}\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<root.children.size();i++){\\n            max = Math.max(max,maxDepth(root.children.get(i)));\\n        }\\n        return 1+max;   \\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2266014,
                "title": "python-clean-code-o-n",
                "content": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        def dfs(v):\\n            if not v: return 0\\n            res = 1\\n            for w in v.children:\\n                res = max(res, 1+dfs(w))\\n            return res\\n        return dfs(root)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        def dfs(v):\\n            if not v: return 0\\n            res = 1\\n            for w in v.children:\\n                res = max(res, 1+dfs(w))\\n            return res\\n        return dfs(root)",
                "codeTag": "Java"
            },
            {
                "id": 2247981,
                "title": "0ms-100-faster-java-simple-solution",
                "content": "![image](https://assets.leetcode.com/users/images/f165d15c-54b3-4a58-9b0f-b7bf3fda12f8_1657138401.865614.png)\\n```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        int level = 0;\\n        levelOrderTraversal(root, result, level);\\n        \\n        return result.size();\\n    }\\n    private void levelOrderTraversal(Node root, List<List<Integer>> result, int level){\\n        \\n        if(level >= result.size()){\\n            List<Integer> list = new ArrayList<>();\\n            list.add(root.val);\\n            result.add(list);\\n        }else{\\n            result.get(level).add(root.val);\\n        }\\n        for(int i = 0; i < root.children.size(); i++){\\n            levelOrderTraversal(root.children.get(i), result, level+1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        int level = 0;\\n        levelOrderTraversal(root, result, level);\\n        \\n        return result.size();\\n    }\\n    private void levelOrderTraversal(Node root, List<List<Integer>> result, int level){\\n        \\n        if(level >= result.size()){\\n            List<Integer> list = new ArrayList<>();\\n            list.add(root.val);\\n            result.add(list);\\n        }else{\\n            result.get(level).add(root.val);\\n        }\\n        for(int i = 0; i < root.children.size(); i++){\\n            levelOrderTraversal(root.children.get(i), result, level+1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192345,
                "title": "easy-logic-completed-in-3ms",
                "content": "class Solution {\\n    public int maxDepth(Node root) {\\n        Queue<Node> queue=new LinkedList<>();\\n        int count=0;\\n        if(root==null)\\n            return count;\\n        queue.offer(root);\\n        while(queue.size()!=0)\\n        {\\n            int len=queue.size();\\n            for(int i=0;i<len;i++)\\n            {\\n                Node node=queue.poll();\\n                //if(node!=null)\\n                for(Node child:node.children)\\n                    queue.offer(child);\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxDepth(Node root) {\\n        Queue<Node> queue=new LinkedList<>();\\n        int count=0;\\n        if(root==null)\\n            return count;\\n        queue.offer(root);\\n        while(queue.size()!=0)\\n        {\\n            int len=queue.size();\\n            for(int i=0;i<len;i++)\\n            {\\n                Node node=queue.poll();\\n                //if(node!=null)\\n                for(Node child:node.children)\\n                    queue.offer(child);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2190005,
                "title": "c-dfs-bfs-solutions",
                "content": "**Code (dfs - recursive):**\\n```\\nclass Solution {\\n public:\\n  int MaxDepth(Node *root) {\\n    if (!root) return 0;\\n    int max_depth = 0;\\n    for (auto child : root->children)\\n      max_depth = max(max_depth, MaxDepth(child));\\n    return max_depth + 1;\\n  }\\n};\\n```\\n\\n---\\n**Code (dfs - iterative):**\\n```\\nclass Solution {\\n public:\\n  int MaxDepth(Node *root) {\\n    int max_depth = 0, depth;\\n    stack<pair<Node *, int>> s;\\n\\n    if (root) s.push({root, 1});\\n    while (!s.empty()) {\\n      root = s.top().first;\\n      depth = s.top().second;\\n      s.pop();\\n\\n      if (root->children.empty())\\n        max_depth = max(max_depth, depth);\\n      for (auto child : root->children)\\n        s.push({child, depth + 1});\\n    }\\n    return max_depth;\\n  }\\n};\\n```\\n\\n---\\n**Code (bfs - iterative):**\\n```\\nclass Solution {\\n public:\\n  int MaxDepth(Node *root) {\\n    int max_depth = 0, breadth;\\n    queue<Node *> q;\\n\\n    if (root) q.push(root);\\n    while (!q.empty()) {\\n      breadth = q.size(), max_depth++;\\n      for (int i = 0; i < breadth; i++) {\\n        root = q.front(), q.pop();\\n        for (auto child : root->children) q.push(child);\\n      }\\n    }\\n    return max_depth;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int MaxDepth(Node *root) {\\n    if (!root) return 0;\\n    int max_depth = 0;\\n    for (auto child : root->children)\\n      max_depth = max(max_depth, MaxDepth(child));\\n    return max_depth + 1;\\n  }\\n};\\n```\n```\\nclass Solution {\\n public:\\n  int MaxDepth(Node *root) {\\n    int max_depth = 0, depth;\\n    stack<pair<Node *, int>> s;\\n\\n    if (root) s.push({root, 1});\\n    while (!s.empty()) {\\n      root = s.top().first;\\n      depth = s.top().second;\\n      s.pop();\\n\\n      if (root->children.empty())\\n        max_depth = max(max_depth, depth);\\n      for (auto child : root->children)\\n        s.push({child, depth + 1});\\n    }\\n    return max_depth;\\n  }\\n};\\n```\n```\\nclass Solution {\\n public:\\n  int MaxDepth(Node *root) {\\n    int max_depth = 0, breadth;\\n    queue<Node *> q;\\n\\n    if (root) q.push(root);\\n    while (!q.empty()) {\\n      breadth = q.size(), max_depth++;\\n      for (int i = 0; i < breadth; i++) {\\n        root = q.front(), q.pop();\\n        for (auto child : root->children) q.push(child);\\n      }\\n    }\\n    return max_depth;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125689,
                "title": "c-simple-approach-recursive-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root==NULL)\\n            return 0;\\n        int ans=0;\\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            int temp=maxDepth(root->children[i]);\\n            ans=max(ans,temp);\\n        }\\n        return 1+ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root==NULL)\\n            return 0;\\n        int ans=0;\\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            int temp=maxDepth(root->children[i]);\\n            ans=max(ans,temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2091554,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int max = 1;\\n        for(Node c: root.children) {\\n            max = Math.max(max, 1 + maxDepth(c));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int max = 1;\\n        for(Node c: root.children) {\\n            max = Math.max(max, 1 + maxDepth(c));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989133,
                "title": "javascript-dfs-recursive-solution-with-short-comment-image-91-65-faster",
                "content": "```\\nvar maxDepth = function(root) {\\n    if(!root) return 0;  // if root is null, depth is 0\\n    let depth = 1;  // root\\'s depth is 1\\n    let max = 0;  // maximum depth of each children node\\n    \\n    for(let child of root.children) {\\n        max = Math.max(maxDepth(child), max)  // Calculate the maximum depth of each children node with recursion\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // it means each children node to be root node in maxDepth() function recursion\\n    }\\n    depth += max;  // root node\\'s depth is to be calculated root node\\'s depth(1) plus maximum depth of each children node\\n    return depth;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/d8835efe-8d3f-4026-8ce7-0138d2877d1d_1651154028.2737224.jpeg)\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar maxDepth = function(root) {\\n    if(!root) return 0;  // if root is null, depth is 0\\n    let depth = 1;  // root\\'s depth is 1\\n    let max = 0;  // maximum depth of each children node\\n    \\n    for(let child of root.children) {\\n        max = Math.max(maxDepth(child), max)  // Calculate the maximum depth of each children node with recursion\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // it means each children node to be root node in maxDepth() function recursion\\n    }\\n    depth += max;  // root node\\'s depth is to be calculated root node\\'s depth(1) plus maximum depth of each children node\\n    return depth;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977860,
                "title": "js-dfs-recursion-easy-one",
                "content": "1. **make array for storing depth for every child**\\n2. **traverse with DFS  to last leaf node of every child**\\n3. **return max depth of it**\\n\\n\\n```\\nvar maxDepth = function(root) {\\nlet nums= [];\\n    traverseDepth(root,nums,0)\\n    let max=  Math.max(...nums);\\n  return  max<=0 ?0:max;\\n}\\n\\nfunction traverseDepth(root,nums,depth=0){\\n    if(!root) return 0;\\n     let c= depth;\\n        for (child of root.children){\\n            if(child)\\n            c= traverseDepth(child,nums,depth+1)\\n            \\n            \\n        }\\n    \\n    \\n  nums.push(c+1)\\n    return c; \\n    \\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar maxDepth = function(root) {\\nlet nums= [];\\n    traverseDepth(root,nums,0)\\n    let max=  Math.max(...nums);\\n  return  max<=0 ?0:max;\\n}\\n\\nfunction traverseDepth(root,nums,depth=0){\\n    if(!root) return 0;\\n     let c= depth;\\n        for (child of root.children){\\n            if(child)\\n            c= traverseDepth(child,nums,depth+1)\\n            \\n            \\n        }\\n    \\n    \\n  nums.push(c+1)\\n    return c; \\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1963939,
                "title": "faster-than-80-easy-java",
                "content": "```\\nclass Solution {\\n    public int maxDepth(Node node) {\\n        if (node == null)\\n            return 0;\\n        int ht = 0;\\n        for (Node child : node.children) {\\n            ht= Math.max(ht, maxDepth(child));\\n        }\\n        return ht+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node node) {\\n        if (node == null)\\n            return 0;\\n        int ht = 0;\\n        for (Node child : node.children) {\\n            ht= Math.max(ht, maxDepth(child));\\n        }\\n        return ht+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946408,
                "title": "easy-to-understand-java-bfs-level-order-dfs",
                "content": "**BFS**\\n```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        Queue<Node> que = new LinkedList<>();\\n        que.add(root);\\n        int level =0;\\n        while(!que.isEmpty()){\\n            level++;\\n            int size = que.size();\\n            for(int i=0; i<size; i++){\\n                Node cur = que.poll();\\n                List<Node> child = cur.children;\\n                for(Node children: child){\\n                    que.add(children);\\n                }\\n            }\\n            \\n        }\\n        return level;\\n    }\\n}\\n```\\n\\n**DFS**\\n```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int height = 1;\\n        for(Node child: root.children){\\n            height = Math.max(height, 1+maxDepth(child));\\n        }\\n        return height;\\n    }\\n}\\n```\\n\\n\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Don\\'t Forget to **upvote**\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        Queue<Node> que = new LinkedList<>();\\n        que.add(root);\\n        int level =0;\\n        while(!que.isEmpty()){\\n            level++;\\n            int size = que.size();\\n            for(int i=0; i<size; i++){\\n                Node cur = que.poll();\\n                List<Node> child = cur.children;\\n                for(Node children: child){\\n                    que.add(children);\\n                }\\n            }\\n            \\n        }\\n        return level;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int height = 1;\\n        for(Node child: root.children){\\n            height = Math.max(height, 1+maxDepth(child));\\n        }\\n        return height;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918255,
                "title": "python-bfs",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        \\n        current_depth = 1\\n        if not root:\\n            return 0\\n        queue = [root]\\n        \\n        while(queue):\\n            l = len(queue)\\n            for i in range(l):\\n                node = queue.pop(0)\\n                for n in node.children:\\n                    if n:\\n                        queue.append(n)\\n            current_depth +=1\\n        \\n        return current_depth-1\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        \\n        current_depth = 1\\n        if not root:\\n            return 0\\n        queue = [root]\\n        \\n        while(queue):\\n            l = len(queue)\\n            for i in range(l):\\n                node = queue.pop(0)\\n                for n in node.children:\\n                    if n:\\n                        queue.append(n)\\n            current_depth +=1\\n        \\n        return current_depth-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890005,
                "title": "c-simple-solution-using-accumulate",
                "content": "\\tint maxDepth(Node* root) {\\n\\t\\t\\tif(!root)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\treturn std::accumulate(\\n\\t\\t\\t\\troot->children.begin(), root->children.end(), 1, \\n\\t\\t\\t\\t[this](int maxResult, Node* node) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// if node exists return 1 + (depth of children) else just 0 and accumulate the result by taking max.\\n\\t\\t\\t\\t\\treturn std::max(maxResult, !node? 0 : 1 + maxDepth(node) );\\n\\t\\t\\t\\t});\\n\\t\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tint maxDepth(Node* root) {\\n\\t\\t\\tif(!root)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\treturn std::accumulate(\\n\\t\\t\\t\\troot->children.begin(), root->children.end(), 1, \\n\\t\\t\\t\\t[this](int maxResult, Node* node) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// if node exists return 1 + (depth of children) else just 0 and accumulate the result by taking max.\\n\\t\\t\\t\\t\\treturn std::max(maxResult, !node? 0 : 1 + maxDepth(node) );\\n\\t\\t\\t\\t});\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1887461,
                "title": "python-dfs-clean-code",
                "content": "```\\ndef height(root):\\n    if root is None:\\n        return 0\\n    ans=0\\n    for i in root.children:\\n        ans=max(ans,height(i))\\n    return ans+1\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        return height(root)\\n```\\n   **if you like the solution please upvote**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef height(root):\\n    if root is None:\\n        return 0\\n    ans=0\\n    for i in root.children:\\n        ans=max(ans,height(i))\\n    return ans+1\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        return height(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881273,
                "title": "simple-4-lines-of-c-code-check-it-once",
                "content": "# **[@iprincekumark](https://leetcode.com/iprincekumark/)**\\nVISIT MY PROFILE\\n**CODE**\\n```\\nint maxDepth(Node* root) {\\n        if(root == NULL)\\n            return 0;\\n        int i, depth = 1;\\n        for(i=0; i<root->children.size(); i++)\\n            depth = max(maxDepth(root->children[i]) + 1, depth);\\n        return depth;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint maxDepth(Node* root) {\\n        if(root == NULL)\\n            return 0;\\n        int i, depth = 1;\\n        for(i=0; i<root->children.size(); i++)\\n            depth = max(maxDepth(root->children[i]) + 1, depth);\\n        return depth;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1815357,
                "title": "c-bfs-dfs-two-methods-to-implement",
                "content": "(1)Level Traversal, BFS\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(!root)\\n            return 0;\\n        \\n        queue<Node*> q;\\n        Node* curr=root;\\n        q.push(curr);\\n        int depth=0;\\n        while(!q.empty()){\\n            depth++;\\n            int n_level=q.size();\\n            for(int i=0;i<n_level;i++){\\n                curr=q.front();\\n                q.pop();\\n                for(Node* t:curr->children){\\n                    q.push(t);\\n                }\\n            }\\n        }\\n        return depth;\\n    }\\n};\\n```\\n(2)DFS\\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(!root)\\n            return 0;\\n        \\n        int res=0;\\n        int temp=0;\\n        for(Node* t:root->children){\\n            temp=maxDepth(t);\\n            res=max(res,temp);\\n        }\\n        return res+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(!root)\\n            return 0;\\n        \\n        queue<Node*> q;\\n        Node* curr=root;\\n        q.push(curr);\\n        int depth=0;\\n        while(!q.empty()){\\n            depth++;\\n            int n_level=q.size();\\n            for(int i=0;i<n_level;i++){\\n                curr=q.front();\\n                q.pop();\\n                for(Node* t:curr->children){\\n                    q.push(t);\\n                }\\n            }\\n        }\\n        return depth;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(!root)\\n            return 0;\\n        \\n        int res=0;\\n        int temp=0;\\n        for(Node* t:root->children){\\n            temp=maxDepth(t);\\n            res=max(res,temp);\\n        }\\n        return res+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797459,
                "title": "c-easy-to-understand",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int h = 0;\\n        \\n        for(auto x : root->children){\\n            h = max(h,maxDepth(x));\\n        }\\n        return 1+h;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxDepth(Node* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int h = 0;\\n        \\n        for(auto x : root->children){\\n            h = max(h,maxDepth(x));\\n        }\\n        return 1+h;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769554,
                "title": "java-simple-recursive-solution-beats-100-runtime",
                "content": "The code explains itself.\\n\\n```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int depth = 0;\\n        for(int i = 0; i < root.children.size(); i++){\\n            depth = Math.max(depth, maxDepth(root.children.get(i)));\\n        }\\n        return depth + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null) return 0;\\n        int depth = 0;\\n        for(int i = 0; i < root.children.size(); i++){\\n            depth = Math.max(depth, maxDepth(root.children.get(i)));\\n        }\\n        return depth + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757615,
                "title": "python-1-liner",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        return 1 + max(map(self.maxDepth, root.children), default = 0) if root else 0\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        return 1 + max(map(self.maxDepth, root.children), default = 0) if root else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737715,
                "title": "simple-dfs-solution-in-python",
                "content": "\\xB4\\xB4\\xB4\\nclass Solution:\\n\\n    def isLeaf(self, node):\\n        return node.children == []\\n    \\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root == None:\\n            return 0\\n        \\n        stack = []\\n        checked = {}\\n        count = 0\\n        checked[root] = 1\\n        stack.append(root)\\n        \\n        while stack != []:\\n            current = stack.pop()\\n            \\n            if self.isLeaf(current):\\n                count = max(count, checked[current])\\n            else:\\n                for i in current.children:\\n                    if i not in checked:\\n                        stack.append(i)\\n                        checked[i] = checked[current] + 1\\n        return count\\n\\xB4\\xB4\\xB4",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n\\n    def isLeaf(self, node):\\n        return node.children == []\\n    \\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root == None:\\n            return 0\\n        \\n        stack = []\\n        checked = {}",
                "codeTag": "Java"
            },
            {
                "id": 1723408,
                "title": "beginner-friendly-java-solution",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null)    return 0;\\n        int max = 0;\\n        for(Node child : root.children){\\n            max = Math.max(max, maxDepth(child));\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public int maxDepth(Node root) {\\n        if(root == null)    return 0;\\n        int max = 0;\\n        for(Node child : root.children){\\n            max = Math.max(max, maxDepth(child));\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572140,
                "content": [
                    {
                        "username": "Kurtz",
                        "content": "From the description, we don\\'t know if a node has no children, will it be ``self.children == []``, or ``self.children == None``. It will be ideal to add a line indicating that ``self.children = []`` if the node has no children."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "DFS using stack, Detailed Explanation\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3866117/dfs-using-stack-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`BFS` iterative approach, Beats 100% Runtime\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865955/bfs-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Explore the tree\\'s `branches` and `sub-branches`, recursively finding the deepest path possible, and returns the maximum number of levels in the tree, giving us its height!!! Simple!\\n\\n`Here is Recursive Implementation` $$O(N)$$, with Detailed Explanation:\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865642/recursive-sollution-o-n-detailed-explanation/"
                    },
                    {
                        "username": "edsaunders92",
                        "content": "Type hint poor in Python3. Optional would be clearer"
                    },
                    {
                        "username": "fantazer",
                        "content": " 22 / 38 testcases passed\\nTime Limit Exceeded\\n\\n`int maxDepth(struct Node* root) {\\n\\n    if (!root) return 0;\\n    int max = 0;\\n    for (int i = 0; i<root->numChildren; i++){\\n        if (maxDepth(root->children[i]) > max) max = maxDepth(root->children[i]);\\n    }\\n    return 1+max;\\n\\n}`\\n\\nIs this code logically correct, but too unefficient? If so, how can I optimize it? "
                    },
                    {
                        "username": "ribhav_32",
                        "content": "for (int i = 0; i<root->children.size(); i++){\n            mx = max(mx,maxDepth(root->children[i]));\n        }\nreturn 1+mx;\n\njust modify your code as shown above \nbecause you are recursively checking same thing many times by using if condition."
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "[@fantazer](/fantazer) It seems like it\\'s the way your code is written. You are recursively checking the max depth of EVERY NODE first and then using the if condition to set the max variable which is AGAIN recursively searching EVERY NODE. \\n\\nIn essence that is very redundant which I think is what\\'s causing your code to exceed the time limit. You can instead try this\\n- Search the node\\'s children\\n- Add the depth of the children to a list\\n- Return the max value of the depths of the children\\n\\nImplement the above recursively and it should work."
                    },
                    {
                        "username": "fantazer",
                        "content": "[@drvnprgrmr](/drvnprgrmr) the failed testcase is long af, so I am assuming that everything is ok, just too slow. (Time Limit Exceeded, 22 / 38 testcases passed)\n\n[4,null,9,null,2,null,0,null,7,null,6,null,4,null,7,null,7,null,7,null,1,null,4,null,0,null,7,null,3,null,1,null,9,null,9,null,3,null,1,null,8,null,5,null,7,null,0,null,5,null,0,null,3,null,9,null,8,null,9,null,7,null,7,null,1,null,5,null,6,null,5,null,6,null,7,null,2,null,1,null,9,null,10,null,9,null,3,null,3,null,1,null,10,null,0,null,10,null,10,null,7,null,9,null,10,null,1,null,7,null,9,null,10,null,10,null,0,null,9,null,8,null,6,null,10,null,3,null,1,null,6,null,0,null,9,null,9,null,2,null,7,null,7,null,5,null,8,null,2,null,6,null,6,null,2,null,3,null,5,null,2,null,2,null,3,null,3,null,9,null,10,null,6,null,1,null,2,null,7,null,4,null,4,null,5,null,3,null,9,null,4,null,0,null,0,null,1,null,3,null,4,null,2,null,0,null,3,null,4,null,8,null,7,null,10,null,4,null,1,null,5,null,6,null,8,null,5,null,8,null,5,null,7,null,6,null,5,null,8,null,10,null,8,null,3,null,4,null,4,null,6,null,8,null,8,null,0,null,9,null,3,null,4,null,4,null,6,null,9,null,2,null,0,null,8,null,3,null,7,null,5,null,10,null,3,null,8,null,4,null,8,null,5,null,5,null,2,null,5,null,7,null,9,null,7,null,3,null,3,null,6,null,1,null,3,null,4,null,5,null,3,null,7,null,7,null,7,null,5,null,6,null,9,null,6,null,3,null,8,null,9,null,5,null,7,null,9,null,4,null,8,null,6,null,7,null,10,null,0,null,4,null,10,null,1,null,8,null,9,null,8,null,8,null,8,null,9,null,1,null,8,null,4,null,6,null,1,null,0,null,7,null,1,null,2,null,5,null,8,null,6,null,6,null,8,null,9,null,8,null,5,null,9,null,8,null,6,null,6,null,1,null,8,null,1,null,2,null,6,null,5,null,5,null,4,null,8,null,9,null,3,null,8,null,9,null,0,null,4,null,0,null,9,null,5,null,7,null,3,null,9,null,2,null,2,null,0,null,8,null,0,null,5,null,3,null,7,null,4,null,1,null,4,null,5,null,3,null,9,null,7,null,10,null,7,null,9,null,5,null,5,null,10,null,6,null,2,null,10,null,4,null,10,null,1,null,7,null,8,null,6,null,1,null,2,null,0,null,7,null,6,null,2,null,1,null,2,null,5,null,10,null,1,null,1,null,2,null,2,null,8,null,8,null,0,null,9,null,9,null,1,null,6,null,1,null,2,null,9,null,2,null,2,null,10,null,2,null,2,null,7,null,10,null,9,null,6,null,8,null,3,null,8,null,3,null,9,null,0,null,2,null,2,null,4,null,8,null,10,null,1,null,3,null,2,null,2,null,5,null,8,null,0,null,6,null,2,null,7,null,2,null,9,null,10,null,7,null,7,null,6,null,9,null,0,null,7,null,9,null,7,null,4,null,9,null,10,null,3,null,5,null,10,null,9,null,5,null,0,null,6,null,7,null,9,null,10,null,4,null,8,null,9,null,3,null,0,null,2,null,6,null,3,null,9,null,4,null,10,null,4,null,7,null,10,null,7,null,9,null,6,null,9,null,1,null,6,null,2,null,8,null,2,null,0,null,7]"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I don\\'t know the language this is written in but it seems to me that you\\'re logic is correct. \\nWhat was the test case that failed? Maybe try examining it and walking through your algorithm step by step to see where it went wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 2000778,
                "content": [
                    {
                        "username": "Kurtz",
                        "content": "From the description, we don\\'t know if a node has no children, will it be ``self.children == []``, or ``self.children == None``. It will be ideal to add a line indicating that ``self.children = []`` if the node has no children."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "DFS using stack, Detailed Explanation\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3866117/dfs-using-stack-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`BFS` iterative approach, Beats 100% Runtime\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865955/bfs-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Explore the tree\\'s `branches` and `sub-branches`, recursively finding the deepest path possible, and returns the maximum number of levels in the tree, giving us its height!!! Simple!\\n\\n`Here is Recursive Implementation` $$O(N)$$, with Detailed Explanation:\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865642/recursive-sollution-o-n-detailed-explanation/"
                    },
                    {
                        "username": "edsaunders92",
                        "content": "Type hint poor in Python3. Optional would be clearer"
                    },
                    {
                        "username": "fantazer",
                        "content": " 22 / 38 testcases passed\\nTime Limit Exceeded\\n\\n`int maxDepth(struct Node* root) {\\n\\n    if (!root) return 0;\\n    int max = 0;\\n    for (int i = 0; i<root->numChildren; i++){\\n        if (maxDepth(root->children[i]) > max) max = maxDepth(root->children[i]);\\n    }\\n    return 1+max;\\n\\n}`\\n\\nIs this code logically correct, but too unefficient? If so, how can I optimize it? "
                    },
                    {
                        "username": "ribhav_32",
                        "content": "for (int i = 0; i<root->children.size(); i++){\n            mx = max(mx,maxDepth(root->children[i]));\n        }\nreturn 1+mx;\n\njust modify your code as shown above \nbecause you are recursively checking same thing many times by using if condition."
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "[@fantazer](/fantazer) It seems like it\\'s the way your code is written. You are recursively checking the max depth of EVERY NODE first and then using the if condition to set the max variable which is AGAIN recursively searching EVERY NODE. \\n\\nIn essence that is very redundant which I think is what\\'s causing your code to exceed the time limit. You can instead try this\\n- Search the node\\'s children\\n- Add the depth of the children to a list\\n- Return the max value of the depths of the children\\n\\nImplement the above recursively and it should work."
                    },
                    {
                        "username": "fantazer",
                        "content": "[@drvnprgrmr](/drvnprgrmr) the failed testcase is long af, so I am assuming that everything is ok, just too slow. (Time Limit Exceeded, 22 / 38 testcases passed)\n\n[4,null,9,null,2,null,0,null,7,null,6,null,4,null,7,null,7,null,7,null,1,null,4,null,0,null,7,null,3,null,1,null,9,null,9,null,3,null,1,null,8,null,5,null,7,null,0,null,5,null,0,null,3,null,9,null,8,null,9,null,7,null,7,null,1,null,5,null,6,null,5,null,6,null,7,null,2,null,1,null,9,null,10,null,9,null,3,null,3,null,1,null,10,null,0,null,10,null,10,null,7,null,9,null,10,null,1,null,7,null,9,null,10,null,10,null,0,null,9,null,8,null,6,null,10,null,3,null,1,null,6,null,0,null,9,null,9,null,2,null,7,null,7,null,5,null,8,null,2,null,6,null,6,null,2,null,3,null,5,null,2,null,2,null,3,null,3,null,9,null,10,null,6,null,1,null,2,null,7,null,4,null,4,null,5,null,3,null,9,null,4,null,0,null,0,null,1,null,3,null,4,null,2,null,0,null,3,null,4,null,8,null,7,null,10,null,4,null,1,null,5,null,6,null,8,null,5,null,8,null,5,null,7,null,6,null,5,null,8,null,10,null,8,null,3,null,4,null,4,null,6,null,8,null,8,null,0,null,9,null,3,null,4,null,4,null,6,null,9,null,2,null,0,null,8,null,3,null,7,null,5,null,10,null,3,null,8,null,4,null,8,null,5,null,5,null,2,null,5,null,7,null,9,null,7,null,3,null,3,null,6,null,1,null,3,null,4,null,5,null,3,null,7,null,7,null,7,null,5,null,6,null,9,null,6,null,3,null,8,null,9,null,5,null,7,null,9,null,4,null,8,null,6,null,7,null,10,null,0,null,4,null,10,null,1,null,8,null,9,null,8,null,8,null,8,null,9,null,1,null,8,null,4,null,6,null,1,null,0,null,7,null,1,null,2,null,5,null,8,null,6,null,6,null,8,null,9,null,8,null,5,null,9,null,8,null,6,null,6,null,1,null,8,null,1,null,2,null,6,null,5,null,5,null,4,null,8,null,9,null,3,null,8,null,9,null,0,null,4,null,0,null,9,null,5,null,7,null,3,null,9,null,2,null,2,null,0,null,8,null,0,null,5,null,3,null,7,null,4,null,1,null,4,null,5,null,3,null,9,null,7,null,10,null,7,null,9,null,5,null,5,null,10,null,6,null,2,null,10,null,4,null,10,null,1,null,7,null,8,null,6,null,1,null,2,null,0,null,7,null,6,null,2,null,1,null,2,null,5,null,10,null,1,null,1,null,2,null,2,null,8,null,8,null,0,null,9,null,9,null,1,null,6,null,1,null,2,null,9,null,2,null,2,null,10,null,2,null,2,null,7,null,10,null,9,null,6,null,8,null,3,null,8,null,3,null,9,null,0,null,2,null,2,null,4,null,8,null,10,null,1,null,3,null,2,null,2,null,5,null,8,null,0,null,6,null,2,null,7,null,2,null,9,null,10,null,7,null,7,null,6,null,9,null,0,null,7,null,9,null,7,null,4,null,9,null,10,null,3,null,5,null,10,null,9,null,5,null,0,null,6,null,7,null,9,null,10,null,4,null,8,null,9,null,3,null,0,null,2,null,6,null,3,null,9,null,4,null,10,null,4,null,7,null,10,null,7,null,9,null,6,null,9,null,1,null,6,null,2,null,8,null,2,null,0,null,7]"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I don\\'t know the language this is written in but it seems to me that you\\'re logic is correct. \\nWhat was the test case that failed? Maybe try examining it and walking through your algorithm step by step to see where it went wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 2000735,
                "content": [
                    {
                        "username": "Kurtz",
                        "content": "From the description, we don\\'t know if a node has no children, will it be ``self.children == []``, or ``self.children == None``. It will be ideal to add a line indicating that ``self.children = []`` if the node has no children."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "DFS using stack, Detailed Explanation\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3866117/dfs-using-stack-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`BFS` iterative approach, Beats 100% Runtime\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865955/bfs-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Explore the tree\\'s `branches` and `sub-branches`, recursively finding the deepest path possible, and returns the maximum number of levels in the tree, giving us its height!!! Simple!\\n\\n`Here is Recursive Implementation` $$O(N)$$, with Detailed Explanation:\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865642/recursive-sollution-o-n-detailed-explanation/"
                    },
                    {
                        "username": "edsaunders92",
                        "content": "Type hint poor in Python3. Optional would be clearer"
                    },
                    {
                        "username": "fantazer",
                        "content": " 22 / 38 testcases passed\\nTime Limit Exceeded\\n\\n`int maxDepth(struct Node* root) {\\n\\n    if (!root) return 0;\\n    int max = 0;\\n    for (int i = 0; i<root->numChildren; i++){\\n        if (maxDepth(root->children[i]) > max) max = maxDepth(root->children[i]);\\n    }\\n    return 1+max;\\n\\n}`\\n\\nIs this code logically correct, but too unefficient? If so, how can I optimize it? "
                    },
                    {
                        "username": "ribhav_32",
                        "content": "for (int i = 0; i<root->children.size(); i++){\n            mx = max(mx,maxDepth(root->children[i]));\n        }\nreturn 1+mx;\n\njust modify your code as shown above \nbecause you are recursively checking same thing many times by using if condition."
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "[@fantazer](/fantazer) It seems like it\\'s the way your code is written. You are recursively checking the max depth of EVERY NODE first and then using the if condition to set the max variable which is AGAIN recursively searching EVERY NODE. \\n\\nIn essence that is very redundant which I think is what\\'s causing your code to exceed the time limit. You can instead try this\\n- Search the node\\'s children\\n- Add the depth of the children to a list\\n- Return the max value of the depths of the children\\n\\nImplement the above recursively and it should work."
                    },
                    {
                        "username": "fantazer",
                        "content": "[@drvnprgrmr](/drvnprgrmr) the failed testcase is long af, so I am assuming that everything is ok, just too slow. (Time Limit Exceeded, 22 / 38 testcases passed)\n\n[4,null,9,null,2,null,0,null,7,null,6,null,4,null,7,null,7,null,7,null,1,null,4,null,0,null,7,null,3,null,1,null,9,null,9,null,3,null,1,null,8,null,5,null,7,null,0,null,5,null,0,null,3,null,9,null,8,null,9,null,7,null,7,null,1,null,5,null,6,null,5,null,6,null,7,null,2,null,1,null,9,null,10,null,9,null,3,null,3,null,1,null,10,null,0,null,10,null,10,null,7,null,9,null,10,null,1,null,7,null,9,null,10,null,10,null,0,null,9,null,8,null,6,null,10,null,3,null,1,null,6,null,0,null,9,null,9,null,2,null,7,null,7,null,5,null,8,null,2,null,6,null,6,null,2,null,3,null,5,null,2,null,2,null,3,null,3,null,9,null,10,null,6,null,1,null,2,null,7,null,4,null,4,null,5,null,3,null,9,null,4,null,0,null,0,null,1,null,3,null,4,null,2,null,0,null,3,null,4,null,8,null,7,null,10,null,4,null,1,null,5,null,6,null,8,null,5,null,8,null,5,null,7,null,6,null,5,null,8,null,10,null,8,null,3,null,4,null,4,null,6,null,8,null,8,null,0,null,9,null,3,null,4,null,4,null,6,null,9,null,2,null,0,null,8,null,3,null,7,null,5,null,10,null,3,null,8,null,4,null,8,null,5,null,5,null,2,null,5,null,7,null,9,null,7,null,3,null,3,null,6,null,1,null,3,null,4,null,5,null,3,null,7,null,7,null,7,null,5,null,6,null,9,null,6,null,3,null,8,null,9,null,5,null,7,null,9,null,4,null,8,null,6,null,7,null,10,null,0,null,4,null,10,null,1,null,8,null,9,null,8,null,8,null,8,null,9,null,1,null,8,null,4,null,6,null,1,null,0,null,7,null,1,null,2,null,5,null,8,null,6,null,6,null,8,null,9,null,8,null,5,null,9,null,8,null,6,null,6,null,1,null,8,null,1,null,2,null,6,null,5,null,5,null,4,null,8,null,9,null,3,null,8,null,9,null,0,null,4,null,0,null,9,null,5,null,7,null,3,null,9,null,2,null,2,null,0,null,8,null,0,null,5,null,3,null,7,null,4,null,1,null,4,null,5,null,3,null,9,null,7,null,10,null,7,null,9,null,5,null,5,null,10,null,6,null,2,null,10,null,4,null,10,null,1,null,7,null,8,null,6,null,1,null,2,null,0,null,7,null,6,null,2,null,1,null,2,null,5,null,10,null,1,null,1,null,2,null,2,null,8,null,8,null,0,null,9,null,9,null,1,null,6,null,1,null,2,null,9,null,2,null,2,null,10,null,2,null,2,null,7,null,10,null,9,null,6,null,8,null,3,null,8,null,3,null,9,null,0,null,2,null,2,null,4,null,8,null,10,null,1,null,3,null,2,null,2,null,5,null,8,null,0,null,6,null,2,null,7,null,2,null,9,null,10,null,7,null,7,null,6,null,9,null,0,null,7,null,9,null,7,null,4,null,9,null,10,null,3,null,5,null,10,null,9,null,5,null,0,null,6,null,7,null,9,null,10,null,4,null,8,null,9,null,3,null,0,null,2,null,6,null,3,null,9,null,4,null,10,null,4,null,7,null,10,null,7,null,9,null,6,null,9,null,1,null,6,null,2,null,8,null,2,null,0,null,7]"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I don\\'t know the language this is written in but it seems to me that you\\'re logic is correct. \\nWhat was the test case that failed? Maybe try examining it and walking through your algorithm step by step to see where it went wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 2000651,
                "content": [
                    {
                        "username": "Kurtz",
                        "content": "From the description, we don\\'t know if a node has no children, will it be ``self.children == []``, or ``self.children == None``. It will be ideal to add a line indicating that ``self.children = []`` if the node has no children."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "DFS using stack, Detailed Explanation\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3866117/dfs-using-stack-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`BFS` iterative approach, Beats 100% Runtime\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865955/bfs-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Explore the tree\\'s `branches` and `sub-branches`, recursively finding the deepest path possible, and returns the maximum number of levels in the tree, giving us its height!!! Simple!\\n\\n`Here is Recursive Implementation` $$O(N)$$, with Detailed Explanation:\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865642/recursive-sollution-o-n-detailed-explanation/"
                    },
                    {
                        "username": "edsaunders92",
                        "content": "Type hint poor in Python3. Optional would be clearer"
                    },
                    {
                        "username": "fantazer",
                        "content": " 22 / 38 testcases passed\\nTime Limit Exceeded\\n\\n`int maxDepth(struct Node* root) {\\n\\n    if (!root) return 0;\\n    int max = 0;\\n    for (int i = 0; i<root->numChildren; i++){\\n        if (maxDepth(root->children[i]) > max) max = maxDepth(root->children[i]);\\n    }\\n    return 1+max;\\n\\n}`\\n\\nIs this code logically correct, but too unefficient? If so, how can I optimize it? "
                    },
                    {
                        "username": "ribhav_32",
                        "content": "for (int i = 0; i<root->children.size(); i++){\n            mx = max(mx,maxDepth(root->children[i]));\n        }\nreturn 1+mx;\n\njust modify your code as shown above \nbecause you are recursively checking same thing many times by using if condition."
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "[@fantazer](/fantazer) It seems like it\\'s the way your code is written. You are recursively checking the max depth of EVERY NODE first and then using the if condition to set the max variable which is AGAIN recursively searching EVERY NODE. \\n\\nIn essence that is very redundant which I think is what\\'s causing your code to exceed the time limit. You can instead try this\\n- Search the node\\'s children\\n- Add the depth of the children to a list\\n- Return the max value of the depths of the children\\n\\nImplement the above recursively and it should work."
                    },
                    {
                        "username": "fantazer",
                        "content": "[@drvnprgrmr](/drvnprgrmr) the failed testcase is long af, so I am assuming that everything is ok, just too slow. (Time Limit Exceeded, 22 / 38 testcases passed)\n\n[4,null,9,null,2,null,0,null,7,null,6,null,4,null,7,null,7,null,7,null,1,null,4,null,0,null,7,null,3,null,1,null,9,null,9,null,3,null,1,null,8,null,5,null,7,null,0,null,5,null,0,null,3,null,9,null,8,null,9,null,7,null,7,null,1,null,5,null,6,null,5,null,6,null,7,null,2,null,1,null,9,null,10,null,9,null,3,null,3,null,1,null,10,null,0,null,10,null,10,null,7,null,9,null,10,null,1,null,7,null,9,null,10,null,10,null,0,null,9,null,8,null,6,null,10,null,3,null,1,null,6,null,0,null,9,null,9,null,2,null,7,null,7,null,5,null,8,null,2,null,6,null,6,null,2,null,3,null,5,null,2,null,2,null,3,null,3,null,9,null,10,null,6,null,1,null,2,null,7,null,4,null,4,null,5,null,3,null,9,null,4,null,0,null,0,null,1,null,3,null,4,null,2,null,0,null,3,null,4,null,8,null,7,null,10,null,4,null,1,null,5,null,6,null,8,null,5,null,8,null,5,null,7,null,6,null,5,null,8,null,10,null,8,null,3,null,4,null,4,null,6,null,8,null,8,null,0,null,9,null,3,null,4,null,4,null,6,null,9,null,2,null,0,null,8,null,3,null,7,null,5,null,10,null,3,null,8,null,4,null,8,null,5,null,5,null,2,null,5,null,7,null,9,null,7,null,3,null,3,null,6,null,1,null,3,null,4,null,5,null,3,null,7,null,7,null,7,null,5,null,6,null,9,null,6,null,3,null,8,null,9,null,5,null,7,null,9,null,4,null,8,null,6,null,7,null,10,null,0,null,4,null,10,null,1,null,8,null,9,null,8,null,8,null,8,null,9,null,1,null,8,null,4,null,6,null,1,null,0,null,7,null,1,null,2,null,5,null,8,null,6,null,6,null,8,null,9,null,8,null,5,null,9,null,8,null,6,null,6,null,1,null,8,null,1,null,2,null,6,null,5,null,5,null,4,null,8,null,9,null,3,null,8,null,9,null,0,null,4,null,0,null,9,null,5,null,7,null,3,null,9,null,2,null,2,null,0,null,8,null,0,null,5,null,3,null,7,null,4,null,1,null,4,null,5,null,3,null,9,null,7,null,10,null,7,null,9,null,5,null,5,null,10,null,6,null,2,null,10,null,4,null,10,null,1,null,7,null,8,null,6,null,1,null,2,null,0,null,7,null,6,null,2,null,1,null,2,null,5,null,10,null,1,null,1,null,2,null,2,null,8,null,8,null,0,null,9,null,9,null,1,null,6,null,1,null,2,null,9,null,2,null,2,null,10,null,2,null,2,null,7,null,10,null,9,null,6,null,8,null,3,null,8,null,3,null,9,null,0,null,2,null,2,null,4,null,8,null,10,null,1,null,3,null,2,null,2,null,5,null,8,null,0,null,6,null,2,null,7,null,2,null,9,null,10,null,7,null,7,null,6,null,9,null,0,null,7,null,9,null,7,null,4,null,9,null,10,null,3,null,5,null,10,null,9,null,5,null,0,null,6,null,7,null,9,null,10,null,4,null,8,null,9,null,3,null,0,null,2,null,6,null,3,null,9,null,4,null,10,null,4,null,7,null,10,null,7,null,9,null,6,null,9,null,1,null,6,null,2,null,8,null,2,null,0,null,7]"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I don\\'t know the language this is written in but it seems to me that you\\'re logic is correct. \\nWhat was the test case that failed? Maybe try examining it and walking through your algorithm step by step to see where it went wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1960095,
                "content": [
                    {
                        "username": "Kurtz",
                        "content": "From the description, we don\\'t know if a node has no children, will it be ``self.children == []``, or ``self.children == None``. It will be ideal to add a line indicating that ``self.children = []`` if the node has no children."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "DFS using stack, Detailed Explanation\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3866117/dfs-using-stack-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`BFS` iterative approach, Beats 100% Runtime\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865955/bfs-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Explore the tree\\'s `branches` and `sub-branches`, recursively finding the deepest path possible, and returns the maximum number of levels in the tree, giving us its height!!! Simple!\\n\\n`Here is Recursive Implementation` $$O(N)$$, with Detailed Explanation:\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865642/recursive-sollution-o-n-detailed-explanation/"
                    },
                    {
                        "username": "edsaunders92",
                        "content": "Type hint poor in Python3. Optional would be clearer"
                    },
                    {
                        "username": "fantazer",
                        "content": " 22 / 38 testcases passed\\nTime Limit Exceeded\\n\\n`int maxDepth(struct Node* root) {\\n\\n    if (!root) return 0;\\n    int max = 0;\\n    for (int i = 0; i<root->numChildren; i++){\\n        if (maxDepth(root->children[i]) > max) max = maxDepth(root->children[i]);\\n    }\\n    return 1+max;\\n\\n}`\\n\\nIs this code logically correct, but too unefficient? If so, how can I optimize it? "
                    },
                    {
                        "username": "ribhav_32",
                        "content": "for (int i = 0; i<root->children.size(); i++){\n            mx = max(mx,maxDepth(root->children[i]));\n        }\nreturn 1+mx;\n\njust modify your code as shown above \nbecause you are recursively checking same thing many times by using if condition."
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "[@fantazer](/fantazer) It seems like it\\'s the way your code is written. You are recursively checking the max depth of EVERY NODE first and then using the if condition to set the max variable which is AGAIN recursively searching EVERY NODE. \\n\\nIn essence that is very redundant which I think is what\\'s causing your code to exceed the time limit. You can instead try this\\n- Search the node\\'s children\\n- Add the depth of the children to a list\\n- Return the max value of the depths of the children\\n\\nImplement the above recursively and it should work."
                    },
                    {
                        "username": "fantazer",
                        "content": "[@drvnprgrmr](/drvnprgrmr) the failed testcase is long af, so I am assuming that everything is ok, just too slow. (Time Limit Exceeded, 22 / 38 testcases passed)\n\n[4,null,9,null,2,null,0,null,7,null,6,null,4,null,7,null,7,null,7,null,1,null,4,null,0,null,7,null,3,null,1,null,9,null,9,null,3,null,1,null,8,null,5,null,7,null,0,null,5,null,0,null,3,null,9,null,8,null,9,null,7,null,7,null,1,null,5,null,6,null,5,null,6,null,7,null,2,null,1,null,9,null,10,null,9,null,3,null,3,null,1,null,10,null,0,null,10,null,10,null,7,null,9,null,10,null,1,null,7,null,9,null,10,null,10,null,0,null,9,null,8,null,6,null,10,null,3,null,1,null,6,null,0,null,9,null,9,null,2,null,7,null,7,null,5,null,8,null,2,null,6,null,6,null,2,null,3,null,5,null,2,null,2,null,3,null,3,null,9,null,10,null,6,null,1,null,2,null,7,null,4,null,4,null,5,null,3,null,9,null,4,null,0,null,0,null,1,null,3,null,4,null,2,null,0,null,3,null,4,null,8,null,7,null,10,null,4,null,1,null,5,null,6,null,8,null,5,null,8,null,5,null,7,null,6,null,5,null,8,null,10,null,8,null,3,null,4,null,4,null,6,null,8,null,8,null,0,null,9,null,3,null,4,null,4,null,6,null,9,null,2,null,0,null,8,null,3,null,7,null,5,null,10,null,3,null,8,null,4,null,8,null,5,null,5,null,2,null,5,null,7,null,9,null,7,null,3,null,3,null,6,null,1,null,3,null,4,null,5,null,3,null,7,null,7,null,7,null,5,null,6,null,9,null,6,null,3,null,8,null,9,null,5,null,7,null,9,null,4,null,8,null,6,null,7,null,10,null,0,null,4,null,10,null,1,null,8,null,9,null,8,null,8,null,8,null,9,null,1,null,8,null,4,null,6,null,1,null,0,null,7,null,1,null,2,null,5,null,8,null,6,null,6,null,8,null,9,null,8,null,5,null,9,null,8,null,6,null,6,null,1,null,8,null,1,null,2,null,6,null,5,null,5,null,4,null,8,null,9,null,3,null,8,null,9,null,0,null,4,null,0,null,9,null,5,null,7,null,3,null,9,null,2,null,2,null,0,null,8,null,0,null,5,null,3,null,7,null,4,null,1,null,4,null,5,null,3,null,9,null,7,null,10,null,7,null,9,null,5,null,5,null,10,null,6,null,2,null,10,null,4,null,10,null,1,null,7,null,8,null,6,null,1,null,2,null,0,null,7,null,6,null,2,null,1,null,2,null,5,null,10,null,1,null,1,null,2,null,2,null,8,null,8,null,0,null,9,null,9,null,1,null,6,null,1,null,2,null,9,null,2,null,2,null,10,null,2,null,2,null,7,null,10,null,9,null,6,null,8,null,3,null,8,null,3,null,9,null,0,null,2,null,2,null,4,null,8,null,10,null,1,null,3,null,2,null,2,null,5,null,8,null,0,null,6,null,2,null,7,null,2,null,9,null,10,null,7,null,7,null,6,null,9,null,0,null,7,null,9,null,7,null,4,null,9,null,10,null,3,null,5,null,10,null,9,null,5,null,0,null,6,null,7,null,9,null,10,null,4,null,8,null,9,null,3,null,0,null,2,null,6,null,3,null,9,null,4,null,10,null,4,null,7,null,10,null,7,null,9,null,6,null,9,null,1,null,6,null,2,null,8,null,2,null,0,null,7]"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I don\\'t know the language this is written in but it seems to me that you\\'re logic is correct. \\nWhat was the test case that failed? Maybe try examining it and walking through your algorithm step by step to see where it went wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1739636,
                "content": [
                    {
                        "username": "Kurtz",
                        "content": "From the description, we don\\'t know if a node has no children, will it be ``self.children == []``, or ``self.children == None``. It will be ideal to add a line indicating that ``self.children = []`` if the node has no children."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "DFS using stack, Detailed Explanation\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3866117/dfs-using-stack-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`BFS` iterative approach, Beats 100% Runtime\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865955/bfs-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Explore the tree\\'s `branches` and `sub-branches`, recursively finding the deepest path possible, and returns the maximum number of levels in the tree, giving us its height!!! Simple!\\n\\n`Here is Recursive Implementation` $$O(N)$$, with Detailed Explanation:\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865642/recursive-sollution-o-n-detailed-explanation/"
                    },
                    {
                        "username": "edsaunders92",
                        "content": "Type hint poor in Python3. Optional would be clearer"
                    },
                    {
                        "username": "fantazer",
                        "content": " 22 / 38 testcases passed\\nTime Limit Exceeded\\n\\n`int maxDepth(struct Node* root) {\\n\\n    if (!root) return 0;\\n    int max = 0;\\n    for (int i = 0; i<root->numChildren; i++){\\n        if (maxDepth(root->children[i]) > max) max = maxDepth(root->children[i]);\\n    }\\n    return 1+max;\\n\\n}`\\n\\nIs this code logically correct, but too unefficient? If so, how can I optimize it? "
                    },
                    {
                        "username": "ribhav_32",
                        "content": "for (int i = 0; i<root->children.size(); i++){\n            mx = max(mx,maxDepth(root->children[i]));\n        }\nreturn 1+mx;\n\njust modify your code as shown above \nbecause you are recursively checking same thing many times by using if condition."
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "[@fantazer](/fantazer) It seems like it\\'s the way your code is written. You are recursively checking the max depth of EVERY NODE first and then using the if condition to set the max variable which is AGAIN recursively searching EVERY NODE. \\n\\nIn essence that is very redundant which I think is what\\'s causing your code to exceed the time limit. You can instead try this\\n- Search the node\\'s children\\n- Add the depth of the children to a list\\n- Return the max value of the depths of the children\\n\\nImplement the above recursively and it should work."
                    },
                    {
                        "username": "fantazer",
                        "content": "[@drvnprgrmr](/drvnprgrmr) the failed testcase is long af, so I am assuming that everything is ok, just too slow. (Time Limit Exceeded, 22 / 38 testcases passed)\n\n[4,null,9,null,2,null,0,null,7,null,6,null,4,null,7,null,7,null,7,null,1,null,4,null,0,null,7,null,3,null,1,null,9,null,9,null,3,null,1,null,8,null,5,null,7,null,0,null,5,null,0,null,3,null,9,null,8,null,9,null,7,null,7,null,1,null,5,null,6,null,5,null,6,null,7,null,2,null,1,null,9,null,10,null,9,null,3,null,3,null,1,null,10,null,0,null,10,null,10,null,7,null,9,null,10,null,1,null,7,null,9,null,10,null,10,null,0,null,9,null,8,null,6,null,10,null,3,null,1,null,6,null,0,null,9,null,9,null,2,null,7,null,7,null,5,null,8,null,2,null,6,null,6,null,2,null,3,null,5,null,2,null,2,null,3,null,3,null,9,null,10,null,6,null,1,null,2,null,7,null,4,null,4,null,5,null,3,null,9,null,4,null,0,null,0,null,1,null,3,null,4,null,2,null,0,null,3,null,4,null,8,null,7,null,10,null,4,null,1,null,5,null,6,null,8,null,5,null,8,null,5,null,7,null,6,null,5,null,8,null,10,null,8,null,3,null,4,null,4,null,6,null,8,null,8,null,0,null,9,null,3,null,4,null,4,null,6,null,9,null,2,null,0,null,8,null,3,null,7,null,5,null,10,null,3,null,8,null,4,null,8,null,5,null,5,null,2,null,5,null,7,null,9,null,7,null,3,null,3,null,6,null,1,null,3,null,4,null,5,null,3,null,7,null,7,null,7,null,5,null,6,null,9,null,6,null,3,null,8,null,9,null,5,null,7,null,9,null,4,null,8,null,6,null,7,null,10,null,0,null,4,null,10,null,1,null,8,null,9,null,8,null,8,null,8,null,9,null,1,null,8,null,4,null,6,null,1,null,0,null,7,null,1,null,2,null,5,null,8,null,6,null,6,null,8,null,9,null,8,null,5,null,9,null,8,null,6,null,6,null,1,null,8,null,1,null,2,null,6,null,5,null,5,null,4,null,8,null,9,null,3,null,8,null,9,null,0,null,4,null,0,null,9,null,5,null,7,null,3,null,9,null,2,null,2,null,0,null,8,null,0,null,5,null,3,null,7,null,4,null,1,null,4,null,5,null,3,null,9,null,7,null,10,null,7,null,9,null,5,null,5,null,10,null,6,null,2,null,10,null,4,null,10,null,1,null,7,null,8,null,6,null,1,null,2,null,0,null,7,null,6,null,2,null,1,null,2,null,5,null,10,null,1,null,1,null,2,null,2,null,8,null,8,null,0,null,9,null,9,null,1,null,6,null,1,null,2,null,9,null,2,null,2,null,10,null,2,null,2,null,7,null,10,null,9,null,6,null,8,null,3,null,8,null,3,null,9,null,0,null,2,null,2,null,4,null,8,null,10,null,1,null,3,null,2,null,2,null,5,null,8,null,0,null,6,null,2,null,7,null,2,null,9,null,10,null,7,null,7,null,6,null,9,null,0,null,7,null,9,null,7,null,4,null,9,null,10,null,3,null,5,null,10,null,9,null,5,null,0,null,6,null,7,null,9,null,10,null,4,null,8,null,9,null,3,null,0,null,2,null,6,null,3,null,9,null,4,null,10,null,4,null,7,null,10,null,7,null,9,null,6,null,9,null,1,null,6,null,2,null,8,null,2,null,0,null,7]"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I don\\'t know the language this is written in but it seems to me that you\\'re logic is correct. \\nWhat was the test case that failed? Maybe try examining it and walking through your algorithm step by step to see where it went wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1728235,
                "content": [
                    {
                        "username": "Kurtz",
                        "content": "From the description, we don\\'t know if a node has no children, will it be ``self.children == []``, or ``self.children == None``. It will be ideal to add a line indicating that ``self.children = []`` if the node has no children."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "DFS using stack, Detailed Explanation\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3866117/dfs-using-stack-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`BFS` iterative approach, Beats 100% Runtime\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865955/bfs-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Explore the tree\\'s `branches` and `sub-branches`, recursively finding the deepest path possible, and returns the maximum number of levels in the tree, giving us its height!!! Simple!\\n\\n`Here is Recursive Implementation` $$O(N)$$, with Detailed Explanation:\\nhttps://leetcode.com/problems/maximum-depth-of-n-ary-tree/solutions/3865642/recursive-sollution-o-n-detailed-explanation/"
                    },
                    {
                        "username": "edsaunders92",
                        "content": "Type hint poor in Python3. Optional would be clearer"
                    },
                    {
                        "username": "fantazer",
                        "content": " 22 / 38 testcases passed\\nTime Limit Exceeded\\n\\n`int maxDepth(struct Node* root) {\\n\\n    if (!root) return 0;\\n    int max = 0;\\n    for (int i = 0; i<root->numChildren; i++){\\n        if (maxDepth(root->children[i]) > max) max = maxDepth(root->children[i]);\\n    }\\n    return 1+max;\\n\\n}`\\n\\nIs this code logically correct, but too unefficient? If so, how can I optimize it? "
                    },
                    {
                        "username": "ribhav_32",
                        "content": "for (int i = 0; i<root->children.size(); i++){\n            mx = max(mx,maxDepth(root->children[i]));\n        }\nreturn 1+mx;\n\njust modify your code as shown above \nbecause you are recursively checking same thing many times by using if condition."
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "[@fantazer](/fantazer) It seems like it\\'s the way your code is written. You are recursively checking the max depth of EVERY NODE first and then using the if condition to set the max variable which is AGAIN recursively searching EVERY NODE. \\n\\nIn essence that is very redundant which I think is what\\'s causing your code to exceed the time limit. You can instead try this\\n- Search the node\\'s children\\n- Add the depth of the children to a list\\n- Return the max value of the depths of the children\\n\\nImplement the above recursively and it should work."
                    },
                    {
                        "username": "fantazer",
                        "content": "[@drvnprgrmr](/drvnprgrmr) the failed testcase is long af, so I am assuming that everything is ok, just too slow. (Time Limit Exceeded, 22 / 38 testcases passed)\n\n[4,null,9,null,2,null,0,null,7,null,6,null,4,null,7,null,7,null,7,null,1,null,4,null,0,null,7,null,3,null,1,null,9,null,9,null,3,null,1,null,8,null,5,null,7,null,0,null,5,null,0,null,3,null,9,null,8,null,9,null,7,null,7,null,1,null,5,null,6,null,5,null,6,null,7,null,2,null,1,null,9,null,10,null,9,null,3,null,3,null,1,null,10,null,0,null,10,null,10,null,7,null,9,null,10,null,1,null,7,null,9,null,10,null,10,null,0,null,9,null,8,null,6,null,10,null,3,null,1,null,6,null,0,null,9,null,9,null,2,null,7,null,7,null,5,null,8,null,2,null,6,null,6,null,2,null,3,null,5,null,2,null,2,null,3,null,3,null,9,null,10,null,6,null,1,null,2,null,7,null,4,null,4,null,5,null,3,null,9,null,4,null,0,null,0,null,1,null,3,null,4,null,2,null,0,null,3,null,4,null,8,null,7,null,10,null,4,null,1,null,5,null,6,null,8,null,5,null,8,null,5,null,7,null,6,null,5,null,8,null,10,null,8,null,3,null,4,null,4,null,6,null,8,null,8,null,0,null,9,null,3,null,4,null,4,null,6,null,9,null,2,null,0,null,8,null,3,null,7,null,5,null,10,null,3,null,8,null,4,null,8,null,5,null,5,null,2,null,5,null,7,null,9,null,7,null,3,null,3,null,6,null,1,null,3,null,4,null,5,null,3,null,7,null,7,null,7,null,5,null,6,null,9,null,6,null,3,null,8,null,9,null,5,null,7,null,9,null,4,null,8,null,6,null,7,null,10,null,0,null,4,null,10,null,1,null,8,null,9,null,8,null,8,null,8,null,9,null,1,null,8,null,4,null,6,null,1,null,0,null,7,null,1,null,2,null,5,null,8,null,6,null,6,null,8,null,9,null,8,null,5,null,9,null,8,null,6,null,6,null,1,null,8,null,1,null,2,null,6,null,5,null,5,null,4,null,8,null,9,null,3,null,8,null,9,null,0,null,4,null,0,null,9,null,5,null,7,null,3,null,9,null,2,null,2,null,0,null,8,null,0,null,5,null,3,null,7,null,4,null,1,null,4,null,5,null,3,null,9,null,7,null,10,null,7,null,9,null,5,null,5,null,10,null,6,null,2,null,10,null,4,null,10,null,1,null,7,null,8,null,6,null,1,null,2,null,0,null,7,null,6,null,2,null,1,null,2,null,5,null,10,null,1,null,1,null,2,null,2,null,8,null,8,null,0,null,9,null,9,null,1,null,6,null,1,null,2,null,9,null,2,null,2,null,10,null,2,null,2,null,7,null,10,null,9,null,6,null,8,null,3,null,8,null,3,null,9,null,0,null,2,null,2,null,4,null,8,null,10,null,1,null,3,null,2,null,2,null,5,null,8,null,0,null,6,null,2,null,7,null,2,null,9,null,10,null,7,null,7,null,6,null,9,null,0,null,7,null,9,null,7,null,4,null,9,null,10,null,3,null,5,null,10,null,9,null,5,null,0,null,6,null,7,null,9,null,10,null,4,null,8,null,9,null,3,null,0,null,2,null,6,null,3,null,9,null,4,null,10,null,4,null,7,null,10,null,7,null,9,null,6,null,9,null,1,null,6,null,2,null,8,null,2,null,0,null,7]"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I don\\'t know the language this is written in but it seems to me that you\\'re logic is correct. \\nWhat was the test case that failed? Maybe try examining it and walking through your algorithm step by step to see where it went wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            }
        ]
    }
]