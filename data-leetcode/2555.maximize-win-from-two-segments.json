[
    {
        "title": "Maximize Win From Two Segments",
        "question_content": "There are some prizes on the X-axis. You are given an integer array prizePositions that is sorted in non-decreasing order, where prizePositions[i] is the position of the ith prize. There could be different prizes at the same position on the line. You are also given an integer k.\nYou are allowed to select two segments with integer endpoints. The length of each segment must be k. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect.\n\n\tFor example if k = 2, you can choose segments [1, 3] and [2, 4], and you will win any prize i that satisfies 1 <= prizePositions[i] <= 3 or 2 <= prizePositions[i] <= 4.\n\nReturn the maximum number of prizes you can win if you choose the two segments optimally.\n&nbsp;\nExample 1:\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\nExplanation: In this example, you can win all 7 prizes by selecting two segments [1, 3] and [3, 5].\n\nExample 2:\n\nInput: prizePositions = [1,2,3,4], k = 0\nOutput: 2\nExplanation: For this example, one choice for the segments is [3, 3] and [4, 4], and you will be able to get 2 prizes. \n\n&nbsp;\nConstraints:\n\n\t1 <= prizePositions.length <= 105\n\t1 <= prizePositions[i] <= 109\n\t0 <= k <= 109 \n\tprizePositions is sorted in non-decreasing order.\n\n&nbsp;\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; \n}\n.spoiler {overflow:hidden;}\n.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}\n.spoilerbutton[value=\"Show Message\"] + .spoiler > div {margin-top:-500%;}\n.spoilerbutton[value=\"Hide Message\"] + .spoiler {padding:5px;}",
        "solutions": [
            {
                "id": 3141449,
                "title": "java-c-python-dp-sliding-segment-o-n",
                "content": "# **Intuition**\\nMaximize Win From **One** Segments,\\ncan be solved by sliding window.\\n\\nNow we can slide the second segment,\\nand get calculate the result from `dp`.\\n<br>\\n\\n# **Explanation**\\nMaintain a sliding segment(sliding window),\\nwhere `A[i] - A[j] <= k`.\\n\\n`dp[k]` means the the  maximum number\\nwe can cover if you choose the **one** segments optimally\\nin the first `k` elements.\\n\\nWhen we slide a segment from left to right,\\nthe number of elements that we cover is `i - j + 1`\\nand in the first `j` elements,\\nwe can cover at most `dp[j]` elements,\\nso we can cover `i - j + 1 + dp[j]` in total.\\nUpdate the result `res` and finally return it.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maximizeWin(int[] A, int k) {\\n        int res = 0, n = A.length, j = 0, dp[] = new int[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            while (A[j] < A[i] - k)\\n                ++j;\\n            dp[i + 1] = Math.max(dp[i], i - j + 1);\\n            res = Math.max(res, i - j + 1 + dp[j]);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int maximizeWin(vector<int>& A, int k) {\\n        int res = 0, n = A.size(), j = 0;\\n        vector<int> dp(n + 1, 0);\\n        for (int i = 0; i < n; ++i) {\\n            while (A[j] < A[i] - k)\\n                ++j;\\n            dp[i + 1] = max(dp[i], i - j + 1);\\n            res = max(res, i - j + 1 + dp[j]);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maximizeWin(self, A, k):\\n        dp = [0] * (len(A) + 1)\\n        res = j = 0\\n        for i, a in enumerate(A):\\n            while A[j] < A[i] - k: j += 1\\n            dp[i + 1] = max(dp[i], i - j + 1)\\n            res = max(res, i - j + 1 + dp[j])\\n        return res\\n```\\n<br>\\n\\n# **Follow up**\\nWhat if we want to solve `Maximize Win From K Segments`\\nWe can solve it by this approach as well.\\nSimply increase one linear `dp[i]` to `dp[k][i]`,\\n`dp[k][i]` means the maixmum we can in the first `i` elements with `k` segments.\\n<br>\\n\\n# More Similar Sliding Window Problems\\nHere are some similar sliding window problems.\\nAlso find more explanations and discussion.\\nGood luck and have fun.\\n\\n- 2555. [Maximize Win From Two Segments](https://leetcode.com/problems/maximize-win-from-two-segments/discuss/3141449/JavaC%2B%2BPython-DP-%2B-Sliding-Segment-O(n))\\n- 2537. [Count the Number of Good Subarrays](https://leetcode.com/problems/count-the-number-of-good-subarrays/discuss/3052559/C%2B%2BPython-Sliding-Window)\\n- 2401. [Longest Nice Subarray](https://leetcode.com/problems/longest-nice-subarray/discuss/2527496/Python-Sliding-Window)\\n- 2398. [Maximum Number of Robots Within Budget](https://leetcode.com/problems/maximum-number-of-robots-within-budget/discuss/2524838/Python-Sliding-Window-O(n))\\n- 1838. [Frequency of the Most Frequent Element](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175090/JavaC%2B%2BPython-Sliding-Window)\\n- 1493. [Longest Subarray of 1\\'s After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/discuss/708112/JavaC%2B%2BPython-Sliding-Window-at-most-one-0)\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1358. [Number of Substrings Containing All Three Characters](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/discuss/516977/JavaC++Python-Easy-and-Concise)\\n- 1248. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n- 1234. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/)\\n- 1004. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/JavaC%2B%2BPython-Sliding-Window)\\n-  930. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\\n-  992. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/523136/JavaC%2B%2BPython-Sliding-Window)\\n-  904. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\\n-  862. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\\n-  209. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123/JavaC++Python-Sliding-Window)\\n<br>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int maximizeWin(int[] A, int k) {\\n        int res = 0, n = A.length, j = 0, dp[] = new int[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            while (A[j] < A[i] - k)\\n                ++j;\\n            dp[i + 1] = Math.max(dp[i], i - j + 1);\\n            res = Math.max(res, i - j + 1 + dp[j]);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int maximizeWin(vector<int>& A, int k) {\\n        int res = 0, n = A.size(), j = 0;\\n        vector<int> dp(n + 1, 0);\\n        for (int i = 0; i < n; ++i) {\\n            while (A[j] < A[i] - k)\\n                ++j;\\n            dp[i + 1] = max(dp[i], i - j + 1);\\n            res = max(res, i - j + 1 + dp[j]);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def maximizeWin(self, A, k):\\n        dp = [0] * (len(A) + 1)\\n        res = j = 0\\n        for i, a in enumerate(A):\\n            while A[j] < A[i] - k: j += 1\\n            dp[i + 1] = max(dp[i], i - j + 1)\\n            res = max(res, i - j + 1 + dp[j])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3141497,
                "title": "sliding-window-dp-o-n",
                "content": "# Intuition\\n* what if we were allowed to choose only one segment(sliding window)\\n* what if i save the last  segment with maximum prizes that I can attain from 0<=j<=i(dynamic programming)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* if I am currently at ith position, the maximum prizes I can attain \\n**i-start+1** prizes such that **nums[i]-nums[start]<=k** using sliding window.\\nNote\\n(\\n    nums[i]-nums[start]<=k \\n    takes care of the condition (The length of each segment must be k)\\n    .Even if my length is smaller than k then there is going to be overlapping which is allowed.\\n)\\n\\n* so suppose I can attain **i-start+1** prizes from the ith position , I will try to find the maximum prizes that can be attained in the subarray \\nfrom **0<=i< start**(\\n which can be calculated by dp\\nthat is **dp[i]=max(i-start+1,dp[i-1])**;\\n\\n).\\n# Complexity\\n- Time complexity: amortised O(n)\\n- Space complexity: O(n) (size of array dp)\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int maximizeWin(vector<int> &nums, int k)\\n    {\\n        int n = nums.size(), start = 0, ans = 0;\\n        vector<int> dp(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            while (nums[i] - nums[start] > k)\\n                    start++;\\n            \\n            ans = max(ans, i - start + 1 + (start > 0 ? dp[start - 1] : 0));\\n            dp[i] = max((i > 0 ? dp[i - 1] : 0), i - start + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maximizeWin(vector<int> &nums, int k)\\n    {\\n        int n = nums.size(), start = 0, ans = 0;\\n        vector<int> dp(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            while (nums[i] - nums[start] > k)\\n                    start++;\\n            \\n            ans = max(ans, i - start + 1 + (start > 0 ? dp[start - 1] : 0));\\n            dp[i] = max((i > 0 ? dp[i - 1] : 0), i - start + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141496,
                "title": "dp-binary-search-c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int fn(int ind,vector<int>&arr,int segment,int k) \\n    {\\n        if(segment==0)\\n            return 0;\\n        if(ind>=arr.size())\\n            return 0;\\n        if(dp[ind][segment]!=-1)\\n            return dp[ind][segment];\\n        \\n        int non_pick=fn(ind+1,arr,segment,k); \\n        int target=lower_bound(arr.begin(),arr.end(),arr[ind]+k+1)-arr.begin();\\n        int pick=target-ind; \\n        \\n        pick+=fn(target,arr,segment-1,k);\\n        \\n        return dp[ind][segment]= max(non_pick,pick);\\n        \\n        \\n    }\\n        \\n    int maximizeWin(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        dp.resize(n,vector<int>(3,-1));\\n        \\n        return fn(0,arr,2,k);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int fn(int ind,vector<int>&arr,int segment,int k) \\n    {\\n        if(segment==0)\\n            return 0;\\n        if(ind>=arr.size())\\n            return 0;\\n        if(dp[ind][segment]!=-1)\\n            return dp[ind][segment];\\n        \\n        int non_pick=fn(ind+1,arr,segment,k); \\n        int target=lower_bound(arr.begin(),arr.end(),arr[ind]+k+1)-arr.begin();\\n        int pick=target-ind; \\n        \\n        pick+=fn(target,arr,segment-1,k);\\n        \\n        return dp[ind][segment]= max(non_pick,pick);\\n        \\n        \\n    }\\n        \\n    int maximizeWin(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        dp.resize(n,vector<int>(3,-1));\\n        \\n        return fn(0,arr,2,k);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154943,
                "title": "easy-sliding-window-with-dp-visual-example",
                "content": "# Idea\\n- Use sliding window along with 1D dynamic programming. \\n- Sliding window will find all possible segments while `dp` array stores the maximum segment up to each index. \\n- Combining these two concepts, sliding window is used for current segment length while `dp` finds a previous maximum segment. \\n    - Notice using this method means our segments will never overlap. \\n\\n##### Sliding Window\\n- We increase our window while the segment is *less than or equal to* `k`.\\n- Decrease our window when above condition is not satisifed. \\n- We want to have a valid window with every iteration so we can check with `dp` for max segments. \\n\\n##### Dynamic Programming \\n- Size $$n+1$$ to initialize `dp[0] = 0` for start max segment size. Conventional and convenient for most DP problems. \\n- At each index, we store the maximum segment size up to that point.\\n- The candidates for consideration: current segment length `start` to `end` and previous max segment `dp[start]`.\\n\\n\\n# Example\\n-  Here is every iteration of case `[1, 1, 2, 2, 3, 3, 5]`\\n\\n![1.jfif](https://assets.leetcode.com/users/images/77aca49d-2fb7-4b43-a31f-507c94029605_1675882092.2132459.jpeg)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        vector<int> dp(n+1, 0);\\n        int res = 0;\\n        for (int start = 0, end = 0; end < n; end++){\\n            while (prizePositions[end] - prizePositions[start] > k){\\n                start++;\\n            }\\n            dp[end+1] = max(dp[end], end-start+1);\\n            res = max(res, end-start+1 + dp[start]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n### Please upvote if this was helpful. Thanks! \\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        vector<int> dp(n+1, 0);\\n        int res = 0;\\n        for (int start = 0, end = 0; end < n; end++){\\n            while (prizePositions[end] - prizePositions[start] > k){\\n                start++;\\n            }\\n            dp[end+1] = max(dp[end], end-start+1);\\n            res = max(res, end-start+1 + dp[start]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141910,
                "title": "prefix-count-o-n-sliding-window-with-image",
                "content": "# Intuition\\nSince we only need to choose two segement , why not consider one to left and one to right for all index \\'i\\'\\n![IMG_0099.PNG](https://assets.leetcode.com/users/images/e3e30f91-e418-41a5-b66d-57fb1d72fd08_1675530398.6877542.png)\\n\\n\\n# Approach\\nUsing sliding window we can find the max count for [0,i] for all i we storre in prefix array,\\nsimilarly if we can find for suffix array .\\nThe max value of [0,i] + [i+1,n-1] is our answer\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) -- sliding window\\n\\n- Space complexity:\\nO(n) --  for prefix and suffix array\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& A, int k) {\\n        int ans = 0,n = A.size();\\n        //pointer to start of sliding window\\n        int start = 0 ;\\n        //variable for storing current count\\n        int count = 0;\\n        //end_limit of range\\n        int end = A[0] + k;\\n        \\n        int cur_val = 0;\\n        vector<int>pref(n),suff(n);\\n\\n        for(int i=0;i<n;++i){\\n            int cur = A[i];\\n            //if current element is in range we increment our count\\n            if(cur<= end){\\n                count++;\\n            }\\n            else{\\n                //else we move the start of our window to right until current \\n                //element is in range \\n                while(cur>end){\\n                    start++;\\n                    end = A[start]+k;\\n                    count--;\\n                }\\n                count++;\\n            }\\n            cur_val = max(cur_val,count);\\n            //pref[i] -- it store the max count from [0,i]\\n            pref[i] = cur_val;\\n        }\\n        \\n        //now for suffix \\n        start = n-1;\\n        end = A[n-1] - k;\\n        count = 0,cur_val = 0;\\n\\n        for(int i=n-1;i>=0;--i){\\n            int cur = A[i];\\n            //if current value is in range    \\n            if(cur>=end){\\n                count++;\\n            }\\n            else{\\n                //else we move the start of our window to left until current \\n                //element is in range (we are starting form end and moving to first so left movment)\\n                while(cur<end){\\n                    start--;\\n                    end = A[start]-k;\\n                    count--;\\n                }\\n                count++;\\n                 \\n            }\\n            cur_val = max(cur_val,count);\\n            //suff[i] --  it store the max count from [i,n-1]\\n            suff[i] = cur_val;\\n        }\\n        \\n        for(int i=0;i<n;++i){\\n            int sum = pref[i];\\n            if((i+1)<n)sum += suff[i+1];\\n\\n            //the max sum from [0,i] + [i+1,n-1]\\n            ans = max(ans,sum);\\n        }\\n      \\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& A, int k) {\\n        int ans = 0,n = A.size();\\n        //pointer to start of sliding window\\n        int start = 0 ;\\n        //variable for storing current count\\n        int count = 0;\\n        //end_limit of range\\n        int end = A[0] + k;\\n        \\n        int cur_val = 0;\\n        vector<int>pref(n),suff(n);\\n\\n        for(int i=0;i<n;++i){\\n            int cur = A[i];\\n            //if current element is in range we increment our count\\n            if(cur<= end){\\n                count++;\\n            }\\n            else{\\n                //else we move the start of our window to right until current \\n                //element is in range \\n                while(cur>end){\\n                    start++;\\n                    end = A[start]+k;\\n                    count--;\\n                }\\n                count++;\\n            }\\n            cur_val = max(cur_val,count);\\n            //pref[i] -- it store the max count from [0,i]\\n            pref[i] = cur_val;\\n        }\\n        \\n        //now for suffix \\n        start = n-1;\\n        end = A[n-1] - k;\\n        count = 0,cur_val = 0;\\n\\n        for(int i=n-1;i>=0;--i){\\n            int cur = A[i];\\n            //if current value is in range    \\n            if(cur>=end){\\n                count++;\\n            }\\n            else{\\n                //else we move the start of our window to left until current \\n                //element is in range (we are starting form end and moving to first so left movment)\\n                while(cur<end){\\n                    start--;\\n                    end = A[start]-k;\\n                    count--;\\n                }\\n                count++;\\n                 \\n            }\\n            cur_val = max(cur_val,count);\\n            //suff[i] --  it store the max count from [i,n-1]\\n            suff[i] = cur_val;\\n        }\\n        \\n        for(int i=0;i<n;++i){\\n            int sum = pref[i];\\n            if((i+1)<n)sum += suff[i+1];\\n\\n            //the max sum from [0,i] + [i+1,n-1]\\n            ans = max(ans,sum);\\n        }\\n      \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141758,
                "title": "dp-leftmax-rightmax",
                "content": "# Intuition\\nFor every index ```i```, if we can get ```leftMax[i-1]``` and ```rightMax[i]```, we can iterate through ```i``` and get the max result.\\n\\n```leftMax[i]```: max on the left of index ```i``` (including ```i```) \\n```rightMax[i]```: max on the right of index ```i``` (including ```i```)\\n\\nTo get ```leftMax[i]```: the max between ```leftMax[i-1]```, and the number in the window of size ```k``` from ```i``` to the left, i.e., ```i - j + 1```, where ```j``` is the most left element meeting the window size ```k``` requirement for ```i```.\\n\\nTo get ```rightMax[i]```: the max between ```rightMax[i+1]```, and the number in the window of size ```k``` from ```i``` to the right, i.e., ```j - i + 1```, where ```j``` is the most right element meeting the window size ```k``` requirement for ```i```.\\n\\nTime complexity: ```O(n)```\\n- ```O(n)``` to get ```leftMax```\\n- ```O(n)``` to get ```rightMax```\\n- ```O(n)``` to get result\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeWin(int[] prizePositions, int k) {\\n        int n = prizePositions.length;\\n        int[] leftMax = new int[n], rightMax = new int[n];\\n        // leftMax[i]: max on the left of i (including i) \\n        // rightMax[i]: max on the right of i (including i)\\n\\n        int j = 0;\\n        leftMax[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            while (prizePositions[i] - prizePositions[j] > k) j++;\\n            leftMax[i] = Math.max(leftMax[i - 1], i - j + 1);\\n            // leftMax[i]: the max between leftMax[i-1], and\\n            // the number in the window of size k from i to the left\\n        }\\n        \\n        j = n - 1;\\n        rightMax[n - 1] = 1;\\n        for(int i = n - 2; i >= 0; i--) {\\n            while (prizePositions[j] - prizePositions[i] > k) j--;\\n            rightMax[i] = Math.max(rightMax[i + 1], j - i + 1);\\n            // rightMax[i]: the max between rightMax[i+1], and\\n            // the number in the window of size k from i to the right\\n        }\\n        \\n        int result = 0;\\n        \\n        for(int i = 0; i <= n; i++) {\\n            // XXXXXXXXXX i-1 i XXXXXXXXXXX for each i to get leftMax[i - 1] + rightMax[i]\\n            // edge cases: when i = 0 no leftMax, when i = n - 1 no rightMax\\n            result = Math.max(result, (i == 0 ? 0 : leftMax[i - 1]) + (i == n ? 0 : rightMax[i]));\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```i```\n```leftMax[i-1]```\n```rightMax[i]```\n```i```\n```leftMax[i]```\n```i```\n```i```\n```rightMax[i]```\n```i```\n```i```\n```leftMax[i]```\n```leftMax[i-1]```\n```k```\n```i```\n```i - j + 1```\n```j```\n```k```\n```i```\n```rightMax[i]```\n```rightMax[i+1]```\n```k```\n```i```\n```j - i + 1```\n```j```\n```k```\n```i```\n```O(n)```\n```O(n)```\n```leftMax```\n```O(n)```\n```rightMax```\n```O(n)```\n```\\nclass Solution {\\n    public int maximizeWin(int[] prizePositions, int k) {\\n        int n = prizePositions.length;\\n        int[] leftMax = new int[n], rightMax = new int[n];\\n        // leftMax[i]: max on the left of i (including i) \\n        // rightMax[i]: max on the right of i (including i)\\n\\n        int j = 0;\\n        leftMax[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            while (prizePositions[i] - prizePositions[j] > k) j++;\\n            leftMax[i] = Math.max(leftMax[i - 1], i - j + 1);\\n            // leftMax[i]: the max between leftMax[i-1], and\\n            // the number in the window of size k from i to the left\\n        }\\n        \\n        j = n - 1;\\n        rightMax[n - 1] = 1;\\n        for(int i = n - 2; i >= 0; i--) {\\n            while (prizePositions[j] - prizePositions[i] > k) j--;\\n            rightMax[i] = Math.max(rightMax[i + 1], j - i + 1);\\n            // rightMax[i]: the max between rightMax[i+1], and\\n            // the number in the window of size k from i to the right\\n        }\\n        \\n        int result = 0;\\n        \\n        for(int i = 0; i <= n; i++) {\\n            // XXXXXXXXXX i-1 i XXXXXXXXXXX for each i to get leftMax[i - 1] + rightMax[i]\\n            // edge cases: when i = 0 no leftMax, when i = n - 1 no rightMax\\n            result = Math.max(result, (i == 0 ? 0 : leftMax[i - 1]) + (i == n ? 0 : rightMax[i]));\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154473,
                "title": "catch-up",
                "content": "We can run the first `[l1, r1]` and the second `[l2, r2]` sliding windows at the same time.\\n\\nAs `r2 < l1`, the second window catches up as the first one moves.\\n\\nWe track the maximum win we can get from the second window (`max_w2`) so far.\\n\\nThe win from the first window is `w1`, and we return the best result we can get from `w1 + max_w2`.\\n\\n**C++**\\n```cpp\\nint maximizeWin(vector<int>& p, int k) {\\n    int res = 0, w1 = 0, w2 = 0, max_w2 = 0;\\n    for (int l1 = 0, r1 = 0, l2 = 0, r2 = 0; r1 < p.size(); ++r1) {\\n        ++w1;\\n        for(; p[r1] - p[l1] > k; ++l1)\\n            --w1;\\n        for(; r2 < l1; ++r2) {\\n            ++w2;\\n            for (; p[r2] - p[l2] > k; ++l2)\\n                --w2;\\n            max_w2 = max(max_w2, w2);\\n        }\\n        res = max(res, w1 + max_w2);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maximizeWin(vector<int>& p, int k) {\\n    int res = 0, w1 = 0, w2 = 0, max_w2 = 0;\\n    for (int l1 = 0, r1 = 0, l2 = 0, r2 = 0; r1 < p.size(); ++r1) {\\n        ++w1;\\n        for(; p[r1] - p[l1] > k; ++l1)\\n            --w1;\\n        for(; r2 < l1; ++r2) {\\n            ++w2;\\n            for (; p[r2] - p[l2] > k; ++l2)\\n                --w2;\\n            max_w2 = max(max_w2, w2);\\n        }\\n        res = max(res, w1 + max_w2);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3141458,
                "title": "python-binary-search-dp",
                "content": "\\n        def maximizeWin(self, arr: List[int], k: int) -> int:\\n            n = len(arr)\\n            best = [0]*(n+1)  # best segment after >= i \\n            res = 0\\n            for i in range(n-1,-1,-1):   # curr seg start at ith\\n                e = bisect.bisect_right(arr,arr[i]+k)   # take maximum as possible\\n                res = max(res,e-i + best[e])  # maximize the segments , curr seg [i,e) + next segment after >= e\\n                best[i] = max(best[i+1],e-i)  # track the best segment [i,e)\\n            return res",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "\\n        def maximizeWin(self, arr: List[int], k: int) -> int:\\n            n = len(arr)\\n            best = [0]*(n+1)  # best segment after >= i \\n            res = 0\\n            for i in range(n-1,-1,-1):   # curr seg start at ith\\n                e = bisect.bisect_right(arr,arr[i]+k)   # take maximum as possible\\n                res = max(res,e-i + best[e])  # maximize the segments , curr seg [i,e) + next segment after >= e\\n                best[i] = max(best[i+1],e-i)  # track the best segment [i,e)\\n            return res",
                "codeTag": "Python3"
            },
            {
                "id": 3142834,
                "title": "why-intuitive-approach-didn-t-work-out-greedy",
                "content": "For all those who are thinking why the intuitive greedy approach didn\\'t work out, here is a conversation image\\n![image](https://assets.leetcode.com/users/images/ce697146-c271-4c13-b648-7767c859a060_1675543387.4825861.jpeg)\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "For all those who are thinking why the intuitive greedy approach didn\\'t work out, here is a conversation image\\n![image](https://assets.leetcode.com/users/images/ce697146-c271-4c13-b648-7767c859a060_1675543387.4825861.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3142075,
                "title": "c-solution-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    long long range=0;\\n    long long n;\\n    long long dp[100500][3];\\n    int find(vector<int>&nums,int index,int count)\\n    {\\n        if(count==0||index>=n)\\n        {\\n            return 0;\\n        }\\n        if(dp[index][count]!=-1)\\n        {\\n            return dp[index][count];\\n        }\\n        long long ans=find(nums,index+1,count);\\n        long long it=upper_bound(nums.begin(),nums.end(),nums[index]+range)-nums.begin();\\n        ans=max(ans,it-index+find(nums,it,count-1));\\n        return dp[index][count]= ans;\\n    }\\n    int maximizeWin(vector<int>& prizePositions, int k) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        n=prizePositions.size();\\n        range=k;\\n        return find(prizePositions,0,2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long range=0;\\n    long long n;\\n    long long dp[100500][3];\\n    int find(vector<int>&nums,int index,int count)\\n    {\\n        if(count==0||index>=n)\\n        {\\n            return 0;\\n        }\\n        if(dp[index][count]!=-1)\\n        {\\n            return dp[index][count];\\n        }\\n        long long ans=find(nums,index+1,count);\\n        long long it=upper_bound(nums.begin(),nums.end(),nums[index]+range)-nums.begin();\\n        ans=max(ans,it-index+find(nums,it,count-1));\\n        return dp[index][count]= ans;\\n    }\\n    int maximizeWin(vector<int>& prizePositions, int k) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        n=prizePositions.size();\\n        range=k;\\n        return find(prizePositions,0,2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144297,
                "title": "c-dp-bs-memoization-well-explained-code",
                "content": "# Intuition\\nWe will be going through all the possible combinations of windows and return the max sum.The code will be making sure that the windows don\\'t overlap.We will be traversing from right to left as it\\'ll allow us to apply binary search to find the start of the window whose end is \\'Arr[i]\\'\\n\\n# Approach\\n->Start traversing from right to left.\\n->At each index make decisions to include the window that\\'ll be formed here(End at Arr[i]) or not.\\n->In case of exclusion we simply move to next index(i-1).\\n->In case of inclusion we have to find the start of the window by binary search (lower bound of Arr[i]-k).The length of the window will be i-idx+1(idx is start of the window) and now to avoid overlapping we simply passs idx-1 to the next call and add the window length and decrement the X variable in next call(X variable denotes the number of windows selected so far)\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int Help(int i,int X,vector<int> &prizePositions,int k,vector<vector<int>> &dp)\\n    {\\n        if(X==0)//2 windows have been formed\\n        {\\n            return 0;\\n        }\\n        if(i<0)//Invalid case(2 windows weren\\'t formed)\\n        {\\n            return INT_MIN;\\n        }\\n        if(dp[i][X]!=-1)\\n        {\\n            return dp[i][X];\\n        }\\n\\n        int exc=Help(i-1,X,prizePositions,k,dp);//exclusion case\\n        int inc;//inclusion case\\n        int idx=lower_bound(prizePositions.begin(),prizePositions.end(),prizePositions[i]-k)-prizePositions.begin();//To find the start of this window\\n        inc=(i-idx+1)+Help(idx-1,X-1,prizePositions,k,dp);\\n\\n        return dp[i][X]=max(inc,exc);\\n    }\\n\\n    int maximizeWin(vector<int>& prizePositions, int k)\\n    {\\n        int n=prizePositions.size();\\n        if(2*k>=prizePositions[n-1]-prizePositions[0])//If combined length is greater than the range we can cover all prizes\\n        {\\n            return n;\\n        } \\n        vector<vector<int>> dp(n+1,vector<int> (3,-1));\\n        return Help(prizePositions.size()-1,2,prizePositions,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int Help(int i,int X,vector<int> &prizePositions,int k,vector<vector<int>> &dp)\\n    {\\n        if(X==0)//2 windows have been formed\\n        {\\n            return 0;\\n        }\\n        if(i<0)//Invalid case(2 windows weren\\'t formed)\\n        {\\n            return INT_MIN;\\n        }\\n        if(dp[i][X]!=-1)\\n        {\\n            return dp[i][X];\\n        }\\n\\n        int exc=Help(i-1,X,prizePositions,k,dp);//exclusion case\\n        int inc;//inclusion case\\n        int idx=lower_bound(prizePositions.begin(),prizePositions.end(),prizePositions[i]-k)-prizePositions.begin();//To find the start of this window\\n        inc=(i-idx+1)+Help(idx-1,X-1,prizePositions,k,dp);\\n\\n        return dp[i][X]=max(inc,exc);\\n    }\\n\\n    int maximizeWin(vector<int>& prizePositions, int k)\\n    {\\n        int n=prizePositions.size();\\n        if(2*k>=prizePositions[n-1]-prizePositions[0])//If combined length is greater than the range we can cover all prizes\\n        {\\n            return n;\\n        } \\n        vector<vector<int>> dp(n+1,vector<int> (3,-1));\\n        return Help(prizePositions.size()-1,2,prizePositions,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148353,
                "title": "simple-dp-solution-with-explanation",
                "content": "# Intuition\\nLet\\'s start with a simple problem with one segment. This problem could be solved with a sliding window. To solve the problem with 2 segments we can use dynamic programming.\\n\\n# Approach\\nLet\\'s define a dp[k] as the max segment in the first k elements. We can iterate an array and for every, i build a max possible segment ending on the ith element. Imagine for particular i we have have segment starting on j. In this case, segment length would be `i - j + 1`. dp[i+1] - max possible segment in the array up to index i. We can calculate `dp[i+1] = max(dp[i], i + j - 1)`. If we have some valid segment from j to i, then a max of 2 segments including this one will be a max segment in the first j elements + length of current segment - `dp[j] + (i - j + 1)`. The final answer for this problem will be `max(dp[j] + (i - j + 1))` for every possible i.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} prizePositions\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximizeWin = function(prizePositions, k) {\\n    const n = prizePositions.length;\\n    let dp = new Array(n + 1).fill(0);\\n    let j = 0;\\n    let res = 0;\\n    for(let i = 0; i < n; i++) {\\n        while(prizePositions[i] > prizePositions[j] + k){\\n            j++;\\n        }\\n        let len = i - j + 1;\\n        dp[i + 1] = Math.max(dp[i], len);\\n        res = Math.max(res, dp[j] + len);\\n    }\\n    \\n    return res;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} prizePositions\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximizeWin = function(prizePositions, k) {\\n    const n = prizePositions.length;\\n    let dp = new Array(n + 1).fill(0);\\n    let j = 0;\\n    let res = 0;\\n    for(let i = 0; i < n; i++) {\\n        while(prizePositions[i] > prizePositions[j] + k){\\n            j++;\\n        }\\n        let len = i - j + 1;\\n        dp[i + 1] = Math.max(dp[i], len);\\n        res = Math.max(res, dp[j] + len);\\n    }\\n    \\n    return res;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847651,
                "title": "c-o-n-sliding-window-dp",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n=prizePositions.size();\\n        \\n        int i=0, j=0;\\n        \\n        // maximum no. of prizes which can be selected for segment [0,j] within range k\\n        vector<int> l2r(n,0); \\n        while(j<n){\\n            while(prizePositions[j] - prizePositions[i] > k) i++;\\n            \\n            if(j>0) l2r[j] = l2r[j-1];\\n            l2r[j] = max(l2r[j],j-i+1);\\n            \\n            j++;\\n        }\\n        \\n        // maximum no. of prizes which can be selected for segment [j,n-1] within range k\\n        vector<int> r2l(n,0);\\n        i=n-1, j=n-1;\\n        while(j>=0){\\n            while(prizePositions[i] - prizePositions[j] > k) i--;\\n            \\n            if(j<n-1) r2l[j] = r2l[j+1];\\n            r2l[j] = max(r2l[j],i-j+1);\\n            \\n            j--;\\n        }\\n        \\n        int ans=1;\\n        for(int i=0;i<n-1;i++) ans=max(ans,l2r[i]+r2l[i+1]);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Do upvote if it helps:)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n=prizePositions.size();\\n        \\n        int i=0, j=0;\\n        \\n        // maximum no. of prizes which can be selected for segment [0,j] within range k\\n        vector<int> l2r(n,0); \\n        while(j<n){\\n            while(prizePositions[j] - prizePositions[i] > k) i++;\\n            \\n            if(j>0) l2r[j] = l2r[j-1];\\n            l2r[j] = max(l2r[j],j-i+1);\\n            \\n            j++;\\n        }\\n        \\n        // maximum no. of prizes which can be selected for segment [j,n-1] within range k\\n        vector<int> r2l(n,0);\\n        i=n-1, j=n-1;\\n        while(j>=0){\\n            while(prizePositions[i] - prizePositions[j] > k) i--;\\n            \\n            if(j<n-1) r2l[j] = r2l[j+1];\\n            r2l[j] = max(r2l[j],i-j+1);\\n            \\n            j--;\\n        }\\n        \\n        int ans=1;\\n        for(int i=0;i<n-1;i++) ans=max(ans,l2r[i]+r2l[i+1]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141993,
                "title": "please-help-me-find-error-in-this-code",
                "content": "My thought process was- first find the subarray in which the count of prizes is max for a given k.. then remove those elements already picked and repeat the same process for 1 more time on the new array since there should be exactly 2 segments.. the code I wrote is as follows-  (It passed 61 out of 65 test cases during the contest)\\n```\\nclass Solution {\\n    public int maximizeWin(int[] pos, int k) {\\n        int n = pos.length;\\n        \\n        long max1=Long.MIN_VALUE, sum=0;\\n        int maxIdx=0, i=0,j=0, maxIdx2=0;\\n        \\n        while(i<n){\\n            while(j<n && pos[j]-pos[i] <= k){\\n                sum++;\\n                j++;\\n            }\\n            if(sum >= max1){\\n                maxIdx = i;\\n                max1 = sum;\\n                maxIdx2 = j;\\n            }\\n            while(i<n-1 && pos[i] == pos[i+1]){\\n                i++;\\n                sum--;\\n            }\\n            i++;\\n            sum--;\\n        }\\n        //System.out.println(max1);\\n        int[] npos = new int[n-(maxIdx2-maxIdx)];\\n        int idx=0;\\n        \\n        for(i=0; i<maxIdx; i++) npos[idx++] = pos[i];\\n        for(i=maxIdx2; i<n; i++) npos[idx++] = pos[i];\\n        n = npos.length;\\n        //System.out.println(npos[0]);\\n        long max2=Long.MIN_VALUE;\\n        i=0;\\n        j=0;\\n        sum=0;\\n        while(i<n){\\n            while(j<n && npos[j]-npos[i] <= k){\\n                sum++;\\n                j++;\\n            }\\n            if(sum >= max2){\\n                max2 = sum;\\n            }\\n            while(i<n-1 && npos[i] == npos[i+1]){\\n                i++;\\n                sum--;\\n            }\\n            i++;\\n            sum--;\\n        }\\n        \\n        return (int)(max1+max2);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maximizeWin(int[] pos, int k) {\\n        int n = pos.length;\\n        \\n        long max1=Long.MIN_VALUE, sum=0;\\n        int maxIdx=0, i=0,j=0, maxIdx2=0;\\n        \\n        while(i<n){\\n            while(j<n && pos[j]-pos[i] <= k){\\n                sum++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3142302,
                "title": "using-binary-search-easy-to-understand",
                "content": "# Approach\\nFind the Most appropriate value from all index\\'s and pick that value and maximum of remaining values as answer.\\nFind same thing for all 1<=i<=n.\\n\\n# Complexity\\n- Time complexity:\\n  O(N LogN)\\n\\n- Space complexity:\\n  O(2N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lower(vector<int> &v,int val) {\\n        int i=0,j=v.size()-1,ans=-1;\\n        while(i<=j) {\\n            int mid=(i+j)/2;\\n            if(v[mid]<=val) {\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else j=mid-1;\\n        } return ans;\\n    }\\n\\n    int maximizeWin(vector<int>& p, int k) {\\n        int n = p.size();\\n        vector<int> ans(n);\\n        for(int i=0 ; i<n ; ++i) {\\n            ans[i]=lower(p,p[i]+k)-i+1;\\n        }\\n        vector<int> b(n);\\n        for(int i=n-1 ; i>=0 ; --i) b[i] = max((i==n-1?0:b[i+1]),ans[i]);\\n        int res=0;\\n        for(int i=0 ; i<n ; ++i) {\\n            int extra=0;\\n            if(i+ans[i]<n) {\\n                extra=b[i+ans[i]];\\n            }\\n            res = max(res,ans[i]+extra);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lower(vector<int> &v,int val) {\\n        int i=0,j=v.size()-1,ans=-1;\\n        while(i<=j) {\\n            int mid=(i+j)/2;\\n            if(v[mid]<=val) {\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else j=mid-1;\\n        } return ans;\\n    }\\n\\n    int maximizeWin(vector<int>& p, int k) {\\n        int n = p.size();\\n        vector<int> ans(n);\\n        for(int i=0 ; i<n ; ++i) {\\n            ans[i]=lower(p,p[i]+k)-i+1;\\n        }\\n        vector<int> b(n);\\n        for(int i=n-1 ; i>=0 ; --i) b[i] = max((i==n-1?0:b[i+1]),ans[i]);\\n        int res=0;\\n        for(int i=0 ; i<n ; ++i) {\\n            int extra=0;\\n            if(i+ans[i]<n) {\\n                extra=b[i+ans[i]];\\n            }\\n            res = max(res,ans[i]+extra);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146550,
                "title": "beats-100-by-speed-and-memory-python-simple-solution",
                "content": "# Intuition\\nLet\\'s iterate through the array and for each position, calculate the count of prizes in the interval if the interval ends at the current position and store the count and the position in the \"intervals\" list.\\n```\\nintervals = [(count of prizes, end pos), (count of prizes, end pos)]\\n```\\n\\nLet\\'s also store the interval which covers the maximum count of prizes that ends before some position, the \"max stack for the intervals,\" in the \"max_before\".\\n```\\nmax_before = [(max count of prizes, end pos1), (max count of prizes, end pos2)]\\nend pos1 <= end pos2 <= end pos3 <= end pos4 ....\\ncount1 <= count2 <= count3 <= count4 ...\\n```\\n\\nThe solution is then straightforward and is based on two key ideas:\\n\\n1. If we have two intervals, we can make them non-intersecting by moving the first of them, as the second will cover the same prizes. So we need only consider the non-intersecting intervals.\\n\\n2. The solution must have the last interval. To find the solution, we pop intervals from the \"intervals\" list one by one and calculate the solution if the current interval is the last one. Then, find the maximum among these solutions.\\n\\nTo implement this, we pop the next interval from the \"intervals\" list - the current last interval.\\nThen, pop all intervals from the \"max_before\" list that do not end before the current interval.\\nThe top of the \"max_before\" list will then have the interval with the maximum prize count before the current interval.\\nThe current best candidate solution for the current last interval is the count of prizes for the current last interval plus the top of the \"max_before\" interval.\\n```\\ncandidate = count+(0 if not max_beffore else max_beffore[-1][0])\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        # count of prizes for all intervals\\n        # (count, end position of interval)        \\n        intervals = []\\n        # max stack of intervals\\n        # (count, end position of interval),\\n        # There can\\'t be interval with bigger count before the interval\\n        max_beffore = []\\n        start_inx = 0 # start index of the current interval\\n        count = 0 # count of the current interval\\n        for inx, pos in enumerate(prizePositions):\\n            count += 1\\n            # subtract prizes from the current interval if they are not covered by the interval\\n            while pos-k > prizePositions[start_inx]:\\n                count -= 1\\n                start_inx += 1\\n            intervals.append((count, pos))\\n            if not max_beffore or max_beffore[-1][0] < count:\\n                max_beffore.append((count, pos))\\n\\n        max_solution = 0\\n        while intervals:\\n            # the last interval for the current solution\\n            count, pos = intervals.pop()\\n            # max_beffore stores only intervals before the last interval,\\n            # max_beffore is a max stack,\\n            # so the top of the max possible has the max count among all values in the max_beffore\\n            while max_beffore and max_beffore[-1][1] >= pos-k:\\n                max_beffore.pop()\\n            # The soluthon if the current last interval is the last\\n            candidate = count+(0 if not max_beffore else max_beffore[-1][0])\\n            # we need to find maximum among all candidates\\n            max_solution = max(candidate, max_solution)\\n        return max_solution\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nintervals = [(count of prizes, end pos), (count of prizes, end pos)]\\n```\n```\\nmax_before = [(max count of prizes, end pos1), (max count of prizes, end pos2)]\\nend pos1 <= end pos2 <= end pos3 <= end pos4 ....\\ncount1 <= count2 <= count3 <= count4 ...\\n```\n```\\ncandidate = count+(0 if not max_beffore else max_beffore[-1][0])\\n```\n```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        # count of prizes for all intervals\\n        # (count, end position of interval)        \\n        intervals = []\\n        # max stack of intervals\\n        # (count, end position of interval),\\n        # There can\\'t be interval with bigger count before the interval\\n        max_beffore = []\\n        start_inx = 0 # start index of the current interval\\n        count = 0 # count of the current interval\\n        for inx, pos in enumerate(prizePositions):\\n            count += 1\\n            # subtract prizes from the current interval if they are not covered by the interval\\n            while pos-k > prizePositions[start_inx]:\\n                count -= 1\\n                start_inx += 1\\n            intervals.append((count, pos))\\n            if not max_beffore or max_beffore[-1][0] < count:\\n                max_beffore.append((count, pos))\\n\\n        max_solution = 0\\n        while intervals:\\n            # the last interval for the current solution\\n            count, pos = intervals.pop()\\n            # max_beffore stores only intervals before the last interval,\\n            # max_beffore is a max stack,\\n            # so the top of the max possible has the max count among all values in the max_beffore\\n            while max_beffore and max_beffore[-1][1] >= pos-k:\\n                max_beffore.pop()\\n            # The soluthon if the current last interval is the last\\n            candidate = count+(0 if not max_beffore else max_beffore[-1][0])\\n            # we need to find maximum among all candidates\\n            max_solution = max(candidate, max_solution)\\n        return max_solution\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144130,
                "title": "c-maintain-2-arrays-front-and-back-to-calculate-the-answer",
                "content": "In the solution, what I have tried to do is to have 2 arrays which store, for each index i, for the front array, the value stored in array tells us about the maximum window that can satisfy the given condition of k, and similarily for the back row, the values tell us about the maximum window size that satisfies the given condition.\\n\\nAnd, after we have calculated both front and back array, we just traverse from 0 to n-1 and use both these arrays to find 2 windows as required in the question.\\n\\n```\\n\\tint maximizeWin(vector<int>& arr, int k) {\\n        int ans = 0, n = arr.size();\\n        if(n==1) return 1;\\n        \\n        vector<int> fr(n, 0), bk(n, 0);\\n        int i=0, j=0, mx = 1;\\n        while(j<n) {\\n            while(j>=i && arr[j]-arr[i] > k) i++;\\n            mx = max(j-i+1, mx);\\n            fr[j] = mx;\\n            j++;\\n        }\\n        \\n        j=n-1, i=n-1, mx = 1;\\n        while(j>=0) {\\n            mx = max(i-j+1, mx);\\n            bk[j] = mx;\\n            while(j<=i && arr[i]-arr[j] > k) i--;\\n            j--;\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            ans = max(ans, fr[i]+bk[i]-1);\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "In the solution, what I have tried to do is to have 2 arrays which store, for each index i, for the front array, the value stored in array tells us about the maximum window that can satisfy the given condition of k, and similarily for the back row, the values tell us about the maximum window size that satisfies the given condition.\\n\\nAnd, after we have calculated both front and back array, we just traverse from 0 to n-1 and use both these arrays to find 2 windows as required in the question.\\n\\n```\\n\\tint maximizeWin(vector<int>& arr, int k) {\\n        int ans = 0, n = arr.size();\\n        if(n==1) return 1;\\n        \\n        vector<int> fr(n, 0), bk(n, 0);\\n        int i=0, j=0, mx = 1;\\n        while(j<n) {\\n            while(j>=i && arr[j]-arr[i] > k) i++;\\n            mx = max(j-i+1, mx);\\n            fr[j] = mx;\\n            j++;\\n        }\\n        \\n        j=n-1, i=n-1, mx = 1;\\n        while(j>=0) {\\n            mx = max(i-j+1, mx);\\n            bk[j] = mx;\\n            while(j<=i && arr[i]-arr[j] > k) i--;\\n            j--;\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            ans = max(ans, fr[i]+bk[i]-1);\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3141664,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        dp=[0]*(len(prizePositions)+1)\\n        res=0\\n        j=0\\n        for i,a in enumerate(prizePositions):\\n            while prizePositions[j]<prizePositions[i]-k:\\n                j+=1\\n            dp[i+1]=max(dp[i],i-j+1)\\n            res=max(res,i-j+1+dp[j])\\n            \\n        return res     \\n                \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        dp=[0]*(len(prizePositions)+1)\\n        res=0\\n        j=0\\n        for i,a in enumerate(prizePositions):\\n            while prizePositions[j]<prizePositions[i]-k:\\n                j+=1\\n            dp[i+1]=max(dp[i],i-j+1)\\n            res=max(res,i-j+1+dp[j])\\n            \\n        return res     \\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227352,
                "title": "python-solution-using-binary-search",
                "content": "# Code\\n```\\nfrom bisect import bisect_right,bisect_left\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        ans=prv=0\\n        for i,item in enumerate(prizePositions):\\n            j1=bisect_left(prizePositions,item-k)\\n            j2=bisect_right(prizePositions,item+k)\\n            ans=max(ans,j2-j1,prv+j2-i)\\n            prv=max(prv,i-j1+1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import bisect_right,bisect_left\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        ans=prv=0\\n        for i,item in enumerate(prizePositions):\\n            j1=bisect_left(prizePositions,item-k)\\n            j2=bisect_right(prizePositions,item+k)\\n            ans=max(ans,j2-j1,prv+j2-i)\\n            prv=max(prv,i-j1+1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169175,
                "title": "both-100-c-58-ms-54-6-mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet DP[i] represent the farthest distance that can be reached to the right at position i. The problem is to find x and y to maximize the sum of DP[x] + DP[y]. Note that the parts covered by x and y cannot overlap.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse two sliding windows, one is used to calculate dp[i] (because dp[i]+i is increasing to the right); the other is used to find max(dp[x]) for x<i (the reason is the same as above). Note when x=0, it means that all elements to the left of i are in the range k.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& p, int k) {\\n        int n=p.size(),ans=0;\\n        for(int i=0,r=0,l=0,v=0;i<n;++i){\\n            while(r<n&&p[r]-p[i]<=k)++r;\\n            p[i]=r-i;\\n            while(p[l]+l<=i)v=max(v,p[l++]);\\n            ans=max(ans,l?v+p[i]:p[i]+i);\\n            if(r==n)return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& p, int k) {\\n        int n=p.size(),ans=0;\\n        for(int i=0,r=0,l=0,v=0;i<n;++i){\\n            while(r<n&&p[r]-p[i]<=k)++r;\\n            p[i]=r-i;\\n            while(p[l]+l<=i)v=max(v,p[l++]);\\n            ans=max(ans,l?v+p[i]:p[i]+i);\\n            if(r==n)return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143226,
                "title": "binary-search-dp-with-tc-sc-approach",
                "content": "\\n# Approach\\n- Pick First_Range_STARTIdx from 0 till n-1\\n- Now,START = prizePositions[START] , END = START + k\\n- Find First_Range_ENDIdx Using Binary Search(END) or UpperBound(END) as all values in range [START,END] they are Now a part of First_Range\\n- Now, Second_Range_STARTIdx will either start Just from First_Range_ENDIdx OR we will be skipping some and go till n to get maximum Second Range. This is Handled in **nextMaxRange Function** using takeIt OR notTake it LOGIC\\n  1. Now, firstRange = First_Range_ENDIdx - First_Range_STARTIdx  \\n  2. secondRange = nextMaxRange(First_Range_ENDIdx)\\n- return max(ans,firstRange+secondRange)\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*[logn + nextMaxRange])$$ \\n= $$O(nlogn]$$\\n*here, O[nextMaxRange] ~ logn  ,for particular idx ,So overall $$O(nlogn)$$\\nBecause Using Memo, we will be going only Once in nextMaxRange Fn*\\n\\n\\n- Space complexity:\\n$$O(n)$$ , *memoized vector*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nextMaxRange(int idx,vector<int>& prizePositions,int k,int n,vector<int>& memo){\\n        if(idx == n){\\n            return 0;\\n        }\\n\\n        if(memo[idx] != -1){\\n            return memo[idx];\\n        }\\n\\n        //not Take\\n        int notTakeRange = 0 , takeRange = 0;\\n        notTakeRange =  nextMaxRange(idx+1,prizePositions,k,n,memo);\\n\\n        //Take\\n        int start = prizePositions[idx];\\n        int end = start + k;\\n        int endIdx = upper_bound(prizePositions.begin(),prizePositions.end(),end) - prizePositions.begin(); \\n        takeRange = endIdx - idx;\\n\\n        return memo[idx] = max(takeRange,notTakeRange);\\n\\n    }\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        vector<int> memo(n,-1);\\n        int ans = 0;\\n\\n        for(int i=0;i<n;i++){\\n            int start = prizePositions[i];\\n            int end = start + k;\\n            //just after Index of end\\n            int endIdx = upper_bound(prizePositions.begin(),prizePositions.end(),end) - prizePositions.begin(); \\n            int firstRange = endIdx - i;\\n            int secondRange = nextMaxRange(endIdx,prizePositions,k,n,memo);\\n           \\n            ans = max(ans,firstRange+secondRange);\\n\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextMaxRange(int idx,vector<int>& prizePositions,int k,int n,vector<int>& memo){\\n        if(idx == n){\\n            return 0;\\n        }\\n\\n        if(memo[idx] != -1){\\n            return memo[idx];\\n        }\\n\\n        //not Take\\n        int notTakeRange = 0 , takeRange = 0;\\n        notTakeRange =  nextMaxRange(idx+1,prizePositions,k,n,memo);\\n\\n        //Take\\n        int start = prizePositions[idx];\\n        int end = start + k;\\n        int endIdx = upper_bound(prizePositions.begin(),prizePositions.end(),end) - prizePositions.begin(); \\n        takeRange = endIdx - idx;\\n\\n        return memo[idx] = max(takeRange,notTakeRange);\\n\\n    }\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        vector<int> memo(n,-1);\\n        int ans = 0;\\n\\n        for(int i=0;i<n;i++){\\n            int start = prizePositions[i];\\n            int end = start + k;\\n            //just after Index of end\\n            int endIdx = upper_bound(prizePositions.begin(),prizePositions.end(),end) - prizePositions.begin(); \\n            int firstRange = endIdx - i;\\n            int secondRange = nextMaxRange(endIdx,prizePositions,k,n,memo);\\n           \\n            ans = max(ans,firstRange+secondRange);\\n\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141489,
                "title": "map-intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(vector<int>& v, int l, int r) {\\n        return upper_bound(v.begin(), v.end(), r) - lower_bound(v.begin(), v.end(), l);\\n    }\\n    \\n    int maximizeWin(vector<int>& v, int k) {\\n        map<int, int> ma;\\n        for(auto it : v) {\\n            ma[it]++;\\n        }\\n        vector<int> w;\\n        for(auto it : ma) {\\n            w.push_back(it.first);\\n        }\\n        int n = w.size();\\n        int maxi = 0;\\n        int maxi_prev = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n            maxi = max(maxi, maxi_prev + func(v, w[i] - k, w[i]));\\n            maxi_prev = max(maxi_prev, func(v, w[i], w[i] + k));\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(vector<int>& v, int l, int r) {\\n        return upper_bound(v.begin(), v.end(), r) - lower_bound(v.begin(), v.end(), l);\\n    }\\n    \\n    int maximizeWin(vector<int>& v, int k) {\\n        map<int, int> ma;\\n        for(auto it : v) {\\n            ma[it]++;\\n        }\\n        vector<int> w;\\n        for(auto it : ma) {\\n            w.push_back(it.first);\\n        }\\n        int n = w.size();\\n        int maxi = 0;\\n        int maxi_prev = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n            maxi = max(maxi, maxi_prev + func(v, w[i] - k, w[i]));\\n            maxi_prev = max(maxi_prev, func(v, w[i], w[i] + k));\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141475,
                "title": "python-clear-solution-leetcode-2054-two-best-non-overlapping-events",
                "content": "Clearly, maximum score will be achieved with `two non-overlapping segments`.\\nAs a result, we can see the link of this problem to Leetcode 2054.\\n\\n    def maximizeWin(self, ps: List[int], k: int) -> int:\\n        if max(ps)-min(ps)<=k*2:\\n            return len(ps)\\n\\n        scores, q, cur, ans = [], [], 0, 0\\n\\t\\t# build the list of (start, end, prize-numbers)\\n        for i, n in enumerate(ps):\\n            if not scores or scores[-1][0]!=n:\\n                idx = bisect.bisect_left(ps, n+k+1)\\n                scores.append([n, ps[idx-1], idx-i])\\n\\t\\n\\t\\t# calculate best score of two Non-overlapping segments\\n        for i, j, v in scores:\\n            while(q and q[0][0]<i):\\n                cur = max(cur, heappop(q)[1])\\n            ans = max(ans, cur+v)\\n            heappush(q, (j, v))\\n        return ans",
                "solutionTags": [],
                "code": "Clearly, maximum score will be achieved with `two non-overlapping segments`.\\nAs a result, we can see the link of this problem to Leetcode 2054.\\n\\n    def maximizeWin(self, ps: List[int], k: int) -> int:\\n        if max(ps)-min(ps)<=k*2:\\n            return len(ps)\\n\\n        scores, q, cur, ans = [], [], 0, 0\\n\\t\\t# build the list of (start, end, prize-numbers)\\n        for i, n in enumerate(ps):\\n            if not scores or scores[-1][0]!=n:\\n                idx = bisect.bisect_left(ps, n+k+1)\\n                scores.append([n, ps[idx-1], idx-i])\\n\\t\\n\\t\\t# calculate best score of two Non-overlapping segments\\n        for i, j, v in scores:\\n            while(q and q[0][0]<i):\\n                cur = max(cur, heappop(q)[1])\\n            ans = max(ans, cur+v)\\n            heappush(q, (j, v))\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 3775120,
                "title": "99-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& A, int k) \\n    {\\n        int res = 0, n = A.size(), j = 0;\\n        vector<int> dp(n + 1, 0);\\n        for (int i = 0; i < n; ++i) \\n        {\\n            while (A[j] < A[i] - k)\\n                ++j;\\n            dp[i + 1] = max(dp[i], i - j + 1);\\n            res = max(res, i - j + 1 + dp[j]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& A, int k) \\n    {\\n        int res = 0, n = A.size(), j = 0;\\n        vector<int> dp(n + 1, 0);\\n        for (int i = 0; i < n; ++i) \\n        {\\n            while (A[j] < A[i] - k)\\n                ++j;\\n            dp[i + 1] = max(dp[i], i - j + 1);\\n            res = max(res, i - j + 1 + dp[j]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167395,
                "title": "dp-similar-to-buy-and-sell-stocks-with-2-transaction-memoization-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can use dp to find at most 2 different ranges and return the maximum sum of these ranges. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe limit ourself to 2 picks .\\nwe use the principal of take / not take at a given index.\\nwe can take a starting element from the array , then using the  fact that array is sorted , we can use binary search to find the last index of range such that , the element is less than or equal to first element +k.\\n\\n\\nwe can do this process at most 2 times.\\nthen return maximum number of elements accumulated.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2*n*log(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n // this will return index of the last valid element in the range\\n \\n int search(vector<int>& prize,int s, int key){\\nint e=prize.size()-1;\\nint mid;\\nint ans=-1;\\nwhile(s<=e){\\n\\nmid=(s+e)/2;\\nif(prize[mid]<=key){\\n    ans=mid;\\n    s=mid+1;\\n}\\nelse\\n e=mid-1;\\n\\n}\\nreturn ans;\\n } \\n\\nint solve(vector<int>& prize, int &k,int idx,int t,int &n,vector<vector<int>>&dp){\\n\\nif(t==2) // we have used 2 ranges/transactions  \\nreturn 0;\\n\\nif(idx>=n) // we are out of the array\\nreturn 0;\\n\\nif(dp[idx][t]!=-1)\\nreturn dp[idx][t];\\n// memoization\\nint l=0,r=0;\\n// take \\nint range = search(prize,idx,prize[idx]+k); \\nl= range-idx+1 + solve(prize,k,range+1,t+1,n,dp);\\n// not take\\nr=solve(prize,k,idx+1,t,n,dp);\\n\\nreturn dp[idx][t]=max(l,r);\\n}\\n\\n    int maximizeWin(vector<int>& prize, int k) {\\n        //take, not take\\n        // we can take at most 2 times\\n\\nint n=prize.size();\\nvector<vector<int>>dp(n,vector<int>(2,-1));\\n// n size of all the indexes from 0- (n-1) and 2 size for atmost 2 transactions.\\nreturn solve(prize,k,0,0,n,dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n // this will return index of the last valid element in the range\\n \\n int search(vector<int>& prize,int s, int key){\\nint e=prize.size()-1;\\nint mid;\\nint ans=-1;\\nwhile(s<=e){\\n\\nmid=(s+e)/2;\\nif(prize[mid]<=key){\\n    ans=mid;\\n    s=mid+1;\\n}\\nelse\\n e=mid-1;\\n\\n}\\nreturn ans;\\n } \\n\\nint solve(vector<int>& prize, int &k,int idx,int t,int &n,vector<vector<int>>&dp){\\n\\nif(t==2) // we have used 2 ranges/transactions  \\nreturn 0;\\n\\nif(idx>=n) // we are out of the array\\nreturn 0;\\n\\nif(dp[idx][t]!=-1)\\nreturn dp[idx][t];\\n// memoization\\nint l=0,r=0;\\n// take \\nint range = search(prize,idx,prize[idx]+k); \\nl= range-idx+1 + solve(prize,k,range+1,t+1,n,dp);\\n// not take\\nr=solve(prize,k,idx+1,t,n,dp);\\n\\nreturn dp[idx][t]=max(l,r);\\n}\\n\\n    int maximizeWin(vector<int>& prize, int k) {\\n        //take, not take\\n        // we can take at most 2 times\\n\\nint n=prize.size();\\nvector<vector<int>>dp(n,vector<int>(2,-1));\\n// n size of all the indexes from 0- (n-1) and 2 size for atmost 2 transactions.\\nreturn solve(prize,k,0,0,n,dp);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153465,
                "title": "javascript-dp-sliding-window",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} prizePositions\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximizeWin = function (prizePositions, k) {\\n  const n = prizePositions.length;\\n  const dp = new Array(n + 1).fill(0);\\n  let ans = 0;\\n  let start = 0;\\n\\n  for (let end = 0; end < prizePositions.length; end++) {\\n    while (prizePositions[end] - prizePositions[start] > k) start++;\\n\\n    const currPrize = end - start + 1;\\n    dp[end + 1] = Math.max(dp[end], currPrize);\\n    ans = Math.max(ans, currPrize + dp[start]);\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prizePositions\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximizeWin = function (prizePositions, k) {\\n  const n = prizePositions.length;\\n  const dp = new Array(n + 1).fill(0);\\n  let ans = 0;\\n  let start = 0;\\n\\n  for (let end = 0; end < prizePositions.length; end++) {\\n    while (prizePositions[end] - prizePositions[start] > k) start++;\\n\\n    const currPrize = end - start + 1;\\n    dp[end + 1] = Math.max(dp[end], currPrize);\\n    ans = Math.max(ans, currPrize + dp[start]);\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3143112,
                "title": "c-binary-search-dp-beats-100-easy-intuitive-explanation-illustration",
                "content": "\\n# Solution\\n**We Calculate the maximum number of prizes we can collect if we start collecting from index i , using binary search to find the first index that cannot be included if we start at index i.**\\n\\nAfter that we can just iterate over all index\\'s **finding the maximum possible length of segment 1 , which was already calculated in the previous step (DP). For segment 2, we take the maximum possible value of all the remaning indices that remain after inclusion of segment 1 (stored in DP2 using suffix maximum).**\\n\\n**The answer is the maximum over all index\\'s.**\\n\\n ![explainationleetcodee.png](https://assets.leetcode.com/users/images/2bd509d5-aee5-421d-aa8d-6f539a102ff4_1675550563.418666.png)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& a, int k) {\\n        int n = (int)a.size();\\n        vector<int>dp(n,0);\\n        for(int i = 0 ; i < n ; i++) {\\n        //Calculates the maximum number of prizes we can collect if we start at index i.\\n\\n         int p = upper_bound(a.begin(),a.end(),a[i] + k) - a.begin(); // binary search to find the first index that cannot be included\\n         int len = p - i; // length of the segment that can included we start at index i.\\n         dp[i] = len; // storing the best possible answer if we start collecting prizes if we start at index i.\\n        }      \\n        vector<int>dp2 = dp;\\n        int mx = dp[n-1];\\n        for(int i = n-1 ; i >= 0 ; i--) {\\n            mx = max(dp[i],mx);\\n            dp2[i] = mx; // creating suffix maximum array.\\n        }\\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++) {\\n         int res = dp[i]; // gives the maximum number of prizes we can take if we start at index i [Segment 1]. (marked blue & red in picture)\\n         if(i+dp[i] < n) {\\n            // Maximum possible value for Segment 2 (marked as pink in picture)\\n            res += dp2[i+dp[i]]; \\n         }\\n         ans = max(ans,res); // maximum possible answer.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& a, int k) {\\n        int n = (int)a.size();\\n        vector<int>dp(n,0);\\n        for(int i = 0 ; i < n ; i++) {\\n        //Calculates the maximum number of prizes we can collect if we start at index i.\\n\\n         int p = upper_bound(a.begin(),a.end(),a[i] + k) - a.begin(); // binary search to find the first index that cannot be included\\n         int len = p - i; // length of the segment that can included we start at index i.\\n         dp[i] = len; // storing the best possible answer if we start collecting prizes if we start at index i.\\n        }      \\n        vector<int>dp2 = dp;\\n        int mx = dp[n-1];\\n        for(int i = n-1 ; i >= 0 ; i--) {\\n            mx = max(dp[i],mx);\\n            dp2[i] = mx; // creating suffix maximum array.\\n        }\\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++) {\\n         int res = dp[i]; // gives the maximum number of prizes we can take if we start at index i [Segment 1]. (marked blue & red in picture)\\n         if(i+dp[i] < n) {\\n            // Maximum possible value for Segment 2 (marked as pink in picture)\\n            res += dp2[i+dp[i]]; \\n         }\\n         ans = max(ans,res); // maximum possible answer.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142667,
                "title": "very-easy-and-intuitive-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsee my first intuition was that , in none of the cases it is ideal for me to take two overlapping subarrays , if it is possible for me to take two non overlapping subarrays than that would always be better.\\nThere is just one case where you need to take overlapping subarrays that is when the number of position on x axis is less than 2*k here you can get all the rewards possible .\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow this question becomes same as dividing array in two k sized non overlapping subarrays and maximizing our sum , there is just one issue that we can\\'t make our right and left dp on positions as it is 10^9 . hence what we will do is we will make dp on the unique pos present in our initial array, that would be in worst case be 10^5,\\nnow we just need to take a sliding window approach to fill in these dp\\'s and than we can iterate these dp\\'s to find our answer.\\n\\nThere could be two cases on each pos-:\\n1) left_max till pos(i)+right_max till pos(i+1);\\n2) right_max till pos(i)+left_max till pos(i-1);\\nmax of these value should be comapred to our gloabal answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(N) (i.e actually o(2*N));\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& arr, int k) {\\n        map<int,int> mp;\\n        vector<int> vec;\\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]]+=1;\\n            if(mp[arr[i]]==1){\\n                vec.push_back(arr[i]);\\n            }\\n        }\\n        \\n        vector<int> left_max(vec.size(),0);\\n        int left_max_val=mp[vec[0]];\\n        int start=0;\\n        int end=1;\\n        int sum=mp[vec[0]];\\n        left_max[0]=mp[vec[0]];\\n        while(end<vec.size()){\\n            while(end<vec.size() &&(vec[end]-vec[start])<=k){\\n                sum+=mp[vec[end]];\\n                left_max_val=max(sum,left_max_val);\\n                left_max[end]=left_max_val;\\n                end++;\\n            }\\n            while(end<vec.size() && start<=end && (vec[end]-vec[start])>k){\\n                sum-=mp[vec[start]];\\n                start++;\\n            }\\n        }\\n        /*for(int i=0;i<vec.size();i++){\\n            cout<<left_max[i]<<\" \";\\n        }*/\\n       \\n        vector<int> right_max(vec.size(),0);\\n        int right_max_val=mp[vec[vec.size()-1]];\\n        start=vec.size()-1;\\n        end=vec.size()-2;\\n        sum=mp[vec[vec.size()-1]];\\n        right_max[vec.size()-1]=mp[vec[vec.size()-1]];\\n        while(end>=0){\\n            while(end>=0 &&(vec[start]-vec[end])<=k){\\n                sum+=mp[vec[end]];\\n                right_max_val=max(sum,right_max_val);\\n                right_max[end]=right_max_val;\\n                end--;\\n            }\\n            while(end>=0 && start>=end && (vec[start]-vec[end])>k){\\n                sum-=mp[vec[start]];\\n                start--;\\n            }\\n        }\\n        /*for(int i=0;i<vec.size();i++){\\n            cout<<right_max[i]<<\" \";\\n        }*/\\n        int ans=INT_MIN;\\n        for(int i=0;i<vec.size();i++){\\n            int val=0;\\n            if(i==0){\\n                if(i+1<vec.size()){\\n                    val=max(right_max[i],left_max[i]+right_max[i+1]);\\n                }\\n                else{\\n                    val=max(right_max[i],left_max[i]);\\n                }\\n            }\\n            else if(i==vec.size()-1){\\n                if(i-1>=0){\\n                    val=max(left_max[i],right_max[i]+left_max[i-1]);\\n                }\\n                else{\\n                    val=max(left_max[i],right_max[i]);\\n                }\\n            }\\n            else{\\n                val=max(left_max[i]+right_max[i+1],right_max[i]+left_max[i-1]);\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& arr, int k) {\\n        map<int,int> mp;\\n        vector<int> vec;\\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]]+=1;\\n            if(mp[arr[i]]==1){\\n                vec.push_back(arr[i]);\\n            }\\n        }\\n        \\n        vector<int> left_max(vec.size(),0);\\n        int left_max_val=mp[vec[0]];\\n        int start=0;\\n        int end=1;\\n        int sum=mp[vec[0]];\\n        left_max[0]=mp[vec[0]];\\n        while(end<vec.size()){\\n            while(end<vec.size() &&(vec[end]-vec[start])<=k){\\n                sum+=mp[vec[end]];\\n                left_max_val=max(sum,left_max_val);\\n                left_max[end]=left_max_val;\\n                end++;\\n            }\\n            while(end<vec.size() && start<=end && (vec[end]-vec[start])>k){\\n                sum-=mp[vec[start]];\\n                start++;\\n            }\\n        }\\n        /*for(int i=0;i<vec.size();i++){\\n            cout<<left_max[i]<<\" \";\\n        }*/\\n       \\n        vector<int> right_max(vec.size(),0);\\n        int right_max_val=mp[vec[vec.size()-1]];\\n        start=vec.size()-1;\\n        end=vec.size()-2;\\n        sum=mp[vec[vec.size()-1]];\\n        right_max[vec.size()-1]=mp[vec[vec.size()-1]];\\n        while(end>=0){\\n            while(end>=0 &&(vec[start]-vec[end])<=k){\\n                sum+=mp[vec[end]];\\n                right_max_val=max(sum,right_max_val);\\n                right_max[end]=right_max_val;\\n                end--;\\n            }\\n            while(end>=0 && start>=end && (vec[start]-vec[end])>k){\\n                sum-=mp[vec[start]];\\n                start--;\\n            }\\n        }\\n        /*for(int i=0;i<vec.size();i++){\\n            cout<<right_max[i]<<\" \";\\n        }*/\\n        int ans=INT_MIN;\\n        for(int i=0;i<vec.size();i++){\\n            int val=0;\\n            if(i==0){\\n                if(i+1<vec.size()){\\n                    val=max(right_max[i],left_max[i]+right_max[i+1]);\\n                }\\n                else{\\n                    val=max(right_max[i],left_max[i]);\\n                }\\n            }\\n            else if(i==vec.size()-1){\\n                if(i-1>=0){\\n                    val=max(left_max[i],right_max[i]+left_max[i-1]);\\n                }\\n                else{\\n                    val=max(left_max[i],right_max[i]);\\n                }\\n            }\\n            else{\\n                val=max(left_max[i]+right_max[i+1],right_max[i]+left_max[i-1]);\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3142203,
                "title": "java-dp-sliding-window-solution",
                "content": "# Intuition\\nThe intuition behind solving the problem is to use dynamic programming to efficiently keep track of the maximum number of prizes that can be won at each position.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStarting from the first position, the code uses a 2-dimensional DP array dp[][] to store the maximum number of prizes won so far for each position. The DP approach is used to avoid re-computing the same solution multiple times and to ensure that the solution is optimal.\\n\\nFor each position, the code checks the valid segment (the segment whose difference between the current position and the starting position is less than or equal to k) and updates the dp[][] array to store the maximum number of prizes that can be won. The maximum number of prizes is either the maximum number of prizes won at the previous position or the maximum number of prizes won before the current valid segment plus the length of the valid segment.\\n\\nThe code continues to do this for each position until the end of the prizePositions array. The final result is stored in dp[2][n], which is the maximum number of prizes that can be won for k jumps starting from the first position and ending at the last position.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeWin(int[] prizePositions, int k) {\\n        int n = prizePositions.length;\\n        //dp to store the maximum number of prizes that can be won at each position\\n        int dp[][] = new int[3][n+1];\\n\\n        for(int i=1;i<3;i++){\\n            int start = 1;\\n            for(int j=1;j<=n;j++){\\n                //if segment becomes greater than k, increase start to make it valid again.\\n                while(prizePositions[j-1]- prizePositions[start-1] > k){\\n                    start++;\\n                }\\n                //update the dp by taking the maximum between the maximum number of prizes at the previous position and the maximum number of prizes in the current valid segment plus the length of the valid segment.\\n                dp[i][j] = Math.max(dp[i][j-1], dp[i-1][start-1] + j-start +1);\\n            }\\n        }\\n        return dp[2][n];        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeWin(int[] prizePositions, int k) {\\n        int n = prizePositions.length;\\n        //dp to store the maximum number of prizes that can be won at each position\\n        int dp[][] = new int[3][n+1];\\n\\n        for(int i=1;i<3;i++){\\n            int start = 1;\\n            for(int j=1;j<=n;j++){\\n                //if segment becomes greater than k, increase start to make it valid again.\\n                while(prizePositions[j-1]- prizePositions[start-1] > k){\\n                    start++;\\n                }\\n                //update the dp by taking the maximum between the maximum number of prizes at the previous position and the maximum number of prizes in the current valid segment plus the length of the valid segment.\\n                dp[i][j] = Math.max(dp[i][j-1], dp[i-1][start-1] + j-start +1);\\n            }\\n        }\\n        return dp[2][n];        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142040,
                "title": "recursion-memoization-in-cpp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int func(int i,vector<int>&p,int k,int t,vector<vector<int>>&dp){\\n\\n        if(i>=p.size())return 0;\\n        if(t<=0)return 0;\\n\\n        if(dp[i][t]!=-1)return dp[i][t];\\n\\n        int a=0,b=0;\\n\\n         int ind=upper_bound(p.begin(),p.end(),p[i]+k)-p.begin();\\n\\n        // cout<<ind<<\" \";\\n        b=ind-i+func(ind,p,k,t-1,dp);\\n\\n        a=func(i+1,p,k,t,dp);\\n       \\n\\n        return dp[i][t] = max(a,b);\\n    }\\n\\n    int maximizeWin(vector<int>& p, int k) {\\n       \\n       vector<vector<int>>dp(p.size(),vector<int>(3,-1));\\n       return func(0,p,k,2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int func(int i,vector<int>&p,int k,int t,vector<vector<int>>&dp){\\n\\n        if(i>=p.size())return 0;\\n        if(t<=0)return 0;\\n\\n        if(dp[i][t]!=-1)return dp[i][t];\\n\\n        int a=0,b=0;\\n\\n         int ind=upper_bound(p.begin(),p.end(),p[i]+k)-p.begin();\\n\\n        // cout<<ind<<\" \";\\n        b=ind-i+func(ind,p,k,t-1,dp);\\n\\n        a=func(i+1,p,k,t,dp);\\n       \\n\\n        return dp[i][t] = max(a,b);\\n    }\\n\\n    int maximizeWin(vector<int>& p, int k) {\\n       \\n       vector<vector<int>>dp(p.size(),vector<int>(3,-1));\\n       return func(0,p,k,2,dp);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3141676,
                "title": "c-solution-with-upper-bound-suffix-maximum-array",
                "content": "# Time Complexity: $$O(nlog(n))$$\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int maximizeWin(vector<int>& a, int k) \\n    {\\n        int n = a.size();\\n        vector<pair<int, int>> b(n), s(n);\\n        for (int i = 0; i < n; ++i)\\n        {\\n            int target = a[i] + k;\\n            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);\\n            b[i] = {i, idx};\\n        }\\n        \\n        int mx = 0;\\n        pair<int, int> curr;\\n        for (int i = n - 1; i >= 0; --i)\\n        {\\n            if (b[i].second - b[i].first + 1 > mx)\\n            {\\n                mx = b[i].second - b[i].first + 1;\\n                curr = {b[i].first, b[i].second}; \\n            }\\n            \\n            s[i] = curr;\\n        }\\n        \\n        int res = 1;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            int j = b[i].second;\\n            \\n            res = max(res, b[i].second - b[i].first + 1 + s[j].second - s[j].first + 1 - (s[j].first == b[i].second));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maximizeWin(vector<int>& a, int k) \\n    {\\n        int n = a.size();\\n        vector<pair<int, int>> b(n), s(n);\\n        for (int i = 0; i < n; ++i)\\n        {\\n            int target = a[i] + k;\\n            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);\\n            b[i] = {i, idx};\\n        }\\n        \\n        int mx = 0;\\n        pair<int, int> curr;\\n        for (int i = n - 1; i >= 0; --i)\\n        {\\n            if (b[i].second - b[i].first + 1 > mx)\\n            {\\n                mx = b[i].second - b[i].first + 1;\\n                curr = {b[i].first, b[i].second}; \\n            }\\n            \\n            s[i] = curr;\\n        }\\n        \\n        int res = 1;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            int j = b[i].second;\\n            \\n            res = max(res, b[i].second - b[i].first + 1 + s[j].second - s[j].first + 1 - (s[j].first == b[i].second));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044812,
                "title": "golang-sliding-solution",
                "content": "# Code\\n```go\\nfunc maximizeWin(prizePositions []int, k int) int {\\n\\thash := make(map[int]int)\\n\\tfor _, p := range prizePositions {\\n\\t\\thash[p]++\\n\\t}\\n\\tkeys := make([]int, 0, len(hash))\\n\\tfor k := range hash {\\n\\t\\tkeys = append(keys, k)\\n\\t}\\n\\tsort.Ints(keys)\\n\\tl1, r1 := 0, 0\\n\\tmaxWinScore := hash[keys[0]]\\n\\tfor r1+1 < len(keys) && keys[r1+1] - keys[l1] <= k {\\n\\t\\tr1++\\n\\t\\tmaxWinScore += hash[keys[r1]]\\n\\t}\\n\\tif r1 + 1 >= len(keys) {\\n\\t\\treturn maxWinScore\\n\\t}\\n\\tmaxLine1 := maxWinScore\\n\\tcurLine1 := maxWinScore\\n\\tmaxWinScore += hash[keys[r1+1]]\\n\\tl2, r2 := r1+1, r1+1\\n\\tfor r2+1 < len(keys) && keys[r2+1] - keys[l2] <= k {\\n\\t\\tr2++\\n\\t\\tmaxWinScore += hash[keys[r2]]\\n\\t}\\n\\tcurLine2 := maxWinScore - curLine1\\n\\tfor r2 + 1 < len(keys) {\\n\\t\\tr2++\\n\\t\\tcurLine2 += hash[keys[r2]]\\n\\t\\tfor keys[r2] - keys[l2] > k {\\n\\t\\t\\tcurLine2 -= hash[keys[l2]]\\n\\t\\t\\tl2++\\n\\t\\t}\\n\\t\\tfor r1 + 1 < l2 {\\n\\t\\t\\tr1++\\n\\t\\t\\tcurLine1 += hash[keys[r1]]\\n\\t\\t\\tfor keys[r1] - keys[l1] > k {\\n\\t\\t\\t\\tcurLine1 -= hash[keys[l1]]\\n\\t\\t\\t\\tl1++\\n\\t\\t\\t}\\n\\t\\t\\tif curLine1 > maxLine1 {\\n\\t\\t\\t\\tmaxLine1 = curLine1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif maxLine1 + curLine2 > maxWinScore {\\n\\t\\t\\tmaxWinScore = maxLine1 + curLine2\\n\\t\\t}\\n\\t}\\n\\treturn maxWinScore\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sliding Window"
                ],
                "code": "```go\\nfunc maximizeWin(prizePositions []int, k int) int {\\n\\thash := make(map[int]int)\\n\\tfor _, p := range prizePositions {\\n\\t\\thash[p]++\\n\\t}\\n\\tkeys := make([]int, 0, len(hash))\\n\\tfor k := range hash {\\n\\t\\tkeys = append(keys, k)\\n\\t}\\n\\tsort.Ints(keys)\\n\\tl1, r1 := 0, 0\\n\\tmaxWinScore := hash[keys[0]]\\n\\tfor r1+1 < len(keys) && keys[r1+1] - keys[l1] <= k {\\n\\t\\tr1++\\n\\t\\tmaxWinScore += hash[keys[r1]]\\n\\t}\\n\\tif r1 + 1 >= len(keys) {\\n\\t\\treturn maxWinScore\\n\\t}\\n\\tmaxLine1 := maxWinScore\\n\\tcurLine1 := maxWinScore\\n\\tmaxWinScore += hash[keys[r1+1]]\\n\\tl2, r2 := r1+1, r1+1\\n\\tfor r2+1 < len(keys) && keys[r2+1] - keys[l2] <= k {\\n\\t\\tr2++\\n\\t\\tmaxWinScore += hash[keys[r2]]\\n\\t}\\n\\tcurLine2 := maxWinScore - curLine1\\n\\tfor r2 + 1 < len(keys) {\\n\\t\\tr2++\\n\\t\\tcurLine2 += hash[keys[r2]]\\n\\t\\tfor keys[r2] - keys[l2] > k {\\n\\t\\t\\tcurLine2 -= hash[keys[l2]]\\n\\t\\t\\tl2++\\n\\t\\t}\\n\\t\\tfor r1 + 1 < l2 {\\n\\t\\t\\tr1++\\n\\t\\t\\tcurLine1 += hash[keys[r1]]\\n\\t\\t\\tfor keys[r1] - keys[l1] > k {\\n\\t\\t\\t\\tcurLine1 -= hash[keys[l1]]\\n\\t\\t\\t\\tl1++\\n\\t\\t\\t}\\n\\t\\t\\tif curLine1 > maxLine1 {\\n\\t\\t\\t\\tmaxLine1 = curLine1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif maxLine1 + curLine2 > maxWinScore {\\n\\t\\t\\tmaxWinScore = maxLine1 + curLine2\\n\\t\\t}\\n\\t}\\n\\treturn maxWinScore\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947918,
                "title": "python-medium",
                "content": "```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n\\n        N = len(prizePositions)\\n\\n        dp = [0] * (N + 1)\\n\\n        l = 0\\n\\n        ans = 0\\n\\n        for r in range(N):\\n\\n            while prizePositions[l] + k < prizePositions[r]:\\n                l += 1\\n\\n            dp[r + 1] = max(dp[r], r - l + 1)\\n\\n            ans = max(ans, dp[l] + r - l + 1)\\n        \\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n\\n        N = len(prizePositions)\\n\\n        dp = [0] * (N + 1)\\n\\n        l = 0\\n\\n        ans = 0\\n\\n        for r in range(N):\\n\\n            while prizePositions[l] + k < prizePositions[r]:\\n                l += 1\\n\\n            dp[r + 1] = max(dp[r], r - l + 1)\\n\\n            ans = max(ans, dp[l] + r - l + 1)\\n        \\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937853,
                "title": "python-sliding-window-o-n-clean-code-intuition-similar-problem",
                "content": "# Intuition\\nThis is the same problem as:\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/editorial, Approach 1: Bidirectional Dynamic Programming, where you want a max to the left of i and a max to the right of i.\\n\\n# Approach\\n1. Use a counter to get a num -> count mapping so the distance to iterate becomes less\\n2. Make an array in_span_l which is the maximum possible score making a span to the left of this index. Use a sliding window to compute this, tracking all numbers within k span of the index. \\n3. Similarly, make an array in_span_r is the maximum possible to the right of this index. \\n4. The max is max(in_span_l[i] + in_span_r[i + 1]) for any i        \\n```\\n1 2 3 5 7    num\\n2 2 2 1 2    count of num\\n2 4 6 6 6    in_span_l\\n6 4 3 3 2    in_span_r\\n```\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n\\n        counts = Counter(prizePositions)\\n        counts_arr = [(num, count) for num, count in counts.items()]\\n        if len(counts_arr) == 1:\\n            return counts_arr[0][1]\\n        num_ind = list(counts.keys())\\n        in_span = []\\n        rolling_count = 0\\n        j = 0\\n        pre = -inf\\n        for i in range(len(counts_arr)):\\n            rolling_count += counts_arr[i][1]\\n            while num_ind[i] - num_ind[j] > k:\\n                rolling_count -= counts_arr[j][1]\\n                j += 1\\n            in_span.append(max(rolling_count, pre))\\n            pre = max(rolling_count, pre)\\n\\n        in_span_r = []\\n        rolling_count = 0\\n        j = len(counts_arr) - 1\\n        pre = -inf\\n        for i in range(len(counts_arr) - 1, -1, -1):\\n            rolling_count += counts_arr[i][1]\\n            while num_ind[j] - num_ind[i] > k:\\n                rolling_count -= counts_arr[j][1]\\n                j -= 1\\n            in_span_r.append(max(rolling_count, pre))\\n            pre = max(rolling_count, pre)\\n        in_span_r = list(reversed(in_span_r))\\n        # print(list(range(len(counts_arr))), \\'i\\')\\n        # print(list(counts.keys()), \\'num\\')\\n        # print(list(counts.values()), \\'count of num\\')\\n        # print(in_span, \\'span_l\\')\\n        # print(in_span_r, \\'span_r\\')\\n        max_all = -inf\\n        for i in range(len(in_span) - 1):\\n            max_all = max(max_all, in_span[i] + in_span_r[i + 1])\\n        return max_all\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n1 2 3 5 7    num\\n2 2 2 1 2    count of num\\n2 4 6 6 6    in_span_l\\n6 4 3 3 2    in_span_r\\n```\n```\\n\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n\\n        counts = Counter(prizePositions)\\n        counts_arr = [(num, count) for num, count in counts.items()]\\n        if len(counts_arr) == 1:\\n            return counts_arr[0][1]\\n        num_ind = list(counts.keys())\\n        in_span = []\\n        rolling_count = 0\\n        j = 0\\n        pre = -inf\\n        for i in range(len(counts_arr)):\\n            rolling_count += counts_arr[i][1]\\n            while num_ind[i] - num_ind[j] > k:\\n                rolling_count -= counts_arr[j][1]\\n                j += 1\\n            in_span.append(max(rolling_count, pre))\\n            pre = max(rolling_count, pre)\\n\\n        in_span_r = []\\n        rolling_count = 0\\n        j = len(counts_arr) - 1\\n        pre = -inf\\n        for i in range(len(counts_arr) - 1, -1, -1):\\n            rolling_count += counts_arr[i][1]\\n            while num_ind[j] - num_ind[i] > k:\\n                rolling_count -= counts_arr[j][1]\\n                j -= 1\\n            in_span_r.append(max(rolling_count, pre))\\n            pre = max(rolling_count, pre)\\n        in_span_r = list(reversed(in_span_r))\\n        # print(list(range(len(counts_arr))), \\'i\\')\\n        # print(list(counts.keys()), \\'num\\')\\n        # print(list(counts.values()), \\'count of num\\')\\n        # print(in_span, \\'span_l\\')\\n        # print(in_span_r, \\'span_r\\')\\n        max_all = -inf\\n        for i in range(len(in_span) - 1):\\n            max_all = max(max_all, in_span[i] + in_span_r[i + 1])\\n        return max_all\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931859,
                "title": "swift-dp-sliding-segment-o-n",
                "content": "# Intuition\\nThe problem of maximizing wins from one segment, can be effectively solved using a sliding window approach. By utilizing this approach, we can calculate the outcome by considering the dynamic programming (dp) values.\\n\\n# Approach\\nTo solve this problem, we establish a sliding segment, resembling a sliding window, where the difference between A[i] and A[j] is less than or equal to k.\\n\\nThe dp array dp[k] signifies the maximum number of elements we can encompass if we optimally choose a single segment within the first k elements.\\n\\nAs we shift a segment from the left to the right, the count of elements covered by this segment is given by i - j + 1. Additionally, within the initial j elements, we are capable of covering at most dp[j] elements.\\n\\nIn total, we can cover i - j + 1 + dp[j] elements. Continuously update the result res during this process. Ultimately, return the value of res.\\n\\nThis approach offers a clear way to maximize the count of prizes won through strategically selecting two segments while adhering to the specified conditions.\\n\\n# Complexity\\n\\n- Time complexity: `O(n)`\\n\\n- Space complexity: `O(n)`\\n\\n# Code\\n```\\nclass Solution {\\n    func maximizeWin(_ prizePositions: [Int], _ k: Int) -> Int {\\n        var res = 0\\n        let n = prizePositions.count\\n        var j = 0\\n        var dp = Array(repeating: 0, count: n + 1)\\n        \\n        for i in 0..<n {\\n            while j < n && prizePositions[j] < prizePositions[i] - k {\\n                j += 1\\n            }\\n            dp[i + 1] = max(dp[i], i - j + 1)\\n            res = max(res, i - j + 1 + dp[j])\\n        }\\n        \\n        return res\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximizeWin(_ prizePositions: [Int], _ k: Int) -> Int {\\n        var res = 0\\n        let n = prizePositions.count\\n        var j = 0\\n        var dp = Array(repeating: 0, count: n + 1)\\n        \\n        for i in 0..<n {\\n            while j < n && prizePositions[j] < prizePositions[i] - k {\\n                j += 1\\n            }\\n            dp[i + 1] = max(dp[i], i - j + 1)\\n            res = max(res, i - j + 1 + dp[j])\\n        }\\n        \\n        return res\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880763,
                "title": "python-o-n-runtime-o-1-space",
                "content": "# Approach\\n$$Iterate$$ with $$head$$ right to left.\\nAt any iteration maintain the following:\\n- longest segment that ends exactly at $$head$$ on the right side of the segment: $$currLeft$$ stands for the number of prizes in this segment and $$leftEdge$$ stands for the left edge of the segment\\n- longest segment that ends exactly at $$head$$ on the left side of the segment : $$currRight$$ stands for the number of prizes in this segment and $$rightEdge$$ stands for the right edge of the segment\\n- number of prizes in the longest segment that ends at some indx larger or equal than $$head$$ on the left side of the segment: $$bestRight$$\\n- best result until now: $$best$$\\n\\nat any iteration of $$head$$ we:\\n - update $$currLeft$$ and $$leftEdge$$  by iterating left with $$leftEdge$$ as long as the segment is valid.\\n - update $$currRight$$ and $$rightEdge$$  by iterating left with $$rightEdge$$ as long as the segment is not valid.\\n - update $$bestRight$$ as max($$bestRight$$, $$currRight$$)\\n - update $best$ as max($best$, $$currLeft$$ + $$bestRight$$)\\n\\nat the end return $best$.\\ncorrectness follows straight forward from the algorithm description\\nLets say for example that the best segments to pick are [10,30], [80,100] so by the time head got to 30 we already accounted for  [80,100]\\nand now we have [10,30] in our hands, so we will account for this solution. (obviously we will never account a non existing solution so all good)\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$\\n$$leftEdge$$, $$rightEdge$$, $$head$$ always advance left and at each advnacment we do O(1) operations so all good.\\n- Space complexity:\\n$$O(1)$$: we simply hold 7 variables \\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximizeWin(self, prizePositions, k):\\n        \"\"\"\\n        :type prizePositions: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        N = len(prizePositions)\\n        head, left_edge, right_edge, curr_left, curr_right, best_right, best = N-1, N, N-1, 1, 0, 0, 0\\n        \\n        while head >= 0:\\n            curr_left -= 1\\n            while (left_edge > 0) and (prizePositions[head] - prizePositions[left_edge - 1] <= k):\\n                left_edge -= 1\\n                curr_left += 1\\n            best = max(best, best_right + curr_left)\\n            curr_right += 1\\n            while prizePositions[right_edge] - prizePositions[head] > k:\\n                curr_right -= 1\\n                right_edge -= 1\\n            best_right = max(best_right, curr_right)\\n            head -= 1\\n        return best\\n\\n\\n\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximizeWin(self, prizePositions, k):\\n        \"\"\"\\n        :type prizePositions: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        N = len(prizePositions)\\n        head, left_edge, right_edge, curr_left, curr_right, best_right, best = N-1, N, N-1, 1, 0, 0, 0\\n        \\n        while head >= 0:\\n            curr_left -= 1\\n            while (left_edge > 0) and (prizePositions[head] - prizePositions[left_edge - 1] <= k):\\n                left_edge -= 1\\n                curr_left += 1\\n            best = max(best, best_right + curr_left)\\n            curr_right += 1\\n            while prizePositions[right_edge] - prizePositions[head] > k:\\n                curr_right -= 1\\n                right_edge -= 1\\n            best_right = max(best_right, curr_right)\\n            head -= 1\\n        return best\\n\\n\\n\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869337,
                "title": "ruby-o-n",
                "content": "\\n```ruby\\n# @param {Integer[]} prize_positions\\n# @param {Integer} k\\n# @return {Integer}\\ndef maximize_win(prize_positions, k)\\n  # dp[idx] := max prize if one optimal segment is chosen among the first k prizes\\n  dp = Array.new(prize_positions.length + 1, 0)\\n  res, left = 0, 0\\n  for right in 0...prize_positions.length\\n    while prize_positions[right] - prize_positions[left] > k\\n      left += 1\\n    end\\n    dp[right + 1] = [dp[right], right - left + 1].max\\n    res = [res, right - left + 1 + dp[left]].max\\n  end\\n  res\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer[]} prize_positions\\n# @param {Integer} k\\n# @return {Integer}\\ndef maximize_win(prize_positions, k)\\n  # dp[idx] := max prize if one optimal segment is chosen among the first k prizes\\n  dp = Array.new(prize_positions.length + 1, 0)\\n  res, left = 0, 0\\n  for right in 0...prize_positions.length\\n    while prize_positions[right] - prize_positions[left] > k\\n      left += 1\\n    end\\n    dp[right + 1] = [dp[right], right - left + 1].max\\n    res = [res, right - left + 1 + dp[left]].max\\n  end\\n  res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3793156,
                "title": "fully-explained-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    int maximizeWin(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int>v(n);\\n      // this vector store how much element if take nums[i] starting x-cordinates\\n      // That means number of element between [nums[i],nums[i]+k];\\n        for(int i = 0;i<nums.size();i++){\\n                int x = upper_bound(nums.begin()+i,nums.end(),nums[i]+k) - nums.begin(); \\n                v[i] = x - i;\\n                cout<<v[i]<<\" \";\\n                 // as i mention above we store element between[nums[i],nums[i]+k]\\n                 // suppose we take nums[i] = 1 at i = 0 in example 1 1 2 2 3 3 5\\n                 //then x will be index = 6\\n                 // we store at i = 0 in vector v;  6 that is number of element between [nums[i],nums[i]+k] (1 , 3);\\n            } \\n\\n            //now v vector : - 6 5 5 3 3 2 1\\n\\n\\n        vector<int>suff(n);\\n        suff[n-1] = 1;\\n        // suff vector store maximum number of prize we get if we chhose index i;\\n        long long ans = 0;\\n        for(int i = n-2;i>=0;i--){\\n            suff[i] = max(suff[i+1],v[i]);\\n        }\\n        //now suff vector : - 1 2 3 3 4 5 6\\n\\n\\n        //now for getting answer\\n        for(int i = 0;i<n;i++){\\n            //suppose you chhose index i = 1,then v[i]  = 5 means it have prize so 1 + 5 = 6 \\n            // first segment is at i = 1 and second at 6\\n            // and suff vector store maximum prize you can get at index 6 suff[i+v[i]] \\n            if(i+v[i]<n){\\n                ans = max(ans,1ll*(suff[i+v[i]]+v[i]));\\n            }\\n            ans = max(ans,1ll*(v[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int maximizeWin(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int>v(n);\\n      // this vector store how much element if take nums[i] starting x-cordinates\\n      // That means number of element between [nums[i],nums[i]+k];\\n        for(int i = 0;i<nums.size();i++){\\n                int x = upper_bound(nums.begin()+i,nums.end(),nums[i]+k) - nums.begin(); \\n                v[i] = x - i;\\n                cout<<v[i]<<\" \";\\n                 // as i mention above we store element between[nums[i],nums[i]+k]\\n                 // suppose we take nums[i] = 1 at i = 0 in example 1 1 2 2 3 3 5\\n                 //then x will be index = 6\\n                 // we store at i = 0 in vector v;  6 that is number of element between [nums[i],nums[i]+k] (1 , 3);\\n            } \\n\\n            //now v vector : - 6 5 5 3 3 2 1\\n\\n\\n        vector<int>suff(n);\\n        suff[n-1] = 1;\\n        // suff vector store maximum number of prize we get if we chhose index i;\\n        long long ans = 0;\\n        for(int i = n-2;i>=0;i--){\\n            suff[i] = max(suff[i+1],v[i]);\\n        }\\n        //now suff vector : - 1 2 3 3 4 5 6\\n\\n\\n        //now for getting answer\\n        for(int i = 0;i<n;i++){\\n            //suppose you chhose index i = 1,then v[i]  = 5 means it have prize so 1 + 5 = 6 \\n            // first segment is at i = 1 and second at 6\\n            // and suff vector store maximum prize you can get at index 6 suff[i+v[i]] \\n            if(i+v[i]<n){\\n                ans = max(ans,1ll*(suff[i+v[i]]+v[i]));\\n            }\\n            ans = max(ans,1ll*(v[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3774286,
                "title": "python3-dynamic-programming",
                "content": "# Approach\\n- Need to choose at most two segment, the dfs function should go through all index or run out of two segments.\\n- There are two states in each index, pick or not pick\\n- If pick the idx, skip the value less or equal than the value plus k. \\n    ex: `prize[idx] = 1 and k = 2`\\n    It can cover from value 1 to 3, so find the next first index larger than 3, using binary search to find next index\\n- If skip the index, skip all the index with the same value.\\n    ex: `prize = [1,1,1,1,2,2,2,3,3]`\\n    If skip index 0, should also skip other index with the same value `1`, it won\\'t bring larget answer, using binary search to find the next first index of value larger than 1d\\n\\n# Complexity\\n- Time complexity:\\nO( n * log(n) *2)\\n\\n- Space complexity:\\nO( n )\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        @cache\\n        def dfs(idx, n):\\n            if idx==len(prizePositions) or n==0:\\n                return 0\\n            left = bisect.bisect_right(prizePositions, prizePositions[idx]+k)\\n            i = bisect.bisect_right(prizePositions, prizePositions[idx])\\n            a = dfs(left, n-1)+left-idx\\n            b = dfs(i, n)\\n            return max(a,b)\\n        return dfs(0, 2)\\n```\\n\\nIterator\\n```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        dp = [0 for _ in range(len(prizePositions)+1)]\\n        ans = 0\\n        for i in range(len(prizePositions)):\\n            if i>0:\\n                dp[i] = max(dp[i], dp[i-1])\\n            left = bisect.bisect_right(prizePositions, prizePositions[i]+k)\\n            dp[left] = max(dp[left], left-i)\\n            ans = max(ans, dp[i]+left-i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        @cache\\n        def dfs(idx, n):\\n            if idx==len(prizePositions) or n==0:\\n                return 0\\n            left = bisect.bisect_right(prizePositions, prizePositions[idx]+k)\\n            i = bisect.bisect_right(prizePositions, prizePositions[idx])\\n            a = dfs(left, n-1)+left-idx\\n            b = dfs(i, n)\\n            return max(a,b)\\n        return dfs(0, 2)\\n```\n```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        dp = [0 for _ in range(len(prizePositions)+1)]\\n        ans = 0\\n        for i in range(len(prizePositions)):\\n            if i>0:\\n                dp[i] = max(dp[i], dp[i-1])\\n            left = bisect.bisect_right(prizePositions, prizePositions[i]+k)\\n            dp[left] = max(dp[left], left-i)\\n            ans = max(ans, dp[i]+left-i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770593,
                "title": "dp-time-o-3-n-space-o-2-n",
                "content": "class Solution(object):\\n    def maximizeWin(self, prizePositions, k):\\n        \"\"\"\\n        :type prizePositions: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        n = len(prizePositions)\\n        \\n        jump_arr = [0 for i in range(n)]\\n        r = n-1\\n        \\n        for i in range(n-1,-1,-1):\\n            while prizePositions[r] > prizePositions[i] + k:\\n                r -= 1\\n            \\n            jump_arr[i] = r\\n        \\n        \\n        dp_prev = [0 for i in range(n)]\\n        \\n        max_so_far = 0\\n        for i in range(n-1,-1,-1):\\n            dp_prev[i] = max(jump_arr[i] - i + 1, max_so_far)\\n            max_so_far = dp_prev[i]\\n        \\n        res = 0\\n        for i in range(n-1,-1,-1):\\n            cur = jump_arr[i] - i + 1\\n            \\n            if jump_arr[i] + 1 < n:\\n                cur += dp_prev[jump_arr[i] + 1]\\n            \\n            res = max(res, cur)\\n        \\n        return res\\n\\n            \\n        \\n            \\n        \\n        \\n            \\n            \\n        \\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def maximizeWin(self, prizePositions, k):\\n        \"\"\"\\n        :type prizePositions: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        n = len(prizePositions)\\n        \\n        jump_arr = [0 for i in range(n)]\\n        r = n-1\\n        \\n        for i in range(n-1,-1,-1):\\n            while prizePositions[r] > prizePositions[i] + k:\\n                r -= 1\\n            \\n            jump_arr[i] = r\\n        \\n        \\n        dp_prev = [0 for i in range(n)]\\n        \\n        max_so_far = 0\\n        for i in range(n-1,-1,-1):\\n            dp_prev[i] = max(jump_arr[i] - i + 1, max_so_far)\\n            max_so_far = dp_prev[i]\\n        \\n        res = 0\\n        for i in range(n-1,-1,-1):\\n            cur = jump_arr[i] - i + 1\\n            \\n            if jump_arr[i] + 1 < n:\\n                cur += dp_prev[jump_arr[i] + 1]\\n            \\n            res = max(res, cur)\\n        \\n        return res\\n\\n            \\n        \\n            \\n        \\n        \\n            \\n            \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3770493,
                "title": "best-dp-binary-search-solution-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int f(int ind,int k,vector<int>&arr,int l,vector<vector<int>>&dp){\\n        if(k == 0)return 0;\\n        if(ind == arr.size())return 0;\\n\\n        if(dp[ind][k]!=-1)return dp[ind][k];\\n        int nottake = f(ind+1,k,arr,l,dp);\\n        int take = -1e9;\\n        if(k>0){\\n            int findind = lower_bound(arr.begin(),arr.end(),arr[ind]+l+1) - arr.begin();\\n            take = (findind - ind) + f(findind,k-1,arr,l,dp);\\n        }\\n        return dp[ind][k] = max(take,nottake);\\n    }\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        vector<vector<int>>dp(n+1,vector<int>(3,-1));//we can take at most 2 segment \\n        //DP + Binary search solution(c++ solution)\\n        return f(0,2,prizePositions,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int f(int ind,int k,vector<int>&arr,int l,vector<vector<int>>&dp){\\n        if(k == 0)return 0;\\n        if(ind == arr.size())return 0;\\n\\n        if(dp[ind][k]!=-1)return dp[ind][k];\\n        int nottake = f(ind+1,k,arr,l,dp);\\n        int take = -1e9;\\n        if(k>0){\\n            int findind = lower_bound(arr.begin(),arr.end(),arr[ind]+l+1) - arr.begin();\\n            take = (findind - ind) + f(findind,k-1,arr,l,dp);\\n        }\\n        return dp[ind][k] = max(take,nottake);\\n    }\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        vector<vector<int>>dp(n+1,vector<int>(3,-1));//we can take at most 2 segment \\n        //DP + Binary search solution(c++ solution)\\n        return f(0,2,prizePositions,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716533,
                "title": "simple-1d-dp-c",
                "content": "\\n\\nVariables:\\n\\nn represents the size of the input array nums.\\nstart keeps track of the starting index of the segment.\\nans stores the maximum number of prizes won.\\ndp is an auxiliary array that keeps track of the maximum number of prizes that can be won up to the current index.\\n\\n\\nIterate through the elements of prizePositions using the variable i:\\n\\nInside the loop, we find the maximum value of start such that prizePositions[i] - prizePositions[start] <= k. This means we find the leftmost element within k distance from prizePositions[i].\\nUpdate ans by comparing the current maximum with the length of the current segment (i - start + 1) plus the maximum number of prizes won from the previous segment (start > 0 ? dp[start - 1] : 0).\\nUpdate dp[i] by comparing the maximum number of prizes won up to the previous index (i > 0 ? dp[i - 1] : 0) with the length of the current segment (i - start + 1).\\nReturn the maximum number of prizes won, which is stored in ans.\\n\\nThe main idea behind this approach is to find the maximum number of prizes that can be won by selecting two segments of length k or less. By keeping track of the starting index start and updating the dp array, the algorithm efficiently finds the optimal solution in a single pass through the prizePositions array.\\n\\nThe time complexity of this code is O(n), where n is the size of the input array prizePositions. The space complexity is O(n) as well, due to the dp array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n        int maximizeWin(vector<int>& prizePositions, int k) \\n        {\\n            int n=prizePositions.size();\\n            int start =0; int ans=0;\\n            vector<int> dp(n);\\n            for(int i=0;i<n;i++)\\n            {\\n                //find leftmost element with k segement\\n                while(prizePositions[i]-prizePositions[start]>k) start++;\\n                //calculate this segment length\\n                int segmentLength = i-start+1;\\n                //maintain ans, sum of two segemtn, curr+ use dp for previous one \\n                ans = max(ans,segmentLength+(start>0?dp[start-1]:0));\\n                //update dp[i] which store maxlenght upto this index\\n                dp[i] = max((i>0 ? dp[i-1]:0),segmentLength);\\n            }\\n            return ans;\\n        }\\n    \\n//     int maximizeWin(vector<int>& prizePositions, int k) {\\n//         //FIrst to intersect na hi kr to theek , But kabhi forceful krana pdega\\n//         //maintain two max\\n        \\n//         int max1=INT_MIN,max2 =INT_MIN;\\n//         for(int i=0;i<prizePositions.size();i++)\\n//         {\\n//             int val =prizePositions[i];\\n//             int target = val+k-1; //isse bade wala pinter nikalo\\n//             int len = upper_bound(prizePositions.begin()+i,prizePositions.end(),target) - (prizePositions.begin()+i) ;\\n//             if(len>=max1)\\n//             {\\n//                 max2 =max1;\\n//                 max1 = len;\\n//             }\\n//             //update i to the pointer iterator \\n//             i=i+len; //But yhn cases miss honge overlap wale\\n//         }\\n//         return max1+max2;\\n//     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n        int maximizeWin(vector<int>& prizePositions, int k) \\n        {\\n            int n=prizePositions.size();\\n            int start =0; int ans=0;\\n            vector<int> dp(n);\\n            for(int i=0;i<n;i++)\\n            {\\n                //find leftmost element with k segement\\n                while(prizePositions[i]-prizePositions[start]>k) start++;\\n                //calculate this segment length\\n                int segmentLength = i-start+1;\\n                //maintain ans, sum of two segemtn, curr+ use dp for previous one \\n                ans = max(ans,segmentLength+(start>0?dp[start-1]:0));\\n                //update dp[i] which store maxlenght upto this index\\n                dp[i] = max((i>0 ? dp[i-1]:0),segmentLength);\\n            }\\n            return ans;\\n        }\\n    \\n//     int maximizeWin(vector<int>& prizePositions, int k) {\\n//         //FIrst to intersect na hi kr to theek , But kabhi forceful krana pdega\\n//         //maintain two max\\n        \\n//         int max1=INT_MIN,max2 =INT_MIN;\\n//         for(int i=0;i<prizePositions.size();i++)\\n//         {\\n//             int val =prizePositions[i];\\n//             int target = val+k-1; //isse bade wala pinter nikalo\\n//             int len = upper_bound(prizePositions.begin()+i,prizePositions.end(),target) - (prizePositions.begin()+i) ;\\n//             if(len>=max1)\\n//             {\\n//                 max2 =max1;\\n//                 max1 = len;\\n//             }\\n//             //update i to the pointer iterator \\n//             i=i+len; //But yhn cases miss honge overlap wale\\n//         }\\n//         return max1+max2;\\n//     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712730,
                "title": "2p-dp",
                "content": "**time: `O(N)`; space: `O(N)`**\\n```\\nint maximizeWin(vector<int>& x, int k) \\n{\\n\\tint out{}; \\n\\tfor(int i{}, j{}, d[100002]{}; i<size(x); )\\n\\t\\tif(x[i]-x[j]<=k)\\n\\t\\t\\t++i,\\n\\t\\t\\td[i] = max(d[i-1], i-j),\\n            out  = max(out,    i-j+d[j]);\\n\\t\\telse\\n\\t\\t\\t++j;\\n\\treturn out;         \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maximizeWin(vector<int>& x, int k) \\n{\\n\\tint out{}; \\n\\tfor(int i{}, j{}, d[100002]{}; i<size(x); )\\n\\t\\tif(x[i]-x[j]<=k)\\n\\t\\t\\t++i,\\n\\t\\t\\td[i] = max(d[i-1], i-j),\\n            out  = max(out,    i-j+d[j]);\\n\\t\\telse\\n\\t\\t\\t++j;\\n\\treturn out;         \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588901,
                "title": "o-n-approach-using-dynamic-programming-and-sliding-window",
                "content": "# Approach\\nDynamic Programming with Sliding Window\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximizeWin(self, P, k):\\n        #Have a dp array to record the max length of the first segment at i:\\n        dp = [0] * len(P)\\n        res = 0\\n        left = 0 # first pointer of the sliding window\\n        for right in range(len(P)):\\n            while P[right] - P[left] > k:\\n                # sliding window, contract left if (P[left],P[right]) is not a valid segment\\n                left += 1\\n\\n            # now, (left, right) is valid\\n            # calculate this segment length starts from left to right\\n            this_segment = right - left + 1\\n\\n            # first max segment length is the dp[left-1] because this segment starts from left\\n            first_segment = dp[left-1]\\n\\n            # result is the max of current res or (first_segment + second segment(this_segment))\\n            res = max(res, first_segment + this_segment)\\n\\n            # dp[right] is the max of dp[right-1] or this_segment\\n            dp[right] = max(dp[right-1], this_segment)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximizeWin(self, P, k):\\n        #Have a dp array to record the max length of the first segment at i:\\n        dp = [0] * len(P)\\n        res = 0\\n        left = 0 # first pointer of the sliding window\\n        for right in range(len(P)):\\n            while P[right] - P[left] > k:\\n                # sliding window, contract left if (P[left],P[right]) is not a valid segment\\n                left += 1\\n\\n            # now, (left, right) is valid\\n            # calculate this segment length starts from left to right\\n            this_segment = right - left + 1\\n\\n            # first max segment length is the dp[left-1] because this segment starts from left\\n            first_segment = dp[left-1]\\n\\n            # result is the max of current res or (first_segment + second segment(this_segment))\\n            res = max(res, first_segment + this_segment)\\n\\n            # dp[right] is the max of dp[right-1] or this_segment\\n            dp[right] = max(dp[right-1], this_segment)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514177,
                "title": "store-longest-range-in-left-and-right-using-sliding-window",
                "content": "```\\nclass Solution:\\n    def maximizeWin(self, pos, k):\\n        n = len(pos)\\n        l = [0] * n\\n        r = [0] * n\\n        i = 0\\n        for j in range(n):\\n            while i < j and pos[j] - pos[i] > k:\\n                i += 1\\n            if pos[j] - pos[i] <= k:\\n                l[j] = j - i + 1\\n        i = n - 1\\n        for j in range(n - 1, -1, -1):\\n            while i > j and pos[i] - pos[j] > k:\\n                i -= 1\\n            if pos[i] - pos[j] <= k:\\n                r[j] = i - j + 1\\n        res = 0\\n        maxleft = 0\\n        for i in range(n):\\n            res = max(res, maxleft + r[i])\\n            maxleft = max(maxleft, l[i])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximizeWin(self, pos, k):\\n        n = len(pos)\\n        l = [0] * n\\n        r = [0] * n\\n        i = 0\\n        for j in range(n):\\n            while i < j and pos[j] - pos[i] > k:\\n                i += 1\\n            if pos[j] - pos[i] <= k:\\n                l[j] = j - i + 1\\n        i = n - 1\\n        for j in range(n - 1, -1, -1):\\n            while i > j and pos[i] - pos[j] > k:\\n                i -= 1\\n            if pos[i] - pos[j] <= k:\\n                r[j] = i - j + 1\\n        res = 0\\n        maxleft = 0\\n        for i in range(n):\\n            res = max(res, maxleft + r[i])\\n            maxleft = max(maxleft, l[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396868,
                "title": "c-dp-sliding-window-approaches",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int res =0;;\\n        int n = prizePositions.size();\\n        int j=0;\\n\\n        vector<int>dp(n+1,0);\\n        for(int i=0;i<n;i++){\\n            while(prizePositions[j]<prizePositions[i]-k)\\n                j++;\\n            \\n            dp[i+1] = max(dp[i],i-j+1);\\n            res = max(res,i-j+1+dp[j]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int res =0;;\\n        int n = prizePositions.size();\\n        int j=0;\\n\\n        vector<int>dp(n+1,0);\\n        for(int i=0;i<n;i++){\\n            while(prizePositions[j]<prizePositions[i]-k)\\n                j++;\\n            \\n            dp[i+1] = max(dp[i],i-j+1);\\n            res = max(res,i-j+1+dp[j]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281726,
                "title": "use-two-points-cleverly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeWin(self, p: List[int], k: int) -> int:\\n        i,n = 0,len(p)\\n        if p[-1] - p[0] <= k:\\n            return n\\n        pre = [0]\\n        i = 0\\n        for j in range(1,n):\\n            if p[j] - p[i] > k:\\n                i += 1\\n            else:\\n                pre.append(j)\\n        sub = [n-1]\\n        j = n-1\\n        for i in range(n-2,-1,-1):\\n            if p[j] - p[i] > k:\\n                j -= 1\\n            else:\\n                sub.append(i)\\n        \\n        sub = sub[::-1]\\n        i,j = 0,0\\n        ans = -len(sub)\\n        while i < len(pre) and j < len(sub):\\n            if pre[i] >= sub[j]:\\n                j += 1\\n            else:\\n                ans = max(i-j,ans)\\n                i += 1\\n        return ans  + len(sub) + 1\\n\\n\\n\\n                \\n            \\n\\n            \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeWin(self, p: List[int], k: int) -> int:\\n        i,n = 0,len(p)\\n        if p[-1] - p[0] <= k:\\n            return n\\n        pre = [0]\\n        i = 0\\n        for j in range(1,n):\\n            if p[j] - p[i] > k:\\n                i += 1\\n            else:\\n                pre.append(j)\\n        sub = [n-1]\\n        j = n-1\\n        for i in range(n-2,-1,-1):\\n            if p[j] - p[i] > k:\\n                j -= 1\\n            else:\\n                sub.append(i)\\n        \\n        sub = sub[::-1]\\n        i,j = 0,0\\n        ans = -len(sub)\\n        while i < len(pre) and j < len(sub):\\n            if pre[i] >= sub[j]:\\n                j += 1\\n            else:\\n                ans = max(i-j,ans)\\n                i += 1\\n        return ans  + len(sub) + 1\\n\\n\\n\\n                \\n            \\n\\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252701,
                "title": "python-simple-dp-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeWin(self, prizePositions, k):\\n        n = len(prizePositions)\\n\\n        left, dp, max_val = 0, [0]*(n+1), 0\\n\\n        for right in range(n):\\n            while prizePositions[right] - prizePositions[left] > k:\\n                left += 1\\n\\n            dp[right+1] = max(dp[right],right-left+1)\\n\\n            max_val = max(max_val,dp[left] + right - left + 1)\\n\\n        return max_val\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeWin(self, prizePositions, k):\\n        n = len(prizePositions)\\n\\n        left, dp, max_val = 0, [0]*(n+1), 0\\n\\n        for right in range(n):\\n            while prizePositions[right] - prizePositions[left] > k:\\n                left += 1\\n\\n            dp[right+1] = max(dp[right],right-left+1)\\n\\n            max_val = max(max_val,dp[left] + right - left + 1)\\n\\n        return max_val\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201449,
                "title": "1sentence-slide-a-window-saving-best-solution-so-far-return-max-sum-window-best-to-the-left",
                "content": "# Upvote if you like the simplicity\\n\\n```\\ndef maximizeWin(self, prizes: List[int], k: int) -> int:\\n    bestBefore = [0] * (len(prizes) + 1)\\n    bestBeforeSoFar = 0\\n    ret = 0\\n    runSum = 0\\n    i, j = 0, 0\\n    while j<len(prizes):\\n        x = prizes[j]\\n        while j<len(prizes) and prizes[j] == x:\\n            runSum += 1\\n            j += 1\\n        while prizes[i] + k < prizes[j-1]:\\n            runSum -= 1\\n            i += 1  # i points to the first included price index\\n        bestBeforeSoFar = max(bestBeforeSoFar, runSum)\\n        bestBefore[j] = bestBeforeSoFar\\n        ret = max(ret, runSum + bestBefore[i])\\n    return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef maximizeWin(self, prizes: List[int], k: int) -> int:\\n    bestBefore = [0] * (len(prizes) + 1)\\n    bestBeforeSoFar = 0\\n    ret = 0\\n    runSum = 0\\n    i, j = 0, 0\\n    while j<len(prizes):\\n        x = prizes[j]\\n        while j<len(prizes) and prizes[j] == x:\\n            runSum += 1\\n            j += 1\\n        while prizes[i] + k < prizes[j-1]:\\n            runSum -= 1\\n            i += 1  # i points to the first included price index\\n        bestBeforeSoFar = max(bestBeforeSoFar, runSum)\\n        bestBefore[j] = bestBeforeSoFar\\n        ret = max(ret, runSum + bestBefore[i])\\n    return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3201109,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n\\n        prefix = [0] * len(prizePositions)\\n        sufix = [0] * len(prizePositions)\\n        prefix[0] = 1\\n        sufix[-1] = 1\\n        left, right = 0, 1\\n        while right < len(prizePositions):\\n            if prizePositions[right] - prizePositions[left] <= k:\\n                prefix[right] = max(prefix[right - 1], right - left + 1)\\n                right += 1\\n            else:\\n                left += 1\\n\\n        left, right = len(prizePositions) - 2, len(prizePositions) - 1\\n        while left >= 0:\\n            if prizePositions[right] - prizePositions[left] <= k:\\n                sufix[left] = max(sufix[left + 1], right - left + 1)\\n                left -= 1\\n            else:\\n                right -= 1\\n                \\n        \\n        ans = 0\\n        print(prefix)\\n        print(sufix)\\n        for border in range(len(prizePositions) + 1):\\n            p = prefix[border - 1] if border > 0 else 0\\n            s = sufix[border] if border < len(prizePositions) else 0\\n            l = p + s\\n            ans = max(ans, l)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n\\n        prefix = [0] * len(prizePositions)\\n        sufix = [0] * len(prizePositions)\\n        prefix[0] = 1\\n        sufix[-1] = 1\\n        left, right = 0, 1\\n        while right < len(prizePositions):\\n            if prizePositions[right] - prizePositions[left] <= k:\\n                prefix[right] = max(prefix[right - 1], right - left + 1)\\n                right += 1\\n            else:\\n                left += 1\\n\\n        left, right = len(prizePositions) - 2, len(prizePositions) - 1\\n        while left >= 0:\\n            if prizePositions[right] - prizePositions[left] <= k:\\n                sufix[left] = max(sufix[left + 1], right - left + 1)\\n                left -= 1\\n            else:\\n                right -= 1\\n                \\n        \\n        ans = 0\\n        print(prefix)\\n        print(sufix)\\n        for border in range(len(prizePositions) + 1):\\n            p = prefix[border - 1] if border > 0 else 0\\n            s = sufix[border] if border < len(prizePositions) else 0\\n            l = p + s\\n            ans = max(ans, l)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200803,
                "title": "prefix-suffix-bs-using-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximizeWin(self, pp: List[int], k: int) -> int:\\n        n=len(pp)\\n        \\n        pre=[0]*(n)\\n        suff=[0]*(n)\\n        \\n        for i in range(n-1,-1,-1):\\n            pos=bisect_right(pp,pp[i]+k)\\n            if i==n-1:\\n                suff[i]=pos-i\\n            else:\\n                suff[i]=max(pos-i,suff[i+1])\\n                \\n            pos=bisect_right(pp,pp[i]-k-1)\\n            pre[i]=i-pos+1\\n            \\n        for i in range(1,n):\\n            pre[i]=max(pre[i-1],pre[i])\\n        \\n        ans=pre[0]\\n        # for i in range(n-2,-1,-1):\\n        #     suff[i]=max(suff[i+1],suff[i])\\n        for i in range(n-1):\\n            ans=max(ans,pre[i]+suff[i+1])\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeWin(self, pp: List[int], k: int) -> int:\\n        n=len(pp)\\n        \\n        pre=[0]*(n)\\n        suff=[0]*(n)\\n        \\n        for i in range(n-1,-1,-1):\\n            pos=bisect_right(pp,pp[i]+k)\\n            if i==n-1:\\n                suff[i]=pos-i\\n            else:\\n                suff[i]=max(pos-i,suff[i+1])\\n                \\n            pos=bisect_right(pp,pp[i]-k-1)\\n            pre[i]=i-pos+1\\n            \\n        for i in range(1,n):\\n            pre[i]=max(pre[i-1],pre[i])\\n        \\n        ans=pre[0]\\n        # for i in range(n-2,-1,-1):\\n        #     suff[i]=max(suff[i+1],suff[i])\\n        for i in range(n-1):\\n            ans=max(ans,pre[i]+suff[i+1])\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200049,
                "title": "python-solution-using-dp",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximizeWin(self, A: List[int], k: int) -> int:\\n        dp = [0] * (len(A) + 1)\\n        res = j = 0\\n        for i, a in enumerate(A):\\n            while A[j] < A[i] - k: j += 1\\n            res = max(res, i - j + 1 + dp[j])\\n            dp[i + 1] = max(dp[i], i - j + 1)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeWin(self, A: List[int], k: int) -> int:\\n        dp = [0] * (len(A) + 1)\\n        res = j = 0\\n        for i, a in enumerate(A):\\n            while A[j] < A[i] - k: j += 1\\n            res = max(res, i - j + 1 + dp[j])\\n            dp[i + 1] = max(dp[i], i - j + 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195159,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n  func maximizeWin(_ p: [Int], _ k: Int) -> Int {\\n     p.indices.reduce(into:(0,0,[0])){while p[$0.0]<p[$1]-k{$0.0+=1};let x=$1-$0.0+1;$0.1=max($0.1,x+$0.2[$0.0]);$0.2+=[max($0.2[$1],x)]}.1\\n  }\\n}\\n```\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func maximizeWin(_ prizePositions: [Int], _ k: Int) -> Int {\\n        prizePositions.indices.reduce(into: (\\n            result: 0,\\n            trailingSegLower: 0, // lower bounds of second segment\\n            dp: [0]  // each element is max prize count (delta X) for the prize at this location\\n        )) { data, leadingSegLower in\\n            while prizePositions[data.trailingSegLower] < prizePositions[leadingSegLower] - k {\\n                data.trailingSegLower += 1\\n            }\\n            let leadingSegPrizeCount = leadingSegLower - data.trailingSegLower + 1\\n            let trailingSegPrizeCount = data.dp[data.trailingSegLower]\\n            data.result = max(data.result, leadingSegPrizeCount + trailingSegPrizeCount)\\n            data.dp.append(max(data.dp[leadingSegLower], leadingSegPrizeCount))\\n        }.result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n  func maximizeWin(_ p: [Int], _ k: Int) -> Int {\\n     p.indices.reduce(into:(0,0,[0])){while p[$0.0]<p[$1]-k{$0.0+=1};let x=$1-$0.0+1;$0.1=max($0.1,x+$0.2[$0.0]);$0.2+=[max($0.2[$1],x)]}.1\\n  }\\n}\\n```\n```\\nclass Solution {\\n    func maximizeWin(_ prizePositions: [Int], _ k: Int) -> Int {\\n        prizePositions.indices.reduce(into: (\\n            result: 0,\\n            trailingSegLower: 0, // lower bounds of second segment\\n            dp: [0]  // each element is max prize count (delta X) for the prize at this location\\n        )) { data, leadingSegLower in\\n            while prizePositions[data.trailingSegLower] < prizePositions[leadingSegLower] - k {\\n                data.trailingSegLower += 1\\n            }\\n            let leadingSegPrizeCount = leadingSegLower - data.trailingSegLower + 1\\n            let trailingSegPrizeCount = data.dp[data.trailingSegLower]\\n            data.result = max(data.result, leadingSegPrizeCount + trailingSegPrizeCount)\\n            data.dp.append(max(data.dp[leadingSegLower], leadingSegPrizeCount))\\n        }.result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184567,
                "title": "easy-c-o-n-solution-sliding-segment",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& arr, int k) {\\n        //for every index store the result\\n        vector<int> dp(arr.size());\\n        \\n        //dp[i] stores the max pos covered by any single segment of length k\\n        int res=0;\\n        int i=0;\\n        int maxiSingle=0;\\n        \\n        for(int j=0;j<arr.size();j++)\\n        {\\n            while(arr[i]< arr[j]-k)\\n                i++;\\n            int dist=j-i+1;\\n            maxiSingle=max(maxiSingle,dist);\\n            dp[j]=maxiSingle;   \\n            //arr[i..j] consits of one segment  and add the max ans for subarray [0..i-1] \\n            int curr=dist;\\n            if(i>0)\\n                curr+=dp[i-1];\\n            res=max(res,curr);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& arr, int k) {\\n        //for every index store the result\\n        vector<int> dp(arr.size());\\n        \\n        //dp[i] stores the max pos covered by any single segment of length k\\n        int res=0;\\n        int i=0;\\n        int maxiSingle=0;\\n        \\n        for(int j=0;j<arr.size();j++)\\n        {\\n            while(arr[i]< arr[j]-k)\\n                i++;\\n            int dist=j-i+1;\\n            maxiSingle=max(maxiSingle,dist);\\n            dp[j]=maxiSingle;   \\n            //arr[i..j] consits of one segment  and add the max ans for subarray [0..i-1] \\n            int curr=dist;\\n            if(i>0)\\n                curr+=dp[i-1];\\n            res=max(res,curr);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181132,
                "title": "c-solution-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) \\n    {\\n        int f[3];\\n        f[0]=f[1]=f[2]=0;\\n        queue<int>q1;\\n        queue<pair<int,int>>q2;\\n        for(auto &x:prizePositions)\\n        {\\n            f[0]+=1;\\n            q1.push(x);\\n            while(q1.size()&&q1.front()<x-k)\\n            {\\n                f[0]-=1;\\n                q1.pop();\\n            }\\n            q2.push({x,f[0]});\\n            while(q2.size()&&q2.front().first<x-k)\\n            {\\n                f[1]=max(f[1],q2.front().second);\\n                q2.pop();\\n            }\\n            f[2]=max(f[2],f[1]+f[0]);\\n        }\\n        return max({f[0],f[1],f[2]});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) \\n    {\\n        int f[3];\\n        f[0]=f[1]=f[2]=0;\\n        queue<int>q1;\\n        queue<pair<int,int>>q2;\\n        for(auto &x:prizePositions)\\n        {\\n            f[0]+=1;\\n            q1.push(x);\\n            while(q1.size()&&q1.front()<x-k)\\n            {\\n                f[0]-=1;\\n                q1.pop();\\n            }\\n            q2.push({x,f[0]});\\n            while(q2.size()&&q2.front().first<x-k)\\n            {\\n                f[1]=max(f[1],q2.front().second);\\n                q2.pop();\\n            }\\n            f[2]=max(f[2],f[1]+f[0]);\\n        }\\n        return max({f[0],f[1],f[2]});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174564,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define vi(x) vector<x>\\nint maximizeWin(vector<int>&v, int k) {\\n    ll n=v.size(), ans=0;\\n    vi(ll)dp(n);\\n    for(ll i=0, j=0;i<n;++i){\\n        while(j<i && v[i]-v[j]>k){\\n            ++j;\\n        }\\n        dp[i]=max(i?dp[i-1]:0, i-j+1);\\n        ans=max(ans, i-j+1+(j?dp[j-1]:0));\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define vi(x) vector<x>\\nint maximizeWin(vector<int>&v, int k) {\\n    ll n=v.size(), ans=0;\\n    vi(ll)dp(n);\\n    for(ll i=0, j=0;i<n;++i){\\n        while(j<i && v[i]-v[j]>k){\\n            ++j;\\n        }\\n        dp[i]=max(i?dp[i-1]:0, i-j+1);\\n        ans=max(ans, i-j+1+(j?dp[j-1]:0));\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173305,
                "title": "python-maximize-left-and-right-segments-the-best",
                "content": "# Intuition\\nSplit the prizes list such that the number of maximum-count prizes segment of length $$k$$ in left and right part of the split is maximized.\\n\\nThe Best!\\n\\n# Approach\\nUse a sliding window to build two aggregated maximums of $$k$$-length prizes counts when moving from left and from right.\\n\\nHandle a special case of singleton input array by providing a default value to the final `max()` iterator.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```py\\ndef maximizeWin(self, prizes: list[int], k: int) -> int:\\n    n, i, j = len(prizes), 0, 0\\n    left, right = [0] * n, [0] * n\\n\\n    while j != n:\\n        while prizes[j]-prizes[i] > k:\\n            i += 1\\n        left[j] = max(j-i+1, left[j-1] if j != 0 else 0)\\n        j += 1\\n    \\n    i = j = n-1\\n    while i != -1:\\n        while prizes[j]-prizes[i] > k:\\n            j -= 1\\n        right[i] = max(j-i+1, right[i+1] if i != n-1 else 0)\\n        i -= 1\\n\\n    return max((left[i] + right[i+1] for i in range(n-1)), default=n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\ndef maximizeWin(self, prizes: list[int], k: int) -> int:\\n    n, i, j = len(prizes), 0, 0\\n    left, right = [0] * n, [0] * n\\n\\n    while j != n:\\n        while prizes[j]-prizes[i] > k:\\n            i += 1\\n        left[j] = max(j-i+1, left[j-1] if j != 0 else 0)\\n        j += 1\\n    \\n    i = j = n-1\\n    while i != -1:\\n        while prizes[j]-prizes[i] > k:\\n            j -= 1\\n        right[i] = max(j-i+1, right[i+1] if i != n-1 else 0)\\n        i -= 1\\n\\n    return max((left[i] + right[i+1] for i in range(n-1)), default=n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3170339,
                "title": "c-binary-search-lower-bound-suffix-max",
                "content": "# Complexity\\n- Time complexity: O(NlogN+N+N)\\n\\n- Space complexity: O(3N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    //find last value of val\\n    //1 2 2  3 4 5\\n    //2 3 3  4 5 5\\n    int lowerBound(vector<int>& nums, int &ws,int &n, int lo , int hi, int val){\\n        int j = -1;\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n\\n            if( nums[mid] <= val ){\\n                lo = mid+1;\\n                j = mid;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n\\n        if(j == -1){\\n            return n-1;\\n        }\\n        return j;\\n    }\\n    int maximizeWin(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        int ws = k;\\n        vector<pair<int,int>> endidx(n);//{endIdx,max no.of prices}\\n        for(int i=0;i<n;i++){\\n            int val = nums[i]+k;\\n            int j = lowerBound(nums,ws,n,0,n-1,val);\\n            endidx[i].first = j;\\n            endidx[i].second = j-i+1;\\n        }\\n\\n\\n        vector<int> suffixMax(n);\\n        for(int i=n-1;i>=0;i--){\\n            if(i == n-1){\\n                suffixMax[n-1] = endidx[n-1].second;\\n            }\\n            else{\\n                suffixMax[i] = max(suffixMax[i+1],endidx[i].second);\\n            }\\n        }\\n\\n        \\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            int j = endidx[i].first;\\n            // int t = endidx[i].second + (i==n-1? 0: suffixMax[j+1]);\\n            int t;\\n            \\n            if(j == n-1){\\n                t = endidx[i].second;\\n            }\\n            else{\\n                t = endidx[i].second + suffixMax[j+1];\\n            }\\n            ans = max(ans,t);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    //find last value of val\\n    //1 2 2  3 4 5\\n    //2 3 3  4 5 5\\n    int lowerBound(vector<int>& nums, int &ws,int &n, int lo , int hi, int val){\\n        int j = -1;\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n\\n            if( nums[mid] <= val ){\\n                lo = mid+1;\\n                j = mid;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n\\n        if(j == -1){\\n            return n-1;\\n        }\\n        return j;\\n    }\\n    int maximizeWin(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        int ws = k;\\n        vector<pair<int,int>> endidx(n);//{endIdx,max no.of prices}\\n        for(int i=0;i<n;i++){\\n            int val = nums[i]+k;\\n            int j = lowerBound(nums,ws,n,0,n-1,val);\\n            endidx[i].first = j;\\n            endidx[i].second = j-i+1;\\n        }\\n\\n\\n        vector<int> suffixMax(n);\\n        for(int i=n-1;i>=0;i--){\\n            if(i == n-1){\\n                suffixMax[n-1] = endidx[n-1].second;\\n            }\\n            else{\\n                suffixMax[i] = max(suffixMax[i+1],endidx[i].second);\\n            }\\n        }\\n\\n        \\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            int j = endidx[i].first;\\n            // int t = endidx[i].second + (i==n-1? 0: suffixMax[j+1]);\\n            int t;\\n            \\n            if(j == n-1){\\n                t = endidx[i].second;\\n            }\\n            else{\\n                t = endidx[i].second + suffixMax[j+1];\\n            }\\n            ans = max(ans,t);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167992,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `prizePositions`\\n */\\nclass Solution {\\n public:\\n  int maximizeWin(const vector<int> &prizePositions, const int k) {\\n    const int n = static_cast<int>(prizePositions.size());\\n    int left[n];\\n    for (int max_prices = 0, start = 0, end = 0; end < n; ++end) {\\n      while (prizePositions[end] - prizePositions[start] > k) {\\n        ++start;\\n      }\\n      max_prices = max(max_prices, end - start + 1);\\n      left[end] = max_prices;\\n    }\\n    \\n    int right[n];\\n    for (int max_prices = 0, start = n - 1, end = n - 1; end > -1; --end) {\\n      while (prizePositions[start] - prizePositions[end] > k) {\\n        --start;\\n      }\\n      max_prices = max(max_prices, start - end + 1);\\n      right[end] = max_prices;\\n    }\\n    \\n    int ret = 0;\\n    for (int separator = 0; separator < n; ++separator) {\\n      ret = max(ret, left[separator] + (separator + 1 < n ? right[separator + 1] : 0));\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `prizePositions`\\n */\\nclass Solution {\\n public:\\n  int maximizeWin(const vector<int> &prizePositions, const int k) {\\n    const int n = static_cast<int>(prizePositions.size());\\n    int left[n];\\n    for (int max_prices = 0, start = 0, end = 0; end < n; ++end) {\\n      while (prizePositions[end] - prizePositions[start] > k) {\\n        ++start;\\n      }\\n      max_prices = max(max_prices, end - start + 1);\\n      left[end] = max_prices;\\n    }\\n    \\n    int right[n];\\n    for (int max_prices = 0, start = n - 1, end = n - 1; end > -1; --end) {\\n      while (prizePositions[start] - prizePositions[end] > k) {\\n        --start;\\n      }\\n      max_prices = max(max_prices, start - end + 1);\\n      right[end] = max_prices;\\n    }\\n    \\n    int ret = 0;\\n    for (int separator = 0; separator < n; ++separator) {\\n      ret = max(ret, left[separator] + (separator + 1 < n ? right[separator + 1] : 0));\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167396,
                "title": "java-solution-using-segment-tree",
                "content": "Consider array arr[1,1,2,2,3,3,5] and k=2 and make an array grtrOrEq which stores at index i , index of least element greater than arr[i]+k . For example grtrOrEq will look like [6, 6, 6, 6, 7, 7, 7]. Now make an array ans where at any index i ans[i]=grtrOrEq[i]-i.\\nCode for grtrOrEq array\\n```\\nfor(int i=0;i<grtrOrEq.length;i++){\\n   grtrOrEq[i]=grtrOrEq(arr,arr[i]+k);\\n}\\n```\\n\\nCode for function grtrOrEq\\n```\\npublic int grtrOrEq(long []arr,long k){\\n    int l=-1;\\n    int r=arr.length;\\n    while(l+1<r){\\n        int mid=(l+r)/2;\\n        if(arr[mid]<=k){\\n           l=mid;\\n        }else{\\n           r=mid;\\n        }\\n\\t}\\n    return r;\\n}\\n```\\n\\nCode for making ans array\\n```\\nfor(int i=0;i<n;i++){\\n     ans[i]=grtrOrEq[i]-i;\\n}\\n```\\n\\nMake a class segment tree that has two functions build and query in which build preprocesses the segment tree and query finds maximum in some range.\\nNow make a variable st of class Segment Tree and a variable sum\\nNow for each index i sum is either\\n1. Maximum of sum or ans[i] which means we are selecting two segments and they completely overlap\\n2. Maximum of sum or ans[i]+maximum in ans from index grtrOrEq[i] to last index.\\n\\n```\\nsegTree st=new segTree(n);\\nst.build(0,0,n-1,ans);\\nlong sum=0;\\nfor(int i=0;i<n;i++){\\n    sum=Math.max(ans[i],sum);\\n    sum=Math.max(sum,ans[i]+st.query(0,0,n-1,grtrOrEq[i],n-1));\\n}\\n```\\n\\nCode for Segment Tree \\n```\\npublic class segTree {\\n    private long[] seg;\\n\\n    public segTree(int size) {\\n        seg = new long[4 * size];\\n    }\\n\\n    // segment_index (0) ,low_for_arr (0), high_for_arr,arr (arr.length-1)\\n    public void build(int ind, int low, int high, long[] arr) {\\n       if (low == high) {\\n           seg[ind] = arr[low];\\n\\t\\t   return;\\n\\t\\t}\\n\\t\\tint mid = (low + high) / 2;\\n\\t\\tbuild(2 * ind + 1, low, mid, arr);\\n\\t\\tbuild(2 * ind + 2, mid + 1, high, arr);\\n\\t\\tseg[ind] = mer(seg[2 * ind + 1], seg[2 * ind + 2]);\\n\\t}\\n\\n    // ind_for_seg (0) , low_for_arr (0) , high_for_arr (arr.length-1) , l=>given\\n    // query left, r=>given query right\\n    public long query(int ind, int low, int high, int l, int r) {\\n       // NO OVERLAP\\n       if (r < low || high < l) {\\n           return Long.MIN_VALUE;\\n       }\\n       if (low >= l && high <= r) {\\n           return seg[ind];\\n       }\\n       int mid = (low + high) / 2;\\n       long left = query(2 * ind + 1, low, mid, l, r);\\n       long right = query(2 * ind + 2, mid + 1, high, l, r);\\n       return mer(left, right);\\n\\t }\\n\\n     public long mer(long left, long right) {\\n         return Math.max(left, right);\\n     }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nfor(int i=0;i<grtrOrEq.length;i++){\\n   grtrOrEq[i]=grtrOrEq(arr,arr[i]+k);\\n}\\n```\n```\\npublic int grtrOrEq(long []arr,long k){\\n    int l=-1;\\n    int r=arr.length;\\n    while(l+1<r){\\n        int mid=(l+r)/2;\\n        if(arr[mid]<=k){\\n           l=mid;\\n        }else{\\n           r=mid;\\n        }\\n\\t}\\n    return r;\\n}\\n```\n```\\nfor(int i=0;i<n;i++){\\n     ans[i]=grtrOrEq[i]-i;\\n}\\n```\n```\\nsegTree st=new segTree(n);\\nst.build(0,0,n-1,ans);\\nlong sum=0;\\nfor(int i=0;i<n;i++){\\n    sum=Math.max(ans[i],sum);\\n    sum=Math.max(sum,ans[i]+st.query(0,0,n-1,grtrOrEq[i],n-1));\\n}\\n```\n```\\npublic class segTree {\\n    private long[] seg;\\n\\n    public segTree(int size) {\\n        seg = new long[4 * size];\\n    }\\n\\n    // segment_index (0) ,low_for_arr (0), high_for_arr,arr (arr.length-1)\\n    public void build(int ind, int low, int high, long[] arr) {\\n       if (low == high) {\\n           seg[ind] = arr[low];\\n\\t\\t   return;\\n\\t\\t}\\n\\t\\tint mid = (low + high) / 2;\\n\\t\\tbuild(2 * ind + 1, low, mid, arr);\\n\\t\\tbuild(2 * ind + 2, mid + 1, high, arr);\\n\\t\\tseg[ind] = mer(seg[2 * ind + 1], seg[2 * ind + 2]);\\n\\t}\\n\\n    // ind_for_seg (0) , low_for_arr (0) , high_for_arr (arr.length-1) , l=>given\\n    // query left, r=>given query right\\n    public long query(int ind, int low, int high, int l, int r) {\\n       // NO OVERLAP\\n       if (r < low || high < l) {\\n           return Long.MIN_VALUE;\\n       }\\n       if (low >= l && high <= r) {\\n           return seg[ind];\\n       }\\n       int mid = (low + high) / 2;\\n       long left = query(2 * ind + 1, low, mid, l, r);\\n       long right = query(2 * ind + 2, mid + 1, high, l, r);\\n       return mer(left, right);\\n\\t }\\n\\n     public long mer(long left, long right) {\\n         return Math.max(left, right);\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160768,
                "title": "easy-c-solution-100-faster-in-binarysearch-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif use the the array then you find that it is sorted so we can apply binary search over here\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbinary search and dynamic programing\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prize, int k) {\\n        int n=prize.size();\\n        \\n        \\n        vector<int> dp(n);\\n        \\n        for(int i=0;i<n;i++){\\n            int lb=i;\\n            int ub=n-1;\\n            \\n            while(lb<=ub){\\n                int mid=(lb+ub)/2;\\n                \\n                if(prize[i]+k>=prize[mid]){\\n                    dp[i]=(mid-i)+1;\\n                    lb=mid+1;\\n                }else{\\n                    ub=mid-1;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        vector<int> maxArr(n);\\n        int maxVal=dp[n-1];\\n        for(int i=n-1;i>-1;i--){\\n            maxVal=max(maxVal,dp[i]);\\n            maxArr[i]=maxVal;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            int next=dp[i]+i<n?maxArr[dp[i]+i]:0;\\n            ans=max(ans,dp[i]+next);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prize, int k) {\\n        int n=prize.size();\\n        \\n        \\n        vector<int> dp(n);\\n        \\n        for(int i=0;i<n;i++){\\n            int lb=i;\\n            int ub=n-1;\\n            \\n            while(lb<=ub){\\n                int mid=(lb+ub)/2;\\n                \\n                if(prize[i]+k>=prize[mid]){\\n                    dp[i]=(mid-i)+1;\\n                    lb=mid+1;\\n                }else{\\n                    ub=mid-1;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        vector<int> maxArr(n);\\n        int maxVal=dp[n-1];\\n        for(int i=n-1;i>-1;i--){\\n            maxVal=max(maxVal,dp[i]);\\n            maxArr[i]=maxVal;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            int next=dp[i]+i<n?maxArr[dp[i]+i]:0;\\n            ans=max(ans,dp[i]+next);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159479,
                "title": "c-dp-binary-search-sliding-window",
                "content": "i) First create all ranges i.e take all values as starting points and again all of them as ending points using sliding window. Store all these ranges and their sums.\\nii) Sort the values according to starting index and apply dp to choose 2 non-overlapping intervals with maximum sum. Use Binary search to avoid overlapping intervals. Note here we consider all non-overlapping ranges whose starting point is greater than ending point of given range.\\niii) Sort the values according to ending index and apply dp to choose 2 non-overlapping intervals with maximum sum. Use Binary search to avoid overlapping intervals. Note here we consider all non-overlapping ranges whose ending point is smaller than starting point of given range.\\n```\\nclass Solution {\\npublic:\\n    static bool sortcol(const vector<long>& v1, const vector<long>& v2){\\n    return v1[1] > v2[1];\\n    }\\n    int maxiW1(vector<vector<long>>& pq,int k,int ind,vector<vector<int>>& dp1,vector<long>& v1){\\n        if(k==0)\\n            return 0;\\n        if(ind==pq.size())\\n            return 0;\\n        if(dp1[ind][k]!=-1)\\n            return dp1[ind][k];\\n        int tk=0;\\n        int ntk=0;\\n        if(k==2){\\n            int t=upper_bound(v1.begin(),v1.end(),pq[ind][1])-v1.begin();\\n            tk=pq[ind][2]+maxiW1(pq,k-1,t,dp1,v1);\\n            ntk=maxiW1(pq,k,ind+1,dp1,v1);\\n        }\\n        else if(k==1){\\n            tk=pq[ind][2]+maxiW1(pq,0,ind+1,dp1,v1);\\n            ntk=maxiW1(pq,k,ind+1,dp1,v1);\\n        }\\n        return dp1[ind][k]=max(tk,ntk);\\n    }\\n    int maxiW2(vector<vector<long>>& pq1,int k,int ind,vector<vector<int>>& dp2,vector<long>& v2){\\n        if(k==0)\\n            return 0;\\n        if(ind==pq1.size())\\n            return 0;\\n        if(dp2[ind][k]!=-1)\\n            return dp2[ind][k];\\n        int tk=0;\\n        int ntk=0;\\n        if(k==2){\\n            int t=upper_bound(v2.begin(),v2.end(),pq1[ind][1],greater<long>())-v2.begin();\\n            tk=pq1[ind][2]+maxiW2(pq1,k-1,t,dp2,v2);\\n            ntk=maxiW2(pq1,k,ind+1,dp2,v2);\\n        }\\n        else if(k==1){\\n            tk=pq1[ind][2]+maxiW2(pq1,0,ind+1,dp2,v2);\\n            ntk=maxiW2(pq1,k,ind+1,dp2,v2);\\n        }\\n        return dp2[ind][k]=max(tk,ntk);\\n    }\\n    int maximizeWin(vector<int>& pp, int k) {\\n        vector<vector<long>>pq;\\n        map<long,long>m1;\\n        int i;\\n        for(i=0;i<pp.size();i++)\\n            m1[pp[i]]++;\\n        long start=pp[0]-k;\\n        long end=pp[0];\\n        long sum=0;\\n        sum+=m1[end];\\n        vector<long>v2,v4;\\n        v2.push_back(start);\\n        v2.push_back(end);\\n        v2.push_back(sum);\\n        pq.push_back(v2);\\n        long t2=end;\\n        int ind=upper_bound(pp.begin(),pp.end(),end)-pp.begin();\\n        if(ind==pp.size())\\n            return sum;\\n        long temp=start;\\n        while(ind<pp.size()){\\n            end=pp[ind];\\n            start=end-k;\\n            while(temp<start){\\n                sum=sum-m1[temp];\\n                int ind1=upper_bound(pp.begin(),pp.end(),temp)-pp.begin();\\n                temp=pp[ind1];\\n            }\\n            sum+=m1[end];\\n            vector<long>v3;\\n            v3.push_back(start);\\n            v3.push_back(end);\\n            v3.push_back(sum);\\n            pq.push_back(v3);\\n            ind=upper_bound(pp.begin(),pp.end(),end)-pp.begin();\\n        }\\n        reverse(pp.begin(),pp.end());\\n        start=pp[0]+k;\\n        end=pp[0];\\n        sum=0;\\n        sum+=m1[end];\\n        v4.push_back(end);\\n        v4.push_back(start);\\n        v4.push_back(sum);\\n        pq.push_back(v4);\\n        ind=upper_bound(pp.begin(),pp.end(),end,greater<int>())-pp.begin();\\n        temp=start;\\n        while(ind<pp.size()){\\n            end=pp[ind];\\n            start=end+k;\\n            while(temp>start){\\n                sum=sum-m1[temp];\\n                int ind1=upper_bound(pp.begin(),pp.end(),temp,greater<int>())-pp.begin();\\n                temp=pp[ind1];\\n            }\\n            sum+=m1[end];\\n            vector<long>v3;\\n            v3.push_back(end);\\n            v3.push_back(start);\\n            v3.push_back(sum);\\n            pq.push_back(v3);\\n            ind=upper_bound(pp.begin(),pp.end(),end,greater<int>())-pp.begin();\\n        }\\n        sort(pq.begin(),pq.end());\\n        vector<vector<long>>pq1(pq.size(),vector<long>(3));\\n        vector<long>v1,v5;\\n        for(i=0;i<pq.size();i++){\\n            v1.push_back(pq[i][0]);\\n            pq1[i][0]=pq[i][1];\\n            pq1[i][1]=pq[i][0];\\n            pq1[i][2]=pq[i][2];\\n        }\\n        sort(pq1.begin(),pq1.end(),sortcol);\\n        for(i=0;i<pq.size();i++)\\n            v5.push_back(pq1[i][0]);\\n        vector<vector<int>>dp1(pq.size()+1,vector<int>(3,-1));\\n        vector<vector<int>>dp2(pq.size()+1,vector<int>(3,-1));\\n        int ans1=maxiW1(pq,2,0,dp1,v1);\\n        int ans2=maxiW2(pq1,2,0,dp2,v5);\\n        return max(ans1,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool sortcol(const vector<long>& v1, const vector<long>& v2){\\n    return v1[1] > v2[1];\\n    }\\n    int maxiW1(vector<vector<long>>& pq,int k,int ind,vector<vector<int>>& dp1,vector<long>& v1){\\n        if(k==0)\\n            return 0;\\n        if(ind==pq.size())\\n            return 0;\\n        if(dp1[ind][k]!=-1)\\n            return dp1[ind][k];\\n        int tk=0;\\n        int ntk=0;\\n        if(k==2){\\n            int t=upper_bound(v1.begin(),v1.end(),pq[ind][1])-v1.begin();\\n            tk=pq[ind][2]+maxiW1(pq,k-1,t,dp1,v1);\\n            ntk=maxiW1(pq,k,ind+1,dp1,v1);\\n        }\\n        else if(k==1){\\n            tk=pq[ind][2]+maxiW1(pq,0,ind+1,dp1,v1);\\n            ntk=maxiW1(pq,k,ind+1,dp1,v1);\\n        }\\n        return dp1[ind][k]=max(tk,ntk);\\n    }\\n    int maxiW2(vector<vector<long>>& pq1,int k,int ind,vector<vector<int>>& dp2,vector<long>& v2){\\n        if(k==0)\\n            return 0;\\n        if(ind==pq1.size())\\n            return 0;\\n        if(dp2[ind][k]!=-1)\\n            return dp2[ind][k];\\n        int tk=0;\\n        int ntk=0;\\n        if(k==2){\\n            int t=upper_bound(v2.begin(),v2.end(),pq1[ind][1],greater<long>())-v2.begin();\\n            tk=pq1[ind][2]+maxiW2(pq1,k-1,t,dp2,v2);\\n            ntk=maxiW2(pq1,k,ind+1,dp2,v2);\\n        }\\n        else if(k==1){\\n            tk=pq1[ind][2]+maxiW2(pq1,0,ind+1,dp2,v2);\\n            ntk=maxiW2(pq1,k,ind+1,dp2,v2);\\n        }\\n        return dp2[ind][k]=max(tk,ntk);\\n    }\\n    int maximizeWin(vector<int>& pp, int k) {\\n        vector<vector<long>>pq;\\n        map<long,long>m1;\\n        int i;\\n        for(i=0;i<pp.size();i++)\\n            m1[pp[i]]++;\\n        long start=pp[0]-k;\\n        long end=pp[0];\\n        long sum=0;\\n        sum+=m1[end];\\n        vector<long>v2,v4;\\n        v2.push_back(start);\\n        v2.push_back(end);\\n        v2.push_back(sum);\\n        pq.push_back(v2);\\n        long t2=end;\\n        int ind=upper_bound(pp.begin(),pp.end(),end)-pp.begin();\\n        if(ind==pp.size())\\n            return sum;\\n        long temp=start;\\n        while(ind<pp.size()){\\n            end=pp[ind];\\n            start=end-k;\\n            while(temp<start){\\n                sum=sum-m1[temp];\\n                int ind1=upper_bound(pp.begin(),pp.end(),temp)-pp.begin();\\n                temp=pp[ind1];\\n            }\\n            sum+=m1[end];\\n            vector<long>v3;\\n            v3.push_back(start);\\n            v3.push_back(end);\\n            v3.push_back(sum);\\n            pq.push_back(v3);\\n            ind=upper_bound(pp.begin(),pp.end(),end)-pp.begin();\\n        }\\n        reverse(pp.begin(),pp.end());\\n        start=pp[0]+k;\\n        end=pp[0];\\n        sum=0;\\n        sum+=m1[end];\\n        v4.push_back(end);\\n        v4.push_back(start);\\n        v4.push_back(sum);\\n        pq.push_back(v4);\\n        ind=upper_bound(pp.begin(),pp.end(),end,greater<int>())-pp.begin();\\n        temp=start;\\n        while(ind<pp.size()){\\n            end=pp[ind];\\n            start=end+k;\\n            while(temp>start){\\n                sum=sum-m1[temp];\\n                int ind1=upper_bound(pp.begin(),pp.end(),temp,greater<int>())-pp.begin();\\n                temp=pp[ind1];\\n            }\\n            sum+=m1[end];\\n            vector<long>v3;\\n            v3.push_back(end);\\n            v3.push_back(start);\\n            v3.push_back(sum);\\n            pq.push_back(v3);\\n            ind=upper_bound(pp.begin(),pp.end(),end,greater<int>())-pp.begin();\\n        }\\n        sort(pq.begin(),pq.end());\\n        vector<vector<long>>pq1(pq.size(),vector<long>(3));\\n        vector<long>v1,v5;\\n        for(i=0;i<pq.size();i++){\\n            v1.push_back(pq[i][0]);\\n            pq1[i][0]=pq[i][1];\\n            pq1[i][1]=pq[i][0];\\n            pq1[i][2]=pq[i][2];\\n        }\\n        sort(pq1.begin(),pq1.end(),sortcol);\\n        for(i=0;i<pq.size();i++)\\n            v5.push_back(pq1[i][0]);\\n        vector<vector<int>>dp1(pq.size()+1,vector<int>(3,-1));\\n        vector<vector<int>>dp2(pq.size()+1,vector<int>(3,-1));\\n        int ans1=maxiW1(pq,2,0,dp1,v1);\\n        int ans2=maxiW2(pq1,2,0,dp2,v5);\\n        return max(ans1,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158708,
                "title": "c-easy-solution-bs",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int bns(int x,vector<int>&v) {\\n        int l=0,r=n-1;\\n        int res;\\n        while(l<=r) {\\n            int md=(l+r)/2;\\n            if(v[md]<=x) res=md,l=md+1;\\n            else r=md-1;\\n        }\\n        return res;\\n    }\\n    int maximizeWin(vector<int>& v, int k) {\\n        n=v.size();\\n        int ans=0;\\n        int aa[n+5],bb[n+5];\\n        \\n        for(int i=0; i<n; i++) {\\n            int x=k+v[i];\\n            int y=bns(x,v)+1;\\n            int p=i;\\n            //cout<<y-p<<endl;\\n            aa[i]=y-p;\\n            \\n        }\\n        for(int i=n-1; i>=0; i--) {\\n            int x;\\n            if(i==n-1) x=0;\\n            else x=bb[i+1];\\n            bb[i]=max(aa[i],x);\\n        }\\n        for(int i=0; i<n; i++) {\\n            int x=0;\\n            if(i+aa[i]<n) {\\n                x=bb[i+aa[i]];\\n            }\\n            ans=max(ans,aa[i]+x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int bns(int x,vector<int>&v) {\\n        int l=0,r=n-1;\\n        int res;\\n        while(l<=r) {\\n            int md=(l+r)/2;\\n            if(v[md]<=x) res=md,l=md+1;\\n            else r=md-1;\\n        }\\n        return res;\\n    }\\n    int maximizeWin(vector<int>& v, int k) {\\n        n=v.size();\\n        int ans=0;\\n        int aa[n+5],bb[n+5];\\n        \\n        for(int i=0; i<n; i++) {\\n            int x=k+v[i];\\n            int y=bns(x,v)+1;\\n            int p=i;\\n            //cout<<y-p<<endl;\\n            aa[i]=y-p;\\n            \\n        }\\n        for(int i=n-1; i>=0; i--) {\\n            int x;\\n            if(i==n-1) x=0;\\n            else x=bb[i+1];\\n            bb[i]=max(aa[i],x);\\n        }\\n        for(int i=0; i<n; i++) {\\n            int x=0;\\n            if(i+aa[i]<n) {\\n                x=bb[i+aa[i]];\\n            }\\n            ans=max(ans,aa[i]+x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3157468,
                "title": "worst-implementation-of-binary-search",
                "content": "```\\nclass Solution {\\n    public int maximizeWin(int[] arr, int k) {\\n        int n = arr.length;\\n        int[] pre = new int[n];\\n        int count = 0;\\n        for(int i = 0 ; i < arr.length ; i++){\\n            pre[i] = count;\\n            count++;\\n        }\\n        for(int i = arr.length - 1 ; i >= 0 ; i--){\\n            int index = getIndex(0 , i , arr[i] - k , arr);\\n            pre[i] = pre[i] +1 - pre[index];\\n        }\\n        // for(int i = 0 ; i < arr.length ; i++){\\n        //     System.out.print(pre[i] + \" \");\\n        // }\\n        count = 0;\\n        int[] suffix = new int[n];\\n        for(int i = arr.length - 1 ; i >= 0 ; i--){\\n            suffix[i] = count;\\n            count++;\\n        }\\n        for(int i = 0 ; i < arr.length ; i++){\\n            int index = getIndex2(i , arr.length - 1 , arr[i] + k , arr);\\n            suffix[i] =  - suffix[index] + suffix[i] + 1;\\n        }\\n        //System.out.println();\\n        // for(int i = 0 ; i < arr.length ; i++){\\n        //     System.out.print(suffix[i] + \" \");\\n        // }\\n        int cur = 0;\\n        for(int i = 0 ; i < arr.length ; i++){\\n            cur = Math.max(cur , pre[i]);\\n            pre[i] = cur;\\n        }\\n        cur = 0;\\n        for(int i = arr.length - 1 ; i >= 0 ; i--){\\n            cur = Math.max(cur , suffix[i]);\\n            suffix[i] = cur;\\n        }\\n        int ans = 0;\\n        for(int i = 0 ; i < arr.length - 1 ; i++){\\n            ans = Math.max(ans , pre[i]+suffix[i+1]);\\n        }\\n        if(arr.length == 1){\\n            return pre[0];\\n        }\\n        return ans;\\n    }\\n    private int getIndex2(int i , int j , int target ,int[] arr){\\n        int index = -1000000;\\n        while(i <= j){\\n            int mid = (i+j) >> 1;\\n            if(arr[mid] <= target){\\n                index = Math.max(mid , index);\\n                i = mid + 1;\\n            }else{\\n                j = mid - 1; \\n            }\\n        }\\n        return index == -1000000 ? arr.length - 1 : index;\\n    }\\n    private int getIndex(int i , int j , int target ,int[] arr){\\n        int index = 1000000;\\n        while(i <= j){\\n            int mid = (i+j) >> 1;\\n            if(arr[mid] >= target){\\n                index = Math.min(mid , index);\\n                j = mid - 1;\\n            }else{\\n                i = mid + 1; \\n            }\\n        }\\n        return index == 1000000 ? 0 : index;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximizeWin(int[] arr, int k) {\\n        int n = arr.length;\\n        int[] pre = new int[n];\\n        int count = 0;\\n        for(int i = 0 ; i < arr.length ; i++){\\n            pre[i] = count;\\n            count++;\\n        }\\n        for(int i = arr.length - 1 ; i >= 0 ; i--){\\n            int index = getIndex(0 , i , arr[i] - k , arr);\\n            pre[i] = pre[i] +1 - pre[index];\\n        }\\n        // for(int i = 0 ; i < arr.length ; i++){\\n        //     System.out.print(pre[i] + \" \");\\n        // }\\n        count = 0;\\n        int[] suffix = new int[n];\\n        for(int i = arr.length - 1 ; i >= 0 ; i--){\\n            suffix[i] = count;\\n            count++;\\n        }\\n        for(int i = 0 ; i < arr.length ; i++){\\n            int index = getIndex2(i , arr.length - 1 , arr[i] + k , arr);\\n            suffix[i] =  - suffix[index] + suffix[i] + 1;\\n        }\\n        //System.out.println();\\n        // for(int i = 0 ; i < arr.length ; i++){\\n        //     System.out.print(suffix[i] + \" \");\\n        // }\\n        int cur = 0;\\n        for(int i = 0 ; i < arr.length ; i++){\\n            cur = Math.max(cur , pre[i]);\\n            pre[i] = cur;\\n        }\\n        cur = 0;\\n        for(int i = arr.length - 1 ; i >= 0 ; i--){\\n            cur = Math.max(cur , suffix[i]);\\n            suffix[i] = cur;\\n        }\\n        int ans = 0;\\n        for(int i = 0 ; i < arr.length - 1 ; i++){\\n            ans = Math.max(ans , pre[i]+suffix[i+1]);\\n        }\\n        if(arr.length == 1){\\n            return pre[0];\\n        }\\n        return ans;\\n    }\\n    private int getIndex2(int i , int j , int target ,int[] arr){\\n        int index = -1000000;\\n        while(i <= j){\\n            int mid = (i+j) >> 1;\\n            if(arr[mid] <= target){\\n                index = Math.max(mid , index);\\n                i = mid + 1;\\n            }else{\\n                j = mid - 1; \\n            }\\n        }\\n        return index == -1000000 ? arr.length - 1 : index;\\n    }\\n    private int getIndex(int i , int j , int target ,int[] arr){\\n        int index = 1000000;\\n        while(i <= j){\\n            int mid = (i+j) >> 1;\\n            if(arr[mid] >= target){\\n                index = Math.min(mid , index);\\n                j = mid - 1;\\n            }else{\\n                i = mid + 1; \\n            }\\n        }\\n        return index == 1000000 ? 0 : index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157275,
                "title": "c-easy-solution-dp-sliding-window-beats-88",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size(), start = 0, ans = 0;\\n        vector<int>dp(n);\\n        for(int end=0; end<n; end++) {\\n            while(prizePositions[end] - prizePositions[start] > k)\\n                start++;\\n\\n            int curr_ans = end-start + 1;    \\n            if(start > 0) {\\n                curr_ans += dp[start-1];\\n            }\\n            ans = max(ans, curr_ans);\\n\\n            int prev = 0;\\n            if(end > 0) prev = dp[end-1];\\n            \\n            dp[end] = max(prev, end-start+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size(), start = 0, ans = 0;\\n        vector<int>dp(n);\\n        for(int end=0; end<n; end++) {\\n            while(prizePositions[end] - prizePositions[start] > k)\\n                start++;\\n\\n            int curr_ans = end-start + 1;    \\n            if(start > 0) {\\n                curr_ans += dp[start-1];\\n            }\\n            ans = max(ans, curr_ans);\\n\\n            int prev = 0;\\n            if(end > 0) prev = dp[end-1];\\n            \\n            dp[end] = max(prev, end-start+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156451,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        //It is meaningless to let the two interval to overlap\\n        int l = prizePositions.size();\\n        if(prizePositions[l-1] - prizePositions[0] <= 2*k+1) return l;\\n        //now we can assume they don\\'t overlap. \\n        //so we search the interval through [m,m+k] to [M-k,M]\\n        //and use Mi,Mj to mark the first interval that we can get most prizes from prizePisitions[Mi] to prizePositions[Mj-1], where prizePositions[Mj-1]+k <= curi, and curi to curj is the second interval\\n        //if we find more prizes in the second interval, we will renew the Mi and Mj to the new ones as soon as they don\\'t overlap\\n        int Mi=0,Mj=0;//mark our first interval\\n        queue<pair<int, int>> previousIntervals;//stores possible larger intervals for our first interval\\n        int ans = 0;\\n        int curi=0,curj=Mj;\\n        for(;curi<l;curi++)\\n        {\\n            //find interval\\n            while(curj < l && prizePositions[curj] - prizePositions[curi] <= k)\\n            {\\n                curj++;\\n            }\\n            //If there are no overlap we can replace the old first interval with the new first interval.\\n            while(!previousIntervals.empty() && previousIntervals.front().second <= curi)\\n            {\\n                if(previousIntervals.front().second - previousIntervals.front().first > Mj - Mi)\\n                {\\n                    Mj = previousIntervals.front().second;\\n                    Mi = previousIntervals.front().first;\\n                }\\n                previousIntervals.pop();\\n            }\\n            if(curj-curi > Mj - Mi)//If we find a larger interval\\n            {\\n                previousIntervals.push(make_pair(curi,curj));\\n            }\\n            if(curj - curi + Mj - Mi > ans) ans = curj-curi+Mj-Mi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        //It is meaningless to let the two interval to overlap\\n        int l = prizePositions.size();\\n        if(prizePositions[l-1] - prizePositions[0] <= 2*k+1) return l;\\n        //now we can assume they don\\'t overlap. \\n        //so we search the interval through [m,m+k] to [M-k,M]\\n        //and use Mi,Mj to mark the first interval that we can get most prizes from prizePisitions[Mi] to prizePositions[Mj-1], where prizePositions[Mj-1]+k <= curi, and curi to curj is the second interval\\n        //if we find more prizes in the second interval, we will renew the Mi and Mj to the new ones as soon as they don\\'t overlap\\n        int Mi=0,Mj=0;//mark our first interval\\n        queue<pair<int, int>> previousIntervals;//stores possible larger intervals for our first interval\\n        int ans = 0;\\n        int curi=0,curj=Mj;\\n        for(;curi<l;curi++)\\n        {\\n            //find interval\\n            while(curj < l && prizePositions[curj] - prizePositions[curi] <= k)\\n            {\\n                curj++;\\n            }\\n            //If there are no overlap we can replace the old first interval with the new first interval.\\n            while(!previousIntervals.empty() && previousIntervals.front().second <= curi)\\n            {\\n                if(previousIntervals.front().second - previousIntervals.front().first > Mj - Mi)\\n                {\\n                    Mj = previousIntervals.front().second;\\n                    Mi = previousIntervals.front().first;\\n                }\\n                previousIntervals.pop();\\n            }\\n            if(curj-curi > Mj - Mi)//If we find a larger interval\\n            {\\n                previousIntervals.push(make_pair(curi,curj));\\n            }\\n            if(curj - curi + Mj - Mi > ans) ans = curj-curi+Mj-Mi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154552,
                "title": "sliding-window-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& v, int k) {\\n        int n=v.size(),ans=0;\\n\\n     // sliding window from right\\n        int cnt=0,j=n-1;\\n        vector<int> res(n+2,0);\\n        for(int i=n-1;i>=0;i--){\\n           cnt++;\\n           while(v[j]-v[i]>k){ \\n               j--;\\n               cnt--;\\n           }\\n           res[i]=max(res[i+1],cnt);\\n        }\\n\\n   // sliding window from left\\n       j=0,cnt=0;\\n        for(int i=0;i<n;i++){\\n            cnt++;\\n            while(v[i]-v[j]>k){\\n                j++;\\n                cnt--;\\n            }\\n            ans=max(ans,cnt+res[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& v, int k) {\\n        int n=v.size(),ans=0;\\n\\n     // sliding window from right\\n        int cnt=0,j=n-1;\\n        vector<int> res(n+2,0);\\n        for(int i=n-1;i>=0;i--){\\n           cnt++;\\n           while(v[j]-v[i]>k){ \\n               j--;\\n               cnt--;\\n           }\\n           res[i]=max(res[i+1],cnt);\\n        }\\n\\n   // sliding window from left\\n       j=0,cnt=0;\\n        for(int i=0;i<n;i++){\\n            cnt++;\\n            while(v[i]-v[j]>k){\\n                j++;\\n                cnt--;\\n            }\\n            ans=max(ans,cnt+res[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152214,
                "title": "memoization-tabulation-dp-bs-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int n, int k, int cnt, vector<int> &pp, vector<vector<int>> &dp) {\\n        if(i == n) return 0;\\n        if(dp[i][cnt] != -1) return dp[i][cnt];\\n\\n        int notPick = dfs(i + 1, n, k, cnt, pp, dp), pick = 0;\\n        if(cnt) {\\n            int pos = lower_bound(pp.begin() + i, pp.end(), pp[i] + k + 1) - pp.begin() - 1;\\n            pick = pos - i + 1 + dfs(pos + 1, n, k, cnt - 1, pp, dp);\\n        }\\n        return dp[i][cnt] = max(pick, notPick);\\n    }\\npublic:\\n    int maximizeWin(vector<int>& pp, int k) {\\n        int n = pp.size();\\n        vector<vector<int>> dp(n, vector<int>(3, -1));\\n\\n        return dfs(0, n, k, 2, pp, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& pp, int k) {\\n        int n = pp.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(3));\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int cnt=1; cnt<=2; cnt++) {\\n                int notPick = dp[i + 1][cnt], pick = 0;\\n                int pos = lower_bound(pp.begin() + i, pp.end(), pp[i] + k + 1) - pp.begin() - 1;\\n                pick = pos - i + 1 + dp[pos + 1][cnt - 1];\\n                dp[i][cnt] = max(pick, notPick);\\n            }\\n        }\\n        return dp[0][2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int n, int k, int cnt, vector<int> &pp, vector<vector<int>> &dp) {\\n        if(i == n) return 0;\\n        if(dp[i][cnt] != -1) return dp[i][cnt];\\n\\n        int notPick = dfs(i + 1, n, k, cnt, pp, dp), pick = 0;\\n        if(cnt) {\\n            int pos = lower_bound(pp.begin() + i, pp.end(), pp[i] + k + 1) - pp.begin() - 1;\\n            pick = pos - i + 1 + dfs(pos + 1, n, k, cnt - 1, pp, dp);\\n        }\\n        return dp[i][cnt] = max(pick, notPick);\\n    }\\npublic:\\n    int maximizeWin(vector<int>& pp, int k) {\\n        int n = pp.size();\\n        vector<vector<int>> dp(n, vector<int>(3, -1));\\n\\n        return dfs(0, n, k, 2, pp, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& pp, int k) {\\n        int n = pp.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(3));\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int cnt=1; cnt<=2; cnt++) {\\n                int notPick = dp[i + 1][cnt], pick = 0;\\n                int pos = lower_bound(pp.begin() + i, pp.end(), pp[i] + k + 1) - pp.begin() - 1;\\n                pick = pos - i + 1 + dp[pos + 1][cnt - 1];\\n                dp[i][cnt] = max(pick, notPick);\\n            }\\n        }\\n        return dp[0][2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151193,
                "title": "java-prefix-max-binary-search-o-nlogn-solution",
                "content": "```\\nclass Solution {\\n    public int maximizeWin(int[] a, int k) {\\n        int max_till_here=0;\\n        int maxans=0;\\n        for(int j=0;j<a.length;j++)\\n        {\\n            int end=j;\\n            int l=0;\\n            int r=a.length-1;\\n            while(l<=r)\\n            {\\n                int mid=l+(r-l)/2;\\n                if(a[mid]<=a[j]+k)\\n                {\\n                    end=mid;\\n                    l=mid+1;\\n                }\\n                else\\n                    r=mid-1;\\n            }\\n            maxans=Math.max(maxans,max_till_here+(end-j)+1);\\n            int start=j;\\n            l=0;\\n            r=a.length-1;\\n            while(l<=r)\\n            {\\n                int mid=l+(r-l)/2;\\n                if(a[mid]>=a[j]-k)\\n                {\\n                    start=mid;\\n                    r=mid-1;\\n                }\\n                else\\n                    l=mid+1;\\n            }\\n            max_till_here=Math.max(max_till_here,(j-start)+1);\\n        }\\n        return maxans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeWin(int[] a, int k) {\\n        int max_till_here=0;\\n        int maxans=0;\\n        for(int j=0;j<a.length;j++)\\n        {\\n            int end=j;\\n            int l=0;\\n            int r=a.length-1;\\n            while(l<=r)\\n            {\\n                int mid=l+(r-l)/2;\\n                if(a[mid]<=a[j]+k)\\n                {\\n                    end=mid;\\n                    l=mid+1;\\n                }\\n                else\\n                    r=mid-1;\\n            }\\n            maxans=Math.max(maxans,max_till_here+(end-j)+1);\\n            int start=j;\\n            l=0;\\n            r=a.length-1;\\n            while(l<=r)\\n            {\\n                int mid=l+(r-l)/2;\\n                if(a[mid]>=a[j]-k)\\n                {\\n                    start=mid;\\n                    r=mid-1;\\n                }\\n                else\\n                    l=mid+1;\\n            }\\n            max_till_here=Math.max(max_till_here,(j-start)+1);\\n        }\\n        return maxans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150134,
                "title": "clean-prefix-solution-c",
                "content": "# Approach\\nCode size is huge but not logic is\\n- Left array : At every index find no. of prizes in a window of k (idx to left)\\n- Right array : At every index find no. of prizes in a window of k (idx to right)\\n- prefix array : keep track of maximum no. of prize till this point from right\\n- Last for loop : at every index take the no. of prizes from left array and take the just next index of prefix array as we are storing maximum in prefix array\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(4N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& arr, int k) {\\n        vector<pair<int,int>> vp;\\n        for(int i=0;i<arr.size();){\\n            int j = i;\\n            while(j < arr.size() and arr[j] == arr[i]) j++;\\n            vp.push_back({arr[i],j-i});\\n            i = j;\\n        }\\n        int i=0,j=0,sum=0;\\n        vector<int> left;\\n        while(j < vp.size()){\\n            int diff = vp[j].first - vp[i].first;\\n            sum += vp[j].second;\\n            if(diff <= k){\\n                left.push_back(sum);\\n            }else{\\n                while(i <= j){\\n                    sum -= vp[i].second;\\n                    int diff = vp[j].first - vp[++i].first;\\n                    if(diff <= k){\\n                        left.push_back(sum); break;\\n                    }\\n                }\\n            }\\n            j++;\\n        }\\n        i=vp.size()-1,j=vp.size()-1,sum=0;\\n        vector<int> right;\\n        while(j >= 0){\\n            int diff = vp[i].first - vp[j].first;\\n            sum += vp[j].second;\\n            if(diff <= k){\\n                right.push_back(sum);\\n            }else{\\n                while(i >= j){\\n                    sum -= vp[i].second;\\n                    int diff = vp[--i].first - vp[j].first;\\n                    if(diff <= k){\\n                        right.push_back(sum); break;\\n                    }\\n                }\\n            }\\n            j--;\\n        }        \\n        reverse(right.begin(),right.end());\\n        vector<int> pref(left.size());\\n        int maxi = right.back();\\n        for(int i=right.size()-1;i>=0;i--){\\n            maxi = max(maxi,right[i]);\\n            pref[i] = maxi;\\n        }\\n        int ans = 0;\\n        for(int i=0;i<left.size();i++){\\n            ans = max(ans,left[i]+(i+1 < left.size() ? pref[i+1] : 0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& arr, int k) {\\n        vector<pair<int,int>> vp;\\n        for(int i=0;i<arr.size();){\\n            int j = i;\\n            while(j < arr.size() and arr[j] == arr[i]) j++;\\n            vp.push_back({arr[i],j-i});\\n            i = j;\\n        }\\n        int i=0,j=0,sum=0;\\n        vector<int> left;\\n        while(j < vp.size()){\\n            int diff = vp[j].first - vp[i].first;\\n            sum += vp[j].second;\\n            if(diff <= k){\\n                left.push_back(sum);\\n            }else{\\n                while(i <= j){\\n                    sum -= vp[i].second;\\n                    int diff = vp[j].first - vp[++i].first;\\n                    if(diff <= k){\\n                        left.push_back(sum); break;\\n                    }\\n                }\\n            }\\n            j++;\\n        }\\n        i=vp.size()-1,j=vp.size()-1,sum=0;\\n        vector<int> right;\\n        while(j >= 0){\\n            int diff = vp[i].first - vp[j].first;\\n            sum += vp[j].second;\\n            if(diff <= k){\\n                right.push_back(sum);\\n            }else{\\n                while(i >= j){\\n                    sum -= vp[i].second;\\n                    int diff = vp[--i].first - vp[j].first;\\n                    if(diff <= k){\\n                        right.push_back(sum); break;\\n                    }\\n                }\\n            }\\n            j--;\\n        }        \\n        reverse(right.begin(),right.end());\\n        vector<int> pref(left.size());\\n        int maxi = right.back();\\n        for(int i=right.size()-1;i>=0;i--){\\n            maxi = max(maxi,right[i]);\\n            pref[i] = maxi;\\n        }\\n        int ans = 0;\\n        for(int i=0;i<left.size();i++){\\n            ans = max(ans,left[i]+(i+1 < left.size() ? pref[i+1] : 0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150048,
                "title": "detailed-solution-with-comments-sliding-window-prefix-sum-suffix-sum-o-n",
                "content": "```\\nclass Solution\\n{\\n    public:\\n       \\t// basically for ant index i, (0,i) will give me one segment out of all segments possible\\n       \\t//in this range (0,i) in such a way that it will give me max. prize. Similarly (i+1,n-1)\\n       \\t// will give me one segment out of all segments possible in this range (i+1,n-1) in such\\n       \\t// way that it will give me max.prize. So adding up their values will give me max.prize\\n       \\t// possible for any index i and i have to do that for every index. out of thsese whichever \\n       \\t// will give maximum answer, would be my answer.\\n        int maximizeWin(vector<int> &prizePositions, int k)\\n        {\\n            int n = prizePositions.size();\\n            vector<int> pref(n), suff(n);\\n```\\n\\n           \\t// Find maximum count of prize for(0,i). It can be[1,3], [2,4], [3,5]...out of these\\n           \\t// segments whichever will give me max count, i will choose it. For this example it \\n           \\t// is[1,3]\\n\\n            int count = 0, maxCount = 0;\\n            int st = 0;\\n            int end = prizePositions[0] + k;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                int curr = prizePositions[i];\\n\\n                if (curr <= end) count++;\\n                else\\n                {\\n                   \\t// i will keep contracting my window until my curr is in range or so to say\\n                   \\t// find a new range\\n                    while (curr > end)\\n                    {\\n                        st++;\\n                        end = prizePositions[st] + k;\\n                        count--;\\n                    }\\n\\n                    count++;\\n                }\\n                maxCount = max(maxCount, count);\\n                pref[i] = maxCount;\\t// store the max count for (0,i);\\n            }\\n\\n            count = 0, maxCount = 0;\\n            st = n - 1;\\n            end = prizePositions[n - 1] - k;\\n\\n            for (int i = n - 1; i >= 0; i--)\\n            {\\n                int curr = prizePositions[i];\\n\\n                if (curr >= end) count++;\\n                else\\n                {\\n                   \\t// i will keep contracting my window until my curr is in range or so to say\\n                   \\t// find a new range\\n                    while (curr < end)\\n                    {\\n                        st--;\\n                        end = prizePositions[st] - k;\\n                        count--;\\n                    }\\n\\n                    count++;\\n                }\\n                maxCount = max(maxCount, count);\\n                suff[i] = maxCount;\\t// store the max count for (i,n-1)\\n            }\\n\\n            int maxPrize = 0;\\n            for (int i = 0; i < n; i++)\\n            {\\n                int prize = pref[i];\\n                if (i + 1 < n) prize += suff[i + 1];\\n                maxPrize = max(maxPrize, prize);\\n            }\\n            return maxPrize;\\n        }\\n};\\n\\n**If you find this explanation helpful, make sure you upvote this!**\\n**For more such solution, you can follow this:** https://github.com/tanmoyheritage23/Leetcode-GFG\\n**Find me on LinkedIn:** https://www.linkedin.com/in/tanmoysahaofficial/",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n       \\t// basically for ant index i, (0,i) will give me one segment out of all segments possible\\n       \\t//in this range (0,i) in such a way that it will give me max. prize. Similarly (i+1,n-1)\\n       \\t// will give me one segment out of all segments possible in this range (i+1,n-1) in such\\n       \\t// way that it will give me max.prize. So adding up their values will give me max.prize\\n       \\t// possible for any index i and i have to do that for every index. out of thsese whichever \\n       \\t// will give maximum answer, would be my answer.\\n        int maximizeWin(vector<int> &prizePositions, int k)\\n        {\\n            int n = prizePositions.size();\\n            vector<int> pref(n), suff(n);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148453,
                "title": "problem-with-the-problem-description",
                "content": "Anybody else read this problem wrong to where they thought a segment must contain both the left and the right endpoints to be valid? What led me to think this is the fact it said the \\'The length of each segment must be k\\', which made me think that the right endpoint of the segment should always be contained within the segment, else the segment is not of length k technically. Of course this ends up being a harder problem if so, and could maybe be considered a a valid follow up.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3148231,
                "title": "javascript-dp",
                "content": "```javascript\\nvar maximizeWin = function(prizePositions, k) {\\n  const dp = {};\\n  \\n  for (const position of prizePositions)\\n    dp[position] = Array(3).fill(0);\\n  \\n  for (let i = 0, j = 0; i < prizePositions.length; ++i) {\\n    const position = prizePositions[i];\\n    \\n    // range of prizes we can collect is [position - k, position];\\n    while (prizePositions[j] < position - k)\\n      ++j;\\n    \\n    for (let interval = 1; interval <= 2; ++interval) {\\n      // we have two options:\\n\\n      // 1) we place the interval so that it ends at `position`\\n      //    in doing so we collect i - j + 1 prizes plus \\n      //    dp[prizePositions[j - 1]][interval - 1]\\n      const maxFromPlacingIntervalAtPosition =\\n        i - j + 1 + (j > 0 ? dp[prizePositions[j - 1]][interval - 1] : 0);\\n      \\n      // 2) we do not place the interval and use the max we got\\n      //    at the previous position\\n      const maxFromPrevious = i > 0 ? dp[prizePositions[i - 1]][interval] : 0;\\n      \\n      dp[position][interval] = Math.max(\\n        maxFromPlacingIntervalAtPosition, maxFromPrevious\\n      );\\n    }\\n  }\\n  \\n  return dp[prizePositions[prizePositions.length - 1]][2];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar maximizeWin = function(prizePositions, k) {\\n  const dp = {};\\n  \\n  for (const position of prizePositions)\\n    dp[position] = Array(3).fill(0);\\n  \\n  for (let i = 0, j = 0; i < prizePositions.length; ++i) {\\n    const position = prizePositions[i];\\n    \\n    // range of prizes we can collect is [position - k, position];\\n    while (prizePositions[j] < position - k)\\n      ++j;\\n    \\n    for (let interval = 1; interval <= 2; ++interval) {\\n      // we have two options:\\n\\n      // 1) we place the interval so that it ends at `position`\\n      //    in doing so we collect i - j + 1 prizes plus \\n      //    dp[prizePositions[j - 1]][interval - 1]\\n      const maxFromPlacingIntervalAtPosition =\\n        i - j + 1 + (j > 0 ? dp[prizePositions[j - 1]][interval - 1] : 0);\\n      \\n      // 2) we do not place the interval and use the max we got\\n      //    at the previous position\\n      const maxFromPrevious = i > 0 ? dp[prizePositions[i - 1]][interval] : 0;\\n      \\n      dp[position][interval] = Math.max(\\n        maxFromPlacingIntervalAtPosition, maxFromPrevious\\n      );\\n    }\\n  }\\n  \\n  return dp[prizePositions[prizePositions.length - 1]][2];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3148223,
                "title": "golang-binary-search-dp",
                "content": "# Code\\n```\\nfunc max(a, b int) int {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc upperBound(num []int, low, high, item int) int {\\n    var ans int = -1\\n    for low <= high {\\n        var mid int = low + (high - low) / 2\\n        if num[mid] <= item {\\n            ans = max(ans, mid)\\n            low = mid + 1\\n        } else {\\n            high = mid - 1\\n        }\\n    }\\n    return ans + 1\\n}\\n\\nfunc maximizeWin(prizePositions []int, k int) int {\\n    var n int = len(prizePositions)\\n    count := make([]int, n + 1)\\n    var ans int = 0\\n    for i := n - 1; i >= 0; i-- {\\n        count[i] = upperBound(prizePositions, 0, n - 1, prizePositions[i] + k) - i\\n        ans = max(ans, count[i] + count[i + count[i]])\\n        count[i] = max(count[i + 1], count[i])\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc max(a, b int) int {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc upperBound(num []int, low, high, item int) int {\\n    var ans int = -1\\n    for low <= high {\\n        var mid int = low + (high - low) / 2\\n        if num[mid] <= item {\\n            ans = max(ans, mid)\\n            low = mid + 1\\n        } else {\\n            high = mid - 1\\n        }\\n    }\\n    return ans + 1\\n}\\n\\nfunc maximizeWin(prizePositions []int, k int) int {\\n    var n int = len(prizePositions)\\n    count := make([]int, n + 1)\\n    var ans int = 0\\n    for i := n - 1; i >= 0; i-- {\\n        count[i] = upperBound(prizePositions, 0, n - 1, prizePositions[i] + k) - i\\n        ans = max(ans, count[i] + count[i + count[i]])\\n        count[i] = max(count[i + 1], count[i])\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3146639,
                "title": "c-simple-solution-with-explanation-beats-100",
                "content": "# Approach\\nFor each index of prizePositions vector, we will search how far we can go on the left and right side.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prz, int k) {\\n        // TLDR: for each index of prz (prizePositions) vector, we will search how far we can go on the left and right side.\\n\\n        vector<int> left(prz.size() + 5), right(prz.size() + 5);\\n        \\n        // we will take each index and check how far we can go on the left side.\\n        // we are searching for leftmost index of prz[i] - k\\n        left[0] = 1;\\n        for(int i=1; i<prz.size(); i++) {\\n            int pos = lower_bound(prz.begin(), prz.end(), prz[i] - k) - prz.begin();\\n            left[i] = max(i - pos + 1, left[i-1]);\\n        }\\n        \\n        // we will take each index and check how far we can go on the right side.\\n        // we are searching for rightmost index of prz[i] + k\\n        right[prz.size() - 1] = 1;\\n        for(int i=prz.size() - 2; i>=0; i--) {\\n            int pos = upper_bound(prz.begin(), prz.end(), prz[i] + k) - prz.begin();\\n            right[i] = max(pos - i, right[i+1]);\\n        }\\n\\n        // now for each index we will sum the value of left and right vector and take the maximum value\\n        int res = 0;\\n        for(int i=0; i<prz.size(); i++) {\\n            res = max(res, (i == 0 ? 0 : left[i-1]) + right[i]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prz, int k) {\\n        // TLDR: for each index of prz (prizePositions) vector, we will search how far we can go on the left and right side.\\n\\n        vector<int> left(prz.size() + 5), right(prz.size() + 5);\\n        \\n        // we will take each index and check how far we can go on the left side.\\n        // we are searching for leftmost index of prz[i] - k\\n        left[0] = 1;\\n        for(int i=1; i<prz.size(); i++) {\\n            int pos = lower_bound(prz.begin(), prz.end(), prz[i] - k) - prz.begin();\\n            left[i] = max(i - pos + 1, left[i-1]);\\n        }\\n        \\n        // we will take each index and check how far we can go on the right side.\\n        // we are searching for rightmost index of prz[i] + k\\n        right[prz.size() - 1] = 1;\\n        for(int i=prz.size() - 2; i>=0; i--) {\\n            int pos = upper_bound(prz.begin(), prz.end(), prz[i] + k) - prz.begin();\\n            right[i] = max(pos - i, right[i+1]);\\n        }\\n\\n        // now for each index we will sum the value of left and right vector and take the maximum value\\n        int res = 0;\\n        for(int i=0; i<prz.size(); i++) {\\n            res = max(res, (i == 0 ? 0 : left[i-1]) + right[i]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146412,
                "title": "complete-explanation-binary-search-dp-c",
                "content": "# Intuition\\n- its given that prize array has co-ordinates in sorted order \\n- so something like binary search can work \\n- now we have to find the indexing of first gift which is at position greater than `(arr[i]+k)` for each i in the array \\n- if we have data for each indexing how much gifts can be collected then we can just use run loop and get the answer for second segement which we have to select such that maximum possible gift sum we have.\\n- now we can focus on second segment.\\n- suppose if we choose indexing `i `then we can collect gift upto v[i] **where v store the information till where we can collect the gifts of that i**\\n- now for second segment we must chose the indexing from `v[i]` to collect maximum gift\\n- now lets look code for better understanding.\\n- \\n# Approach\\n- explaing in code \\n\\n# Complexity\\n- Time complexity:\\n- O(N+NlogN)----->O(NlogN)\\n\\n- Space complexity:\\n- $$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) \\n    {\\n        vector<int>pre=f(prizePositions,k);\\n        int ans=0;\\n        vector<int>dp(prizePositions.size()+1,-1);\\n        for(int i=0;i<prizePositions.size();i++)\\n        {\\n            //for each segment calculating maxing gifts we\\n            // we can collect.\\n            int temp=pre[i]-i+f1(pre[i],pre,dp);\\n            ans=max(ans,temp);\\n        } \\n        return ans;\\n    }\\n    //f-->fxn which will calculate the indexing \\n    //till where we can collect the gift starting \\n    //from ith indexing will work as precomputation .\\n    vector<int>f(vector<int>&v,int k)\\n    {\\n        vector<int>pre(v.size(),0);\\n        for(int j=0;j<v.size();j++)\\n        {\\n            int it=v[j];\\n            int i=upper_bound(v.begin(),v.end(),it+k)-v.begin();\\n            pre[j]=i;\\n        }\\n        return pre;\\n        \\n    }\\n    //f1->fxn which will tell you maximum gift you\\n    //can collect of segment <=k staring from \\n    //ith indexing basically we have to chose the optimal \\n    //indexing which so there we have to chose something \\n    // recurrsion comes into picture.\\n    int f1(int i,vector<int>&v,vector<int>&dp)\\n    {\\n        if (i>=v.size())\\n        {\\n            return 0;\\n        }\\n        if (dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n        int ans=v[i]-i;\\n        int ans2=f1(i+1,v,dp);\\n        return  dp[i]=max(ans,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) \\n    {\\n        vector<int>pre=f(prizePositions,k);\\n        int ans=0;\\n        vector<int>dp(prizePositions.size()+1,-1);\\n        for(int i=0;i<prizePositions.size();i++)\\n        {\\n            //for each segment calculating maxing gifts we\\n            // we can collect.\\n            int temp=pre[i]-i+f1(pre[i],pre,dp);\\n            ans=max(ans,temp);\\n        } \\n        return ans;\\n    }\\n    //f-->fxn which will calculate the indexing \\n    //till where we can collect the gift starting \\n    //from ith indexing will work as precomputation .\\n    vector<int>f(vector<int>&v,int k)\\n    {\\n        vector<int>pre(v.size(),0);\\n        for(int j=0;j<v.size();j++)\\n        {\\n            int it=v[j];\\n            int i=upper_bound(v.begin(),v.end(),it+k)-v.begin();\\n            pre[j]=i;\\n        }\\n        return pre;\\n        \\n    }\\n    //f1->fxn which will tell you maximum gift you\\n    //can collect of segment <=k staring from \\n    //ith indexing basically we have to chose the optimal \\n    //indexing which so there we have to chose something \\n    // recurrsion comes into picture.\\n    int f1(int i,vector<int>&v,vector<int>&dp)\\n    {\\n        if (i>=v.size())\\n        {\\n            return 0;\\n        }\\n        if (dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n        int ans=v[i]-i;\\n        int ans2=f1(i+1,v,dp);\\n        return  dp[i]=max(ans,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146409,
                "title": "dp-bottom-up",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        n = len(prizePositions)\\n\\n        if k == 0:\\n            return min(n ,2)\\n\\n        left, right = [0]*(n+1), [0]*(n+1)\\n        left[0] = 1\\n        right[n-1] = 1\\n\\n        j = 0\\n        for i in range(1, n):\\n            while (prizePositions[i] - prizePositions[j] > k):\\n                j += 1\\n            left[i] = max(left[i-1], i-j+1)\\n\\n        j = n-1\\n        for i in range(n-1, -1, -1):\\n            while (prizePositions[j] - prizePositions[i] > k):\\n                j -= 1\\n            right[i] = max(right[i+1], j-i+1)\\n\\n        res = 0\\n        for i in range(n+1):\\n            res = max(res, (0 if i == 0 else left[i-1]) + (0 if i == n else right[i]))\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        n = len(prizePositions)\\n\\n        if k == 0:\\n            return min(n ,2)\\n\\n        left, right = [0]*(n+1), [0]*(n+1)\\n        left[0] = 1\\n        right[n-1] = 1\\n\\n        j = 0\\n        for i in range(1, n):\\n            while (prizePositions[i] - prizePositions[j] > k):\\n                j += 1\\n            left[i] = max(left[i-1], i-j+1)\\n\\n        j = n-1\\n        for i in range(n-1, -1, -1):\\n            while (prizePositions[j] - prizePositions[i] > k):\\n                j -= 1\\n            right[i] = max(right[i+1], j-i+1)\\n\\n        res = 0\\n        for i in range(n+1):\\n            res = max(res, (0 if i == 0 else left[i-1]) + (0 if i == n else right[i]))\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146392,
                "title": "prefix-calculation-binary-search-c-well-commented",
                "content": "**1. Find max prize in each segment till that index and store it in maxTill (prefix) array.\\n2. calculate the prize count in current segment and add it to previous maximum \\n3. Update the maxTill (prefix) array in each iteration and store value**\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prize, int k) {\\n        int n=prize.size();\\n//         stores max no of prizes from each \\'k\\' sized segment till that index starting from 0th index\\n        vector<int> maxTill(n,-1);\\n//         ans stores overall answer from both segments till that index\\n        int ans=0;\\n//         max no of prizes from all k sized segments till that index\\n        int mx=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int curr=prize[i];\\n            auto itr=lower_bound(prize.begin(),prize.end(),curr-k);\\n//             if lower bound is start index then there is no previous element\\n            if(itr==prize.begin()){\\n                int diff=i+1;\\n                mx=max(diff,mx);\\n                maxTill[i]=mx;\\n                ans=max(ans,mx);\\n            }else{\\n//                 there exist a previous element and find max till that index from each k-sized segments\\n                int diff=prize.begin()-itr+i+1;\\n                mx=max(diff,mx);\\n                maxTill[i]=mx;\\n                int prevIdx=itr-prize.begin()-1;\\n                ans=max(ans,diff+maxTill[prevIdx]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prize, int k) {\\n        int n=prize.size();\\n//         stores max no of prizes from each \\'k\\' sized segment till that index starting from 0th index\\n        vector<int> maxTill(n,-1);\\n//         ans stores overall answer from both segments till that index\\n        int ans=0;\\n//         max no of prizes from all k sized segments till that index\\n        int mx=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int curr=prize[i];\\n            auto itr=lower_bound(prize.begin(),prize.end(),curr-k);\\n//             if lower bound is start index then there is no previous element\\n            if(itr==prize.begin()){\\n                int diff=i+1;\\n                mx=max(diff,mx);\\n                maxTill[i]=mx;\\n                ans=max(ans,mx);\\n            }else{\\n//                 there exist a previous element and find max till that index from each k-sized segments\\n                int diff=prize.begin()-itr+i+1;\\n                mx=max(diff,mx);\\n                maxTill[i]=mx;\\n                int prevIdx=itr-prize.begin()-1;\\n                ans=max(ans,diff+maxTill[prevIdx]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146066,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& p, int k) {\\n        std::ios::sync_with_stdio(false);\\n        std::cin.tie(nullptr);\\n        int n=p.size(),ans=0;\\n        for(int i=0,r=0,l=0,v=0;i<n;++i){\\n            while(r<n&&p[r]-p[i]<=k)++r;\\n            p[i]=r-i;\\n            while(p[l]+l<=i)v=max(v,p[l++]);\\n            ans=max(ans,l?v+p[i]:p[i]+i);\\n            if(r==n)return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def maximizeWin(self, pos: List[int], k: int) -> int:\\n        n = len(pos)\\n        if k*2+1 >= pos[-1] - pos[0]: return n\\n        pre = [0] * (n + 1)\\n        ans = left = 0\\n        for right, p in enumerate(pos):\\n            while p - pos[left] > k:\\n                left += 1\\n            sz = right - left + 1\\n            res = sz + pre[left]\\n            if res > ans: ans = res\\n            if sz >= pre[right]: pre[right+1] = sz\\n            else: pre[right+1] = pre[right]\\n        return ans\\n```\\n\\n```Java []\\nclass Solution {\\n    public int maximizeWin(int[] prizePositions, int k) {\\n        int n = prizePositions.length;\\n        if (prizePositions[n - 1] - prizePositions[0] <= k * 2) return n;\\n        int[] a = new int[n], b = new int[n];\\n        for (int i = 0, j = 0, t = 0; i < n; i++) {\\n            if (prizePositions[i] - prizePositions[j] > k) j++;\\n            t = Math.max(t, i - j + 1);\\n            a[i] = t;\\n        }\\n        for (int i = n - 1, j = n - 1, t = 0; i >= 0; i--) {\\n            if (prizePositions[j] - prizePositions[i] > k) j--;\\n            t = Math.max(t, j - i + 1);\\n            b[i] = t;\\n        }\\n        int res = 0;\\n        for (int i = 0; i + 1 < n; i++) res = Math.max(res, a[i] + b[i + 1]);\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& p, int k) {\\n        std::ios::sync_with_stdio(false);\\n        std::cin.tie(nullptr);\\n        int n=p.size(),ans=0;\\n        for(int i=0,r=0,l=0,v=0;i<n;++i){\\n            while(r<n&&p[r]-p[i]<=k)++r;\\n            p[i]=r-i;\\n            while(p[l]+l<=i)v=max(v,p[l++]);\\n            ans=max(ans,l?v+p[i]:p[i]+i);\\n            if(r==n)return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def maximizeWin(self, pos: List[int], k: int) -> int:\\n        n = len(pos)\\n        if k*2+1 >= pos[-1] - pos[0]: return n\\n        pre = [0] * (n + 1)\\n        ans = left = 0\\n        for right, p in enumerate(pos):\\n            while p - pos[left] > k:\\n                left += 1\\n            sz = right - left + 1\\n            res = sz + pre[left]\\n            if res > ans: ans = res\\n            if sz >= pre[right]: pre[right+1] = sz\\n            else: pre[right+1] = pre[right]\\n        return ans\\n```\n```Java []\\nclass Solution {\\n    public int maximizeWin(int[] prizePositions, int k) {\\n        int n = prizePositions.length;\\n        if (prizePositions[n - 1] - prizePositions[0] <= k * 2) return n;\\n        int[] a = new int[n], b = new int[n];\\n        for (int i = 0, j = 0, t = 0; i < n; i++) {\\n            if (prizePositions[i] - prizePositions[j] > k) j++;\\n            t = Math.max(t, i - j + 1);\\n            a[i] = t;\\n        }\\n        for (int i = n - 1, j = n - 1, t = 0; i >= 0; i--) {\\n            if (prizePositions[j] - prizePositions[i] > k) j--;\\n            t = Math.max(t, j - i + 1);\\n            b[i] = t;\\n        }\\n        int res = 0;\\n        for (int i = 0; i + 1 < n; i++) res = Math.max(res, a[i] + b[i + 1]);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146031,
                "title": "easy-to-understand-using-dp-c",
                "content": "# Intuition\\nUsing Dp || c++\\n\\n# Approach\\nBeats 100% of solution\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n           int n=prizePositions.size(),res=0,j=0;\\n        vector<int> dp(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            while(prizePositions[i]-prizePositions[j]>k)\\n            {\\n                j++;\\n            }\\n            dp[i+1]=max(dp[i],i-j+1);\\n            res=max(res,dp[j]+i-j+1);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n           int n=prizePositions.size(),res=0,j=0;\\n        vector<int> dp(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            while(prizePositions[i]-prizePositions[j]>k)\\n            {\\n                j++;\\n            }\\n            dp[i+1]=max(dp[i],i-j+1);\\n            res=max(res,dp[j]+i-j+1);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145879,
                "title": "maximize-win-from-two-segments-easy-c-solution",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<vector<int>>dp;\\n    int index(int i,int k,vector<int>&a){\\n        int lo=i,hi=a.size()-1,mid,ans=-1;\\n        while(lo<=hi){\\n            mid=lo+(hi-lo)/2;\\n            if((a[mid]-a[i])==k){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else if((a[mid]-a[i])>k){\\n                hi=mid-1;\\n            }\\n            else lo=mid+1;\\n        }\\n        return ans;\\n    }\\n    int solve(int i,int n,int k,int cnt,vector<int>&a){\\n        if(i>=n||cnt>=2)return 0;\\n        if(dp[i][cnt]!=-1)return dp[i][cnt];\\n        int cur=a[i];\\n        int s=lower_bound(a.begin()+i,a.end(),cur+k)-a.begin();\\n        \\n        int nxt=index(i,k,a);\\n        int without=solve(i+1,n,k,cnt,a);\\n        int with=0;\\n       \\n         if(nxt!=-1)with=(nxt-i+1)+solve(nxt+1,n,k,cnt+1,a);// a[i]+k exist and in this case we will go to the farthest point till we get a[i]+k that\\'s i use index function with binary search\\n        \\n         else with=(s-1-i+1)+solve(s,n,k,cnt+1,a);//means a[i]+k doesn\\'t exist in the array so we assume that a[i]+k exists and at index s\\n        \\n        return dp[i][cnt]=max(with,without);\\n    }\\n    int maximizeWin(vector<int>&a, int k) {\\n        int n=a.size();\\n        dp=vector<vector<int>>(n+1,vector<int>(3,-1));\\n        return solve(0,n,k,0,a);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    vector<vector<int>>dp;\\n    int index(int i,int k,vector<int>&a){\\n        int lo=i,hi=a.size()-1,mid,ans=-1;\\n        while(lo<=hi){\\n            mid=lo+(hi-lo)/2;\\n            if((a[mid]-a[i])==k){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else if((a[mid]-a[i])>k){\\n                hi=mid-1;\\n            }\\n            else lo=mid+1;\\n        }\\n        return ans;\\n    }\\n    int solve(int i,int n,int k,int cnt,vector<int>&a){\\n        if(i>=n||cnt>=2)return 0;\\n        if(dp[i][cnt]!=-1)return dp[i][cnt];\\n        int cur=a[i];\\n        int s=lower_bound(a.begin()+i,a.end(),cur+k)-a.begin();\\n        \\n        int nxt=index(i,k,a);\\n        int without=solve(i+1,n,k,cnt,a);\\n        int with=0;\\n       \\n         if(nxt!=-1)with=(nxt-i+1)+solve(nxt+1,n,k,cnt+1,a);// a[i]+k exist and in this case we will go to the farthest point till we get a[i]+k that\\'s i use index function with binary search\\n        \\n         else with=(s-1-i+1)+solve(s,n,k,cnt+1,a);//means a[i]+k doesn\\'t exist in the array so we assume that a[i]+k exists and at index s\\n        \\n        return dp[i][cnt]=max(with,without);\\n    }\\n    int maximizeWin(vector<int>&a, int k) {\\n        int n=a.size();\\n        dp=vector<vector<int>>(n+1,vector<int>(3,-1));\\n        return solve(0,n,k,0,a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145872,
                "title": "c-dp-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& P, int k) {\\n        int res = 0, dp[100001]{};\\n        for(int i = 0, j = 0; i < P.size(); i++) {\\n            while(P[i]-P[j] > k) j++;\\n            int cnt = i - j + 1;\\n            res = max(res, cnt + (j > 1 ? dp[j-1] : 0));\\n            dp[i] = max(i > 0 ? dp[i-1] : 0, cnt);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& P, int k) {\\n        int res = 0, dp[100001]{};\\n        for(int i = 0, j = 0; i < P.size(); i++) {\\n            while(P[i]-P[j] > k) j++;\\n            int cnt = i - j + 1;\\n            res = max(res, cnt + (j > 1 ? dp[j-1] : 0));\\n            dp[i] = max(i > 0 ? dp[i-1] : 0, cnt);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145800,
                "title": "java-easy-explained-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Dp to store the elements with the pervious n value max prizes.\\nMake the check for part which is with in the limits of K.\\nStore the max value in ans .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Use Dp and Sliding Window .\\nWhile loop checks that element is in sliding window limit.**\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeWin(int[] a, int k) {\\n        int j=0,i=0;\\n        int n = a.length;\\n        int dp[]=new int[n+1];\\n        int ans =0;\\n        for(i=0;i<a.length;i++)\\n        {\\n            while(a[i]-a[j]>k)\\n            j++;\\n            dp[i+1] = Math.max(dp[i],i-j+1);\\n            ans = Math.max(ans,dp[j]+i-j+1);\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeWin(int[] a, int k) {\\n        int j=0,i=0;\\n        int n = a.length;\\n        int dp[]=new int[n+1];\\n        int ans =0;\\n        for(i=0;i<a.length;i++)\\n        {\\n            while(a[i]-a[j]>k)\\n            j++;\\n            dp[i+1] = Math.max(dp[i],i-j+1);\\n            ans = Math.max(ans,dp[j]+i-j+1);\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145758,
                "title": "2555-maximize-win-from-two-segments-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding window with Dynamic programming \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nin dp[i], always maintain the maximum length of window from 0 to i which satisfy condition of k, so that can be used as first window segment and consider current window as second segment.\\nMaintain answer at every sliding window position and return answer\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int maximizeWin(int[] pp, int k) {\\n        int n=pp.length;\\n        int[] dp=new int[n];//ith ele tk maxi kitna window aa skta\\n        int l=0;int r=0;\\n        int ans=0;\\n        while(r<n){\\n            while(pp[r]-pp[l]>k){\\n                l++;\\n            }\\n            ans=Math.max(ans,(r-l+1)+(l>0?dp[l-1]:0));\\n            dp[r]=Math.max(r-l+1,r>0?dp[r-1]:0);\\n            r++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeWin(int[] pp, int k) {\\n        int n=pp.length;\\n        int[] dp=new int[n];//ith ele tk maxi kitna window aa skta\\n        int l=0;int r=0;\\n        int ans=0;\\n        while(r<n){\\n            while(pp[r]-pp[l]>k){\\n                l++;\\n            }\\n            ans=Math.max(ans,(r-l+1)+(l>0?dp[l-1]:0));\\n            dp[r]=Math.max(r-l+1,r>0?dp[r-1]:0);\\n            r++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145489,
                "title": "interview-friendly-java-o-n-sliding-window-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to [LC : 1031](https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/description/)\\n\\n# Complexity\\n\\n    n -> length of prizePositions Array\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeWin(int[] prizePositions, int k) {\\n        \\n        int result = 0;\\n        ArrayList<Integer> numLine = new ArrayList<>();\\n        Map<Integer, Integer> prizesMap = new HashMap<>();\\n\\n\\n        for(int i = 0 ; i < prizePositions.length; i++){\\n            \\n            int freq = prizesMap.getOrDefault(prizePositions[i], 0);\\n            if(freq == 0){\\n                numLine.add(prizePositions[i]);\\n            }\\n            prizesMap.put( prizePositions[i], freq + 1);\\n        }\\n\\n        // calculate prefix sum\\n        int prefixSum = 0;\\n        for(int i =0; i < numLine.size(); i++){\\n            prefixSum += prizesMap.get(numLine.get(i));\\n            prizesMap.put(numLine.get(i), prefixSum);\\n        }\\n\\n        // dp array to maintain max prizes in previous all k size windows\\n        int[] dp = new int[numLine.size()];\\n\\n        int l = 0; // iterators for current window //  left \\n        int r = 0;  // right\\n\\n        int prevMaxWindow = 0; // previous window of k len with maximum prizes\\n        int prizesInCurrWin = 0;\\n        \\n        while( r < numLine.size()){\\n            \\n            int lastIndex = numLine.get(l);\\n            int currIndex = numLine.get(r);\\n\\n            while(currIndex - lastIndex > k){\\n                l++;\\n                lastIndex = numLine.get(l);\\n            }\\n\\n            // calculate prevMaxWindow\\n            prevMaxWindow = 0;\\n            if(l - 1 >= 0){\\n                prevMaxWindow = dp[l - 1];\\n            }\\n\\n             // calculate prizesInCurrWin\\n               \\n            prizesInCurrWin = prizesMap.get(currIndex);\\n            if(l - 1 >=0){\\n                prizesInCurrWin -= prizesMap.get(numLine.get(l - 1));\\n            }\\n\\n            result = Math.max(result, prizesInCurrWin + prevMaxWindow);\\n            dp[r] = Math.max(r - 1>= 0 ?  dp[r - 1] : 0, prizesInCurrWin);\\n            r++;\\n        }\\n\\n        return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeWin(int[] prizePositions, int k) {\\n        \\n        int result = 0;\\n        ArrayList<Integer> numLine = new ArrayList<>();\\n        Map<Integer, Integer> prizesMap = new HashMap<>();\\n\\n\\n        for(int i = 0 ; i < prizePositions.length; i++){\\n            \\n            int freq = prizesMap.getOrDefault(prizePositions[i], 0);\\n            if(freq == 0){\\n                numLine.add(prizePositions[i]);\\n            }\\n            prizesMap.put( prizePositions[i], freq + 1);\\n        }\\n\\n        // calculate prefix sum\\n        int prefixSum = 0;\\n        for(int i =0; i < numLine.size(); i++){\\n            prefixSum += prizesMap.get(numLine.get(i));\\n            prizesMap.put(numLine.get(i), prefixSum);\\n        }\\n\\n        // dp array to maintain max prizes in previous all k size windows\\n        int[] dp = new int[numLine.size()];\\n\\n        int l = 0; // iterators for current window //  left \\n        int r = 0;  // right\\n\\n        int prevMaxWindow = 0; // previous window of k len with maximum prizes\\n        int prizesInCurrWin = 0;\\n        \\n        while( r < numLine.size()){\\n            \\n            int lastIndex = numLine.get(l);\\n            int currIndex = numLine.get(r);\\n\\n            while(currIndex - lastIndex > k){\\n                l++;\\n                lastIndex = numLine.get(l);\\n            }\\n\\n            // calculate prevMaxWindow\\n            prevMaxWindow = 0;\\n            if(l - 1 >= 0){\\n                prevMaxWindow = dp[l - 1];\\n            }\\n\\n             // calculate prizesInCurrWin\\n               \\n            prizesInCurrWin = prizesMap.get(currIndex);\\n            if(l - 1 >=0){\\n                prizesInCurrWin -= prizesMap.get(numLine.get(l - 1));\\n            }\\n\\n            result = Math.max(result, prizesInCurrWin + prevMaxWindow);\\n            dp[r] = Math.max(r - 1>= 0 ?  dp[r - 1] : 0, prizesInCurrWin);\\n            r++;\\n        }\\n\\n        return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145386,
                "title": "sliding-window-suffix-max-faster-than-100-o-n-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prize, int k) {\\n        int n=prize.size(), i=0, j=0;\\n        vector<int>collect(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            while(j<n && prize[j]-prize[i]<=k) j++;\\n            collect[i]=j-i; // storing number of prizes we can collect starting from current index until current index+k\\n        }\\n        vector<int>suffixMax(n);\\n        suffixMax[n-1]=collect[n-1];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            suffixMax[i]=max(collect[i], suffixMax[i+1]); // maintaining suffix max from ending \\n        }\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int firstEnding=collect[i]+i;\\n            int curAns=collect[i]; // number of prizes we can collect in first segment\\n            if(firstEnding<n)\\n            {\\n                curAns+=suffixMax[firstEnding]; // number of prizes we can collect in second segment\\n            }\\n            ans=max(ans, curAns);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prize, int k) {\\n        int n=prize.size(), i=0, j=0;\\n        vector<int>collect(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            while(j<n && prize[j]-prize[i]<=k) j++;\\n            collect[i]=j-i; // storing number of prizes we can collect starting from current index until current index+k\\n        }\\n        vector<int>suffixMax(n);\\n        suffixMax[n-1]=collect[n-1];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            suffixMax[i]=max(collect[i], suffixMax[i+1]); // maintaining suffix max from ending \\n        }\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int firstEnding=collect[i]+i;\\n            int curAns=collect[i]; // number of prizes we can collect in first segment\\n            if(firstEnding<n)\\n            {\\n                curAns+=suffixMax[firstEnding]; // number of prizes we can collect in second segment\\n            }\\n            ans=max(ans, curAns);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145254,
                "title": "easy-java-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int maximizeWin(int[] prize, int k) {\\n        int n = prize.length;\\n        \\n        int maxRange[] = new int[n+1];\\n        BestRange(prize,maxRange,0,n,k);\\n        \\n        int res = Integer.MIN_VALUE;\\n        \\n        for(int i=0; i<n; i++){\\n            int left=i;\\n            int right = searchIndex(prize,prize[i]+k);\\n            int curRes = right-left+1;\\n            curRes+=maxRange[right+1];\\n            res=Math.max(res,curRes);           \\n        }        \\n        return res;\\n    }\\n    \\n    int searchIndex(int []prize, int val){\\n        int low=0; int high=prize.length-1;\\n        int idx=0;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(prize[mid]<=val){\\n                idx=mid;\\n                low=mid+1;\\n            }else{\\n               high=mid-1; \\n            }\\n        }\\n        return idx;        \\n    }\\n    \\n    int BestRange(int []prize, int[]maxRange, int index, int n, int k){\\n        if(index==n) return 0;\\n        int right =  searchIndex(prize,prize[index]+k);\\n        int curRes = right-index+1;\\n        curRes = Math.max(curRes,BestRange(prize,maxRange,index+1,n,k));\\n        maxRange[index]=curRes;\\n        return curRes;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int maximizeWin(int[] prize, int k) {\\n        int n = prize.length;\\n        \\n        int maxRange[] = new int[n+1];\\n        BestRange(prize,maxRange,0,n,k);\\n        \\n        int res = Integer.MIN_VALUE;\\n        \\n        for(int i=0; i<n; i++){\\n            int left=i;\\n            int right = searchIndex(prize,prize[i]+k);\\n            int curRes = right-left+1;\\n            curRes+=maxRange[right+1];\\n            res=Math.max(res,curRes);           \\n        }        \\n        return res;\\n    }\\n    \\n    int searchIndex(int []prize, int val){\\n        int low=0; int high=prize.length-1;\\n        int idx=0;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(prize[mid]<=val){\\n                idx=mid;\\n                low=mid+1;\\n            }else{\\n               high=mid-1; \\n            }\\n        }\\n        return idx;        \\n    }\\n    \\n    int BestRange(int []prize, int[]maxRange, int index, int n, int k){\\n        if(index==n) return 0;\\n        int right =  searchIndex(prize,prize[index]+k);\\n        int curRes = right-index+1;\\n        curRes = Math.max(curRes,BestRange(prize,maxRange,index+1,n,k));\\n        maxRange[index]=curRes;\\n        return curRes;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145228,
                "title": "simple-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will use simple intuition like we need to find two segments so we will  take every segment and find what is the maximum segment we can obtain for our selected segment on the right side of the array and add to it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all,any segment we selected should start with an element present in it greedy way. So we need to iterate only the elements present in set of array. so we can get both ends of any segment like one end is ```i``` and other is ```i+k``` say as j. we can use binary search to find number of elements in between them say as ```count```. and push into array left with starting index ```i``` and ```count```.\\nAfter that maintain an array say ```right``` which stores maximum count we can get after that point.\\nThat\\'s it do iterate left and do binary search in right to find maximum we can get. \\n\\n# Complexity\\n- Time complexity:$$O(nlog(n))$$\\n\\n\\n- Space complexity:$$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        l=prizePositions\\n        l=sorted(l)\\n        i=1\\n        left=[]\\n        u=sorted(list(set(prizePositions)))\\n        #iterate only elements present in it\\n        for i in u:\\n            j=min(i+k,l[-1])\\n            lower=bisect.bisect_left(l,i)\\n            upper=bisect.bisect_right(l,j)\\n            left.append([i,upper-lower])\\n        right=[[0,0]]\\n        #calculating right maximum for every segment\\n        for i in t[::-1]:\\n            right.append([i[0],max(right[-1][1],i[1])])\\n        right=right[1:]\\n        right=right[::-1]\\n        right.append([float(\\'inf\\'),0])\\n        res=0\\n            \\n        for i in left:\\n            v=bisect.bisect_right(right,[i[0]+k+1,0])\\n            if v==len(right):\\n                v-=1\\n            res=max(res,i[1]+right[v][1])\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```i```\n```i+k```\n```count```\n```i```\n```count```\n```right```\n```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        l=prizePositions\\n        l=sorted(l)\\n        i=1\\n        left=[]\\n        u=sorted(list(set(prizePositions)))\\n        #iterate only elements present in it\\n        for i in u:\\n            j=min(i+k,l[-1])\\n            lower=bisect.bisect_left(l,i)\\n            upper=bisect.bisect_right(l,j)\\n            left.append([i,upper-lower])\\n        right=[[0,0]]\\n        #calculating right maximum for every segment\\n        for i in t[::-1]:\\n            right.append([i[0],max(right[-1][1],i[1])])\\n        right=right[1:]\\n        right=right[::-1]\\n        right.append([float(\\'inf\\'),0])\\n        res=0\\n            \\n        for i in left:\\n            v=bisect.bisect_right(right,[i[0]+k+1,0])\\n            if v==len(right):\\n                v-=1\\n            res=max(res,i[1]+right[v][1])\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145081,
                "title": "c-recursive-soln-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/71440440-ae89-4845-a16d-1d42c8262c32_1675583151.6232393.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int n,vector<int>& pp,vector<int>& total_count,int seg,vector<vector<int>>& dp){\\n        if(i==n) return 0;\\n        if(dp[i][seg]!=-1) return dp[i][seg];\\n        if(seg<=1){\\n            return dp[i][seg] =   max(total_count[i]+solve(i+total_count[i],n,pp,total_count,seg+1,dp)  ,\\n            solve(i+1,n,pp,total_count,seg,dp));\\n        }\\n        return 0;\\n    }\\n    int maximizeWin(vector<int>& pp, int k) {\\n        int n = pp.size();\\n        vector<int> total_count(n);\\n        int l=0,r=0;\\n        if(k >= pp[n-1]) return n;\\n        while(r<n){\\n            while(r<n && pp[r] - pp[l] <=k ) r++;\\n            total_count[l] = r - l; // store segment size for every index\\n            l++;\\n        }\\n        while(l<n){\\n             total_count[l] = n - l;  // store segment size for remaining index\\n             l++;\\n        }\\n        vector<vector<int>> dp(n,vector<int> (3,-1)); //memoization\\n        return solve(0,n,pp,total_count,0,dp);\\n    }\\n};\\n```\\nPlease UPVOTE if you find it helpful !! Thank you !!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int n,vector<int>& pp,vector<int>& total_count,int seg,vector<vector<int>>& dp){\\n        if(i==n) return 0;\\n        if(dp[i][seg]!=-1) return dp[i][seg];\\n        if(seg<=1){\\n            return dp[i][seg] =   max(total_count[i]+solve(i+total_count[i],n,pp,total_count,seg+1,dp)  ,\\n            solve(i+1,n,pp,total_count,seg,dp));\\n        }\\n        return 0;\\n    }\\n    int maximizeWin(vector<int>& pp, int k) {\\n        int n = pp.size();\\n        vector<int> total_count(n);\\n        int l=0,r=0;\\n        if(k >= pp[n-1]) return n;\\n        while(r<n){\\n            while(r<n && pp[r] - pp[l] <=k ) r++;\\n            total_count[l] = r - l; // store segment size for every index\\n            l++;\\n        }\\n        while(l<n){\\n             total_count[l] = n - l;  // store segment size for remaining index\\n             l++;\\n        }\\n        vector<vector<int>> dp(n,vector<int> (3,-1)); //memoization\\n        return solve(0,n,pp,total_count,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144893,
                "title": "python-sliding-window-dp-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding Window\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nObserve that the array values denotes the index of prizes and the difference between left and right indexes of our window `(right - left + 1)` will give the number of prize collected. So in my solution this value is used to compare with the previously encountered value. We keep on filling the `dp` and finding the ans while we linearly traverse the array.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        dp, left, ans = [0] * (len(prizePositions) + 1), 0, 0\\n        for right in range(len(prizePositions)):\\n            while prizePositions[right] - prizePositions[left] > k:\\n                left += 1\\n            dp[right + 1] = max(dp[right], right - left + 1)\\n            ans = max(ans, dp[left] + right - left + 1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```python []\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        dp, left, ans = [0] * (len(prizePositions) + 1), 0, 0\\n        for right in range(len(prizePositions)):\\n            while prizePositions[right] - prizePositions[left] > k:\\n                left += 1\\n            dp[right + 1] = max(dp[right], right - left + 1)\\n            ans = max(ans, dp[left] + right - left + 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144817,
                "title": "c-sliding-window-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. We can solve this problem easily using sliding window method if there was only one window to select from.\\n2. Now, there are two windows, so we need to find two windows such that there prizes sum is maximum.\\n3. We can use dp to store the previously prize obtained from diffrent windows while traversing the array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Observe that the array values denotes the index of prizes and the difference between left and right indexes of our window(r-l+1) will give the number of prize collected.\\n2. So in my solution this value is used to compare with the previously encountered value.\\n3. We keep on filling the dp and finding the ans while we linearly traverse the array.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Sliding window + DP\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        int l=0,ans=0;\\n        vector<int>dp(n+1,0);\\n\\n        for(int r=0;r<n;r++){\\n            while(prizePositions[r]-prizePositions[l]>k)\\n                l++; // to maintain the window size\\n            \\n            dp[r+1] = max(dp[r],r-l+1); // r-l+1 will give the number of prices picked in that window of l and r\\n            ans = max(ans,dp[l]+r-l+1); // getting the max sum\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Sliding window + DP\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        int l=0,ans=0;\\n        vector<int>dp(n+1,0);\\n\\n        for(int r=0;r<n;r++){\\n            while(prizePositions[r]-prizePositions[l]>k)\\n                l++; // to maintain the window size\\n            \\n            dp[r+1] = max(dp[r],r-l+1); // r-l+1 will give the number of prices picked in that window of l and r\\n            ans = max(ans,dp[l]+r-l+1); // getting the max sum\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144666,
                "title": "c-top-down-dp-based-on-knapsack-upper-bound",
                "content": "```\\nclass Solution {\\npublic:\\n// idx denote the current index\\n// cnt denote how many segments are left to be placed out of 2 segments\\n    int f(int idx, int cnt, vector<int>& a, int k, vector<vector<int>>& dp) {\\n        int n = a.size();\\n        if(idx >= n) return 0;\\n        \\n        if(dp[idx][cnt] != -1) return dp[idx][cnt];\\n        int place = 0, notPlace = 0;\\n        \\n\\t\\t// if we are placing one segment at a current index then it will cover all the prices with value less than a[idx] + k as the size of the segment is k\\n        int i = upper_bound(a.begin(), a.end(), a[idx] + k) - a.begin();\\n        \\n        if(cnt > 0) { \\n\\t\\t//take all the prices in the range (i - idx) and go to the index i \\n            place = min(n, i) - idx + f(i, cnt - 1, a, k, dp);\\n        }\\n        \\n\\t\\t// if we are not placing segment at the current index, then we need to skip all the prices with the same value as the lie on the same point on the x-axis\\n        int i2 = upper_bound(a.begin(), a.end(), a[idx]) - a.begin();\\n        notPlace = f(i2, cnt, a, k, dp);\\n        \\n        return dp[idx][cnt] = max(place, notPlace);\\n    }\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        vector<vector<int>>dp(n + 5, vector<int>(5, -1));\\n        return f(0, 2, prizePositions, k, dp);\\n    }\\n};\\n//upvote if you like the solution\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n// idx denote the current index\\n// cnt denote how many segments are left to be placed out of 2 segments\\n    int f(int idx, int cnt, vector<int>& a, int k, vector<vector<int>>& dp) {\\n        int n = a.size();\\n        if(idx >= n) return 0;\\n        \\n        if(dp[idx][cnt] != -1) return dp[idx][cnt];\\n        int place = 0, notPlace = 0;\\n        \\n\\t\\t// if we are placing one segment at a current index then it will cover all the prices with value less than a[idx] + k as the size of the segment is k\\n        int i = upper_bound(a.begin(), a.end(), a[idx] + k) - a.begin();\\n        \\n        if(cnt > 0) { \\n\\t\\t//take all the prices in the range (i - idx) and go to the index i \\n            place = min(n, i) - idx + f(i, cnt - 1, a, k, dp);\\n        }\\n        \\n\\t\\t// if we are not placing segment at the current index, then we need to skip all the prices with the same value as the lie on the same point on the x-axis\\n        int i2 = upper_bound(a.begin(), a.end(), a[idx]) - a.begin();\\n        notPlace = f(i2, cnt, a, k, dp);\\n        \\n        return dp[idx][cnt] = max(place, notPlace);\\n    }\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        vector<vector<int>>dp(n + 5, vector<int>(5, -1));\\n        return f(0, 2, prizePositions, k, dp);\\n    }\\n};\\n//upvote if you like the solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144072,
                "title": "c-o-n-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe starting point of the interval should be the position in the array. For each starting point `prizePositions[i]`, we can find the smallest endpoint `j` such that `prizePositions[j] > prizePositions[i] + k`. The prize of the interval is `j-i`.\\n\\nObserving the larger the starting point, the larger the endpoint. So sliding window should be applied to make the algorithm O(n).\\n\\nClaim: Optimally selecting two non-intersecting interval is always non-inferior to the optimal selecting two intersecting inteval.\\n \\nWe should not make two intervals intersect because the prize cannot be taken twice. It is always better to choose the second interval that start after the endpoint of the first interval. So we have to prepare an array `bestProfit[j]` that stores the maximal possible profit we can get after index `j` and build a vector to store the minimal starting index of the second interval if we choose `i..j-1` as the first interval.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSliding Window.\\n\\nFirstly we will store the maximal profit with a starting point at `prizePositions[i]` at `profit[i]`, find the next non-overlapping starting position `j` at `nextPosition[i]`, and prepare `bestProfit[j]` as the maximal possible profit of an interval with a starting point `>= prizePosition[j]`. The answer is maximum of `profit[i] + bestProfit[nextPosition[i]]`. The special case is when `nextPosition[i] == n`, in that case we can purely set the second term to be 0.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        vector<int> bestProfit(n, 0);\\n        vector<int> profit(n, 0);\\n        vector<int> nextPosition(n, -1);\\n        int j = 0;\\n        for (int i = 0; i < n; ++i) {\\n            while (j < n && prizePositions[j] - prizePositions[i] <= k) {++j;}\\n            profit[i] = j-i;\\n            nextPosition[i] = j;\\n        }\\n        bestProfit[n-1] = profit[n-1];\\n        for (int i = n-2; i >= 0; --i) {\\n            bestProfit[i] = max(profit[i], bestProfit[i+1]);\\n        }\\n        int res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            res = max(res, profit[i] + (nextPosition[i] == n?0:bestProfit[nextPosition[i]]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        vector<int> bestProfit(n, 0);\\n        vector<int> profit(n, 0);\\n        vector<int> nextPosition(n, -1);\\n        int j = 0;\\n        for (int i = 0; i < n; ++i) {\\n            while (j < n && prizePositions[j] - prizePositions[i] <= k) {++j;}\\n            profit[i] = j-i;\\n            nextPosition[i] = j;\\n        }\\n        bestProfit[n-1] = profit[n-1];\\n        for (int i = n-2; i >= 0; --i) {\\n            bestProfit[i] = max(profit[i], bestProfit[i+1]);\\n        }\\n        int res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            res = max(res, profit[i] + (nextPosition[i] == n?0:bestProfit[nextPosition[i]]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143577,
                "title": "100-fast-100-space-efficient-c-recursion-hashmap",
                "content": "***Only world where Parts having power same as whole is The kingdom of Recursion***\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>vp;\\n    int k;\\n    vector<vector<int>>memo;\\n    int rec(int i,bool picked_one){\\n        if(i>=vp.size())return 0;\\n        if(memo[i][picked_one]!=-1)return memo[i][picked_one];\\n        if(picked_one==0){\\n            int curr=i;int lim=vp[i].first+k;\\n            int sum=0;\\n            while(curr<vp.size()&&vp[curr].first<=lim){sum+=vp[curr++].second;}\\n            return memo[i][picked_one]=max(sum+rec(curr,true),rec(i+1,false));\\n        }else{\\n            int curr=i;int lim=vp[i].first+k;\\n            int sum=0;\\n            while(curr<vp.size()&&vp[curr].first<=lim){sum+=vp[curr++].second;}\\n            return memo[i][picked_one]=max(sum,rec(i+1,true));\\n        }\\n    }\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        map<int,int>mp;this->k=k;\\n        for(auto &position:prizePositions)mp[position]++;\\n        for(auto &freq:mp)vp.push_back(freq);memo.assign(vp.size(),vector<int>(2,-1));\\n        return rec(0,0);\\n    }\\n};\\n```\\n**logik:**\\n1. Use hashmap to store frequencies, make a global vector pair and push all the frequency pairs in it\\n2. Now we can take prizes from given vector pair only 2 times \\n3. There is no point of using the fact that overlapping is possible as prizes would be counted only once even if max lengths overlap, So we will begin our second selection after the point where our first end\\n4. make recursion with iterator i and picked_once to tell if you have picked once and now when you pick you will not explore further and return sum \\n5. at each point in recursion we either start picking from given point and if we do we only pick once more \\n6. if we don\\'t pick we can continue exploring further for our first and second pick, and we return the sum of frequencies of all the objects we picked\\n![image](https://assets.leetcode.com/users/images/38aef632-2b1d-4c22-bc2d-ee83a624686a_1675568330.2027087.png)\\n",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>vp;\\n    int k;\\n    vector<vector<int>>memo;\\n    int rec(int i,bool picked_one){\\n        if(i>=vp.size())return 0;\\n        if(memo[i][picked_one]!=-1)return memo[i][picked_one];\\n        if(picked_one==0){\\n            int curr=i;int lim=vp[i].first+k;\\n            int sum=0;\\n            while(curr<vp.size()&&vp[curr].first<=lim){sum+=vp[curr++].second;}\\n            return memo[i][picked_one]=max(sum+rec(curr,true),rec(i+1,false));\\n        }else{\\n            int curr=i;int lim=vp[i].first+k;\\n            int sum=0;\\n            while(curr<vp.size()&&vp[curr].first<=lim){sum+=vp[curr++].second;}\\n            return memo[i][picked_one]=max(sum,rec(i+1,true));\\n        }\\n    }\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        map<int,int>mp;this->k=k;\\n        for(auto &position:prizePositions)mp[position]++;\\n        for(auto &freq:mp)vp.push_back(freq);memo.assign(vp.size(),vector<int>(2,-1));\\n        return rec(0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143356,
                "title": "python-what-s-wrong-with-my-solution",
                "content": "```py\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], kk: int) -> int:\\n        c = Counter(prizePositions)\\n        arr = []\\n        for k,v in c.items():\\n            arr.append([k,v])\\n        arr.sort()\\n        pref = []\\n        \\n        pref.append(arr[0][1])\\n        for i in range(1, len(arr)):\\n            pref.append(pref[-1] + arr[i][1])\\n        \\n        windows = []\\n        for i in range(len(arr)):\\n            r = bisect_right(arr, arr[i][0]+kk, key=lambda k: k[0])-1\\n            \\n            left = pref[i-1] if i-1 >= 0 else 0\\n            windows.append([pref[r]-left, [arr[i][0], arr[r][0]], [i-1, r]])\\n        \\n        windows.sort(reverse=True)\\n        res = 0\\n        big = windows[0][0]\\n        for i in range(1, len(windows)):\\n            w,a,p = windows[i]\\n            l = max(windows[0][2][0], p[0])\\n            r = min(windows[0][2][1], p[1])\\n            overlap=0\\n            if r>=l:\\n                overlap = pref[r]- pref[l]\\n            print(l,r,overlap)\\n            res = max(res, big+w-overlap)\\n            \\n        return res\\n        #return sum(windows[-2:])\\n        ```\\n\\t\\t\\n\\t\\tI find all windows of size k and then i find the largest one, and then the second one which has the maximum total minus the overlap",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], kk: int) -> int:\\n        c = Counter(prizePositions)\\n        arr = []\\n        for k,v in c.items():\\n            arr.append([k,v])\\n        arr.sort()\\n        pref = []\\n        \\n        pref.append(arr[0][1])\\n        for i in range(1, len(arr)):\\n            pref.append(pref[-1] + arr[i][1])\\n        \\n        windows = []\\n        for i in range(len(arr)):\\n            r = bisect_right(arr, arr[i][0]+kk, key=lambda k: k[0])-1\\n            \\n            left = pref[i-1] if i-1 >= 0 else 0\\n            windows.append([pref[r]-left, [arr[i][0], arr[r][0]], [i-1, r]])\\n        \\n        windows.sort(reverse=True)\\n        res = 0\\n        big = windows[0][0]\\n        for i in range(1, len(windows)):\\n            w,a,p = windows[i]\\n            l = max(windows[0][2][0], p[0])\\n            r = min(windows[0][2][1], p[1])\\n            overlap=0\\n            if r>=l:\\n                overlap = pref[r]- pref[l]\\n            print(l,r,overlap)\\n            res = max(res, big+w-overlap)\\n            \\n        return res\\n        #return sum(windows[-2:])\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 3143251,
                "title": "python-sliding-window-simple-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximizeWin(self, P: List[int], k: int) -> int:\\n        n = len(P)\\n        def leftMaximize(P):\\n            i = 0\\n            curmax = 0\\n            left = [0]*n\\n            for j, p in enumerate(P):\\n                while abs(p - P[i]) > k:\\n                    i += 1\\n                curmax = max(curmax, j - i + 1)\\n                left[j] = curmax\\n            return left\\n        left = leftMaximize(P)\\n        right = list(reversed(leftMaximize(P[::-1])))\\n        res = 0\\n        for i in range(n):\\n            res = max(res, left[i] + (right[i+1] if i + 1 != n else 0))\\n        return res\\n            \\n        \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeWin(self, P: List[int], k: int) -> int:\\n        n = len(P)\\n        def leftMaximize(P):\\n            i = 0\\n            curmax = 0\\n            left = [0]*n\\n            for j, p in enumerate(P):\\n                while abs(p - P[i]) > k:\\n                    i += 1\\n                curmax = max(curmax, j - i + 1)\\n                left[j] = curmax\\n            return left\\n        left = leftMaximize(P)\\n        right = list(reversed(leftMaximize(P[::-1])))\\n        res = 0\\n        for i in range(n):\\n            res = max(res, left[i] + (right[i+1] if i + 1 != n else 0))\\n        return res\\n            \\n        \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143141,
                "title": "python-beats-100-o-n-time-overlapping-of-two-subarrays",
                "content": "intuition:\\nget max non overlapping of  two subarrays , there\\'s question in leetcode which is similar to this , just tweak it a little \\n```\\n\\nclass Solution:\\n    def maximizeWin(self, p: List[int], k: int) -> int:\\n        count = Counter(p)\\n        p = list(count.keys())\\n        # first segement\\n        fq = deque()\\n        # second segement\\n        sq = deque()\\n        \\n        #first queue for first  segement\\n        for i in range(0,min(k+1,len(p))):\\n            n = p[i]\\n            if fq and n - fq[0][0] > k:\\n                break\\n            fq.append((n,count[n],i))\\n            \\n        #second queue for second  segement\\n\\n        for i in range(min(len(fq),len(p)), len(p)):\\n            n = p[i]\\n            if sq and n - sq[0][0] > k : break\\n            sq.append((n,count[n],i))\\n            \\n            \\n        first = prevMax = sum(c for v, c,i in fq)\\n        second = sum(c for v,c,i in sq)\\n\\n        res = first + second\\n        for i in range(len(fq) + len(sq) , len(p)):\\n            #extend second segement one point forword\\n            while sq and p[i] - sq[0][0] > k : \\n                second -= sq.popleft()[1]\\n            sq.append((p[i],count[p[i]],i))\\n            second += count[p[i]]\\n            res = max(second + prevMax,res)\\n            #extend first segement one point forword till the start of the second segement \\n            #while extending update best first seg and get max res till now\\n\\n            while  fq[-1][-1] + 1 < sq[0][-1] :\\n                j = fq[-1][-1] + 1\\n                while fq and p[j] - fq[0][0] > k :\\n                    first -= fq.popleft()[1]\\n                fq.append((p[j],count[p[j]],j))\\n                first += count[p[j]]\\n                prevMax = max(first,prevMax)\\n                res = max(second+prevMax,res)\\n\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\n\\nclass Solution:\\n    def maximizeWin(self, p: List[int], k: int) -> int:\\n        count = Counter(p)\\n        p = list(count.keys())\\n        # first segement\\n        fq = deque()\\n        # second segement\\n        sq = deque()\\n        \\n        #first queue for first  segement\\n        for i in range(0,min(k+1,len(p))):\\n            n = p[i]\\n            if fq and n - fq[0][0] > k:\\n                break\\n            fq.append((n,count[n],i))\\n            \\n        #second queue for second  segement\\n\\n        for i in range(min(len(fq),len(p)), len(p)):\\n            n = p[i]\\n            if sq and n - sq[0][0] > k : break\\n            sq.append((n,count[n],i))\\n            \\n            \\n        first = prevMax = sum(c for v, c,i in fq)\\n        second = sum(c for v,c,i in sq)\\n\\n        res = first + second\\n        for i in range(len(fq) + len(sq) , len(p)):\\n            #extend second segement one point forword\\n            while sq and p[i] - sq[0][0] > k : \\n                second -= sq.popleft()[1]\\n            sq.append((p[i],count[p[i]],i))\\n            second += count[p[i]]\\n            res = max(second + prevMax,res)\\n            #extend first segement one point forword till the start of the second segement \\n            #while extending update best first seg and get max res till now\\n\\n            while  fq[-1][-1] + 1 < sq[0][-1] :\\n                j = fq[-1][-1] + 1\\n                while fq and p[j] - fq[0][0] > k :\\n                    first -= fq.popleft()[1]\\n                fq.append((p[j],count[p[j]],j))\\n                first += count[p[j]]\\n                prevMax = max(first,prevMax)\\n                res = max(second+prevMax,res)\\n\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143099,
                "title": "javascript-treemap-327ms",
                "content": "```\\n////////////////////////// Template ////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nfunction TreeMap(g) {\\n    let ts = [], m = new Map(), bisect = new Bisect();\\n    initialize();\\n    return { set, get, firstKey, lastKey, keys, pollFirstEntry, pollLastEntry, ceilingKey, higherKey, lowerKey, floorKey, ceilingEntry, higherEntry, lowerEntry, floorEntry, remove, has, size, findKth, clear, show };\\n    function initialize() {\\n        if (g) {\\n            for (const [k, v] of g) {\\n                if (!m.has(k)) bisect.insort_right(ts, k);\\n                m.set(k, v);\\n            }\\n        }\\n    }\\n    function set(k, v) {\\n        if (!m.has(k)) bisect.insort_right(ts, k); // ts has no duplicates/unique key\\n        m.set(k, v); // update key with most recent value\\n    }\\n    function get(k) {\\n        return m.get(k);\\n    }\\n    function keys() {\\n        return ts;\\n    }\\n    function firstKey() {\\n        return ts[0];\\n    }\\n    function lastKey() {\\n        return ts[ts.length - 1];\\n    }\\n    function pollFirstEntry() {\\n        let k = ts[0], v = m.get(k);\\n        ts.splice(0, 1);\\n        m.delete(k);\\n        return [k, v];\\n    }\\n    function pollLastEntry() {\\n        let k = ts.pop(), v = m.get(k);\\n        m.delete(k);\\n        return [k, v];\\n    }\\n    function ceilingKey(e) { // >= lower_bound\\n        let idx = bisect.bisect_right(ts, e);\\n        let res = ts[idx - 1] == e ? e : ts[bisect.bisect_right(ts, e)];\\n        return res == undefined ? null : res;\\n    }\\n    function higherKey(e) { // > upper_bound\\n        let idx = bisect.bisect_right(ts, e);\\n        let res = ts[idx] > e ? ts[idx] : ts[bisect.bisect_right(ts, e) + 1];\\n        return res == undefined ? null : res;\\n    }\\n    function floorKey(e) { // <= \\n        let idx = bisect.bisect_left(ts, e);\\n        let res = ts[idx] == e ? e : ts[bisect.bisect_left(ts, e) - 1];\\n        return res == undefined ? null : res;\\n    }\\n    function lowerKey(e) { // <\\n        let idx = bisect.bisect_left(ts, e);\\n        let res = ts[idx] < e ? ts[idx] : ts[bisect.bisect_left(ts, e) - 1];\\n        return res == undefined ? null : res;\\n    }\\n    function data(k) {\\n        return k == null ? null : { key: k, value: m.get(k) }\\n    }\\n    function ceilingEntry(k) {\\n        return data(ceilingKey(k));\\n    }\\n    function higherEntry(k) {\\n        return data(higherKey(k));\\n    }\\n    function floorEntry(k) {\\n        return data(floorKey(k));\\n    }\\n    function lowerEntry(k) {\\n        return data(lowerKey(k));\\n    }\\n    function remove(e) {\\n        let idx = bisect.bisect_left(ts, e);\\n        if (ts[idx] == e) ts.splice(idx, 1);\\n        m.delete(e);\\n    }\\n    function has(e) {\\n        return m.has(e);\\n    }\\n    function size() {\\n        return ts.length;\\n    }\\n    function findKth(k) {\\n        let cnt = 0;\\n        for (const x of ts) {\\n            let occ = m.get(x);\\n            if (cnt + occ < k) {\\n                cnt += occ;\\n            } else {\\n                return x;\\n            }\\n        }\\n    }\\n    function clear() {\\n        ts = [];\\n        m.clear();\\n    }\\n    function show() {\\n        let res = new Map();\\n        for (const x of ts) res.set(x, m.get(x));\\n        return res;\\n    }\\n}\\n///////////////////////////////////////////////////////////////////\\n\\nconst maximizeWin = (a, k) => {\\n    let m = new TreeMap(), res = 0, pre = 0;\\n    for (let i = 0; i < a.length; i++) m.set(a[i], i + 1); // {v : last index}\\n    for (const x of m.keys()) {\\n        let l = x - k, r = x + k, xLastIdx = m.get(x) || 0;\\n        let floorR = m.floorKey(r);\\n        let floorRLastIdx = floorR == null ? 0 : m.get(floorR);\\n        let lowerX = m.lowerKey(x);\\n        let lowerXLastIdx = lowerX == null ? 0 : m.get(lowerX);\\n        let lowerL = m.lowerKey(l);\\n        let lowerLLastIdx = lowerL == null ? 0 : m.get(lowerL);\\n        res = Math.max(res, pre + floorRLastIdx - lowerXLastIdx);\\n        pre = Math.max(pre, xLastIdx - lowerLLastIdx);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Ordered Map"
                ],
                "code": "```\\n////////////////////////// Template ////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nfunction TreeMap(g) {\\n    let ts = [], m = new Map(), bisect = new Bisect();\\n    initialize();\\n    return { set, get, firstKey, lastKey, keys, pollFirstEntry, pollLastEntry, ceilingKey, higherKey, lowerKey, floorKey, ceilingEntry, higherEntry, lowerEntry, floorEntry, remove, has, size, findKth, clear, show };\\n    function initialize() {\\n        if (g) {\\n            for (const [k, v] of g) {\\n                if (!m.has(k)) bisect.insort_right(ts, k);\\n                m.set(k, v);\\n            }\\n        }\\n    }\\n    function set(k, v) {\\n        if (!m.has(k)) bisect.insort_right(ts, k); // ts has no duplicates/unique key\\n        m.set(k, v); // update key with most recent value\\n    }\\n    function get(k) {\\n        return m.get(k);\\n    }\\n    function keys() {\\n        return ts;\\n    }\\n    function firstKey() {\\n        return ts[0];\\n    }\\n    function lastKey() {\\n        return ts[ts.length - 1];\\n    }\\n    function pollFirstEntry() {\\n        let k = ts[0], v = m.get(k);\\n        ts.splice(0, 1);\\n        m.delete(k);\\n        return [k, v];\\n    }\\n    function pollLastEntry() {\\n        let k = ts.pop(), v = m.get(k);\\n        m.delete(k);\\n        return [k, v];\\n    }\\n    function ceilingKey(e) { // >= lower_bound\\n        let idx = bisect.bisect_right(ts, e);\\n        let res = ts[idx - 1] == e ? e : ts[bisect.bisect_right(ts, e)];\\n        return res == undefined ? null : res;\\n    }\\n    function higherKey(e) { // > upper_bound\\n        let idx = bisect.bisect_right(ts, e);\\n        let res = ts[idx] > e ? ts[idx] : ts[bisect.bisect_right(ts, e) + 1];\\n        return res == undefined ? null : res;\\n    }\\n    function floorKey(e) { // <= \\n        let idx = bisect.bisect_left(ts, e);\\n        let res = ts[idx] == e ? e : ts[bisect.bisect_left(ts, e) - 1];\\n        return res == undefined ? null : res;\\n    }\\n    function lowerKey(e) { // <\\n        let idx = bisect.bisect_left(ts, e);\\n        let res = ts[idx] < e ? ts[idx] : ts[bisect.bisect_left(ts, e) - 1];\\n        return res == undefined ? null : res;\\n    }\\n    function data(k) {\\n        return k == null ? null : { key: k, value: m.get(k) }\\n    }\\n    function ceilingEntry(k) {\\n        return data(ceilingKey(k));\\n    }\\n    function higherEntry(k) {\\n        return data(higherKey(k));\\n    }\\n    function floorEntry(k) {\\n        return data(floorKey(k));\\n    }\\n    function lowerEntry(k) {\\n        return data(lowerKey(k));\\n    }\\n    function remove(e) {\\n        let idx = bisect.bisect_left(ts, e);\\n        if (ts[idx] == e) ts.splice(idx, 1);\\n        m.delete(e);\\n    }\\n    function has(e) {\\n        return m.has(e);\\n    }\\n    function size() {\\n        return ts.length;\\n    }\\n    function findKth(k) {\\n        let cnt = 0;\\n        for (const x of ts) {\\n            let occ = m.get(x);\\n            if (cnt + occ < k) {\\n                cnt += occ;\\n            } else {\\n                return x;\\n            }\\n        }\\n    }\\n    function clear() {\\n        ts = [];\\n        m.clear();\\n    }\\n    function show() {\\n        let res = new Map();\\n        for (const x of ts) res.set(x, m.get(x));\\n        return res;\\n    }\\n}\\n///////////////////////////////////////////////////////////////////\\n\\nconst maximizeWin = (a, k) => {\\n    let m = new TreeMap(), res = 0, pre = 0;\\n    for (let i = 0; i < a.length; i++) m.set(a[i], i + 1); // {v : last index}\\n    for (const x of m.keys()) {\\n        let l = x - k, r = x + k, xLastIdx = m.get(x) || 0;\\n        let floorR = m.floorKey(r);\\n        let floorRLastIdx = floorR == null ? 0 : m.get(floorR);\\n        let lowerX = m.lowerKey(x);\\n        let lowerXLastIdx = lowerX == null ? 0 : m.get(lowerX);\\n        let lowerL = m.lowerKey(l);\\n        let lowerLLastIdx = lowerL == null ? 0 : m.get(lowerL);\\n        res = Math.max(res, pre + floorRLastIdx - lowerXLastIdx);\\n        pre = Math.max(pre, xLastIdx - lowerLLastIdx);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3142975,
                "title": "python3-sliding-window",
                "content": "**Intuition**\\nThis is a typical application of sliding window algorithm. \\nA range sum is computed for the values bounded by the two pointers which indicates the maximum sum possible ending at a given index not exceeding the window length. An extra step is required to memorize these values so that a maximum range sum ending at the starting index plus the current range sum becomes a candidate for the answer. The final answer is the maximum of all such candidates. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        ans = ii = 0 \\n        dp = [0]\\n        for i, x in enumerate(prizePositions): \\n            while x - prizePositions[ii] > k: ii += 1\\n            ans = max(ans, dp[ii] + i - ii + 1)\\n            dp.append(max(dp[-1], i-ii+1))\\n        return ans\\n```\\n**Complexity**\\nTime `O(N)`\\nSpace `O(N)`\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        ans = ii = 0 \\n        dp = [0]\\n        for i, x in enumerate(prizePositions): \\n            while x - prizePositions[ii] > k: ii += 1\\n            ans = max(ans, dp[ii] + i - ii + 1)\\n            dp.append(max(dp[-1], i-ii+1))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142973,
                "title": "c-binary-search-100-faster-with-explanation-3-maps",
                "content": "**Please Upvote**\\n\\nDetails of all 3 maps :-\\n1. Key of m represents elements of given array, while the value is the number of prizes in [arr[i], arr[i] + k].\\n2. Map Next for a key arr[i], represents the upper_bound index of arr[i] + k.\\n3. sufMax reprsents the maximum prizes from end till now\\n\\nNow you may get it, Comment down for queries (if any)\\n```\\nclass Solution {\\n    unordered_map <int, int> m, next, sufMax;\\npublic:\\n    int maximizeWin(vector<int>& v, int k) {\\n        int n = v.size();\\n        for(int i = 0; i < n; ) {\\n            int j = upper_bound(v.begin(), v.end(), v[i] + k) - v.begin();\\n            next[v[i]] = j;\\n            m[v[i]] = j - i;\\n            i++;\\n            while(i < n && v[i] == v[i - 1]) i++;\\n        }\\n        \\n        int mx = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n            if(m.count(v[i])) {\\n                sufMax[v[i]] = max(mx, m[v[i]]);\\n                mx = sufMax[v[i]];\\n            }\\n        }\\n        sufMax[v[n - 1] + k] = 0;\\n        \\n        int ans = 0;\\n        for(auto&it: m) {\\n            int end;\\n            int ind = next[it.first];\\n            if(ind == n) end = v[n - 1] + k;\\n            else end = v[ind];\\n            ans = max(ans, m[it.first] + sufMax[end]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please Upvote**\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map <int, int> m, next, sufMax;\\npublic:\\n    int maximizeWin(vector<int>& v, int k) {\\n        int n = v.size();\\n        for(int i = 0; i < n; ) {\\n            int j = upper_bound(v.begin(), v.end(), v[i] + k) - v.begin();\\n            next[v[i]] = j;\\n            m[v[i]] = j - i;\\n            i++;\\n            while(i < n && v[i] == v[i - 1]) i++;\\n        }\\n        \\n        int mx = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n            if(m.count(v[i])) {\\n                sufMax[v[i]] = max(mx, m[v[i]]);\\n                mx = sufMax[v[i]];\\n            }\\n        }\\n        sufMax[v[n - 1] + k] = 0;\\n        \\n        int ans = 0;\\n        for(auto&it: m) {\\n            int end;\\n            int ind = next[it.first];\\n            if(ind == n) end = v[n - 1] + k;\\n            else end = v[ind];\\n            ans = max(ans, m[it.first] + sufMax[end]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142961,
                "title": "c-without-dp-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& A, int k) {\\n        int ans=0,\\n        n=A.size();\\n        int start=0;\\n        int count=0;\\n        int end=A[0]+k;\\n        int cur_val=0;\\n        vector<int>pref(n);\\n        vector<int>suff(n);\\n        for(int i=0;i<n;++i){\\n            int cur=A[i];\\n            if(cur<=end){\\n                count++;\\n            }\\n            else{\\n                while(cur>end){\\n                    start++;\\n                    end=A[start]+k;\\n                    count--;\\n                }\\n                count++;\\n            }\\n            cur_val=max(cur_val,count);\\n            pref[i]=cur_val;\\n        }\\n        start=n-1;\\n        end=A[n-1]-k;\\n        count = 0,cur_val = 0;\\n        for(int i=n-1;i>=0;--i){\\n            int cur=A[i];\\n            if(cur>=end){\\n                count++;\\n            }\\n            else{\\n                while(cur<end){\\n                    start--;\\n                    end = A[start]-k;\\n                    count--;\\n                }\\n                count++;\\n            }\\n            cur_val=max(cur_val,count);\\n            suff[i]=cur_val;\\n        }\\n        for(int i=0;i<n;++i){\\n            int sum=pref[i];\\n            if((i+1)<n)\\n            sum+=suff[i+1];\\n            ans=max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& A, int k) {\\n        int ans=0,\\n        n=A.size();\\n        int start=0;\\n        int count=0;\\n        int end=A[0]+k;\\n        int cur_val=0;\\n        vector<int>pref(n);\\n        vector<int>suff(n);\\n        for(int i=0;i<n;++i){\\n            int cur=A[i];\\n            if(cur<=end){\\n                count++;\\n            }\\n            else{\\n                while(cur>end){\\n                    start++;\\n                    end=A[start]+k;\\n                    count--;\\n                }\\n                count++;\\n            }\\n            cur_val=max(cur_val,count);\\n            pref[i]=cur_val;\\n        }\\n        start=n-1;\\n        end=A[n-1]-k;\\n        count = 0,cur_val = 0;\\n        for(int i=n-1;i>=0;--i){\\n            int cur=A[i];\\n            if(cur>=end){\\n                count++;\\n            }\\n            else{\\n                while(cur<end){\\n                    start--;\\n                    end = A[start]-k;\\n                    count--;\\n                }\\n                count++;\\n            }\\n            cur_val=max(cur_val,count);\\n            suff[i]=cur_val;\\n        }\\n        for(int i=0;i<n;++i){\\n            int sum=pref[i];\\n            if((i+1)<n)\\n            sum+=suff[i+1];\\n            ans=max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142936,
                "title": "clear-explanation-beats-100-both-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question is not easy to be understood at once :-\\n\\nfor eg :- \\n\\n[1,1,2,10]\\n2\\n\\nis Your answer 4 if so then you are right because we can take two segments as [1,3] and [8 , 10].\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nwe can get the first segment and store that in a dp to get the max count till that index , in the next traversal we again look for the max count but now with the previous segement max count stored ,\\n\\nso we look for (i - j + 1 + dp[j]);\\n\\nwhere dp[j] is the first segment and (i - j + 1) is 2nd.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        \\n        if(k >= prizePositions.back() - prizePositions[0]) {\\n            return prizePositions.size();\\n        }\\n        unordered_map<int , int> mp;\\n        vector<int> vp;\\n        int mx = 0;\\n        for(auto el : prizePositions) {\\n            mp[el]++;\\n            mx = max(mx , el);\\n        }\\n        map<int , int> vis;\\n        for(auto el : prizePositions) {\\n            if(vis[el]) continue;\\n            vis[el] = 1;\\n            vp.push_back(el);\\n        }\\n        \\n        vector<int> pre(vp.size() + 1 , 0);\\n        \\n        for(int i = 1 ; i <= vp.size() ; i++) {\\n            pre[i] = pre[i - 1] + mp[vp[i - 1]];\\n        }\\n        \\n        vector<int> dp(vp.size() + 1 , 0);\\n        \\n        int ans = 0 , mx_till = 0;\\n        \\n        for(int i = 0 ; i < vp.size() ; i++) {\\n            auto it = lower_bound(vp.begin() , vp.end() , k + vp[i]);\\n                if(it == vp.end() || *it - vp[i] != k) {\\n                    it = prev(it , 1);\\n                }\\n                int cur = pre[it - vp.begin() + 1] - pre[i];\\n                dp[it - vp.begin() + 1] = max(cur , mx_till);\\n                mx_till = max(mx_till , dp[it - vp.begin() + 1]);\\n            dp[i + 1] = max(dp[i + 1] , dp[i]);\\n            ans = max(ans , mx_till  );\\n        }\\n        \\n        \\n        for(int i = 0 ; i < vp.size() ; i++) {\\n            auto it = lower_bound(vp.begin() , vp.end() , k + vp[i]);\\n                if(it == vp.end() || *it - vp[i] != k) {\\n                    it = prev(it , 1);\\n                }\\n                int cur = pre[it - vp.begin() + 1] - pre[i];\\n                ans = max(ans , dp[i] + cur);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        \\n        if(k >= prizePositions.back() - prizePositions[0]) {\\n            return prizePositions.size();\\n        }\\n        unordered_map<int , int> mp;\\n        vector<int> vp;\\n        int mx = 0;\\n        for(auto el : prizePositions) {\\n            mp[el]++;\\n            mx = max(mx , el);\\n        }\\n        map<int , int> vis;\\n        for(auto el : prizePositions) {\\n            if(vis[el]) continue;\\n            vis[el] = 1;\\n            vp.push_back(el);\\n        }\\n        \\n        vector<int> pre(vp.size() + 1 , 0);\\n        \\n        for(int i = 1 ; i <= vp.size() ; i++) {\\n            pre[i] = pre[i - 1] + mp[vp[i - 1]];\\n        }\\n        \\n        vector<int> dp(vp.size() + 1 , 0);\\n        \\n        int ans = 0 , mx_till = 0;\\n        \\n        for(int i = 0 ; i < vp.size() ; i++) {\\n            auto it = lower_bound(vp.begin() , vp.end() , k + vp[i]);\\n                if(it == vp.end() || *it - vp[i] != k) {\\n                    it = prev(it , 1);\\n                }\\n                int cur = pre[it - vp.begin() + 1] - pre[i];\\n                dp[it - vp.begin() + 1] = max(cur , mx_till);\\n                mx_till = max(mx_till , dp[it - vp.begin() + 1]);\\n            dp[i + 1] = max(dp[i + 1] , dp[i]);\\n            ans = max(ans , mx_till  );\\n        }\\n        \\n        \\n        for(int i = 0 ; i < vp.size() ; i++) {\\n            auto it = lower_bound(vp.begin() , vp.end() , k + vp[i]);\\n                if(it == vp.end() || *it - vp[i] != k) {\\n                    it = prev(it , 1);\\n                }\\n                int cur = pre[it - vp.begin() + 1] - pre[i];\\n                ans = max(ans , dp[i] + cur);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142934,
                "title": "easy-solution-by-using-upper-and-lower-bound-only-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind upper and lower bound of each element and then find the no. between them.\\nthen try to find the max sum of two segments..\\n\\n\\nIf anydoubt Feel free to ask in comments...\\n#KeepCoding\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& vec , int k) {\\n        vector<int> vt(vec.size(),0);\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            vt[i]=upper_bound(vec.begin(),vec.end(),vec[i]+k)-lower_bound(vec.begin(),vec.end(),vec[i]);\\n        }\\n        vector<int> mx(vec.size(),0);\\n        int mn=INT_MIN;\\n        for(int i=vt.size()-1;i>=0;i--)\\n        {\\n            mn=max(mn,vt[i]);\\n            mx[i]=mn;\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<vt.size();i++)\\n        {       auto it=upper_bound(vec.begin(),vec.end(),vec[i]+k)-vec.begin();\\n            if(it<vt.size())\\n            { ans=max(ans,(vt[i]+ mx[it]));}\\n        }\\n        if(ans==INT_MIN)\\n        {\\n            return vec.size();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& vec , int k) {\\n        vector<int> vt(vec.size(),0);\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            vt[i]=upper_bound(vec.begin(),vec.end(),vec[i]+k)-lower_bound(vec.begin(),vec.end(),vec[i]);\\n        }\\n        vector<int> mx(vec.size(),0);\\n        int mn=INT_MIN;\\n        for(int i=vt.size()-1;i>=0;i--)\\n        {\\n            mn=max(mn,vt[i]);\\n            mx[i]=mn;\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<vt.size();i++)\\n        {       auto it=upper_bound(vec.begin(),vec.end(),vec[i]+k)-vec.begin();\\n            if(it<vt.size())\\n            { ans=max(ans,(vt[i]+ mx[it]));}\\n        }\\n        if(ans==INT_MIN)\\n        {\\n            return vec.size();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142907,
                "title": "go-solution",
                "content": "# Code\\n```\\nfunc maximizeWin(prizePositions []int, k int) int {\\n    dp := make([]int, len(prizePositions)+1)\\n    maxPrizes := 0\\n    start := 0\\n    for i, position := range prizePositions {\\n        for ; prizePositions[start] < position-k; start++ {\\n        }\\n        dp[i+1] = max(dp[i], i-start+1)\\n        maxPrizes = max(maxPrizes, i-start+1+dp[start])\\n    }\\n    return maxPrizes\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc maximizeWin(prizePositions []int, k int) int {\\n    dp := make([]int, len(prizePositions)+1)\\n    maxPrizes := 0\\n    start := 0\\n    for i, position := range prizePositions {\\n        for ; prizePositions[start] < position-k; start++ {\\n        }\\n        dp[i+1] = max(dp[i], i-start+1)\\n        maxPrizes = max(maxPrizes, i-start+1+dp[start])\\n    }\\n    return maxPrizes\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3142882,
                "title": "c-intuitive-solution-100-faster-binary-search-memoization",
                "content": "This is the full problem explanation & solution [Video](https://youtu.be/-5DGaggZuYw) by **codingMohan**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binary_search(vector<int> &arr, int ele, int &n){\\n        int l=0, u=n-1, m=(l+u)/2, idx=0;\\n        while(l<=u){\\n            if( ele == arr[m] ) idx = m, l=m+1;\\n            else if( ele < arr[m] ) u=m-1;\\n            else l=m+1;\\n            m=(l+u)/2;\\n        }\\n        return m;\\n    }\\n\\n    int bestAfterIndex(vector<int> &arr, int idx, int &n, int &k, int dp[]){\\n        if( idx>=n ) return dp[idx]=0;\\n        int next = bestAfterIndex(arr, idx+1, n, k, dp);\\n        int endIdx = binary_search(arr, arr[idx]+k, n);\\n        return dp[idx] = max(next, (endIdx-idx+1));\\n    }\\n\\n    int maximizeWin(vector<int>& arr, int k) {\\n        int n=arr.size(), dp[n+1], ans=0;\\n        bestAfterIndex(arr, 0, n, k, dp);\\n        for(int i=0;i<n;i++){\\n            if( i==0 || arr[i] != arr[i-1] ){\\n                int endIdx = binary_search(arr, arr[i]+k, n);\\n                int firstSegPrizes = (endIdx - i + 1), secSegPrizes = dp[endIdx+1];\\n                ans = max(ans, (firstSegPrizes + secSegPrizes));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please upvote if you like the solution \\uD83D\\uDE09**",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binary_search(vector<int> &arr, int ele, int &n){\\n        int l=0, u=n-1, m=(l+u)/2, idx=0;\\n        while(l<=u){\\n            if( ele == arr[m] ) idx = m, l=m+1;\\n            else if( ele < arr[m] ) u=m-1;\\n            else l=m+1;\\n            m=(l+u)/2;\\n        }\\n        return m;\\n    }\\n\\n    int bestAfterIndex(vector<int> &arr, int idx, int &n, int &k, int dp[]){\\n        if( idx>=n ) return dp[idx]=0;\\n        int next = bestAfterIndex(arr, idx+1, n, k, dp);\\n        int endIdx = binary_search(arr, arr[idx]+k, n);\\n        return dp[idx] = max(next, (endIdx-idx+1));\\n    }\\n\\n    int maximizeWin(vector<int>& arr, int k) {\\n        int n=arr.size(), dp[n+1], ans=0;\\n        bestAfterIndex(arr, 0, n, k, dp);\\n        for(int i=0;i<n;i++){\\n            if( i==0 || arr[i] != arr[i-1] ){\\n                int endIdx = binary_search(arr, arr[i]+k, n);\\n                int firstSegPrizes = (endIdx - i + 1), secSegPrizes = dp[endIdx+1];\\n                ans = max(ans, (firstSegPrizes + secSegPrizes));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142789,
                "title": "simple-sort-and-sweet-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& p, int k) {\\n        int n=p.size(),start=0,ans=0;\\n//making an dp vector \\n        vector<int> dp(n);\\n        for(int end=0;end<n;end++){\\n            while(p[end]-p[start]>k) start++;\\n            int curr_sum=end-start+1;\\n            if(start>0) curr_sum+=dp[start-1];\\n            ans=max(ans,curr_sum);\\n            int prev=0;\\n            if(end>0) prev=dp[end-1];\\n            dp[end]=max(prev,end-start+1);\\n        }\\n        return ans;\\n\\n    }\\n};\\n//upvote if found helpful\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& p, int k) {\\n        int n=p.size(),start=0,ans=0;\\n//making an dp vector \\n        vector<int> dp(n);\\n        for(int end=0;end<n;end++){\\n            while(p[end]-p[start]>k) start++;\\n            int curr_sum=end-start+1;\\n            if(start>0) curr_sum+=dp[start-1];\\n            ans=max(ans,curr_sum);\\n            int prev=0;\\n            if(end>0) prev=dp[end-1];\\n            dp[end]=max(prev,end-start+1);\\n        }\\n        return ans;\\n\\n    }\\n};\\n//upvote if found helpful\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142787,
                "title": "c-beats-100-dp-sliding-window-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& a, int k) \\n    {\\n        int n=a.size(),res=0,j=0;\\n        vector<int> dp(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            while(a[i]-a[j]>k)\\n            {\\n                j++;\\n            }\\n            dp[i+1]=max(dp[i],i-j+1);\\n            res=max(res,dp[j]+i-j+1);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\nIf you like the solution plz upvote",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& a, int k) \\n    {\\n        int n=a.size(),res=0,j=0;\\n        vector<int> dp(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            while(a[i]-a[j]>k)\\n            {\\n                j++;\\n            }\\n            dp[i+1]=max(dp[i],i-j+1);\\n            res=max(res,dp[j]+i-j+1);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142718,
                "title": "two-pointers-one-pass-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prize_positions, int k) {\\n        const int max_distance = k;\\n        int max_prize_collected = 0;\\n        int i = 0, j = 0;            \\n        std::vector<int> tbl_segment_counts(prize_positions.size() + 1, 0);\\n        int non_intersecting_segment_max = 0;\\n        while (j < prize_positions.size()) {\\n            const int curr = prize_positions[j];\\n            for (; j < prize_positions.size(); ++j) {\\n                if (prize_positions[j] != curr) {\\n                    break;\\n                }\\n            }\\n            for (; i < j; ++i) {\\n                const int prev = prize_positions[i];\\n                if (prev + max_distance >= curr) {\\n                    break;\\n                }\\n                non_intersecting_segment_max = std::max(\\n                    tbl_segment_counts[i + 1], non_intersecting_segment_max\\n                );\\n            }\\n            const int curr_segment_counts = j - i;\\n            tbl_segment_counts[j] = curr_segment_counts;\\n            max_prize_collected = std::max(\\n                non_intersecting_segment_max + curr_segment_counts,\\n                max_prize_collected);\\n        }   \\n        return max_prize_collected;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prize_positions, int k) {\\n        const int max_distance = k;\\n        int max_prize_collected = 0;\\n        int i = 0, j = 0;            \\n        std::vector<int> tbl_segment_counts(prize_positions.size() + 1, 0);\\n        int non_intersecting_segment_max = 0;\\n        while (j < prize_positions.size()) {\\n            const int curr = prize_positions[j];\\n            for (; j < prize_positions.size(); ++j) {\\n                if (prize_positions[j] != curr) {\\n                    break;\\n                }\\n            }\\n            for (; i < j; ++i) {\\n                const int prev = prize_positions[i];\\n                if (prev + max_distance >= curr) {\\n                    break;\\n                }\\n                non_intersecting_segment_max = std::max(\\n                    tbl_segment_counts[i + 1], non_intersecting_segment_max\\n                );\\n            }\\n            const int curr_segment_counts = j - i;\\n            tbl_segment_counts[j] = curr_segment_counts;\\n            max_prize_collected = std::max(\\n                non_intersecting_segment_max + curr_segment_counts,\\n                max_prize_collected);\\n        }   \\n        return max_prize_collected;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142709,
                "title": "python-3-heap-and-binary-search",
                "content": "```\\nclass Solution:\\n    def maximizeWin(self, p: List[int], k: int) -> int:\\n        \\n        cnt = Counter(p)\\n        acc = [0]\\n        locs = sorted(cnt)\\n        for c in locs:\\n            acc.append(acc[-1] + cnt[c])\\n        \\n        \\n        # maximum coverage strating from current position\\n        cands = []\\n        res = {}\\n        for i, loc in enumerate(locs):\\n            x = bisect.bisect(locs, loc+k)\\n            # covered prize counts\\n            res[loc] = acc[x] - acc[i]\\n            # maximum heap to store the prize counts and start position\\n            heappush(cands, (-res[loc], loc))\\n        \\n        # loop through each start position\\n        ans = 0\\n        for i, loc in enumerate(locs):\\n            # the next segment should not overlap with the current end position\\n            while cands and cands[0][1] <= loc + k:\\n                heappop(cands)\\n            \\n            # pick the next largest segment\\n            if cands:\\n                ans = max(ans, res[loc] - cands[0][0])\\n            # if there is no rest, meaning we could cover till the end\\n            else:\\n                return max(ans, acc[-1] - acc[i])\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution:\\n    def maximizeWin(self, p: List[int], k: int) -> int:\\n        \\n        cnt = Counter(p)\\n        acc = [0]\\n        locs = sorted(cnt)\\n        for c in locs:\\n            acc.append(acc[-1] + cnt[c])\\n        \\n        \\n        # maximum coverage strating from current position\\n        cands = []\\n        res = {}",
                "codeTag": "Java"
            },
            {
                "id": 3142510,
                "title": "maximize-left-max-right-max-for-every-i-precomputations-o-n",
                "content": "# Intuition\\nThe idea is that as we have to select two segments and making those segments disjoint would always be better. So lets take an index i in the array and take the first segment in the left of i and the second segment in the right of i. \\n\\n# Approach\\nMaximizing the (**left segment** + **right segments**) value over all indexes will give us the answer.\\nWe can precompute the prefix and suffix array which stores the maximum prizes we can take from the left and right of some index.\\n\\n# Complexity\\n- Time complexity: O(n)\\nO(n) for precomputation + O(n) for calculating final answer\\n\\n# Code\\n```\\n#define ll int\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& v, int k) {\\n        ll n = v.size();\\n        if(n == 1) return 1;\\n        vector<ll> pre(n), suff(n);\\n        ll s = 0;\\n        for(ll i = 0; i < n; i++){\\n            while(v[i] - v[s] > k){\\n                s++;\\n            }\\n            ll len = i - s + 1;\\n            ll prev = (i > 0) ? pre[i-1] : 0;\\n            pre[i] = max(prev, len);\\n        }\\n        s = n-1;\\n        for(ll i = n-1; i >= 0; i--){\\n            while(v[s] - v[i] > k){\\n                s--;\\n            }\\n            ll len = s - i + 1;\\n            ll nx = (i < n-1) ? suff[i + 1] : 0;\\n            suff[i] = max(nx, len);\\n        }\\n        ll ans = 0;\\n        for(ll i = 0; i < n-1; i++){\\n            ans = max(ans, pre[i] + suff[i + 1]);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\n#define ll int\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& v, int k) {\\n        ll n = v.size();\\n        if(n == 1) return 1;\\n        vector<ll> pre(n), suff(n);\\n        ll s = 0;\\n        for(ll i = 0; i < n; i++){\\n            while(v[i] - v[s] > k){\\n                s++;\\n            }\\n            ll len = i - s + 1;\\n            ll prev = (i > 0) ? pre[i-1] : 0;\\n            pre[i] = max(prev, len);\\n        }\\n        s = n-1;\\n        for(ll i = n-1; i >= 0; i--){\\n            while(v[s] - v[i] > k){\\n                s--;\\n            }\\n            ll len = s - i + 1;\\n            ll nx = (i < n-1) ? suff[i + 1] : 0;\\n            suff[i] = max(nx, len);\\n        }\\n        ll ans = 0;\\n        for(ll i = 0; i < n-1; i++){\\n            ans = max(ans, pre[i] + suff[i + 1]);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142486,
                "title": "java-flexible-window-linkedlist-binarysearch",
                "content": "# Approach\\n1. We want to know how many groups we can build by selecting i (0.n -k) and a number for > i+k.\\n    EG: [1,2,3,4,5,6,7], k = 3; We want to know the best selection of groups by 1 and >= 5 (> 1+3)\\n    Then for 2 + bestGroup >= 6 etc\\n2. To know how many good group each number can make, we need to count the groups.\\n3. Use a linkedList<int[]> to store the int and count of elements.\\n4. While traversing, if next element - firstInList > k, we need to evict first element.\\n    At that stage, we know that ALL the elements in list are part of head\\'s partition.\\n    Evict head and put the group and size of that number in map/separate list.\\n5. Once you have this second list/map, from right to left you need to determine the largest group even encountered.\\nAs numbers are in order, this list is already sorted\\n6. As we have determined step 5, start from head and see the max you can get by adding group of i and largestGroup starting from i +k + 1.    \\n7. Return the max.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeWin(int[] prizePositions, int k) {\\n        if (k == 0) {\\n            return Math.min(prizePositions.length, 2);\\n        }\\n        List<int[]> maxGroupInterval = getMaxForEachGroupInterval(prizePositions, k);\\n        int col = maxGroupInterval.size();\\n        int[][] maxGroups = getMaxGroupsFromLeft(maxGroupInterval);\\n        int max = maxGroups[1][0];\\n        for (int i = 0; i < col - 1; i++) {\\n            max = Math.max(max, maxGroups[1][i] + getNextHighestGroup(maxGroups, maxGroups[0][i] + k + 1));\\n        }\\n        return max;\\n\\n    }\\n\\n    // binary search for the highest group starting with i+k+1.\\n    private int getNextHighestGroup(int[][] maxGroups, int from) {\\n        int col = maxGroups[0].length;\\n        if (maxGroups[0][col - 1] < from) {\\n            return 0;\\n        }\\n        int index = Arrays.binarySearch(maxGroups[0], from);\\n        if (index >= 0) {\\n            return maxGroups[2][index];\\n        } else {\\n            if (col == Math.abs(index)) {\\n                return maxGroups[2][col - 1];\\n            } else {\\n                return maxGroups[2][Math.abs(index + 1)];\\n            }\\n        }\\n    }\\n\\n    // determine the max partition from left to right. This is used for binarySearch (i+k+1);\\n    private int[][] getMaxGroupsFromLeft(List<int[]> maxGroupInterval) {\\n        int col = maxGroupInterval.size();\\n        int[][] maxGroups = new int[3][col];\\n        int index =0;\\n        for (int[] group : maxGroupInterval) {\\n            maxGroups[0][index] = group[0];\\n            maxGroups[1][index] = group[1];\\n            index++;\\n        }\\n        maxGroups[2][col - 1] = maxGroups[1][col - 1];\\n        for (int i = col - 2; i>= 0; i--) {\\n            maxGroups[2][i] = Math.max(maxGroups[2][i+1], maxGroups[1][i]);\\n        }\\n        return maxGroups;\\n    }\\n\\n    // flexible window. This window will contain the group of elements such that head + tail < k.\\n    // when tail - head > k and we need to evict head, we know that head can make list\\'s size partition.\\n    private List<int[]> getMaxForEachGroupInterval(int[] prizePositions, int k) {\\n        LinkedList<int[]> flexibleInterval = new LinkedList<>();\\n        List<int[]> maxGroupInterval = new LinkedList<>();\\n        flexibleInterval.add(new int[]{prizePositions[0] ,1});\\n        int size = 1;\\n        for (int i = 1; i < prizePositions.length; i++) {\\n            if (prizePositions[i] == flexibleInterval.peekLast()[0]) {\\n                flexibleInterval.peekLast()[1]++;\\n                size++;\\n            } else {\\n                if (prizePositions[i] - flexibleInterval.peekFirst()[0] > k) {\\n                    while (!flexibleInterval.isEmpty() && prizePositions[i] - flexibleInterval.peekFirst()[0] > k) {\\n                        int[] evicted = flexibleInterval.removeFirst();\\n                        maxGroupInterval.add(new int[]{evicted[0], size});\\n                        size -= evicted[1];\\n                    }\\n                }\\n                flexibleInterval.addLast(new int[]{prizePositions[i], 1});\\n                size++;\\n            }\\n        }\\n        while(!flexibleInterval.isEmpty()) {\\n            int[] evicted = flexibleInterval.removeFirst();\\n            maxGroupInterval.add(new int[]{evicted[0], size});\\n            size -= evicted[1];\\n        }\\n        return maxGroupInterval;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeWin(int[] prizePositions, int k) {\\n        if (k == 0) {\\n            return Math.min(prizePositions.length, 2);\\n        }\\n        List<int[]> maxGroupInterval = getMaxForEachGroupInterval(prizePositions, k);\\n        int col = maxGroupInterval.size();\\n        int[][] maxGroups = getMaxGroupsFromLeft(maxGroupInterval);\\n        int max = maxGroups[1][0];\\n        for (int i = 0; i < col - 1; i++) {\\n            max = Math.max(max, maxGroups[1][i] + getNextHighestGroup(maxGroups, maxGroups[0][i] + k + 1));\\n        }\\n        return max;\\n\\n    }\\n\\n    // binary search for the highest group starting with i+k+1.\\n    private int getNextHighestGroup(int[][] maxGroups, int from) {\\n        int col = maxGroups[0].length;\\n        if (maxGroups[0][col - 1] < from) {\\n            return 0;\\n        }\\n        int index = Arrays.binarySearch(maxGroups[0], from);\\n        if (index >= 0) {\\n            return maxGroups[2][index];\\n        } else {\\n            if (col == Math.abs(index)) {\\n                return maxGroups[2][col - 1];\\n            } else {\\n                return maxGroups[2][Math.abs(index + 1)];\\n            }\\n        }\\n    }\\n\\n    // determine the max partition from left to right. This is used for binarySearch (i+k+1);\\n    private int[][] getMaxGroupsFromLeft(List<int[]> maxGroupInterval) {\\n        int col = maxGroupInterval.size();\\n        int[][] maxGroups = new int[3][col];\\n        int index =0;\\n        for (int[] group : maxGroupInterval) {\\n            maxGroups[0][index] = group[0];\\n            maxGroups[1][index] = group[1];\\n            index++;\\n        }\\n        maxGroups[2][col - 1] = maxGroups[1][col - 1];\\n        for (int i = col - 2; i>= 0; i--) {\\n            maxGroups[2][i] = Math.max(maxGroups[2][i+1], maxGroups[1][i]);\\n        }\\n        return maxGroups;\\n    }\\n\\n    // flexible window. This window will contain the group of elements such that head + tail < k.\\n    // when tail - head > k and we need to evict head, we know that head can make list\\'s size partition.\\n    private List<int[]> getMaxForEachGroupInterval(int[] prizePositions, int k) {\\n        LinkedList<int[]> flexibleInterval = new LinkedList<>();\\n        List<int[]> maxGroupInterval = new LinkedList<>();\\n        flexibleInterval.add(new int[]{prizePositions[0] ,1});\\n        int size = 1;\\n        for (int i = 1; i < prizePositions.length; i++) {\\n            if (prizePositions[i] == flexibleInterval.peekLast()[0]) {\\n                flexibleInterval.peekLast()[1]++;\\n                size++;\\n            } else {\\n                if (prizePositions[i] - flexibleInterval.peekFirst()[0] > k) {\\n                    while (!flexibleInterval.isEmpty() && prizePositions[i] - flexibleInterval.peekFirst()[0] > k) {\\n                        int[] evicted = flexibleInterval.removeFirst();\\n                        maxGroupInterval.add(new int[]{evicted[0], size});\\n                        size -= evicted[1];\\n                    }\\n                }\\n                flexibleInterval.addLast(new int[]{prizePositions[i], 1});\\n                size++;\\n            }\\n        }\\n        while(!flexibleInterval.isEmpty()) {\\n            int[] evicted = flexibleInterval.removeFirst();\\n            maxGroupInterval.add(new int[]{evicted[0], size});\\n            size -= evicted[1];\\n        }\\n        return maxGroupInterval;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142484,
                "title": "sliding-window-100-fastest-soln",
                "content": "\\n# Code\\n```\\n\\n/* sliding window technique is a bit hard to understand. \\nIf if you`ve understood the method by seeing others solution,\\n implement on your own */\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& pos, int k) {\\n        int far= pos.back()-pos.front();\\n        int sz= pos.size(); int n= sz;\\n        if(sz==1){\\n            return 1;\\n        }\\n        if(k==0){\\n            return 2;\\n        }\\n        \\n        vector<int> ans; //ans[i]- how many elements are available in the range of k starting from pos[i]\\n\\n        int j=0;\\n        int cnt=0;\\n        vector<int> li(sz, 0); //li=>last index, \\n        //li[i] will tell us that if we start from pos[i],\\n        // what is the last index in the pos array that is in range of k\\n        \\n        for(int i=0; i<sz; ){\\n            while(j<sz and pos[j]<= pos[i]+k){\\n                cnt++; j++;\\n            }\\n\\n            int cnt0=cnt;\\n            int i0=i;\\n            li[i]= j-1; //we can take utpo the (j-1)th element as the cond gor invalidated for jth index as per the above loop\\n            \\n            while(i<sz and pos[i]==pos[i0]){ //ignore same pos\\n                li[i]= j-1;\\n                i++; ans.push_back(cnt0); cnt--;\\n            }\\n        }\\n        \\n        if(ans.size()==1){\\n            return ans[0];\\n        }\\n        \\n        ans.push_back(0);ans.push_back(0); //just to avoid overflow\\n        auto orans= ans; //orans= original ans\\n        int res=0;\\n\\n        //store what maximum ans can be achieved in the range (i, n-1)\\n        for(int i=n-2; i>=0; i--){\\n            ans[i]= max(ans[i], ans[i+1]);\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(li[i]==0) continue;\\n            //we take the first interval from i ti li\\n            //and the second interval anywhere after li\\n            res= max(res, orans[i]+ans[li[i]+1]);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\n\\n/* sliding window technique is a bit hard to understand. \\nIf if you`ve understood the method by seeing others solution,\\n implement on your own */\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& pos, int k) {\\n        int far= pos.back()-pos.front();\\n        int sz= pos.size(); int n= sz;\\n        if(sz==1){\\n            return 1;\\n        }\\n        if(k==0){\\n            return 2;\\n        }\\n        \\n        vector<int> ans; //ans[i]- how many elements are available in the range of k starting from pos[i]\\n\\n        int j=0;\\n        int cnt=0;\\n        vector<int> li(sz, 0); //li=>last index, \\n        //li[i] will tell us that if we start from pos[i],\\n        // what is the last index in the pos array that is in range of k\\n        \\n        for(int i=0; i<sz; ){\\n            while(j<sz and pos[j]<= pos[i]+k){\\n                cnt++; j++;\\n            }\\n\\n            int cnt0=cnt;\\n            int i0=i;\\n            li[i]= j-1; //we can take utpo the (j-1)th element as the cond gor invalidated for jth index as per the above loop\\n            \\n            while(i<sz and pos[i]==pos[i0]){ //ignore same pos\\n                li[i]= j-1;\\n                i++; ans.push_back(cnt0); cnt--;\\n            }\\n        }\\n        \\n        if(ans.size()==1){\\n            return ans[0];\\n        }\\n        \\n        ans.push_back(0);ans.push_back(0); //just to avoid overflow\\n        auto orans= ans; //orans= original ans\\n        int res=0;\\n\\n        //store what maximum ans can be achieved in the range (i, n-1)\\n        for(int i=n-2; i>=0; i--){\\n            ans[i]= max(ans[i], ans[i+1]);\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(li[i]==0) continue;\\n            //we take the first interval from i ti li\\n            //and the second interval anywhere after li\\n            res= max(res, orans[i]+ans[li[i]+1]);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142472,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int maximizeWin(int[] prizePositions, int k) {\\n        int n=prizePositions.length;\\n        if(prizePositions[n-1]-prizePositions[0]<=k) return n;\\n        //Semantic array-> maxElement segment including ith position\\n        int[] dp=new int[n];\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j>=0;j--){\\n                if(!(prizePositions[i]-prizePositions[j]<=k)){\\n                    break;\\n                }\\n                dp[i]++;\\n            }\\n        }\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j>=0;j--){\\n                if(prizePositions[i]-prizePositions[j]>k) ans=Math.max(ans,dp[i]+dp[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeWin(int[] prizePositions, int k) {\\n        int n=prizePositions.length;\\n        if(prizePositions[n-1]-prizePositions[0]<=k) return n;\\n        //Semantic array-> maxElement segment including ith position\\n        int[] dp=new int[n];\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j>=0;j--){\\n                if(!(prizePositions[i]-prizePositions[j]<=k)){\\n                    break;\\n                }\\n                dp[i]++;\\n            }\\n        }\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j>=0;j--){\\n                if(prizePositions[i]-prizePositions[j]>k) ans=Math.max(ans,dp[i]+dp[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142464,
                "title": "solution-based-on-heuristic-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each index i, we can compute the maximum index j such that prizePositions[j]$\\\\leq$prizePositions[i]+k, in $O(n)$ time overall.\\n\\n\\nThen, we try to maximize the sum of the pairs of nonoverlapping intervals. The heuristic is that at least one of the two intervals will be one of the top N intervals, where N is some fixed sufficiently large number.\\nSo we sort the interval list and consider the length of each top N interval, plus the maximum length of any non-intersecting interval.\\n\\nDuring the contest I took N=100 to be safe, but N=50 also works.\\n\\nThe two intervals could also overlap or be adjacent, so we separately compute the maximum number of prizes in an interval of length 2k+1.\\n\\nThe final answer is the bigger of these two partial answers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe only consider the maximal intervals, i.e. we do not consider the intervals [i, j] that are contained in a wider interval with the same property.\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log n + Nn)$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        l=len(prizePositions)\\n        i=0\\n        j=0\\n        max_ct=[]\\n        while j<l:\\n            while j<l and prizePositions[j]<=prizePositions[i]+k:\\n                j+=1\\n            max_ct.append((i, j, j-i))\\n            while i<j and (j==l or prizePositions[j]>prizePositions[i]+k):\\n                i+=1\\n                \\n        lng=min(50, len(max_ct)-1)\\n        max_ct.sort(key=lambda x:-x[2])\\n        ans=0\\n        for m in range(lng):\\n            i1, j1, a1=max_ct[m]\\n            for it in max_ct:\\n                if it[1]<=i1 or it[0]>=j1:\\n                    a1+=it[2]\\n                    break\\n            if a1>ans:\\n                ans=a1\\n        \\n        i=0\\n        j=0\\n        k=(k<<1)|1\\n        while j<l:\\n            while j<l and prizePositions[j]<=prizePositions[i]+k:\\n                j+=1\\n            if j-i>ans:\\n                ans=j-i\\n            while i<j and (j==l or prizePositions[j]>prizePositions[i]+k):\\n                i+=1\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        l=len(prizePositions)\\n        i=0\\n        j=0\\n        max_ct=[]\\n        while j<l:\\n            while j<l and prizePositions[j]<=prizePositions[i]+k:\\n                j+=1\\n            max_ct.append((i, j, j-i))\\n            while i<j and (j==l or prizePositions[j]>prizePositions[i]+k):\\n                i+=1\\n                \\n        lng=min(50, len(max_ct)-1)\\n        max_ct.sort(key=lambda x:-x[2])\\n        ans=0\\n        for m in range(lng):\\n            i1, j1, a1=max_ct[m]\\n            for it in max_ct:\\n                if it[1]<=i1 or it[0]>=j1:\\n                    a1+=it[2]\\n                    break\\n            if a1>ans:\\n                ans=a1\\n        \\n        i=0\\n        j=0\\n        k=(k<<1)|1\\n        while j<l:\\n            while j<l and prizePositions[j]<=prizePositions[i]+k:\\n                j+=1\\n            if j-i>ans:\\n                ans=j-i\\n            while i<j and (j==l or prizePositions[j]>prizePositions[i]+k):\\n                i+=1\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142462,
                "title": "c-solution-using-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we can select two segments, it is best to choose two non-intersecting segments to maximize the answer. So, for each element we have to find biggest segment with that element as the last value and then find a second segment from the left of current segment.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf for an element i (0 <= i < n - 1) if the next element is also same, we can skip the current element because when we will process the next element, the current element will also get included in it.\\nNow, in the first dp, we will store the index of first element from where the segment starts such that dp[i] is the start element index and i is the last element index for the current segment.\\nWe need a second dp to store the maximum segment value till that point, i.e., dp[i] = max(dp[0], dp[1], ..... , dp[i - 1], dp[i]).\\nNow the answer simply becomes maximum of current segment length + max length before the current segment.\\n\\n# Complexity\\n- Time complexity: O(n)\\n    - O(n) for the first loop to store dp values.\\n    - O(n) for the second loop to store dp2 values and simultaneously calculate answer.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n    - O(n) to store both dp and dp2 arrays.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        vector <int> dp(n, 0);\\n        for (int i=0; i<n; ++i) {\\n            if (i < n - 1 && prizePositions[i] == prizePositions[i + 1]) continue;\\n            int fstIdx = upper_bound(prizePositions.begin(), prizePositions.end(), prizePositions[i] - k - 1) - prizePositions.begin();\\n            dp[i] = fstIdx;\\n        }\\n        int ans = 0;\\n        vector <int> mxDp(n, 0);\\n        int mx = 0;\\n        mxDp[0] = dp[0];\\n        for (int i=0; i<n; ++i) {\\n            if (i < n - 1 && prizePositions[i] == prizePositions[i + 1]) continue;\\n            if (dp[i] == 0) ans = max(ans, i + 1);\\n            else ans = max(ans, i - dp[i] + 1 + mxDp[dp[i] - 1]);\\n            mx = max(mx, i - dp[i] + 1);\\n            mxDp[i] = mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        vector <int> dp(n, 0);\\n        for (int i=0; i<n; ++i) {\\n            if (i < n - 1 && prizePositions[i] == prizePositions[i + 1]) continue;\\n            int fstIdx = upper_bound(prizePositions.begin(), prizePositions.end(), prizePositions[i] - k - 1) - prizePositions.begin();\\n            dp[i] = fstIdx;\\n        }\\n        int ans = 0;\\n        vector <int> mxDp(n, 0);\\n        int mx = 0;\\n        mxDp[0] = dp[0];\\n        for (int i=0; i<n; ++i) {\\n            if (i < n - 1 && prizePositions[i] == prizePositions[i + 1]) continue;\\n            if (dp[i] == 0) ans = max(ans, i + 1);\\n            else ans = max(ans, i - dp[i] + 1 + mxDp[dp[i] - 1]);\\n            mx = max(mx, i - dp[i] + 1);\\n            mxDp[i] = mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142403,
                "title": "beats-100-binarysearch-fully-explained-c",
                "content": "\\n# Approach\\n From every position where prizes are present find the maximum prizes that you can take using prefix sum.\\nfor eg-prizePositions = [1,1,2,2,3,3,5], k = 2\\nnow we will store freq in map and prizepostion in arr.\\narr is-[1,2,3,5]\\nNow for every arr[i] find lower bound for arr[i]-k (it is the required length of segment you want) and store for every index\\nNow do the similar thing for the other segment\\nfor other just do arr[i]+k and handle edge case index out of bound\\nsort this also\\nnow the answer is simply maximum of arr1[i]+arr2[i+1] for every i\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n=prizePositions.size();\\n        if(k==0){\\n            if(n>=2){\\n                return 2;\\n            }\\n            return n;\\n        }\\n        map<int,int> mp;\\n        for(auto x:prizePositions){\\n            mp[x]++;\\n        }\\n        vector<int> temp;\\n        for(auto x:mp){\\n            temp.push_back(x.first);\\n        }\\n        vector<int> sum;\\n        sum.push_back(0);\\n        int last=0;\\n        for(auto x:mp){\\n            sum.push_back(x.second+last);\\n            last=sum.back();\\n        }\\n        sum.push_back(0);\\n        vector<int> dp1,dp2;\\n        for(int i=0;i<temp.size();i++){\\n            auto it=lower_bound(temp.begin(),temp.end(),temp[i]-k)-temp.begin();\\n            dp1.push_back(sum[i+1]-sum[it]);\\n        }\\n        for(int i=0;i<temp.size();i++){\\n            auto it=lower_bound(temp.begin(),temp.end(),temp[i]+k)-temp.begin();\\n            if(it>=temp.size()) it--;\\n            if(temp[it]-temp[i]>k){\\n                it--;\\n            }\\n            dp2.push_back(sum[it+1]-sum[i]);\\n        }\\n        int mx=dp2[dp2.size()-1];\\n        for(int i=dp2.size()-2;i>=0;i--){\\n            mx=max(mx,dp2[i]);\\n            dp2[i]=mx;\\n        }\\n        int ans=0;\\n        for(int i=0;i<dp1.size()-1;i++){\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        ans=max(ans,dp1[dp1.size()-1]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n=prizePositions.size();\\n        if(k==0){\\n            if(n>=2){\\n                return 2;\\n            }\\n            return n;\\n        }\\n        map<int,int> mp;\\n        for(auto x:prizePositions){\\n            mp[x]++;\\n        }\\n        vector<int> temp;\\n        for(auto x:mp){\\n            temp.push_back(x.first);\\n        }\\n        vector<int> sum;\\n        sum.push_back(0);\\n        int last=0;\\n        for(auto x:mp){\\n            sum.push_back(x.second+last);\\n            last=sum.back();\\n        }\\n        sum.push_back(0);\\n        vector<int> dp1,dp2;\\n        for(int i=0;i<temp.size();i++){\\n            auto it=lower_bound(temp.begin(),temp.end(),temp[i]-k)-temp.begin();\\n            dp1.push_back(sum[i+1]-sum[it]);\\n        }\\n        for(int i=0;i<temp.size();i++){\\n            auto it=lower_bound(temp.begin(),temp.end(),temp[i]+k)-temp.begin();\\n            if(it>=temp.size()) it--;\\n            if(temp[it]-temp[i]>k){\\n                it--;\\n            }\\n            dp2.push_back(sum[it+1]-sum[i]);\\n        }\\n        int mx=dp2[dp2.size()-1];\\n        for(int i=dp2.size()-2;i>=0;i--){\\n            mx=max(mx,dp2[i]);\\n            dp2[i]=mx;\\n        }\\n        int ans=0;\\n        for(int i=0;i<dp1.size()-1;i++){\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        ans=max(ans,dp1[dp1.size()-1]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142381,
                "title": "c-binary-search-dp-2-pass-and-1-pass",
                "content": "# Code\\n```\\n// 2 Pass\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        vector<int> count(n + 1);\\n        for(int i = 0; i < n; i++) {\\n            count[i] = upper_bound(prizePositions.begin(), prizePositions.end(), prizePositions[i] + k) - prizePositions.begin() - i;\\n        }\\n        int ans = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n            ans = max(ans, count[i] + count[i + count[i]]);\\n            count[i] = max(count[i + 1], count[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\nOR\\n\\n// 1 Pass\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        vector<int> count(n + 1);\\n        int ans = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n            count[i] = upper_bound(prizePositions.begin(), prizePositions.end(), prizePositions[i] + k) - prizePositions.begin() - i;\\n            ans = max(ans, count[i] + count[i + count[i]]);\\n            count[i] = max(count[i + 1], count[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\n// 2 Pass\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        vector<int> count(n + 1);\\n        for(int i = 0; i < n; i++) {\\n            count[i] = upper_bound(prizePositions.begin(), prizePositions.end(), prizePositions[i] + k) - prizePositions.begin() - i;\\n        }\\n        int ans = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n            ans = max(ans, count[i] + count[i + count[i]]);\\n            count[i] = max(count[i + 1], count[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\nOR\\n\\n// 1 Pass\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        vector<int> count(n + 1);\\n        int ans = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n            count[i] = upper_bound(prizePositions.begin(), prizePositions.end(), prizePositions[i] + k) - prizePositions.begin() - i;\\n            ans = max(ans, count[i] + count[i + count[i]]);\\n            count[i] = max(count[i + 1], count[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142357,
                "title": "go-python-o-n-time-o-n-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc maximizeWin(prizePositions []int, k int) int {\\n    n := len(prizePositions)\\n    dp := make([]int, n+1)\\n    answer := 0\\n    j := 0\\n    for i:=0;i<n;i++{\\n        for prizePositions[i] - prizePositions[j] > k{\\n            j++\\n        }\\n        num_of_items := i - j + 1\\n        dp[i + 1] = max(dp[i], num_of_items)\\n        answer = max(answer, num_of_items + dp[j])\\n    }\\n    return answer\\n}\\n\\nfunc max(a,b int) int{\\n    if a>b{\\n        return a\\n    }\\n    return b\\n}\\n```\\n```python []\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        n = len(prizePositions)\\n        dp = [0 for _ in range(n+1)]\\n        answer = 0\\n        j = 0\\n        for i in range(n):\\n            while prizePositions[i] - prizePositions[j] > k:\\n                j += 1\\n            num_of_items = i - j + 1\\n            dp[i + 1] = max(dp[i], num_of_items)\\n            answer = max(answer, num_of_items + dp[j])\\n        return answer\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```golang []\\nfunc maximizeWin(prizePositions []int, k int) int {\\n    n := len(prizePositions)\\n    dp := make([]int, n+1)\\n    answer := 0\\n    j := 0\\n    for i:=0;i<n;i++{\\n        for prizePositions[i] - prizePositions[j] > k{\\n            j++\\n        }\\n        num_of_items := i - j + 1\\n        dp[i + 1] = max(dp[i], num_of_items)\\n        answer = max(answer, num_of_items + dp[j])\\n    }\\n    return answer\\n}\\n\\nfunc max(a,b int) int{\\n    if a>b{\\n        return a\\n    }\\n    return b\\n}\\n```\n```python []\\nclass Solution:\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        n = len(prizePositions)\\n        dp = [0 for _ in range(n+1)]\\n        answer = 0\\n        j = 0\\n        for i in range(n):\\n            while prizePositions[i] - prizePositions[j] > k:\\n                j += 1\\n            num_of_items = i - j + 1\\n            dp[i + 1] = max(dp[i], num_of_items)\\n            answer = max(answer, num_of_items + dp[j])\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142329,
                "title": "rust-sliding-window-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn maximize_win(prize_positions: Vec<i32>, k: i32) -> i32 {\\n        let mut data = Vec::<(i32, i32)>::new();\\n        for p in prize_positions {\\n            if data.is_empty() == false && data[data.len() - 1].0 == p {\\n                let m = data.len();\\n                data[m - 1].1 += 1;\\n            } else { data.push((p, 1)); }\\n        }\\n\\n        let n = data.len();\\n        let mut right = vec![0; n];\\n        let mut j = n - 1;\\n        let (mut ret, mut sum) = (0, 0);\\n        \\n        for i in (0 .. n).rev() {\\n            sum += data[i].1;\\n            while data[j].0 - k > data[i].0 {\\n                sum -= data[j].1;\\n                j -= 1;\\n            }\\n            right[i] = sum;\\n            if i + 1 < n { right[i] = right[i].max(right[i + 1]); } \\n            \\n            let mut t = sum;\\n            if j + 1 < n { t += right[j + 1]; }\\n            ret = ret.max(t);\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximize_win(prize_positions: Vec<i32>, k: i32) -> i32 {\\n        let mut data = Vec::<(i32, i32)>::new();\\n        for p in prize_positions {\\n            if data.is_empty() == false && data[data.len() - 1].0 == p {\\n                let m = data.len();\\n                data[m - 1].1 += 1;\\n            } else { data.push((p, 1)); }\\n        }\\n\\n        let n = data.len();\\n        let mut right = vec![0; n];\\n        let mut j = n - 1;\\n        let (mut ret, mut sum) = (0, 0);\\n        \\n        for i in (0 .. n).rev() {\\n            sum += data[i].1;\\n            while data[j].0 - k > data[i].0 {\\n                sum -= data[j].1;\\n                j -= 1;\\n            }\\n            right[i] = sum;\\n            if i + 1 < n { right[i] = right[i].max(right[i + 1]); } \\n            \\n            let mut t = sum;\\n            if j + 1 < n { t += right[j + 1]; }\\n            ret = ret.max(t);\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3142324,
                "title": "c-solution-recursive-solution-memoization-faster-and-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int helper(vector<int>&v,int seg,int i,int k){\\n        if(seg == 0 || i==v.size()) return 0;\\n        if(dp[i][seg] != -1) return dp[i][seg];\\n        \\n        int nextIndex = upper_bound(v.begin(),v.end(),v[i] + k) - v.begin();\\n        int prizesInBlock = nextIndex - i;\\n        \\n        //now return max(take,notTake)\\n        return dp[i][seg] = max(prizesInBlock + helper(v,seg-1,nextIndex,k),helper(v,seg,i+1,k));\\n    }\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        dp.resize(n,vector<int>(3,-1));\\n        return helper(prizePositions,2,0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int helper(vector<int>&v,int seg,int i,int k){\\n        if(seg == 0 || i==v.size()) return 0;\\n        if(dp[i][seg] != -1) return dp[i][seg];\\n        \\n        int nextIndex = upper_bound(v.begin(),v.end(),v[i] + k) - v.begin();\\n        int prizesInBlock = nextIndex - i;\\n        \\n        //now return max(take,notTake)\\n        return dp[i][seg] = max(prizesInBlock + helper(v,seg-1,nextIndex,k),helper(v,seg,i+1,k));\\n    }\\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        dp.resize(n,vector<int>(3,-1));\\n        return helper(prizePositions,2,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142316,
                "title": "without-dp-super-simple-code",
                "content": "\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& pp, int k) {\\n        set<int> s(pp.begin(),pp.end());\\n        int n=s.size(),pos[n],prizes[n],maxbehind[n],maxfront[n];\\n        int ind=0;\\n        for(auto i:s)\\n        {\\n            pos[ind]=i;\\n            prizes[ind++]=upper_bound(pp.begin(),pp.end(),i+k)-lower_bound(pp.begin(),pp.end(),i);\\n        }\\n        maxbehind[n-1]=prizes[n-1],maxfront[0]=prizes[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            maxbehind[n-i-1]=max(maxbehind[n-i],prizes[n-i-1]);\\n            maxfront[i]=max(maxfront[i-1],prizes[i]);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=0;\\n            int ind=upper_bound(pos,pos+n,pos[i]-k-1)-pos-1;\\n            if(ind>=0) left=maxfront[ind];\\n            ind=lower_bound(pos,pos+n,pos[i]+k+1)-pos;\\n            if(ind<n) right=maxbehind[ind];\\n            ans=max(ans,prizes[i]+max(left,right));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& pp, int k) {\\n        set<int> s(pp.begin(),pp.end());\\n        int n=s.size(),pos[n],prizes[n],maxbehind[n],maxfront[n];\\n        int ind=0;\\n        for(auto i:s)\\n        {\\n            pos[ind]=i;\\n            prizes[ind++]=upper_bound(pp.begin(),pp.end(),i+k)-lower_bound(pp.begin(),pp.end(),i);\\n        }\\n        maxbehind[n-1]=prizes[n-1],maxfront[0]=prizes[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            maxbehind[n-i-1]=max(maxbehind[n-i],prizes[n-i-1]);\\n            maxfront[i]=max(maxfront[i-1],prizes[i]);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=0;\\n            int ind=upper_bound(pos,pos+n,pos[i]-k-1)-pos-1;\\n            if(ind>=0) left=maxfront[ind];\\n            ind=lower_bound(pos,pos+n,pos[i]+k+1)-pos;\\n            if(ind<n) right=maxbehind[ind];\\n            ans=max(ans,prizes[i]+max(left,right));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142267,
                "title": "dp-sliding-window-o-n-leftmax-rightmax-faster-100",
                "content": "# Intuition\\n   For every index i, if we can get leftmax[i-1] and rightmax[i], we can iterate through i and get the max result.\\n\\nleftmax[i]: max on the left of index i (including i)\\nrightmax[i]: max on the right of index i (including i)\\n\\nTo get leftmax[i]: the max between leftmax[i-1], and the number in the window of size k from i to the left, i.e., i - j + 1, where j is the most left element meeting the window size k requirement for i.\\n\\nTo get rightmax[i]: the max between rightmax[i+1], and the number in the window of size k from i to the right, i.e., j - i + 1, where j is the most right element meeting the window size k requirement for i.\\n\\n# Complexity\\n- Time complexity: o(n)\\n- space complexity : o(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& v, int k) {\\n         int n = v.size();\\n         vector<int> leftmax(n,1);\\n         vector<int> rightmax(n,1);\\n         int j=0;\\n         for(int i=1;i<n;i++){\\n             while(v[i]-v[j]>k)  j++;\\n             leftmax[i] = max(leftmax[i-1],i-j+1);\\n         }\\n        j = n-1;\\n         for(int i=n-2;i>=0;i--){\\n             while(v[j]-v[i]>k)  j--;\\n             rightmax[i] = max(rightmax[i+1],j-i+1);\\n         }\\n         int ans=0;\\n         for(int i=0;i<=n;i++){\\n              ans =  max((i==0?0:leftmax[i-1])+(i==n?0:rightmax[i]) , ans);\\n         }\\n         return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& v, int k) {\\n         int n = v.size();\\n         vector<int> leftmax(n,1);\\n         vector<int> rightmax(n,1);\\n         int j=0;\\n         for(int i=1;i<n;i++){\\n             while(v[i]-v[j]>k)  j++;\\n             leftmax[i] = max(leftmax[i-1],i-j+1);\\n         }\\n        j = n-1;\\n         for(int i=n-2;i>=0;i--){\\n             while(v[j]-v[i]>k)  j--;\\n             rightmax[i] = max(rightmax[i+1],j-i+1);\\n         }\\n         int ans=0;\\n         for(int i=0;i<=n;i++){\\n              ans =  max((i==0?0:leftmax[i-1])+(i==n?0:rightmax[i]) , ans);\\n         }\\n         return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142197,
                "title": "dp-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeWin(self, arr: List[int], k: int) -> int:\\n        ma = 0\\n        n = len(arr)\\n        dp = [0]*(n+1)\\n        for i in range(n-1,-1,-1):\\n            j = bisect.bisect_right(arr,arr[i]+k)-1\\n            ma = max(ma,((j-i+1 )+ dp[j+1]))\\n            dp[i] = max(j-i+1,dp[i+1])\\n        #print(dp)\\n        return ma\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeWin(self, arr: List[int], k: int) -> int:\\n        ma = 0\\n        n = len(arr)\\n        dp = [0]*(n+1)\\n        for i in range(n-1,-1,-1):\\n            j = bisect.bisect_right(arr,arr[i]+k)-1\\n            ma = max(ma,((j-i+1 )+ dp[j+1]))\\n            dp[i] = max(j-i+1,dp[i+1])\\n        #print(dp)\\n        return ma\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142173,
                "title": "maximize-win-from-two-segments-java-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { \\n    public int maximizeWin(int[] prizePositions, int k) { \\n  int n = prizePositions.length; \\n  Arrays.sort(prizePositions); \\n  int[] after = new int[n]; \\n  int[] maxafter = new int[n]; \\n  for (int i = 0; i < n; i++) { \\n   int ind = BinarySearch.floorIndex(prizePositions, prizePositions[i] + k); \\n   after[i] = ind - i + 1; \\n  } \\n  for (int i = n - 1; i >= 0; i--) { \\n   maxafter[i] = Math.max(after[i], (i < n - 1 ? maxafter[i + 1] : 0)); \\n  } \\n  int ans = 0; \\n  for (int i = 0; i < n; i++) { \\n   int ind = BinarySearch.floorIndex(prizePositions, prizePositions[i] + k) + 1; \\n   ans = Math.max(ans, after[i] + (ind < n ? maxafter[ind] : 0)); \\n  } \\n  return ans; \\n } \\n    static class BinarySearch { \\n  static int ceilIndex(int arr[], int x) { \\n   int low = 0; \\n   int high = arr.length - 1; \\n   int ind = -1; \\n   boolean xmatched = false; \\n   while (low <= high) { \\n    int mid = (low + high) / 2; \\n    if (arr[mid] > x) { \\n     if (!xmatched) \\n      ind = mid; \\n     high = mid - 1; \\n    } else if (arr[mid] == x) { \\n     ind = mid; \\n     low = mid + 1; \\n     xmatched = true; \\n    } else { \\n     low = mid + 1; \\n    } \\n   } \\n   return ind; \\n  } \\n \\n  static int floorIndex(int[] arr, int x) { \\n   int low = 0; \\n   int high = arr.length - 1; \\n   int ind = -1; \\n   boolean xmatched = false; \\n   while (low <= high) { \\n    int mid = (low + high) / 2; \\n    if (arr[mid] < x) { \\n     if (!xmatched) \\n      ind = mid; \\n     low = mid + 1; \\n    } else if (arr[mid] == x) { \\n     ind = mid; \\n     low = mid + 1; \\n     xmatched = true; \\n    } else { \\n     high = mid - 1; \\n    } \\n   } \\n   return ind; \\n  } \\n } \\n \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution { \\n    public int maximizeWin(int[] prizePositions, int k) { \\n  int n = prizePositions.length; \\n  Arrays.sort(prizePositions); \\n  int[] after = new int[n]; \\n  int[] maxafter = new int[n]; \\n  for (int i = 0; i < n; i++) { \\n   int ind = BinarySearch.floorIndex(prizePositions, prizePositions[i] + k); \\n   after[i] = ind - i + 1; \\n  } \\n  for (int i = n - 1; i >= 0; i--) { \\n   maxafter[i] = Math.max(after[i], (i < n - 1 ? maxafter[i + 1] : 0)); \\n  } \\n  int ans = 0; \\n  for (int i = 0; i < n; i++) { \\n   int ind = BinarySearch.floorIndex(prizePositions, prizePositions[i] + k) + 1; \\n   ans = Math.max(ans, after[i] + (ind < n ? maxafter[ind] : 0)); \\n  } \\n  return ans; \\n } \\n    static class BinarySearch { \\n  static int ceilIndex(int arr[], int x) { \\n   int low = 0; \\n   int high = arr.length - 1; \\n   int ind = -1; \\n   boolean xmatched = false; \\n   while (low <= high) { \\n    int mid = (low + high) / 2; \\n    if (arr[mid] > x) { \\n     if (!xmatched) \\n      ind = mid; \\n     high = mid - 1; \\n    } else if (arr[mid] == x) { \\n     ind = mid; \\n     low = mid + 1; \\n     xmatched = true; \\n    } else { \\n     low = mid + 1; \\n    } \\n   } \\n   return ind; \\n  } \\n \\n  static int floorIndex(int[] arr, int x) { \\n   int low = 0; \\n   int high = arr.length - 1; \\n   int ind = -1; \\n   boolean xmatched = false; \\n   while (low <= high) { \\n    int mid = (low + high) / 2; \\n    if (arr[mid] < x) { \\n     if (!xmatched) \\n      ind = mid; \\n     low = mid + 1; \\n    } else if (arr[mid] == x) { \\n     ind = mid; \\n     low = mid + 1; \\n     xmatched = true; \\n    } else { \\n     high = mid - 1; \\n    } \\n   } \\n   return ind; \\n  } \\n } \\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142139,
                "title": "binary-search-explaination",
                "content": "# Intuition\\nGenerally when we have to divide in two part we fix a point and try to get optimal division for left and right part\\n\\n# Approach\\n1. Iterate for all i from 1 to n and consider prizePositions[i] as the end of the first window we select \\n2. After selecting the window find the nearest element on left smaller than prizePositions[i]-k , that element won\\'t be in range\\n3. Do a similar thing while iterating from right to left and find the first element greater than prizePositions[i]+k\\n4. Now iterate over array and for each i get the maxWindow from left and maxWindow from right\\n5. Maximise the ans\\n\\nDuring contest i implemented solve1 and solve 2 for quickness and they can be combined together to form a general function\\nBut for simplicity i keep them unchanged\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n\\nFuther ideas:\\nAs we see while iterating for i  from 1 to n as the prizePositions[i] is increasing our nearest element on left that is outof range is also sliding to the right.\\nThis behaviour tells us that we can use a sliding window technique in here\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve1(vector<int> &prizePositions , int index , int k){\\n        int l = 0 , r = index;\\n        int ans = -1 , find = prizePositions[index]-k;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(prizePositions[mid] >= find){\\n                r = mid-1;\\n            }else{\\n                ans = mid;\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n     int solve2(vector<int> &prizePositions , int index , int k){\\n        int l = index , r = prizePositions.size()-1;\\n        int ans = prizePositions.size() , find = prizePositions[index]+k;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(prizePositions[mid] <= find){\\n                l = mid+1;\\n            }else{\\n                ans = mid;\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        \\n        vector<int> left(n) , right(n);\\n        for(int i=0;i<n;i++){\\n            //find nearest element on left out of range\\n            int index = solve1(prizePositions,i, k);\\n            left[i] = i - index;\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            //find nearest element on right out of range\\n            int index = solve2(prizePositions , i , k);\\n            right[i] = index-i;\\n        }\\n        \\n        vector<int> rightMax(n);\\n        rightMax[n-1] = right[n-1];\\n        //compute the max for second window in right\\n        for(int i=n-2;i>=0;i--){\\n            rightMax[i] = max(right[i],rightMax[i+1]);\\n        }\\n        \\n        //form the ans while calculating max for left window\\n        int maxi = left[0],ans=0;\\n        for(int i=0;i<n;i++){\\n            //get max from left\\n            maxi = max(maxi , left[i]); \\n            //combine left and right\\n            ans = max(ans , maxi +((i+1<n)?rightMax[i+1]:0) );\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve1(vector<int> &prizePositions , int index , int k){\\n        int l = 0 , r = index;\\n        int ans = -1 , find = prizePositions[index]-k;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(prizePositions[mid] >= find){\\n                r = mid-1;\\n            }else{\\n                ans = mid;\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n     int solve2(vector<int> &prizePositions , int index , int k){\\n        int l = index , r = prizePositions.size()-1;\\n        int ans = prizePositions.size() , find = prizePositions[index]+k;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(prizePositions[mid] <= find){\\n                l = mid+1;\\n            }else{\\n                ans = mid;\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int maximizeWin(vector<int>& prizePositions, int k) {\\n        int n = prizePositions.size();\\n        \\n        vector<int> left(n) , right(n);\\n        for(int i=0;i<n;i++){\\n            //find nearest element on left out of range\\n            int index = solve1(prizePositions,i, k);\\n            left[i] = i - index;\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            //find nearest element on right out of range\\n            int index = solve2(prizePositions , i , k);\\n            right[i] = index-i;\\n        }\\n        \\n        vector<int> rightMax(n);\\n        rightMax[n-1] = right[n-1];\\n        //compute the max for second window in right\\n        for(int i=n-2;i>=0;i--){\\n            rightMax[i] = max(right[i],rightMax[i+1]);\\n        }\\n        \\n        //form the ans while calculating max for left window\\n        int maxi = left[0],ans=0;\\n        for(int i=0;i<n;i++){\\n            //get max from left\\n            maxi = max(maxi , left[i]); \\n            //combine left and right\\n            ans = max(ans , maxi +((i+1<n)?rightMax[i+1]:0) );\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142136,
                "title": "very-easy-dynamic-programming-solution",
                "content": "# Intuition\\nAs we don\\'t know that which segments will give us maximum value.\\n\\n# Approach\\nWe can think of selecting the 2 segments by help of dp then checking if we got the maximum length or not.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    \\n    int fun(int i,int ct,vector<int> &v,int k,vector<vector<int>>&dp){\\n        if(ct==2){\\n            return 0;\\n        }\\n        if(i>=v.size()){\\n            return 0;\\n        }\\n        if(dp[i][ct]!=-1){\\n            return dp[i][ct];\\n        }\\n        \\n        int ans=0;\\n        int notpick=fun(i+1,ct,v,k,dp);\\n        \\n           int ind=lower_bound(v.begin(),v.end(),v[i]+k+1)-v.begin();\\n           ans=max(ans,ind-i+fun(ind,ct+1,v,k,dp));\\n        \\n      return dp[i][ct]=max(notpick,ans);\\n    }\\n\\n    int maximizeWin(vector<int>& p, int k) {\\n        \\n        vector<vector<int>> dp(100001,vector<int> (2,-1));\\n        return fun(0,0,p,k,dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    \\n    int fun(int i,int ct,vector<int> &v,int k,vector<vector<int>>&dp){\\n        if(ct==2){\\n            return 0;\\n        }\\n        if(i>=v.size()){\\n            return 0;\\n        }\\n        if(dp[i][ct]!=-1){\\n            return dp[i][ct];\\n        }\\n        \\n        int ans=0;\\n        int notpick=fun(i+1,ct,v,k,dp);\\n        \\n           int ind=lower_bound(v.begin(),v.end(),v[i]+k+1)-v.begin();\\n           ans=max(ans,ind-i+fun(ind,ct+1,v,k,dp));\\n        \\n      return dp[i][ct]=max(notpick,ans);\\n    }\\n\\n    int maximizeWin(vector<int>& p, int k) {\\n        \\n        vector<vector<int>> dp(100001,vector<int> (2,-1));\\n        return fun(0,0,p,k,dp);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142111,
                "title": "simple-memoization-with-explanation-specially-designed-for-beginner-s",
                "content": "```\\nclass Solution {\\n    vector<vector<int>>dp;\\npublic:\\n    int solve(int idx,int currSegmentCount,vector<int>&arr,int &k){\\n        if(currSegmentCount==0 or idx>=arr.size())\\n            return 0;\\n        if(dp[idx][currSegmentCount]!=-1)\\n            return dp[idx][currSegmentCount];\\n        /// we have 2 options\\n        // Ignore the value;\\n        int ignore = solve(idx+1,currSegmentCount,arr,k);\\n        int farthestPos = lower_bound(arr.begin(),arr.end(),arr[idx]+k+1) - arr.begin();\\n        int consider = (farthestPos-idx) + solve(farthestPos,currSegmentCount-1,arr,k);\\n        \\n        return dp[idx][currSegmentCount]=max(ignore,consider);\\n    }\\n    \\n    int maximizeWin(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        dp.resize(n,vector<int>(3,-1));\\n        // dp[i][j] is the maximumPrice we can get using from 0 to ith index having segment j;\\n        // Here the segmentCount=2, But this question can be designed for any SegmentCount C\\n        int segmentCount = 2;\\n        return solve(0,segmentCount,arr,k);\\n   }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<vector<int>>dp;\\npublic:\\n    int solve(int idx,int currSegmentCount,vector<int>&arr,int &k){\\n        if(currSegmentCount==0 or idx>=arr.size())\\n            return 0;\\n        if(dp[idx][currSegmentCount]!=-1)\\n            return dp[idx][currSegmentCount];\\n        /// we have 2 options\\n        // Ignore the value;\\n        int ignore = solve(idx+1,currSegmentCount,arr,k);\\n        int farthestPos = lower_bound(arr.begin(),arr.end(),arr[idx]+k+1) - arr.begin();\\n        int consider = (farthestPos-idx) + solve(farthestPos,currSegmentCount-1,arr,k);\\n        \\n        return dp[idx][currSegmentCount]=max(ignore,consider);\\n    }\\n    \\n    int maximizeWin(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        dp.resize(n,vector<int>(3,-1));\\n        // dp[i][j] is the maximumPrice we can get using from 0 to ith index having segment j;\\n        // Here the segmentCount=2, But this question can be designed for any SegmentCount C\\n        int segmentCount = 2;\\n        return solve(0,segmentCount,arr,k);\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142068,
                "title": "java-o-n-sliding-window",
                "content": "```Java\\n\\n/*\\n     [1,1,2,2,......., j-th, ..................]\\n    maxKN(0, j - 1) + n(j, j + k)\\n*/\\nclass Solution {\\n    public int maximizeWin(int[] prizePositions, int k) {\\n        int res = 0;\\n        int maxKN = 0;\\n        int left1 = 0, right1 = 0;  // segment 1\\n        int left2 = 0, right2 = 0;  // segment 2;\\n        while (right2 < prizePositions.length) {\\n            while (prizePositions[right2] - prizePositions[left2] > k) {\\n                left2++;\\n            }\\n            right2++;\\n            int n2 = right2 - left2;\\n            \\n            while (prizePositions[right1] < prizePositions[left2]) {\\n                while (prizePositions[right1] - prizePositions[left1] > k) {\\n                    left1++;\\n                }\\n                right1++;\\n                int n1 = right1 - left1;        // the number of segement1\\n                maxKN = Math.max(maxKN, n1);    // the max number can be covered before segemnt2.\\n            }\\n            \\n            res = Math.max(res, maxKN + n2);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\n\\n/*\\n     [1,1,2,2,......., j-th, ..................]\\n    maxKN(0, j - 1) + n(j, j + k)\\n*/\\nclass Solution {\\n    public int maximizeWin(int[] prizePositions, int k) {\\n        int res = 0;\\n        int maxKN = 0;\\n        int left1 = 0, right1 = 0;  // segment 1\\n        int left2 = 0, right2 = 0;  // segment 2;\\n        while (right2 < prizePositions.length) {\\n            while (prizePositions[right2] - prizePositions[left2] > k) {\\n                left2++;\\n            }\\n            right2++;\\n            int n2 = right2 - left2;\\n            \\n            while (prizePositions[right1] < prizePositions[left2]) {\\n                while (prizePositions[right1] - prizePositions[left1] > k) {\\n                    left1++;\\n                }\\n                right1++;\\n                int n1 = right1 - left1;        // the number of segement1\\n                maxKN = Math.max(maxKN, n1);    // the max number can be covered before segemnt2.\\n            }\\n            \\n            res = Math.max(res, maxKN + n2);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142039,
                "title": "prefix-suffix",
                "content": "1.  calculate the count for every sliding window from left and add it with maximum value with right array\\n```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& p, int k) {\\n        int res = 0;\\n        int n = p.size();\\n        int count = 0;\\n        vector<int>suffix(n,0);\\n        int rightMax = 0;\\n        int end = n-1;\\n        \\n        //calculate the suffix\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            int x = p[i];\\n            while(end>i && (p[end] - x)>k)\\n            {\\n                count--;\\n                end--;\\n            }\\n            ++count;\\n            rightMax = max(rightMax,count);\\n            suffix[i] = rightMax;\\n        }\\n        \\n        // calculate the prefix\\n        int start = 0;\\n        count = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            int x = p[i];\\n            while(start<i && (x-p[start]) > k)\\n            {\\n                count--;\\n                start++;\\n            }\\n            ++count;\\n            \\n            if(i==n-1) res = max(res,count);\\n            else res =  max(res,count+suffix[i+1]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& p, int k) {\\n        int res = 0;\\n        int n = p.size();\\n        int count = 0;\\n        vector<int>suffix(n,0);\\n        int rightMax = 0;\\n        int end = n-1;\\n        \\n        //calculate the suffix\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            int x = p[i];\\n            while(end>i && (p[end] - x)>k)\\n            {\\n                count--;\\n                end--;\\n            }\\n            ++count;\\n            rightMax = max(rightMax,count);\\n            suffix[i] = rightMax;\\n        }\\n        \\n        // calculate the prefix\\n        int start = 0;\\n        count = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            int x = p[i];\\n            while(start<i && (x-p[start]) > k)\\n            {\\n                count--;\\n                start++;\\n            }\\n            ++count;\\n            \\n            if(i==n-1) res = max(res,count);\\n            else res =  max(res,count+suffix[i+1]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141936,
                "title": "c-using-map-and-upper-bound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& t, int k) {\\n        \\nunordered_map<ll,int> mp;\\n        for(auto a:t){\\n       mp[a]+=1;\\n        }\\n        vector<ll> v;\\n        for(auto a:mp){\\n            v.push_back(a.first);\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        int size= v.size();\\n        vector<ll> left(size,0);\\n        \\n        for(int i=0; i<size; i++){\\n            if(i==0){\\n                left[i]=mp[v[i]];\\n            }else{\\n                left[i]=mp[v[i]]+left[i-1];\\n            }\\n        }\\n                \\n                vector<ll> tt(size);\\n \\n        ll previous=0;\\n        for(int i=0; i<size; i++){\\n             ll temp = v[i];\\n            ll end= v[i]+k;       \\n            auto it = upper_bound(v.begin(),v.end(),end)-v.begin();\\n            if(it==v.size()){\\n                tt[i]=left[size-1]-previous;\\n            }else{\\n                tt[i]=left[it-1]-previous;   \\n            }\\n            previous=left[i];\\n        }\\n        \\n  \\n        vector<ll> right(size);\\n        for(int i=size-1; i>=0; i--){\\n            if(i==(size-1)){\\n                right[i]=tt[i];\\n            }else{\\n                right[i]=max(right[i+1],tt[i]);\\n            }\\n        }\\n  \\n        ll ANS =0;\\n        \\n        for(int i=0; i<size; i++){\\n            ll END = v[i]+k;\\n    auto it = upper_bound(v.begin(),v.end(),END)-v.begin();\\n            if(it==v.size()){\\n                ANS=max(ANS,tt[i]);\\n            }else{\\n                ANS=max(ANS,tt[i]+right[it]);\\n            }\\n        }\\n   \\n        return ANS;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& t, int k) {\\n        \\nunordered_map<ll,int> mp;\\n        for(auto a:t){\\n       mp[a]+=1;\\n        }\\n        vector<ll> v;\\n        for(auto a:mp){\\n            v.push_back(a.first);\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        int size= v.size();\\n        vector<ll> left(size,0);\\n        \\n        for(int i=0; i<size; i++){\\n            if(i==0){\\n                left[i]=mp[v[i]];\\n            }else{\\n                left[i]=mp[v[i]]+left[i-1];\\n            }\\n        }\\n                \\n                vector<ll> tt(size);\\n \\n        ll previous=0;\\n        for(int i=0; i<size; i++){\\n             ll temp = v[i];\\n            ll end= v[i]+k;       \\n            auto it = upper_bound(v.begin(),v.end(),end)-v.begin();\\n            if(it==v.size()){\\n                tt[i]=left[size-1]-previous;\\n            }else{\\n                tt[i]=left[it-1]-previous;   \\n            }\\n            previous=left[i];\\n        }\\n        \\n  \\n        vector<ll> right(size);\\n        for(int i=size-1; i>=0; i--){\\n            if(i==(size-1)){\\n                right[i]=tt[i];\\n            }else{\\n                right[i]=max(right[i+1],tt[i]);\\n            }\\n        }\\n  \\n        ll ANS =0;\\n        \\n        for(int i=0; i<size; i++){\\n            ll END = v[i]+k;\\n    auto it = upper_bound(v.begin(),v.end(),END)-v.begin();\\n            if(it==v.size()){\\n                ANS=max(ANS,tt[i]);\\n            }else{\\n                ANS=max(ANS,tt[i]+right[it]);\\n            }\\n        }\\n   \\n        return ANS;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141665,
                "title": "c-solution-with-upper-bound-suffix-maximum-array",
                "content": "# Time Complexity: $$O(nlog(n))$$\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int maximizeWin(vector<int>& a, int k) \\n    {\\n        int n = a.size();\\n        vector<pair<int, int>> b(n), s(n);\\n        for (int i = 0; i < n; ++i)\\n        {\\n            int target = a[i] + k;\\n            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);\\n            b[i] = {i, idx};\\n        }\\n        \\n        int mx = 0;\\n        pair<int, int> curr;\\n        for (int i = n - 1; i >= 0; --i)\\n        {\\n            if (b[i].second - b[i].first + 1 > mx)\\n            {\\n                mx = b[i].second - b[i].first + 1;\\n                curr = {b[i].first, b[i].second}; \\n            }\\n            \\n            s[i] = curr;\\n        }\\n        \\n        int res = 1;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            int j = b[i].second;\\n            \\n            res = max(res, b[i].second - b[i].first + 1 + s[j].second - s[j].first + 1 - (s[j].first == b[i].second));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maximizeWin(vector<int>& a, int k) \\n    {\\n        int n = a.size();\\n        vector<pair<int, int>> b(n), s(n);\\n        for (int i = 0; i < n; ++i)\\n        {\\n            int target = a[i] + k;\\n            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);\\n            b[i] = {i, idx};\\n        }\\n        \\n        int mx = 0;\\n        pair<int, int> curr;\\n        for (int i = n - 1; i >= 0; --i)\\n        {\\n            if (b[i].second - b[i].first + 1 > mx)\\n            {\\n                mx = b[i].second - b[i].first + 1;\\n                curr = {b[i].first, b[i].second}; \\n            }\\n            \\n            s[i] = curr;\\n        }\\n        \\n        int res = 1;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            int j = b[i].second;\\n            \\n            res = max(res, b[i].second - b[i].first + 1 + s[j].second - s[j].first + 1 - (s[j].first == b[i].second));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141655,
                "title": "c-sliding-window-dp-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fun(int k,vector<int> &a){\\n        int c=0;\\n        int j=0;\\n        int n=a.size();\\n        vector<int> ans(n);\\n        int mx=0;\\n        for(int i=0;i<n;i++){\\n            c++;\\n            while(abs(a[i]-a[j])>k){\\n                c--;\\n                j++;\\n            }\\n            // ans[i]=c;\\n            ans[i]=max(c,mx);\\n            mx=max(mx,c);\\n        }\\n       \\n        return ans;\\n    }\\n    int maximizeWin(vector<int>& p, int k) {\\n        \\n        auto v = fun(k,p);\\n        int n=p.size();\\n        reverse(p.begin(),p.end());\\n        auto r=fun(k,p);\\n        reverse(r.begin(),r.end());\\nint ans=max({v[n-1],r[0],r[n-1],v[0]});\\n        for(int i=0;i<n-1;i++){\\n            ans=max(ans,v[i]+r[i+1]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fun(int k,vector<int> &a){\\n        int c=0;\\n        int j=0;\\n        int n=a.size();\\n        vector<int> ans(n);\\n        int mx=0;\\n        for(int i=0;i<n;i++){\\n            c++;\\n            while(abs(a[i]-a[j])>k){\\n                c--;\\n                j++;\\n            }\\n            // ans[i]=c;\\n            ans[i]=max(c,mx);\\n            mx=max(mx,c);\\n        }\\n       \\n        return ans;\\n    }\\n    int maximizeWin(vector<int>& p, int k) {\\n        \\n        auto v = fun(k,p);\\n        int n=p.size();\\n        reverse(p.begin(),p.end());\\n        auto r=fun(k,p);\\n        reverse(r.begin(),r.end());\\nint ans=max({v[n-1],r[0],r[n-1],v[0]});\\n        for(int i=0;i<n-1;i++){\\n            ans=max(ans,v[i]+r[i+1]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141604,
                "title": "c-sliding-window",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int MaximizeWin(int[] prizePositions, int k) \\n    {\\n        int n = prizePositions.Length;\\n        int[] rightSize = new int[n];\\n        int[] leftSize = new int[n];\\n\\n        int left = 0;\\n        int right = 0;\\n        for (; right < n; right++)\\n        {\\n            while (left < right && prizePositions[right] - prizePositions[left] > k)\\n            {\\n                left++;\\n            }\\n            leftSize[right] = right - left + 1;\\n        }\\n\\n        right = n-1;\\n        for (left = n-1;left >= 0; left--)\\n        {\\n            while (left < right && prizePositions[right] - prizePositions[left] > k)\\n            {\\n                right--;\\n            }\\n            rightSize[left] = right - left + 1;\\n        }\\n\\n        int result = 0;\\n        int leftMax = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            result = Math.Max(result, leftMax + rightSize[i]);\\n            leftMax = Math.Max(leftMax, leftSize[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MaximizeWin(int[] prizePositions, int k) \\n    {\\n        int n = prizePositions.Length;\\n        int[] rightSize = new int[n];\\n        int[] leftSize = new int[n];\\n\\n        int left = 0;\\n        int right = 0;\\n        for (; right < n; right++)\\n        {\\n            while (left < right && prizePositions[right] - prizePositions[left] > k)\\n            {\\n                left++;\\n            }\\n            leftSize[right] = right - left + 1;\\n        }\\n\\n        right = n-1;\\n        for (left = n-1;left >= 0; left--)\\n        {\\n            while (left < right && prizePositions[right] - prizePositions[left] > k)\\n            {\\n                right--;\\n            }\\n            rightSize[left] = right - left + 1;\\n        }\\n\\n        int result = 0;\\n        int leftMax = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            result = Math.Max(result, leftMax + rightSize[i]);\\n            leftMax = Math.Max(leftMax, leftSize[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141572,
                "title": "c",
                "content": "```\\nint binarySearch(int* nums, int n, int val){\\n    int l = 0 ;\\n    int r = n-1 ;\\n    if(nums[0] > val)\\n        return 0 ;\\n    while(l < r){\\n        int mid = r - (r - l)/2 ;\\n        if(nums[mid] > val)\\n            r = mid - 1; \\n        else\\n            l = mid ;\\n    }\\n    return l + 1 ;\\n}\\nint maximizeWin(int* prizePositions, int prizePositionsSize, int k){\\n    int n = prizePositionsSize ;\\n    int** dp = malloc(n * sizeof(int*)) ;\\n    for(int i = 0; i < n; i++){\\n        dp[i] = malloc(2 * sizeof(int)) ;\\n        dp[i][0] = -1 ;\\n    }\\n    for(int i = 0; i < n; i++){\\n        int left = prizePositions[i] ;\\n        int right = prizePositions[i] + k ;\\n        int items = binarySearch(&prizePositions[i], n-i, right) ;\\n        dp[i][0] = items ;\\n        dp[i][1] = i+items ;\\n    }\\n    int* suffixMax = malloc(n * sizeof(int)) ;\\n    suffixMax[n-1] = dp[n-1][0] ;\\n    for(int i = n-2; i >=0; i--){\\n        suffixMax[i] = fmax(suffixMax[i+1], dp[i][0]) ;\\n    }\\n    int ans = 0; \\n    for(int i = 0; i < n; i++){\\n        int sum = dp[i][0] ;\\n        int next = dp[i][1] ;\\n        if(next < n)\\n            sum += suffixMax[next] ;\\n        ans = fmax(ans, sum) ;\\n        if(next == n)\\n            break ;\\n    }\\n    for(int i = 0; i < n; i++){\\n        free(dp[i]) ;\\n    }\\n    free(dp) ;\\n    free(suffixMax) ;\\n    return ans ;\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\nint binarySearch(int* nums, int n, int val){\\n    int l = 0 ;\\n    int r = n-1 ;\\n    if(nums[0] > val)\\n        return 0 ;\\n    while(l < r){\\n        int mid = r - (r - l)/2 ;\\n        if(nums[mid] > val)\\n            r = mid - 1; \\n        else\\n            l = mid ;\\n    }\\n    return l + 1 ;\\n}\\nint maximizeWin(int* prizePositions, int prizePositionsSize, int k){\\n    int n = prizePositionsSize ;\\n    int** dp = malloc(n * sizeof(int*)) ;\\n    for(int i = 0; i < n; i++){\\n        dp[i] = malloc(2 * sizeof(int)) ;\\n        dp[i][0] = -1 ;\\n    }\\n    for(int i = 0; i < n; i++){\\n        int left = prizePositions[i] ;\\n        int right = prizePositions[i] + k ;\\n        int items = binarySearch(&prizePositions[i], n-i, right) ;\\n        dp[i][0] = items ;\\n        dp[i][1] = i+items ;\\n    }\\n    int* suffixMax = malloc(n * sizeof(int)) ;\\n    suffixMax[n-1] = dp[n-1][0] ;\\n    for(int i = n-2; i >=0; i--){\\n        suffixMax[i] = fmax(suffixMax[i+1], dp[i][0]) ;\\n    }\\n    int ans = 0; \\n    for(int i = 0; i < n; i++){\\n        int sum = dp[i][0] ;\\n        int next = dp[i][1] ;\\n        if(next < n)\\n            sum += suffixMax[next] ;\\n        ans = fmax(ans, sum) ;\\n        if(next == n)\\n            break ;\\n    }\\n    for(int i = 0; i < n; i++){\\n        free(dp[i]) ;\\n    }\\n    free(dp) ;\\n    free(suffixMax) ;\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3141508,
                "title": "by-binary-search",
                "content": "## Binary search \\nclass Solution:\\n\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        n = len(prizePositions)\\n\\n        pre = [0]*(n+1)\\n        for i in range(n):\\n            cur = i + 1 - bisect.bisect_left(prizePositions, prizePositions[i]-k)\\n            pre[i+1] = pre[i] if pre[i] > cur else cur\\n\\n        post = [0] * (n + 1)\\n        for i in range(n-1, -1, -1):\\n            cur = bisect.bisect_right(prizePositions, prizePositions[i] + k) - i\\n            post[i] = post[i+1] if post[i+1] > cur else cur\\n        ans = max(pre[i]+post[i] for i in range(n))\\n        \\n        for i in range(n):\\n            cur = i + 1 - bisect.bisect_left(prizePositions, prizePositions[i]-2*k)\\n            ans = ans if ans > cur else cur\\n        return ans",
                "solutionTags": [],
                "code": "## Binary search \\nclass Solution:\\n\\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\\n        n = len(prizePositions)\\n\\n        pre = [0]*(n+1)\\n        for i in range(n):\\n            cur = i + 1 - bisect.bisect_left(prizePositions, prizePositions[i]-k)\\n            pre[i+1] = pre[i] if pre[i] > cur else cur\\n\\n        post = [0] * (n + 1)\\n        for i in range(n-1, -1, -1):\\n            cur = bisect.bisect_right(prizePositions, prizePositions[i] + k) - i\\n            post[i] = post[i+1] if post[i+1] > cur else cur\\n        ans = max(pre[i]+post[i] for i in range(n))\\n        \\n        for i in range(n):\\n            cur = i + 1 - bisect.bisect_left(prizePositions, prizePositions[i]-2*k)\\n            ans = ans if ans > cur else cur\\n        return ans",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1787673,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1787472,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1790327,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1885174,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1787660,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1789054,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 2059032,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1863333,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1790921,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1788884,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1787673,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1787472,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1790327,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1885174,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1787660,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1789054,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 2059032,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1863333,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1790921,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            },
            {
                "id": 1788884,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "how ppl understanding this one in first read\\uD83D\\uDE44"
                    },
                    {
                        "username": "mchim",
                        "content": "Usually, explanation given in examples are easier to read than problem description."
                    },
                    {
                        "username": "tr1ten",
                        "content": "oof"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Am I the one getting **Memory Limit Exceeded**?"
                    },
                    {
                        "username": "YokaiCode",
                        "content": "The way this is written is really confusing. \\n\"sorted in non-decreasing order\" ... so ascending?\\nJust one example.\\n"
                    },
                    {
                        "username": "the-spartan",
                        "content": "[1, 1, 2]  is non-descending, but isn\\'t ascending. "
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "can anybody check which for which test case my code is giving incorrect output.\n61/65 test cases are getting passed.\n `\nclass Solution {\npublic:\n    \n    vector<int> helper1(vector<int>& arr, int k){\n        int n= arr.size();\n        int curr=0;\n        int ans=0;\n        int i, j=0;\n        int st=0, ed=0;\n        for( i=0; i<n; i++){\n            for( ; j<n && arr[j]-arr[i]<=k; j++){\n                curr++;\n            }\n            if(curr> ans){\n                ans= curr;\n                st=i;\n                ed=j;\n            }\n            ans= max(ans, curr);\n            curr--;\n        }\n        return {ans, st, ed};\n    }\n    \n    int maximizeWin(vector<int>& prize, int k) {\n        int n= prize.size();\n        vector<int> p1= helper1(prize, k);\n        vector<int> arr;\n        for(int i=0; i<n; i++){\n            if(i<p1[1] || i>=p1[2]){\n                arr.push_back(prize[i]);\n            }\n        }\n        vector<int> p2= helper1(arr, k);\n        \n        return p1[0]+p2[0];\n    }\n};\n`"
                    },
                    {
                        "username": "Rutunjay_Karbhal",
                        "content": "[@grantas0612](/grantas0612) thank you so much."
                    },
                    {
                        "username": "grantas0612",
                        "content": "I had the same amount of tests passing. I assume that you're trying to find a best win for a single segment, and then another best win from the prizes excluding the best segment. But it is not guaranteed that the best single segment is included in the two best combined segments. For example, with `prizePositions = [2, 6, 7, 9, 11, 14]` and `k = 5`, the best single segment is `[6, 7, 9, 11]`, while the best two combined segments are `[2, 6, 7]` and `[9, 11, 14]`"
                    },
                    {
                        "username": "kushan2302",
                        "content": "If you found out whats wrong in it please let me know.\\n"
                    },
                    {
                        "username": "sshrey06",
                        "content": "In the first example, can someone explain to me that how is length of segment [1,3] is 2?? 1.......2.........3, i guess it is 3."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "3 - 1 = 2"
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "If you think of segment as on the x-axis and if your initial point is 1, then to get a segment with length of 2 you will have 1+2 = 3. So [1,3] segment has length of 2 in this case."
                    },
                    {
                        "username": "the-spartan",
                        "content": "No where is it specified whether the endpoints have to be within given positions or not. I think it is a necessary info that should be given.\\n\\nFor instance, in the first eg, segments [1, 3] and [5, 7] could also have been chosen."
                    },
                    {
                        "username": "jagtapshreyash408",
                        "content": "passes the 53 /72est case can any one tell whats the prblm is there in the code\\n\\n\\nclass Solution {\\npublic:\\n    int maximizeWin(vector<int>& nums, int k) {\\n      int n=nums.size();\\n      int max1=-1,max2=-1;\\n      int i=0,j=0;\\n      while(j<n)\\n      {\\n       if(nums[j]-nums[i]<=k)\\n       {\\n         j++;\\n       }\\n       else\\n       {\\n        if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         i=j;\\n       }\\n      }\\n      if(j-i>=max1)\\n        {\\n          int temp=max1;\\n          max1=j-i;\\n          max2=max1;\\n        }\\n        else if(j-i>max2)\\n        {\\n          max2=j-i;\\n        }\\n         \\n      cout<<max1<<\" \"<<max2<<\" \"<<n<<\"\\\\n\";\\n      if(max2!=-1)\\n      {\\n        return min(max1+max2,n);\\n      }\\n      return min(max1,n);\\n    }\\n};"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "I am getting TLE ..\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\n\nfrquency \n1 -> 2\n2-> 2\n3-> 2\n5->1\n\nnew array \narr[i] = 0 2 2 2 0 1\ni         ->  0 1 2 3 4 5\n\n\nSo after obtaning this arrray i am applying sliding window .\n\n1st time sliding winow..then i will make the elements 0 ;\nthen 2nd time sliding window ..\n\nthe sum of both the answers will be the answer \nbut gettting TLE \n\nCODE :-https://leetcode.com/problems/maximize-win-from-two-segments/submissions/892816031/\n\nclass Solution {\npublic:\n\n\nint maxSum(vector<int> &arr, int k)\n{\n    int n = arr.size();   \n    // Compute sum of first window of size k\n    int res = 0;\n    for (int i=0; i<k; i++)\n       res += arr[i];\n \n    // Compute sums of remaining windows by\n    // removing first element of previous\n    // window and adding last element of\n    // current window.\n    int curr_sum = res;\n    int idx = -1;\n\n    for (int i=k; i<n; i++)\n    {\n       curr_sum += arr[i] - arr[i-k];\n\n       if(curr_sum > res) {\n           res = curr_sum;\n           idx = i;\n       }\n    }\n\n    if(idx==-1) return k;\n    return idx;\n}\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        int n = prizePositions.size();\n\n        unordered_map<int,int> m;\n\n        int maxNum = 0;\n        for(int i=0;i<n;i++) {\n            maxNum = max(maxNum,prizePositions[i]);\n            m[prizePositions[i]]++;\n        }\n\n        vector<int> v;\n\n        for(int i=0;i<=maxNum;i++) {\n            if(m.count(i)==1) v.push_back(m[i]);\n            else v.push_back(0);\n        }\n\n        k = k+1;\n\n        n = v.size();\n\n        long long int ans = 0;\n        int idx =  maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n          //  cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n            v[i]=0;\n        }\n\n        idx = maxSum(v,k);\n        \n        for(int i=idx;i>=idx-k+1 && i>=0;i--) {\n           // cout<<i<<\" \"<<v[i]<<endl;\n            ans += v[i];\n        }\n\n        return ans;\n    }\n};\n\n\n\n"
                    },
                    {
                        "username": "rahilraikwar494",
                        "content": "[@lycannrocc](/lycannrocc) Thank you ...you are right .."
                    },
                    {
                        "username": "lycannrocc",
                        "content": "Your loop is going till maxNum which can be 1e9."
                    },
                    {
                        "username": "tr1ten",
                        "content": "[1,1,1,2,2,2], k = 3\\noutput: 6\\nhow?, is it even possible to select segment of exact 3 length?"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "[@Finesse](/Finesse) This should be top comment."
                    },
                    {
                        "username": "mrvlsaf",
                        "content": "You can select [0,3], [1,4]. Both will give you output 6."
                    },
                    {
                        "username": "Finesse",
                        "content": "The position on the X axis is defined by the array values. You have 3 prizes at \\u201C1\\u201D and 3 at \\u201C2\\u201D. Positions 1 and 2 are both within the range of 3 (`2-1<=3`), so you can take all the 6 prizes."
                    }
                ]
            }
        ]
    }
]