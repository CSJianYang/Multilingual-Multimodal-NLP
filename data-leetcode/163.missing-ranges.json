[
    {
        "title": "Missing Ranges",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1788218,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1932089,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1929843,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1893062,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 2039675,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 2037904,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1986957,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1929880,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1759808,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1729557,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1788218,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1932089,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1929843,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1893062,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 2039675,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 2037904,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1986957,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1929880,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1759808,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            },
            {
                "id": 1729557,
                "content": [
                    {
                        "username": "v_suresh",
                        "content": "Unfortunately, One of the most frustrating experiences was with this question! \\n"
                    },
                    {
                        "username": "nikonok",
                        "content": "Because of corner cases looks like not \"easy\" =("
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Do not naively loop from lower to upper. O(n) can be achieved by looping over nums instead."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases make this obnoxious."
                    },
                    {
                        "username": "BubbleTree",
                        "content": "so many edge cases lol"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "Why are there so many dislikes, is it because there are few edge cases or? I think the problem statement and constraints are clearly defined."
                    },
                    {
                        "username": "lpaben62",
                        "content": "Pay attention to the constraints, especially on the fact that \"lower <= nums[i] <= upper\". As opposed to number of dislikes may suggest, this problem is actually a good practices for you to pay attention to some of the nuances!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This used to ask for a return of []string."
                    },
                    {
                        "username": "saurabh_biswas",
                        "content": " `\\n\\n    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\\n        Set<Integer> set = new HashSet<>();\\n        List<String> results = new ArrayList<>();\\n        for(int num: nums) set.add(num);\\n        for(int i=lower; i <=upper; i++){\\n            if(!set.contains(i)){\\n                StringBuilder sb = new StringBuilder();\\n                int start = i;\\n                int j=0;\\n                while(!set.contains(i+j) && i+j <= upper) j++;\\n                int end = i+j-1;\\n                i = end;\\n                if(start == end) sb.append(start);\\n                else sb.append(start).append(\"->\").append(end);\\n                results.add(sb.toString());\\n            }\\n        }\\n        return results;\\n    }\\n\\n`\\nHi need some feedback on my above solution. This is the most intuitive solution I could come up on my first attempt. The default test cases passes but it times out using [1000000000] ,lower=0, upper=1000000000. I believe the time complexity of the above code is O(n) with constant space of the Set being used. Wondering what is that I\\'m doing wrong. Thanks in advance."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Too many edge cases! Frustrating for each test case...!"
                    }
                ]
            }
        ]
    }
]