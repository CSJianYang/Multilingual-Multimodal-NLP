[
    {
        "title": "Can Convert String in K Moves",
        "question_content": "Given two strings&nbsp;s&nbsp;and&nbsp;t, your goal is to convert&nbsp;s&nbsp;into&nbsp;t&nbsp;in&nbsp;k&nbsp;moves or less.\nDuring the&nbsp;ith&nbsp;(1 <= i <= k)&nbsp;move you can:\n\n\tChoose any index&nbsp;j&nbsp;(1-indexed) from&nbsp;s, such that&nbsp;1 <= j <= s.length&nbsp;and j&nbsp;has not been chosen in any previous move,&nbsp;and shift the character at that index&nbsp;i&nbsp;times.\n\tDo nothing.\n\nShifting a character means replacing it by the next letter in the alphabet&nbsp;(wrapping around so that&nbsp;'z'&nbsp;becomes&nbsp;'a'). Shifting a character by&nbsp;i&nbsp;means applying the shift operations&nbsp;i&nbsp;times.\nRemember that any index&nbsp;j&nbsp;can be picked at most once.\nReturn&nbsp;true&nbsp;if it's possible to convert&nbsp;s&nbsp;into&nbsp;t&nbsp;in no more than&nbsp;k&nbsp;moves, otherwise return&nbsp;false.\n&nbsp;\nExample 1:\n\nInput: s = \"input\", t = \"ouput\", k = 9\nOutput: true\nExplanation: In the 6th move, we shift 'i' 6 times to get 'o'. And in the 7th move we shift 'n' to get 'u'.\n\nExample 2:\n\nInput: s = \"abc\", t = \"bcd\", k = 10\nOutput: false\nExplanation: We need to shift each character in s one time to convert it into t. We can shift 'a' to 'b' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\n\nExample 3:\n\nInput: s = \"aab\", t = \"bbb\", k = 27\nOutput: true\nExplanation: In the 1st move, we shift the first 'a' 1 time to get 'b'. In the 27th move, we shift the second 'a' 27 times to get 'b'.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length, t.length <= 10^5\n\t0 <= k <= 10^9\n\ts, t contain&nbsp;only lowercase English letters.",
        "solutions": [
            {
                "id": 779903,
                "title": "java-python-3-o-n-count-the-shift-displacement-w-brief-explanation-and-analysis",
                "content": "**Q & A:**\\nQ1: Where in the problem do you derive to get the following step `3`?\\nA1: From the following description:\\n\" ...\\nDuring the ith (1 <= i <= k) move you can:\\n\\n1. Choose any index j (1-indexed) from s, such that 1 <= j <= s.length and j has not been chosen in any previous move, and shift the character at that index i times.\\n2. Do nothing.\\n\\n...\"\\n\\n**End of Q & A**\\n\\n----\\n\\n# Brief Explanation:\\n\\n\\n1. Check if the 2 strings `s` and `t` have same length, if not, return `false`; \\n2. Loop through the input strings and count the shift displacement, in case negative, plus 26 to make it positive;\\n3. If same displacement appears multiple times, the 1st time use the displacement itself, the 2nd time add `26 `to it, the 3rd time add `26 * (3 - 1) = 52 `, the 4th time add `26 * (4 - 1) = 78`, etc.; if after adding the result is greater than `k`, return `false`;\\n4. If never encounter `false` in the above 3, return `true`.\\n\\n```java\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            int diff = (t.charAt(i) - s.charAt(i) + 26) % 26;\\n            if (diff > 0 && diff + count[diff] * 26 > k) {\\n                return false;\\n            }\\n            ++count[diff];\\n        }\\n        return true;\\n    }\\n```\\n```python\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        cnt = [0] * 26\\n        for cs, ct in zip(s, t):\\n            diff = (ord(ct) - ord(cs)) % 26\\n            if diff > 0 and cnt[diff] * 26 + diff > k:\\n                return False\\n            cnt[diff] += 1\\n        return True\\n```\\n**Analysis:**\\n\\nTime: O(n), space: O(1), where n = s.length().",
                "solutionTags": [],
                "code": "```java\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            int diff = (t.charAt(i) - s.charAt(i) + 26) % 26;\\n            if (diff > 0 && diff + count[diff] * 26 > k) {\\n                return false;\\n            }\\n            ++count[diff];\\n        }\\n        return true;\\n    }\\n```\n```python\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        cnt = [0] * 26\\n        for cs, ct in zip(s, t):\\n            diff = (ord(ct) - ord(cs)) % 26\\n            if diff > 0 and cnt[diff] * 26 + diff > k:\\n                return False\\n            cnt[diff] += 1\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 779908,
                "title": "c-o-n-track-multiplier",
                "content": "#### Intuition\\nYou can only shift a letter once, and you cannot change more than once letter by the same number of shifts (`i`). In other words, if you shift one letter by `1`, no other letters can be shifted by `1`. If you need to shift by `1` again, you need to use \"wrapping\" and shift by `27` (which is `1 + 26`).\\n\\nTherefore, if our strings are `\"aaa\"` and `\"bbb\"`, we need to shift the first letter by `1`, the second by `27` (`1 + 26`), and the third - by `53` (`1 + 2 * 26`). So, you  can accomplish the task if `k` is equal or greater than `53`.\\n\\n#### Algorithm\\nGo through the strings and determine `shift` for each letter. If letter in `t` is smaller, we need to \"wrap\" it by adding 26 (e.g. changing `b` into `a` needs 25 shifts).\\n\\nAfter we use a certain number of shifts, we need to add 26, 52, and so on if we need to use it again. So we track the multiplier for each number of shifts in `mul`. If, at any time, the needed number of shifts exceeds `k`, we return `false`.\\n\\n```cpp\\nbool canConvertString(string s, string t, int k) {\\n    if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool canConvertString(string s, string t, int k) {\\n    if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779932,
                "title": "o-n-c-simple-solution-with-explanation",
                "content": "Basic idea is to convert str1 to str2 using less or equal to k iterations where in ith iteration you can choose **atmost** one character to shift **exactly** i places.\\n\\nIntuition :\\n1. if string size is not equal, return false;\\n2. use a hashmap to check how many times the diff is same and keep using the iteration with the formula (26 *(num of occurreces of same diff) + diff;\\n\\nFor eg. \"abc\" -> \"bcd\", diff for a -> b is 1 and we can check hashmap for occurences of diff as following:\\n\\n\\n```hashMap = {....... {1 = 0}....}```\\nWe can use iteration 1 in this case and we update the hashmap to the following to denote that 1 iteration has already been used.\\n```hashMap = {....... {1 = 1}....}```\\n\\nNow to shift b -> c also we need 1 Iteration,which is already being used.\\n```hashMap = {....... {1 = 1}....}```\\n\\nSince 1 iteration is already being used, we can use 26 + 1, and update hash map :\\n```hashMap = {....... {1 = 2}....}```\\nand we also keep track of the maximum iteration found so far.\\n...\\n...\\nand so on.\\n\\nFinally if max iteration <= k return true.\\n\\nNote: Please upvote if you find this useful, this motivates me to write more descriptive solutions\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int m = s.length(), n = t.length(), count = 0;\\n        if (m != n) return false;\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < m; i++) {\\n            if (t[i] == s[i]) continue;\\n            int diff = t[i] - s[i] < 0 ? 26 + t[i] - s[i] : t[i] - s[i];\\n            if (mp.find(diff) == mp.end()) {\\n                count = max(count, diff);\\n            } else {\\n                count = max(count, (mp[diff] * 26) + diff);\\n            }\\n            mp[diff]++;\\n            if (count > k) return false;\\n        }\\n        return count <= k;\\n    }\\n    \\n}; \\n```\\n\\nMore Concise solution\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int m = s.length(), n = t.length(), count = 0;\\n        if (m != n) return false;\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < m; i++) {\\n            if (t[i] == s[i]) continue;\\n            int diff = t[i] - s[i] < 0 ? 26 + t[i] - s[i] : t[i] - s[i];\\n            count = max(count, (mp[diff] * 26) + diff);\\n            mp[diff]++;\\n            if (count > k) return false;\\n        }\\n        return count <= k;\\n    }\\n    \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```hashMap = {....... {1 = 0}....}```\n```hashMap = {....... {1 = 1}....}```\n```hashMap = {....... {1 = 1}....}```\n```hashMap = {....... {1 = 2}....}```\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int m = s.length(), n = t.length(), count = 0;\\n        if (m != n) return false;\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < m; i++) {\\n            if (t[i] == s[i]) continue;\\n            int diff = t[i] - s[i] < 0 ? 26 + t[i] - s[i] : t[i] - s[i];\\n            if (mp.find(diff) == mp.end()) {\\n                count = max(count, diff);\\n            } else {\\n                count = max(count, (mp[diff] * 26) + diff);\\n            }\\n            mp[diff]++;\\n            if (count > k) return false;\\n        }\\n        return count <= k;\\n    }\\n    \\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 779938,
                "title": "python-o-n-explained",
                "content": "The logic is as follows:\\nFirst we need to calculate the difference of the conversion. for example conversion from a to be will have difference of 1.\\nThen we hold a hash map ```diff``` to see how many times we want to convert each difference.\\nFor example to go from \"aa\" to \"bb\" we want to go ```difference 1``` for 2 times.\\nThis is possible only if we will have k of 27 or above, because to go from ```a``` to ```b``` we need 1, and each loop starts at 26 (alphabet count).\\n\\nQuick way to check that is: ``` ((diff[d] - 1) * 26) + d > k ```\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        # We calculate the differences\\n        diff = defaultdict(int)\\n        for sc, tc in zip(s, t):\\n            d = (ord(tc) - ord(sc)) % 26\\n            if d == 0: continue\\n            if d > k: return False\\n            diff[d] += 1\\n            if ((diff[d] - 1) * 26) + d > k:\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```diff```\n```difference 1```\n```a```\n```b```\n``` ((diff[d] - 1) * 26) + d > k ```\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        # We calculate the differences\\n        diff = defaultdict(int)\\n        for sc, tc in zip(s, t):\\n            d = (ord(tc) - ord(sc)) % 26\\n            if d == 0: continue\\n            if d > k: return False\\n            diff[d] += 1\\n            if ((diff[d] - 1) * 26) + d > k:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780012,
                "title": "can-anyone-explain",
                "content": "I didnt understand the second test case\\n\\n```\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n```\\n\\nWhy is the answer false? Shouldnt this be possible in three moves?",
                "solutionTags": [],
                "code": "```\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 782335,
                "title": "python-simple-array-lookup-o-n-time-o-1-space",
                "content": "**Idea:**\\n\\nTest Cases:\\n* Check if length of strings are equal \\n\\nLogic\\n* Check the distance between between the s[i] and t[i] using the ord()\\n* Record the distance in an array which tracks used shifts\\n* Check the array to see if shift has been used\\n* If shift has been used take the number of times it has been used and multiply by 26\\n* If shift > k return False \\n\\n**Tricks**\\n* Use mod 26 when taking the ord() difference between the chars\\n* Example: s[i] = \\'b\\' and t[i] = \\'a\\' which requires 25 shifts\\n* ord(s[i]) - ord(t[i]) = -1\\n* (-1) % 26 = 25 \\n*  Makes logic simpler \\n\\n**Code:**\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n        # Check uneven lengths \\n        if len(s) != len(t):\\n            return False \\n        \\n\\t\\t# Track used shifts\\n        shifts = [0 for x in range(1,27)]\\n      \\n        for i in range(len(s)):\\n            \\n\\t\\t\\t# No shift required\\n            if t[i] == s[i]:\\n                continue\\n\\t\\t\\t\\n\\t\\t\\t# Number of shifts calculation\\n            diff = (ord(t[i]) - ord(s[i])) % 26\\n\\t\\t\\t\\n\\t\\t\\t# Check if number of shift is permitted \\n            if ((shifts[diff]) *26 + diff) > k:\\n                return False\\n            shifts[diff] += 1\\n\\n        return True\\n```\\n\\nLike if this helped!\\nCheers,\\nArgent",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n        # Check uneven lengths \\n        if len(s) != len(t):\\n            return False \\n        \\n\\t\\t# Track used shifts\\n        shifts = [0 for x in range(1,27)]\\n      \\n        for i in range(len(s)):\\n            \\n\\t\\t\\t# No shift required\\n            if t[i] == s[i]:\\n                continue\\n\\t\\t\\t\\n\\t\\t\\t# Number of shifts calculation\\n            diff = (ord(t[i]) - ord(s[i])) % 26\\n\\t\\t\\t\\n\\t\\t\\t# Check if number of shift is permitted \\n            if ((shifts[diff]) *26 + diff) > k:\\n                return False\\n            shifts[diff] += 1\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780269,
                "title": "java-simple-hashmap",
                "content": "```\\n    public boolean canConvertString(String s, String t, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int m = s.length(), n = t.length(), prev = 0;\\n        if (m != n) return false;\\n        for (int i = 0; i < m; i++) {\\n            int dist = getDist(s.charAt(i), t.charAt(i)), prevCnt = map.getOrDefault(dist, 0);\\n            if (dist > 0) map.put(dist, prevCnt + 1);\\n            if (prevCnt * 26 + dist > k) return false;  // find next available move\\n        }\\n        return true;\\n    }\\n    \\n    private int getDist(char a, char b) {\\n        int dist = b - a;\\n        return (dist + 26) % 26;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canConvertString(String s, String t, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int m = s.length(), n = t.length(), prev = 0;\\n        if (m != n) return false;\\n        for (int i = 0; i < m; i++) {\\n            int dist = getDist(s.charAt(i), t.charAt(i)), prevCnt = map.getOrDefault(dist, 0);\\n            if (dist > 0) map.put(dist, prevCnt + 1);\\n            if (prevCnt * 26 + dist > k) return false;  // find next available move\\n        }\\n        return true;\\n    }\\n    \\n    private int getDist(char a, char b) {\\n        int dist = b - a;\\n        return (dist + 26) % 26;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779955,
                "title": "simple-c-solution-with-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if(s.size() != t.size()) return false;\\n        \\n        int n = s.size();\\n        vector<int> v(n,0);\\n        map<int,int> mp;\\n        \\n        for(int i = 0;i < n;i++){\\n            int x = t[i] - s[i];\\n            if(x < 0) x = 26 + x;   // s[i] > t[i] then we have to roll back\\n            if(x != 0)\\n                v[i] = mp[x]*26 + x;    //if same x comes then we can roll for another 26 times if we have moves\\n            else v[i] = x;\\n            if(v[i] > k) return false;  // if moves are more then limit then return false\\n            mp[x]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if(s.size() != t.size()) return false;\\n        \\n        int n = s.size();\\n        vector<int> v(n,0);\\n        map<int,int> mp;\\n        \\n        for(int i = 0;i < n;i++){\\n            int x = t[i] - s[i];\\n            if(x < 0) x = 26 + x;   // s[i] > t[i] then we have to roll back\\n            if(x != 0)\\n                v[i] = mp[x]*26 + x;    //if same x comes then we can roll for another 26 times if we have moves\\n            else v[i] = x;\\n            if(v[i] > k) return false;  // if moves are more then limit then return false\\n            mp[x]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779906,
                "title": "transform-to-math-question",
                "content": "imagine the first round we can do x steps, x is min(26, k)\\nfor each different char, we can change it to the destination char in the first round, after that, we have to always wait for another 26 times\\n\\nfor example, \"ab\" -> \"cd\"\\n\\n\\'a\\' to \\'c\\' needs 2 steps;\\n\\'b\\' to \\'d\\' needs 2 steps;\\n\\nbut we can only do ONE replacing with 2 steps to make \\'a\\' to \\'c\\'\\nto make \\'b\\' to \\'d\\' happen, we will need to wait for next round, which is 2+26 = 28. \\n\\nso simply check how many cases(C) exist for a N steps operation.\\nif N + (c-1)*26 > K then we can\\'t make it happen. \\n\\n```\\nbool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size())\\n            return false;\\n        if(s == t)\\n            return true;\\n        vector<int> times(26);\\n        int n = s.size();\\n        for(int i = 0; i < n; ++i) {\\n            int ti = (t[i] - s[i] + 26) % 26;\\n            ++times[ti];\\n        }\\n        \\n        for(int i = 1; i < 26; ++i) {\\n            if(i + (times[i] - 1) * 26 > k)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size())\\n            return false;\\n        if(s == t)\\n            return true;\\n        vector<int> times(26);\\n        int n = s.size();\\n        for(int i = 0; i < n; ++i) {\\n            int ti = (t[i] - s[i] + 26) % 26;\\n            ++times[ti];\\n        }\\n        \\n        for(int i = 1; i < 26; ++i) {\\n            if(i + (times[i] - 1) * 26 > k)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1189629,
                "title": "simple-c-solution-8-lines",
                "content": "Here we simply calculate the shift required for each character of ```s``` and and store it in an array of size 26. Then check if those many shift are possible or not within the given value of ```k```.\\n* ```ar[i] = x``` implies that there are x characters in ```string s``` that need a shift of i to match the charcters in ```string t```.\\n* Now it is given in the question that each shift can be used only once. \\n* So if two charcters need a shift of 1, only one of them will be allowed.\\n* The next charcter will get a shift of 1 + 26 which makes the efective shift to be 1. \\nEg: lets say ```s = \"aa\"``` and ```t = \"cc\"```\\nThen ```ar[2] = 2```\\nSo two characters need a net shift of 2. So the possible shifts are 2, 28, 54, .....\\nSince we need only two, so 2 and 28 are enough. Therefore our value of k should be atleast 28 .If not then return false immediately.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int ar[26] = {0};       \\n        for(int i = 0;i < s.length();i++){\\n            int shift = (t[i] - s[i] + 26) % 26;            \\n            ar[shift]++;\\n        }\\n        for(int i = 1;i <= 25;i++)\\n            if(i + (ar[i] - 1)*26 > k)\\n                return false;\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```s```\n```k```\n```ar[i] = x```\n```string s```\n```string t```\n```s = \"aa\"```\n```t = \"cc\"```\n```ar[2] = 2```\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int ar[26] = {0};       \\n        for(int i = 0;i < s.length();i++){\\n            int shift = (t[i] - s[i] + 26) % 26;            \\n            ar[shift]++;\\n        }\\n        for(int i = 1;i <= 25;i++)\\n            if(i + (ar[i] - 1)*26 > k)\\n                return false;\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881255,
                "title": "python-3-3-lines-counter-w-example-t-m-93-19",
                "content": "Here\\'s the plan:\\n* We construct a `Counter` to keep track of the shifts.\\n\\n* We check whether `k` is sufficient to accomodate the shifts for each position of like difference. For example, if `c[2] = 3` (that is, three positions each have a difference of 2)  the third char is shifted `2+26+26 = 54`, so it must be that `k >= 54`.\\n* If so, we return `True`; if not `False`.\\n\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n        if len(s) != len(t): return False               # Example: s = \"aacdd\" , t = \"bbcdf\" , k = 30\\n\\n        c = Counter([(ord(t[i]) - ord(s[i])) % 26       # Counter([1,  1,  0,  0,  2]) = {1: 2, 0: 2, 2: 1} \\n                            for i in range(len(s))])    #          |   |   |   |   |\\n                                                        #         a:b a:b c:c d:d d:f \\n\\n        return all((c[i]-1)*26 + i <= k                 #  all( (1-1)*26 + 1 <= 30, (1-1)*26 + 1 <= 30, (2-1)*26 + 1 <= 30)\\n                            for i in c if i)            #  all(True,True,True)\\n                                                        #  return True \\n```\\n[https://leetcode.com/submissions/detail/855147141/](http://)\\n\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n        if len(s) != len(t): return False               # Example: s = \"aacdd\" , t = \"bbcdf\" , k = 30\\n\\n        c = Counter([(ord(t[i]) - ord(s[i])) % 26       # Counter([1,  1,  0,  0,  2]) = {1: 2, 0: 2, 2: 1} \\n                            for i in range(len(s))])    #          |   |   |   |   |\\n                                                        #         a:b a:b c:c d:d d:f \\n\\n        return all((c[i]-1)*26 + i <= k                 #  all( (1-1)*26 + 1 <= 30, (1-1)*26 + 1 <= 30, (2-1)*26 + 1 <= 30)\\n                            for i in c if i)            #  all(True,True,True)\\n                                                        #  return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657022,
                "title": "detailed-explanation-well-coded-92-faster",
                "content": "## IDEA :\\n* First we need to calculate the difference of the conversion. for example conversion from `a to b` will have difference of 1.\\n* Then we hold a dictiomary (hash map) diff to see how many times we want to convert each difference.\\n\\n* For example to go from `\"aa\" to \"bb\"` we want to go difference 1 for 2 times.\\n* This is possible only if we will have k of 27 or above, because to go from a to b we need 1, and each loop starts at 26 (alphabet count).\\n\\n****\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n\\t\\t\\tif len(s)!=len(t):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tdic = defaultdict(int)\\n\\t\\t\\tfor a,b in zip(s,t):\\n\\t\\t\\t\\tif a!=b:\\n\\t\\t\\t\\t\\tif ord(b)>ord(a):\\n\\t\\t\\t\\t\\t\\tdiff = ord(b)-ord(a)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdiff = (26-ord(a)+ord(b))\\n\\n\\t\\t\\t\\t\\tn = dic[diff]*26 + diff\\n\\t\\t\\t\\t\\tif n>k:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tdic[diff]+=1\\n\\n\\t\\t\\treturn True\\n\\n### Explanation :\\n\\n**Dict Storing Difference as key and value as frequency of that shift require to convert all char with same difference to respective char in \\'t\\'.**\\nExample \\n\\'\\'\\'\\n\\n\\ts=abc t=bcd , we require 1 shift three times.So key=1 val=3.\\n\\n\\n**Now for a particular key, we require maximum `26*(val)+diff` number if we want to convert all char with same difference(key) to valid char in \\'t\\'.**\\nExample :\\n\\'\\'\\'\\n\\n\\ts = abc t =bcd we require number 1,27,53 to convert s to t.\\n\\n\\n\\t\\t\\t\\n**Thanks and Upvote if you got any help or like the Idea !!** \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA :\\n* First we need to calculate the difference of the conversion. for example conversion from `a to b` will have difference of 1.\\n* Then we hold a dictiomary (hash map) diff to see how many times we want to convert each difference.\\n\\n* For example to go from `\"aa\" to \"bb\"` we want to go difference 1 for 2 times.\\n* This is possible only if we will have k of 27 or above, because to go from a to b we need 1, and each loop starts at 26 (alphabet count).\\n\\n****\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n\\t\\t\\tif len(s)!=len(t):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tdic = defaultdict(int)\\n\\t\\t\\tfor a,b in zip(s,t):\\n\\t\\t\\t\\tif a!=b:\\n\\t\\t\\t\\t\\tif ord(b)>ord(a):\\n\\t\\t\\t\\t\\t\\tdiff = ord(b)-ord(a)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdiff = (26-ord(a)+ord(b))\\n\\n\\t\\t\\t\\t\\tn = dic[diff]*26 + diff\\n\\t\\t\\t\\t\\tif n>k:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tdic[diff]+=1\\n\\n\\t\\t\\treturn True\\n\\n### Explanation :\\n\\n**Dict Storing Difference as key and value as frequency of that shift require to convert all char with same difference to respective char in \\'t\\'.**\\nExample \\n\\'\\'\\'\\n\\n\\ts=abc t=bcd , we require 1 shift three times.So key=1 val=3.\\n\\n\\n**Now for a particular key, we require maximum `26*(val)+diff` number if we want to convert all char with same difference(key) to valid char in \\'t\\'.**\\nExample :\\n\\'\\'\\'\\n\\n\\ts = abc t =bcd we require number 1,27,53 to convert s to t.\\n\\n\\n\\t\\t\\t\\n**Thanks and Upvote if you got any help or like the Idea !!** \\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1268156,
                "title": "easy-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        map<int,int>mp;\\n        int n=s.length(),m=t.length();\\n        if(n!=m)\\n            return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            int diff=int(t[i])-int(s[i]);\\n            if(diff<0)\\n                diff=26-abs(diff);\\n            if(diff>0)\\n                mp[diff]+=1;\\n        }\\n        bool ans=true;\\n        for(auto i:mp)\\n        {\\n            if(k<26*(i.second-1)+i.first)\\n                ans=false;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        map<int,int>mp;\\n        int n=s.length(),m=t.length();\\n        if(n!=m)\\n            return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            int diff=int(t[i])-int(s[i]);\\n            if(diff<0)\\n                diff=26-abs(diff);\\n            if(diff>0)\\n                mp[diff]+=1;\\n        }\\n        bool ans=true;\\n        for(auto i:mp)\\n        {\\n            if(k<26*(i.second-1)+i.first)\\n                ans=false;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779987,
                "title": "java-hashmap-o-n",
                "content": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length())\\n            return false;\\n        Map<Integer,Integer> seen=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            int d=(t.charAt(i)-\\'a\\')-(s.charAt(i)-\\'a\\');\\n            if(d==0)\\n                continue;\\n            if(d<0)\\n                d+=26;\\n            if(d>k)\\n                return false;\\n            if(seen.containsKey(d)){\\n                int lastShift=seen.get(d);\\n                if(26+lastShift<=k)\\n                    seen.put(d,lastShift+26);\\n                else\\n                    return false;\\n            } else\\n                seen.put(d,d);\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length())\\n            return false;\\n        Map<Integer,Integer> seen=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            int d=(t.charAt(i)-\\'a\\')-(s.charAt(i)-\\'a\\');\\n            if(d==0)\\n                continue;\\n            if(d<0)\\n                d+=26;\\n            if(d>k)\\n                return false;\\n            if(seen.containsKey(d)){\\n                int lastShift=seen.get(d);\\n                if(26+lastShift<=k)\\n                    seen.put(d,lastShift+26);\\n                else\\n                    return false;\\n            } else\\n                seen.put(d,d);\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779911,
                "title": "simple-c-o-n-solution-no-hashmap-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        // Array to store the next usable difference \\n        long long int diffArr[27] = { 0 };\\n\\n        char sChar, tChar;\\n        int diff;\\n        for (int i=0; i<s.length(); i++) {\\n            sChar = s[i];\\n            tChar = t[i];\\n            if (sChar == tChar) {\\n                continue;\\n            }\\n            \\n            diff = (tChar - sChar);\\n            diff += ((diff < 0) ? 26 : 0); // If we go from \\'z\\' to \\'a\\', diff is negative, so we add 26 to make it positive (circular)\\n\\n            if (diff + diffArr[diff] > k) {\\n                return false;\\n            }\\n            \\n            // Increase the diff value by 26 if we happen to find it again with some other character\\n            diffArr[diff] += 26;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        // Array to store the next usable difference \\n        long long int diffArr[27] = { 0 };\\n\\n        char sChar, tChar;\\n        int diff;\\n        for (int i=0; i<s.length(); i++) {\\n            sChar = s[i];\\n            tChar = t[i];\\n            if (sChar == tChar) {\\n                continue;\\n            }\\n            \\n            diff = (tChar - sChar);\\n            diff += ((diff < 0) ? 26 : 0); // If we go from \\'z\\' to \\'a\\', diff is negative, so we add 26 to make it positive (circular)\\n\\n            if (diff + diffArr[diff] > k) {\\n                return false;\\n            }\\n            \\n            // Increase the diff value by 26 if we happen to find it again with some other character\\n            diffArr[diff] += 26;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286937,
                "title": "java-string-greedy-10ms-beats-90-t-c-o-n-s-c-o-n",
                "content": "\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        int len1 = s.length(), len2 = t.length();\\n        if(len1 != len2)\\n            return false;\\n        \\n        int[] next = new int[26];\\n        \\n        for(int i=0;i<26;i++)\\n            next[i] = i;\\n        \\n        for(int i = 0 ; i < len1 ; i++){\\n            \\n            int diff = t.charAt(i) - s.charAt(i);\\n            if(diff == 0)\\n                continue;\\n            \\n            if(diff < 0)\\n                diff += 26;\\n            \\n            int move = next[diff];\\n            next[diff] += 26;\\n            \\n            if(move > k)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        int len1 = s.length(), len2 = t.length();\\n        if(len1 != len2)\\n            return false;\\n        \\n        int[] next = new int[26];\\n        \\n        for(int i=0;i<26;i++)\\n            next[i] = i;\\n        \\n        for(int i = 0 ; i < len1 ; i++){\\n            \\n            int diff = t.charAt(i) - s.charAt(i);\\n            if(diff == 0)\\n                continue;\\n            \\n            if(diff < 0)\\n                diff += 26;\\n            \\n            int move = next[diff];\\n            next[diff] += 26;\\n            \\n            if(move > k)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 981234,
                "title": "python-3-beats-91-with-explanation",
                "content": "For example, we want to transform \"ad\" to \"be\".\\nApparently, we can shift \"a\" by 1 move, to \"b\", however, in order to shift \"d\" to \"e\", we can no longer shift \"d\" by 1 move since we have already done it before, so we have to find the next smallest number which residue is 1, which is 27. So once we shift \"a\" by 1 move, we can wait for 25 following steps with 0 move, then, we shift d by 27 moves to get \"e\"\\nTherefore it is pretty clear that we just need to sort the characters pairs in s and t, by the residue of ord different after mod 26.\\nSo the dictionary for our example is d={1:2}, which means the char pairs have 2 residue of 1. Then the smallest K should be 1+(2-1)* 26.\\n\\nDo not forget to pick the alphabitically largest character if multiple characters have same values.\\n\\n```\\ndef canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s)!=len(t):\\n            return False\\n        d=collections.defaultdict(int)\\n        for x,y in zip(s,t):\\n            d[(ord(y)-ord(x))%26]+=1\\n        ans=sorted(d.items(), key=lambda x: [-x[1],-x[0]])[0]        \\n        return True if ans[0]==0 else ans[0]+26*(ans[1]-1)<=k\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\ndef canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s)!=len(t):\\n            return False\\n        d=collections.defaultdict(int)\\n        for x,y in zip(s,t):\\n            d[(ord(y)-ord(x))%26]+=1\\n        ans=sorted(d.items(), key=lambda x: [-x[1],-x[0]])[0]        \\n        return True if ans[0]==0 else ans[0]+26*(ans[1]-1)<=k\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 895168,
                "title": "python-sol-explained-in-great-detail",
                "content": "\\tclass Solution(object):\\n\\t\\tdef canConvertString(self, s, t, k):\\n\\t\\t\\tif s==t:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif len(s)!=len(t):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tshift_require_dict = collections.defaultdict(int) \\n\\t\\t\\t\\'\\'\\'Dict Storing Difference/shift as key and value as frequency \\n\\t\\t\\tof that shift require to convert all char with same shift/difference \\n\\t\\t\\tto respective char in \\'t\\'. Example s=abc t=bcd , we require 1 shift three times.So key=1 val=3\\'\\'\\'\\n\\t\\t\\tfor i,j in zip(s,t):\\n\\t\\t\\t\\tif i!=j:\\n\\t\\t\\t\\t\\tif j<i:\\n\\t\\t\\t\\t\\t\\ta = (122-ord(i)) + (ord(j)-96) # if char[s] > char[t], then we may go till z and again come char[t]\\n\\t\\t\\t\\t\\t\\tshift_require_dict[a] +=1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ta = ord(j)-ord(i)\\n\\t\\t\\t\\t\\t\\tshift_require_dict[a] += 1\\n\\n\\t\\'\\'\\'Now for a particular key, we require maximum\\n\\t26*(val-1)+key number if we want to convert all \\n\\tchar with same shift(key) to valid char in \\'t\\'.\\n\\tExample s = abc t =bcd we require number 1,27,53 to convert s to t.\\'\\'\\'\\n\\n\\t# So MAX_Val required will be max_freq with largest shift\\n\\t\\t\\tmax_f = shift_require_dict[max(shift_require_dict,key=shift_require_dict.get)]\\n\\t\\t\\tmax_diff =0\\n\\t\\t\\tfor key,val in shift_require_dict.items():\\n\\t\\t\\t\\tif val ==max_f:\\n\\t\\t\\t\\t\\tmax_diff = max(max_diff,key)\\n\\n\\t\\t\\tif (26*(max_f-1) + max_diff) <=k:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\t\\tdef canConvertString(self, s, t, k):\\n\\t\\t\\tif s==t:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif len(s)!=len(t):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tshift_require_dict = collections.defaultdict(int) \\n\\t\\t\\t\\'\\'\\'Dict Storing Difference/shift as key and value as frequency \\n\\t\\t\\tof that shift require to convert all char with same shift/difference \\n\\t\\t\\tto respective char in \\'t\\'. Example s=abc t=bcd , we require 1 shift three times.So key=1 val=3\\'\\'\\'\\n\\t\\t\\tfor i,j in zip(s,t):\\n\\t\\t\\t\\tif i!=j:\\n\\t\\t\\t\\t\\tif j<i:\\n\\t\\t\\t\\t\\t\\ta = (122-ord(i)) + (ord(j)-96) # if char[s] > char[t], then we may go till z and again come char[t]\\n\\t\\t\\t\\t\\t\\tshift_require_dict[a] +=1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ta = ord(j)-ord(i)\\n\\t\\t\\t\\t\\t\\tshift_require_dict[a] += 1\\n\\n\\t\\'\\'\\'Now for a particular key, we require maximum\\n\\t26*(val-1)+key number if we want to convert all \\n\\tchar with same shift(key) to valid char in \\'t\\'.\\n\\tExample s = abc t =bcd we require number 1,27,53 to convert s to t.\\'\\'\\'\\n\\n\\t# So MAX_Val required will be max_freq with largest shift\\n\\t\\t\\tmax_f = shift_require_dict[max(shift_require_dict,key=shift_require_dict.get)]\\n\\t\\t\\tmax_diff =0\\n\\t\\t\\tfor key,val in shift_require_dict.items():\\n\\t\\t\\t\\tif val ==max_f:\\n\\t\\t\\t\\t\\tmax_diff = max(max_diff,key)\\n\\n\\t\\t\\tif (26*(max_f-1) + max_diff) <=k:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False",
                "codeTag": "Java"
            },
            {
                "id": 858863,
                "title": "python-breifly-explained-remember-the-recent-longest-shift-o-n",
                "content": "Each character at index j in both source and target string have some expected shifts. For example,\\n```\\ns[j] = \"a\"\\nt[j] = \"e\" \\n```\\nAlgorithm:\\n1.  Expected shifts are ```(ord(\"e\") - ord(\"a\"))%26```, since alphabets arranged in cycle. Here, ```shifts = 4```\\n\\n2.  Maintain a hashmap for used i number of shifts. Ask hashmap whether 4 shifts are available. If yes update the ```eyesUsed[4] = 4```\\n\\n3.  if any other pair of chars in s and t also asking for 4 shifts which are occupied, then previously saved hashmap[4] can lead us where to look next, which is  ```26 + eyesUsed[4]```  because next valid way to reach target char is to shift through all alphabets once.\\n\\n4.  Repeat **step 2** and **step3** untill vacant shifts found if number of shifts exceeded the K value then abort the loop and return False\\n\\n5.  After successfully shifting all the characters return True\\n\\n```\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n\\t\\tif len(s) != len(t): return False\\n\\n\\t\\t\\teyesUsed = dict()\\n\\t\\t\\tfor ch1,ch2 in zip(map(ord,s),map(ord,t)):\\n\\n\\t\\t\\t\\tif ch1 == ch2: continue\\n\\t\\t\\t\\tshift = (ch2 - ch1)%26\\n\\n\\t\\t\\t\\tinitShift = shift\\n\\t\\t\\t\\twhile 1 <= shift <= k:\\n\\n\\t\\t\\t\\t\\tif shift not in eyesUsed:\\n\\t\\t\\t\\t\\t\\teyesUsed[initShift] = shift\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\tshift = eyesUsed[initShift]+26\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True\\n        \\n```\\n\\n**Base cases:** \\n* ```If source s[i]  == target t[j] then skip shifting```\\n* ```if lengths of source != target then return False```\\n\\nUnderStood? Any Improvements?",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ns[j] = \"a\"\\nt[j] = \"e\" \\n```\n```(ord(\"e\") - ord(\"a\"))%26```\n```shifts = 4```\n```eyesUsed[4] = 4```\n```26 + eyesUsed[4]```\n```\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n\\t\\tif len(s) != len(t): return False\\n\\n\\t\\t\\teyesUsed = dict()\\n\\t\\t\\tfor ch1,ch2 in zip(map(ord,s),map(ord,t)):\\n\\n\\t\\t\\t\\tif ch1 == ch2: continue\\n\\t\\t\\t\\tshift = (ch2 - ch1)%26\\n\\n\\t\\t\\t\\tinitShift = shift\\n\\t\\t\\t\\twhile 1 <= shift <= k:\\n\\n\\t\\t\\t\\t\\tif shift not in eyesUsed:\\n\\t\\t\\t\\t\\t\\teyesUsed[initShift] = shift\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\tshift = eyesUsed[initShift]+26\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True\\n        \\n```\n```If source s[i]  == target t[j] then skip shifting```\n```if lengths of source != target then return False```",
                "codeTag": "Python3"
            },
            {
                "id": 836489,
                "title": "java-o-n-method",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] shiftCounts = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == t.charAt(i)) {\\n                continue;\\n            }\\n            int shift = getNumOfShifts(s.charAt(i), t.charAt(i));\\n            int val = shiftCounts[shift] * 26 + shift;\\n            if (val > k) {\\n                return false;\\n            }\\n            shiftCounts[shift]++;\\n        }\\n        return true;\\n    }\\n    \\n    private final int getNumOfShifts(char a, char b) {\\n        return (b - a + 26) % 26;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] shiftCounts = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == t.charAt(i)) {\\n                continue;\\n            }\\n            int shift = getNumOfShifts(s.charAt(i), t.charAt(i));\\n            int val = shiftCounts[shift] * 26 + shift;\\n            if (val > k) {\\n                return false;\\n            }\\n            shiftCounts[shift]++;\\n        }\\n        return true;\\n    }\\n    \\n    private final int getNumOfShifts(char a, char b) {\\n        return (b - a + 26) % 26;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781884,
                "title": "c-o-n-beat-100",
                "content": "Got TLE using set, so i use a int array to store the numbers of move. 100% time\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int used[26] = {0};\\n        int diff = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(t[i] - s[i] > 0) diff = t[i] - s[i];\\n            else if(t[i] - s[i] < 0) diff = 26 - s[i] + t[i];\\n            else continue;\\n            \\n            if( (used[diff]) * 26 + diff > k) return false;\\n            used[diff]++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int used[26] = {0};\\n        int diff = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(t[i] - s[i] > 0) diff = t[i] - s[i];\\n            else if(t[i] - s[i] < 0) diff = 26 - s[i] + t[i];\\n            else continue;\\n            \\n            if( (used[diff]) * 26 + diff > k) return false;\\n            used[diff]++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780437,
                "title": "python-o-n-solution-with-explanation",
                "content": "**Technique:**\\n\\n1. Create a `diffArr` (Difference Array) which will store the ascii difference between the characters in the string `t` & `s`. Since we can only increment & not reduce, for all the negative values(When we sustract `a` with `z`) we have to subtract it with 26 & store the difference. \\n2. Next step is to crate a set (`diffSet`) to keep track of the shifts which we have already used between `1-k`. \\n3. As we iterate through the `diffArr` we have to check if we already have the `ith` step in set, if not we\\'ll add it to the set since that is the first time we\\'re using it. And if it is already present - here\\'s where the real logic is. We have to keep incrementing the number of shifts by 26 as that would result in the same character. We have to increment it until we get the number of moves which have not been used until now (which is what the while loop within else statement is responsible for). \\n\\ni.e., difference 1 can take values 1, 27, 53, 79... & so on\\n\\nMeanwhile while moving itself, we can check if the number of shifts is going to exceed k or not, if yes return False\\n\\n**TLE Issue Code**\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        diffArr = []\\n        if s == t:\\n            return True\\n        n = len(s)\\n        n2 = len(t)\\n        if n != n2:\\n            return False\\n        for i in range(n):\\n            diff = ord(t[i])-ord(s[i])\\n            if diff < 0:\\n                diff = 26+diff\\n            diffArr.append(diff)\\n        diffSet = set()\\n        for i in diffArr:\\n            if i == 0:\\n                continue\\n            if i not in diffSet:\\n                diffSet.add(i)\\n            else:\\n                while i in diffSet:\\n                    if i > k:\\n                        return False\\n                    i += 26\\n                diffSet.add(i)\\n        return max(diffSet) <= k\\n```\\n\\n**Whats the problem with this approach?**\\n\\nSince we\\'re having a while loop which starts from i (which is less than 26) and loop until we find the next number of shifts for every value in `diffArr` we will end up in ***`TLE`***\\n\\n**How to solve this?**\\n\\nHere\\'s where memoization comes into picture. Instead of looping through by incrementing values by 26, we can store what is the value for the original `i` which will store the most recently used value for `i`\\n\\nFor eg., \\nif i = 1, we can have the number of shifts as 1,27,53,79... and so on.\\nInstead of calculating this from 1 upto... the limit k or next free value, mem[1] will store the most recently used value which will fit it. \\n\\nFor 1st iteration\\n```mem[1] = 1```\\n2nd\\n```mem[1] = 27```\\n3rd\\n```mem[1] = 53```\\n& so on\\n\\n**Working code with Single Loop**\\n\\nWe don\\'t have to store and then iterate the `diffArr`, we can perform the memoization & checks while iterating through the strings itself.\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        n = len(s)\\n        n2 = len(t)\\n        if n != n2:\\n            return False\\n        mem = {}\\n        for i in range(n):\\n            diff = ord(t[i])-ord(s[i])\\n            if diff == 0:\\n                continue\\n            if diff < 0:\\n                diff += 26\\n            if diff in mem:\\n                mem[diff] += 26\\n            else:\\n                mem[diff] = diff\\n            if mem[diff] > k:\\n                return False\\n        return True\\n```\\n\\nJust checking for the base conditions if both strings are same, we return `True`. And if the lengths don\\'t match, we return `False`",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        diffArr = []\\n        if s == t:\\n            return True\\n        n = len(s)\\n        n2 = len(t)\\n        if n != n2:\\n            return False\\n        for i in range(n):\\n            diff = ord(t[i])-ord(s[i])\\n            if diff < 0:\\n                diff = 26+diff\\n            diffArr.append(diff)\\n        diffSet = set()\\n        for i in diffArr:\\n            if i == 0:\\n                continue\\n            if i not in diffSet:\\n                diffSet.add(i)\\n            else:\\n                while i in diffSet:\\n                    if i > k:\\n                        return False\\n                    i += 26\\n                diffSet.add(i)\\n        return max(diffSet) <= k\\n```\n```mem[1] = 1```\n```mem[1] = 27```\n```mem[1] = 53```\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        n = len(s)\\n        n2 = len(t)\\n        if n != n2:\\n            return False\\n        mem = {}\\n        for i in range(n):\\n            diff = ord(t[i])-ord(s[i])\\n            if diff == 0:\\n                continue\\n            if diff < 0:\\n                diff += 26\\n            if diff in mem:\\n                mem[diff] += 26\\n            else:\\n                mem[diff] = diff\\n            if mem[diff] > k:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780066,
                "title": "java-6-lines-o-n-time-o-1-space",
                "content": "Just compute required swaps for each position modulo 26, and confirm that k is large enough to satisfy all required swappings.\\n\\n```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) return false;\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.length(); i++) counts[Math.floorMod(t.charAt(i) - s.charAt(i), 26)]++;\\n        for (int i = 1; i < 26; i++)\\n            if (counts[i] > 0 && i + (counts[i]-1)*26 > k) return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) return false;\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.length(); i++) counts[Math.floorMod(t.charAt(i) - s.charAt(i), 26)]++;\\n        for (int i = 1; i < 26; i++)\\n            if (counts[i] > 0 && i + (counts[i]-1)*26 > k) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3039833,
                "title": "can-convert-string-in-k-moves",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, it checks if the length of two strings are not equal, it returns false\\nIt calculates the number of shift required for each character to convert the first string to the second one.\\nThen it iterates over the number of shift required and for each shift, it checks if the number of shift * 26 + the current shift greater than k, if so it returns false.\\nIf all the indexes can be shifted in k moves or less, it returns true.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n) where n is the length of the string.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n The space complexity is O(1) since we are using a fixed size array of size 26 to store the shift count.\\n# Code\\n```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        // Edge case: if the length of the two strings are not equal, return false\\n        if (s.length() != t.length()) return false;\\n        int n = s.length();\\n        int[] diff = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            diff[i] = (t.charAt(i) - s.charAt(i) + 26) % 26;\\n        }\\n        int[] count = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            if (diff[i] == 0) continue;\\n            if (count[diff[i]] * 26 + diff[i] > k) return false;\\n            count[diff[i]]++;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        // Edge case: if the length of the two strings are not equal, return false\\n        if (s.length() != t.length()) return false;\\n        int n = s.length();\\n        int[] diff = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            diff[i] = (t.charAt(i) - s.charAt(i) + 26) % 26;\\n        }\\n        int[] count = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            if (diff[i] == 0) continue;\\n            if (count[diff[i]] * 26 + diff[i] > k) return false;\\n            count[diff[i]]++;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963839,
                "title": "python3-solution-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canConvertString(self, s, t, k):\\n        if len(s) != len(t): return False\\n        dp = [-1] * 27\\n        for a, b in zip(s, t):\\n            n = ord(b) - ord(a)\\n            dp[n if n >= 0 else 26 + n] += 1\\n        return all([dp[i] <= (k - i) // 26 for i in range(1, 27)])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s, t, k):\\n        if len(s) != len(t): return False\\n        dp = [-1] * 27\\n        for a, b in zip(s, t):\\n            n = ord(b) - ord(a)\\n            dp[n if n >= 0 else 26 + n] += 1\\n        return all([dp[i] <= (k - i) // 26 for i in range(1, 27)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666958,
                "title": "c-easy-to-understand-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool canConvertString(string s, string t, int k) {\\n    if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool canConvertString(string s, string t, int k) {\\n    if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915299,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int round = k / 26;\\n        int remaining = k % 26;\\n        int[] record = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            if (i < remaining) {\\n                record[i] += 1;\\n            }\\n            record[i] += round;\\n        }\\n        for (int i = 0; i < s.length(); i++) {\\n            char c1 = s.charAt(i);\\n            char c2 = t.charAt(i);\\n            if (c1 == c2) continue;\\n            int index = (c2 - c1 + 26) % 26 - 1;\\n            if (record[index] > 0) {\\n                record[index] -= 1;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1409548,
                "title": "c-easy",
                "content": "```\\n\\n```public:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        vector<vector<int>>v(26);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int diff=t[i]-s[i];\\n            if(diff<0)\\n            {\\n                diff=diff+26;\\n            }\\n            if(diff!=0)\\n            {\\n                if(v[diff].size()==0)\\n                {\\n                    v[diff].push_back(diff);\\n                }\\n                else\\n                {\\n                    v[diff].push_back(v[diff].back()+26);\\n                    diff=v[diff].back();\\n                }\\n            }\\n            if(diff>k)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1315618,
                "title": "first-pass-with-len-s-second-pass-with-len-26-100-speed",
                "content": "Runtime: 260 ms, faster than 100.00% of Python3 online submissions for Can Convert String in K Moves.\\nMemory Usage: 15.7 MB, less than 16.67% of Python3 online submissions for Can Convert String in K Moves.\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        shifts = [0] * 26\\n        for a, b in zip(s, t):\\n            shifts[(ord(b) - ord(a)) % 26] += 1\\n        for j, n in enumerate(shifts):\\n            if j > 0 and n > 0 and j + (n - 1) * 26 > k:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        shifts = [0] * 26\\n        for a, b in zip(s, t):\\n            shifts[(ord(b) - ord(a)) % 26] += 1\\n        for j, n in enumerate(shifts):\\n            if j > 0 and n > 0 and j + (n - 1) * 26 > k:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092769,
                "title": "c-easy-solution",
                "content": "```\\nbool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())\\n            return false;\\n        map<int,int> mp;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(t[i]-s[i]<0)\\n                mp[t[i]-s[i]+26]++;\\n            else if(t[i]-s[i]>0)\\n                mp[t[i]-s[i]]++;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if((it->second-1)*26+it->first>k)\\n                return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())\\n            return false;\\n        map<int,int> mp;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(t[i]-s[i]<0)\\n                mp[t[i]-s[i]+26]++;\\n            else if(t[i]-s[i]>0)\\n                mp[t[i]-s[i]]++;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if((it->second-1)*26+it->first>k)\\n                return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1059413,
                "title": "java-faster-than-100-o-n-time-complexity",
                "content": "\\n\\nclass Solution {\\n#####  public boolean canConvertString(String s, String t, int k) {\\n        char[] sref=s.toCharArray();            //Converting string to char Array\\n        char[] tref=t.toCharArray();            //Converting string to char Array\\n         int len=sref.length;\\n        if(len!=tref.length) return false;     //Base case\\n        int[] count=new int[26];                //Maximum difference we can get is 26\\n\\t\\tfor(int i=0;i<len;i++){\\n            if(tref[i]==sref[i]) continue;\\n            int temp=tref[i]-sref[i];\\n            if(temp<0) temp=temp+26;\\n            count[temp]++;                                  // Increment the count\\n            temp=temp+(26*(count[temp]-1));                 //value which it needs\\n            if(temp>k) return false;                         //compare with the k value\\n        }\\n        return true;\\n       \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n#####  public boolean canConvertString(String s, String t, int k) {\\n        char[] sref=s.toCharArray();            //Converting string to char Array\\n        char[] tref=t.toCharArray();            //Converting string to char Array\\n         int len=sref.length;\\n        if(len!=tref.length) return false;     //Base case\\n        int[] count=new int[26];                //Maximum difference we can get is 26\\n\\t\\tfor(int i=0;i<len;i++){\\n            if(tref[i]==sref[i]) continue;\\n            int temp=tref[i]-sref[i];\\n            if(temp<0) temp=temp+26;\\n            count[temp]++;                                  // Increment the count\\n            temp=temp+(26*(count[temp]-1));                 //value which it needs\\n            if(temp>k) return false;                         //compare with the k value\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 988808,
                "title": "c-60-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(const string& s, const string& t, int k) {\\n        \\n        if(s.size()!=t.size()) return false;\\n        \\n        int shift=0;\\n        vector<int> v(26);\\n        for(int i=0; i<s.size(); ++i) {\\n            if(s[i]!=t[i]) {\\n                shift=s[i]<t[i]?t[i]-s[i]:t[i]-s[i]+26;\\n                shift+=26*v[shift]++;\\n                if(k-shift<0) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(const string& s, const string& t, int k) {\\n        \\n        if(s.size()!=t.size()) return false;\\n        \\n        int shift=0;\\n        vector<int> v(26);\\n        for(int i=0; i<s.size(); ++i) {\\n            if(s[i]!=t[i]) {\\n                shift=s[i]<t[i]?t[i]-s[i]:t[i]-s[i]+26;\\n                shift+=26*v[shift]++;\\n                if(k-shift<0) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888012,
                "title": "python3-o-n-solution-beats-99",
                "content": "```py\\nimport collections\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        # check lengths\\n        n1 = len(s)\\n        n2 = len(t)\\n        if n1 != n2:\\n            return False\\n        n = n1\\n        \\n        # find diffArray\\n        diffArray = [(ord(t[i])-ord(s[i]))%26 for i in range(n)]\\n       \\n        # frequency of difference\\n        cda = collections.Counter(diffArray)\\n        \\n        # delete 0\\n        del cda[0]\\n        \\n        minK = 0\\n        if len(cda) > 0 :\\n            key = max([(i[1], i[0])for i in cda.items()])\\n            minK = (key[0] - 1) *26 + key[1]\\n        \\n        return k >= minK\\n```",
                "solutionTags": [],
                "code": "```py\\nimport collections\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        # check lengths\\n        n1 = len(s)\\n        n2 = len(t)\\n        if n1 != n2:\\n            return False\\n        n = n1\\n        \\n        # find diffArray\\n        diffArray = [(ord(t[i])-ord(s[i]))%26 for i in range(n)]\\n       \\n        # frequency of difference\\n        cda = collections.Counter(diffArray)\\n        \\n        # delete 0\\n        del cda[0]\\n        \\n        minK = 0\\n        if len(cda) > 0 :\\n            key = max([(i[1], i[0])for i in cda.items()])\\n            minK = (key[0] - 1) *26 + key[1]\\n        \\n        return k >= minK\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887066,
                "title": "python3-o-n-solution-can-convert-string-in-k-moves",
                "content": "Find the largest character among those who have the highest frequency. The min steps required is the `(freq - 1) * 26 + ord(char)`.\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        distance = Counter((ord(b) - ord(a)) % 26 for a, b in zip(s, t) if a != b)\\n        maxf = [-1, -1]\\n        for c, f in distance.items():\\n            if f > maxf[1] or f == maxf[1] and c > maxf[0]:\\n                maxf[0] = c\\n                maxf[1] = f\\n        return not distance or ((maxf[1] - 1) * 26 + maxf[0]) <= k\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        distance = Counter((ord(b) - ord(a)) % 26 for a, b in zip(s, t) if a != b)\\n        maxf = [-1, -1]\\n        for c, f in distance.items():\\n            if f > maxf[1] or f == maxf[1] and c > maxf[0]:\\n                maxf[0] = c\\n                maxf[1] = f\\n        return not distance or ((maxf[1] - 1) * 26 + maxf[0]) <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881844,
                "title": "c-99-faster-simple-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        vector<int> changes(26, 0);\\n        for(int i=0;i<s.size();i++){\\n            if(t[i]!=s[i])\\n            changes[ (t[i]-s[i]+26)%26]++;\\n        }\\n        \\n        for(int i=1; i<changes.size(); i++){\\n            int diff = i + (26 * (changes[i]-1));\\n            if(diff > k) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        vector<int> changes(26, 0);\\n        for(int i=0;i<s.size();i++){\\n            if(t[i]!=s[i])\\n            changes[ (t[i]-s[i]+26)%26]++;\\n        }\\n        \\n        for(int i=1; i<changes.size(); i++){\\n            int diff = i + (26 * (changes[i]-1));\\n            if(diff > k) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822842,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length()) return false;\\n        vector<int> vi(27, 0);\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (t[i] > s[i]) vi[t[i] - s[i]]++;\\n            else vi[t[i] - s[i] + 26]++;\\n        }\\n        for (int i = 1; i < 26; ++i) {\\n            if (i + (vi[i] - 1) * 26 > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length()) return false;\\n        vector<int> vi(27, 0);\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (t[i] > s[i]) vi[t[i] - s[i]]++;\\n            else vi[t[i] - s[i] + 26]++;\\n        }\\n        for (int i = 1; i < 26; ++i) {\\n            if (i + (vi[i] - 1) * 26 > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 814681,
                "title": "very-eazy-and-clear-python-3-solution-o-n",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n\\t\\t# checking edge cases\\n        if len(s) != len(t):\\n            return False\\n        if s == t:\\n            return True\\n        \\n\\t\\t\\n        s = list(s)\\n        t = list(t)\\n        \\n        used = {} # creating dictionary or ditances which were used\\n        for i in range(len(s)):\\n            if s[i] != t[i]:  # if these letter are the same we don\\'t care about them\\n                diff = (ord(t[i]) - ord(s[i]))%26  \\n\\n                if diff > k:\\n                    return False\\n                \\n                if diff not in used:\\n                    used[diff] = 1    \\n                else:\\n                    if diff + 26*used[diff] <= k:  # we can wrap around adding 26 steps\\n                        used[diff] += 1\\n                    else:\\n                        return False   # if we don\\'t have what we need \\n        \\n        return True   # we went through strings and everything is OK\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n\\t\\t# checking edge cases\\n        if len(s) != len(t):\\n            return False\\n        if s == t:\\n            return True\\n        \\n\\t\\t\\n        s = list(s)\\n        t = list(t)\\n        \\n        used = {} # creating dictionary or ditances which were used\\n        for i in range(len(s)):\\n            if s[i] != t[i]:  # if these letter are the same we don\\'t care about them\\n                diff = (ord(t[i]) - ord(s[i]))%26  \\n\\n                if diff > k:\\n                    return False\\n                \\n                if diff not in used:\\n                    used[diff] = 1    \\n                else:\\n                    if diff + 26*used[diff] <= k:  # we can wrap around adding 26 steps\\n                        used[diff] += 1\\n                    else:\\n                        return False   # if we don\\'t have what we need \\n        \\n        return True   # we went through strings and everything is OK\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 800729,
                "title": "java-hashmap-solution",
                "content": "```\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0;i < s.length();i++){\\n            int d = getOp(s.charAt(i),t.charAt(i));\\n            if(d == 0) continue;\\n            int op = map.getOrDefault(d,0)*26 + d;\\n            if(op > k) return false;\\n            map.put(d,map.getOrDefault(d,0) + 1);\\n        }\\n        return true;\\n    }\\n    public int getOp(char in,char out){\\n        if(in <= out){\\n            return out - in;\\n        }else{\\n            return (\\'z\\' - in + (out - \\'a\\' + 1));\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0;i < s.length();i++){\\n            int d = getOp(s.charAt(i),t.charAt(i));\\n            if(d == 0) continue;\\n            int op = map.getOrDefault(d,0)*26 + d;\\n            if(op > k) return false;\\n            map.put(d,map.getOrDefault(d,0) + 1);\\n        }\\n        return true;\\n    }\\n    public int getOp(char in,char out){\\n        if(in <= out){\\n            return out - in;\\n        }else{\\n            return (\\'z\\' - in + (out - \\'a\\' + 1));\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 800282,
                "title": "c-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()) return false;\\n        unordered_map<int,int>mp;\\n        int left=k%26;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==t[i]) continue;\\n            int req;\\n            if(s[i]<t[i]){\\n                req=t[i]-s[i];\\n            }else{\\n                req=t[i]-\\'a\\'+(\\'z\\'-s[i])+1;\\n            }\\n            if(req>k) return false;\\n            mp[req]++;\\n            int max=k/26;\\n            if(req<=left) max++;\\n            if(mp[req]>max) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()) return false;\\n        unordered_map<int,int>mp;\\n        int left=k%26;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==t[i]) continue;\\n            int req;\\n            if(s[i]<t[i]){\\n                req=t[i]-s[i];\\n            }else{\\n                req=t[i]-\\'a\\'+(\\'z\\'-s[i])+1;\\n            }\\n            if(req>k) return false;\\n            mp[req]++;\\n            int max=k/26;\\n            if(req<=left) max++;\\n            if(mp[req]>max) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793074,
                "title": "simple-c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length())   return false;\\n        map<int, int> vmap;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] != t[i]) {\\n                int diff;\\n                if (t[i] > s[i]) diff = t[i] - s[i];\\n                else diff = t[i] - s[i] + 26;\\n                vmap[diff]++;\\n            }\\n        }\\n        if (vmap.empty())   return true;\\n        for (map<int, int> :: iterator it = vmap.begin(); it != vmap.end(); it++) {\\n            \\n            if (((it->second - 1) * 26) + it->first > k) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length())   return false;\\n        map<int, int> vmap;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] != t[i]) {\\n                int diff;\\n                if (t[i] > s[i]) diff = t[i] - s[i];\\n                else diff = t[i] - s[i] + 26;\\n                vmap[diff]++;\\n            }\\n        }\\n        if (vmap.empty())   return true;\\n        for (map<int, int> :: iterator it = vmap.begin(); it != vmap.end(); it++) {\\n            \\n            if (((it->second - 1) * 26) + it->first > k) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784683,
                "title": "python-3-explained",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \"\"\"\\n        This program determines whether string can be converted\\n        to string t within k moves.\\n\\n        :param s: string to be converted\\n        :type s: str\\n        :param t: target string\\n        :type t: str\\n        :param k: maximum number of moves allowed\\n        :type k: int\\n        :return: True if conversion possible within k moves,\\n                 else False\\n        :rtype: bool\\n        \"\"\"\\n\\n        \"\"\"\\n        Base Case:\\n        - If strings s and t are different lengths, return False.\\n        \"\"\"\\n        if len(s) != len(t):\\n            return False\\n\\n        \"\"\"\\n        Determine whether conversion from s to t is possible\\n        within k moves:\\n        - The shift map (shift_map) maps a shift count to the\\n          maximum number of moves needed to complete all moves\\n          with this shift count. If there are multiple moves\\n          with the same shift count, the first shift is executed\\n          at move \"shift count\". The second shift is executed 26\\n          moves, the third one 26 moves after the second, and so\\n          on.\\n        - If the maximum number of moves for a shift count exceeds\\n          k, return False.\\n        - If the analysis of strings s and t is completed without\\n          exceeding k moves, return True.\\n        \"\"\"\\n        shift_map = {}\\n        for j, s_chr in enumerate(s):\\n            if s_chr != t[j]:\\n                shift = ord(t[j]) - ord(s_chr)\\n                if shift < 0:\\n                    shift += 26\\n                if shift:\\n                    if shift in shift_map:\\n                        shift_map[shift] += 26\\n                    else:\\n                        shift_map[shift] = shift\\n                    if shift_map[shift] > k:\\n                        return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \"\"\"\\n        This program determines whether string can be converted\\n        to string t within k moves.\\n\\n        :param s: string to be converted\\n        :type s: str\\n        :param t: target string\\n        :type t: str\\n        :param k: maximum number of moves allowed\\n        :type k: int\\n        :return: True if conversion possible within k moves,\\n                 else False\\n        :rtype: bool\\n        \"\"\"\\n\\n        \"\"\"\\n        Base Case:\\n        - If strings s and t are different lengths, return False.\\n        \"\"\"\\n        if len(s) != len(t):\\n            return False\\n\\n        \"\"\"\\n        Determine whether conversion from s to t is possible\\n        within k moves:\\n        - The shift map (shift_map) maps a shift count to the\\n          maximum number of moves needed to complete all moves\\n          with this shift count. If there are multiple moves\\n          with the same shift count, the first shift is executed\\n          at move \"shift count\". The second shift is executed 26\\n          moves, the third one 26 moves after the second, and so\\n          on.\\n        - If the maximum number of moves for a shift count exceeds\\n          k, return False.\\n        - If the analysis of strings s and t is completed without\\n          exceeding k moves, return True.\\n        \"\"\"\\n        shift_map = {}\\n        for j, s_chr in enumerate(s):\\n            if s_chr != t[j]:\\n                shift = ord(t[j]) - ord(s_chr)\\n                if shift < 0:\\n                    shift += 26\\n                if shift:\\n                    if shift in shift_map:\\n                        shift_map[shift] += 26\\n                    else:\\n                        shift_map[shift] = shift\\n                    if shift_map[shift] > k:\\n                        return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782490,
                "title": "java-easy-solution-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        List<Integer> li=new ArrayList<>();\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=t.charAt(i)){\\n                int diff=t.charAt(i)-s.charAt(i);\\n                // System.out.println(t.charAt(i)+\" \"+diff+\" \"+s.charAt(i));\\n                if(diff<0){\\n                    diff=diff+26;\\n                }\\n                int a=diff;\\n                int v=0;\\n                if(li.contains(diff)){\\n                    v=map.get(a);\\n                    diff=v+26;\\n                }\\n                map.put(a,diff);\\n                if(k>=diff){\\n                \\n                    li.add(diff);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 781657,
                "title": "java-simple-o-n-time-constant-space-solution",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int[] arr=new int[26];\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=get(s.charAt(i),t.charAt(i));\\n            if(a!=0)\\n            {\\n                arr[a]++;\\n                a=(arr[a]-1)*26+a;\\n            }\\n            if(a>k)return false;\\n        }\\n        return true;\\n    }\\n    public int get(char a,char b)\\n    {   if(a==b)return 0;\\n        if(b>a)return b-a;\\n        return b+26-a;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int[] arr=new int[26];\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=get(s.charAt(i),t.charAt(i));\\n            if(a!=0)\\n            {\\n                arr[a]++;\\n                a=(arr[a]-1)*26+a;\\n            }\\n            if(a>k)return false;\\n        }\\n        return true;\\n    }\\n    public int get(char a,char b)\\n    {   if(a==b)return 0;\\n        if(b>a)return b-a;\\n        return b+26-a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780785,
                "title": "easy-c-solution-using-hashmap-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())return false;\\n        unordered_map<long long int,long long int>mp;\\n        vector<long long int>ans;\\n        for(int i=0;i<t.size();i++)\\n        {\\n\\t\\t\\t\\t if(s[i]!=t[i])\\n\\t\\t\\t\\t {\\n\\t\\t\\t\\t  long long int req = s[i]<t[i] ? t[i]-s[i] : 26+t[i]-s[i];\\n\\t\\t\\t\\t  if(req>k)return false;\\n\\t\\t\\t\\t\\t\\t  if(mp.find(req)!=mp.end()) {\\n\\t\\t\\t\\t\\t\\t   mp[req]+=26;\\n\\t\\t\\t\\t\\t\\t   if(mp[req]>k)return false;\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t\\t  else{\\n\\t\\t\\t\\t\\t\\t\\t\\tmp[req]=req;\\n\\t\\t\\t\\t\\t\\t\\t   if(req>k)return false;\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())return false;\\n        unordered_map<long long int,long long int>mp;\\n        vector<long long int>ans;\\n        for(int i=0;i<t.size();i++)\\n        {\\n\\t\\t\\t\\t if(s[i]!=t[i])\\n\\t\\t\\t\\t {\\n\\t\\t\\t\\t  long long int req = s[i]<t[i] ? t[i]-s[i] : 26+t[i]-s[i];\\n\\t\\t\\t\\t  if(req>k)return false;\\n\\t\\t\\t\\t\\t\\t  if(mp.find(req)!=mp.end()) {\\n\\t\\t\\t\\t\\t\\t   mp[req]+=26;\\n\\t\\t\\t\\t\\t\\t   if(mp[req]>k)return false;\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t\\t  else{\\n\\t\\t\\t\\t\\t\\t\\t\\tmp[req]=req;\\n\\t\\t\\t\\t\\t\\t\\t   if(req>k)return false;\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780454,
                "title": "javascript-python3-c-add-del-needs",
                "content": "**Synopsis:**\\n\\nUse a hash table to track `needs`.  Return `true` if and only if there are no `needs`.  There are three use cases to consider when calculating `needs` by comparing the difference (ie. `k`) between each i-th character\\'s ordinal value in `s` and `t`:\\n\\n* **Case 1:** the difference is 0, then there\\'s no need to perform any rotation, since the characters are the same\\n* **Case 2:** the difference is a positive value `x`, this means that the character `s[i]` occurs *before* the character `t[i]` lexicographically in the english latin alphabet, and so we can safely add 26 onto `x` because when we mod by 26, we end up with the same value, ie `x == (x + 26) % 26`.  (Try plugging in some positive values for `x` if you don\\'t believe me.)  Since adding 26 then mod\\'ing by 26 is a no-op for case 2, one may wonder \"what\\'s the point?\"  The purpose of adding by 26 is for case 3, the \"wrap-around\" case.\\n* **Case 3:** the difference is a negative value, this means that the character `s[i]` occurs *after* the character `t[i]` lexicographically in the english latin alphabet, per the problem statement, when we rotate this character, it \"wraps-around\" upon reaching `z` back to `a`.  So the \"wrap-around\" length is taken into account by adding 26 onto the negative value.  The result is a positive value `y` which is less than 26, and so we can safely mod `y` by 26 because any value less than 26 mod by 26 is that same value, ie. if `0 < y < 26`, then `y == y % 26`\\n\\nIn general, we can think of the difference (ie. `k`) as buckets between 1..25 inclusive which track the count of each i-th character rotation needed to transform `s` to `t` per the rules of the problem statement.\\n\\n---\\n\\n**Screenshare:** https://www.youtube.com/watch?v=xuyvk8ycHFs\\n\\n---\\n\\n**Verbose Solutions:**\\n\\n*Javascript*\\n```\\nlet canConvertString = (s, t, K, need = {}, needs = 0) => {\\n    if (s.length != t.length)\\n        return false;\\n    // \\u2705 add needs\\n    for (let i = 0; i < s.length; ++i) {\\n        let diff = (t[i].charCodeAt(0) - s[i].charCodeAt(0) + 26) % 26;\\n        if (diff)\\n            need[diff] = need[diff] ? 1 + need[diff] : 1, ++needs;\\n    }\\n    // \\uD83D\\uDEAB del needs\\n    for (let i = 1; i <= K && needs; ++i) {\\n        let diff = i % 26;\\n        if (need[diff])\\n            --need[diff], --needs;\\n    }\\n    return !needs; // \\uD83C\\uDFAF no needs\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, K: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        need, needs = {}, 0\\n        # \\u2705 add needs \\n        for i in range(len(s)):\\n            diff = (ord(t[i]) - ord(s[i]) + 26) % 26\\n            if diff:\\n                if not diff in need:\\n                    need[diff] = 0\\n                need[diff] += 1\\n                needs += 1\\n        # \\uD83D\\uDEAB del needs\\n        for i in range(1, K + 1):\\n            if not needs:\\n                break\\n            diff = i % 26\\n            if diff in need and need[diff]:\\n                need[diff] -= 1\\n                needs -= 1\\n        return not needs # \\uD83C\\uDFAF no needs\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<int, int>;\\n    bool canConvertString(string s, string t, int K, Map need = {}, int needs = 0) {\\n        if (s.size() != t.size())\\n            return false;\\n        // \\u2705 add needs\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto diff = (t[i] - s[i] + 26) % 26;\\n            if (diff)\\n                ++need[diff], ++needs;\\n        }\\n        // \\uD83D\\uDEAB del needs\\n        for (auto i{ 1 }; i <= K && needs; ++i) {\\n            auto diff = i % 26;\\n            if (need[diff])\\n                --need[diff], --needs;\\n        }\\n        return !needs; // \\uD83C\\uDFAF no needs\\n    }\\n};\\n```\\n\\n---\\n\\n**Concise Solutions:** it is naive to continually iterate i to find needs to delete because we know we need to rotate each k-th need bucket by 26 (ie. the cardinality of the latin alphabet) for each bucket count greater than 1.  For example to transform `aa` to `bb`, we need 1 rotation for the first difference in this bucket, plus (1 * 26) rotations for the remaining differences in this bucket for a total of 27 rotations.  Similiarly to transform `aaa` to `bbb`, we need 1 rotation for the first difference in this bucket, plus (2 * 26) rotations for the remaining differences in this bucket for a total of 53 rotations, etc, etc...\\n\\n*Javascript*\\n```\\nlet canConvertString = (s, t, T, need = {}) => {\\n    if (s.length != t.length)\\n        return false;\\n    // \\u2705 add needs\\n    for (let i = 0; i < s.length; ++i) {\\n        let k = (t[i].charCodeAt(0) - s[i].charCodeAt(0) + 26) % 26;\\n        if (k)\\n            need[k] = need[k] ? 1 + need[k] : 1;\\n    }\\n    // check if T is \\uD83D\\uDEAB insufficient for the needs\\n    for (let [k, cnt] of Object.entries(need))\\n        if (T < Number(k) + (cnt - 1) * 26)\\n            return false;\\n    return true; // \\uD83C\\uDFAF T is sufficient for the needs\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, T: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        need = {}\\n        # \\u2705 add needs \\n        for i in range(len(s)):\\n            k = (ord(t[i]) - ord(s[i])) % 26\\n            if k:\\n                if not k in need:\\n                    need[k] = 0\\n                need[k] += 1\\n        # check if T is \\uD83D\\uDEAB insufficient for the needs\\n        for k, cnt in need.items():\\n            if T < k + (cnt - 1) * 26:\\n                return False\\n        return True # \\uD83C\\uDFAF T is sufficient for the needs\\n```\\n\\n*C++*\\n```\\npublic:\\n    using Map = unordered_map<int, int>;\\n    bool canConvertString(string s, string t, int T, Map need = {}) {\\n        if (s.size() != t.size())\\n            return false;\\n        // \\u2705 add needs\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto k = (t[i] - s[i] + 26) % 26;\\n            if (k)\\n                ++need[k];\\n        }\\n        // check if T is \\uD83D\\uDEAB insufficient for the needs\\n        for (auto [k, cnt]: need)\\n            if (T < k + (cnt - 1) * 26)\\n                return false;\\n        return true; // \\uD83C\\uDFAF T is sufficient for the needs\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nlet canConvertString = (s, t, K, need = {}, needs = 0) => {\\n    if (s.length != t.length)\\n        return false;\\n    // \\u2705 add needs\\n    for (let i = 0; i < s.length; ++i) {\\n        let diff = (t[i].charCodeAt(0) - s[i].charCodeAt(0) + 26) % 26;\\n        if (diff)\\n            need[diff] = need[diff] ? 1 + need[diff] : 1, ++needs;\\n    }\\n    // \\uD83D\\uDEAB del needs\\n    for (let i = 1; i <= K && needs; ++i) {\\n        let diff = i % 26;\\n        if (need[diff])\\n            --need[diff], --needs;\\n    }\\n    return !needs; // \\uD83C\\uDFAF no needs\\n};\\n```\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, K: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        need, needs = {}, 0\\n        # \\u2705 add needs \\n        for i in range(len(s)):\\n            diff = (ord(t[i]) - ord(s[i]) + 26) % 26\\n            if diff:\\n                if not diff in need:\\n                    need[diff] = 0\\n                need[diff] += 1\\n                needs += 1\\n        # \\uD83D\\uDEAB del needs\\n        for i in range(1, K + 1):\\n            if not needs:\\n                break\\n            diff = i % 26\\n            if diff in need and need[diff]:\\n                need[diff] -= 1\\n                needs -= 1\\n        return not needs # \\uD83C\\uDFAF no needs\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<int, int>;\\n    bool canConvertString(string s, string t, int K, Map need = {}, int needs = 0) {\\n        if (s.size() != t.size())\\n            return false;\\n        // \\u2705 add needs\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto diff = (t[i] - s[i] + 26) % 26;\\n            if (diff)\\n                ++need[diff], ++needs;\\n        }\\n        // \\uD83D\\uDEAB del needs\\n        for (auto i{ 1 }; i <= K && needs; ++i) {\\n            auto diff = i % 26;\\n            if (need[diff])\\n                --need[diff], --needs;\\n        }\\n        return !needs; // \\uD83C\\uDFAF no needs\\n    }\\n};\\n```\n```\\nlet canConvertString = (s, t, T, need = {}) => {\\n    if (s.length != t.length)\\n        return false;\\n    // \\u2705 add needs\\n    for (let i = 0; i < s.length; ++i) {\\n        let k = (t[i].charCodeAt(0) - s[i].charCodeAt(0) + 26) % 26;\\n        if (k)\\n            need[k] = need[k] ? 1 + need[k] : 1;\\n    }\\n    // check if T is \\uD83D\\uDEAB insufficient for the needs\\n    for (let [k, cnt] of Object.entries(need))\\n        if (T < Number(k) + (cnt - 1) * 26)\\n            return false;\\n    return true; // \\uD83C\\uDFAF T is sufficient for the needs\\n};\\n```\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, T: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        need = {}\\n        # \\u2705 add needs \\n        for i in range(len(s)):\\n            k = (ord(t[i]) - ord(s[i])) % 26\\n            if k:\\n                if not k in need:\\n                    need[k] = 0\\n                need[k] += 1\\n        # check if T is \\uD83D\\uDEAB insufficient for the needs\\n        for k, cnt in need.items():\\n            if T < k + (cnt - 1) * 26:\\n                return False\\n        return True # \\uD83C\\uDFAF T is sufficient for the needs\\n```\n```\\npublic:\\n    using Map = unordered_map<int, int>;\\n    bool canConvertString(string s, string t, int T, Map need = {}) {\\n        if (s.size() != t.size())\\n            return false;\\n        // \\u2705 add needs\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto k = (t[i] - s[i] + 26) % 26;\\n            if (k)\\n                ++need[k];\\n        }\\n        // check if T is \\uD83D\\uDEAB insufficient for the needs\\n        for (auto [k, cnt]: need)\\n            if (T < k + (cnt - 1) * 26)\\n                return false;\\n        return true; // \\uD83C\\uDFAF T is sufficient for the needs\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780288,
                "title": "c-o-n-solution-easy-to-understand",
                "content": "**\\nIt\\'s just iterate over the length of the strings....\\nfirst case : if length of both the strings are not same simply return false ;\\nSecond case : if both char are different take the differnce of the ASCII values of the char and if it less than 0 so you need to add the differnce(i.e is diff) to 26 + diff ....as we need to see clockwise rotation from a to z.\\nand the main part comes when it asks you about if differnce is repeated then what ? Then you just need to mantain a map or set something to keep frequency of the differnce how many times it is appearing ... and formula will be like diff = 26 * m[diff] + diff ..... see the code which will help you to understand more...and make a dry run which will help you more better\\n**\\n\\n*if liked my solution please upvote :D*\\n```\\nclass Solution {\\npublic:\\nbool canConvertString(string s, string t, int k)\\n{\\n\\tint n = s.length();\\n\\tint l = t.length();\\n\\n\\tif (n != l)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tmap<int, int> m;\\n\\t\\tint diff = 0;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (s[i] != t[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdiff = t[i] - s[i];\\n\\t\\t\\t\\tif (diff < 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdiff = 26 + diff;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (diff <= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (m.find(diff) == m.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tm.insert({diff, 1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint ans = 26 * m[diff] + diff;\\n\\t\\t\\t\\t\\tif (ans <= k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tm[diff]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\n\\t}\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nbool canConvertString(string s, string t, int k)\\n{\\n\\tint n = s.length();\\n\\tint l = t.length();\\n\\n\\tif (n != l)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tmap<int, int> m;\\n\\t\\tint diff = 0;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (s[i] != t[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdiff = t[i] - s[i];\\n\\t\\t\\t\\tif (diff < 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdiff = 26 + diff;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (diff <= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (m.find(diff) == m.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tm.insert({diff, 1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint ans = 26 * m[diff] + diff;\\n\\t\\t\\t\\t\\tif (ans <= k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tm[diff]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\n\\t}\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780084,
                "title": "c-o-n-time-o-1-space-explained",
                "content": "If length are not same return false.\\notherwise\\nThere are 3 possible cases for each chars at same index\\n1. if s[i] == t[i] then continue;\\n2. else find difference (if -ve add 26) which will be in range [0,25], for this we take 26 size array **step** to remember the which moves we have already taken, and update **step** for next possible move we can take.\\n**example:**\\ndiff = t[i]-s[i];\\nFor diff = 1, possible moves are 1, 27, 53 ...\\nFor diff = 2, possible moves are 2, 28, 54 ...\\nFor diff = 3, possible moves are 3, 29, 55 ... \\n.\\n.\\n.\\nFor diff = 25, possible moves are 25, 51, 77 ... \\n\\n3. Whenever we found the move we need for this is greater K return false. \\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()) return false;\\n        vector<int> step(27, 0);\\n        for(int i=1; i<27; ++i){\\n            step[i] = i;\\n        }\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            if(s[i] == t[i]) continue;\\n            \\n            int diff = t[i]-s[i];\\n            if(diff < 0) diff += 26;\\n            if(step[diff] <= k){\\n                step[diff] += 26;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()) return false;\\n        vector<int> step(27, 0);\\n        for(int i=1; i<27; ++i){\\n            step[i] = i;\\n        }\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            if(s[i] == t[i]) continue;\\n            \\n            int diff = t[i]-s[i];\\n            if(diff < 0) diff += 26;\\n            if(step[diff] <= k){\\n                step[diff] += 26;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780078,
                "title": "python-dictionary-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\t\\t\\tif len(s) != len(t):\\n\\t\\t\\t\\treturn False\\n\\t\\t\\td = {}\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif t[i] != s[i]:\\n\\t\\t\\t\\t\\tif t[i] > s[i]:\\n\\t\\t\\t\\t\\t\\tdiff = ord(t[i]) - ord(s[i])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdiff = ord(t[i]) + 26 - ord(s[i])\\n\\t\\t\\t\\t\\tif diff > k:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tif diff not in d:\\n\\t\\t\\t\\t\\t\\t\\td[diff] = diff\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tif d[diff] + 26 > k:\\n\\t\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\t\\td[diff] += 26\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\t\\t\\tif len(s) != len(t):\\n\\t\\t\\t\\treturn False\\n\\t\\t\\td = {}",
                "codeTag": "Java"
            },
            {
                "id": 779965,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int[] hash = new int[26];\\n        Arrays.fill(hash,k / 26);\\n        int offset = k % 26;\\n        for(int i=0;i<=offset;++i) hash[i]++;\\n        for(int i=0;i<s.length();++i){\\n            if(s.charAt(i) != t.charAt(i)){\\n                int c1 = s.charAt(i) - \\'a\\' + 1;\\n                int c2 = t.charAt(i) - \\'a\\' + 1;\\n                int m = 0;\\n                if(c1 <= c2){\\n                    m = c2 - c1;\\n                }else{\\n                    m = 26 - c1 + c2;\\n                }\\n                \\n                if(hash[m]-- <= 0) return false;        \\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int[] hash = new int[26];\\n        Arrays.fill(hash,k / 26);\\n        int offset = k % 26;\\n        for(int i=0;i<=offset;++i) hash[i]++;\\n        for(int i=0;i<s.length();++i){\\n            if(s.charAt(i) != t.charAt(i)){\\n                int c1 = s.charAt(i) - \\'a\\' + 1;\\n                int c2 = t.charAt(i) - \\'a\\' + 1;\\n                int m = 0;\\n                if(c1 <= c2){\\n                    m = c2 - c1;\\n                }else{\\n                    m = 26 - c1 + c2;\\n                }\\n                \\n                if(hash[m]-- <= 0) return false;        \\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779961,
                "title": "c-dictionary",
                "content": "Runtime: 224 ms\\nMemory Usage: 40.2 MB\\n\\n```\\n\\n    public bool CanConvertString(string s, string t, int k) {\\n        if (s.Length != t.Length) { return false; }\\n        \\n        int alphaLength = \\'z\\'-\\'a\\'+1;\\n        \\n        Dictionary<int, int> distance = new Dictionary<int, int>();\\n        int moves;\\n        \\n        for(int i=0; i<s.Length; i++)\\n        {\\n            if (s[i] == t[i]) { continue; }\\n            \\n            if (s[i] < t[i]) \\n            {  \\n                moves = t[i] - s[i]; \\n            }\\n            else\\n            {\\n                moves = alphaLength - (s[i] - t[i]); \\n            }\\n           \\n            if (moves > k) { return false; }\\n            \\n            if (!distance.ContainsKey(moves)) { distance[moves] = 0; }\\n            distance[moves]++;\\n        }\\n        \\n        foreach(int key in distance.Keys)\\n        {\\n            if (distance[key] == 1) { continue; }\\n            if (key + ((distance[key]-1) * alphaLength) > k) { return false; }\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 224 ms\\nMemory Usage: 40.2 MB\\n\\n```\\n\\n    public bool CanConvertString(string s, string t, int k) {\\n        if (s.Length != t.Length) { return false; }\\n        \\n        int alphaLength = \\'z\\'-\\'a\\'+1;\\n        \\n        Dictionary<int, int> distance = new Dictionary<int, int>();\\n        int moves;\\n        \\n        for(int i=0; i<s.Length; i++)\\n        {\\n            if (s[i] == t[i]) { continue; }\\n            \\n            if (s[i] < t[i]) \\n            {  \\n                moves = t[i] - s[i]; \\n            }\\n            else\\n            {\\n                moves = alphaLength - (s[i] - t[i]); \\n            }\\n           \\n            if (moves > k) { return false; }\\n            \\n            if (!distance.ContainsKey(moves)) { distance[moves] = 0; }\\n            distance[moves]++;\\n        }\\n        \\n        foreach(int key in distance.Keys)\\n        {\\n            if (distance[key] == 1) { continue; }\\n            if (key + ((distance[key]-1) * alphaLength) > k) { return false; }\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4091920,
                "title": "simple-c-solution-o-n-time-and-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        vector<int> diff(26,0);\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]!=t[i]){\\n                int d = (t[i] - s[i] + 26)%26;\\n                int n1 = 26*diff[d] + d;\\n                if(n1<=k){\\n                    diff[d]++;\\n                }\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        vector<int> diff(26,0);\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]!=t[i]){\\n                int d = (t[i] - s[i] + 26)%26;\\n                int n1 = 26*diff[d] + d;\\n                if(n1<=k){\\n                    diff[d]++;\\n                }\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084270,
                "title": "simple-c-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n\\n        int n = s.size();\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=t[i]){\\n                int x = (int)(t[i])-(int)(s[i]);\\n                if(x<0) x+=26;\\n                int m=26*mp[x];\\n                if(x+m>k) return 0;\\n                else{\\n                    mp[x]++;\\n                }\\n            }\\n        }\\n\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n\\n        int n = s.size();\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=t[i]){\\n                int x = (int)(t[i])-(int)(s[i]);\\n                if(x<0) x+=26;\\n                int m=26*mp[x];\\n                if(x+m>k) return 0;\\n                else{\\n                    mp[x]++;\\n                }\\n            }\\n        }\\n\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010225,
                "title": "c-hash-table-string",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())\\n        return false;\\n        if(s==t)\\n        return true;\\n        if(k==0)\\n        return false;\\n        int n = s.size();\\n        vector<int> diff(n);\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            diff[i] = (t[i]-s[i]+26)%26;\\n            if(m.find(diff[i])!=m.end() && diff[i]!=0)\\n            {\\n                m[diff[i]]+=26;\\n                diff[i] = m[diff[i]];\\n            }\\n            else\\n            m[diff[i]] = diff[i];\\n        }\\n        sort(diff.begin(),diff.end());\\n        int mov = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(diff[i]==0)\\n            continue;\\n            if(mov<diff[i] && diff[i]<=k)\\n            {\\n                mov = diff[i];\\n            }\\n            else if(diff[i]+26>mov && diff[i]+26<=k)\\n            {\\n                mov = diff[i]+26;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())\\n        return false;\\n        if(s==t)\\n        return true;\\n        if(k==0)\\n        return false;\\n        int n = s.size();\\n        vector<int> diff(n);\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            diff[i] = (t[i]-s[i]+26)%26;\\n            if(m.find(diff[i])!=m.end() && diff[i]!=0)\\n            {\\n                m[diff[i]]+=26;\\n                diff[i] = m[diff[i]];\\n            }\\n            else\\n            m[diff[i]] = diff[i];\\n        }\\n        sort(diff.begin(),diff.end());\\n        int mov = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(diff[i]==0)\\n            continue;\\n            if(mov<diff[i] && diff[i]<=k)\\n            {\\n                mov = diff[i];\\n            }\\n            else if(diff[i]+26>mov && diff[i]+26<=k)\\n            {\\n                mov = diff[i]+26;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002892,
                "title": "java-modulo-and-clean-code",
                "content": "# Approach\\n1. The key is to count how many group of modulos you have for the given k.\\n    - EG: 27: [1,2,3...26,27]. All of these % 26 would result [1,2,...1]. Two elements (1 and 27) % 26 = 1. So modulo[1] = 2.\\n2. For given k calculate the groups of modulos\\n3. Traverse s and t and for each index, if the chars are disting, calculate their distance.\\n    - a -> c = 2 ; y -> b = 3. \\n4. For each such distinct pair, deduct 1 from their modulo groups. If the modulo groups goes below 0, it means you do not have enough numbers to cover their modulos. \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(26)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (k == 0) {\\n            return s.equals(t);\\n        } else if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] modulos = getModulos(k);\\n        return canConvert(s, t, modulos);\\n    }\\n\\n    private boolean canConvert(String s, String t, int[] modulos) {\\n        char first, second;\\n        int distance;\\n        for (int i = 0; i < s.length(); i++) {\\n            first = s.charAt(i);\\n            second = t.charAt(i);\\n            if (first != second) {\\n                distance = first < second ? second - first : (26 - first) + second;\\n                if (--modulos[distance] < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int[] getModulos(int k) {\\n        int[] modulos = new int[26];\\n        int div = k / 26;\\n        Arrays.fill(modulos, div);\\n        k = k % 26;\\n        while (k >= 0) {\\n            modulos[k--]++;\\n        }\\n        return modulos;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (k == 0) {\\n            return s.equals(t);\\n        } else if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] modulos = getModulos(k);\\n        return canConvert(s, t, modulos);\\n    }\\n\\n    private boolean canConvert(String s, String t, int[] modulos) {\\n        char first, second;\\n        int distance;\\n        for (int i = 0; i < s.length(); i++) {\\n            first = s.charAt(i);\\n            second = t.charAt(i);\\n            if (first != second) {\\n                distance = first < second ? second - first : (26 - first) + second;\\n                if (--modulos[distance] < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int[] getModulos(int k) {\\n        int[] modulos = new int[26];\\n        int div = k / 26;\\n        Arrays.fill(modulos, div);\\n        k = k % 26;\\n        while (k >= 0) {\\n            modulos[k--]++;\\n        }\\n        return modulos;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999274,
                "title": "c-8-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we simply calculate the shift required for each character of s and and store it in an array of size 26. Then check if those many shift are possible or not within the given value of k.\\n\\nar[i] = x implies that there are x characters in string s that need a shift of i to match the charcters in string t.\\nNow it is given in the question that each shift can be used only once.\\nSo if two charcters need a shift of 1, only one of them will be allowed.\\nThe next charcter will get a shift of 1 + 26 which makes the efective shift to be 1.\\nEg: lets say s = \"aa\" and t = \"cc\"\\nThen ar[2] = 2\\nSo two characters need a net shift of 2. So the possible shifts are 2, 28, 54, .....\\nSince we need only two, so 2 and 28 are enough. Therefore our value of k should be atleast 28 .If not then return false immediately\\n\\n# Complexity\\n- Time complexity:O(s.length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int ar[26] = {0};       \\n        for(int i = 0;i < s.length();i++){\\n            int shift = (t[i] - s[i] + 26) % 26;            \\n            ar[shift]++;\\n        }\\n        for(int i = 1;i <= 25;i++)\\n            if(i + (ar[i] - 1)*26 > k)\\n                return false;\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int ar[26] = {0};       \\n        for(int i = 0;i < s.length();i++){\\n            int shift = (t[i] - s[i] + 26) % 26;            \\n            ar[shift]++;\\n        }\\n        for(int i = 1;i <= 25;i++)\\n            if(i + (ar[i] - 1)*26 > k)\\n                return false;\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956395,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  bool canConvertString(string s, string t, int k) {\\n    if (s.length() != t.length())\\n      return false;\\n\\n    // E.g. s = \"aab\", t = \"bbc\", so shiftCount[1] = 3\\n    // For a -> b, need 1 move\\n    //     a -> b, need 1 + 26 moves\\n    //     b -> c, need 1 + 26 * 2 moves\\n    vector<int> shiftCount(26);\\n\\n    for (int i = 0; i < s.length(); ++i)\\n      ++shiftCount[(t[i] - s[i] + 26) % 26];\\n\\n    for (int shift = 1; shift < 26; ++shift)\\n      if (shift + 26 * (shiftCount[shift] - 1) > k)\\n        return false;\\n\\n    return true;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool canConvertString(string s, string t, int k) {\\n    if (s.length() != t.length())\\n      return false;\\n\\n    // E.g. s = \"aab\", t = \"bbc\", so shiftCount[1] = 3\\n    // For a -> b, need 1 move\\n    //     a -> b, need 1 + 26 moves\\n    //     b -> c, need 1 + 26 * 2 moves\\n    vector<int> shiftCount(26);\\n\\n    for (int i = 0; i < s.length(); ++i)\\n      ++shiftCount[(t[i] - s[i] + 26) % 26];\\n\\n    for (int shift = 1; shift < 26; ++shift)\\n      if (shift + 26 * (shiftCount[shift] - 1) > k)\\n        return false;\\n\\n    return true;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903100,
                "title": "easy-to-understand-javascript-solution-hash-table",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(26)$$\\n\\n# Code\\n```\\nvar canConvertString = function(s, t, k) {\\n    if (s.length !== t.length) return false;\\n    const convertCounts = Array(26).fill(0);\\n\\n    for (let index = 0; index < s.length; index++) {\\n        const diff = (t.charCodeAt(index) - s.charCodeAt(index) + 26) % 26;\\n        \\n        if (!diff) continue;\\n        if (diff + convertCounts[diff] * 26 > k) return false;\\n        convertCounts[diff] += 1;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConvertString = function(s, t, k) {\\n    if (s.length !== t.length) return false;\\n    const convertCounts = Array(26).fill(0);\\n\\n    for (let index = 0; index < s.length; index++) {\\n        const diff = (t.charCodeAt(index) - s.charCodeAt(index) + 26) % 26;\\n        \\n        if (!diff) continue;\\n        if (diff + convertCounts[diff] * 26 > k) return false;\\n        convertCounts[diff] += 1;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3842294,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size()!=t.size()) return false;\\n        int n=s.size();\\n        int div=k/26;\\n        vector<int>temp(26,div);\\n        int rem=k%26;\\n        for (int i=0;i<=rem;i++) temp[i]++;   \\n        for (int i=0;i<n;i++)\\n        {\\n            if (s[i]!=t[i])\\n            {\\n                int diff=(t[i]-s[i]+26)%26;\\n                if (temp[diff]==0) return false;\\n                temp[diff]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size()!=t.size()) return false;\\n        int n=s.size();\\n        int div=k/26;\\n        vector<int>temp(26,div);\\n        int rem=k%26;\\n        for (int i=0;i<=rem;i++) temp[i]++;   \\n        for (int i=0;i<n;i++)\\n        {\\n            if (s[i]!=t[i])\\n            {\\n                int diff=(t[i]-s[i]+26)%26;\\n                if (temp[diff]==0) return false;\\n                temp[diff]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725131,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        vector<int> diffs(26,0);\\n        for(int i=0;i<26;i++){\\n            diffs[i]=i;\\n        }\\n        int n = s.size();\\n        int m = t.size();\\n        if(m!=n) return false;\\n        for(int i=0;i<n;i++){\\n            int diff = ((int)t[i] - (int)s[i]);\\n            if(diff==0) continue;\\n            else if(diff<0) diff+=26;\\n            if(diffs[diff]>k) return false;\\n            diffs[diff]+=26;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        vector<int> diffs(26,0);\\n        for(int i=0;i<26;i++){\\n            diffs[i]=i;\\n        }\\n        int n = s.size();\\n        int m = t.size();\\n        if(m!=n) return false;\\n        for(int i=0;i<n;i++){\\n            int diff = ((int)t[i] - (int)s[i]);\\n            if(diff==0) continue;\\n            else if(diff<0) diff+=26;\\n            if(diffs[diff]>k) return false;\\n            diffs[diff]+=26;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663184,
                "title": "python-check-max-counter-of-diff-o-n",
                "content": "```\\n\"\"\"\\nHere we just count of same diff, and then\\ncheck if the max difference*26 larger than k.\\n\\nBecause of each new +1 of same diff increases\\nour move by 26.\\n\\nTC: O(N)\\nSC: O(1)\\n\"\"\"\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        count = Counter()\\n        for a, b in zip(s, t):\\n            if a != b:\\n                count[(ord(b) - ord(a)) % 26] += 1\\n            \\n        m = 0\\n        for d, v in count.items():\\n            m = max(m, d + (v - 1)*26)\\n            if m > k:\\n                return False\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nHere we just count of same diff, and then\\ncheck if the max difference*26 larger than k.\\n\\nBecause of each new +1 of same diff increases\\nour move by 26.\\n\\nTC: O(N)\\nSC: O(1)\\n\"\"\"\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        count = Counter()\\n        for a, b in zip(s, t):\\n            if a != b:\\n                count[(ord(b) - ord(a)) % 26] += 1\\n            \\n        m = 0\\n        for d, v in count.items():\\n            m = max(m, d + (v - 1)*26)\\n            if m > k:\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598436,
                "title": "small-c-solution-100-runtime-and-100-memory",
                "content": "# Code\\n```\\n#pragma GCC optimize (\"-O3\", \"-march=native\")\\nbool canConvertString(char *s, char *t, int k) {\\n    int needed_shifts[26] = {};\\n    for (; *s && *t; ++s, ++t) ++needed_shifts[(*t - *s + 26) % 26];\\n    if (*s || *t) return false;\\n    for (int i = 1; i < 26; ++i) {\\n        if (i + (needed_shifts[i] - 1) * 26 > k) return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#pragma GCC optimize (\"-O3\", \"-march=native\")\\nbool canConvertString(char *s, char *t, int k) {\\n    int needed_shifts[26] = {};\\n    for (; *s && *t; ++s, ++t) ++needed_shifts[(*t - *s + 26) % 26];\\n    if (*s || *t) return false;\\n    for (int i = 1; i < 26; ++i) {\\n        if (i + (needed_shifts[i] - 1) * 26 > k) return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3552972,
                "title": "beats-100-must-see-approach-t-c-o-n-and-o-26-or-constant-space",
                "content": "# Intuition\\nto make a freq array and then look for value of k\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- O(n) -->\\n\\n- Space complexity:  O(26) \\n<!-- O(26) or basically it is constant -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n       <!-- for fast I/O -->\\n        std::ios_base::sync_with_stdio(false);\\n        std::cout.tie(nullptr);\\n        std::cin.tie(nullptr);\\n\\n        int n = s.length(), m = t.length();\\n        <!-- edge case -->\\n        if(n!=m) return false;\\n        vector<int > mp(27,0);\\n        <!-- if we got diff as 1 (increase freq of 1 at this point)then if we get another 1 then we look for k=27 i.e diff(1)+mp[diff](1)  then we take action according to value of k--> \\n\\n        for(int i =0;i<n;i++){\\n            int diff= (t[i]-s[i]+26)%26;\\n            if(diff!=0){\\n                if(diff+mp[diff]*26<=k){\\n                    mp[diff]++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n       <!-- for fast I/O -->\\n        std::ios_base::sync_with_stdio(false);\\n        std::cout.tie(nullptr);\\n        std::cin.tie(nullptr);\\n\\n        int n = s.length(), m = t.length();\\n        <!-- edge case -->\\n        if(n!=m) return false;\\n        vector<int > mp(27,0);\\n        <!-- if we got diff as 1 (increase freq of 1 at this point)then if we get another 1 then we look for k=27 i.e diff(1)+mp[diff](1)  then we take action according to value of k--> \\n\\n        for(int i =0;i<n;i++){\\n            int diff= (t[i]-s[i]+26)%26;\\n            if(diff!=0){\\n                if(diff+mp[diff]*26<=k){\\n                    mp[diff]++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3549991,
                "title": "find-the-residue-of-modulo",
                "content": "# Approach\\nif two strings have different length, can\\'t convert s to t for all k.\\nFind the modulo number of shifts by i and its upper bound for i = 1,2,...,25, meaning that do nothing for the residue\\'s. \\n\\n# Complexity\\n- Time complexity: O(n), n:length of s\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n            \\n        k += 1\\n        L = [0] * 26\\n        T = [k // 26] * 26\\n        k %= 26\\n\\n        for i in range(len(s)):\\n            L[ord(t[i])-ord(s[i])] += 1\\n        \\n        for i in range(k):\\n            T[i] += 1\\n\\n        for i in range(1, 26):\\n            if L[i] > T[i]:\\n                return False\\n        \\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n            \\n        k += 1\\n        L = [0] * 26\\n        T = [k // 26] * 26\\n        k %= 26\\n\\n        for i in range(len(s)):\\n            L[ord(t[i])-ord(s[i])] += 1\\n        \\n        for i in range(k):\\n            T[i] += 1\\n\\n        for i in range(1, 26):\\n            if L[i] > T[i]:\\n                return False\\n        \\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534281,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n  pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\\n    if s.len() != t.len() {\\n      return false\\n    }\\n    let s = s.chars().into_iter().map(|v| v as usize - \\'a\\' as usize).collect::<Vec<usize>>();\\n    let t = t.chars().into_iter().map(|v| v as usize - \\'a\\' as usize).collect::<Vec<usize>>();\\n    let n = s.len();\\n    let k = k as usize;\\n    let mut memo = (0..26).into_iter().collect::<Vec<usize>>();\\n\\n    for i in 0..n {\\n      if s[i] < t[i] {\\n        let ti = t[i] - s[i];\\n        if memo[ti] > k {\\n          return false\\n        }\\n        memo[ti] += 26;\\n      } else if s[i] > t[i] {\\n        let ti = 26 - s[i] + t[i];\\n        if memo[ti] > k {\\n          return false\\n        }\\n        memo[ti] += 26;\\n      }\\n    }\\n    true\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\\n    if s.len() != t.len() {\\n      return false\\n    }\\n    let s = s.chars().into_iter().map(|v| v as usize - \\'a\\' as usize).collect::<Vec<usize>>();\\n    let t = t.chars().into_iter().map(|v| v as usize - \\'a\\' as usize).collect::<Vec<usize>>();\\n    let n = s.len();\\n    let k = k as usize;\\n    let mut memo = (0..26).into_iter().collect::<Vec<usize>>();\\n\\n    for i in 0..n {\\n      if s[i] < t[i] {\\n        let ti = t[i] - s[i];\\n        if memo[ti] > k {\\n          return false\\n        }\\n        memo[ti] += 26;\\n      } else if s[i] > t[i] {\\n        let ti = 26 - s[i] + t[i];\\n        if memo[ti] > k {\\n          return false\\n        }\\n        memo[ti] += 26;\\n      }\\n    }\\n    true\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524005,
                "title": "simple-c-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n     int l = s.length();\\n     int qwe = t.length();\\n\\n     if(l!=qwe){\\n         return 0;\\n     }\\n\\n    vector<int> alpha(27);\\n    vector<int> match(27);\\n    match[0] = INT_MAX;\\n    int n = k/26;\\n    int r = k%26;\\n\\n\\n    for(int i = 0; i<=26; i++){\\n         alpha[i] = 0;\\n     } \\n\\n     for(int i = 0; i<l; i++){\\n         if(t[i] - s[i] >= 0){\\n             int k = t[i] - s[i];\\n             alpha[k]++;\\n         }\\n         else{\\n             int k = t[i] - s[i] + 26;\\n             alpha[k]++;\\n         }\\n     }\\n\\n     \\n\\n     \\n     for(int i = 1; i<=26; i++){\\n         if(r>0){\\n             match[i] = n+1;\\n             r--;\\n         }\\n         else{\\n             match[i] = n;\\n         }\\n     }\\n\\n     for(int i = 1; i<=26; i++){\\n         if(match[i] - alpha[i]<0){\\n             return false;\\n         }\\n     }\\n     return true;\\n     \\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n     int l = s.length();\\n     int qwe = t.length();\\n\\n     if(l!=qwe){\\n         return 0;\\n     }\\n\\n    vector<int> alpha(27);\\n    vector<int> match(27);\\n    match[0] = INT_MAX;\\n    int n = k/26;\\n    int r = k%26;\\n\\n\\n    for(int i = 0; i<=26; i++){\\n         alpha[i] = 0;\\n     } \\n\\n     for(int i = 0; i<l; i++){\\n         if(t[i] - s[i] >= 0){\\n             int k = t[i] - s[i];\\n             alpha[k]++;\\n         }\\n         else{\\n             int k = t[i] - s[i] + 26;\\n             alpha[k]++;\\n         }\\n     }\\n\\n     \\n\\n     \\n     for(int i = 1; i<=26; i++){\\n         if(r>0){\\n             match[i] = n+1;\\n             r--;\\n         }\\n         else{\\n             match[i] = n;\\n         }\\n     }\\n\\n     for(int i = 1; i<=26; i++){\\n         if(match[i] - alpha[i]<0){\\n             return false;\\n         }\\n     }\\n     return true;\\n     \\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438162,
                "title": "fast-and-simple-solution-with-explanation-c",
                "content": "# Intuition\\nWe can convert *s* to *t* only if for every position *i* (*0 <= i < s.size()*) where *s[i] != t[i]* we can find a unique number *1 <= n <= k* such that *s[i] + (n % 26)  == t[i]*. (26 is the number of characters in english alphabet).\\n\\n# Approach\\nFirst we check sizes of the two strings. When they differ, we return false immidiately. Next, we iterate over the strings and count only chars that do differ. When difference is negative, we add 26 to it.\\n\\nIn the last step, we iterate over the summery map and check every position, where difference greater than 0. For example, when we have a difference 2 in 3 positions, we have to use numbers 2, 28 and 54 to close gaps in all three positions (2, 2 + 1 x 26, 2 + 2 x 26). When the maximal number do not exceeds k, we return true, otherwise false. \\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\tconst int alphabet_size = 26;\\n\\npublic:\\n\\tbool canConvertString(string s, string t, int k) {\\n\\t\\tif (s.size() != t.size()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tvector<int> movesMap(127, 0);\\n\\t\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\t\\tint diff = t[i] - s[i];\\n\\t\\t\\tif (diff > 0) {\\n\\t\\t\\t\\tmovesMap[diff]++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (diff < 0) {\\n\\t\\t\\t\\tmovesMap[alphabet_size + diff]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (movesMap.empty()) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < movesMap.size(); i++) {\\n\\t\\t\\tif ((movesMap[i] > 0) && (i + (movesMap[i] - 1) * alphabet_size > k)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\tconst int alphabet_size = 26;\\n\\npublic:\\n\\tbool canConvertString(string s, string t, int k) {\\n\\t\\tif (s.size() != t.size()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tvector<int> movesMap(127, 0);\\n\\t\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\t\\tint diff = t[i] - s[i];\\n\\t\\t\\tif (diff > 0) {\\n\\t\\t\\t\\tmovesMap[diff]++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (diff < 0) {\\n\\t\\t\\t\\tmovesMap[alphabet_size + diff]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (movesMap.empty()) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < movesMap.size(); i++) {\\n\\t\\t\\tif ((movesMap[i] > 0) && (i + (movesMap[i] - 1) * alphabet_size > k)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314788,
                "title": "and-c",
                "content": "C solution:\\n```\\nbool canConvertString(char * s, char * t, int k){\\n    if(strlen(s) != strlen(t))\\n        return false ;\\n    int n = strlen(s) ;\\n    int* count = calloc(26, sizeof(int)) ;\\n    for(int i = 0; i < n; i++){\\n        int d = (t[i] - s[i] + 26) % 26 ;\\n        count[d]++ ;\\n    }\\n    bool ret = true ;\\n    for(int i = 1; i < 26; i++){\\n        if(count[i] > 0){\\n            int max = i + (count[i]-1)*26 ;\\n            if(max > k){\\n                ret = false ;\\n                break ;\\n            }\\n        }\\n    }\\n    free(count) ;\\n    return ret ;\\n}\\n```\\n\\nC++ solution \\uFF1A\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size())\\n            return false ;\\n        int n = s.size() ;\\n        vector<int>count(26) ;\\n        for(int i = 0; i < n; i++){\\n            int d = (t[i] - s[i] + 26) % 26 ;\\n            count[d]++ ;\\n        }\\n        for(int i = 1 ; i < 26; i++){\\n            if(count[i] > 0){\\n                int max = i + 26 *(count[i] -1) ;\\n                if(max > k)\\n                    return false ;\\n            }\\n        }\\n        return true ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(char * s, char * t, int k){\\n    if(strlen(s) != strlen(t))\\n        return false ;\\n    int n = strlen(s) ;\\n    int* count = calloc(26, sizeof(int)) ;\\n    for(int i = 0; i < n; i++){\\n        int d = (t[i] - s[i] + 26) % 26 ;\\n        count[d]++ ;\\n    }\\n    bool ret = true ;\\n    for(int i = 1; i < 26; i++){\\n        if(count[i] > 0){\\n            int max = i + (count[i]-1)*26 ;\\n            if(max > k){\\n                ret = false ;\\n                break ;\\n            }\\n        }\\n    }\\n    free(count) ;\\n    return ret ;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size())\\n            return false ;\\n        int n = s.size() ;\\n        vector<int>count(26) ;\\n        for(int i = 0; i < n; i++){\\n            int d = (t[i] - s[i] + 26) % 26 ;\\n            count[d]++ ;\\n        }\\n        for(int i = 1 ; i < 26; i++){\\n            if(count[i] > 0){\\n                int max = i + 26 *(count[i] -1) ;\\n                if(max > k)\\n                    return false ;\\n            }\\n        }\\n        return true ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283787,
                "title": "short-and-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int,int>mp;\\n        if(s.size()!=t.size()) return false;\\n        for(int i=0;i<s.size();i++){\\n           int x=(t[i]-s[i]+26)%26;\\n           if(x!=0){\\n               int v=mp[x];\\n               int ve=x+26*v;\\n               if(ve<=k){\\n                   mp[x]++;\\n               }\\n               else{\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int,int>mp;\\n        if(s.size()!=t.size()) return false;\\n        for(int i=0;i<s.size();i++){\\n           int x=(t[i]-s[i]+26)%26;\\n           if(x!=0){\\n               int v=mp[x];\\n               int ve=x+26*v;\\n               if(ve<=k){\\n                   mp[x]++;\\n               }\\n               else{\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270070,
                "title": "o-n-constant-space-solution-in-c",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(26) ~ constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        vector<int> tracker(26, 0);\\n        for(int i=0;i<s.length();i++){\\n            int diff;\\n            if(t[i]>s[i]){\\n                diff = (t[i]-\\'a\\')-(s[i]-\\'a\\');\\n            }\\n            else{\\n                diff = (\\'z\\'-s[i]) + (t[i]-\\'a\\') + 1;\\n            }\\n            if(diff==0 || diff==26){\\n                continue;\\n            }\\n            if(diff>k){\\n                return false;\\n            }\\n            if(tracker[diff]!=0){\\n                tracker[diff]+=26;\\n                if(tracker[diff]>k){\\n                    return false;\\n                }\\n            }\\n            else{\\n                tracker[diff] += diff;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        vector<int> tracker(26, 0);\\n        for(int i=0;i<s.length();i++){\\n            int diff;\\n            if(t[i]>s[i]){\\n                diff = (t[i]-\\'a\\')-(s[i]-\\'a\\');\\n            }\\n            else{\\n                diff = (\\'z\\'-s[i]) + (t[i]-\\'a\\') + 1;\\n            }\\n            if(diff==0 || diff==26){\\n                continue;\\n            }\\n            if(diff>k){\\n                return false;\\n            }\\n            if(tracker[diff]!=0){\\n                tracker[diff]+=26;\\n                if(tracker[diff]>k){\\n                    return false;\\n                }\\n            }\\n            else{\\n                tracker[diff] += diff;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269343,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        int[] count = new int[26];\\n        for(int i =0; i< s.length(); i++){\\n            int diff = (int)(t.charAt(i) - s.charAt(i));\\n            if(diff < 0 ) diff = diff + 26;\\n\\n            if(diff > 0 && diff + count[diff]*26 > k ) return false;\\n            count[diff]++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        int[] count = new int[26];\\n        for(int i =0; i< s.length(); i++){\\n            int diff = (int)(t.charAt(i) - s.charAt(i));\\n            if(diff < 0 ) diff = diff + 26;\\n\\n            if(diff > 0 && diff + count[diff]*26 > k ) return false;\\n            count[diff]++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266162,
                "title": "c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n       if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n       if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265958,
                "title": "c-o-n-o-1-frequency-array",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int sl = s.length(), tl = t.length();\\n        if(sl != tl) return false;\\n\\n        vector<int> m(27, k/26);\\n        for(int i = 1; i < 27; i++) {\\n            if(k%26 >= i) m[i]++;\\n        }\\n\\n        for(int i = 0; i < sl; i++) {\\n            if(s[i] == t[i]) continue;\\n            int diff = t[i]-s[i];\\n            if(diff < 0) diff += 26;\\n            if(diff > k || m[diff] <= 0) return false;\\n            m[diff]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int sl = s.length(), tl = t.length();\\n        if(sl != tl) return false;\\n\\n        vector<int> m(27, k/26);\\n        for(int i = 1; i < 27; i++) {\\n            if(k%26 >= i) m[i]++;\\n        }\\n\\n        for(int i = 0; i < sl; i++) {\\n            if(s[i] == t[i]) continue;\\n            int diff = t[i]-s[i];\\n            if(diff < 0) diff += 26;\\n            if(diff > k || m[diff] <= 0) return false;\\n            m[diff]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262977,
                "title": "simple-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince for every move we can go for i steps forward, we need to track for steps..\\nAlso every j will be unique as we are traversing the string..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain a map where we store the i values along with the no of times we used it.\\nIt we would like to convert a to c , we need to look for 2nd move, suppose for another j again we get a to c, then we can\\'t use 2nd move but we can use 2+26 the move. again if we get same conversion use 2+26*2... so on..\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)  as map keys are from 1 to 26 only..\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for map.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        map<int,int> mp;\\n        for(int j=0;j<s.length();i++){\\n            char c1 = s[j];\\n            char c2 = t[j];\\n            int val = t[j]-s[j];\\n            if(val!=0){\\n                if(val<0){\\n                    val+=26;\\n                }\\n                //cout<<\"Val is \"<<val+mp[val]*26<<\"for converting \"<<s[i]<<\" to \"<<t[i]<<endl;\\n                if(val+mp[val]*26<=k){\\n                    mp[val]++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        map<int,int> mp;\\n        for(int j=0;j<s.length();i++){\\n            char c1 = s[j];\\n            char c2 = t[j];\\n            int val = t[j]-s[j];\\n            if(val!=0){\\n                if(val<0){\\n                    val+=26;\\n                }\\n                //cout<<\"Val is \"<<val+mp[val]*26<<\"for converting \"<<s[i]<<\" to \"<<t[i]<<endl;\\n                if(val+mp[val]*26<=k){\\n                    mp[val]++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3262137,
                "title": "258-ms",
                "content": "```ruby\\ndef can_convert_string s, t, k\\n    return false if s.size != t.size\\n    s, t = *[s, t].map!(&:bytes)\\n    h = (0...s.size).map do\\n        x, y = s[_1], t[_1]\\n        y + (y < x ? 26 : 0) - x \\n    end .tally\\n    h.delete 0\\n    h.empty? || begin\\n        x, y = *h.max_by { [_2, _1] }\\n        (y - 1) * 26 + x <= k\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef can_convert_string s, t, k\\n    return false if s.size != t.size\\n    s, t = *[s, t].map!(&:bytes)\\n    h = (0...s.size).map do\\n        x, y = s[_1], t[_1]\\n        y + (y < x ? 26 : 0) - x \\n    end .tally\\n    h.delete 0\\n    h.empty? || begin\\n        x, y = *h.max_by { [_2, _1] }\\n        (y - 1) * 26 + x <= k\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3223328,
                "title": "java-using-modulo-operation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        int[] arr=new int[27];\\n        int div=k/26,rem=k%26;\\n        for (int i=1;i<arr.length;i++){\\n            arr[i]=div;\\n        }\\n        for (int i=1;i<=rem;i++){\\n            arr[i]++;\\n        }\\n        for (int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=t.charAt(i)){\\n                int val=(t.charAt(i)-s.charAt(i)+26)%26;\\n                if(arr[val]>0){\\n                    arr[val]--;\\n                }else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n     public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        int[] arr=new int[27];\\n        int div=k/26,rem=k%26;\\n        for (int i=1;i<arr.length;i++){\\n            arr[i]=div;\\n        }\\n        for (int i=1;i<=rem;i++){\\n            arr[i]++;\\n        }\\n        for (int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=t.charAt(i)){\\n                int val=(t.charAt(i)-s.charAt(i)+26)%26;\\n                if(arr[val]>0){\\n                    arr[val]--;\\n                }else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169455,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    // calculates distance between char a and b through shifting right\\n    int dist(char a, char b){\\n        int moves = 0;\\n        while (a != b){\\n            ++moves;\\n            if (a == \\'z\\') a = \\'a\\';\\n            else ++a;\\n        }\\n        return moves;\\n    }\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) return false;\\n        unordered_map<int,int> m;\\n        int remainder = k % 26;\\n        for (int i = 1; i <= 26; ++i){\\n            m[i] += k / 26;\\n            if (remainder-- > 0) m[i] += 1;\\n        }\\n        for (int i = 0; i < s.size(); ++i){\\n            if (s[i] != t[i]){\\n                int d = dist(s[i], t[i]);\\n                if (--m[d] == -1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // calculates distance between char a and b through shifting right\\n    int dist(char a, char b){\\n        int moves = 0;\\n        while (a != b){\\n            ++moves;\\n            if (a == \\'z\\') a = \\'a\\';\\n            else ++a;\\n        }\\n        return moves;\\n    }\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) return false;\\n        unordered_map<int,int> m;\\n        int remainder = k % 26;\\n        for (int i = 1; i <= 26; ++i){\\n            m[i] += k / 26;\\n            if (remainder-- > 0) m[i] += 1;\\n        }\\n        for (int i = 0; i < s.size(); ++i){\\n            if (s[i] != t[i]){\\n                int d = dist(s[i], t[i]);\\n                if (--m[d] == -1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167267,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\\n        use std::collections::HashMap;\\n        if s.len() != t.len() {\\n            return false;\\n        }\\n        let diffs = s.bytes().zip(t.bytes()).map(|(x, y)| (y as i32 - x as i32 + 26) % 26);\\n        let diffs = diffs.into_iter().filter(|&x| x != 0);\\n        let mut map: HashMap<i32, i32> = HashMap::new();\\n        for diff in diffs {\\n            let multiplier = *map.entry(diff).or_insert(0);\\n            if diff + (26 * multiplier) > k {\\n                return false;\\n            }\\n            *map.entry(diff).or_insert(0) += 1;\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\\n        use std::collections::HashMap;\\n        if s.len() != t.len() {\\n            return false;\\n        }\\n        let diffs = s.bytes().zip(t.bytes()).map(|(x, y)| (y as i32 - x as i32 + 26) % 26);\\n        let diffs = diffs.into_iter().filter(|&x| x != 0);\\n        let mut map: HashMap<i32, i32> = HashMap::new();\\n        for diff in diffs {\\n            let multiplier = *map.entry(diff).or_insert(0);\\n            if diff + (26 * multiplier) > k {\\n                return false;\\n            }\\n            *map.entry(diff).or_insert(0) += 1;\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164248,
                "title": "c-o-n-easy-solution-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length())\\n            return 0;\\n        vector<int> vacant(26, 0);\\n        for(int i=0;i<26;i++)\\n            vacant[i] = i;\\n        int x, p;\\n        for(int i=0;i<s.length();i++){\\n            if(t[i] - \\'a\\'- (s[i] - \\'a\\') != 0)\\n            {\\n             x = t[i] - \\'a\\'- (s[i] - \\'a\\');\\n            if(x < 0)\\n                x += 26;\\n             p = vacant[x%26];\\n            vacant[x%26] += 26;\\n            if(p > k)\\n                return 0;         \\n            s[i] = t[i];\\n            }\\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length())\\n            return 0;\\n        vector<int> vacant(26, 0);\\n        for(int i=0;i<26;i++)\\n            vacant[i] = i;\\n        int x, p;\\n        for(int i=0;i<s.length();i++){\\n            if(t[i] - \\'a\\'- (s[i] - \\'a\\') != 0)\\n            {\\n             x = t[i] - \\'a\\'- (s[i] - \\'a\\');\\n            if(x < 0)\\n                x += 26;\\n             p = vacant[x%26];\\n            vacant[x%26] += 26;\\n            if(p > k)\\n                return 0;         \\n            s[i] = t[i];\\n            }\\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035460,
                "title": "hashing-o-n",
                "content": "used hashmap to store previous min value of difference of two alphabets in both s and t respectively \\nfirst i was using hashset which was not effeceint because that checks everytime if the number is present or not \\n\\nso i used hashmap and everything solved \\n\\n```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()) return false ; \\n        HashMap<Long,Long> hm = new HashMap<>();\\n        for(int i = 0 ; i < s.length() ; i++){\\n            Long a = (long)(t.charAt(i)-\\'a\\')-(long)(s.charAt(i)-\\'a\\');\\n            if(a>0) {\\n                if(hm.containsKey(a)){\\n                    if((hm.get(a)+26)>k) return false ; \\n                    else hm.put(a,hm.get(a)+26);\\n                }\\n                else {\\n                    if(a>k) return false ; \\n                    hm.put(a,a);\\n                }\\n            }\\n            else if(a<0){\\n                a += 26 ; \\n                if(hm.containsKey(a)){\\n                    if((hm.get(a)+26) > k) return false ; \\n                    else hm.put(a,hm.get(a)+26);\\n                }\\n                else {\\n                    if(a>k) return false ; \\n                    hm.put(a,a);\\n                }\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()) return false ; \\n        HashMap<Long,Long> hm = new HashMap<>();\\n        for(int i = 0 ; i < s.length() ; i++){\\n            Long a = (long)(t.charAt(i)-\\'a\\')-(long)(s.charAt(i)-\\'a\\');\\n            if(a>0) {\\n                if(hm.containsKey(a)){\\n                    if((hm.get(a)+26)>k) return false ; \\n                    else hm.put(a,hm.get(a)+26);\\n                }\\n                else {\\n                    if(a>k) return false ; \\n                    hm.put(a,a);\\n                }\\n            }\\n            else if(a<0){\\n                a += 26 ; \\n                if(hm.containsKey(a)){\\n                    if((hm.get(a)+26) > k) return false ; \\n                    else hm.put(a,hm.get(a)+26);\\n                }\\n                else {\\n                    if(a>k) return false ; \\n                    hm.put(a,a);\\n                }\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928266,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()) return false;\\n        int cnt[26]{}, round = k/26, remainer = k%26;\\n        for(int i = 0; i < s.size(); i++) cnt[(t[i]-s[i]+26)%26]++;\\n        for(int i = 1; i <= 25; i++) if(round + (i <= remainer ? 1 : 0) < cnt[i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()) return false;\\n        int cnt[26]{}, round = k/26, remainer = k%26;\\n        for(int i = 0; i < s.size(); i++) cnt[(t[i]-s[i]+26)%26]++;\\n        for(int i = 1; i <= 25; i++) if(round + (i <= remainer ? 1 : 0) < cnt[i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927948,
                "title": "c-simple-solution-worst-question",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        int end= s.size()-1, start = 0;\\n        map<int,int> mp;\\n        while(start<=end){\\n            int diff = (t[start]-s[start]+26)%26; //for negative difference\\n            if(diff!=0){\\n                int mul = mp[diff];\\n                long long val = diff+ (26*mul);\\n                if(val<=k) mp[diff]++; \\n                else return false;\\n            }\\n            start++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        int end= s.size()-1, start = 0;\\n        map<int,int> mp;\\n        while(start<=end){\\n            int diff = (t[start]-s[start]+26)%26; //for negative difference\\n            if(diff!=0){\\n                int mul = mp[diff];\\n                long long val = diff+ (26*mul);\\n                if(val<=k) mp[diff]++; \\n                else return false;\\n            }\\n            start++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842168,
                "title": "python-hashmap-faster-than-100",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:    \\n        m, n = len(s), len(t)\\n        if m != n: return False\\n        cnt1 = Counter((ord(t[i]) - ord(s[i])) % 26 for i in range(m))\\n        del(cnt1[0])\\n        q, r = divmod(k, 26)\\n        cnt2 = Counter({i: q for i in range(1, 26)}) + Counter({i: 1 for i in range(1, r + 1)})\\n        return cnt1 <= cnt2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:    \\n        m, n = len(s), len(t)\\n        if m != n: return False\\n        cnt1 = Counter((ord(t[i]) - ord(s[i])) % 26 for i in range(m))\\n        del(cnt1[0])\\n        q, r = divmod(k, 26)\\n        cnt2 = Counter({i: q for i in range(1, 26)}) + Counter({i: 1 for i in range(1, r + 1)})\\n        return cnt1 <= cnt2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683473,
                "title": "c-count-o-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$ -> `n` is the length os string `s`.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool canConvertString(const string& s, const string& t, int k) {\\n        const int n = size(s);\\n        if (n != size(t))\\n            return false;\\n        array<int, 26> count{};\\n        for (int i = 0; i < n; ++i)\\n            if (int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n                shift && shift + count[shift]++ * 26 > k)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool canConvertString(const string& s, const string& t, int k) {\\n        const int n = size(s);\\n        if (n != size(t))\\n            return false;\\n        array<int, 26> count{};\\n        for (int i = 0; i < n; ++i)\\n            if (int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n                shift && shift + count[shift]++ * 26 > k)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628773,
                "title": "c-o-n-simple",
                "content": "I found that many solutions check the possibility at the end of every round of the loop, but I do it later instead.\\nI wonder which one would be faster.\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()){\\n            return false;\\n        }\\n        const int n = s.size();\\n        const int M = 26;\\n        int count[M];\\n        memset(count, 0, sizeof(count));\\n        for(int i = 0; i < n; ++i){\\n            count[t[i] - s[i] + (t[i] < s[i] ? M : 0)]++;\\n        }\\n        for(int i = 1; i < M; ++i){\\n            if((count[i] - 1) * M + i > k){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()){\\n            return false;\\n        }\\n        const int n = s.size();\\n        const int M = 26;\\n        int count[M];\\n        memset(count, 0, sizeof(count));\\n        for(int i = 0; i < n; ++i){\\n            count[t[i] - s[i] + (t[i] < s[i] ? M : 0)]++;\\n        }\\n        for(int i = 1; i < M; ++i){\\n            if((count[i] - 1) * M + i > k){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593356,
                "title": "can-convert-string-in-k-moves",
                "content": "bool canConvertString(string s, string t, int k) {\\n          if(s.size()!=t.size())\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n       for(int i=0;i<s.size();i++)\\n      {\\n           if(s[i]==t[i])\\n           {\\n               continue;\\n           }\\n           if(t[i]-s[i]>k)\\n           {\\n               return false;\\n           }\\n           if(t[i]-s[i]<0){\\n           if(t[i]-s[i]+26>k)\\n           {\\n               return false;\\n           }\\n           }\\n           if(t[i]-s[i]>0)\\n           mp[t[i]-s[i]]++;\\n           if(t[i]-s[i]<0)\\n           mp[t[i]-s[i]+26]++;\\n           \\n    \\n       }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(t[i]-s[i]>0)\\n            {\\n                if(mp[t[i]-s[i]]>1)\\n                {\\n                    if(26*(mp[t[i]-s[i]]-1)+t[i]-s[i]>k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n                \\n            }\\n            if(t[i]-s[i]<0)\\n            {\\n                 if(mp[t[i]-s[i]+26]>1)\\n                {\\n                    if(26+26*(mp[t[i]-s[i]+26]-1)+t[i]-s[i]>k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;",
                "solutionTags": [],
                "code": "bool canConvertString(string s, string t, int k) {\\n          if(s.size()!=t.size())\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n       for(int i=0;i<s.size();i++)\\n      {\\n           if(s[i]==t[i])\\n           {\\n               continue;\\n           }\\n           if(t[i]-s[i]>k)\\n           {\\n               return false;\\n           }\\n           if(t[i]-s[i]<0){\\n           if(t[i]-s[i]+26>k)\\n           {\\n               return false;\\n           }\\n           }\\n           if(t[i]-s[i]>0)\\n           mp[t[i]-s[i]]++;\\n           if(t[i]-s[i]<0)\\n           mp[t[i]-s[i]+26]++;\\n           \\n    \\n       }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(t[i]-s[i]>0)\\n            {\\n                if(mp[t[i]-s[i]]>1)\\n                {\\n                    if(26*(mp[t[i]-s[i]]-1)+t[i]-s[i]>k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n                \\n            }\\n            if(t[i]-s[i]<0)\\n            {\\n                 if(mp[t[i]-s[i]+26]>1)\\n                {\\n                    if(26+26*(mp[t[i]-s[i]+26]-1)+t[i]-s[i]>k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;",
                "codeTag": "Unknown"
            },
            {
                "id": 2542449,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int len1 = s.length();\\n        int len2 = t.length();\\n        if (len1 != len2) {\\n            return false;\\n        }\\n        if (s.equals(t)) {\\n            return true;\\n        }\\n        int[] freq = new int[26];\\n        int multiple = k / 26;\\n        for (int i = 0; i < 26; i++) {\\n            freq[i] = multiple;\\n        }\\n        int rem = k % 26;\\n        for (int i = 1; i <= rem; i++) {\\n            freq[i]++;\\n        }\\n        int movesRemaining = k;\\n        for (int i = 0; i < len1; i++) {\\n            char ch1 = s.charAt(i);\\n            char ch2 = t.charAt(i);\\n            if (ch1 == ch2) {\\n                movesRemaining--;\\n                continue;\\n            }\\n            int diff = (ch2 - ch1 + 26) % 26;\\n            if (freq[diff] > 0) {\\n                freq[diff]--;\\n                movesRemaining--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return movesRemaining >= 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int len1 = s.length();\\n        int len2 = t.length();\\n        if (len1 != len2) {\\n            return false;\\n        }\\n        if (s.equals(t)) {\\n            return true;\\n        }\\n        int[] freq = new int[26];\\n        int multiple = k / 26;\\n        for (int i = 0; i < 26; i++) {\\n            freq[i] = multiple;\\n        }\\n        int rem = k % 26;\\n        for (int i = 1; i <= rem; i++) {\\n            freq[i]++;\\n        }\\n        int movesRemaining = k;\\n        for (int i = 0; i < len1; i++) {\\n            char ch1 = s.charAt(i);\\n            char ch2 = t.charAt(i);\\n            if (ch1 == ch2) {\\n                movesRemaining--;\\n                continue;\\n            }\\n            int diff = (ch2 - ch1 + 26) % 26;\\n            if (freq[diff] > 0) {\\n                freq[diff]--;\\n                movesRemaining--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return movesRemaining >= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467091,
                "title": "an-easy-o-26-space-solution-learn-new-tricks",
                "content": "class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int ns=s.length(), nt=t.length();\\n        \\n        if(ns!=nt) \\n            return false;\\n        \\n        unordered_map<int,int> un;\\n        int num = k/26, rem=k%26;\\n        \\n        for(int i=1;i<=26;i++) {\\n            un[i]+=num;\\n            if(rem>=i)\\n                un[i]++;\\n        }\\n        \\n        for(int i=0;i<ns;i++) {\\n            int diff = 0;\\n            if(s[i] > t[i]) {\\n                diff = 26+(t[i]-s[i]);\\n            }\\n            else if(s[i] < t[i]) {\\n                diff = t[i]-s[i];\\n            }\\n            if(diff!=0) {\\n                if(un[diff]>0) un[diff]--;\\n                else return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int ns=s.length(), nt=t.length();\\n        \\n        if(ns!=nt) \\n            return false;\\n        \\n        unordered_map<int,int> un;\\n        int num = k/26, rem=k%26;\\n        \\n        for(int i=1;i<=26;i++) {\\n            un[i]+=num;\\n            if(rem>=i)\\n                un[i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2464132,
                "title": "crisp-n-clear-o-n-javascript-runtime-100-00-meaningful-vars",
                "content": "Runtime: 85 ms, faster than 100.00% of JavaScript online submissions for Can Convert String in K Moves.\\nMemory Usage: 47.5 MB, less than 57.14% of JavaScript online submissions for Can Convert String in K Moves.\\n\\n```\\nvar canConvertString = function (str = \\'\\', target = \\'\\', k) {\\n  if (str.length !== target.length) {\\n    return false;\\n  }\\n  const config = {};\\n  for (let index = 0; index < str.length; index++) {\\n    const diff = target.charCodeAt(index) - str.charCodeAt(index);\\n\\n    if (diff === 0) {\\n      continue;\\n    }\\n    if (diff > k) {\\n      return false;\\n    }\\n    if (diff < 0) {\\n      const temp = 26 + diff;\\n      if (temp > k) {\\n        return false;\\n      }\\n      if (!config[temp]) {\\n        config[temp] = 0;\\n      }\\n      config[temp] += 1;\\n    } else {\\n      if (!config[diff]) {\\n        config[diff] = 0;\\n      }\\n      config[diff] += 1;\\n    }\\n  }\\n  for (const key in config) {\\n    if (config[key] > 1) {\\n      const temp = (config[key] - 1) * 26 + Number(key);\\n      if (k < temp) {\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConvertString = function (str = \\'\\', target = \\'\\', k) {\\n  if (str.length !== target.length) {\\n    return false;\\n  }\\n  const config = {};\\n  for (let index = 0; index < str.length; index++) {\\n    const diff = target.charCodeAt(index) - str.charCodeAt(index);\\n\\n    if (diff === 0) {\\n      continue;\\n    }\\n    if (diff > k) {\\n      return false;\\n    }\\n    if (diff < 0) {\\n      const temp = 26 + diff;\\n      if (temp > k) {\\n        return false;\\n      }\\n      if (!config[temp]) {\\n        config[temp] = 0;\\n      }\\n      config[temp] += 1;\\n    } else {\\n      if (!config[diff]) {\\n        config[diff] = 0;\\n      }\\n      config[diff] += 1;\\n    }\\n  }\\n  for (const key in config) {\\n    if (config[key] > 1) {\\n      const temp = (config[key] - 1) * 26 + Number(key);\\n      if (k < temp) {\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431379,
                "title": "c-o-n-time-o-26-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())  return false;\\n        \\n        vector<int> moves( 27, k/26);\\n        for( int i=1; i<=k%26; i++)\\n            moves[i]+=1;\\n        \\n        for( int i=0; i<s.size(); i++){\\n            int d=(26+t[i]-s[i])%26;\\n            if(d==0)    continue;\\n            if(moves[d]==0)\\n                return false;\\n            else\\n                moves[d]-=1;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())  return false;\\n        \\n        vector<int> moves( 27, k/26);\\n        for( int i=1; i<=k%26; i++)\\n            moves[i]+=1;\\n        \\n        for( int i=0; i<s.size(); i++){\\n            int d=(26+t[i]-s[i])%26;\\n            if(d==0)    continue;\\n            if(moves[d]==0)\\n                return false;\\n            else\\n                moves[d]-=1;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430909,
                "title": "c-modulo-arithmetics",
                "content": "We compute how many times me can and we should use `(t[i] - k[i])` shift:\\n\\n```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        if (s.Length != t.Length)\\n            return false;\\n        \\n        int[] moves = Enumerable\\n            .Range(0, 26)\\n            .Select(i => k / 26 + (i <= k % 26 ? 1 : 0))\\n            .ToArray();\\n        \\n        moves[0] = int.MaxValue;\\n        \\n        for (int i = s.Length - 1; i >= 0; --i) \\n            if (--moves[(t[i] - s[i] + 26) % 26] < 0)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        if (s.Length != t.Length)\\n            return false;\\n        \\n        int[] moves = Enumerable\\n            .Range(0, 26)\\n            .Select(i => k / 26 + (i <= k % 26 ? 1 : 0))\\n            .ToArray();\\n        \\n        moves[0] = int.MaxValue;\\n        \\n        for (int i = s.Length - 1; i >= 0; --i) \\n            if (--moves[(t[i] - s[i] + 26) % 26] < 0)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400825,
                "title": "c-easy-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string tr, int k) {\\n        int n=s.size();\\n        if(n!=tr.size())\\n            return 0;\\n        vector<int> t(26);\\n        for(int i=0;i<26;i++)\\n            t[i]=k/26;\\n        for(int i=k%26;i>=1;i--)\\n            t[i]++;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(tr[i]==s[i])continue;\\n            int a=(tr[i]>s[i]?tr[i]-s[i]:26-s[i]+tr[i]);\\n            if(!t[a])return 0;\\n            t[a]--;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string tr, int k) {\\n        int n=s.size();\\n        if(n!=tr.size())\\n            return 0;\\n        vector<int> t(26);\\n        for(int i=0;i<26;i++)\\n            t[i]=k/26;\\n        for(int i=k%26;i>=1;i--)\\n            t[i]++;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(tr[i]==s[i])continue;\\n            int a=(tr[i]>s[i]?tr[i]-s[i]:26-s[i]+tr[i]);\\n            if(!t[a])return 0;\\n            t[a]--;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343164,
                "title": "c",
                "content": "```\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) return false;\\n        \\n        int ans = 0;\\n        vector<int> bucket(26);\\n        for (int i = 0; i < s.size(); ++ i){\\n            if (s[i] == t[i]) continue;\\n            int temp = (-s[i] + t[i]) > 0 ? (-s[i] + t[i]) : (-s[i] + t[i]) + 26;\\n            ans = max(ans, (bucket[temp]) * 26 + temp);\\n            bucket[temp] ++;\\n        }\\n        \\n        return ans <= k;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) return false;\\n        \\n        int ans = 0;\\n        vector<int> bucket(26);\\n        for (int i = 0; i < s.size(); ++ i){\\n            if (s[i] == t[i]) continue;\\n            int temp = (-s[i] + t[i]) > 0 ? (-s[i] + t[i]) : (-s[i] + t[i]) + 26;\\n            ans = max(ans, (bucket[temp]) * 26 + temp);\\n            bucket[temp] ++;\\n        }\\n        \\n        return ans <= k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2341667,
                "title": "intuitive-do-as-hints-say-corner-cases",
                "content": "```\\nclass Solution {\\n    \\n    int dis(char s, char t) {\\n        return (t - s + 26) % 26;\\n    }\\n    \\n    vector<int> get_dis(const string& s, const string& t) {\\n        int len = s.size();\\n        vector<int> res(26);\\n        for (int i = 0; i < len; ++i) {\\n            res[dis(s[i], t[i])]++;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if (s.size() != t.size()) return false;\\n        \\n        auto distances = get_dis(s, t);\\n        for (int i = 1; i < distances.size(); ++i) {\\n            if (i + (distances[i] - 1) * 26 > k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int dis(char s, char t) {\\n        return (t - s + 26) % 26;\\n    }\\n    \\n    vector<int> get_dis(const string& s, const string& t) {\\n        int len = s.size();\\n        vector<int> res(26);\\n        for (int i = 0; i < len; ++i) {\\n            res[dis(s[i], t[i])]++;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if (s.size() != t.size()) return false;\\n        \\n        auto distances = get_dis(s, t);\\n        for (int i = 1; i < distances.size(); ++i) {\\n            if (i + (distances[i] - 1) * 26 > k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331947,
                "title": "c-98-optimised-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        int n=s.size();\\n        vector<int>v(26);\\n        int diff;\\n        for(int i=0;i<n;i++)\\n        {\\n            // cout<<t[i]-s[i]\\n            if(s[i]!=t[i])\\n            {\\n                diff=t[i]-s[i];\\n                // cout<<\"i , diff : \"<<i<<\" \"<<diff<<endl;\\n                if(diff>0)\\n                {\\n                    v[diff]=v[diff]+1;\\n                }\\n                else \\n                {\\n                    v[26+diff]=v[26+diff]+1;\\n                }\\n            }\\n        }\\n        // for(int i=0;i<26;i++) cout<<i<<\" \"<<v[i]<<endl;\\n        int maxi=-1;\\n        for(int i=1;i<=25;i++)\\n        {\\n            if(v[i]>0)\\n            {\\n                // cout<<\"v[i] : \"<<v[i]<<endl;\\n                int step=((v[i]-1)*26)+i;\\n                // cout<<\"step : \"<<step<<endl;\\n                maxi=max(maxi,step);\\n            }\\n        }\\n        if(maxi<=k) return true;\\n        else return false;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        int n=s.size();\\n        vector<int>v(26);\\n        int diff;\\n        for(int i=0;i<n;i++)\\n        {\\n            // cout<<t[i]-s[i]\\n            if(s[i]!=t[i])\\n            {\\n                diff=t[i]-s[i];\\n                // cout<<\"i , diff : \"<<i<<\" \"<<diff<<endl;\\n                if(diff>0)\\n                {\\n                    v[diff]=v[diff]+1;\\n                }",
                "codeTag": "C++"
            },
            {
                "id": 2302803,
                "title": "c-solution-with-explanation",
                "content": "```\\n/*\\n\\n    actually here, the k value represents the maximum difference we can use\\n    to go from a to b - we can start from a and reach b in one step \\n                      - we can start from a, complete a full circle, and come back to a, then take 1 step to reach b (1 + 26 steps)\\n                      - we can start from a, complete 2 full circles, and come back to a, then take 1 step to reach b (1 + 2*26 steps)\\n                      - if we take m circles then, we will take 1 + m*26 steps\\n                      \\n   notice that to transform s[i] to t[i], the number of circles, we will have to take is the number of occurrences of the difference \\n   (t[i] - s[i] + 26) % 26 [this is actually the circular difference between s[i] and t[i] (angular displacement*r)] \\n   like if we want to convert x to a, then the shortest path in ciruclar fashion will be (a - x + 26) % 26 = (-23 + 26) % 26 = 3\\n   \\n   \\n   for example \\n   a a b\\n   b b b\\n   \\n   for converting the first a to b, we used 1 step\\n   now for converting the second a to b, we will have to use the next available option : that is [1 + 1*26] = 27\\n   so at each point, check if diff + cnt[diff]*26 <= k, if it is you can change it to t[i] else not\\n                      \\n\\n*/\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n            \\n        if(s.length() != t.length()) return false;\\n        \\n        int cnt[26]{0};\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == t[i]) continue;\\n            int diff = (t[i] - s[i] + 26) % 26;\\n            if(diff + cnt[diff]*26 > k) return false;\\n            cnt[diff]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\n    actually here, the k value represents the maximum difference we can use\\n    to go from a to b - we can start from a and reach b in one step \\n                      - we can start from a, complete a full circle, and come back to a, then take 1 step to reach b (1 + 26 steps)\\n                      - we can start from a, complete 2 full circles, and come back to a, then take 1 step to reach b (1 + 2*26 steps)\\n                      - if we take m circles then, we will take 1 + m*26 steps\\n                      \\n   notice that to transform s[i] to t[i], the number of circles, we will have to take is the number of occurrences of the difference \\n   (t[i] - s[i] + 26) % 26 [this is actually the circular difference between s[i] and t[i] (angular displacement*r)] \\n   like if we want to convert x to a, then the shortest path in ciruclar fashion will be (a - x + 26) % 26 = (-23 + 26) % 26 = 3\\n   \\n   \\n   for example \\n   a a b\\n   b b b\\n   \\n   for converting the first a to b, we used 1 step\\n   now for converting the second a to b, we will have to use the next available option : that is [1 + 1*26] = 27\\n   so at each point, check if diff + cnt[diff]*26 <= k, if it is you can change it to t[i] else not\\n                      \\n\\n*/\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n            \\n        if(s.length() != t.length()) return false;\\n        \\n        int cnt[26]{0};\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == t[i]) continue;\\n            int diff = (t[i] - s[i] + 26) % 26;\\n            if(diff + cnt[diff]*26 > k) return false;\\n            cnt[diff]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268872,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int val=0;\\n        if(s.size()!=t.size())return false;\\n        unordered_map<int,int>m;//it contains the number of times diff appeared\\n        for(int i=0;i<s.size();i++){\\n            int diff=t[i]-s[i];\\n            if(diff==0)continue;\\n            if(diff<0)diff+=26;\\n            if(m[diff]*26+diff>k)return false;\\n            m[diff]++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int val=0;\\n        if(s.size()!=t.size())return false;\\n        unordered_map<int,int>m;//it contains the number of times diff appeared\\n        for(int i=0;i<s.size();i++){\\n            int diff=t[i]-s[i];\\n            if(diff==0)continue;\\n            if(diff<0)diff+=26;\\n            if(m[diff]*26+diff>k)return false;\\n            m[diff]++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260349,
                "title": "easy-to-understand-o-n-c",
                "content": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        \\n        if(s.Length!=t.Length) return false;\\n        var map = new int[27];\\n        \\n        var whole = k/26;\\n        var partial = k%26;\\n        \\n        //Fill values with available replaces\\n        // a => b can happen with 1 or 27 so we can count 27 as 1\\n        for(int i=1; i<=26; i++)\\n        {\\n            map[i] = whole;\\n            if(i<=partial) map[i]++;\\n        }\\n        \\n        for(int i=0; i<s.Length; i++)\\n        {\\n            //(t[i] - s[i]) =>  a->z. => 26-1 => 25\\n            //(t[i] - s[i] + 26) => z -> a  => 1 - 26 + 26 => 1\\n            var diff = (t[i] - s[i]) >= 0 ? (t[i] - s[i]) : (t[i] - s[i] + 26);\\n            \\n            //If difference is 0 then we don\\'t need to do anything\\n            if(diff== 0) continue;\\n            \\n            //If we don\\'t have any replace available\\n            if(map[diff] <= 0) return false;\\n            map[diff]--;\\n            \\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        \\n        if(s.Length!=t.Length) return false;\\n        var map = new int[27];\\n        \\n        var whole = k/26;\\n        var partial = k%26;\\n        \\n        //Fill values with available replaces\\n        // a => b can happen with 1 or 27 so we can count 27 as 1\\n        for(int i=1; i<=26; i++)\\n        {\\n            map[i] = whole;\\n            if(i<=partial) map[i]++;\\n        }\\n        \\n        for(int i=0; i<s.Length; i++)\\n        {\\n            //(t[i] - s[i]) =>  a->z. => 26-1 => 25\\n            //(t[i] - s[i] + 26) => z -> a  => 1 - 26 + 26 => 1\\n            var diff = (t[i] - s[i]) >= 0 ? (t[i] - s[i]) : (t[i] - s[i] + 26);\\n            \\n            //If difference is 0 then we don\\'t need to do anything\\n            if(diff== 0) continue;\\n            \\n            //If we don\\'t have any replace available\\n            if(map[diff] <= 0) return false;\\n            map[diff]--;\\n            \\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238035,
                "title": "can-convert-string-in-k-moves",
                "content": "### \\tC++ \\n\\t\\n\\tbool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()){\\n            return false;\\n        }\\n        \\n        int n = s.length();\\n    \\n        int arr[26]={};\\n        \\n        for(int i = 0;i<n;i++){\\n            int diff = t[i]-s[i] + (t[i]>=s[i] ? 0 : 26);\\n            if(diff==0) {\\n                continue;\\n            }    \\n            if(arr[diff]*26 + diff >k){\\n                return false;\\n            }\\n            ++arr[diff];\\n        }\\n        return true;\\n        \\n    }",
                "solutionTags": [
                    "String"
                ],
                "code": "### \\tC++ \\n\\t\\n\\tbool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()){\\n            return false;\\n        }\\n        \\n        int n = s.length();\\n    \\n        int arr[26]={};\\n        \\n        for(int i = 0;i<n;i++){\\n            int diff = t[i]-s[i] + (t[i]>=s[i] ? 0 : 26);\\n            if(diff==0) {\\n                continue;\\n            }    \\n            if(arr[diff]*26 + diff >k){\\n                return false;\\n            }\\n            ++arr[diff];\\n        }\\n        return true;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2222696,
                "title": "c-compare-moves-needed-to-available-moves",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        \\n        vector<int> diffCount(26,0);\\n        for(int i=0;i<s.size();++i) diffCount[(t[i]-s[i]+26)%26]++;\\n        \\n        int repeat = k/26, remain = k%26;\\n        vector<int> diffCountAvailable(26,repeat);\\n        for(int i=1;i<=remain;++i) diffCountAvailable[i]++;\\n        \\n        for(int i=1;i<diffCount.size();++i) \\n            if(diffCount[i]>diffCountAvailable[i]) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        \\n        vector<int> diffCount(26,0);\\n        for(int i=0;i<s.size();++i) diffCount[(t[i]-s[i]+26)%26]++;\\n        \\n        int repeat = k/26, remain = k%26;\\n        vector<int> diffCountAvailable(26,repeat);\\n        for(int i=1;i<=remain;++i) diffCountAvailable[i]++;\\n        \\n        for(int i=1;i<diffCount.size();++i) \\n            if(diffCount[i]>diffCountAvailable[i]) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155709,
                "title": "python-3-simple-o-n-o-1-solution",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        cycles, extra = divmod(k, 26)\\n        shifts = [cycles + (shift <= extra) for shift in range(26)]\\n\\n        for cs, ct in zip(s, t):\\n            shift = (ord(ct) - ord(cs)) % 26\\n            if shift == 0:\\n                continue\\n            if not shifts[shift]:\\n                return False\\n            shifts[shift] -= 1\\n        \\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        cycles, extra = divmod(k, 26)\\n        shifts = [cycles + (shift <= extra) for shift in range(26)]\\n\\n        for cs, ct in zip(s, t):\\n            shift = (ord(ct) - ord(cs)) % 26\\n            if shift == 0:\\n                continue\\n            if not shifts[shift]:\\n                return False\\n            shifts[shift] -= 1\\n        \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2131454,
                "title": "interesting-trick-for-an-interesting-question",
                "content": "```cpp\\nif (s.size() != t.size())\\n\\treturn false;\\n\\n// count the quota of every possible shift 1 ~ 25 given by k wrapping around 26.\\nint q = k / 26;\\nint r = k % 26;\\n\\nvector<int> quota(26, q);\\n\\nfor (int i = 0; i <= r; ++i)\\n\\t++ quota[i];\\n\\n// compare each char\\nfor (int i = 0; i < s.size(); ++i)\\n{\\n\\t// find the difference\\n\\tint d = (t[i] - s[i] + 26) % 26;\\n\\t\\n\\t// skip when d == 0\\n\\t// if run out of quota of any d, sad, can not convert.\\n\\tif (d && -- quota[d] < 0)\\n\\t\\treturn false;\\n}\\n\\nreturn true;\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nif (s.size() != t.size())\\n\\treturn false;\\n\\n// count the quota of every possible shift 1 ~ 25 given by k wrapping around 26.\\nint q = k / 26;\\nint r = k % 26;\\n\\nvector<int> quota(26, q);\\n\\nfor (int i = 0; i <= r; ++i)\\n\\t++ quota[i];\\n\\n// compare each char\\nfor (int i = 0; i < s.size(); ++i)\\n{\\n\\t// find the difference\\n\\tint d = (t[i] - s[i] + 26) % 26;\\n\\t\\n\\t// skip when d == 0\\n\\t// if run out of quota of any d, sad, can not convert.\\n\\tif (d && -- quota[d] < 0)\\n\\t\\treturn false;\\n}\\n\\nreturn true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2106259,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @param {number} k\\n * @return {boolean}\\n */\\n var canConvertString = function(s, t, k) {\\n    let res = true;\\n    if(s.length === t.length){\\n        let tmp = [];\\n        let countMap = new Map();\\n        for(let i=0; i<s.length; i++){\\n            let n1 = s[i].charCodeAt();\\n            let n2 = t[i].charCodeAt();\\n            let r = n2 - n1;\\n            if(r < 0){\\n                r += 26;\\n            }\\n            // exclude special case 0\\n            if(r > 0){\\n                // Considering repeated letters, the unrepeated move should change to r + 26*n (n>=0)\\n                // use hash table to count the same letter\\n                if(!countMap.has(r)){\\n\\t\\t\\t\\t    // first time to move\\n                    countMap.set(r, 1);\\n                    tmp.push(r);\\n                }else{\\n\\t\\t\\t\\t    // n time to move, n means the count of the same letter\\n                    let c = countMap.get(r);\\n                    tmp.push(r + c * 26);\\n\\t\\t\\t\\t\\t// update count\\n                    countMap.set(r, c+1);\\n                }\\n            }\\n        }\\n        // check all possible move in range\\n        for(let i=0; i<tmp.length; i++){\\n            let t = tmp[i];\\n            if(t > k){\\n                res = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        res = false;\\n    }\\n    \\n    return res;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @param {number} k\\n * @return {boolean}\\n */\\n var canConvertString = function(s, t, k) {\\n    let res = true;\\n    if(s.length === t.length){\\n        let tmp = [];\\n        let countMap = new Map();\\n        for(let i=0; i<s.length; i++){\\n            let n1 = s[i].charCodeAt();\\n            let n2 = t[i].charCodeAt();\\n            let r = n2 - n1;\\n            if(r < 0){\\n                r += 26;\\n            }\\n            // exclude special case 0\\n            if(r > 0){\\n                // Considering repeated letters, the unrepeated move should change to r + 26*n (n>=0)\\n                // use hash table to count the same letter\\n                if(!countMap.has(r)){\\n\\t\\t\\t\\t    // first time to move\\n                    countMap.set(r, 1);\\n                    tmp.push(r);\\n                }else{\\n\\t\\t\\t\\t    // n time to move, n means the count of the same letter\\n                    let c = countMap.get(r);\\n                    tmp.push(r + c * 26);\\n\\t\\t\\t\\t\\t// update count\\n                    countMap.set(r, c+1);\\n                }\\n            }\\n        }\\n        // check all possible move in range\\n        for(let i=0; i<tmp.length; i++){\\n            let t = tmp[i];\\n            if(t > k){\\n                res = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        res = false;\\n    }\\n    \\n    return res;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2103358,
                "title": "check-is-the-shift-possible-within-k-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n        vector<int> vec(26, 0); // distance between characters is in  [0,25]\\n        for(int i=0; i<s.size(); i++){\\n            int d= (int)t[i]- (int)s[i]; // distance between ith characters in strings  s, t\\n            if(d<0){\\n                d+=26; // as  d cannot be negative\\n            }\\n            if(d!=0){\\n                if(vec[d]*26+d<=k){ // d+ 26*n is the move required where n can be 0, 1, 2...\\n\\t\\t\\t\\t//we keep track of n for given \\'d\\' in vec[d] when ever this vec[d]*26+d<=k  condition fails we \\n\\t\\t\\t\\t//output false as we cannot find a move that can shift our character our character by d!\\n                    vec[d]++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n        vector<int> vec(26, 0); // distance between characters is in  [0,25]\\n        for(int i=0; i<s.size(); i++){\\n            int d= (int)t[i]- (int)s[i]; // distance between ith characters in strings  s, t\\n            if(d<0){\\n                d+=26; // as  d cannot be negative\\n            }\\n            if(d!=0){\\n                if(vec[d]*26+d<=k){ // d+ 26*n is the move required where n can be 0, 1, 2...\\n\\t\\t\\t\\t//we keep track of n for given \\'d\\' in vec[d] when ever this vec[d]*26+d<=k  condition fails we \\n\\t\\t\\t\\t//output false as we cannot find a move that can shift our character our character by d!\\n                    vec[d]++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081314,
                "title": "javascript-step-check-176ms",
                "content": "```\\nconst ord = (c) => c.charCodeAt();\\nconst counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };\\n\\nconst canConvertString = (s, t, k) => {\\n    if (s.length != t.length) return false;\\n    let n = s.length, step = Array(n).fill(0);\\n    for (let i = 0; i < n; i++) { // calculate each step move\\n        if (s[i] <= t[i]) {\\n            step[i] = ord(t[i]) - ord(s[i]);\\n        } else {\\n            step[i] = 122 - ord(s[i]) + 1 + ord(t[i]) - 97;  // s[i] -> \\'z\\' -> \\'a\\' -> t[i]\\n        }\\n    }\\n    let m = counter(step);\\n    for (const [x, occ] of m) {\\n        if (x == 0) continue;\\n        if (x > k) return false; // over k cannot move\\n        let can = parseInt((k - x) / 26) + 1; // possible all different moves  x + 26 * (1, 2, 3 ......)\\n        if (occ > can) return false; // under k, but can doesn\\'t enough for occurrence\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst ord = (c) => c.charCodeAt();\\nconst counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };\\n\\nconst canConvertString = (s, t, k) => {\\n    if (s.length != t.length) return false;\\n    let n = s.length, step = Array(n).fill(0);\\n    for (let i = 0; i < n; i++) { // calculate each step move\\n        if (s[i] <= t[i]) {\\n            step[i] = ord(t[i]) - ord(s[i]);\\n        } else {\\n            step[i] = 122 - ord(s[i]) + 1 + ord(t[i]) - 97;  // s[i] -> \\'z\\' -> \\'a\\' -> t[i]\\n        }\\n    }\\n    let m = counter(step);\\n    for (const [x, occ] of m) {\\n        if (x == 0) continue;\\n        if (x > k) return false; // over k cannot move\\n        let can = parseInt((k - x) / 26) + 1; // possible all different moves  x + 26 * (1, 2, 3 ......)\\n        if (occ > can) return false; // under k, but can doesn\\'t enough for occurrence\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2069898,
                "title": "simple-python-solution-space-o-1-time-o-n",
                "content": "**Steps:**\\n1. Check if the length for strings are equal. If not, then return False.\\n2. Store the counts of difference from s[i] to t[i].\\n3. Multiply the count by 26 and add the difference if s[i] != t[i]. This is done because for the first occurence of the difference, we need to add it. And for extra occurences of the difference, we need to add 26 to it each time so that i(mentioned in the question) would be unique for each occurrence.\\n4. If the above value is more than k then return False.\\n5. If the whole string gets parsed, return True.\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n        #If length of strings are different return False\\n        if len(s) != len(t):\\n            return False\\n        \\n        check = [0]*26  #List which stores counts of t[i] - s[i]\\n        \\n        #Storing counts of t[i] - s[i] for 0 <= i < len(s)\\n        for i in range(len(s)):\\n            if s[i] != t[i]:\\n                temp = ( ord(t[i]) - ord(s[i]) ) % 26\\n                big = temp + 26*check[temp]\\n                check[temp] += 1\\n                if big > k:\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n        #If length of strings are different return False\\n        if len(s) != len(t):\\n            return False\\n        \\n        check = [0]*26  #List which stores counts of t[i] - s[i]\\n        \\n        #Storing counts of t[i] - s[i] for 0 <= i < len(s)\\n        for i in range(len(s)):\\n            if s[i] != t[i]:\\n                temp = ( ord(t[i]) - ord(s[i]) ) % 26\\n                big = temp + 26*check[temp]\\n                check[temp] += 1\\n                if big > k:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069204,
                "title": "easy-o-n-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        HashMap<Integer, Integer> mp=new HashMap();\\n        if(s.length()!=t.length())return false;\\n        for(int i=0;i<s.length();i++){\\n            int temp = 0;\\n            if((int)(s.charAt(i))<(int)(t.charAt(i))){\\n                temp = (int)(t.charAt(i))-(int)(s.charAt(i));\\n                if(!mp.containsKey(temp))mp.put(temp,1);\\n                else mp.put(temp,mp.get(temp)+1);\\n            }\\n            else if((int)(s.charAt(i))>(int)(t.charAt(i))){\\n                temp = 26 - s.charAt(i) + t.charAt(i);\\n                if(!mp.containsKey(temp))mp.put(temp, 1);\\n                else mp.put(temp,mp.get(temp)+1);\\n            }\\n            else continue;\\n        }\\n        for(int i:mp.keySet()){\\n            int fre = mp.get(i);\\n            int temp = i + (fre-1)*26;\\n            if(temp>k)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        HashMap<Integer, Integer> mp=new HashMap();\\n        if(s.length()!=t.length())return false;\\n        for(int i=0;i<s.length();i++){\\n            int temp = 0;\\n            if((int)(s.charAt(i))<(int)(t.charAt(i))){\\n                temp = (int)(t.charAt(i))-(int)(s.charAt(i));\\n                if(!mp.containsKey(temp))mp.put(temp,1);\\n                else mp.put(temp,mp.get(temp)+1);\\n            }\\n            else if((int)(s.charAt(i))>(int)(t.charAt(i))){\\n                temp = 26 - s.charAt(i) + t.charAt(i);\\n                if(!mp.containsKey(temp))mp.put(temp, 1);\\n                else mp.put(temp,mp.get(temp)+1);\\n            }\\n            else continue;\\n        }\\n        for(int i:mp.keySet()){\\n            int fre = mp.get(i);\\n            int temp = i + (fre-1)*26;\\n            if(temp>k)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037161,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if(s.length()!=t.length()) return false;\\n        \\n        vector<pair<int,int>> v(27, {0,0});\\n        \\n        long long maxK = -1;\\n        for(int i=0; i<s.length(); i++) {\\n            long long diff;\\n            if(s[i] == t[i]) {\\n                continue;\\n            } else if(s[i] < t[i]) {\\n                diff = t[i] - s[i];\\n            } else {\\n                diff = 26 - (s[i] - t[i]);\\n            }\\n            \\n            if(v[diff].first == 0) {\\n                v[diff].first = 1;\\n                maxK = max(maxK, diff);\\n            } else {\\n                v[diff].second += 1;\\n                diff = 26*v[diff].second + diff;\\n                maxK = max(maxK, diff);\\n            }\\n        }\\n        return (maxK>k)?false:true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if(s.length()!=t.length()) return false;\\n        \\n        vector<pair<int,int>> v(27, {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2008682,
                "title": "declarative-ruby-one-liner-beats-100-100",
                "content": "```\\n# @param {String} s\\n# @param {String} t\\n# @param {Integer} k\\n# @return {Boolean}\\ndef can_convert_string(s, t, k)\\n  s.size == t.size && t.bytes.zip(s.bytes).map { (_1 - _2) % 26 }.tally.all? { _1 == 0 || _2 <= (k - _1) / 26 + 1 }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {String} s\\n# @param {String} t\\n# @param {Integer} k\\n# @return {Boolean}\\ndef can_convert_string(s, t, k)\\n  s.size == t.size && t.bytes.zip(s.bytes).map { (_1 - _2) % 26 }.tally.all? { _1 == 0 || _2 <= (k - _1) / 26 + 1 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1925423,
                "title": "c-very-fast-and-memory-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()) return false;\\n        int n = s.length();\\n        vector<int> v(26);\\n        for(int i=0;i<n;i++){\\n            if(s[i]<=t[i]) v[t[i]-s[i]]++;\\n            else{\\n                int d1 = \\'z\\' - s[i];\\n                int d2 = t[i] -\\'a\\' + 1;\\n                v[d1+d2]++;\\n            }\\n        }\\n        for(int i=1;i<26;i++){\\n            if(v[i]){\\n                int q = k/26;\\n                int r = k%26;\\n                if(r>=i) q += 1;\\n                if(v[i]>q) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()) return false;\\n        int n = s.length();\\n        vector<int> v(26);\\n        for(int i=0;i<n;i++){\\n            if(s[i]<=t[i]) v[t[i]-s[i]]++;\\n            else{\\n                int d1 = \\'z\\' - s[i];\\n                int d2 = t[i] -\\'a\\' + 1;\\n                v[d1+d2]++;\\n            }\\n        }\\n        for(int i=1;i<26;i++){\\n            if(v[i]){\\n                int q = k/26;\\n                int r = k%26;\\n                if(r>=i) q += 1;\\n                if(v[i]>q) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892437,
                "title": "python3-o-n-simple-to-understand",
                "content": "* just get an array of the shift values and if the shift value has been seen \\'n\\' times, the largest move we need is:\\n\\t* shift value + \\'n\\' * 26\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s)!=len(t): return False\\n        arr=[ord(b)-ord(a) if b>a else 26-(ord(a)-ord(b)) for a,b in zip(s,t) if a!=b]\\n        dct=collections.Counter()\\n        for el in arr:\\n            if el+dct[el]*26>k: return False\\n            dct[el]+=1\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s)!=len(t): return False\\n        arr=[ord(b)-ord(a) if b>a else 26-(ord(a)-ord(b)) for a,b in zip(s,t) if a!=b]\\n        dct=collections.Counter()\\n        for el in arr:\\n            if el+dct[el]*26>k: return False\\n            dct[el]+=1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889772,
                "title": "hashmap",
                "content": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) return false;\\n        \\n        var map = new HashMap<Integer, Integer>();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (t.charAt(i) == s.charAt(i)) continue;\\n            else if (t.charAt(i) - s.charAt(i) > 0) {\\n                var c = t.charAt(i) - s.charAt(i);\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            } else {\\n                var c = 26 - s.charAt(i) + t.charAt(i);\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n        \\n        var used = new HashSet<Integer>();\\n        for (var it : map.entrySet()) {\\n            var next = it.getKey();\\n            \\n            for (int i = it.getValue(); i > 0; i--) {\\n                while(used.contains(next)) next += 26;\\n                \\n                if (next > k) return false;\\n                else used.add(next);\\n            }   \\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) return false;\\n        \\n        var map = new HashMap<Integer, Integer>();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (t.charAt(i) == s.charAt(i)) continue;\\n            else if (t.charAt(i) - s.charAt(i) > 0) {\\n                var c = t.charAt(i) - s.charAt(i);\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            } else {\\n                var c = 26 - s.charAt(i) + t.charAt(i);\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n        \\n        var used = new HashSet<Integer>();\\n        for (var it : map.entrySet()) {\\n            var next = it.getKey();\\n            \\n            for (int i = it.getValue(); i > 0; i--) {\\n                while(used.contains(next)) next += 26;\\n                \\n                if (next > k) return false;\\n                else used.add(next);\\n            }   \\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1870337,
                "title": "c-freq",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) {\\n            return false;\\n        }\\n        \\n        int shifts[26] = {0};\\n        for (int i = 1; i < 26; ++i) {\\n            shifts[i] = k / 26 + (i <= (k % 26));\\n        }\\n        \\n        for (int i = 0; i < s.size(); ++i) {\\n\\t\\t    auto idx = t[i] - s[i] + (s[i] < t[i] ? 0 : 26);\\n            if (s[i] != t[i] && --shifts[idx] < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) {\\n            return false;\\n        }\\n        \\n        int shifts[26] = {0};\\n        for (int i = 1; i < 26; ++i) {\\n            shifts[i] = k / 26 + (i <= (k % 26));\\n        }\\n        \\n        for (int i = 0; i < s.size(); ++i) {\\n\\t\\t    auto idx = t[i] - s[i] + (s[i] < t[i] ? 0 : 26);\\n            if (s[i] != t[i] && --shifts[idx] < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774010,
                "title": "java-sharing-code",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        if(s.length()!=t.length())\\n            return false;\\n        int[] arr = new int [26];\\n        int mini = k/26;\\n        int limit = k%26;\\n        for(int i=0;i<26;i++){\\n            arr[i]=mini;\\n            if(limit>=i)\\n                arr[i]++;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int cnt = ((t.charAt(i)-s.charAt(i))+26)%26;\\n            if(cnt==0)\\n                continue;\\n            arr[cnt]--;\\n            if(arr[cnt]<0)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        if(s.length()!=t.length())\\n            return false;\\n        int[] arr = new int [26];\\n        int mini = k/26;\\n        int limit = k%26;\\n        for(int i=0;i<26;i++){\\n            arr[i]=mini;\\n            if(limit>=i)\\n                arr[i]++;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int cnt = ((t.charAt(i)-s.charAt(i))+26)%26;\\n            if(cnt==0)\\n                continue;\\n            arr[cnt]--;\\n            if(arr[cnt]<0)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711905,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n     int size=s.size(),n=t.size();\\n        if(size!=n)\\n            return false;\\n        unordered_map<int,int>cnt;\\n        for(int i=0;i<size;i++){\\n            int dist=t[i]-s[i];\\n            dist+=(dist<0)?26:0;\\n            if(dist==0)\\n                continue;\\n            cnt[dist]++;\\n        }\\n        for(auto & p:cnt){\\n           int maxi=26*(p.second-1)+p.first; \\n            if(maxi>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n     int size=s.size(),n=t.size();\\n        if(size!=n)\\n            return false;\\n        unordered_map<int,int>cnt;\\n        for(int i=0;i<size;i++){\\n            int dist=t[i]-s[i];\\n            dist+=(dist<0)?26:0;\\n            if(dist==0)\\n                continue;\\n            cnt[dist]++;\\n        }\\n        for(auto & p:cnt){\\n           int maxi=26*(p.second-1)+p.first; \\n            if(maxi>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707045,
                "title": "easy-explained-solution-using-map",
                "content": "1. If length( s ) and length( t ) are not equal, then it\\'ll never be possible to convert, because we are not allowed to add or remove character from the strings. Hence ans = false.\\n\\nWe want to store remainder, as well as frequency into the map.\\nEx.1. For \\'a\\' to \\'z\\' conversion, \\'z\\' - \\'a\\' = 25, Added with 26 and take mod 26, rem = (25+26)%26 = 25.\\nEx.2. For \\'z\\' to \\'a\\' conversion, \\'a\\' - \\'z\\' = -25, added 26 and take mod 26, rem = (-25+26)%26 = 1.\\nSo 26 is added to avoid negative remainder, as we are only allowed to move forword.\\n\\n2. Ex.3. For s = \\'aaab\\' to t = \\'bbbb\\' conversion, we want three \\'a\\' to \\'b\\' conversion.\\nSo, rem = (\\'b\\'-\\'a\\'+26)%26 = 1, frequency = 3.\\nfor s[0] = \\'a\\' to t[0] = \\'b\\', we need 1st move, we use 1st move,\\nfor s[1] = \\'a\\' to t[1] = \\'b\\', we need 1st move too, we use (1+(26\\\\*1) ) = 27th move,\\nfor s[2] = \\'a\\' to t[2] = \\'b\\', we need 1st move too, we use (1+(26\\\\*2) ) = 53rd move,\\nHence, if for a particular remainder frequency = \\'x\\', we\\'re gonna check, if \\'(x-1)\\\\*26 + rem\\' belongs to the range [0, k] or not.\\nSo, we directly check for 53 <= k, if not, then ans = false.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int, int> mp;\\n        int n = s.size(), i, rem, freq;\\n        if( t.size() != n )return false;\\n        for( i = 0; i < n; i++ ){\\n            if( s[i] == t[i] )continue;\\n            rem = ( t[i] - s[i] + 26)%26;\\n            mp[rem]++;\\n        }\\n        for( auto& x : mp ){\\n            rem = x.first;\\n            freq = x.second;\\n            if( ( freq-1 )*26 + rem > k )return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\nFeel free to comment and upvote ;)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int, int> mp;\\n        int n = s.size(), i, rem, freq;\\n        if( t.size() != n )return false;\\n        for( i = 0; i < n; i++ ){\\n            if( s[i] == t[i] )continue;\\n            rem = ( t[i] - s[i] + 26)%26;\\n            mp[rem]++;\\n        }\\n        for( auto& x : mp ){\\n            rem = x.first;\\n            freq = x.second;\\n            if( ( freq-1 )*26 + rem > k )return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701407,
                "title": "easy-map-set-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int, int>hash;\\n        unordered_set<int>umap;\\n        if(s.length() != t.length()){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == t[i]){\\n                continue;\\n            }\\n            int a = ((t[i]-\\'a\\')-(s[i]-\\'a\\') + 26)%26;\\n            hash[a]++;\\n        }\\n       \\n        for(auto x : hash){\\n            int move = (k/26);\\n            if(k%26 and x.first<=k%26){\\n                move++;\\n            }\\n            cout << move << endl;\\n            if(move < x.second or umap.count(x.first)){\\n                return false;\\n            }\\n            umap.insert(x.first);\\n        }\\n        return true;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int, int>hash;\\n        unordered_set<int>umap;\\n        if(s.length() != t.length()){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == t[i]){\\n                continue;\\n            }\\n            int a = ((t[i]-\\'a\\')-(s[i]-\\'a\\') + 26)%26;\\n            hash[a]++;\\n        }\\n       \\n        for(auto x : hash){\\n            int move = (k/26);\\n            if(k%26 and x.first<=k%26){\\n                move++;\\n            }\\n            cout << move << endl;\\n            if(move < x.second or umap.count(x.first)){\\n                return false;\\n            }\\n            umap.insert(x.first);\\n        }\\n        return true;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1668896,
                "title": "c-linq-one-liner-o-n-time",
                "content": "```\\npublic class Solution \\n{\\n    public bool CanConvertString(string s, string t, int k) \\n        => s.Length == t.Length && \\n           s.Zip(t, (c1, c2) => (26 + c2 - c1) % 26)\\n            .GroupBy(x => x)\\n            .All(g => g.Key == 0 || (g.Count() - 1) * 26 + g.Key <= k);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public bool CanConvertString(string s, string t, int k) \\n        => s.Length == t.Length && \\n           s.Zip(t, (c1, c2) => (26 + c2 - c1) % 26)\\n            .GroupBy(x => x)\\n            .All(g => g.Key == 0 || (g.Count() - 1) * 26 + g.Key <= k);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667151,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        HashMap<Integer,Character> set=new HashMap<>();\\n        int n=s.length();\\n        int m=t.length();\\n        if(m!=n)\\n            return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            char x=s.charAt(i);\\n            char y=t.charAt(i);\\n            int key=(y-x);\\n            if(key<0)\\n            {\\n                key=key+26;\\n            }\\n            else if(key==0)\\n                continue;\\n            if(key>k)\\n                return false;\\n            else if(set.containsKey(key))\\n            {\\n                while(set.containsKey(key))\\n                {\\n                    key=getNum(key);\\n                    if(key>k)\\n                        return false;\\n                }\\n                set.put(key,x);\\n            }\\n            else if(!set.containsKey(key))\\n            {\\n                set.put(key,x);\\n            }\\n            \\n            \\n        }\\n        return true;\\n        \\n        \\n    }\\n    public int getNum(int m)\\n    {\\n        return (26+m);\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        HashMap<Integer,Character> set=new HashMap<>();\\n        int n=s.length();\\n        int m=t.length();\\n        if(m!=n)\\n            return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            char x=s.charAt(i);\\n            char y=t.charAt(i);\\n            int key=(y-x);\\n            if(key<0)\\n            {\\n                key=key+26;\\n            }\\n            else if(key==0)\\n                continue;\\n            if(key>k)\\n                return false;\\n            else if(set.containsKey(key))\\n            {\\n                while(set.containsKey(key))\\n                {\\n                    key=getNum(key);\\n                    if(key>k)\\n                        return false;\\n                }\\n                set.put(key,x);\\n            }\\n            else if(!set.containsKey(key))\\n            {\\n                set.put(key,x);\\n            }\\n            \\n            \\n        }\\n        return true;\\n        \\n        \\n    }\\n    public int getNum(int m)\\n    {\\n        return (26+m);\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666195,
                "title": "golang-o-n-count-group-by-shift-move",
                "content": "```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    count := make([]int, 26)\\n    for i := range s {\\n        var d byte\\n        if s[i] <= t[i] {\\n            d = t[i] - s[i]\\n        } else {\\n            d = t[i] + 26 - s[i]\\n        }\\n        \\n        if int(d) > k {\\n            return false\\n        }\\n        \\n        count[d]++\\n    }\\n    \\n    for i := 1; i < 26; i++ {\\n        if count[i] > 0 {\\n            if max := i + int(count[i] - 1) * 26; max > k {\\n                return false\\n            }\\n        }\\n    } \\n    \\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    count := make([]int, 26)\\n    for i := range s {\\n        var d byte\\n        if s[i] <= t[i] {\\n            d = t[i] - s[i]\\n        } else {\\n            d = t[i] + 26 - s[i]\\n        }\\n        \\n        if int(d) > k {\\n            return false\\n        }\\n        \\n        count[d]++\\n    }\\n    \\n    for i := 1; i < 26; i++ {\\n        if count[i] > 0 {\\n            if max := i + int(count[i] - 1) * 26; max > k {\\n                return false\\n            }\\n        }\\n    } \\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1660061,
                "title": "count-req-and-available-operations",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n        \\n        vector<int> req(26,0);\\n        for(int i=0;i<s.size();i++){\\n            req[(t[i]-s[i]+26)%26]++;\\n        }\\n        vector<int> avail(26,(k+1)/26);\\n        int temp=k%26;\\n        \\n        for(int j=1;j<=temp;j++) avail[j]++;\\n        \\n        for(int i=1;i<26;i++){\\n            if(req[i]>avail[i]) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n        \\n        vector<int> req(26,0);\\n        for(int i=0;i<s.size();i++){\\n            req[(t[i]-s[i]+26)%26]++;\\n        }\\n        vector<int> avail(26,(k+1)/26);\\n        int temp=k%26;\\n        \\n        for(int j=1;j<=temp;j++) avail[j]++;\\n        \\n        for(int i=1;i<26;i++){\\n            if(req[i]>avail[i]) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654414,
                "title": "golang",
                "content": "some examples to calc char offset:\\n\\ns[i] -> t[i]\\n\\n\\'a\\' -> \\'c\\' = 2 - 0 = 2 moves\\n\\n\\'c\\' -> \\'a\\' = 0 + 26 - 2 = 24 moves\\n\\n\\n\\n\\'a\\' -> \\'z\\' = 25 - 0 = 25 moves\\n\\n\\'z\\' -> \\'a\\' = 0 + 26 - 25 = 1 move\\n\\n```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    cache := make([]int, 26) // how many ops needed\\n    for i := range s {\\n        if s[i] != t[i] {  // needs shifting\\n            opsNeeded := int(t[i] + 26 - s[i]) % 26\\n            turn := opsNeeded + 26 * cache[opsNeeded]\\n            cache[opsNeeded]++\\n            \\n            if turn > k {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    cache := make([]int, 26) // how many ops needed\\n    for i := range s {\\n        if s[i] != t[i] {  // needs shifting\\n            opsNeeded := int(t[i] + 26 - s[i]) % 26\\n            turn := opsNeeded + 26 * cache[opsNeeded]\\n            cache[opsNeeded]++\\n            \\n            if turn > k {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605985,
                "title": "c-52ms-99-45-simple-easy-small-time-on-space-o1-operators-only-and",
                "content": "Runtime: 52 ms, faster than 99.45% of C++ online submissions for Can Convert String in K Moves.\\nMemory Usage: 17.7 MB, less than 77.35% of C++ online submissions for Can Convert String in K Moves.\\n\\n```\\nclass Solution {\\npublic:\\n  bool canConvertString(string s, string t, int k) {\\n    if(s.size() != t.size()) return false;\\n    int table[26];\\n    for(int i = 0; i != 26; i++) table[i] = i - 26;\\n    \\n    for(int i = 0; i != s.size(); i++)\\n      if(int def = t[i] - s[i])\\n        if((table[def > 0 ? def : def += 26] += 26) > k) return false;      \\n    \\n    return true;      \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool canConvertString(string s, string t, int k) {\\n    if(s.size() != t.size()) return false;\\n    int table[26];\\n    for(int i = 0; i != 26; i++) table[i] = i - 26;\\n    \\n    for(int i = 0; i != s.size(); i++)\\n      if(int def = t[i] - s[i])\\n        if((table[def > 0 ? def : def += 26] += 26) > k) return false;      \\n    \\n    return true;      \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588760,
                "title": "clearly-explained-python3-faster-than-91",
                "content": "```\\n#Faster than 91% of submissions\\n\\ndef rightmost_argmax(l):\\n    #Return the index and element of the largest element in l that\\'s furthest to the right\\n    i,e=max(enumerate(l),key=lambda x:x[::-1])\\n    return i,e\\n\\ndef min_k(s,t):\\n    \\n    #Assert s and t are two lower-case alphabetical strings of the same length\\n    assert len(s)==len(t) and isinstance(s,str) and isinstance(t,str)\\n    assert s.isalpha() and t.isalpha()\\n    assert s==s.lower() and t==t.lower()\\n\\n    #If s and t are the same string, we don\\'t need any shifts\\n    if s==t:\\n        return 0\\n    \\n    #The rest of this code assumes we need at least one shift\\n    \\n    #Calculate required shifts between letters (d=deltas)\\n    d=[(ord(y)-ord(x))%26 for x,y in zip(s,t)]\\n    \\n    #All elements in d should be integers between 0 and 25 because of the modulo\\n    assert max(d)<=25\\n    \\n    #Calculate a histogram of the elements in d\\n    h=[0]*26 \\n    for x in d:\\n        h[x]+=1\\n        \\n    #Ignore the times we didn\\'t need to change anything\\n    h[0]=0\\n    \\n    #At least one element needs to be changed, because we know if we\\'ve reached this line s!=t\\n    assert not all(x==0 for x in d)\\n    \\n    #This is the main solution here: Whatever shift we need more than once needs to wrap around the 26 letters that many times (the 26*(e-1)), then shift a little more (the +i term)\\n    i,e=rightmost_argmax(h)\\n    return 26*(e-1)+i\\n\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        try:\\n            return k>=min_k(s,t)\\n        except AssertionError:\\n            return False\\n        ```",
                "solutionTags": [],
                "code": "```\\n#Faster than 91% of submissions\\n\\ndef rightmost_argmax(l):\\n    #Return the index and element of the largest element in l that\\'s furthest to the right\\n    i,e=max(enumerate(l),key=lambda x:x[::-1])\\n    return i,e\\n\\ndef min_k(s,t):\\n    \\n    #Assert s and t are two lower-case alphabetical strings of the same length\\n    assert len(s)==len(t) and isinstance(s,str) and isinstance(t,str)\\n    assert s.isalpha() and t.isalpha()\\n    assert s==s.lower() and t==t.lower()\\n\\n    #If s and t are the same string, we don\\'t need any shifts\\n    if s==t:\\n        return 0\\n    \\n    #The rest of this code assumes we need at least one shift\\n    \\n    #Calculate required shifts between letters (d=deltas)\\n    d=[(ord(y)-ord(x))%26 for x,y in zip(s,t)]\\n    \\n    #All elements in d should be integers between 0 and 25 because of the modulo\\n    assert max(d)<=25\\n    \\n    #Calculate a histogram of the elements in d\\n    h=[0]*26 \\n    for x in d:\\n        h[x]+=1\\n        \\n    #Ignore the times we didn\\'t need to change anything\\n    h[0]=0\\n    \\n    #At least one element needs to be changed, because we know if we\\'ve reached this line s!=t\\n    assert not all(x==0 for x in d)\\n    \\n    #This is the main solution here: Whatever shift we need more than once needs to wrap around the 26 letters that many times (the 26*(e-1)), then shift a little more (the +i term)\\n    i,e=rightmost_argmax(h)\\n    return 26*(e-1)+i\\n\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        try:\\n            return k>=min_k(s,t)\\n        except AssertionError:\\n            return False\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 1574043,
                "title": "10-line-of-code-simple-o-n-solution-and-o-1-space-solution-easy-and-cake-walk",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size() or k==0) return false;\\n        vector<int>vec;\\n        int mp[26]; memset(mp,0,sizeof(mp));\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int diff = t[i]-s[i];\\n            if(diff<0) diff+=26;\\n            \\n            if(diff>0)\\n            {\\n                vec.push_back(mp[diff]*26 + diff);\\n                mp[diff]++;\\n            }\\n        }\\n        \\n        \\n        return (*max_element(vec.begin(),vec.end())<=k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size() or k==0) return false;\\n        vector<int>vec;\\n        int mp[26]; memset(mp,0,sizeof(mp));\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int diff = t[i]-s[i];\\n            if(diff<0) diff+=26;\\n            \\n            if(diff>0)\\n            {\\n                vec.push_back(mp[diff]*26 + diff);\\n                mp[diff]++;\\n            }\\n        }\\n        \\n        \\n        return (*max_element(vec.begin(),vec.end())<=k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528283,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int n = s.size(), nn = t.size();\\n        if(n != nn) {\\n            return false;\\n        }\\n        unordered_map<int,int> m;\\n        for(int i=0; i<n; i++) {\\n            if(s[i] == t[i]) {\\n                continue;\\n            }\\n            int a = t[i] - \\'a\\';\\n            int b = s[i] - \\'a\\';\\n            int k;\\n            if(a > b) {\\n                k = a-b;\\n            } else {\\n                k = 26 - (b-a);\\n            }\\n            m[k]++;\\n        }\\n        for(auto x: m) {\\n            int a = x.first;\\n            int b = x.second;\\n            while(b--) {\\n                if(a > k) {\\n                    return false;\\n                }\\n                a += 26;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int n = s.size(), nn = t.size();\\n        if(n != nn) {\\n            return false;\\n        }\\n        unordered_map<int,int> m;\\n        for(int i=0; i<n; i++) {\\n            if(s[i] == t[i]) {\\n                continue;\\n            }\\n            int a = t[i] - \\'a\\';\\n            int b = s[i] - \\'a\\';\\n            int k;\\n            if(a > b) {\\n                k = a-b;\\n            } else {\\n                k = 26 - (b-a);\\n            }\\n            m[k]++;\\n        }\\n        for(auto x: m) {\\n            int a = x.first;\\n            int b = x.second;\\n            while(b--) {\\n                if(a > k) {\\n                    return false;\\n                }\\n                a += 26;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527738,
                "title": "java-14ms-t-c-o-n-s-c-o-26-easy",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int len1 = s.length(), len2 = t.length();\\n        \\n        if(len1 != len2)\\n            return false;\\n        \\n        if(s.equals(t))\\n            return true;\\n        \\n        int[] Freq = new int[26];\\n        \\n        int multiple = k / 26;\\n        for(int i = 0; i < 26; i++) {\\n            Freq[i] = multiple;\\n        }\\n        \\n        int rem = k % 26;\\n        for(int i = 1; i <= rem; i++)\\n            Freq[i]++;\\n        \\n        int movesRemaining = k;\\n        \\n        for(int i = 0; i < len1; i++) {\\n            char ch1 = s.charAt(i);\\n            char ch2 = t.charAt(i);\\n            \\n            if(ch1 == ch2) {\\n                movesRemaining--;\\n                continue;\\n            }\\n            \\n            int diff = (ch2 - ch1 + 26) % 26;\\n            \\n            if(Freq[diff] > 0) {\\n                Freq[diff]--;\\n                movesRemaining--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return movesRemaining >= 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int len1 = s.length(), len2 = t.length();\\n        \\n        if(len1 != len2)\\n            return false;\\n        \\n        if(s.equals(t))\\n            return true;\\n        \\n        int[] Freq = new int[26];\\n        \\n        int multiple = k / 26;\\n        for(int i = 0; i < 26; i++) {\\n            Freq[i] = multiple;\\n        }\\n        \\n        int rem = k % 26;\\n        for(int i = 1; i <= rem; i++)\\n            Freq[i]++;\\n        \\n        int movesRemaining = k;\\n        \\n        for(int i = 0; i < len1; i++) {\\n            char ch1 = s.charAt(i);\\n            char ch2 = t.charAt(i);\\n            \\n            if(ch1 == ch2) {\\n                movesRemaining--;\\n                continue;\\n            }\\n            \\n            int diff = (ch2 - ch1 + 26) % 26;\\n            \\n            if(Freq[diff] > 0) {\\n                Freq[diff]--;\\n                movesRemaining--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return movesRemaining >= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446966,
                "title": "go-o-n-time-o-1-space-1-pass",
                "content": "```go\\nfunc canConvertString(s string, t string, k int) bool {\\n\\tif len(s) != len(t) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tvar shifts [26]int // how many times we need to shift n steps?\\n\\n\\tfor i, c := range s {\\n\\t\\tx := int(c - \\'a\\')\\n\\t\\ty := int(t[i] - \\'a\\')\\n\\n\\t\\tif x != y {\\n\\t\\t\\tstep := (y - x + 26) % 26\\n\\t\\t\\tshifts[step]++\\n\\t\\t\\tif step + (shifts[step]-1)*26 >k {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc canConvertString(s string, t string, k int) bool {\\n\\tif len(s) != len(t) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tvar shifts [26]int // how many times we need to shift n steps?\\n\\n\\tfor i, c := range s {\\n\\t\\tx := int(c - \\'a\\')\\n\\t\\ty := int(t[i] - \\'a\\')\\n\\n\\t\\tif x != y {\\n\\t\\t\\tstep := (y - x + 26) % 26\\n\\t\\t\\tshifts[step]++\\n\\t\\t\\tif step + (shifts[step]-1)*26 >k {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428497,
                "title": "easy-c-map-solution",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int n=s.length();\\n        if(s.length()!=t.length())\\n            return false;\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=t[i])\\n            {\\n                int z=t[i]-s[i];\\n                if(z<0)\\n                    z+=26;\\n                mp[z]++;\\n            }\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.first>k)\\n                return false;\\n            if(it.second>1)\\n            {\\n                mp[it.first+26]+=it.second-1;\\n            }\\n        }\\n        return true;\\n    }\\n};``\\nUpvote if you like :)",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1423160,
                "title": "python-3-using-hashmap",
                "content": "```\\ndef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\tls, lt = len(s), len(t)\\n\\tif ls!=lt:\\n\\t\\treturn False\\n\\n\\tdone = {}\\n\\n\\tfor i in range(0, ls):\\n\\t\\tif s[i]==t[i]:\\n\\t\\t\\tcontinue\\n\\t\\tif s[i]<t[i]:\\n\\t\\t\\tmove = ord(t[i])-ord(s[i])\\n\\t\\telse:\\n\\t\\t\\tmove = 26-(ord(s[i])-96)+(ord(t[i])-96)\\n\\n\\t\\tif move in done:\\n\\t\\t\\tdone[move]+=1\\n\\t\\t\\tmove+=(done[move]-1)*26\\n\\t\\telse:\\n\\t\\t\\tdone[move] = 1\\n\\n\\t\\tif move>k:\\n\\t\\t\\treturn False\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\tls, lt = len(s), len(t)\\n\\tif ls!=lt:\\n\\t\\treturn False\\n\\n\\tdone = {}\\n\\n\\tfor i in range(0, ls):\\n\\t\\tif s[i]==t[i]:\\n\\t\\t\\tcontinue\\n\\t\\tif s[i]<t[i]:\\n\\t\\t\\tmove = ord(t[i])-ord(s[i])\\n\\t\\telse:\\n\\t\\t\\tmove = 26-(ord(s[i])-96)+(ord(t[i])-96)\\n\\n\\t\\tif move in done:\\n\\t\\t\\tdone[move]+=1\\n\\t\\t\\tmove+=(done[move]-1)*26\\n\\t\\telse:\\n\\t\\t\\tdone[move] = 1\\n\\n\\t\\tif move>k:\\n\\t\\t\\treturn False\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1366245,
                "title": "c-easy-multiplier-tracker",
                "content": "```\\npublic bool CanConvertString(string s, string t, int k) {\\n\\t//TAKING care of base case\\n\\n\\tif(s.Length != t.Length) return false;\\n\\t //Keep track of counter of multiplier\\n\\tint [] mul = new int[26];\\n\\n\\tfor(int i = 0 ; i < s.Length ; i++)\\n\\t{\\n\\t\\t//here we wre finding the shift\\n\\t\\tint shift = t[i] - s[i] + (s[i] > t[i] ? 26 :0);\\n\\n\\t\\t//now check the moves should not greater then k\\n\\n\\t\\tif(shift !=0 && shift + mul[shift] *26 >k)\\n\\t\\t\\treturn false;\\n\\n\\t\\tmul[shift]++;\\n\\t}\\n\\n\\treturn true;\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic bool CanConvertString(string s, string t, int k) {\\n\\t//TAKING care of base case\\n\\n\\tif(s.Length != t.Length) return false;\\n\\t //Keep track of counter of multiplier\\n\\tint [] mul = new int[26];\\n\\n\\tfor(int i = 0 ; i < s.Length ; i++)\\n\\t{\\n\\t\\t//here we wre finding the shift\\n\\t\\tint shift = t[i] - s[i] + (s[i] > t[i] ? 26 :0);\\n\\n\\t\\t//now check the moves should not greater then k\\n\\n\\t\\tif(shift !=0 && shift + mul[shift] *26 >k)\\n\\t\\t\\treturn false;\\n\\n\\t\\tmul[shift]++;\\n\\t}\\n\\n\\treturn true;\\n}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1312263,
                "title": "c-solution-o-n-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int,int> m;\\n        if(s.length()!=t.length())\\n            return(false);\\n        int q=k/26,o=k%26;\\n        for(int l=0;l<=25;l++)\\n        {\\n            if(l<=o)\\n                m[l]++;\\n            m[l]+=q;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int p=t[i]-s[i];\\n            if(p<0)\\n            {\\n                p=(\\'z\\'-s[i])+1+(t[i]-\\'a\\');\\n            }\\n            if(p>0)\\n            {\\n                if(m[p]==0)\\n                {\\n                    return(false);\\n                }\\n                m[p]--;\\n            }\\n        }\\n        return(true);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int,int> m;\\n        if(s.length()!=t.length())\\n            return(false);\\n        int q=k/26,o=k%26;\\n        for(int l=0;l<=25;l++)\\n        {\\n            if(l<=o)\\n                m[l]++;\\n            m[l]+=q;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int p=t[i]-s[i];\\n            if(p<0)\\n            {\\n                p=(\\'z\\'-s[i])+1+(t[i]-\\'a\\');\\n            }\\n            if(p>0)\\n            {\\n                if(m[p]==0)\\n                {\\n                    return(false);\\n                }\\n                m[p]--;\\n            }\\n        }\\n        return(true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309687,
                "title": "go-solution",
                "content": "//credits: https://leetcode.com/problems/can-convert-string-in-k-moves/discuss/1268156/Easy-C%2B%2B-solution-using-Map\\n```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s)!=len(t) {\\n        return false\\n    }\\n    val:=0\\n    m:=make(map[int]int)\\n    for i, _ := range s {\\n        val = int(t[i])-int(s[i])\\n        if val < 0  {\\n            val = 26-abs(val)\\n        }  \\n        if val >0 {\\n            m[val]+=1\\n        }  \\n    }\\n    for key, v := range m {\\n        if k<(26*(v-1)+key) {\\n            return false\\n        }\\n    }\\n    return true\\n}\\nfunc abs(n int) int {\\n    if n<0 {\\n        return -n\\n    }\\n    return n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s)!=len(t) {\\n        return false\\n    }\\n    val:=0\\n    m:=make(map[int]int)\\n    for i, _ := range s {\\n        val = int(t[i])-int(s[i])\\n        if val < 0  {\\n            val = 26-abs(val)\\n        }  \\n        if val >0 {\\n            m[val]+=1\\n        }  \\n    }\\n    for key, v := range m {\\n        if k<(26*(v-1)+key) {\\n            return false\\n        }\\n    }\\n    return true\\n}\\nfunc abs(n int) int {\\n    if n<0 {\\n        return -n\\n    }\\n    return n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1256317,
                "title": "c-100-100",
                "content": "```\\nbool canConvertString(char * s, char * t, int k){\\n    int seen[26]={-26, -26, -26, -26, -26, -26, -26, -26, -26,\\n                  -26, -26, -26, -26, -26, -26, -26, -26, -26,\\n                  -26, -26, -26, -26, -26, -26, -26, -26};\\n    while (*s != 0 && *t != 0) {\\n        int d;\\n        if ((d = *t++ - *s++)==0) {\\n            continue;\\n        } else if (d < 0) {\\n            d += 26;\\n        }\\n        if ((d += seen[d] += 26) > k) {\\n            return false;\\n        }\\n    }\\n    return (*t == 0 && *s == 0);\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(char * s, char * t, int k){\\n    int seen[26]={-26, -26, -26, -26, -26, -26, -26, -26, -26,\\n                  -26, -26, -26, -26, -26, -26, -26, -26, -26,\\n                  -26, -26, -26, -26, -26, -26, -26, -26};\\n    while (*s != 0 && *t != 0) {\\n        int d;\\n        if ((d = *t++ - *s++)==0) {\\n            continue;\\n        } else if (d < 0) {\\n            d += 26;\\n        }\\n        if ((d += seen[d] += 26) > k) {\\n            return false;\\n        }\\n    }\\n    return (*t == 0 && *s == 0);\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1256309,
                "title": "python-highly-optimized",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        seen = [-26] * 26\\n        for sc, tc in zip(s, t):\\n            d = ord(tc) - ord(sc)\\n            if d == 0:\\n                continue\\n            elif d < 0:\\n                d += 26\\n            seen[d] += 26\\n            d += seen[d]\\n            if d > k:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        seen = [-26] * 26\\n        for sc, tc in zip(s, t):\\n            d = ord(tc) - ord(sc)\\n            if d == 0:\\n                continue\\n            elif d < 0:\\n                d += 26\\n            seen[d] += 26\\n            d += seen[d]\\n            if d > k:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253830,
                "title": "easy-c-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size()) return false;\\n        vector<int>diff(26,0);\\n        //cout<<(int)\\'z\\' - (int)\\'source\\' + (int)\\'tar\\' - (int)\\'a\\' + 1<<endl;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==t[i]){\\n                continue;\\n            }\\n            if(t[i] > s[i]){\\n                int id = t[i] - s[i];\\n                diff[id]++;\\n            }\\n            else{\\n                int d =( (int)\\'z\\' - (int)s[i] + (int)t[i] - (int)\\'a\\' + 1);\\n                diff[d]++;\\n            }\\n        }\\n        for(int i = 1;i<26;i++){\\n            int tar = i + (26 * (diff[i] - 1));\\n            if(tar > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size()) return false;\\n        vector<int>diff(26,0);\\n        //cout<<(int)\\'z\\' - (int)\\'source\\' + (int)\\'tar\\' - (int)\\'a\\' + 1<<endl;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==t[i]){\\n                continue;\\n            }\\n            if(t[i] > s[i]){\\n                int id = t[i] - s[i];\\n                diff[id]++;\\n            }\\n            else{\\n                int d =( (int)\\'z\\' - (int)s[i] + (int)t[i] - (int)\\'a\\' + 1);\\n                diff[d]++;\\n            }\\n        }\\n        for(int i = 1;i<26;i++){\\n            int tar = i + (26 * (diff[i] - 1));\\n            if(tar > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1248115,
                "title": "js-easy-to-follow-time-o-n-space-o-1",
                "content": "```\\nvar canConvertString = function(s, t, k) {\\n    let numMoves = 0;\\n    let shiftCountMap = {};\\n    let leastNumMoves = 0;\\n    let getMoves = function(from, to) {\\n      let result = to.charCodeAt(0) - from.charCodeAt(0);\\n      return result < 0 ? 26 + result : result;\\n    }\\n\\n    if(s.length !== t.length) {\\n      return false;\\n    }\\n\\n    for(let i = 0; i < s.length; i++) {\\n      numMoves = getMoves(s.charAt(i), t.charAt(i));\\n      shiftCountMap[numMoves] = !!shiftCountMap[numMoves] ? shiftCountMap[numMoves] + 1 : 1;\\n      let temp = (26 * (shiftCountMap[numMoves] - 1)) + numMoves;\\n      if(leastNumMoves < temp && numMoves !== 0){\\n        leastNumMoves = temp;\\n      }\\n    }\\n    return k >= leastNumMoves;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConvertString = function(s, t, k) {\\n    let numMoves = 0;\\n    let shiftCountMap = {};\\n    let leastNumMoves = 0;\\n    let getMoves = function(from, to) {\\n      let result = to.charCodeAt(0) - from.charCodeAt(0);\\n      return result < 0 ? 26 + result : result;\\n    }\\n\\n    if(s.length !== t.length) {\\n      return false;\\n    }\\n\\n    for(let i = 0; i < s.length; i++) {\\n      numMoves = getMoves(s.charAt(i), t.charAt(i));\\n      shiftCountMap[numMoves] = !!shiftCountMap[numMoves] ? shiftCountMap[numMoves] + 1 : 1;\\n      let temp = (26 * (shiftCountMap[numMoves] - 1)) + numMoves;\\n      if(leastNumMoves < temp && numMoves !== 0){\\n        leastNumMoves = temp;\\n      }\\n    }\\n    return k >= leastNumMoves;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240148,
                "title": "c-count",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) \\n    {\\n        if(s.size()!=t.size())\\n            return false;\\n        vector<int>m(26,0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int diff=t[i]-s[i];\\n            if(diff==0)\\n                continue;\\n            if(diff<0)\\n                diff+=26;\\n            m[diff]++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(m[i]==0)\\n                continue;\\n            int req=(26*(m[i]-1))+i;\\n            if(req>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) \\n    {\\n        if(s.size()!=t.size())\\n            return false;\\n        vector<int>m(26,0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int diff=t[i]-s[i];\\n            if(diff==0)\\n                continue;\\n            if(diff<0)\\n                diff+=26;\\n            m[diff]++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(m[i]==0)\\n                continue;\\n            int req=(26*(m[i]-1))+i;\\n            if(req>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234636,
                "title": "swift-solution",
                "content": "Obviously if `s.count != t.count`, then the answer is `false`. Let\\'s add that check at the beginning.\\n\\nIt makes sense to perform shifts in the range from 1 to 25. We can perform each shift `k / 26 + (k % 26 >= shift ? 1 : 0)` times. Let\\'s fill the `shifts` array with the number of available shifts.\\n\\nConsider all indexes `i` in range `0 <= i < s.count` where `s[i] != t[i]` and calculate the `shift` to get `t[i]` from `s[i]`. If `shifts[shift] == 0` then the answer is `false`, else decrement `shifts[shift]` by 1.\\n```\\nclass Solution {\\n    func s2i(_ s: String) -> [Int] {\\n        return s.map({ Int($0.asciiValue ?? 97) - 97 })\\n    }\\n    func canConvertString(_ s: String, _ t: String, _ k: Int) -> Bool {\\n        guard s.count == t.count else { return false }\\n        let alphabet = 26, s = s2i(s), t = s2i(t), n = s.count\\n        var shifts = [Int](repeating: k / alphabet, count: alphabet)\\n        for i in stride(from: 1, through: k % alphabet, by: 1) {\\n            shifts[i] += 1\\n        }\\n        for i in 0..<n where s[i] != t[i] {\\n            let shift = t[i] - s[i] + (t[i] > s[i] ? 0 : alphabet)\\n            shifts[shift] -= 1\\n            if shifts[shift] < 0 {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func s2i(_ s: String) -> [Int] {\\n        return s.map({ Int($0.asciiValue ?? 97) - 97 })\\n    }\\n    func canConvertString(_ s: String, _ t: String, _ k: Int) -> Bool {\\n        guard s.count == t.count else { return false }\\n        let alphabet = 26, s = s2i(s), t = s2i(t), n = s.count\\n        var shifts = [Int](repeating: k / alphabet, count: alphabet)\\n        for i in stride(from: 1, through: k % alphabet, by: 1) {\\n            shifts[i] += 1\\n        }\\n        for i in 0..<n where s[i] != t[i] {\\n            let shift = t[i] - s[i] + (t[i] > s[i] ? 0 : alphabet)\\n            shifts[shift] -= 1\\n            if shifts[shift] < 0 {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226937,
                "title": "python-o-n-with-constant-memory-storage",
                "content": "```Python\\n\"Medium 1540. Can Convert String in K Moves\"\\n# https://leetcode.com/problems/can-convert-string-in-k-moves/\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \"Method 0 47.34%, self done, should be constant memory and time.\"\\n        # Posted to https://leetcode.com/problems/can-convert-string-in-k-moves/discuss/1226937/python-O(n)-with-constant-memory-storage.\\n        if len(s) != len(t): return False\\n        calDiff = lambda l, r: (ord(r) - ord(l)) % 26\\n        gaps = [calDiff(l, r) for l, r in zip(s, t)]\\n        base, remainder = k // 26, k%26\\n        choices = [base for _ in range(26)]\\n        for i in range(remainder + 1):\\n            choices[i] += 1\\n        for gap in gaps:\\n            if gap == 0: continue\\n            choices[gap] -= 1\\n            if choices[gap] == -1: return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```Python\\n\"Medium 1540. Can Convert String in K Moves\"\\n# https://leetcode.com/problems/can-convert-string-in-k-moves/\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \"Method 0 47.34%, self done, should be constant memory and time.\"\\n        # Posted to https://leetcode.com/problems/can-convert-string-in-k-moves/discuss/1226937/python-O(n)-with-constant-memory-storage.\\n        if len(s) != len(t): return False\\n        calDiff = lambda l, r: (ord(r) - ord(l)) % 26\\n        gaps = [calDiff(l, r) for l, r in zip(s, t)]\\n        base, remainder = k // 26, k%26\\n        choices = [base for _ in range(26)]\\n        for i in range(remainder + 1):\\n            choices[i] += 1\\n        for gap in gaps:\\n            if gap == 0: continue\\n            choices[gap] -= 1\\n            if choices[gap] == -1: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223574,
                "title": "map",
                "content": "bool canConvertString(string s, string t, int k) {\\n        \\n        \\n        int n=t.length();\\n        int count=0,i=0;\\n        unordered_map<int,int> m;\\n        \\n      while(i<n && count <=k){\\n            \\n          if(s[i]!=t[i]){\\n            \\n                count=t[i]-s[i];\\n                if(count<0)\\n                    count+=26;\\n        \\n                if(m.find(count)!=m.end()){ \\n                   m[count]++;\\n                   count+=(m[count]-1)*26;\\n                }\\n                m[count]++;\\n               if(count<=k)       \\n                 s[i]=t[i];\\n          }\\n            \\n            i++;\\n        }\\n      \\n    return s==t;       \\n     }\\n        };",
                "solutionTags": [],
                "code": "bool canConvertString(string s, string t, int k) {\\n        \\n        \\n        int n=t.length();\\n        int count=0,i=0;\\n        unordered_map<int,int> m;\\n        \\n      while(i<n && count <=k){\\n            \\n          if(s[i]!=t[i]){\\n            \\n                count=t[i]-s[i];\\n                if(count<0)\\n                    count+=26;\\n        \\n                if(m.find(count)!=m.end()){ \\n                   m[count]++;\\n                   count+=(m[count]-1)*26;\\n                }\\n                m[count]++;\\n               if(count<=k)       \\n                 s[i]=t[i];\\n          }\\n            \\n            i++;\\n        }\\n      \\n    return s==t;       \\n     }\\n        };",
                "codeTag": "Unknown"
            },
            {
                "id": 1214680,
                "title": "simple-to-understand-java-soln",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        int mp[] = new int[100001];\\n        if(s.length() != t.length())\\n            return false;\\n        \\n        int n = s.length();\\n        \\n        for(int i=0;i<n;i++) {\\n            \\n            int diff = t.charAt(i) - s.charAt(i);\\n            \\n            if(diff == 0)\\n                continue;\\n            if(diff > 0) {                      \\n                int z = mp[diff] * 26 + diff;\\n                if(z > k)\\n                    return false;                \\n                mp[diff]++;                \\n            }\\n            else {               \\n                int z =  mp[diff + 26] * 26 + diff + 26;\\n                if(z > k)\\n                    return false;                \\n                mp[diff + 26]++;               \\n            }           \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        int mp[] = new int[100001];\\n        if(s.length() != t.length())\\n            return false;\\n        \\n        int n = s.length();\\n        \\n        for(int i=0;i<n;i++) {\\n            \\n            int diff = t.charAt(i) - s.charAt(i);\\n            \\n            if(diff == 0)\\n                continue;\\n            if(diff > 0) {                      \\n                int z = mp[diff] * 26 + diff;\\n                if(z > k)\\n                    return false;                \\n                mp[diff]++;                \\n            }\\n            else {               \\n                int z =  mp[diff + 26] * 26 + diff + 26;\\n                if(z > k)\\n                    return false;                \\n                mp[diff + 26]++;               \\n            }           \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185999,
                "title": "c-histogram-beats-100-of-submissions",
                "content": "## The Problem\\n\\nWhen we have to shift a letter by i spaces, we want to record that shift in some container. At some point we want to check that this shift is less or equal to k.\\n\\nOur problem is in checking if there is an existing shift of the same distance. Each time there is a letter attempting the same distance of shift, we need one of those letters to be shifted by an additional 26 spaces. The second time we find this occurance we need to shift by 2x26, and so on.\\n\\nThe insight is that we can store a count of the number of letters that shift by the same amount, then we can calculate the number of additional shifts that the final letter needs to be shifted to abide by the unique i restriction in the question.\\n\\n## The Solution\\n\\nWe can create a histogram of distances by using an array of integers initialized at zero. We then iterate over both strings, find the character distance, and then increase the histogram value at that distance location as long as the distance is not zero. \\n\\n### Histogram Checks\\n\\nThe check against K can be performed either in-loop or on its own after the main while-loop. The code below shows the in-loop solution. \\n\\nThe in-loop method allows us to quit early if we find that a histogram value is violating our K requirement. However, the in-loop solutions adds a constant-time overhead for every operation. \\n\\nChecking the histogram values after the main while-loop requires far fewer (25) checks, but we have to compare entire strings and cannot exit early.\\n\\nI have found similar performance (24ms and 28ms) submitting both solutions. This seems to be similar within the variance that leetcode has for submissions.\\n\\n### Perform fewer K checks\\n\\nWe do not need to check against K for every single item we place into the histogram. We can keep track of the max number of duplicate distances in the histogram (largest value in the histogram), and only check against K if we just increased a histogram value to an equal or greater value.\\n\\nThe reason we can avoid these checks is that if the histogram value we just placed is smaller than the max previously seen histogram value, then we cannot have just placed a value greater than K, otherwise we would have exited when we had seen that max previously seen histogram value.\\n\\n### io tricks\\n\\nLeetcode appears to include the io time in the submission benchmarking time. In C++ we can reduce that overhead by including the two lines at the top of the code. The first line removes the synchronization between C and C++ standard streams, and the second line unties cin from cout. \\n\\nThese lines reduce the runtime by about half. I\\'m not sure I like that io tricks can decrease runtime more than my other optimizations, but this is the world that we live in.\\n\\n\\n\\n```\\n    bool canConvertString(string s, string t, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        if (s.size() != t.size())\\n        {\\n            return false;\\n        }\\n        auto it_s = s.begin();\\n        auto it_t = t.begin();\\n        int histogram[25] = {};\\n        int current_max_steps = 0;\\n        int ch_diff, max_steps;\\n        while(it_s != s.end()){\\n             ch_diff = (*it_t - *it_s + 26) % 26;\\n            if(ch_diff != 0){\\n                histogram[ch_diff-1] ++;\\n                if (current_max_steps <= histogram[ch_diff-1])\\n                {\\n                    current_max_steps = histogram[ch_diff-1];\\n                    max_steps = ch_diff + 26 * (histogram[ch_diff-1] - 1);\\n                    if (max_steps > k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n            it_s++; it_t++;\\n        }\\n        return true;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    bool canConvertString(string s, string t, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        if (s.size() != t.size())\\n        {\\n            return false;\\n        }\\n        auto it_s = s.begin();\\n        auto it_t = t.begin();\\n        int histogram[25] = {};\\n        int current_max_steps = 0;\\n        int ch_diff, max_steps;\\n        while(it_s != s.end()){\\n             ch_diff = (*it_t - *it_s + 26) % 26;\\n            if(ch_diff != 0){\\n                histogram[ch_diff-1] ++;\\n                if (current_max_steps <= histogram[ch_diff-1])\\n                {\\n                    current_max_steps = histogram[ch_diff-1];\\n                    max_steps = ch_diff + 26 * (histogram[ch_diff-1] - 1);\\n                    if (max_steps > k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n            it_s++; it_t++;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1171843,
                "title": "easy-c-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())return false;\\n        unordered_map<int,int> vis;\\n        priority_queue<long long> que;\\n        for(int i=0;i<s.length();i++){\\n            int shft=t[i]-s[i];\\n            if(shft==0)continue;\\n            shft=shft<0?shft+26:shft;\\n            long long x=shft+26*vis[shft]; //is same rotn is there we have to move it to next cycle\\n            vis[shft]++;\\n            que.push(x);\\n        }\\n        if(!que.empty()&&que.top()>k)return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())return false;\\n        unordered_map<int,int> vis;\\n        priority_queue<long long> que;\\n        for(int i=0;i<s.length();i++){\\n            int shft=t[i]-s[i];\\n            if(shft==0)continue;\\n            shft=shft<0?shft+26:shft;\\n            long long x=shft+26*vis[shft]; //is same rotn is there we have to move it to next cycle\\n            vis[shft]++;\\n            que.push(x);\\n        }\\n        if(!que.empty()&&que.top()>k)return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169219,
                "title": "detailed-o-n-time-o-1-space-solution",
                "content": "\\t// time complexity : O(n), space complexity : O(1)\\n\\t/*\\n\\t\\tapproach :\\n\\t\\t--> find the least amount of shift we need to do, to convert s[i] to t[i].\\n\\t\\t--> if that was done, then add 26 to it(As a shift amount can not be done more than once).\\n\\t\\t--> If that was also done add 26*2 to the least shift amount and so on.\\n\\t\\t--> Well the question is how to know the # of time we need to add 26.\\n\\t\\t--> For this we create a map of size 26. Cuz least shift can be upto 25, when \\'a\\' -> \\'z\\'.\\n\\t\\t--> map[i] = j means we added 26 upto j times for a shift by i.\\n\\t\\t--> But how to ensure that a particular value of shifting is not used more than once.\\n\\t\\t--> This is beacuse a * 26 + i != b * 26 + j for any value of a and b and i!=j and 1<=i,j<=25.\\n\\t*/\\n\\tclass Solution {\\n\\t\\tpublic boolean canConvertString(String s, String t, int k) {\\n\\t\\t\\tif(s.length()!=t.length())return false;\\n\\t\\t\\tint[] map = new int[26];\\n\\t\\t\\tfor(var i=0;i<s.length();i++){\\n\\t\\t\\t\\tchar c1 = s.charAt(i);\\n\\t\\t\\t\\tchar c2 = t.charAt(i);\\n\\t\\t\\t\\tif(c1==c2)continue;\\n\\t\\t\\t\\tint shifts  = 0;\\n\\t\\t\\t\\tif(c2>c1) shifts = c2-c1;\\n\\t\\t\\t\\telse shifts = \\'z\\'- c1 + 1 + c2-\\'a\\';\\n\\t\\t\\t\\tint totalShifts = 26*map[shifts] + shifts;\\n\\t\\t\\t\\tmap[shifts]++;\\n\\t\\t\\t\\tif(totalShifts>k)return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean canConvertString(String s, String t, int k) {\\n\\t\\t\\tif(s.length()!=t.length())return false;\\n\\t\\t\\tint[] map = new int[26];\\n\\t\\t\\tfor(var i=0;i<s.length();i++){\\n\\t\\t\\t\\tchar c1 = s.charAt(i);\\n\\t\\t\\t\\tchar c2 = t.charAt(i);\\n\\t\\t\\t\\tif(c1==c2)continue;\\n\\t\\t\\t\\tint shifts  = 0;\\n\\t\\t\\t\\tif(c2>c1) shifts = c2-c1;\\n\\t\\t\\t\\telse shifts = \\'z\\'- c1 + 1 + c2-\\'a\\';\\n\\t\\t\\t\\tint totalShifts = 26*map[shifts] + shifts;\\n\\t\\t\\t\\tmap[shifts]++;\\n\\t\\t\\t\\tif(totalShifts>k)return false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1167215,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) \\n    {\\n        if (s.length() != t.length()) return false;\\n        \\n        int diff[26];\\n        for (int i = 0; i<26; i++) diff[i] = i;\\n        for (int i = 0; i<s.length(); i++)\\n        {\\n            if (s[i] == t[i]) continue;\\n            int j = t[i]-s[i];\\n            if (j<0) j+= 26;\\n            if (diff[j] > k)\\n                return false;\\n            \\n            diff[j] += 26;\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) \\n    {\\n        if (s.length() != t.length()) return false;\\n        \\n        int diff[26];\\n        for (int i = 0; i<26; i++) diff[i] = i;\\n        for (int i = 0; i<s.length(); i++)\\n        {\\n            if (s[i] == t[i]) continue;\\n            int j = t[i]-s[i];\\n            if (j<0) j+= 26;\\n            if (diff[j] > k)\\n                return false;\\n            \\n            diff[j] += 26;\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159917,
                "title": "java-hashmap-o-n",
                "content": "```\\n\\tpublic boolean canConvertString(String s, String t, int k){\\n        if(s.length()!=t.length()) return false;\\n        Map<Integer,Integer> map= new HashMap<>();\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==t.charAt(i)) continue;\\n            int moves= 0;\\n            if(t.charAt(i)>s.charAt(i)) moves= t.charAt(i)-s.charAt(i);\\n            else{\\n                moves= \\'z\\'-s.charAt(i)+t.charAt(i)-\\'a\\'+1;\\n            }\\n            if(map.containsKey(moves)){\\n                int less26= moves;\\n                moves= map.get(moves)+26;\\n                map.replace(less26,moves);\\n            }else{\\n                map.put(moves,moves);\\n            } \\n            if(moves>k) return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic boolean canConvertString(String s, String t, int k){\\n        if(s.length()!=t.length()) return false;\\n        Map<Integer,Integer> map= new HashMap<>();\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==t.charAt(i)) continue;\\n            int moves= 0;\\n            if(t.charAt(i)>s.charAt(i)) moves= t.charAt(i)-s.charAt(i);\\n            else{\\n                moves= \\'z\\'-s.charAt(i)+t.charAt(i)-\\'a\\'+1;\\n            }\\n            if(map.containsKey(moves)){\\n                int less26= moves;\\n                moves= map.get(moves)+26;\\n                map.replace(less26,moves);\\n            }else{\\n                map.put(moves,moves);\\n            } \\n            if(moves>k) return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1145426,
                "title": "python3-explanation-runtime-and-space-analysis-o-n-time-o-1-space",
                "content": "**Explanation**\\nThe idea is to use a hashtable for the required shifts to transform one letter into another. It provides the next free number of shifts which is the initial number of shifts plus a multiple of `26`. Every time we access such a free number of shifts, we check if it is greater than `k`. If it is, `false` will be returned. In any other case, the next free number of shifts will be the current one plus `26`.\\n\\nExample: To transform `a` into `b` we need `1` shift. The next free number of shifts for this initial number of shifts will be `27`. If we now are asked to transform `b` into `c`, for instance, the required shifts will be `27` and the next free number of shifts `27 + 26 = 53` and so on.\\n________________________\\n**Definitions**\\n`n`: Size of `s` and `t` if `s = t`.\\n________________________\\n**Runtime Complexity**\\n`O(n)`\\n_______________________\\n**Space Complexity**\\n`O(1)`\\n_______________________\\n**Python Implementation**\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        shifts_to_next_shift = list(range(26))\\n        \\n        for i in range(len(s)):\\n            if s[i] != t[i]:\\n                shifts = ord(t[i]) - ord(s[i]) if s[i] < t[i] else ord(\"z\") - ord(s[i]) + 1 + ord(t[i]) - ord(\"a\")\\n                \\n                if shifts_to_next_shift[shifts] > k:\\n                    return False\\n                \\n                shifts_to_next_shift[shifts] += 26\\n                \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        shifts_to_next_shift = list(range(26))\\n        \\n        for i in range(len(s)):\\n            if s[i] != t[i]:\\n                shifts = ord(t[i]) - ord(s[i]) if s[i] < t[i] else ord(\"z\") - ord(s[i]) + 1 + ord(t[i]) - ord(\"a\")\\n                \\n                if shifts_to_next_shift[shifts] > k:\\n                    return False\\n                \\n                shifts_to_next_shift[shifts] += 26\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143035,
                "title": "c-solution-beats-80-o-n-time-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==t[i])\\n            {\\n                continue;\\n            }\\n            int diff=t[i]-s[i];\\n            if(t[i]<s[i])\\n            {\\n                diff+=26;\\n            }\\n            mp[diff]++;\\n        }\\n        unordered_map<int,int>::iterator itr;\\n        for(itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            int vg=itr->first;\\n            int yu=itr->second;\\n            int ans= vg + (26*(yu-1));\\n            if(ans>k)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==t[i])\\n            {\\n                continue;\\n            }\\n            int diff=t[i]-s[i];\\n            if(t[i]<s[i])\\n            {\\n                diff+=26;\\n            }\\n            mp[diff]++;\\n        }\\n        unordered_map<int,int>::iterator itr;\\n        for(itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            int vg=itr->first;\\n            int yu=itr->second;\\n            int ans= vg + (26*(yu-1));\\n            if(ans>k)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107285,
                "title": "c-solution-using-dictionary",
                "content": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        if(s.Length != t.Length) return false;\\n        int times = k/26;\\n        k %= 26;\\n        Dictionary<int, int> dict = new Dictionary<int, int>();\\n        for(int i=0; i<s.Length; i++)\\n        {\\n            if(s[i] == t[i]) continue;\\n            int shift = s[i]-t[i]>0? 26-s[i]+t[i] : t[i]-s[i];\\n            if(dict.ContainsKey(shift))\\n            {\\n                dict[shift]++;\\n            }\\n            else\\n            {\\n                dict.Add(shift, 1);\\n            }\\n            \\n            if(dict[shift] > times)\\n            {\\n                if(shift > k || dict[shift] - times > 1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        if(s.Length != t.Length) return false;\\n        int times = k/26;\\n        k %= 26;\\n        Dictionary<int, int> dict = new Dictionary<int, int>();\\n        for(int i=0; i<s.Length; i++)\\n        {\\n            if(s[i] == t[i]) continue;\\n            int shift = s[i]-t[i]>0? 26-s[i]+t[i] : t[i]-s[i];\\n            if(dict.ContainsKey(shift))\\n            {\\n                dict[shift]++;\\n            }\\n            else\\n            {\\n                dict.Add(shift, 1);\\n            }\\n            \\n            if(dict[shift] > times)\\n            {\\n                if(shift > k || dict[shift] - times > 1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102036,
                "title": "c-o-n-solution-maintain-counts-of-number-of-ways-to-make-1-25-steps",
                "content": "```\\nbool canConvertString(string s, string t, int k) {\\n\\tif (s.size() != t.size()) return false;\\n\\n\\t// Maintain a count of the number of times we can make\\n\\t// X number of shifts. X ranges from 1-25.\\n\\tint count[26] = {};\\n\\tfor (int i = 1; i < 26; i++) {\\n\\t\\tcount[i] = (k+26-i)/26;\\n\\t}\\n\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tif (s[i] == t[i]) continue;\\n\\n\\t\\tint shift = (t[i] + 26 - s[i]) % 26;\\n\\t\\t// If we have already used up all possible ways to\\n\\t\\t// make \\'shift\\' number of steps, string can\\'t be\\n\\t\\t// converted.\\n\\t\\tif (count[shift]-- == 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(string s, string t, int k) {\\n\\tif (s.size() != t.size()) return false;\\n\\n\\t// Maintain a count of the number of times we can make\\n\\t// X number of shifts. X ranges from 1-25.\\n\\tint count[26] = {};\\n\\tfor (int i = 1; i < 26; i++) {\\n\\t\\tcount[i] = (k+26-i)/26;\\n\\t}\\n\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tif (s[i] == t[i]) continue;\\n\\n\\t\\tint shift = (t[i] + 26 - s[i]) % 26;\\n\\t\\t// If we have already used up all possible ways to\\n\\t\\t// make \\'shift\\' number of steps, string can\\'t be\\n\\t\\t// converted.\\n\\t\\tif (count[shift]-- == 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570107,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 1824479,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 1570421,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 1574182,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 2044343,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 2007883,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            }
        ]
    }
]