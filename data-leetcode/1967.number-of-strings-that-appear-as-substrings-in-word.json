[
    {
        "title": "Unique Morse Code Words",
        "question_content": "International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows:\n\n\t'a' maps to \".-\",\n\t'b' maps to \"-...\",\n\t'c' maps to \"-.-.\", and so on.\n\nFor convenience, the full table for the 26 letters of the English alphabet is given below:\n\n[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\nGiven an array of strings words where each word can be written as a concatenation of the Morse code of each letter.\n\n\tFor example, \"cab\" can be written as \"-.-..--...\", which is the concatenation of \"-.-.\", \".-\", and \"-...\". We will call such a concatenation the transformation of a word.\n\nReturn the number of different transformations among all words we have.\n&nbsp;\nExample 1:\n\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\nOutput: 2\nExplanation: The transformation of each word is:\n\"gin\" -> \"--...-.\"\n\"zen\" -> \"--...-.\"\n\"gig\" -> \"--...--.\"\n\"msg\" -> \"--...--.\"\nThere are 2 different transformations: \"--...-.\" and \"--...--.\".\n\nExample 2:\n\nInput: words = [\"a\"]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 100\n\t1 <= words[i].length <= 12\n\twords[i] consists of lowercase English letters.",
        "solutions": [
            {
                "id": 120675,
                "title": "java-c-python-easy-and-concise-solution",
                "content": "\\n**Java**\\n```java\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] d = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        HashSet<String> s = new HashSet<>();\\n        for (String w : words) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = 0; i < w.length(); ++i)\\n                sb.append(d[w.charAt(i) - \\'a\\']);\\n            s.add(sb.toString());\\n        }\\n        return s.size();\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> d = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        unordered_set<string> s;\\n        for (auto w : words) {\\n            string code;\\n            for (auto c : w) code += d[c - \\'a\\'];\\n            s.insert(code);\\n        }\\n        return s.size();\\n    }\\n```\\n\\n**Python**\\n```python\\n    def uniqueMorseRepresentations(self, words):\\n        d = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\",\\n             \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\\n        return len({\\'\\'.join(d[ord(i) - ord(\\'a\\')] for i in w) for w in words})",
                "solutionTags": [],
                "code": "```java\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] d = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        HashSet<String> s = new HashSet<>();\\n        for (String w : words) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = 0; i < w.length(); ++i)\\n                sb.append(d[w.charAt(i) - \\'a\\']);\\n            s.add(sb.toString());\\n        }\\n        return s.size();\\n    }\\n```\n```cpp\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> d = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        unordered_set<string> s;\\n        for (auto w : words) {\\n            string code;\\n            for (auto c : w) code += d[c - \\'a\\'];\\n            s.insert(code);\\n        }\\n        return s.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329303,
                "title": "javascript-one-line-solution-w-explanation-52-ms-beats-94",
                "content": "**Approach**:\\nWe need to return the number of morse representations for the given list of words. The approach for this problem is as follows:\\n1. Look at each word in `words`.\\n2. For each word, look at each letter.\\n3. Get the morse representation of each letter\\n4. Build the word with the morse letter\\n5. Once we finished building the word, add it to our set if it isn\\'t already in there\\n6. Return the number of *unique* morse representations.\\n\\n**Solution**: \\n```js\\nconst alphabet = {\\n    a: \\'.-\\', b: \\'-...\\',   c: \\'-.-.\\', d: \\'-..\\', e: \\'.\\', f: \\'..-.\\', g: \\'--.\\', h: \\'....\\', i: \\'..\\',  j: \\'.---\\',  k: \\'-.-\\',  l: \\'.-..\\', m: \\'--\\',\\n    n: \\'-.\\',  o: \\'---\\', p: \\'.--.\\',  q: \\'--.-\\',  r: \\'.-.\\', s: \\'...\\', t: \\'-\\', u: \\'..-\\', v: \\'...-\\', w: \\'.--\\', x: \\'-..-\\',  y: \\'-.--\\', z: \\'--..\\' \\n}\\n\\n/**\\n * @param {string[]} words the word array to convert to morse\\n * @return {number} the length of unique morse representations\\n */\\nconst uniqueMorseRepresentations = words => {  \\n\\t// PREVIOUS SOLUTION:\\n\\t// return [...new Set(words.map(word => word.split(\\'\\').map(letter => alphabet[letter]).join(\\'\\')))].length\\n   \\n    // Edited on 9-9-2019\\n    return new Set(words.map(word => word.split(\\'\\').map(letter => alphabet[letter]).join(\\'\\'))).size\\n}\\n```\\n**Explanation**: \\nThis is a fun problem to apply [Array.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)! Since we\\'re changing every element in the array, `map()` works nicely.  We\\'ll use the example `words = [\\'gin\\', \\'zen\\', \\'gig\\', \\'msg\\']` to explain how this works:\\n\\n1. For each word, we\\'ll split the characters of each word with our first use of `map()`. We\\'ll have something like this after looking at one word:\\n\\n\\t```js  \\n\\t[ [\\'g\\', \\'i\\', \\'n\\'], \\'zen\\', \\'gig\\', \\'msg\\' ] \\n\\t ```\\n\\t\\n2. We\\'ll use `map()`  again inside our first map method. We\\'ll do this to look at each letter of the inner array to create a Morse Code word. \\n\\n3.  For each letter during our second use of `map()`, we\\'ll get the letter\\'s Morse Code, and build a word with it using `join(\\'\\')`. After one use of both `map()` methods, we\\'ll get the first Morse word for `\\'gin\\'`: \\n\\t```js  \\n\\t[\\'--...-.\\', \\'zen\\', \\'gig\\', \\'msg\\'] \\n\\t ```\\n\\n4. We\\'ll repeat steps 1-3 until we have an array of new Morse Code words:\\n\\n\\t```js\\n\\t[\\'--...-.\\', \\'--...-.\\', \\'--...--.\\', \\'--...--.\\']\\n\\t```\\n\\n\\n5. We\\'ll use JavaScript\\'s [Set Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) to only keep the unique representations. The Set constructor takes in an array, which will be the array shown in Step 2, and then removes duplicate elements, so we\\'ll only be left with unique Morse Code words:\\n\\n\\t```js\\n\\t[\\'--...-.\\', \\'--...--.\\']\\n\\t```\\n\\n(EDITED on September 9th, 2019)\\nFinally, we can return the size of the set\\n```js\\n    return new Set(words.map(word => word.split(\\'\\').map(letter => alphabet[letter]).join(\\'\\'))).size\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst alphabet = {\\n    a: \\'.-\\', b: \\'-...\\',   c: \\'-.-.\\', d: \\'-..\\', e: \\'.\\', f: \\'..-.\\', g: \\'--.\\', h: \\'....\\', i: \\'..\\',  j: \\'.---\\',  k: \\'-.-\\',  l: \\'.-..\\', m: \\'--\\',\\n    n: \\'-.\\',  o: \\'---\\', p: \\'.--.\\',  q: \\'--.-\\',  r: \\'.-.\\', s: \\'...\\', t: \\'-\\', u: \\'..-\\', v: \\'...-\\', w: \\'.--\\', x: \\'-..-\\',  y: \\'-.--\\', z: \\'--..\\' \\n}\\n\\n/**\\n * @param {string[]} words the word array to convert to morse\\n * @return {number} the length of unique morse representations\\n */\\nconst uniqueMorseRepresentations = words => {  \\n\\t// PREVIOUS SOLUTION:\\n\\t// return [...new Set(words.map(word => word.split(\\'\\').map(letter => alphabet[letter]).join(\\'\\')))].length\\n   \\n    // Edited on 9-9-2019\\n    return new Set(words.map(word => word.split(\\'\\').map(letter => alphabet[letter]).join(\\'\\'))).size\\n}\\n```\n```js  \\n\\t[ [\\'g\\', \\'i\\', \\'n\\'], \\'zen\\', \\'gig\\', \\'msg\\' ] \\n\\t ```\n```js  \\n\\t[\\'--...-.\\', \\'zen\\', \\'gig\\', \\'msg\\'] \\n\\t ```\n```js\\n\\t[\\'--...-.\\', \\'--...-.\\', \\'--...--.\\', \\'--...--.\\']\\n\\t```\n```js\\n\\t[\\'--...-.\\', \\'--...--.\\']\\n\\t```\n```js\\n    return new Set(words.map(word => word.split(\\'\\').map(letter => alphabet[letter]).join(\\'\\'))).size\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 120672,
                "title": "c-straightforward",
                "content": "    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse_code = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> gen_codes;\\n        \\n        for(auto word : words) {\\n            string code = \"\";\\n            for(auto ch : word)\\n                code += morse_code[ch - \\'a\\'];\\n            gen_codes.insert(code);\\n        }\\n        \\n        return gen_codes.size();\\n    }",
                "solutionTags": [],
                "code": "    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse_code = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> gen_codes;\\n        \\n        for(auto word : words) {\\n            string code = \"\";\\n            for(auto ch : word)\\n                code += morse_code[ch - \\'a\\'];\\n            gen_codes.insert(code);\\n        }\\n        \\n        return gen_codes.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 944921,
                "title": "python-just-use-set-explained",
                "content": "Nothing very special about this problem: we just need to iterate through our `words` and for each of them build string. It is actually can be done even in one line (not including `alphabet`) if we use double comperehsions, but this is up to you if you like oneliners.\\n\\n**Complexity**: time and space complexity is `O(n*k)`, where `n` is number of words and `k` average is length of each word and we note that length of each encoding is not more than `4`. Space complexity is `O(n*k)` as well.\\n\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        alphabet = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        ans = []\\n        for word in words:\\n            ans.append(\"\".join(alphabet[ord(s)-ord(\"a\")] for s in word))\\n        return len(set(ans))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        alphabet = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        ans = []\\n        for word in words:\\n            ans.append(\"\".join(alphabet[ord(s)-ord(\"a\")] for s in word))\\n        return len(set(ans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437990,
                "title": "python-easily-understood-faster-than-99-7-2-lines",
                "content": "In this question, the easiest way is to create a dict like this:\\n```\\n\\tmorse_code_dict = {\\'a\\': \\'.-\\',\\n\\t\\t\\'b\\': \\'-...\\',\\n\\t\\t\\'c\\': \\'-.-.\\',\\n\\t\\tand so on...\\n\\t}\\n```\\nbut this is time consuming.\\nThus, we can use the idea of **ASCII** in which\\n```\\na = 97\\nb = 98\\nand so on...\\n```\\n\\nCode:\\n```\\ndef uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\tmorse_code_array = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\n\\tresult = set()\\n\\tfor word in words:\\n\\t\\tword = word.lower()\\n\\t\\ttransformations = \"\"\\n\\t\\tfor chr in word:\\n\\t\\t\\ttransformations += morse_code_array[ord(chr) - 97]\\n\\t\\tresult.add(transformations)\\n\\treturn len(result)\\n```\\n\\nAlso, we can reduce the runtime by **set and list comprehension**:\\n```\\ndef uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\tmorse_code_array = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\treturn len({\\'\\'.join([morse_code_array[ord(chr) - 97] for chr in word]) for word in words})\\n```\\n\\n**Time Complexity**: `O(n*m)`\\n**Space Complexity**: `O(n*m)`\\n<br/>",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\tmorse_code_dict = {\\'a\\': \\'.-\\',\\n\\t\\t\\'b\\': \\'-...\\',\\n\\t\\t\\'c\\': \\'-.-.\\',\\n\\t\\tand so on...\\n\\t}\\n```\n```\\na = 97\\nb = 98\\nand so on...\\n```\n```\\ndef uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\tmorse_code_array = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\n\\tresult = set()\\n\\tfor word in words:\\n\\t\\tword = word.lower()\\n\\t\\ttransformations = \"\"\\n\\t\\tfor chr in word:\\n\\t\\t\\ttransformations += morse_code_array[ord(chr) - 97]\\n\\t\\tresult.add(transformations)\\n\\treturn len(result)\\n```\n```\\ndef uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\tmorse_code_array = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\treturn len({\\'\\'.join([morse_code_array[ord(chr) - 97] for chr in word]) for word in words})\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 120826,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        map_=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        res=set()\\n        \\n        for word in words:\\n            val=\"\"\\n            for s in word:\\n                val+=map_[ord(s)-ord(\\'a\\')]\\n            res.add(val)\\n        \\n        return len(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        map_=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        res=set()\\n        \\n        for word in words:\\n            val=\"\"\\n            for s in word:\\n                val+=map_[ord(s)-ord(\\'a\\')]\\n            res.add(val)\\n        \\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437353,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=uFNUoytk270\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n**C++**\\n```\\n  class Solution {\\n  public:\\n\\n\\n  int uniqueMorseRepresentations(vector<string>& words) \\n  {\\n  \\tvector<string> a = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\\n                  \"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                  \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n  \\tunordered_map<string,int> um;\\n\\n  \\tfor (int i=0; i< words.size(); i++) {\\n  \\t\\tstring st;\\n  \\t\\tfor (int j=0; j<words[i].size(); j++) st += a[words[i][j] - \\'a\\'];\\n  \\t\\tum[st]=1;\\n  \\t }\\n\\n  return um.size ();\\n  }\\n  };\\n```\\n\\n**PYTHON**(copied)\\n\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        s = set()\\n        mos = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        for w in words:                    \\n            m = \\'\\'\\n            for l in w:                       \\n                m += mos[ord(l) - ord(\\'a\\')] \\n            s.add(m)                      \\n        \\n        return len(s)\\n```\\n**JAVA**(copied)\\n\\n```\\nclass Solution {\\n    private final String[] morseCodes = {\\n        \".-\",\\n        \"-...\",\\n        \"-.-.\",\\n        \"-..\",\\n        \".\",\\n        \"..-.\",\\n        \"--.\",\\n        \"....\",\\n        \"..\",\\n        \".---\",\\n        \"-.-\",\\n        \".-..\",\\n        \"--\",\\n        \"-.\",\\n        \"---\",\\n        \".--.\",\\n        \"--.-\",\\n        \".-.\",\\n        \"...\",\\n        \"-\",\\n        \"..-\",\\n        \"...-\",\\n        \".--\",\\n        \"-..-\",\\n        \"-.--\",\\n        \"--..\"\\n    };\\n\\n    public int uniqueMorseRepresentations(String[] words) {\\n        final Set<String> codes = new HashSet<>();\\n\\n        for (String word : words) {\\n            final StringBuilder morseCode = new StringBuilder();\\n            for (int i = 0, n = word.length(); i < n; i++) {\\n                morseCode.append(morseCodes[word.charAt(i) - \\'a\\']);\\n            }\\n            codes.add(morseCode.toString());\\n        }\\n\\n        return codes.size();\\n    }\\n}\\n```\\n**Please UPVOTE  to motivate me for solving more questions like this and clubbing all languages solution!!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n  class Solution {\\n  public:\\n\\n\\n  int uniqueMorseRepresentations(vector<string>& words) \\n  {\\n  \\tvector<string> a = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\\n                  \"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                  \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n  \\tunordered_map<string,int> um;\\n\\n  \\tfor (int i=0; i< words.size(); i++) {\\n  \\t\\tstring st;\\n  \\t\\tfor (int j=0; j<words[i].size(); j++) st += a[words[i][j] - \\'a\\'];\\n  \\t\\tum[st]=1;\\n  \\t }\\n\\n  return um.size ();\\n  }\\n  };\\n```\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        s = set()\\n        mos = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        for w in words:                    \\n            m = \\'\\'\\n            for l in w:                       \\n                m += mos[ord(l) - ord(\\'a\\')] \\n            s.add(m)                      \\n        \\n        return len(s)\\n```\n```\\nclass Solution {\\n    private final String[] morseCodes = {\\n        \".-\",\\n        \"-...\",\\n        \"-.-.\",\\n        \"-..\",\\n        \".\",\\n        \"..-.\",\\n        \"--.\",\\n        \"....\",\\n        \"..\",\\n        \".---\",\\n        \"-.-\",\\n        \".-..\",\\n        \"--\",\\n        \"-.\",\\n        \"---\",\\n        \".--.\",\\n        \"--.-\",\\n        \".-.\",\\n        \"...\",\\n        \"-\",\\n        \"..-\",\\n        \"...-\",\\n        \".--\",\\n        \"-..-\",\\n        \"-.--\",\\n        \"--..\"\\n    };\\n\\n    public int uniqueMorseRepresentations(String[] words) {\\n        final Set<String> codes = new HashSet<>();\\n\\n        for (String word : words) {\\n            final StringBuilder morseCode = new StringBuilder();\\n            for (int i = 0, n = word.length(); i < n; i++) {\\n                morseCode.append(morseCodes[word.charAt(i) - \\'a\\']);\\n            }\\n            codes.add(morseCode.toString());\\n        }\\n\\n        return codes.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433758,
                "title": "python-simple-faster-than-94",
                "content": "<b>Approach 1: </b>Using ```List```\\n\\nLong:\\n```\\ndef solution(words):\\n    codes = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",\\n             \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\\n    res = set()\\n    for word in words:\\n        m = []                           # store the Morse representation of each letter in a word\\n        for ch in word:\\n            m.append(codes[ord(ch) - 97])\\n        res.add(\"\".join(m))\\n    return len(res)\\n```\\n\\nShort:\\n```\\ndef solution(words):\\n    codes = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",\\n             \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\\n\\treturn len(set(\"\".join([codes[ord(ch)-97] for ch in word]) for word in words))\\n```\\n\\n<b>Approach 2: </b>Using ```Dictionary```\\n\\nLong:\\n```\\ndef solution(words):\\n    codes = {\"a\": \".-\", \"b\": \"-...\", \"c\": \"-.-.\", \"d\": \"-..\", \"e\": \".\", \"f\": \"..-.\", \"g\": \"--.\", \"h\": \"....\", \"i\": \"..\",\\n             \"j\": \".---\", \"k\": \"-.-\", \"l\": \".-..\", \"m\": \"--\", \"n\": \"-.\", \"o\": \"---\", \"p\": \".--.\", \"q\": \"--.-\",\\n             \"r\": \".-.\", \"s\": \"...\", \"t\": \"-\", \"u\": \"..-\", \"v\": \"...-\", \"w\": \".--\", \"x\": \"-..-\", \"y\": \"-.--\", \"z\": \"--..\"}\\n    res = set()\\n    for word in words:\\n        m = []                          # store the Morse representation of each letter in a word\\n        for ch in word:\\n            m.append(codes.get(ch))\\n        res.add(\"\".join(m))\\n    return len(res)\\n```\\n\\nShort:\\n```\\ndef solution(words):\\n    codes = {\"a\": \".-\", \"b\": \"-...\", \"c\": \"-.-.\", \"d\": \"-..\", \"e\": \".\", \"f\": \"..-.\", \"g\": \"--.\", \"h\": \"....\", \"i\": \"..\",\\n             \"j\": \".---\", \"k\": \"-.-\", \"l\": \".-..\", \"m\": \"--\", \"n\": \"-.\", \"o\": \"---\", \"p\": \".--.\", \"q\": \"--.-\",\\n             \"r\": \".-.\", \"s\": \"...\", \"t\": \"-\", \"u\": \"..-\", \"v\": \"...-\", \"w\": \".--\", \"x\": \"-..-\", \"y\": \"-.--\", \"z\": \"--..\"}\\n    return len(set([\"\".join([codes.get(ch) for ch in word]) for word in words]))\\n```\\nIf you like my solution and/or find it useful, please upvote :) Thank you.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```List```\n```\\ndef solution(words):\\n    codes = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",\\n             \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\\n    res = set()\\n    for word in words:\\n        m = []                           # store the Morse representation of each letter in a word\\n        for ch in word:\\n            m.append(codes[ord(ch) - 97])\\n        res.add(\"\".join(m))\\n    return len(res)\\n```\n```\\ndef solution(words):\\n    codes = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",\\n             \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\\n\\treturn len(set(\"\".join([codes[ord(ch)-97] for ch in word]) for word in words))\\n```\n```Dictionary```\n```\\ndef solution(words):\\n    codes = {\"a\": \".-\", \"b\": \"-...\", \"c\": \"-.-.\", \"d\": \"-..\", \"e\": \".\", \"f\": \"..-.\", \"g\": \"--.\", \"h\": \"....\", \"i\": \"..\",\\n             \"j\": \".---\", \"k\": \"-.-\", \"l\": \".-..\", \"m\": \"--\", \"n\": \"-.\", \"o\": \"---\", \"p\": \".--.\", \"q\": \"--.-\",\\n             \"r\": \".-.\", \"s\": \"...\", \"t\": \"-\", \"u\": \"..-\", \"v\": \"...-\", \"w\": \".--\", \"x\": \"-..-\", \"y\": \"-.--\", \"z\": \"--..\"}\\n    res = set()\\n    for word in words:\\n        m = []                          # store the Morse representation of each letter in a word\\n        for ch in word:\\n            m.append(codes.get(ch))\\n        res.add(\"\".join(m))\\n    return len(res)\\n```\n```\\ndef solution(words):\\n    codes = {\"a\": \".-\", \"b\": \"-...\", \"c\": \"-.-.\", \"d\": \"-..\", \"e\": \".\", \"f\": \"..-.\", \"g\": \"--.\", \"h\": \"....\", \"i\": \"..\",\\n             \"j\": \".---\", \"k\": \"-.-\", \"l\": \".-..\", \"m\": \"--\", \"n\": \"-.\", \"o\": \"---\", \"p\": \".--.\", \"q\": \"--.-\",\\n             \"r\": \".-.\", \"s\": \"...\", \"t\": \"-\", \"u\": \"..-\", \"v\": \"...-\", \"w\": \".--\", \"x\": \"-..-\", \"y\": \"-.--\", \"z\": \"--..\"}\\n    return len(set([\"\".join([codes.get(ch) for ch in word]) for word in words]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2437635,
                "title": "set-stream",
                "content": "\\n### Java Set\\n```java\\npublic int uniqueMorseRepresentations(String[] words) {\\n        String[] alphabet = new String[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\"\\n                ,\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> uniqueRepresentations = new HashSet<>();\\n        \\n        for (String word : words) {\\n            StringBuilder newWord = new StringBuilder();\\n            for (char character : word.toCharArray()) \\n                newWord.append(alphabet[character - \\'a\\']);\\n            \\n            uniqueRepresentations.add(newWord.toString());\\n        }\\n        return uniqueRepresentations.size();\\n    }\\n```\\n\\n#### Java Stream\\n```java\\npublic int uniqueMorseRepresentations(String[] words) {\\n        String[] alphabet = new String[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\"\\n                ,\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        return (int) Arrays.stream(words).map(word -> word.chars().mapToObj(character -> alphabet[character - \\'a\\'])\\n                .collect(Collectors.joining())).distinct().count();\\n    }\\n```\\n\\n#### C++\\n```\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> alphabet = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\"\\n                ,\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> uniqueRepresentations;\\n\\n        for (string word : words) {\\n            string newWord;\\n            for (char symbol : word) \\n                newWord += (alphabet[symbol - \\'a\\']);\\n            \\n            uniqueRepresentations.insert(newWord);\\n        }\\n        return uniqueRepresentations.size();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int uniqueMorseRepresentations(String[] words) {\\n        String[] alphabet = new String[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\"\\n                ,\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> uniqueRepresentations = new HashSet<>();\\n        \\n        for (String word : words) {\\n            StringBuilder newWord = new StringBuilder();\\n            for (char character : word.toCharArray()) \\n                newWord.append(alphabet[character - \\'a\\']);\\n            \\n            uniqueRepresentations.add(newWord.toString());\\n        }\\n        return uniqueRepresentations.size();\\n    }\\n```\n```java\\npublic int uniqueMorseRepresentations(String[] words) {\\n        String[] alphabet = new String[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\"\\n                ,\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        return (int) Arrays.stream(words).map(word -> word.chars().mapToObj(character -> alphabet[character - \\'a\\'])\\n                .collect(Collectors.joining())).distinct().count();\\n    }\\n```\n```\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> alphabet = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\"\\n                ,\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> uniqueRepresentations;\\n\\n        for (string word : words) {\\n            string newWord;\\n            for (char symbol : word) \\n                newWord += (alphabet[symbol - \\'a\\']);\\n            \\n            uniqueRepresentations.insert(newWord);\\n        }\\n        return uniqueRepresentations.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2439228,
                "title": "python-3-liner-solution-explained-easy-understand-dictionary-beginner-friendly",
                "content": "**You can just copy & paste the Morse code map**\\n\\nHere\\'s the 3 lines solution:\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        ENG_to_MORSE = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\", \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\" }\\n        transform = lambda c: ENG_to_MORSE[c]   # use lambda function\\n        return len(Counter(\"\".join(map(transform, word)) for word in words))\\n```\\n\\nAnd here\\'s the code for better understand:\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        \\n        # create a dictionary for morse code (You can just copy & paste it! ^.^)\\n        ENG_to_MORSE = {  \\n            \\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\",\\n            \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\",\\n            \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\", \\'n\\':\"-.\", \\'o\\':\"---\",\\n            \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\",\\n            \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\",\\n        }\\n        \\n        cnt = {}    # dictionary for different transformations\\n        \\n        for word in words:      # loop through every word\\n            \\n            tmp = \"\"\\n            \\n            for c in word:      # loop through every character\\n                tmp += ENG_to_MORSE[c]    # convert the word to morse code\\n                \\n            if tmp not in cnt:\\n                cnt[tmp] = 0\\n            else:\\n                cnt[tmp] += 1\\n\\n        return len(cnt)     # return how many different elements in cnt\\n```\\n\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        ENG_to_MORSE = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\", \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\" }\\n        transform = lambda c: ENG_to_MORSE[c]   # use lambda function\\n        return len(Counter(\"\".join(map(transform, word)) for word in words))\\n```\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        \\n        # create a dictionary for morse code (You can just copy & paste it! ^.^)\\n        ENG_to_MORSE = {  \\n            \\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\",\\n            \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\",\\n            \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\", \\'n\\':\"-.\", \\'o\\':\"---\",\\n            \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\",\\n            \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\",\\n        }\\n        \\n        cnt = {}    # dictionary for different transformations\\n        \\n        for word in words:      # loop through every word\\n            \\n            tmp = \"\"\\n            \\n            for c in word:      # loop through every character\\n                tmp += ENG_to_MORSE[c]    # convert the word to morse code\\n                \\n            if tmp not in cnt:\\n                cnt[tmp] = 0\\n            else:\\n                cnt[tmp] += 1\\n\\n        return len(cnt)     # return how many different elements in cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436484,
                "title": "daily-leetcoding-challenge-august-day-17",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-morse-code-words/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Hash Set\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-morse-code-words/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 120671,
                "title": "1-ms-faster-than-100-00-of-java-online-submissions",
                "content": "For me, most times it took 1 ms, but admittedly, sometimes it\\'s 2 ms (faster than 99.55% ) or 3 ms. Depends on the Judge\\'s mood ;) \\n\\n```\\n    String[] codes = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            set.add(getCode(word));\\n        }\\n        return set.size();\\n    }\\n\\n    private String getCode(String word) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char ch : word.toCharArray()) {\\n            sb.append(codes[ch - \\'a\\']);\\n        }\\n        return sb.toString();\\n    }\\n\\t\\n```\\n\\t\\nHere\\'s a slightly more readable version, but based on my experience (or maybe luck), it takes 3-4 ms:\\n\\t\\n\\n\\t\\n```\\n    String[] codes = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            String morseCode = getCode(word);\\n            set.add(morseCode);\\n        }\\n        return set.size();\\n    }\\n\\n    private String getCode(String word) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char ch : word.toCharArray()) {\\n            int index = ch - \\'a\\';\\n            String characterCode = codes[index];\\n            sb.append(characterCode);\\n        }\\n        return sb.toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    String[] codes = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            set.add(getCode(word));\\n        }\\n        return set.size();\\n    }\\n\\n    private String getCode(String word) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char ch : word.toCharArray()) {\\n            sb.append(codes[ch - \\'a\\']);\\n        }\\n        return sb.toString();\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374214,
                "title": "javascript-solution-using-set",
                "content": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    var morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\\n                  \"--.\",\"....\",\"..\",\".---\",\\n                  \"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                  \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\\n                  \".--\",\"-..-\",\"-.--\",\"--..\"];\\n    \\n    var transformations = new Set();\\n    \\n    for (let word of words) {        \\n        var trans = \"\";\\n        for (let letter of word) {\\n            var index = letter.charCodeAt(0) - 97;\\n            trans += morse[index];\\n        }\\n        \\n        transformations.add(trans);   \\n    }\\n    \\n    return transformations.size;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    var morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\\n                  \"--.\",\"....\",\"..\",\".---\",\\n                  \"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                  \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\\n                  \".--\",\"-..-\",\"-.--\",\"--..\"];\\n    \\n    var transformations = new Set();\\n    \\n    for (let word of words) {        \\n        var trans = \"\";\\n        for (let letter of word) {\\n            var index = letter.charCodeAt(0) - 97;\\n            trans += morse[index];\\n        }\\n        \\n        transformations.add(trans);   \\n    }\\n    \\n    return transformations.size;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 945063,
                "title": "c-super-easy-and-simple-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> codes = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        set<string> res;\\n        for (auto word : words) {\\n            string curr = \"\";\\n            for (auto ch : word)\\n                curr += codes[ch-97];\\n            res.insert(curr);\\n        }\\n        return res.size();\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> codes = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        set<string> res;\\n        for (auto word : words) {\\n            string curr = \"\";\\n            for (auto ch : word)\\n                curr += codes[ch-97];\\n            res.insert(curr);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436848,
                "title": "java-100-faster-code-easy-solution-using-hashset",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] arr = new String[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        HashSet<String> set = new HashSet<>();\\n        for (String word : words) \\n            set.add(transformMorse(word, arr));\\n        return set.size();\\n    }\\n    private String transformMorse(String word, String[] arr) {\\n        StringBuilder build = new StringBuilder();\\n        for (char c : word.toCharArray())\\n            build.append(arr[(int)c - 97]);\\n        return build.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] arr = new String[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        HashSet<String> set = new HashSet<>();\\n        for (String word : words) \\n            set.add(transformMorse(word, arr));\\n        return set.size();\\n    }\\n    private String transformMorse(String word, String[] arr) {\\n        StringBuilder build = new StringBuilder();\\n        for (char c : word.toCharArray())\\n            build.append(arr[(int)c - 97]);\\n        return build.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436733,
                "title": "100-c-easy-with-explanation-hashmap-clean-code",
                "content": "**General Idea:**\\n- construct each word in morse code\\n- insert word into a set (sets won\\'t store duplicates) <- key point\\n- return set size at the end\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n    \\n\\n\\t\\tint uniqueMorseRepresentations(vector<string>& words) \\n\\t\\t{\\n\\t\\t\\tvector<string> a = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\\n                        \"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                        \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n\\t\\t\\tunordered_set<string> u;\\n\\n\\t\\t\\tfor (auto word : words) {\\n\\t\\t\\t\\tstring t;\\n\\t\\t\\t\\tfor (auto c : word) t += a[c - \\'a\\'];\\n\\t\\t\\t\\tu.insert (t);\\n\\t\\t\\t }\\n\\n\\t\\treturn u.size ();\\n\\t\\t}\\n\\t\\t};\\n\\t\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community).**\\n\\n**HAPPY CODING:)**\\n\\n*Any suggestions and improvements are always welcome*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n    \\n\\n\\t\\tint uniqueMorseRepresentations(vector<string>& words) \\n\\t\\t{\\n\\t\\t\\tvector<string> a = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\\n                        \"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                        \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}",
                "codeTag": "Java"
            },
            {
                "id": 120805,
                "title": "functional-javascript-map-reduce",
                "content": "1. Map each word into it\\'s morse code representation\\n2. Reduce the list of morse code strings into a single set\\n3. Return the size of the set\\n\\nThe helper function just uses the ascii code to index into the `codes` array.\\n\\n```\\nconst codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\nconst getIdx = char => char.charCodeAt(0) - \\'a\\'.charCodeAt(0)\\n\\nvar uniqueMorseRepresentations = function(words) {\\n    return words.map( word => word.split(\\'\\')\\n                                 .map( char => codes[getIdx(char)])\\n                                 .join(\\'\\'))\\n                .reduce((set, cur) => set.add(cur), new Set())\\n                .size\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\nconst getIdx = char => char.charCodeAt(0) - \\'a\\'.charCodeAt(0)\\n\\nvar uniqueMorseRepresentations = function(words) {\\n    return words.map( word => word.split(\\'\\')\\n                                 .map( char => codes[getIdx(char)])\\n                                 .join(\\'\\'))\\n                .reduce((set, cur) => set.add(cur), new Set())\\n                .size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437807,
                "title": "c-0ms-100-easy-solution-explained-easy-to-understand-beginner-friendly-qsort",
                "content": "Basicly, we just convert every word from English to Morse code.\\nWe use qsort to rearrange order, so that we can just compare two adjacent elements.\\n```\\nint cmp(const void* a, const void*b){   // qsort compare function\\n    return strcmp(*(const char**)a, *(const char**)b);\\n}\\n\\n// create a map for morse code\\nchar morse[26][5] = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n                   \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n                   \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n\\n\\nint uniqueMorseRepresentations(char ** words, int wordsSize){\\n    \\n    if (wordsSize == 1) return 1;\\n    \\n    char** trans = (char**)malloc(wordsSize * sizeof(char*));   // create 2D array \\n    \\n    for(int i=0; i < wordsSize; i++){\\n        int len = strlen(words[i]);\\n        trans[i] = (char*) calloc((len * 4 + 1), sizeof(char)); // create space for each morse code\\n        for(int j=0; j < len; j++)\\n            strcat(trans[i], morse[words[i][j] - \\'a\\']);     // convert english to morse code\\n    }\\n    \\n    qsort(trans, wordsSize, sizeof(char**), cmp);      // sort these morse codes by their length\\n    \\n    int cnt = wordsSize;        // this is how many elements are different\\n    for(int i=1; i < wordsSize; i++)\\n        if (!strcmp(trans[i-1], trans[i])) cnt--;   // loop through trans and compare\\n    \\n    for(int i=0; i < wordsSize; i++)    // free the space\\n        free(trans[i]);\\n    free(trans);\\n    \\n    return cnt;\\n}\\n```\\n**Please UPVOTE if you LIKE!!**\\n![image](https://assets.leetcode.com/users/images/d7089d0b-18ee-4752-af79-8abd501568cb_1660717565.7753801.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cmp(const void* a, const void*b){   // qsort compare function\\n    return strcmp(*(const char**)a, *(const char**)b);\\n}\\n\\n// create a map for morse code\\nchar morse[26][5] = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n                   \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n                   \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n\\n\\nint uniqueMorseRepresentations(char ** words, int wordsSize){\\n    \\n    if (wordsSize == 1) return 1;\\n    \\n    char** trans = (char**)malloc(wordsSize * sizeof(char*));   // create 2D array \\n    \\n    for(int i=0; i < wordsSize; i++){\\n        int len = strlen(words[i]);\\n        trans[i] = (char*) calloc((len * 4 + 1), sizeof(char)); // create space for each morse code\\n        for(int j=0; j < len; j++)\\n            strcat(trans[i], morse[words[i][j] - \\'a\\']);     // convert english to morse code\\n    }\\n    \\n    qsort(trans, wordsSize, sizeof(char**), cmp);      // sort these morse codes by their length\\n    \\n    int cnt = wordsSize;        // this is how many elements are different\\n    for(int i=1; i < wordsSize; i++)\\n        if (!strcmp(trans[i-1], trans[i])) cnt--;   // loop through trans and compare\\n    \\n    for(int i=0; i < wordsSize; i++)    // free the space\\n        free(trans[i]);\\n    free(trans);\\n    \\n    return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1869706,
                "title": "804-unique-morse-code-words-hasmap-hashset-4ms-java",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        HashMap<Character, String> map = new HashMap<>();\\n        map.put(\\'a\\', \".-\");\\n        map.put(\\'b\\', \"-...\");\\n        map.put(\\'c\\', \"-.-.\");\\n        map.put(\\'d\\', \"-..\");\\n        map.put(\\'e\\', \".\");\\n        map.put(\\'f\\', \"..-.\");\\n        map.put(\\'g\\', \"--.\");\\n        map.put(\\'h\\', \"....\");\\n        map.put(\\'i\\', \"..\");\\n        map.put(\\'j\\', \".---\");\\n        map.put(\\'k\\', \"-.-\");\\n        map.put(\\'l\\', \".-..\");\\n        map.put(\\'m\\', \"--\");\\n        map.put(\\'n\\', \"-.\");\\n        map.put(\\'o\\', \"---\");\\n        map.put(\\'p\\', \".--.\");\\n        map.put(\\'q\\', \"--.-\");\\n        map.put(\\'r\\', \".-.\");\\n        map.put(\\'s\\', \"...\");\\n        map.put(\\'t\\', \"-\");\\n        map.put(\\'u\\', \"..-\");\\n        map.put(\\'v\\', \"...-\");\\n        map.put(\\'w\\', \".--\");\\n        map.put(\\'x\\', \"-..-\");\\n        map.put(\\'y\\', \"-.--\");\\n        map.put(\\'z\\', \"--..\");\\n        \\n        HashSet<String> set = new HashSet<>();\\n        for(int i=0; i<words.length; i++)\\n        {\\n            String str = words[i];\\n            String str1 = \"\";\\n                for(int j=0; j<str.length(); j++)\\n                {\\n                    str1 = str1 + map.get(str.charAt(j));\\n                }\\n            set.add(str1);\\n        }\\n        return set.size();\\n        \\n    }\\n}\\n```\\n**If you like my solution Please UPVOTE**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        HashMap<Character, String> map = new HashMap<>();\\n        map.put(\\'a\\', \".-\");\\n        map.put(\\'b\\', \"-...\");\\n        map.put(\\'c\\', \"-.-.\");\\n        map.put(\\'d\\', \"-..\");\\n        map.put(\\'e\\', \".\");\\n        map.put(\\'f\\', \"..-.\");\\n        map.put(\\'g\\', \"--.\");\\n        map.put(\\'h\\', \"....\");\\n        map.put(\\'i\\', \"..\");\\n        map.put(\\'j\\', \".---\");\\n        map.put(\\'k\\', \"-.-\");\\n        map.put(\\'l\\', \".-..\");\\n        map.put(\\'m\\', \"--\");\\n        map.put(\\'n\\', \"-.\");\\n        map.put(\\'o\\', \"---\");\\n        map.put(\\'p\\', \".--.\");\\n        map.put(\\'q\\', \"--.-\");\\n        map.put(\\'r\\', \".-.\");\\n        map.put(\\'s\\', \"...\");\\n        map.put(\\'t\\', \"-\");\\n        map.put(\\'u\\', \"..-\");\\n        map.put(\\'v\\', \"...-\");\\n        map.put(\\'w\\', \".--\");\\n        map.put(\\'x\\', \"-..-\");\\n        map.put(\\'y\\', \"-.--\");\\n        map.put(\\'z\\', \"--..\");\\n        \\n        HashSet<String> set = new HashSet<>();\\n        for(int i=0; i<words.length; i++)\\n        {\\n            String str = words[i];\\n            String str1 = \"\";\\n                for(int j=0; j<str.length(); j++)\\n                {\\n                    str1 = str1 + map.get(str.charAt(j));\\n                }\\n            set.add(str1);\\n        }\\n        return set.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568159,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=uFNUoytk270\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n**C++**\\n```\\n  class Solution {\\n  public:\\n\\n\\n  int uniqueMorseRepresentations(vector<string>& words) \\n  {\\n  \\tvector<string> a = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\\n                  \"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                  \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n  \\tunordered_map<string,int> um;\\n\\n  \\tfor (int i=0; i< words.size(); i++) {\\n  \\t\\tstring st;\\n  \\t\\tfor (int j=0; j<words[i].size(); j++) st += a[words[i][j] - \\'a\\'];\\n  \\t\\tum[st]=1;\\n  \\t }\\n\\n  return um.size ();\\n  }\\n  };\\n```\\n\\n**PYTHON**(copied)\\n\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        s = set()\\n        mos = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        for w in words:                    \\n            m = \\'\\'\\n            for l in w:                       \\n                m += mos[ord(l) - ord(\\'a\\')] \\n            s.add(m)                      \\n        \\n        return len(s)\\n```\\n**JAVA**(copied)\\n\\n```\\nclass Solution {\\n    private final String[] morseCodes = {\\n        \".-\",\\n        \"-...\",\\n        \"-.-.\",\\n        \"-..\",\\n        \".\",\\n        \"..-.\",\\n        \"--.\",\\n        \"....\",\\n        \"..\",\\n        \".---\",\\n        \"-.-\",\\n        \".-..\",\\n        \"--\",\\n        \"-.\",\\n        \"---\",\\n        \".--.\",\\n        \"--.-\",\\n        \".-.\",\\n        \"...\",\\n        \"-\",\\n        \"..-\",\\n        \"...-\",\\n        \".--\",\\n        \"-..-\",\\n        \"-.--\",\\n        \"--..\"\\n    };\\n\\n    public int uniqueMorseRepresentations(String[] words) {\\n        final Set<String> codes = new HashSet<>();\\n\\n        for (String word : words) {\\n            final StringBuilder morseCode = new StringBuilder();\\n            for (int i = 0, n = word.length(); i < n; i++) {\\n                morseCode.append(morseCodes[word.charAt(i) - \\'a\\']);\\n            }\\n            codes.add(morseCode.toString());\\n        }\\n\\n        return codes.size();\\n    }\\n}\\n```\\n**Please UPVOTE  to motivate me for solving more questions like this and clubbing all languages solution!!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n  class Solution {\\n  public:\\n\\n\\n  int uniqueMorseRepresentations(vector<string>& words) \\n  {\\n  \\tvector<string> a = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\\n                  \"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                  \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n  \\tunordered_map<string,int> um;\\n\\n  \\tfor (int i=0; i< words.size(); i++) {\\n  \\t\\tstring st;\\n  \\t\\tfor (int j=0; j<words[i].size(); j++) st += a[words[i][j] - \\'a\\'];\\n  \\t\\tum[st]=1;\\n  \\t }\\n\\n  return um.size ();\\n  }\\n  };\\n```\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        s = set()\\n        mos = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        for w in words:                    \\n            m = \\'\\'\\n            for l in w:                       \\n                m += mos[ord(l) - ord(\\'a\\')] \\n            s.add(m)                      \\n        \\n        return len(s)\\n```\n```\\nclass Solution {\\n    private final String[] morseCodes = {\\n        \".-\",\\n        \"-...\",\\n        \"-.-.\",\\n        \"-..\",\\n        \".\",\\n        \"..-.\",\\n        \"--.\",\\n        \"....\",\\n        \"..\",\\n        \".---\",\\n        \"-.-\",\\n        \".-..\",\\n        \"--\",\\n        \"-.\",\\n        \"---\",\\n        \".--.\",\\n        \"--.-\",\\n        \".-.\",\\n        \"...\",\\n        \"-\",\\n        \"..-\",\\n        \"...-\",\\n        \".--\",\\n        \"-..-\",\\n        \"-.--\",\\n        \"--..\"\\n    };\\n\\n    public int uniqueMorseRepresentations(String[] words) {\\n        final Set<String> codes = new HashSet<>();\\n\\n        for (String word : words) {\\n            final StringBuilder morseCode = new StringBuilder();\\n            for (int i = 0, n = word.length(); i < n; i++) {\\n                morseCode.append(morseCodes[word.charAt(i) - \\'a\\']);\\n            }\\n            codes.add(morseCode.toString());\\n        }\\n\\n        return codes.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800987,
                "title": "c-simple-solution-explained-100-time-93-space",
                "content": "Pro-tip: if there are no extra constraints, go for performing low hanging fruits in your own interviews.\\n\\nAnd this one seemed like a typical case: we can solve it using very little extra resources, so let\\'s plan in advance:\\n* we know we need to convert the strings to find similar matches (you might do so without converting and finding how a few characters can overlap others in morse, but I would not go there);\\n* we need some convenient data structure to store our intermediate results so that we can know how many unique morse strings we will get.\\n\\nWe can solve easily the first point with a helper function (`convertToMorse`, in my case) and an `unordered_set` looks ideal for the latter point, so I will call it `seen` and accumulate the results there.\\n\\nOnce I am done, I will just return its length and will be done with it :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string morse[26] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    string convertToMorse(string s) {\\n        string res;\\n        for (char c: s) res.append(morse[c - \\'a\\']);\\n        return res;\\n    }\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        unordered_set<string> seen;\\n        for (string s: words) seen.insert(convertToMorse(s));\\n        return seen.size();\\n    }\\n};\\n```\\n\\nP.S.: extra goodie: an array to keep track of the characters to convert is more than enough - lightweight and with quick 1:1 matching.",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string morse[26] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    string convertToMorse(string s) {\\n        string res;\\n        for (char c: s) res.append(morse[c - \\'a\\']);\\n        return res;\\n    }\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        unordered_set<string> seen;\\n        for (string s: words) seen.insert(convertToMorse(s));\\n        return seen.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079850,
                "title": "easy-solution-line-by-line-explanation-python-java-c-ruby",
                "content": "# Beats\\n![image.png](https://assets.leetcode.com/users/images/3d70d2c2-15a4-4bac-85ee-60513e1da5b6_1695459168.514062.png)\\n\\n# Intuition\\nThe problem asks for the number of different transformations among a list of words, where each word can be represented as a concatenation of Morse code representations for its letters. To solve this, we need to convert each letter in a word to its Morse code equivalent and count the unique representations.\\n\\n# Approach\\n1. Define the English alphabet and Morse code representations:\\n   - `letters` stores the lowercase English alphabet from \\'a\\' to \\'z\\'.\\n   - `morse_code` stores the corresponding Morse code representations for each letter.\\n\\n2. Create a dictionary mapping letters to Morse code:\\n   - `morse_dict` is a dictionary created by zipping `letters` and `morse_code` together. It maps each letter to its Morse code representation.\\n\\n3. Initialize a list to store words converted to Morse code:\\n   - `words2` is an empty list that will be used to store the Morse code representations of the input words.\\n\\n4. Iterate through each word in the input list:\\n   - For each word in `words`, the code initializes an empty string `k` to store the Morse code for the current word.\\n\\n5. Iterate through each character in the current word:\\n   - For each character `i` in the current word, the code appends the Morse code representation of that character (retrieved from `morse_dict`) to the string `k`.\\n\\n6. Append the Morse code for the current word to the list:\\n   - After converting the entire word to Morse code and building the string `k`, the code appends `k` to the `words2` list.\\n\\n7. Return the count of unique Morse code representations:\\n   - The code returns the length of the set of `words2`. This effectively counts the number of unique Morse code representations in the list and returns that count as the result.\\n\\n# Complexity\\n- Time complexity: The code iterates through each character in each word, so the time complexity is O(n), where n is the total number of characters in all words.\\n- Space complexity: The space complexity is O(n) as well because the `words2` list stores Morse code representations for each word.\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        # Define the English alphabet\\n        letters = \"abcdefghijklmnopqrstuvwxyz\"\\n        \\n        # Define the corresponding Morse code representations\\n        morse_code = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\\n\\n        # Create a dictionary that maps letters to Morse code\\n        morse_dict = dict(zip(letters, morse_code))\\n\\n        # Initialize a list to store words converted to Morse code\\n        words2 = []\\n\\n        # Iterate through each word in the input list\\n        for word in words:\\n            # Initialize an empty string to store the Morse code for the current word\\n            k = \"\"\\n            \\n            # Iterate through each character in the current word\\n            for i in word:\\n                # Append the Morse code representation of the character to the string\\n                k += morse_dict[i]\\n\\n            # Append the Morse code for the current word to the list\\n            words2.append(k) \\n\\n        # Return the count of unique Morse code representations\\n        return len(set(words2))\\n\\n```\\n\\n# Java\\n```\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morseCode = {\\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n            \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n            \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n        };\\n\\n        Set<String> uniqueMorse = new HashSet<>();\\n\\n        for (String word : words) {\\n            StringBuilder morseRepresentation = new StringBuilder();\\n            for (char c : word.toCharArray()) {\\n                morseRepresentation.append(morseCode[c - \\'a\\']);\\n            }\\n            uniqueMorse.add(morseRepresentation.toString());\\n        }\\n\\n        return uniqueMorse.size();\\n    }\\n}\\n\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morseCode = {\\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n            \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n            \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n        };\\n\\n        unordered_set<string> uniqueMorse;\\n\\n        for (const string& word : words) {\\n            string morseRepresentation = \"\";\\n            for (char c : word) {\\n                morseRepresentation += morseCode[c - \\'a\\'];\\n            }\\n            uniqueMorse.insert(morseRepresentation);\\n        }\\n\\n        return uniqueMorse.size();\\n    }\\n};\\n\\n```\\n# Ruby\\n```\\nclass Solution\\n  MORSE_CODE = [\\n    \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n    \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n    \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n  ]\\n\\n  def unique_morse_representations(words)\\n    unique_morse = Set.new\\n\\n    words.each do |word|\\n      morse_representation = \"\"\\n      word.each_char do |char|\\n        morse_representation += MORSE_CODE[char.ord - \\'a\\'.ord]\\n      end\\n      unique_morse.add(morse_representation)\\n    end\\n\\n    unique_morse.size\\n  end\\nend\\n\\n```\\n# javascript\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar uniqueMorseRepresentations = function (words) {\\n    const morseCode = [\\n        \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n        \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\",\\n        \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n    ];\\n\\n    const uniqueMorse = new Set();\\n\\n    for (const word of words) {\\n        let morseRepresentation = \"\";\\n        for (const char of word) {\\n            morseRepresentation += morseCode[char.charCodeAt(0) - \\'a\\'.charCodeAt(0)];\\n        }\\n        uniqueMorse.add(morseRepresentation);\\n    }\\n\\n    return uniqueMorse.size;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Ruby"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        # Define the English alphabet\\n        letters = \"abcdefghijklmnopqrstuvwxyz\"\\n        \\n        # Define the corresponding Morse code representations\\n        morse_code = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\\n\\n        # Create a dictionary that maps letters to Morse code\\n        morse_dict = dict(zip(letters, morse_code))\\n\\n        # Initialize a list to store words converted to Morse code\\n        words2 = []\\n\\n        # Iterate through each word in the input list\\n        for word in words:\\n            # Initialize an empty string to store the Morse code for the current word\\n            k = \"\"\\n            \\n            # Iterate through each character in the current word\\n            for i in word:\\n                # Append the Morse code representation of the character to the string\\n                k += morse_dict[i]\\n\\n            # Append the Morse code for the current word to the list\\n            words2.append(k) \\n\\n        # Return the count of unique Morse code representations\\n        return len(set(words2))\\n\\n```\n```\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morseCode = {\\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n            \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n            \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n        };\\n\\n        Set<String> uniqueMorse = new HashSet<>();\\n\\n        for (String word : words) {\\n            StringBuilder morseRepresentation = new StringBuilder();\\n            for (char c : word.toCharArray()) {\\n                morseRepresentation.append(morseCode[c - \\'a\\']);\\n            }\\n            uniqueMorse.add(morseRepresentation.toString());\\n        }\\n\\n        return uniqueMorse.size();\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morseCode = {\\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n            \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n            \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n        };\\n\\n        unordered_set<string> uniqueMorse;\\n\\n        for (const string& word : words) {\\n            string morseRepresentation = \"\";\\n            for (char c : word) {\\n                morseRepresentation += morseCode[c - \\'a\\'];\\n            }\\n            uniqueMorse.insert(morseRepresentation);\\n        }\\n\\n        return uniqueMorse.size();\\n    }\\n};\\n\\n```\n```\\nclass Solution\\n  MORSE_CODE = [\\n    \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n    \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n    \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n  ]\\n\\n  def unique_morse_representations(words)\\n    unique_morse = Set.new\\n\\n    words.each do |word|\\n      morse_representation = \"\"\\n      word.each_char do |char|\\n        morse_representation += MORSE_CODE[char.ord - \\'a\\'.ord]\\n      end\\n      unique_morse.add(morse_representation)\\n    end\\n\\n    unique_morse.size\\n  end\\nend\\n\\n```\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar uniqueMorseRepresentations = function (words) {\\n    const morseCode = [\\n        \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n        \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\",\\n        \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n    ];\\n\\n    const uniqueMorse = new Set();\\n\\n    for (const word of words) {\\n        let morseRepresentation = \"\";\\n        for (const char of word) {\\n            morseRepresentation += morseCode[char.charCodeAt(0) - \\'a\\'.charCodeAt(0)];\\n        }\\n        uniqueMorse.add(morseRepresentation);\\n    }\\n\\n    return uniqueMorse.size;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390327,
                "title": "c-and-c-very-easy-solution",
                "content": "![photo_2023-04-07_17-44-42.jpg](https://assets.leetcode.com/users/images/37fcecb2-fe9c-4b22-83d2-23102a7c2ba5_1680871628.659171.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:Beats 49.9% of other solutions in C#.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:Beats 94.55% of other solutions in C#.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector <string> v={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\\n        \"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\\n        \".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\\n        \"-.--\",\"--..\"};\\n        unordered_map <string,int> my;\\n        string s;\\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[i].length();j++){\\n                s+=v[words[i][j]-\\'a\\'];\\n            }\\n            my[s]=1;\\n            s.clear();\\n        }\\n      return my.size();\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public int UniqueMorseRepresentations(string[] words) {\\n        Dictionary<char,string> dic=new();\\n        dic.Add(\\'a\\',\".-\");dic.Add(\\'b\\',\"-...\");dic.Add(\\'c\\',\"-.-.\");\\n        dic.Add(\\'d\\',\"-..\");dic.Add(\\'e\\',\".\");dic.Add(\\'f\\',\"..-.\");\\n        dic.Add(\\'g\\',\"--.\");dic.Add(\\'h\\',\"....\");dic.Add(\\'i\\',\"..\");\\n        dic.Add(\\'j\\',\".---\");dic.Add(\\'k\\',\"-.-\");dic.Add(\\'l\\',\".-..\");\\n        dic.Add(\\'m\\',\"--\");dic.Add(\\'n\\',\"-.\");dic.Add(\\'o\\',\"---\");\\n        dic.Add(\\'p\\',\".--.\");dic.Add(\\'q\\',\"--.-\");dic.Add(\\'r\\',\".-.\");\\n        dic.Add(\\'s\\',\"...\");dic.Add(\\'t\\',\"-\");dic.Add(\\'u\\',\"..-\");\\n        dic.Add(\\'v\\',\"...-\");dic.Add(\\'w\\',\".--\");dic.Add(\\'x\\',\"-..-\");\\n        dic.Add(\\'y\\',\"-.--\");dic.Add(\\'z\\',\"--..\");\\n        Dictionary<string,char> res=new();\\n        \\n        for(int i=0;i<words.Length;i++){\\n            string s=string.Empty;\\n            for(int j=0;j<words[i].Length;j++){\\n             s+=dic[words[i][j]];\\n            }\\n            if(!res.ContainsKey(s))\\n            res.Add(s,\\'*\\');\\n        }\\n        return res.Count;\\n    }\\n}\\n```\\n```C# []\\npublic class Solution {\\n    public int UniqueMorseRepresentations(string[] words) {\\n         List<string> d =new List<string>() {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        HashSet<string> s=new();\\n        foreach (var w in words) {\\n            string code=\"\";\\n            foreach (var c in w) \\n            code += d[c - \\'a\\'];\\n            s.Add(code);\\n        }\\n        return s.Count;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector <string> v={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\\n        \"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\\n        \".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\\n        \"-.--\",\"--..\"};\\n        unordered_map <string,int> my;\\n        string s;\\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[i].length();j++){\\n                s+=v[words[i][j]-\\'a\\'];\\n            }\\n            my[s]=1;\\n            s.clear();\\n        }\\n      return my.size();\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public int UniqueMorseRepresentations(string[] words) {\\n        Dictionary<char,string> dic=new();\\n        dic.Add(\\'a\\',\".-\");dic.Add(\\'b\\',\"-...\");dic.Add(\\'c\\',\"-.-.\");\\n        dic.Add(\\'d\\',\"-..\");dic.Add(\\'e\\',\".\");dic.Add(\\'f\\',\"..-.\");\\n        dic.Add(\\'g\\',\"--.\");dic.Add(\\'h\\',\"....\");dic.Add(\\'i\\',\"..\");\\n        dic.Add(\\'j\\',\".---\");dic.Add(\\'k\\',\"-.-\");dic.Add(\\'l\\',\".-..\");\\n        dic.Add(\\'m\\',\"--\");dic.Add(\\'n\\',\"-.\");dic.Add(\\'o\\',\"---\");\\n        dic.Add(\\'p\\',\".--.\");dic.Add(\\'q\\',\"--.-\");dic.Add(\\'r\\',\".-.\");\\n        dic.Add(\\'s\\',\"...\");dic.Add(\\'t\\',\"-\");dic.Add(\\'u\\',\"..-\");\\n        dic.Add(\\'v\\',\"...-\");dic.Add(\\'w\\',\".--\");dic.Add(\\'x\\',\"-..-\");\\n        dic.Add(\\'y\\',\"-.--\");dic.Add(\\'z\\',\"--..\");\\n        Dictionary<string,char> res=new();\\n        \\n        for(int i=0;i<words.Length;i++){\\n            string s=string.Empty;\\n            for(int j=0;j<words[i].Length;j++){\\n             s+=dic[words[i][j]];\\n            }\\n            if(!res.ContainsKey(s))\\n            res.Add(s,\\'*\\');\\n        }\\n        return res.Count;\\n    }\\n}\\n```\n```C# []\\npublic class Solution {\\n    public int UniqueMorseRepresentations(string[] words) {\\n         List<string> d =new List<string>() {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        HashSet<string> s=new();\\n        foreach (var w in words) {\\n            string code=\"\";\\n            foreach (var c in w) \\n            code += d[c - \\'a\\'];\\n            s.Add(code);\\n        }\\n        return s.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273741,
                "title": "easiest-approach-c-explained",
                "content": "# Approach\\nWe make an array `morse` to order the morse codes for each alphabet. \\nThen we convert each word in the string to morse code and push back to the `code` vector. \\nThen we count distinct elements in the `code` array and return.\\n\\n# Complexity\\n- **Time complexity**:  O(NM)\\n- **Space complexity**: O(NM)\\nWhere $$N$$ is the size of array and $$M$$ is the length of word.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        vector<string> code; //To store morse codes\\n        int count=1; // To count distinct codes\\n        for(auto i: words){\\n            int n;\\n            string str;\\n            for(int j=0;j<i.length();j++){\\n                n=i[j]-97; // To get index for each alphabet from morse array\\n                str+=morse[n];\\n            }\\n            code.push_back(str);\\n        }\\n\\n        // Count distinct codes\\n        for (int i = 1; i < code.size(); i++) {\\n            int j;\\n            for (j = 0; j < i; j++)\\n                if (code[i] == code[j])\\n                    break;\\n            if (i == j) count++;\\n        }\\n\\n\\n        return count;\\n    }\\n        \\n};\\n```\\n\\n---\\n\\n\\n***Note**: `count` is initialized with 1 as the first element of an array is always unique.*\\n\\n---\\nIf it helped, would really appreciate an upvote ;)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        vector<string> code; //To store morse codes\\n        int count=1; // To count distinct codes\\n        for(auto i: words){\\n            int n;\\n            string str;\\n            for(int j=0;j<i.length();j++){\\n                n=i[j]-97; // To get index for each alphabet from morse array\\n                str+=morse[n];\\n            }\\n            code.push_back(str);\\n        }\\n\\n        // Count distinct codes\\n        for (int i = 1; i < code.size(); i++) {\\n            int j;\\n            for (j = 0; j < i; j++)\\n                if (code[i] == code[j])\\n                    break;\\n            if (i == j) count++;\\n        }\\n\\n\\n        return count;\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165283,
                "title": "c-solution-using-sets-explained",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        // store morse codes for each letter \\n        vector<string> hash = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                                \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\\n                                \"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        set<string> s ;\\n        for (int i = 0 ; i < words.size() ; i++)\\n        {\\n            string temp = \"\" ;\\n            for (int j = 0 ; j < words[i].length() ; j++)\\n            {\\n                // create string of morse of each word \\n                temp += hash[words[i][j] - \\'a\\'] ;\\n            }\\n            // store into a set, set stores only unique elements \\n            s.insert(temp) ;\\n        }\\n        // size of set gives unique morse codes \\n        return s.size() ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/4f899ab0-e157-4430-b23e-dd609b9ba0a8_1675965365.1080947.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        // store morse codes for each letter \\n        vector<string> hash = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                                \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\\n                                \"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        set<string> s ;\\n        for (int i = 0 ; i < words.size() ; i++)\\n        {\\n            string temp = \"\" ;\\n            for (int j = 0 ; j < words[i].length() ; j++)\\n            {\\n                // create string of morse of each word \\n                temp += hash[words[i][j] - \\'a\\'] ;\\n            }\\n            // store into a set, set stores only unique elements \\n            s.insert(temp) ;\\n        }\\n        // size of set gives unique morse codes \\n        return s.size() ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126042,
                "title": "java-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] tokens = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> set = new HashSet<>();\\n        for ( String word : words ) {\\n            StringBuilder sb = new StringBuilder();\\n            for ( int i = 0; i < word.length(); i++ ) {\\n                sb.append( tokens[word.charAt(i)-\\'a\\'] );\\n            }\\n            set.add( sb.toString() );\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] tokens = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> set = new HashSet<>();\\n        for ( String word : words ) {\\n            StringBuilder sb = new StringBuilder();\\n            for ( int i = 0; i < word.length(); i++ ) {\\n                sb.append( tokens[word.charAt(i)-\\'a\\'] );\\n            }\\n            set.add( sb.toString() );\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122579,
                "title": "rust-0ms-using-iterators-hashset",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn unique_morse_representations(words: Vec<String>) -> i32 {\\n        static MORSE: [&str; 26] = [\\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\",\\n            \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\",\\n            \"-.--\", \"--..\",\\n        ];\\n\\t\\t\\n        words\\n            .into_iter()\\n            .map(|w| {\\n                w.chars()\\n                    .map(|c| MORSE[c as usize - \\'a\\' as usize])\\n                    .collect::<String>()\\n            })\\n            .collect::<HashSet<_>>()\\n            .len() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn unique_morse_representations(words: Vec<String>) -> i32 {\\n        static MORSE: [&str; 26] = [\\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\",\\n            \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\",\\n            \"-.--\", \"--..\",\\n        ];\\n\\t\\t\\n        words\\n            .into_iter()\\n            .map(|w| {\\n                w.chars()\\n                    .map(|c| MORSE[c as usize - \\'a\\' as usize])\\n                    .collect::<String>()\\n            })\\n            .collect::<HashSet<_>>()\\n            .len() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2438206,
                "title": "python-elegant-short-two-lines-no-loops",
                "content": "\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tMORSE = {\\n\\t\\t\\t\\'a\\': \\'.-\\',   \\'b\\': \\'-...\\', \\'c\\': \\'-.-.\\', \\'d\\': \\'-..\\',  \\'e\\': \\'.\\',    \\'f\\': \\'..-.\\', \\'g\\': \\'--.\\',\\n\\t\\t\\t\\'h\\': \\'....\\', \\'i\\': \\'..\\',   \\'j\\': \\'.---\\', \\'k\\': \\'-.-\\',  \\'l\\': \\'.-..\\', \\'m\\': \\'--\\',   \\'n\\': \\'-.\\',\\n\\t\\t\\t\\'o\\': \\'---\\',  \\'p\\': \\'.--.\\', \\'q\\': \\'--.-\\', \\'r\\': \\'.-.\\',  \\'s\\': \\'...\\',  \\'t\\': \\'-\\',    \\'u\\': \\'..-\\',\\n\\t\\t\\t\\'v\\': \\'...-\\', \\'w\\': \\'.--\\',  \\'x\\': \\'-..-\\', \\'y\\': \\'-.--\\', \\'z\\': \\'--..\\',\\n\\t\\t}\\n\\n\\t\\tdef uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\t\\t\\treturn len(set(map(self.encode, words)))\\n\\n\\t\\t@classmethod\\n\\t\\tdef encode(cls, word: str) -> str:\\n\\t\\t\\treturn \\'\\'.join(map(cls.MORSE.get, word))\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tMORSE = {\\n\\t\\t\\t\\'a\\': \\'.-\\',   \\'b\\': \\'-...\\', \\'c\\': \\'-.-.\\', \\'d\\': \\'-..\\',  \\'e\\': \\'.\\',    \\'f\\': \\'..-.\\', \\'g\\': \\'--.\\',\\n\\t\\t\\t\\'h\\': \\'....\\', \\'i\\': \\'..\\',   \\'j\\': \\'.---\\', \\'k\\': \\'-.-\\',  \\'l\\': \\'.-..\\', \\'m\\': \\'--\\',   \\'n\\': \\'-.\\',\\n\\t\\t\\t\\'o\\': \\'---\\',  \\'p\\': \\'.--.\\', \\'q\\': \\'--.-\\', \\'r\\': \\'.-.\\',  \\'s\\': \\'...\\',  \\'t\\': \\'-\\',    \\'u\\': \\'..-\\',\\n\\t\\t\\t\\'v\\': \\'...-\\', \\'w\\': \\'.--\\',  \\'x\\': \\'-..-\\', \\'y\\': \\'-.--\\', \\'z\\': \\'--..\\',\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 946854,
                "title": "python-faster-than-98",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int: \\n        transformations = []\\n        count = 0\\n        \\n        morse_code = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        for word in words:\\n            m = \\'\\'\\n            for char in word:\\n                m += morse_code[ord(char)-97]\\n            \\n            if m not in transformations:\\n                transformations.append(m)\\n                count +=1\\n        \\n        return count\\n\\'\\'\\'\\n\\nRuntime: 24 ms, faster than 98.75% of Python3 online submissions for Unique Morse Code Words.\\nMemory Usage: 14.4 MB, less than 13.24% of Python3 online submissions for Unique Morse Code Words.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int: \\n        transformations = []\\n        count = 0\\n        \\n        morse_code = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        for word in words:\\n            m = \\'\\'\\n            for char in word:\\n                m += morse_code[ord(char)-97]\\n            \\n            if m not in transformations:\\n                transformations.append(m)\\n                count +=1\\n        \\n        return count\\n\\'\\'\\'\\n\\nRuntime: 24 ms, faster than 98.75% of Python3 online submissions for Unique Morse Code Words.\\nMemory Usage: 14.4 MB, less than 13.24% of Python3 online submissions for Unique Morse Code Words.",
                "codeTag": "Java"
            },
            {
                "id": 945532,
                "title": "c-linear-scan-and-hash-set",
                "content": "```\\nclass Solution { // Linear scan and hash set\\npublic: \\n// Time/Space: O(N*M); O(N*M*P); \\n//where N is the number of word in the vector of \\'words\\',M is the maximal length of a word in \\'words\\', \\n//P is the maximal length of the Morse code for each letter.\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> m{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\t\\t// string m[26]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}; // ok\\n        unordered_set<string> sset;\\n        for(const auto& w: words){\\n            string temp;\\n            for(const char& c: w) temp += m[c-\\'a\\'];\\n            sset.insert(temp);\\n        }\\n        return sset.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { // Linear scan and hash set\\npublic: \\n// Time/Space: O(N*M); O(N*M*P); \\n//where N is the number of word in the vector of \\'words\\',M is the maximal length of a word in \\'words\\', \\n//P is the maximal length of the Morse code for each letter.\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> m{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\t\\t// string m[26]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}; // ok\\n        unordered_set<string> sset;\\n        for(const auto& w: words){\\n            string temp;\\n            for(const char& c: w) temp += m[c-\\'a\\'];\\n            sset.insert(temp);\\n        }\\n        return sset.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944888,
                "title": "python",
                "content": "```python\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        code_words = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        uq = set()\\n        for word in words:\\n            this = []\\n            for c in word:\\n                this.append(code_words[ord(c)-97])\\n            uq.add(\\'\\'.join(this))\\n            \\n        return(len(uq))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        code_words = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        uq = set()\\n        for word in words:\\n            this = []\\n            for c in word:\\n                this.append(code_words[ord(c)-97])\\n            uq.add(\\'\\'.join(this))\\n            \\n        return(len(uq))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285283,
                "title": "4ms-93-66-c-solution",
                "content": "```\\nstruct Entry_s {\\n    char *key;\\n    int value;\\n    struct Entry_s *next;\\n};\\n\\ntypedef struct Entry_s Entry;\\n\\nstruct Hashtable_s {\\n    int size;\\n    int keys;\\n    struct Entry_s** table;\\n};\\n\\ntypedef struct Hashtable_s Hashtable;\\n\\nint hash(Hashtable *hashtable, char *key) {\\n    unsigned long int hashvalue = 0;\\n    int idx = 0;\\n    while (hashvalue < ULONG_MAX && idx < strlen(key)) {\\n        hashvalue = hashvalue << 8;\\n        hashvalue += key[idx];\\n        idx++;\\n    }\\n    return hashvalue % hashtable->size;\\n}\\n\\nEntry *createEntry(char *key, int value) {\\n    Entry *entry = (Entry *) malloc(sizeof(Entry));\\n    entry->key = strdup(key);\\n    entry->value = value;\\n    entry->next = NULL;\\n    return entry;\\n}\\n\\nvoid set(Hashtable *hashtable, char *key, int value) {\\n    Entry *entry = createEntry(key, value);\\n    int hashvalue = hash(hashtable, key);\\n    if (hashtable->table[hashvalue] == NULL) {\\n        hashtable->table[hashvalue] = entry;\\n        hashtable->keys++;\\n    } else {\\n        Entry *current = hashtable->table[hashvalue];\\n        while (current != NULL) {\\n            if (strcmp(current->key, key) == 0) return;\\n            if (current->next == NULL) {\\n                current->next = entry;\\n                hashtable->keys++;\\n            }\\n            current = current-> next;\\n        }\\n    }\\n}\\n\\nint *get(Hashtable *hashtable, char *key) {\\n    int hashvalue = hash(hashtable, key);\\n    if (hashtable->table[hashvalue] != NULL) {\\n        Entry *current = hashtable->table[hashvalue];\\n        while (current != NULL) {\\n            if (strcmp(current->key, key) == 0) {\\n                return &(current->value);\\n            }\\n            current = current->next;\\n        }\\n        return NULL;\\n    }\\n    return NULL;\\n}\\n\\nHashtable *createHashtable(int size) {\\n    Hashtable *hashtable = (Hashtable *) malloc(sizeof(Hashtable));\\n    hashtable->size = size;\\n    hashtable->keys = 0;\\n    hashtable->table = (Entry **) calloc(size, sizeof(Entry *));\\n    return hashtable;\\n}\\n\\nchar morse[][5] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\nchar *getMorse(char *str) {\\n    char *morseRep = (char *) malloc(200 * sizeof(char));\\n    int morseIdx = 0;\\n    for (int index = 0; str[index] != \\'\\\\0\\'; index++) {\\n        for (int idx = 0; morse[str[index] - 97][idx] != \\'\\\\0\\'; idx++) {\\n            morseRep[morseIdx++] = morse[str[index] - 97][idx];\\n        }\\n    }\\n    morseRep[morseIdx] = \\'\\\\0\\';\\n    return morseRep;\\n}\\n\\nint uniqueMorseRepresentations(char ** words, int wordsSize){\\n    Hashtable *hashtable = createHashtable(wordsSize);\\n    for (int index = 0; index < wordsSize; index++) {\\n        char *morse = getMorse(words[index]);\\n        set(hashtable, morse, 1);\\n    }\\n    return hashtable->keys;\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct Entry_s {\\n    char *key;\\n    int value;\\n    struct Entry_s *next;\\n};\\n\\ntypedef struct Entry_s Entry;\\n\\nstruct Hashtable_s {\\n    int size;\\n    int keys;\\n    struct Entry_s** table;\\n};\\n\\ntypedef struct Hashtable_s Hashtable;\\n\\nint hash(Hashtable *hashtable, char *key) {\\n    unsigned long int hashvalue = 0;\\n    int idx = 0;\\n    while (hashvalue < ULONG_MAX && idx < strlen(key)) {\\n        hashvalue = hashvalue << 8;\\n        hashvalue += key[idx];\\n        idx++;\\n    }\\n    return hashvalue % hashtable->size;\\n}\\n\\nEntry *createEntry(char *key, int value) {\\n    Entry *entry = (Entry *) malloc(sizeof(Entry));\\n    entry->key = strdup(key);\\n    entry->value = value;\\n    entry->next = NULL;\\n    return entry;\\n}\\n\\nvoid set(Hashtable *hashtable, char *key, int value) {\\n    Entry *entry = createEntry(key, value);\\n    int hashvalue = hash(hashtable, key);\\n    if (hashtable->table[hashvalue] == NULL) {\\n        hashtable->table[hashvalue] = entry;\\n        hashtable->keys++;\\n    } else {\\n        Entry *current = hashtable->table[hashvalue];\\n        while (current != NULL) {\\n            if (strcmp(current->key, key) == 0) return;\\n            if (current->next == NULL) {\\n                current->next = entry;\\n                hashtable->keys++;\\n            }\\n            current = current-> next;\\n        }\\n    }\\n}\\n\\nint *get(Hashtable *hashtable, char *key) {\\n    int hashvalue = hash(hashtable, key);\\n    if (hashtable->table[hashvalue] != NULL) {\\n        Entry *current = hashtable->table[hashvalue];\\n        while (current != NULL) {\\n            if (strcmp(current->key, key) == 0) {\\n                return &(current->value);\\n            }\\n            current = current->next;\\n        }\\n        return NULL;\\n    }\\n    return NULL;\\n}\\n\\nHashtable *createHashtable(int size) {\\n    Hashtable *hashtable = (Hashtable *) malloc(sizeof(Hashtable));\\n    hashtable->size = size;\\n    hashtable->keys = 0;\\n    hashtable->table = (Entry **) calloc(size, sizeof(Entry *));\\n    return hashtable;\\n}\\n\\nchar morse[][5] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\nchar *getMorse(char *str) {\\n    char *morseRep = (char *) malloc(200 * sizeof(char));\\n    int morseIdx = 0;\\n    for (int index = 0; str[index] != \\'\\\\0\\'; index++) {\\n        for (int idx = 0; morse[str[index] - 97][idx] != \\'\\\\0\\'; idx++) {\\n            morseRep[morseIdx++] = morse[str[index] - 97][idx];\\n        }\\n    }\\n    morseRep[morseIdx] = \\'\\\\0\\';\\n    return morseRep;\\n}\\n\\nint uniqueMorseRepresentations(char ** words, int wordsSize){\\n    Hashtable *hashtable = createHashtable(wordsSize);\\n    for (int index = 0; index < wordsSize; index++) {\\n        char *morse = getMorse(words[index]);\\n        set(hashtable, morse, 1);\\n    }\\n    return hashtable->keys;\\n}\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 240121,
                "title": "python-o-n-beats-100",
                "content": "```python\\nclass Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        morse = {\\'a\\':\".-\",\\n                 \\'b\\':\"-...\",\\n                 \\'c\\':\"-.-.\",\\n                 \\'d\\':\"-..\",\\n                 \\'e\\':\".\",\\n                 \\'f\\':\"..-.\",\\n                 \\'g\\':\"--.\",\\n                 \\'h\\':\"....\",\\n                 \\'i\\':\"..\",\\n                 \\'j\\':\".---\",\\n                 \\'k\\':\"-.-\",\\n                 \\'l\\':\".-..\",\\n                 \\'m\\':\"--\",\\n                 \\'n\\':\"-.\",\\n                 \\'o\\':\"---\",\\n                 \\'p\\':\".--.\",\\n                 \\'q\\':\"--.-\",\\n                 \\'r\\':\".-.\",\\n                 \\'s\\':\"...\",\\n                 \\'t\\':\"-\",\\n                 \\'u\\':\"..-\",\\n                 \\'v\\':\"...-\",\\n                 \\'w\\':\".--\",\\n                 \\'x\\':\"-..-\",\\n                 \\'y\\':\"-.--\",\\n                 \\'z\\':\"--..\"}\\n        \\n        transformations = set()\\n        for word in words:\\n            transformation = \\'\\'\\n            for c in word:\\n                transformation += morse[c]\\n            transformations.add(transformation)\\n            \\n        return len(transformations)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        morse = {\\'a\\':\".-\",\\n                 \\'b\\':\"-...\",\\n                 \\'c\\':\"-.-.\",\\n                 \\'d\\':\"-..\",\\n                 \\'e\\':\".\",\\n                 \\'f\\':\"..-.\",\\n                 \\'g\\':\"--.\",\\n                 \\'h\\':\"....\",\\n                 \\'i\\':\"..\",\\n                 \\'j\\':\".---\",\\n                 \\'k\\':\"-.-\",\\n                 \\'l\\':\".-..\",\\n                 \\'m\\':\"--\",\\n                 \\'n\\':\"-.\",\\n                 \\'o\\':\"---\",\\n                 \\'p\\':\".--.\",\\n                 \\'q\\':\"--.-\",\\n                 \\'r\\':\".-.\",\\n                 \\'s\\':\"...\",\\n                 \\'t\\':\"-\",\\n                 \\'u\\':\"..-\",\\n                 \\'v\\':\"...-\",\\n                 \\'w\\':\".--\",\\n                 \\'x\\':\"-..-\",\\n                 \\'y\\':\"-.--\",\\n                 \\'z\\':\"--..\"}\\n        \\n        transformations = set()\\n        for word in words:\\n            transformation = \\'\\'\\n            for c in word:\\n                transformation += morse[c]\\n            transformations.add(transformation)\\n            \\n        return len(transformations)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137639,
                "title": "4ms-in-c",
                "content": "\\n```\\n#include <string.h>\\n\\nchar *getMorseString(char c)\\n{\\n    char *morse[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    \\n    return morse[c - \\'a\\'];\\n}\\n\\nvoid setMorseTransform(char *word, char *transform)\\n{    \\n    char *morseString;\\n    \\n    // Add each Morse character of each alphabetical letter from the word to the transform string\\n    while(*word)\\n    {\\n        morseString = getMorseString(*(word++));\\n            \\n        while(*morseString)\\n            *(transform++) = *(morseString++);\\n    }\\n    \\n    // Add the null terminating character to the end of the transform string\\n    *transform = \\'\\\\0\\';\\n    \\n    return;\\n}\\n\\n\\nint uniqueMorseRepresentations(char** words, int wordsSize) \\n{\\n    char *dd, *m, *c, transforms[100][50] = {\"\"};\\n    int counter, i, j, trans_count = 0;\\n    \\n    // Populate the Morse transform array with an entry for each word\\n    for(i = 0; i < wordsSize; i++)\\n        setMorseTransform(words[i], transforms[i]);\\n    \\n    // Starting with first element, perform linear search through array for duplicates.\\n    // When a duplicate transform is found, copy the\\n    // last element in the transform array to position j, and decrement wordsSize.\\n    //\\n    // If the new element at transforms[j] is also a duplicate, repeat the process until\\n    // a non-duplicate is found or wordsSize is less than 2.\\n    //\\n    // The end result should be a de-duplicated array of transforms.\\n    \\n    for(i = 0; i < wordsSize; i++)\\n        for(j = i+1; j < (wordsSize); j++)\\n            while(j < wordsSize && wordsSize > 1 && !strcmp(transforms[i], transforms[j]))\\n            {\\n                strcpy(transforms[j], transforms[wordsSize - 1]);\\n                --wordsSize;\\n            }\\n        \\n    return wordsSize;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#include <string.h>\\n\\nchar *getMorseString(char c)\\n{\\n    char *morse[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    \\n    return morse[c - \\'a\\'];\\n}\\n\\nvoid setMorseTransform(char *word, char *transform)\\n{    \\n    char *morseString;\\n    \\n    // Add each Morse character of each alphabetical letter from the word to the transform string\\n    while(*word)\\n    {\\n        morseString = getMorseString(*(word++));\\n            \\n        while(*morseString)\\n            *(transform++) = *(morseString++);\\n    }\\n    \\n    // Add the null terminating character to the end of the transform string\\n    *transform = \\'\\\\0\\';\\n    \\n    return;\\n}\\n\\n\\nint uniqueMorseRepresentations(char** words, int wordsSize) \\n{\\n    char *dd, *m, *c, transforms[100][50] = {\"\"};\\n    int counter, i, j, trans_count = 0;\\n    \\n    // Populate the Morse transform array with an entry for each word\\n    for(i = 0; i < wordsSize; i++)\\n        setMorseTransform(words[i], transforms[i]);\\n    \\n    // Starting with first element, perform linear search through array for duplicates.\\n    // When a duplicate transform is found, copy the\\n    // last element in the transform array to position j, and decrement wordsSize.\\n    //\\n    // If the new element at transforms[j] is also a duplicate, repeat the process until\\n    // a non-duplicate is found or wordsSize is less than 2.\\n    //\\n    // The end result should be a de-duplicated array of transforms.\\n    \\n    for(i = 0; i < wordsSize; i++)\\n        for(j = i+1; j < (wordsSize); j++)\\n            while(j < wordsSize && wordsSize > 1 && !strcmp(transforms[i], transforms[j]))\\n            {\\n                strcpy(transforms[j], transforms[wordsSize - 1]);\\n                --wordsSize;\\n            }\\n        \\n    return wordsSize;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3471332,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n        int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> d = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        unordered_set<string> s;\\n        for (auto w : words) {\\n            string code;\\n            for (auto c : w) code += d[c - \\'a\\'];\\n            s.insert(code);\\n        }\\n        return s.size();\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\n        table = {}\\n        i = \\'a\\'\\n        for m in morse:\\n            table[i] = m\\n            i = chr(ord(i) + 1)\\n        pairs = set()\\n        for word in words:\\n            string = \"\"\\n            for w in word:\\n                string += table[w]\\n            pairs.add(string)\\n        return len(pairs)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morseCode = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        Set<String> set = new HashSet<>();\\n        for(String word : words){\\n            StringBuilder sb = new StringBuilder();\\n            for(char c : word.toCharArray()){\\n                sb.append(morseCode[c - \\'a\\']);\\n            }\\n            set.add(sb.toString());\\n        } \\n        return set.size();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n        int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> d = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        unordered_set<string> s;\\n        for (auto w : words) {\\n            string code;\\n            for (auto c : w) code += d[c - \\'a\\'];\\n            s.insert(code);\\n        }\\n        return s.size();\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\n        table = {}\\n        i = \\'a\\'\\n        for m in morse:\\n            table[i] = m\\n            i = chr(ord(i) + 1)\\n        pairs = set()\\n        for word in words:\\n            string = \"\"\\n            for w in word:\\n                string += table[w]\\n            pairs.add(string)\\n        return len(pairs)\\n```\n```Java []\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morseCode = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        Set<String> set = new HashSet<>();\\n        for(String word : words){\\n            StringBuilder sb = new StringBuilder();\\n            for(char c : word.toCharArray()){\\n                sb.append(morseCode[c - \\'a\\']);\\n            }\\n            set.add(sb.toString());\\n        } \\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437307,
                "title": "simple-easy-concise-solution-for-java-hashset",
                "content": "```\\nclass Solution {\\n    private String transform(String str) {\\n        String s[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"},res=\"\";\\n        for(int i=0;i<str.length();i++)\\n            res+=s[(int)str.charAt(i)-\\'a\\'];\\n        return res;\\n    }\\n    \\n    public int uniqueMorseRepresentations(String[] words) {\\n        HashSet<String> set = new HashSet<String>();\\n        for(String w : words) set.add(transform(w));\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    private String transform(String str) {\\n        String s[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"},res=\"\";\\n        for(int i=0;i<str.length();i++)\\n            res+=s[(int)str.charAt(i)-\\'a\\'];\\n        return res;\\n    }\\n    \\n    public int uniqueMorseRepresentations(String[] words) {\\n        HashSet<String> set = new HashSet<String>();\\n        for(String w : words) set.add(transform(w));\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436985,
                "title": "javascript-fast-and-simple-single-iteration-of-words-solution-hashmap-set",
                "content": "```\\nconst morseCode = { a: \".-\", b: \"-...\", c: \"-.-.\", d: \"-..\", e: \".\", f: \"..-.\", g: \"--.\", h: \"....\", i: \"..\", j: \".---\", k: \"-.-\", l: \".-..\", m: \"--\", n: \"-.\", o: \"---\", p: \".--.\", q: \"--.-\", r: \".-.\", s: \"...\", t: \"-\", u: \"..-\", v: \"...-\", w: \".--\", x: \"-..-\", y: \"-.--\", z: \"--..\" }\\n\\nfunction uniqueMorseRepresentations(words) {\\n    const set = new Set();\\n\\n    for(let i = 0; i < words.length; i++) {\\n        let encryptedWord = \"\";\\n\\n        for (let l = 0; l < words[i].length; l++) {\\n            const character = words[i][l];\\n            \\n            encryptedWord += morseCode[character];\\n        }\\n\\n        set.add(encryptedWord);\\n    }\\n\\n    return set.size;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nconst morseCode = { a: \".-\", b: \"-...\", c: \"-.-.\", d: \"-..\", e: \".\", f: \"..-.\", g: \"--.\", h: \"....\", i: \"..\", j: \".---\", k: \"-.-\", l: \".-..\", m: \"--\", n: \"-.\", o: \"---\", p: \".--.\", q: \"--.-\", r: \".-.\", s: \"...\", t: \"-\", u: \"..-\", v: \"...-\", w: \".--\", x: \"-..-\", y: \"-.--\", z: \"--..\" }\\n\\nfunction uniqueMorseRepresentations(words) {\\n    const set = new Set();\\n\\n    for(let i = 0; i < words.length; i++) {\\n        let encryptedWord = \"\";\\n\\n        for (let l = 0; l < words[i].length; l++) {\\n            const character = words[i][l];\\n            \\n            encryptedWord += morseCode[character];\\n        }\\n\\n        set.add(encryptedWord);\\n    }\\n\\n    return set.size;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2436616,
                "title": "c-set-and-vectors",
                "content": "1.  keep the morse codes in a vector.\\n2.  iterate thru each character of each word\\n3.  build the code with the morse codes\\n4.  put the code in a set\\n5.  return the size of the set\\n6.  **Tune in to TWITCH to watch me solve it LIVE ON STREAM with my cool keyboards.  6pm Pacific time.  Link in profile.**\\n  \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        unordered_set<string> codes;\\n        vector<string> morses = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        for(auto& word : words) {\\n            string curCode = \"\";\\n            for(char c : word) {\\n                curCode += morses[c - \\'a\\'];\\n            }\\n            codes.insert(curCode);\\n        }\\n        return codes.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        unordered_set<string> codes;\\n        vector<string> morses = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        for(auto& word : words) {\\n            string curCode = \"\";\\n            for(char c : word) {\\n                curCode += morses[c - \\'a\\'];\\n            }\\n            codes.insert(curCode);\\n        }\\n        return codes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436612,
                "title": "c-easy-solution-using-hashmap",
                "content": "# **C++ Easy solution Using Hashmap**\\n```\\nclass Solution {\\n    \\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        string arr[]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_map<string,int>m;\\n        for(int i=0;i<words.size();i++){\\n            string s=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                s+=arr[words[i][j]-\\'a\\'];\\n            }\\n            m[s]++;\\n        }\\n        return m.size();\\n    }\\n};\\n```\\n# **Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        string arr[]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_map<string,int>m;\\n        for(int i=0;i<words.size();i++){\\n            string s=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                s+=arr[words[i][j]-\\'a\\'];\\n            }\\n            m[s]++;\\n        }\\n        return m.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362150,
                "title": "solution-in-python-3-beats-100-two-lines",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n    \\tM = [\\'.-\\',\\'-...\\',\\'-.-.\\',\\'-..\\',\\'.\\',\\'..-.\\',\\'--.\\',\\'....\\',\\'..\\',\\'.---\\',\\'-.-\\',\\'.-..\\',\\'--\\',\\'-.\\',\\'---\\',\\'.--.\\',\\'--.-\\',\\'.-.\\',\\'...\\',\\'-\\',\\'..-\\',\\'...-\\',\\'.--\\',\\'-..-\\',\\'-.--\\',\\'--..\\']\\n    \\treturn len(set([\\'\\'.join(map(lambda x: M[ord(x)-97], w)) for w in words]))\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n    \\tM = [\\'.-\\',\\'-...\\',\\'-.-.\\',\\'-..\\',\\'.\\',\\'..-.\\',\\'--.\\',\\'....\\',\\'..\\',\\'.---\\',\\'-.-\\',\\'.-..\\',\\'--\\',\\'-.\\',\\'---\\',\\'.--.\\',\\'--.-\\',\\'.-.\\',\\'...\\',\\'-\\',\\'..-\\',\\'...-\\',\\'.--\\',\\'-..-\\',\\'-.--\\',\\'--..\\']\\n    \\treturn len(set([\\'\\'.join(map(lambda x: M[ord(x)-97], w)) for w in words]))\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 351647,
                "title": "swift-5-12ms",
                "content": "```\\nclass Solution {\\n    func uniqueMorseRepresentations(_ words: [String]) -> Int {\\n        let morse: [Character : String] = [\"a\": \".-\", \"b\": \"-...\", \"c\": \"-.-.\", \"d\": \"-..\", \"e\": \".\", \"f\": \"..-.\", \"g\": \"--.\", \"h\": \"....\", \"i\": \"..\", \"j\": \".---\", \"k\": \"-.-\", \"l\": \".-..\", \"m\": \"--\", \"n\": \"-.\", \"o\": \"---\", \"p\": \".--.\", \"q\": \"--.-\", \"r\": \".-.\", \"s\": \"...\", \"t\": \"-\", \"u\": \"..-\", \"v\": \"...-\", \"w\": \".--\", \"x\": \"-..-\", \"y\": \"-.--\", \"z\": \"--..\"]\\n\\n        return words.reduce(into: Set<String>()) {\\n            let transform = $1.reduce(into: \"\") { $0 += morse[$1] ?? \"\" }\\n            $0.insert(transform)\\n        }.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func uniqueMorseRepresentations(_ words: [String]) -> Int {\\n        let morse: [Character : String] = [\"a\": \".-\", \"b\": \"-...\", \"c\": \"-.-.\", \"d\": \"-..\", \"e\": \".\", \"f\": \"..-.\", \"g\": \"--.\", \"h\": \"....\", \"i\": \"..\", \"j\": \".---\", \"k\": \"-.-\", \"l\": \".-..\", \"m\": \"--\", \"n\": \"-.\", \"o\": \"---\", \"p\": \".--.\", \"q\": \"--.-\", \"r\": \".-.\", \"s\": \"...\", \"t\": \"-\", \"u\": \"..-\", \"v\": \"...-\", \"w\": \".--\", \"x\": \"-..-\", \"y\": \"-.--\", \"z\": \"--..\"]\\n\\n        return words.reduce(into: Set<String>()) {\\n            let transform = $1.reduce(into: \"\") { $0 += morse[$1] ?? \"\" }\\n            $0.insert(transform)\\n        }.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348948,
                "title": "python-3-using-dict-and-set",
                "content": "The idea is to map each character in the alphabet to a Morse code in a dictionary. Then use this map to make a set of words formated in Morse Code. Then return `len(set())`\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        code = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\" \\\\\\n             ,\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\" \\\\\\n             ,\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        D = dict( zip( string.ascii_lowercase,code ) ) # string.ascii_lowercase returns \"abc...xyz\"\\n        \\n\\t\\ts = set()\\n        for word in words:\\n\\t\\t\\t# add the joint of letter (in code format) to a set\\n            s.add(\"\".join( [ D[letter] for letter in word ] ) ) \\n        return len(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        code = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\" \\\\\\n             ,\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\" \\\\\\n             ,\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        D = dict( zip( string.ascii_lowercase,code ) ) # string.ascii_lowercase returns \"abc...xyz\"\\n        \\n\\t\\ts = set()\\n        for word in words:\\n\\t\\t\\t# add the joint of letter (in code format) to a set\\n            s.add(\"\".join( [ D[letter] for letter in word ] ) ) \\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296064,
                "title": "javascript-solution",
                "content": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    \\n    morsecode = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    \\n    let set = new Set()\\n    \\n    for(let word of words){\\n        let mc = \"\"\\n        for(let c of word){\\n            mc += morsecode[c.charCodeAt(0)-\\'a\\'.charCodeAt(0)]\\n        }\\n        set.add(mc)\\n    }\\n    return set.size\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    \\n    morsecode = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    \\n    let set = new Set()\\n    \\n    for(let word of words){\\n        let mc = \"\"\\n        for(let c of word){\\n            mc += morsecode[c.charCodeAt(0)-\\'a\\'.charCodeAt(0)]\\n        }\\n        set.add(mc)\\n    }\\n    return set.size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151852,
                "title": "python-solution-beats-100",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        transformation = []\\n        for word in words:\\n            temp = []\\n            for char in word:\\n                temp.append(morse[ord(char)-97])\\n            transformation.append(\\'\\'.join(temp))\\n        return len(set(transformation))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        transformation = []\\n        for word in words:\\n            temp = []\\n            for char in word:\\n                temp.append(morse[ord(char)-97])\\n            transformation.append(\\'\\'.join(temp))\\n        return len(set(transformation))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128738,
                "title": "declarative-javascript",
                "content": "Doesn\\'t get better than a good\\'ole map.reduce and JSON\\n\\n```\\nvar morse = {\\n    a: \".-\",\\n    b: \"-...\",\\n    c: \"-.-.\",\\n    d: \"-..\",\\n    e: \".\",\\n    f: \"..-.\",\\n    g: \"--.\",\\n    h: \"....\",\\n    i: \"..\",\\n    j: \".---\",\\n    k: \"-.-\",\\n    l: \".-..\",\\n    m: \"--\",\\n    n: \"-.\",\\n    o: \"---\",\\n    p: \".--.\",\\n    q: \"--.-\",\\n    r: \".-.\",\\n    s: \"...\",\\n    t: \"-\",\\n    u: \"..-\",\\n    v: \"...-\",\\n    w: \".--\",\\n    x: \"-..-\",\\n    y: \"-.--\",\\n    z: \"--..\"\\n}\\n\\n\\nvar uniqueMorseRepresentations = function(words) {\\n    \\n    const transformWord = (word) => Array.from(word).reduce((acc, char) => acc + morse[char], \\'\\')\\n    const addToSet = (set, word) => set.add(word)\\n    \\n    return words.map(transformWord).reduce(addToSet, new Set([])).size    \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar morse = {\\n    a: \".-\",\\n    b: \"-...\",\\n    c: \"-.-.\",\\n    d: \"-..\",\\n    e: \".\",\\n    f: \"..-.\",\\n    g: \"--.\",\\n    h: \"....\",\\n    i: \"..\",\\n    j: \".---\",\\n    k: \"-.-\",\\n    l: \".-..\",\\n    m: \"--\",\\n    n: \"-.\",\\n    o: \"---\",\\n    p: \".--.\",\\n    q: \"--.-\",\\n    r: \".-.\",\\n    s: \"...\",\\n    t: \"-\",\\n    u: \"..-\",\\n    v: \"...-\",\\n    w: \".--\",\\n    x: \"-..-\",\\n    y: \"-.--\",\\n    z: \"--..\"\\n}\\n\\n\\nvar uniqueMorseRepresentations = function(words) {\\n    \\n    const transformWord = (word) => Array.from(word).reduce((acc, char) => acc + morse[char], \\'\\')\\n    const addToSet = (set, word) => set.add(word)\\n    \\n    return words.map(transformWord).reduce(addToSet, new Set([])).size    \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3846821,
                "title": "simple-easy-solution-beats-99-30-ms-accepted",
                "content": "# Code\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, x: List[str]) -> int:\\n        a=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return len(set([\"\".join([a[ord(i)-97] for i in j]) for j in x]))\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, x: List[str]) -> int:\\n        a=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return len(set([\"\".join([a[ord(i)-97] for i in j]) for j in x]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649613,
                "title": "simple-understandable-solution-python-code",
                "content": "# Approach\\n- Convert each word in words array to its corresponding encrypted text\\n- Check if the encrypted text is present in transformations array/list or not\\n- If not present then add it\\n- Finally return the total number of transformations present\\n\\n# Do Upvote if u like it :)\\n\\n# Code\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\n        cipher_txt = \\'\\'\\n        transformations = []\\n\\n        if len(words) == 0:\\n            return 0\\n        \\n        for word in words:\\n            for alpha in word:\\n                cipher_txt = cipher_txt + morse[ord(alpha) - 97]\\n\\n            if cipher_txt not in transformations:\\n                transformations.append(cipher_txt)\\n\\n            cipher_txt = \\'\\'\\n        \\n        return len(transformations)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\n        cipher_txt = \\'\\'\\n        transformations = []\\n\\n        if len(words) == 0:\\n            return 0\\n        \\n        for word in words:\\n            for alpha in word:\\n                cipher_txt = cipher_txt + morse[ord(alpha) - 97]\\n\\n            if cipher_txt not in transformations:\\n                transformations.append(cipher_txt)\\n\\n            cipher_txt = \\'\\'\\n        \\n        return len(transformations)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098442,
                "title": "easiest-approach-c-hasing",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> hash={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string>unique;\\n        for(int i=0;i<words.size();i++){\\n            string temp=\"\";\\n            for(int j=0;j<words[i].length();j++){\\n                temp+=hash[words[i][j]-97];\\n            }\\n            unique.insert(temp);\\n        }\\n        return unique.size();\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> hash={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string>unique;\\n        for(int i=0;i<words.size();i++){\\n            string temp=\"\";\\n            for(int j=0;j<words[i].length();j++){\\n                temp+=hash[words[i][j]-97];\\n            }\\n            unique.insert(temp);\\n        }\\n        return unique.size();\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796304,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nk) k->word length.\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    String[] morseCode = new String[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    public int uniqueMorseRepresentations(String[] words) {\\n       Set<String> code=new HashSet<>();\\n   \\n\\n       for(String word:words){\\n           StringBuilder sb=new StringBuilder();\\n\\n           for(char c:word.toCharArray()){\\n               int index=c-\\'a\\';\\n               sb.append(morseCode[index]);\\n\\n           }\\n           code.add(sb.toString());\\n       }\\n       \\n       return code.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    String[] morseCode = new String[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    public int uniqueMorseRepresentations(String[] words) {\\n       Set<String> code=new HashSet<>();\\n   \\n\\n       for(String word:words){\\n           StringBuilder sb=new StringBuilder();\\n\\n           for(char c:word.toCharArray()){\\n               int index=c-\\'a\\';\\n               sb.append(morseCode[index]);\\n\\n           }\\n           code.add(sb.toString());\\n       }\\n       \\n       return code.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621809,
                "title": "python3-best-solution-o-n-k-where-k-is-a-max-length-of-string",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        arr = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        s =set()\\n        for word in words:\\n            string = \"\"\\n            for ele in word:\\n                string+=arr[ord(ele)-97]\\n            s.add(string)\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        arr = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        s =set()\\n        for word in words:\\n            string = \"\"\\n            for ele in word:\\n                string+=arr[ord(ele)-97]\\n            s.add(string)\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544285,
                "title": "js-best-solution-with-hashmap-100",
                "content": "```\\nconst CONFIG = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n\\nvar uniqueMorseRepresentations = function(words) {\\n    let output = 0;\\n    const hashmap = {};\\n    \\n    for (let i = 0; i < words.length; i++) {\\n        const word = words[i];\\n        let code = \\'\\';\\n        for (let j = 0; j < word.length; j++) {\\n            code += CONFIG[word.charCodeAt(j) - 97];\\n        }\\n        \\n        if (hashmap[code] === undefined) {\\n            output++;\\n            hashmap[code] = i;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst CONFIG = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n\\nvar uniqueMorseRepresentations = function(words) {\\n    let output = 0;\\n    const hashmap = {};\\n    \\n    for (let i = 0; i < words.length; i++) {\\n        const word = words[i];\\n        let code = \\'\\';\\n        for (let j = 0; j < word.length; j++) {\\n            code += CONFIG[word.charCodeAt(j) - 97];\\n        }\\n        \\n        if (hashmap[code] === undefined) {\\n            output++;\\n            hashmap[code] = i;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2443616,
                "title": "short-c-best-method",
                "content": "Here is the short code:\\n \\n int uniqueMorseRepresentations(vector<string>& words) {\\n\\t\\t\\tset<string> se;\\n\\t\\t\\tvector<string> v={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\t\\t\\tfor(int i=0;i<words.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring s=\"\";\\n\\t\\t\\t\\tfor(int j=0;j<words[i].length();j++) s+=v[words[i][j]-\\'a\\'];\\n\\t\\t\\t\\tse.insert(s);\\n\\t\\t\\t}\\n\\t\\t\\treturn se.size();\\n    }",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "Here is the short code:\\n \\n int uniqueMorseRepresentations(vector<string>& words) {\\n\\t\\t\\tset<string> se;\\n\\t\\t\\tvector<string> v={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\t\\t\\tfor(int i=0;i<words.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring s=\"\";\\n\\t\\t\\t\\tfor(int j=0;j<words[i].length();j++) s+=v[words[i][j]-\\'a\\'];\\n\\t\\t\\t\\tse.insert(s);\\n\\t\\t\\t}\\n\\t\\t\\treturn se.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2439894,
                "title": "easy-peasy-solution-in-python",
                "content": "\\tclass Solution:\\n\\t\\tdef uniqueMorseRepresentations(self, words) -> int:\\n\\n\\t\\t\\tans = set()\\n\\t\\t\\ttrans = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\", \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}\\n\\n\\t\\t\\tfor i in words:\\n\\t\\t\\t\\ttemp = \\'\\'\\n\\t\\t\\t\\tfor j in i:\\n\\t\\t\\t\\t\\ttemp += trans[j]\\n\\t\\t\\t\\tans.add(temp)\\n\\n\\t\\t\\treturn len(ans)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\t\\tdef uniqueMorseRepresentations(self, words) -> int:\\n\\n\\t\\t\\tans = set()\\n\\t\\t\\ttrans = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\", \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}",
                "codeTag": "Java"
            },
            {
                "id": 2438990,
                "title": "for-beginners-java-using-set-only",
                "content": "```\\nclass Solution {\\n    public String []check;\\n    public int uniqueMorseRepresentations(String[] words) {\\n        check = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        HashSet<String> set = new HashSet<String>();\\n        for(String temp : words) set.add(helper(temp));\\n        return set.size();\\n    }\\n    public String helper(String word){\\n        String ans = \"\";\\n        for(int i = 0; i < word.length(); i++) ans += check[(int)word.charAt(i) - \\'a\\'];\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String []check;\\n    public int uniqueMorseRepresentations(String[] words) {\\n        check = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}",
                "codeTag": "Java"
            },
            {
                "id": 2437862,
                "title": "1-liner-python-solution",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        translate = {\\'\\'.join([morse[ord(c)-97] for c in word]) for word in words}\\n        return len(translate)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        translate = {\\'\\'.join([morse[ord(c)-97] for c in word]) for word in words}\\n        return len(translate)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437777,
                "title": "easy-and-100-faster-0ms",
                "content": "We traverse through the vector and for each word, we convert it to morse directly using the array we are given in the question. \\nInsert this new string into set so there are no repeatitions in them. \\nThe size of this set is the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        set<string> st;\\n        const char* morse[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        for(auto word:words){\\n            string ans=\"\";\\n            for(auto ch:word)\\n                ans+=morse[ch-\\'a\\'];\\n            st.insert(ans);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        set<string> st;\\n        const char* morse[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        for(auto word:words){\\n            string ans=\"\";\\n            for(auto ch:word)\\n                ans+=morse[ch-\\'a\\'];\\n            st.insert(ans);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437699,
                "title": "c-modular-code-0ms-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/02569a9b-b09e-41aa-a8cc-3d08a2e27772_1660717258.9231017.png)\\n```\\nstring arr[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    string string_to_morse(string s){\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            temp+=arr[s[i]-97];\\n        }\\n        return temp;\\n    }\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        unordered_set<string>st;\\n        for(int i=0;i<words.size();i++){\\n            st.insert(string_to_morse(words[i]));\\n        }\\n        return st.size();\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/02569a9b-b09e-41aa-a8cc-3d08a2e27772_1660717258.9231017.png)\\n```\\nstring arr[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    string string_to_morse(string s){\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            temp+=arr[s[i]-97];\\n        }\\n        return temp;\\n    }\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        unordered_set<string>st;\\n        for(int i=0;i<words.size();i++){\\n            st.insert(string_to_morse(words[i]));\\n        }\\n        return st.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2437571,
                "title": "java-solution-easy-solution",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Map<Character, String> res = new HashMap<>();\\n        res.put(\\'a\\', \".-\"); res.put(\\'b\\', \"-...\"); res.put(\\'c\\', \"-.-.\"); res.put(\\'d\\', \"-..\"); res.put(\\'e\\', \".\");           res.put(\\'f\\', \"..-.\");res.put(\\'g\\', \"--.\"); res.put(\\'h\\', \"....\"); res.put(\\'i\\', \"..\"); res.put(\\'j\\', \".---\");         res.put(\\'k\\', \"-.-\"); res.put(\\'l\\', \".-..\"); res.put(\\'m\\', \"--\"); res.put(\\'n\\', \"-.\"); res.put(\\'o\\', \"---\");\\n        res.put(\\'p\\', \".--.\"); res.put(\\'q\\', \"--.-\"); res.put(\\'r\\', \".-.\"); res.put(\\'s\\', \"...\"); res.put(\\'t\\', \"-\");\\n        res.put(\\'u\\', \"..-\"); res.put(\\'v\\', \"...-\"); res.put(\\'w\\', \".--\"); res.put(\\'x\\', \"-..-\");\\n        res.put(\\'y\\', \"-.--\"); res.put(\\'z\\', \"--..\");\\n        Set<String> set = new HashSet<>();\\n        int count = 0;\\n        for(String word : words){\\n            String str = \"\";\\n            for(char ch : word.toCharArray()){\\n                str = str + res.get(ch);\\n            }\\n            if(!set.contains(str)){\\n                set.add(str);\\n                count ++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Map<Character, String> res = new HashMap<>();\\n        res.put(\\'a\\', \".-\"); res.put(\\'b\\', \"-...\"); res.put(\\'c\\', \"-.-.\"); res.put(\\'d\\', \"-..\"); res.put(\\'e\\', \".\");           res.put(\\'f\\', \"..-.\");res.put(\\'g\\', \"--.\"); res.put(\\'h\\', \"....\"); res.put(\\'i\\', \"..\"); res.put(\\'j\\', \".---\");         res.put(\\'k\\', \"-.-\"); res.put(\\'l\\', \".-..\"); res.put(\\'m\\', \"--\"); res.put(\\'n\\', \"-.\"); res.put(\\'o\\', \"---\");\\n        res.put(\\'p\\', \".--.\"); res.put(\\'q\\', \"--.-\"); res.put(\\'r\\', \".-.\"); res.put(\\'s\\', \"...\"); res.put(\\'t\\', \"-\");\\n        res.put(\\'u\\', \"..-\"); res.put(\\'v\\', \"...-\"); res.put(\\'w\\', \".--\"); res.put(\\'x\\', \"-..-\");\\n        res.put(\\'y\\', \"-.--\"); res.put(\\'z\\', \"--..\");\\n        Set<String> set = new HashSet<>();\\n        int count = 0;\\n        for(String word : words){\\n            String str = \"\";\\n            for(char ch : word.toCharArray()){\\n                str = str + res.get(ch);\\n            }\\n            if(!set.contains(str)){\\n                set.add(str);\\n                count ++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437556,
                "title": "easy-to-understand-java-solution-using-hashset-faster-than-99-55",
                "content": "**Please Upvote if you like my approach**\\n\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] chart = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\\n                         \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\\n                         \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\\n                         \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> count = new HashSet();\\n        for (String word : words) {\\n            StringBuilder code = new StringBuilder();\\n            for (char c : word.toCharArray())\\n             code.append(chart[c - \\'a\\']);\\n             count.add(code.toString());\\n        }\\n        return count.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] chart = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\\n                         \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\\n                         \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\\n                         \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> count = new HashSet();\\n        for (String word : words) {\\n            StringBuilder code = new StringBuilder();\\n            for (char c : word.toCharArray())\\n             code.append(chart[c - \\'a\\']);\\n             count.add(code.toString());\\n        }\\n        return count.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437442,
                "title": "c-easy-approach-simple-to-understand-beginner-friendly",
                "content": "```\\nint uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        set<string> output;\\n        for(auto i : words)\\n        {\\n            string s = \"\";\\n            for(int j : i) s += morse[j-97];\\n            output.insert(s);\\n        }\\n        return output.size();\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        set<string> output;\\n        for(auto i : words)\\n        {\\n            string s = \"\";\\n            for(int j : i) s += morse[j-97];\\n            output.insert(s);\\n        }\\n        return output.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2436772,
                "title": "python-easy-understanding-solution",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        s = set()\\n        mos = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        for w in words:                         # Iterate through every word.\\n            m = \\'\\'\\n            for l in w:                         # Iterate through every letter in current word.\\n                m += mos[ord(l) - ord(\\'a\\')]     # Change the letter into morse code.\\n            s.add(m)                            # Use set to avoid replicate answer.\\n        \\n        return len(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        s = set()\\n        mos = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        for w in words:                         # Iterate through every word.\\n            m = \\'\\'\\n            for l in w:                         # Iterate through every letter in current word.\\n                m += mos[ord(l) - ord(\\'a\\')]     # Change the letter into morse code.\\n            s.add(m)                            # Use set to avoid replicate answer.\\n        \\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436763,
                "title": "c-solution-0ms-better-than-100-only-sets-8-lines-comments",
                "content": "![image](https://assets.leetcode.com/users/images/8ceda11d-fd93-4cae-b2d1-304f63a67f15_1660703125.0653307.png)\\n\\n```\\nint uniqueMorseRepresentations(vector<string>& words) {\\n\\tset<string> s;\\n\\t\\n\\t// we map with vector as 0 based indexing for chars, {\\'a\\', \".-\"}, {\\'b\\', \"-...\"}.....\\n\\tvector<string> vec ={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\tstring st;\\n\\t\\n\\t// then we traverse the string and for each characters from the word, \\n\\t// we get its morse code and add it to the set\\n\\tfor(int i=0; i<words.size(); i++){\\n\\t\\tst = \"\";\\n\\t\\tfor(int j=0; j<words[i].length(); j++)\\n\\t\\t\\tst+=vec[words[i][j]-\\'a\\'];\\n\\t\\t\\t\\n\\t\\t// then we add this string to the set, and continue for all the words\\n\\t\\ts.insert(st);\\n\\t}\\n\\treturn s.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint uniqueMorseRepresentations(vector<string>& words) {\\n\\tset<string> s;\\n\\t\\n\\t// we map with vector as 0 based indexing for chars, {\\'a\\', \".-\"}, {\\'b\\', \"-...\"}.....\\n\\tvector<string> vec ={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\tstring st;\\n\\t\\n\\t// then we traverse the string and for each characters from the word, \\n\\t// we get its morse code and add it to the set\\n\\tfor(int i=0; i<words.size(); i++){\\n\\t\\tst = \"\";\\n\\t\\tfor(int j=0; j<words[i].length(); j++)\\n\\t\\t\\tst+=vec[words[i][j]-\\'a\\'];\\n\\t\\t\\t\\n\\t\\t// then we add this string to the set, and continue for all the words\\n\\t\\ts.insert(st);\\n\\t}\\n\\treturn s.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2436736,
                "title": "0ms-with-go-map-string-builder",
                "content": "```\\nfunc uniqueMorseRepresentations(words []string) int {\\n    wordSet := make(map[string]struct{})\\n    \\n    alphabet := []string{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}\\n    \\n    for i := 0; i < len(words); i++ {\\n        var currentWord strings.Builder\\n        \\n        for j := 0; j < len(words[i]); j++ {\\n            currentWord.WriteString(alphabet[words[i][j] - \\'a\\'])\\n        }\\n        \\n        if _, ok := wordSet[currentWord.String()]; !ok {\\n            wordSet[currentWord.String()] = struct{}{}\\n        }\\n    }\\n    \\n    return len(wordSet)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String"
                ],
                "code": "```\\nfunc uniqueMorseRepresentations(words []string) int {\\n    wordSet := make(map[string]struct{})\\n    \\n    alphabet := []string{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}\\n    \\n    for i := 0; i < len(words); i++ {\\n        var currentWord strings.Builder\\n        \\n        for j := 0; j < len(words[i]); j++ {\\n            currentWord.WriteString(alphabet[words[i][j] - \\'a\\'])\\n        }\\n        \\n        if _, ok := wordSet[currentWord.String()]; !ok {\\n            wordSet[currentWord.String()] = struct{}{}\\n        }\\n    }\\n    \\n    return len(wordSet)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2436566,
                "title": "js-set-easy-solution-in-3-lines",
                "content": "## **TL-DR:** Three variations of solution\\n\\n![image](https://assets.leetcode.com/users/images/a5d97667-f9a5-4974-8339-f0528f10ce5f_1660699065.9906268.png)\\n\\n```\\nvar uniqueMorseRepresentations = function(words) {\\n\\tconst morseCode = { a: \".-\", b: \"-...\", c: \"-.-.\", d: \"-..\", e: \".\", f: \"..-.\", g: \"--.\", h: \"....\", i: \"..\", j: \".---\", k: \"-.-\", l: \".-..\", m: \"--\", n: \"-.\", o: \"---\", p: \".--.\", q: \"--.-\", r: \".-.\", s: \"...\", t: \"-\", u: \"..-\", v: \"...-\", w: \".--\", x: \"-..-\", y: \"-.--\", z: \"--..\" }\\n    const morseRepresentation = word => word.split(\\'\\').map(c => morseCode[c]).join(\\'\\');\\n    \\n    return new Set(words.map(morseRepresentation)).size;\\n};\\n```\\n\\n---\\n\\n## **First** acceptance\\n\\nAt beginning, I was using a `reduce()` function to insert each transformation into the set at time:\\n\\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    return words.reduce((set, w) => set.add(transform(w)), new Set()).size;\\n    \\n    function transform(word) {\\n        const morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return word.split(\\'\\').map(c => morse[c.charCodeAt() - \\'a\\'.charCodeAt()]).join(\\'\\');\\n    }\\n};\\n```\\n\\n---\\n\\n## **Cleaner way** to use `Set()`\\n\\nAs the [Set() constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/Set/) accepts any [iterable object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol) as argument, we can achieve the same result in a better way.\\n\\nEven it would be possible to have a solution in one single line - as we can see at [@acupoftee\\'s great one line solution](https://leetcode.com/problems/unique-morse-code-words/discuss/329303/JavaScript-One-Line-Solution-w-Explanation-(52-ms-beats-94)) - keeping the `transform(word)` function helps to have a lot cleaner solution:\\n\\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    const morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n    \\n    return new Set(words.map(transformWord)).size;\\n    \\n    function transformWord (word) {\\n        return word.split(\\'\\').map(c => morse[c.charCodeAt() - \\'a\\'.charCodeAt()]).join(\\'\\');\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fed24540-1ab1-4be6-b9e5-bb9e665cd5ce_1660697627.3583236.png)\\n\\n---\\n\\n## **Best approach** using *hash table* to keep values\\n\\nFinally, a last improvement that can be made is to use an *hash table* instead of using the *Array* structure given at problem statement.\\n\\nIt will not just make it easier to read and simpler to code, but also will be a lot more efficient, as it will not be necessary any more to make the *maths* and function calls involving ASCII code to find the correct index for morse representations: \\n\\n```\\nvar uniqueMorseRepresentations = function(words) {\\n\\tconst morse = { a: \".-\", b: \"-...\", c: \"-.-.\", d: \"-..\", e: \".\", f: \"..-.\", g: \"--.\", h: \"....\", i: \"..\", j: \".---\", k: \"-.-\", l: \".-..\", m: \"--\", n: \"-.\", o: \"---\", p: \".--.\", q: \"--.-\", r: \".-.\", s: \"...\", t: \"-\", u: \"..-\", v: \"...-\", w: \".--\", x: \"-..-\", y: \"-.--\", z: \"--..\" }\\n    const transformWord = word => word.split(\\'\\').map(c => morse[c]).join(\\'\\');\\n    \\n    return new Set(words.map(transformWord)).size;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a5d97667-f9a5-4974-8339-f0528f10ce5f_1660699065.9906268.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nvar uniqueMorseRepresentations = function(words) {\\n\\tconst morseCode = { a: \".-\", b: \"-...\", c: \"-.-.\", d: \"-..\", e: \".\", f: \"..-.\", g: \"--.\", h: \"....\", i: \"..\", j: \".---\", k: \"-.-\", l: \".-..\", m: \"--\", n: \"-.\", o: \"---\", p: \".--.\", q: \"--.-\", r: \".-.\", s: \"...\", t: \"-\", u: \"..-\", v: \"...-\", w: \".--\", x: \"-..-\", y: \"-.--\", z: \"--..\" }\\n    const morseRepresentation = word => word.split(\\'\\').map(c => morseCode[c]).join(\\'\\');\\n    \\n    return new Set(words.map(morseRepresentation)).size;\\n};\\n```\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    return words.reduce((set, w) => set.add(transform(w)), new Set()).size;\\n    \\n    function transform(word) {\\n        const morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return word.split(\\'\\').map(c => morse[c.charCodeAt() - \\'a\\'.charCodeAt()]).join(\\'\\');\\n    }\\n};\\n```\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    const morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n    \\n    return new Set(words.map(transformWord)).size;\\n    \\n    function transformWord (word) {\\n        return word.split(\\'\\').map(c => morse[c.charCodeAt() - \\'a\\'.charCodeAt()]).join(\\'\\');\\n    }\\n};\\n```\n```\\nvar uniqueMorseRepresentations = function(words) {\\n\\tconst morse = { a: \".-\", b: \"-...\", c: \"-.-.\", d: \"-..\", e: \".\", f: \"..-.\", g: \"--.\", h: \"....\", i: \"..\", j: \".---\", k: \"-.-\", l: \".-..\", m: \"--\", n: \"-.\", o: \"---\", p: \".--.\", q: \"--.-\", r: \".-.\", s: \"...\", t: \"-\", u: \"..-\", v: \"...-\", w: \".--\", x: \"-..-\", y: \"-.--\", z: \"--..\" }\\n    const transformWord = word => word.split(\\'\\').map(c => morse[c]).join(\\'\\');\\n    \\n    return new Set(words.map(transformWord)).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2280241,
                "title": "c-solution-time-o-n-beats-99",
                "content": "```C#\\npublic class Solution {\\n    public int UniqueMorseRepresentations(string[] words) {\\n        string[] code = new [] { \".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\" };\\n        \\n        HashSet<string> h = new HashSet<string>();\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < words.Length; i++) {\\n            for (int j = 0; j < words[i].Length; j++) sb.Append(code[words[i][j] - \\'a\\']);\\n            h.Add(sb.ToString());\\n            sb.Clear();\\n        }\\n        \\n        return h.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int UniqueMorseRepresentations(string[] words) {\\n        string[] code = new [] { \".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\" };\\n        \\n        HashSet<string> h = new HashSet<string>();\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < words.Length; i++) {\\n            for (int j = 0; j < words[i].Length; j++) sb.Append(code[words[i][j] - \\'a\\']);\\n            h.Add(sb.ToString());\\n            sb.Clear();\\n        }\\n        \\n        return h.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901444,
                "title": "easy-c-solution-beginner-friendly",
                "content": "unordered_set<string> st;\\n        string arr[]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        for(int i=0;i<words.size();i++){\\n            string temp=words[i];\\n            string str=\"\";\\n            for(int i=0;i<temp.size();i++)\\n                str+=arr[temp[i]-\\'a\\'];\\n            \\n            st.insert(str);\\n        }\\n        return st.size();",
                "solutionTags": [
                    "C"
                ],
                "code": "unordered_set<string> st;\\n        string arr[]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        for(int i=0;i<words.size();i++){\\n            string temp=words[i];\\n            string str=\"\";\\n            for(int i=0;i<temp.size();i++)\\n                str+=arr[temp[i]-\\'a\\'];\\n            \\n            st.insert(str);\\n        }\\n        return st.size();",
                "codeTag": "Unknown"
            },
            {
                "id": 1610931,
                "title": "one-line-solution-new-set",
                "content": "```\\nconst uniqueMorseRepresentations = (words) => {\\n  const code = [\\'.-\\', \\'-...\\', \\'-.-.\\', \\'-..\\', \\'.\\', \\'..-.\\', \\'--.\\', \\'....\\', \\'..\\', \\'.---\\', \\'-.-\\', \\'.-..\\', \\'--\\', \\'-.\\', \\'---\\', \\'.--.\\', \\'--.-\\', \\'.-.\\', \\'...\\', \\'-\\', \\'..-\\', \\'...-\\', \\'.--\\', \\'-..-\\', \\'-.--\\', \\'--..\\'];\\n\\n  return new Set(words.map((word) => [...word].map((char) => code[char.charCodeAt() - 97]).join(\\'\\'))).size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst uniqueMorseRepresentations = (words) => {\\n  const code = [\\'.-\\', \\'-...\\', \\'-.-.\\', \\'-..\\', \\'.\\', \\'..-.\\', \\'--.\\', \\'....\\', \\'..\\', \\'.---\\', \\'-.-\\', \\'.-..\\', \\'--\\', \\'-.\\', \\'---\\', \\'.--.\\', \\'--.-\\', \\'.-.\\', \\'...\\', \\'-\\', \\'..-\\', \\'...-\\', \\'.--\\', \\'-..-\\', \\'-.--\\', \\'--..\\'];\\n\\n  return new Set(words.map((word) => [...word].map((char) => code[char.charCodeAt() - 97]).join(\\'\\'))).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1088637,
                "title": "java-simple-easy-to-understand",
                "content": "Runtime: 1 ms, faster than 100.00% of Java online submissions for Unique Morse Code Words.\\nMemory Usage: 37.2 MB, less than 56.75% of Java online submissions for Unique Morse Code Words.\\n```\\npublic int uniqueMorseRepresentations(String[] words) {\\n    String[] arr = new String[]{\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n    Set<String> set = new HashSet<>();\\n    for (String s : words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char ch : s.toCharArray()) sb.append(arr[ch - \\'a\\']);\\n        set.add(sb.toString());\\n    }\\n\\n    return set.size();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int uniqueMorseRepresentations(String[] words) {\\n    String[] arr = new String[]{\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n    Set<String> set = new HashSet<>();\\n    for (String s : words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char ch : s.toCharArray()) sb.append(arr[ch - \\'a\\']);\\n        set.add(sb.toString());\\n    }\\n\\n    return set.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 944902,
                "title": "python-simplest-intuitive-solution",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        res = set()\\n        for word in words:\\n            curr = \"\"\\n            for char in word:\\n                curr += codes[ord(char)-97]\\n            res.add(curr)\\n        return len(res)\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        res = set()\\n        for word in words:\\n            curr = \"\"\\n            for char in word:\\n                curr += codes[ord(char)-97]\\n            res.add(curr)\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790324,
                "title": "c-faster-than-100-custom-trie",
                "content": "Idea is to get rid of set,because its expensive translation from string to hashcode,and also we store each string of group where most of them is similar.\\n\\nI get this trie code from geeks,and modify it to have only 2 childs,and to count string we have not previously\\n\\nUpvote if you like it.\\n\\nMy first solution with set was faster than 67%\\n\\n\\n```\\n#define CHAR_SIZE 2\\n\\nint n = 0;\\n\\nclass Trie {\\npublic:\\n\\tbool isLeaf;\\n\\tTrie* character[CHAR_SIZE];\\n\\n\\tTrie()\\n\\t{\\n\\t\\tthis->isLeaf = false;\\n\\t\\tfor (int i = 0; i < CHAR_SIZE; i++)\\n\\t\\t\\tthis->character[i] = nullptr;\\n\\t}\\n\\n\\tvoid insert(std::string);\\n};\\n\\nvoid Trie::insert(std::string key) {\\n\\tTrie* curr = this;\\n\\tfor (int i = 0; i < key.length(); i++) {\\n        int k = key[i]==\\'.\\'?0:1;\\n\\t\\tif (curr->character[k] == nullptr)\\n\\t\\t\\tcurr->character[k] = new Trie();\\n\\t\\t\\n\\t\\tcurr = curr->character[k];\\n\\t}\\n\\tif (!curr->isLeaf) n++;\\n    curr->isLeaf = true;\\n}\\n\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        n = 0;\\n        Trie* root = new Trie();\\n        string morse[26] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        for (string& s:words) {\\n            string mapped;\\n            for (char c:s) {\\n                mapped += morse[c-\\'a\\'];\\n            }\\n            root->insert(mapped);\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define CHAR_SIZE 2\\n\\nint n = 0;\\n\\nclass Trie {\\npublic:\\n\\tbool isLeaf;\\n\\tTrie* character[CHAR_SIZE];\\n\\n\\tTrie()\\n\\t{\\n\\t\\tthis->isLeaf = false;\\n\\t\\tfor (int i = 0; i < CHAR_SIZE; i++)\\n\\t\\t\\tthis->character[i] = nullptr;\\n\\t}\\n\\n\\tvoid insert(std::string);\\n};\\n\\nvoid Trie::insert(std::string key) {\\n\\tTrie* curr = this;\\n\\tfor (int i = 0; i < key.length(); i++) {\\n        int k = key[i]==\\'.\\'?0:1;\\n\\t\\tif (curr->character[k] == nullptr)\\n\\t\\t\\tcurr->character[k] = new Trie();\\n\\t\\t\\n\\t\\tcurr = curr->character[k];\\n\\t}\\n\\tif (!curr->isLeaf) n++;\\n    curr->isLeaf = true;\\n}\\n\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        n = 0;\\n        Trie* root = new Trie();\\n        string morse[26] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        for (string& s:words) {\\n            string mapped;\\n            for (char c:s) {\\n                mapped += morse[c-\\'a\\'];\\n            }\\n            root->insert(mapped);\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536145,
                "title": "c-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> dict{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"} ;\\n        \\n        set<string> set ;\\n        \\n        for( int i=0 ; i<words.size() ; i++ ){\\n            int word_size = words[i].length() ;\\n            string res = \"\" ;\\n            for( int j=0 ; j<word_size ; j++ ){\\n                res = res + dict[words[i][j]-\\'a\\'] ;\\n            }\\n            set.insert(res) ;\\n        }\\n        \\n        return set.size() ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> dict{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"} ;\\n        \\n        set<string> set ;\\n        \\n        for( int i=0 ; i<words.size() ; i++ ){\\n            int word_size = words[i].length() ;\\n            string res = \"\" ;\\n            for( int j=0 ; j<word_size ; j++ ){\\n                res = res + dict[words[i][j]-\\'a\\'] ;\\n            }\\n            set.insert(res) ;\\n        }\\n        \\n        return set.size() ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322913,
                "title": "simple-python-solution-beats-99-83-time-83-96-space",
                "content": "```\\nclass Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        letters = \"abcdefghijklmnopqrstuvwxyz\"\\n        encodings = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\t\\t\\n\\t\\t# map letter to encoding\\n        map = dict()\\n        for letter, encoding in zip(letters,encodings):\\n            map[letter] = encoding\\n           \\n\\t\\t# for each word given, translate to Morse code using lookup table \\n        for i in range(len(words)):\\n            words[i] = \"\".join([map[c] for c in words[i]])\\n        \\n\\t\\t# count distinct encodings\\n        return len(set(words))\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        letters = \"abcdefghijklmnopqrstuvwxyz\"\\n        encodings = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\t\\t\\n\\t\\t# map letter to encoding\\n        map = dict()\\n        for letter, encoding in zip(letters,encodings):\\n            map[letter] = encoding\\n           \\n\\t\\t# for each word given, translate to Morse code using lookup table \\n        for i in range(len(words)):\\n            words[i] = \"\".join([map[c] for c in words[i]])\\n        \\n\\t\\t# count distinct encodings\\n        return len(set(words))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242518,
                "title": "c-easy-to-understand",
                "content": "```\\nint uniqueMorseRepresentations(char** words, int wordsSize) {\\n\\t\\tchar comp[26][6]={\".-\", \"-...\" , \"-.-.\", \"-..\", \".\" ,\"..-.\", \"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    char str1[100],str2[100][100],str3[100];\\n    int i,j,k,l,unique,found;\\n    found=unique=k=0;\\n    for(i=0;i<wordsSize;i++){\\n    \\tstrcpy(str3,\"\");\\n    \\tstrcpy(str1,words[i]);\\n    \\t\\n\\t\\t    for(j=0;j<strlen(str1);j++){\\n    \\t\\tstrcat(str3,comp[str1[j]-\\'a\\']);           //\\u5B57\\u7B26\\u4E32\\u540E\\u8FFD\\u52A0\\u65B0\\u5B57\\u7B26\\u4E32 \\n\\t\\t}\\n\\t\\tfor(l=0;l<unique;l++){\\n\\t\\tif(strcmp(str2[l],str3)==0){\\n\\t\\tfound=1;\\n\\t\\tbreak;}\\n\\t\\t}\\n\\t\\tif(found==0)\\n\\t\\tstrcpy(str2[unique++],str3);\\n\\t\\tfound=0;\\n\\t}\\n\\treturn unique;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint uniqueMorseRepresentations(char** words, int wordsSize) {\\n\\t\\tchar comp[26][6]={\".-\", \"-...\" , \"-.-.\", \"-..\", \".\" ,\"..-.\", \"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    char str1[100],str2[100][100],str3[100];\\n    int i,j,k,l,unique,found;\\n    found=unique=k=0;\\n    for(i=0;i<wordsSize;i++){\\n    \\tstrcpy(str3,\"\");\\n    \\tstrcpy(str1,words[i]);\\n    \\t\\n\\t\\t    for(j=0;j<strlen(str1);j++){\\n    \\t\\tstrcat(str3,comp[str1[j]-\\'a\\']);           //\\u5B57\\u7B26\\u4E32\\u540E\\u8FFD\\u52A0\\u65B0\\u5B57\\u7B26\\u4E32 \\n\\t\\t}\\n\\t\\tfor(l=0;l<unique;l++){\\n\\t\\tif(strcmp(str2[l],str3)==0){\\n\\t\\tfound=1;\\n\\t\\tbreak;}\\n\\t\\t}\\n\\t\\tif(found==0)\\n\\t\\tstrcpy(str2[unique++],str3);\\n\\t\\tfound=0;\\n\\t}\\n\\treturn unique;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 224779,
                "title": "rust-concise-solution-0ms",
                "content": "```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    const morse : [&\\'static str; 26] = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    \\n    pub fn unique_morse_representations(words: Vec<String>) -> i32 {\\n        HashSet::<String>::from_iter(words.iter()\\n                                          .map(|w| w.chars()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    .map(|c| Solution::morse[(c as usize) - (\\'a\\' as usize)])\\n                                                    .collect::<String>())).len() as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    const morse : [&\\'static str; 26] = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    \\n    pub fn unique_morse_representations(words: Vec<String>) -> i32 {\\n        HashSet::<String>::from_iter(words.iter()\\n                                          .map(|w| w.chars()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    .map(|c| Solution::morse[(c as usize) - (\\'a\\' as usize)])\\n                                                    .collect::<String>())).len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 223445,
                "title": "java-5ms-faster-than-94",
                "content": "```\\nclass solutaion{\\n\\tpublic int uniqueMorseRepresentations(String[] words) {\\n\\t\\tString letters=\"abcdefghijklmnopqrstuvwxyz\";\\n        String[] morse={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> s1=new HashSet<>();\\n        for (String word : words) {\\n            String str=\"\";\\n           int num=word.length();\\n            for(int i=0;i<num;i++) {\\n                str=str+morse[letters.indexOf(word.charAt(i))];\\n            }\\n            s1.add(str);\\n        }\\n        return s1.size(); \\n\\t  }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass solutaion{\\n\\tpublic int uniqueMorseRepresentations(String[] words) {\\n\\t\\tString letters=\"abcdefghijklmnopqrstuvwxyz\";\\n        String[] morse={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> s1=new HashSet<>();\\n        for (String word : words) {\\n            String str=\"\";\\n           int num=word.length();\\n            for(int i=0;i<num;i++) {\\n                str=str+morse[letters.indexOf(word.charAt(i))];\\n            }\\n            s1.add(str);\\n        }\\n        return s1.size(); \\n\\t  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 217697,
                "title": "runtime-0-ms-faster-than-100-00-of-go-online-submissions-for-unique-morse-code-words",
                "content": "```\\nvar morseCodes []string = []string{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}\\n\\n\\nfunc uniqueMorseRepresentations(words []string) int {\\n    transformations := make(map[string]int)\\n\\n    for _, word := range words {\\n\\t    var sb strings.Builder\\n\\t\\n\\t    for _, char := range []byte(word) {\\n\\t\\t    sb.WriteString(morseCodes[char - 97])\\t\\n\\t    }\\n\\t\\n\\t    transformations[sb.String()]++\\n    }\\n\\n    return len(transformations)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar morseCodes []string = []string{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}\\n\\n\\nfunc uniqueMorseRepresentations(words []string) int {\\n    transformations := make(map[string]int)\\n\\n    for _, word := range words {\\n\\t    var sb strings.Builder\\n\\t\\n\\t    for _, char := range []byte(word) {\\n\\t\\t    sb.WriteString(morseCodes[char - 97])\\t\\n\\t    }\\n\\t\\n\\t    transformations[sb.String()]++\\n    }\\n\\n    return len(transformations)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 214221,
                "title": "rust-solution",
                "content": "```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn unique_morse_representations(words: Vec<String>) -> i32 {\\n        \\n        let morse_codes = vec![\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n        \\n        let mut morse_set = HashSet::new();\\n        for word in &words{\\n            let mut temp_str : String = \"\".into();\\n            let mut chars = word.chars();\\n            let mut each_char = chars.next();\\n            loop {\\n                match each_char {\\n                    Some(x) => temp_str.push_str(morse_codes[(x as u8 - 97) as usize]),\\n                    None => break,\\n                }\\n             each_char = chars.next();\\n            }\\n            morse_set.insert(temp_str);\\n        }\\n        return morse_set.len() as i32;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn unique_morse_representations(words: Vec<String>) -> i32 {\\n        \\n        let morse_codes = vec![\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n        \\n        let mut morse_set = HashSet::new();\\n        for word in &words{\\n            let mut temp_str : String = \"\".into();\\n            let mut chars = word.chars();\\n            let mut each_char = chars.next();\\n            loop {\\n                match each_char {\\n                    Some(x) => temp_str.push_str(morse_codes[(x as u8 - 97) as usize]),\\n                    None => break,\\n                }\\n             each_char = chars.next();\\n            }\\n            morse_set.insert(temp_str);\\n        }\\n        return morse_set.len() as i32;\\n    }\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 200334,
                "title": "python-2-lines",
                "content": "```\\nclass Solution:\\n    \\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return len(set([\\n            \\'\\'.join([morse[ord(c)-ord(\\'a\\')] for c in word]) \\n            for word in words\\n        ]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return len(set([\\n            \\'\\'.join([morse[ord(c)-ord(\\'a\\')] for c in word]) \\n            for word in words\\n        ]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194241,
                "title": "simple-javascript-solution",
                "content": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    var trans = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    return new Set(words.map((ele, idx) => {\\n       return ele.split(\\'\\').map((item, i) => {\\n            return trans[ele.charCodeAt(i) - \\'a\\'.charCodeAt(0)];\\n        }).join(\\'\\');\\n    })).size;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    var trans = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    return new Set(words.map((ele, idx) => {\\n       return ele.split(\\'\\').map((item, i) => {\\n            return trans[ele.charCodeAt(i) - \\'a\\'.charCodeAt(0)];\\n        }).join(\\'\\');\\n    })).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 122289,
                "title": "2-line-code-with-java-8-stream",
                "content": "```\\npublic int uniqueMorseRepresentations(String[] words) {\\n        Set<String> res = Arrays.stream(words).map(i -> getMC(i)).collect(Collectors.toSet());\\n        return res.size();\\n    }\\n    private String getMC(String str) {\\n        String[] mCode = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                          \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\\n                          \"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        return str.chars().mapToObj(ch -> mCode[(char)ch % 97]).reduce(\"\", String::concat);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int uniqueMorseRepresentations(String[] words) {\\n        Set<String> res = Arrays.stream(words).map(i -> getMC(i)).collect(Collectors.toSet());\\n        return res.size();\\n    }\\n    private String getMC(String str) {\\n        String[] mCode = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                          \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\\n                          \"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        return str.chars().mapToObj(ch -> mCode[(char)ch % 97]).reduce(\"\", String::concat);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3945955,
                "title": "3-types-solutions-fully-explained-simple-solutions",
                "content": "# **1. \"Mapping and Set\" approach:**\\n# Intuition\\nWe are given a list of words and we need to find the number of unique Morse code representations that can be generated from these words. Each letter of the alphabet corresponds to a specific Morse code pattern. Our goal is to map each word to its Morse code representation and count the number of unique representations.\\n# Approach\\n1. First, we create a mapping of each letter to its Morse code pattern using the symbols object provided in the code.\\n2. For each word in the input words list, we split the word into individual letters and map each letter to its Morse code pattern using the symbols object.\\n3. We join these Morse code patterns for each letter to form the Morse code representation of the entire word.\\n4. We use a Set data structure to store these unique Morse code representations. The Set automatically ensures that only unique representations are stored.\\n5. Finally, we return the size of the Set, which represents the number of unique Morse code representations.\\n# Complexity\\n- Time complexity: `O(n * k)`\\n\\n- Space complexity: `O(n)`\\n\\n# Code\\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    const symbols = {\\n        a: \\'.-\\',\\n        b: \\'-...\\',\\n        c: \\'-.-.\\',\\n        d: \\'-..\\',\\n        e: \\'.\\',\\n        f: \\'..-.\\',\\n        g: \\'--.\\',\\n        h: \\'....\\',\\n        i: \\'..\\',\\n        j: \\'.---\\',\\n        k: \\'-.-\\',\\n        l: \\'.-..\\',\\n        m: \\'--\\',\\n        n: \\'-.\\',\\n        o: \\'---\\',\\n        p: \\'.--.\\',\\n        q: \\'--.-\\',\\n        r: \\'.-.\\',\\n        s: \\'...\\',\\n        t: \\'-\\',\\n        u: \\'..-\\',\\n        v: \\'...-\\',\\n        w: \\'.--\\',\\n        x: \\'-..-\\',\\n        y: \\'-.--\\',\\n        z: \\'--..\\'\\n    }\\n\\n    return new Set(words.map(word => word.split(\\'\\').map(letter => symbols[letter]).join(\\'\\'))).size;\\n};\\n```\\n\\n\\n---\\n\\n# **2. \"Mapping and Set\" approach:**\\n# Intuition\\nWe are given a list of words and we need to find the number of unique Morse code representations that can be generated from these words. Each letter of the alphabet corresponds to a specific Morse code pattern. Our goal is to map each word to its Morse code representation and count the number of unique representations.\\n# Approach\\n1. An array named symbols holds the Morse code patterns for each letter of the alphabet. The index of each pattern corresponds to the character\\'s position in the alphabet.\\n2. A Set called transformations is initialized to keep track of unique Morse code representations.\\n3. For each word in the words list:\\n    - A temporary string trans is initialized to store the Morse code transformation of the current word.\\n    - For each letter in the word:\\n        - The ASCII code of the letter is subtracted by 97 (ASCII code of \\'a\\') to get the index in the symbols array.\\n        - The Morse code pattern for the letter at that index is added to the trans string.\\n    - The trans string, representing the Morse code transformation of the   current word, is added to the transformations set.\\n4. After processing all words, the size of the transformations set is returned, which represents the number of unique Morse code representations.\\n# Complexity\\n- Time complexity: `O(n * k)`\\n\\n- Space complexity: `O(n)`\\n\\n# Code\\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    var symbols = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\\n                  \"--.\",\"....\",\"..\",\".---\",\\n                  \"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                  \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\\n                  \".--\",\"-..-\",\"-.--\",\"--..\"];\\n    \\n    var transformations = new Set();\\n    \\n    for (let word of words) {        \\n        var trans = \"\";\\n        for (let letter of word) {\\n            var index = letter.charCodeAt(0) - 97;\\n            trans += symbols[index];\\n        }\\n        \\n        transformations.add(trans);   \\n    }\\n    \\n    return transformations.size;\\n};\\n```\\n---\\n\\n# **3. \"Subarray Transformation and Set\" approach:**\\n# Intuition\\nThis code aims to determine the number of unique Morse code transformations that can be generated from a list of words. Each word is treated as a subarray of characters, and for each character, its Morse code equivalent is appended to a temporary string. The goal is to count the number of unique strings that result from these transformations.\\n# Approach\\n1. The symbols object holds the mapping of letters to their corresponding Morse code patterns, similar to the previous codes.\\n2. A Set named transformations is created to store unique Morse code transformations.\\n3. For each subArr (subarray or word) in the words list:\\n    - A temporary string tempStr is initialized to store the Morse code transformation of the current subarray.\\n    - For each word (character) in the subArr:\\n        - The key is obtained by looking up the symbols object using the word as the key. This retrieves the Morse code pattern corresponding to the current character.\\n        - The Morse code pattern is appended to the tempStr.\\n    - After processing all characters in the subarray, the resulting tempStr represents the Morse code transformation of that subarray.\\n    - The tempStr is added to the transformations set to keep track of unique transformations.\\n4. Once all subarrays have been processed, the function returns the size of the transformations set, which represents the count of unique Morse code transformations.\\n# Complexity\\n- Time complexity: `O(n * k)`\\n\\n- Space complexity: `O(n)`\\n\\n# Code\\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    const symbols = {\\n        a: \\'.-\\',\\n        b: \\'-...\\',\\n        c: \\'-.-.\\',\\n        d: \\'-..\\',\\n        e: \\'.\\',\\n        f: \\'..-.\\',\\n        g: \\'--.\\',\\n        h: \\'....\\',\\n        i: \\'..\\',\\n        j: \\'.---\\',\\n        k: \\'-.-\\',\\n        l: \\'.-..\\',\\n        m: \\'--\\',\\n        n: \\'-.\\',\\n        o: \\'---\\',\\n        p: \\'.--.\\',\\n        q: \\'--.-\\',\\n        r: \\'.-.\\',\\n        s: \\'...\\',\\n        t: \\'-\\',\\n        u: \\'..-\\',\\n        v: \\'...-\\',\\n        w: \\'.--\\',\\n        x: \\'-..-\\',\\n        y: \\'-.--\\',\\n        z: \\'--..\\'\\n    }\\n\\n    let transformations = new Set();\\n\\n    for (let subArr of words) {\\n        let tempStr = \\'\\';\\n        for (let word of subArr) {\\n            let key = symbols[word];\\n            tempStr += key;\\n        }\\n        transformations.add(tempStr);\\n    }\\n    return transformations.size;\\n};\\n```\\n\\n\\n---\\n\\n**Any doubts Comment it!**\\n\\nHappy Coding : )\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/a3814417-9c24-4b25-a61d-9cd994a1b091_1692715864.4624593.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    const symbols = {\\n        a: \\'.-\\',\\n        b: \\'-...\\',\\n        c: \\'-.-.\\',\\n        d: \\'-..\\',\\n        e: \\'.\\',\\n        f: \\'..-.\\',\\n        g: \\'--.\\',\\n        h: \\'....\\',\\n        i: \\'..\\',\\n        j: \\'.---\\',\\n        k: \\'-.-\\',\\n        l: \\'.-..\\',\\n        m: \\'--\\',\\n        n: \\'-.\\',\\n        o: \\'---\\',\\n        p: \\'.--.\\',\\n        q: \\'--.-\\',\\n        r: \\'.-.\\',\\n        s: \\'...\\',\\n        t: \\'-\\',\\n        u: \\'..-\\',\\n        v: \\'...-\\',\\n        w: \\'.--\\',\\n        x: \\'-..-\\',\\n        y: \\'-.--\\',\\n        z: \\'--..\\'\\n    }\\n\\n    return new Set(words.map(word => word.split(\\'\\').map(letter => symbols[letter]).join(\\'\\'))).size;\\n};\\n```\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    var symbols = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\\n                  \"--.\",\"....\",\"..\",\".---\",\\n                  \"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                  \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\\n                  \".--\",\"-..-\",\"-.--\",\"--..\"];\\n    \\n    var transformations = new Set();\\n    \\n    for (let word of words) {        \\n        var trans = \"\";\\n        for (let letter of word) {\\n            var index = letter.charCodeAt(0) - 97;\\n            trans += symbols[index];\\n        }\\n        \\n        transformations.add(trans);   \\n    }\\n    \\n    return transformations.size;\\n};\\n```\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    const symbols = {\\n        a: \\'.-\\',\\n        b: \\'-...\\',\\n        c: \\'-.-.\\',\\n        d: \\'-..\\',\\n        e: \\'.\\',\\n        f: \\'..-.\\',\\n        g: \\'--.\\',\\n        h: \\'....\\',\\n        i: \\'..\\',\\n        j: \\'.---\\',\\n        k: \\'-.-\\',\\n        l: \\'.-..\\',\\n        m: \\'--\\',\\n        n: \\'-.\\',\\n        o: \\'---\\',\\n        p: \\'.--.\\',\\n        q: \\'--.-\\',\\n        r: \\'.-.\\',\\n        s: \\'...\\',\\n        t: \\'-\\',\\n        u: \\'..-\\',\\n        v: \\'...-\\',\\n        w: \\'.--\\',\\n        x: \\'-..-\\',\\n        y: \\'-.--\\',\\n        z: \\'--..\\'\\n    }\\n\\n    let transformations = new Set();\\n\\n    for (let subArr of words) {\\n        let tempStr = \\'\\';\\n        for (let word of subArr) {\\n            let key = symbols[word];\\n            tempStr += key;\\n        }\\n        transformations.add(tempStr);\\n    }\\n    return transformations.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3828299,
                "title": "solution-in-java-beginner-friendly-using-for-loop-and-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morse_code = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\\n                \".--\",\"-..-\",\"-.--\",\"--..\"};\\n        char[] alphabet = {\\n                \\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\', \\'k\\', \\'l\\', \\'m\\',\\n                \\'n\\', \\'o\\', \\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\', \\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\', \\'z\\'\\n        };\\n\\n        String[] new_morse_code_arr = new String[words.length];\\n        int index=0;\\n\\n        String check;\\n        for (String word : words) {\\n            check = word;\\n            for (int j = 0; j < check.length(); j++) {\\n                for (int k = 0; k < alphabet.length; k++) {\\n                    if (check.charAt(j) == alphabet[k]) {\\n                        if (new_morse_code_arr[index] == null) {\\n                            new_morse_code_arr[index] = \"\";\\n                        }\\n                        new_morse_code_arr[index] = new_morse_code_arr[index] + morse_code[k];\\n                    }\\n                }\\n            }\\n            index++;\\n        }\\n\\n        HashSet<String> hs = new HashSet<>(Arrays.asList(new_morse_code_arr));\\n\\n        return hs.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morse_code = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\\n                \".--\",\"-..-\",\"-.--\",\"--..\"};\\n        char[] alphabet = {\\n                \\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\', \\'k\\', \\'l\\', \\'m\\',\\n                \\'n\\', \\'o\\', \\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\', \\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\', \\'z\\'\\n        };\\n\\n        String[] new_morse_code_arr = new String[words.length];\\n        int index=0;\\n\\n        String check;\\n        for (String word : words) {\\n            check = word;\\n            for (int j = 0; j < check.length(); j++) {\\n                for (int k = 0; k < alphabet.length; k++) {\\n                    if (check.charAt(j) == alphabet[k]) {\\n                        if (new_morse_code_arr[index] == null) {\\n                            new_morse_code_arr[index] = \"\";\\n                        }\\n                        new_morse_code_arr[index] = new_morse_code_arr[index] + morse_code[k];\\n                    }\\n                }\\n            }\\n            index++;\\n        }\\n\\n        HashSet<String> hs = new HashSet<>(Arrays.asList(new_morse_code_arr));\\n\\n        return hs.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415075,
                "title": "golang-performance-speed-is-faster-than-others",
                "content": "\\n# Complexity\\n- Time complexity:100%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:28%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc uniqueMorseRepresentations(words []string) int {\\nmorseMap := map[byte]string {\\n\\'a\\': \".-\",\\n\\'b\\': \"-...\",\\n\\'c\\': \"-.-.\",\\n\\'d\\': \"-..\",\\n\\'e\\': \".\",\\n\\'f\\': \"..-.\",\\n\\'g\\': \"--.\",\\n\\'h\\': \"....\",\\n\\'i\\': \"..\",\\n\\'j\\': \".---\",\\n\\'k\\': \"-.-\",\\n\\'l\\': \".-..\",\\n\\'m\\': \"--\",\\n\\'n\\': \"-.\",\\n\\'o\\': \"---\",\\n\\'p\\': \".--.\",\\n\\'q\\': \"--.-\",\\n\\'r\\': \".-.\",\\n\\'s\\': \"...\",\\n\\'t\\': \"-\",\\n\\'u\\': \"..-\",\\n\\'v\\': \"...-\",\\n\\'w\\': \".--\",\\n\\'x\\': \"-..-\",\\n\\'y\\': \"-.--\",\\n\\'z\\': \"--..\",\\n}\\nmorseSet := make(map[string]bool)\\n\\nfor _, word := range words {\\n    morseWord := \"\"\\n\\n    for _, letter := range []byte(word) {\\n        morseWord += morseMap[letter]\\n    }\\n\\n    morseSet[morseWord] = true\\n}\\n\\nreturn len(morseSet)\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc uniqueMorseRepresentations(words []string) int {\\nmorseMap := map[byte]string {\\n\\'a\\': \".-\",\\n\\'b\\': \"-...\",\\n\\'c\\': \"-.-.\",\\n\\'d\\': \"-..\",\\n\\'e\\': \".\",\\n\\'f\\': \"..-.\",\\n\\'g\\': \"--.\",\\n\\'h\\': \"....\",\\n\\'i\\': \"..\",\\n\\'j\\': \".---\",\\n\\'k\\': \"-.-\",\\n\\'l\\': \".-..\",\\n\\'m\\': \"--\",\\n\\'n\\': \"-.\",\\n\\'o\\': \"---\",\\n\\'p\\': \".--.\",\\n\\'q\\': \"--.-\",\\n\\'r\\': \".-.\",\\n\\'s\\': \"...\",\\n\\'t\\': \"-\",\\n\\'u\\': \"..-\",\\n\\'v\\': \"...-\",\\n\\'w\\': \".--\",\\n\\'x\\': \"-..-\",\\n\\'y\\': \"-.--\",\\n\\'z\\': \"--..\",\\n}\\nmorseSet := make(map[string]bool)\\n\\nfor _, word := range words {\\n    morseWord := \"\"\\n\\n    for _, letter := range []byte(word) {\\n        morseWord += morseMap[letter]\\n    }\\n\\n    morseSet[morseWord] = true\\n}\\n\\nreturn len(morseSet)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3285657,
                "title": "java-simple-solution-easy-to-understand",
                "content": "# Java\\n\\n# Code\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n\\n        int l = words.length;\\n        String s = \"\";\\n        StringBuilder m = new StringBuilder();\\n\\n        String morse[] = new String[] {\\n          \".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n          \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\\n          \"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"\\n        }; \\n\\n        Map<Character, String> map = new HashMap<>();\\n\\n        for (int i = 97, j = 0; i < 123; i++, j++) {\\n           map.put((char) i, morse[j]);\\n        }\\n\\n        for (int i = 0; i < l; i++) {\\n            s = words[i];\\n            for (int j = 0; j < s.length(); j++) {\\n                m.append(map.get(s.charAt(j)));\\n            }\\n            words[i] = m.toString();\\n            m.setLength(0);\\n        }\\n\\n        Set<String> ans = new HashSet<String>(Arrays.asList(words));\\n\\n       return ans.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n\\n        int l = words.length;\\n        String s = \"\";\\n        StringBuilder m = new StringBuilder();\\n\\n        String morse[] = new String[] {\\n          \".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n          \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\\n          \"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"\\n        }; \\n\\n        Map<Character, String> map = new HashMap<>();\\n\\n        for (int i = 97, j = 0; i < 123; i++, j++) {\\n           map.put((char) i, morse[j]);\\n        }\\n\\n        for (int i = 0; i < l; i++) {\\n            s = words[i];\\n            for (int j = 0; j < s.length(); j++) {\\n                m.append(map.get(s.charAt(j)));\\n            }\\n            words[i] = m.toString();\\n            m.setLength(0);\\n        }\\n\\n        Set<String> ans = new HashSet<String>(Arrays.asList(words));\\n\\n       return ans.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234710,
                "title": "unique-morse-javascript-98-48-55-ms",
                "content": "![image.png](https://assets.leetcode.com/users/images/007f6567-605a-498f-a9e6-409185d149b5_1677465451.361765.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar uniqueMorseRepresentations = function(words) {\\n    // set morse array (26 elements like english letters)\\n    morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]    \\n    // set array to store result of words transformation\\n    arr = []\\n    // enumerate all word in words array\\n    for (word of words) {        \\n        let temp = []\\n        // transform letter to morse\\n        for(let i = 0; i < word.length; i++)\\n            temp.push(morse[word[i].charCodeAt(0) - 97])\\n        // push result in arr\\n        arr.push(temp.join(\\'\\'))\\n    }   \\n    // return unique values number in arr\\n    return [...new Set(arr)].length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar uniqueMorseRepresentations = function(words) {\\n    // set morse array (26 elements like english letters)\\n    morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]    \\n    // set array to store result of words transformation\\n    arr = []\\n    // enumerate all word in words array\\n    for (word of words) {        \\n        let temp = []\\n        // transform letter to morse\\n        for(let i = 0; i < word.length; i++)\\n            temp.push(morse[word[i].charCodeAt(0) - 97])\\n        // push result in arr\\n        arr.push(temp.join(\\'\\'))\\n    }   \\n    // return unique values number in arr\\n    return [...new Set(arr)].length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3172534,
                "title": "easy-java-solution-self-explanatory-1-ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] strArr = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> set = new HashSet<>();\\n        for(String str : words){\\n            StringBuffer sb = new StringBuffer();\\n            for(char ch : str.toCharArray()){\\n                sb.append(strArr[ch-\\'a\\']);\\n            }\\n            set.add(sb.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] strArr = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> set = new HashSet<>();\\n        for(String str : words){\\n            StringBuffer sb = new StringBuffer();\\n            for(char ch : str.toCharArray()){\\n                sb.append(strArr[ch-\\'a\\']);\\n            }\\n            set.add(sb.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966829,
                "title": "easiest-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n\\n    String []arr={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n    HashMap<String,Boolean>mp=new HashMap<>();\\n\\n    for(int i=0;i<words.length;i++){\\n\\n    String check=\"\";\\n\\n    for(int j=0;j<words[i].length();j++){\\n\\n    check+=arr[words[i].charAt(j)-\\'a\\'];\\n\\n    }\\n\\n    mp.put(check,true);\\n\\n    }\\n\\n    return mp.size();\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n\\n    String []arr={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n    HashMap<String,Boolean>mp=new HashMap<>();\\n\\n    for(int i=0;i<words.length;i++){\\n\\n    String check=\"\";\\n\\n    for(int j=0;j<words[i].length();j++){\\n\\n    check+=arr[words[i].charAt(j)-\\'a\\'];\\n\\n    }\\n\\n    mp.put(check,true);\\n\\n    }\\n\\n    return mp.size();\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872834,
                "title": "java-solution-using-hashset-2ms-99-8-faster",
                "content": "```\\n    public int uniqueMorseRepresentations(String[] words) {\\n        HashSet<String>set=new HashSet<String>();\\n        for(String stu:words){\\n            set.add(code(stu));\\n        }\\n        return set.size();\\n        \\n    }\\n    public String code(String word){\\n        String morse[]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n            \\n        StringBuilder str=new StringBuilder();\\n        for(char ch:word.toCharArray()){\\n            str.append(morse[(int)ch-97]);\\n        }\\n        return str.toString();\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int uniqueMorseRepresentations(String[] words) {\\n        HashSet<String>set=new HashSet<String>();\\n        for(String stu:words){\\n            set.add(code(stu));\\n        }\\n        return set.size();\\n        \\n    }\\n    public String code(String word){\\n        String morse[]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n            \\n        StringBuilder str=new StringBuilder();\\n        for(char ch:word.toCharArray()){\\n            str.append(morse[(int)ch-97]);\\n        }\\n        return str.toString();\\n        }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2706198,
                "title": "c-3ms",
                "content": "class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& w) {\\n        map<char,string> morse{\\n            {\\'a\\',\".-\"},\\n            {\\'b\\',\"-...\"},\\n            {\\'c\\',\"-.-.\"},\\n            {\\'d\\',\"-..\"},\\n            {\\'e\\',\".\"},\\n            {\\'f\\',\"..-.\"},\\n            {\\'g\\',\"--.\"},\\n            {\\'h\\',\"....\"},\\n            {\\'i\\',\"..\"},\\n            {\\'j\\',\".---\"},\\n            {\\'k\\',\"-.-\"},\\n            {\\'l\\',\".-..\"},\\n            {\\'m\\',\"--\"},\\n            {\\'n\\',\"-.\"},\\n            {\\'o\\',\"---\"},\\n            {\\'p\\',\".--.\"},\\n            {\\'q\\',\"--.-\"},\\n            {\\'r\\',\".-.\"},\\n            {\\'s\\',\"...\"},\\n            {\\'t\\',\"-\"},\\n            {\\'u\\',\"..-\"},\\n            {\\'v\\',\"...-\"},\\n            {\\'w\\',\".--\"},\\n            {\\'x\\',\"-..-\"},\\n            {\\'y\\',\"-.--\"},\\n            {\\'z\\',\"--..\"}\\n        };\\n        set<string>se;\\n        int n=w.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string a=\"\";\\n            for(int j=0;j<w[i].size();j++)a+=morse[w[i][j]];\\n            se.insert(a);\\n        }\\n        return se.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& w) {\\n        map<char,string> morse{\\n            {\\'a\\',\".-\"}",
                "codeTag": "Java"
            },
            {
                "id": 2440022,
                "title": "c-simple-easy-to-understand-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n       const vector<string> morseCode  {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        for(auto &x : words) {\\n            string temp = \"\";\\n            \\n            for(auto &y : x)  temp += morseCode[y - \\'a\\'];\\n            \\n            x = temp;\\n        }\\n        \\n        unordered_set<string> mSet;\\n        \\n        for(auto &x : words) mSet.insert(x);\\n        \\n        \\n        return size(mSet);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n       const vector<string> morseCode  {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        for(auto &x : words) {\\n            string temp = \"\";\\n            \\n            for(auto &y : x)  temp += morseCode[y - \\'a\\'];\\n            \\n            x = temp;\\n        }\\n        \\n        unordered_set<string> mSet;\\n        \\n        for(auto &x : words) mSet.insert(x);\\n        \\n        \\n        return size(mSet);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439056,
                "title": "python-2-liner",
                "content": "# With lambda expression (readability):\\n\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse_codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        encode = lambda word: [morse_codes[ord(c) - ord(\\'a\\')] for c in word]\\n        return len({\"\".join(encode(word)) for word in words})\\n        \\n```\\n\\n# Without lambda expression\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse_codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return len({\"\".join(morse_codes[ord(c) - ord(\\'a\\')] for c in word) for word in words})\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse_codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        encode = lambda word: [morse_codes[ord(c) - ord(\\'a\\')] for c in word]\\n        return len({\"\".join(encode(word)) for word in words})\\n        \\n```\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse_codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return len({\"\".join(morse_codes[ord(c) - ord(\\'a\\')] for c in word) for word in words})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438949,
                "title": "c-easy-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> mp = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        unordered_map<string, bool> check;\\n        for(int i = 0 ; i<words.size() ; i++)\\n        {\\n            string temp = \"\";\\n            string word = words[i];\\n            \\n            for(int j = 0 ; j<word.length() ; j++)\\n            {\\n                temp+= mp[word[j]-\\'a\\'];\\n            }\\n            check[temp] = true;\\n            \\n        }\\n        \\n        return check.size();\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/3eab6ea7-1859-489f-aa13-1b4d0cde7948_1660735826.2910888.png)\\n",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> mp = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        unordered_map<string, bool> check;\\n        for(int i = 0 ; i<words.size() ; i++)\\n        {\\n            string temp = \"\";\\n            string word = words[i];\\n            \\n            for(int j = 0 ; j<word.length() ; j++)\\n            {\\n                temp+= mp[word[j]-\\'a\\'];\\n            }\\n            check[temp] = true;\\n            \\n        }\\n        \\n        return check.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438913,
                "title": "daily-leetcode-challenge",
                "content": "class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> v{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\nunordered_set<string> s;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string temp=\"\";\\n            for(int j=0;j<words[i].size();j++)\\n            {\\n                int e=words[i][j]-\\'a\\';\\n                temp+=v[e];\\n            }s.insert(temp);\\n        }return s.size();\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> v{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}",
                "codeTag": "Java"
            },
            {
                "id": 2438600,
                "title": "js-3-line-faster-than-71",
                "content": "\\n```\\n\\nconst MORSE_CODE = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n\\nconst DICTIONARY = \\'abcdefghijklmnopqrstuvwxyz\\'.split(\\'\\').reduce((a, e,i)=> ({...a, [e]:MORSE_CODE[i]}) , {})\\n\\nconst uniqueMorseRepresentations = (words) => [...new Set(words.map(w=> w.split(\\'\\').map(e=> DICTIONARY[e]).join(\\'\\')))].length\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst MORSE_CODE = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n\\nconst DICTIONARY = \\'abcdefghijklmnopqrstuvwxyz\\'.split(\\'\\').reduce((a, e,i)=> ({...a, [e]:MORSE_CODE[i]}) , {})\\n\\nconst uniqueMorseRepresentations = (words) => [...new Set(words.map(w=> w.split(\\'\\').map(e=> DICTIONARY[e]).join(\\'\\')))].length\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2438355,
                "title": "c-beginner-friendly-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        int n=words.size();\\n        vector<string> alpha={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        map<string,int> m;\\n        for(auto it : words){\\n            string ans;\\n            for(int i=0;i<it.size();++i){\\n                  ans+=alpha[it[i]-\\'a\\'];\\n            }\\n            m[ans]++;\\n            \\n        }\\n        return m.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        int n=words.size();\\n        vector<string> alpha={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        map<string,int> m;\\n        for(auto it : words){\\n            string ans;\\n            for(int i=0;i<it.size();++i){\\n                  ans+=alpha[it[i]-\\'a\\'];\\n            }\\n            m[ans]++;\\n            \\n        }\\n        return m.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438240,
                "title": "beginner-friendly-java-javascript-python-solutions",
                "content": "**Time Complexity : O(n*m)**\\n**Java**\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String morse[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> set = new HashSet();\\n        for(String word: words){\\n            StringBuilder str = new StringBuilder();\\n            for(char c: word.toCharArray()){\\n                str.append(morse[c -\\'a\\']);\\n            }\\n            set.add(str.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    let morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n    let myset = new Set()\\n    for(let word of words){\\n        let str = \"\"\\n        for(let i=0; i<word.length; i++){\\n            str += morse[word.charCodeAt(i) - 97]\\n        }\\n        myset.add(str.toString())\\n    }\\n    return myset.size\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        myset = set()\\n        for word in words:\\n            s = \"\"\\n            for c in word:\\n                s += morse[ord(c) - 97]\\n            myset.add(s)\\n        return len(myset)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String morse[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> set = new HashSet();\\n        for(String word: words){\\n            StringBuilder str = new StringBuilder();\\n            for(char c: word.toCharArray()){\\n                str.append(morse[c -\\'a\\']);\\n            }\\n            set.add(str.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    let morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n    let myset = new Set()\\n    for(let word of words){\\n        let str = \"\"\\n        for(let i=0; i<word.length; i++){\\n            str += morse[word.charCodeAt(i) - 97]\\n        }\\n        myset.add(str.toString())\\n    }\\n    return myset.size\\n};\\n```\n```\\nclass Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        myset = set()\\n        for word in words:\\n            s = \"\"\\n            for c in word:\\n                s += morse[ord(c) - 97]\\n            myset.add(s)\\n        return len(myset)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437872,
                "title": "simple-hashset-solution",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] a={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        HashSet<String>hs=new HashSet<String>();int c=0;\\n        for(String w: words){\\n            String s=\"\";\\n            for(int i=0;i<w.length();i++)\\n                s+=a[(int)w.charAt(i)-\\'a\\'];\\n    \\n            hs.add(s);\\n        }\\n        return hs.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] a={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        HashSet<String>hs=new HashSet<String>();int c=0;\\n        for(String w: words){\\n            String s=\"\";\\n            for(int i=0;i<w.length();i++)\\n                s+=a[(int)w.charAt(i)-\\'a\\'];\\n    \\n            hs.add(s);\\n        }\\n        return hs.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437743,
                "title": "easy-and-concised-solution-c-using-unordered-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> x = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> s;\\n        \\n        for(auto c : words){\\n            string tempAns = \"\";\\n            for(auto t : c){\\n                string temp = x[t - \\'a\\'];\\n                tempAns += temp;\\n            }\\n            s.insert(tempAns);\\n            \\n        }\\n        return (s.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> x = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> s;\\n        \\n        for(auto c : words){\\n            string tempAns = \"\";\\n            for(auto t : c){\\n                string temp = x[t - \\'a\\'];\\n                tempAns += temp;\\n            }\\n            s.insert(tempAns);\\n            \\n        }\\n        return (s.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437541,
                "title": "unique-morse-code-words-simple-c-solution",
                "content": "```\\nint uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        set<string> ans;\\n\\n        for(int i = 0; i < words.size();i++){\\n            string s = words[i]; \\n            string temp = \"\"; \\n\\n            for(int j= 0 ;j < s.length(); j++){\\n                int e = s[j] - \\'a\\'; \\n                temp += morse[e];\\n            }\\n            ans.insert(temp); \\n        }\\n        return ans.size(); \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nint uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        set<string> ans;\\n\\n        for(int i = 0; i < words.size();i++){\\n            string s = words[i]; \\n            string temp = \"\"; \\n\\n            for(int j= 0 ;j < s.length(); j++){\\n                int e = s[j] - \\'a\\'; \\n                temp += morse[e];\\n            }\\n            ans.insert(temp); \\n        }\\n        return ans.size(); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437361,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> v = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\\n                         \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\\n                         \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\\n                         \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> set;\\n        \\n        for(auto &w :words)\\n        {\\n            string s= \"\";\\n            for(auto &ch:w)\\n            {\\n                s+=v[ch - \\'a\\']; \\n            }\\n            set.insert(s);\\n        }\\n        return set.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> v = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\\n                         \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\\n                         \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\\n                         \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> set;\\n        \\n        for(auto &w :words)\\n        {\\n            string s= \"\";\\n            for(auto &ch:w)\\n            {\\n                s+=v[ch - \\'a\\']; \\n            }\\n            set.insert(s);\\n        }\\n        return set.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437311,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] w) {\\n        String a[]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> nm=new HashSet<>();\\n        for(String k:w)\\n        {\\n            StringBuilder kk=new StringBuilder();\\n            for(int i=0;i<k.length();i++)\\n            {\\n                kk.append(a[k.charAt(i)-\\'a\\']);\\n            }\\n            nm.add(kk.toString());\\n        }\\n        return nm.size(); \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public int uniqueMorseRepresentations(String[] w) {\\n        String a[]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}",
                "codeTag": "Java"
            },
            {
                "id": 2437170,
                "title": "c-easy-explanation-map",
                "content": "**Approache : for every word find Morse code and store in the map**\\n\\n**Finnaly return the size of map which is gives unique no of Morse Code**\\n\\n\\n\\n\\n\\n     int uniqueMorseRepresentations(vector<string>& words) {\\n        \\n    // all the Morse Code   \\n    string code[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    \\n        //Declaration map\\n    unordered_map<string,int>mp;\\n    \\n        //loop for no of word\\n     for(int i=0;i<words.size();i++){\\n            string s=\"\";\\n         //for every word calculated Morese code\\n            for(int j=0;j<words[i].size();j++){\\n                s+=code[words[i][j]-\\'a\\'];\\n            }\\n         //store in the map...no duplicate can\\'t add due to 1 assign\\n            mp[s]=1;\\n        }\\n    \\n        //return the size of map\\n    return mp.size();\\n        \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**Approache : for every word find Morse code and store in the map**\\n\\n**Finnaly return the size of map which is gives unique no of Morse Code**\\n\\n\\n\\n\\n\\n     int uniqueMorseRepresentations(vector<string>& words) {\\n        \\n    // all the Morse Code   \\n    string code[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    \\n        //Declaration map\\n    unordered_map<string,int>mp;\\n    \\n        //loop for no of word\\n     for(int i=0;i<words.size();i++){\\n            string s=\"\";\\n         //for every word calculated Morese code\\n            for(int j=0;j<words[i].size();j++){\\n                s+=code[words[i][j]-\\'a\\'];\\n            }\\n         //store in the map...no duplicate can\\'t add due to 1 assign\\n            mp[s]=1;\\n        }\\n    \\n        //return the size of map\\n    return mp.size();\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2437112,
                "title": "easy-java-solution-explained-beginner-friendly-best-method-comments",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        //Storing the code in the Array of Strings\\n        String[] code = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\t\\t\\n\\t\\t//Declaring an HashMap to map each key to its respective value such as {\\'a\\' = \".-\",\\'b\\' = \"-...\",....etc}\\n\\t\\tHashMap<Character,String> map = new HashMap<Character,String>();\\n\\t\\t//initializing a Character Count with value \\'a\\'\\n\\t\\tchar ch = \\'a\\';\\n\\t\\t\\n        for(int i = 0 ; i < code.length ; i ++){\\n\\t\\t\\t//at each iteration we are incrementing the character count by one \\n\\t\\t\\t//i.e from \\'a\\' to \\'b\\' and \\'b\\' to \\'c\\' and so on \\n\\t\\t\\t//and respectively storing the key value pair in HashMap\\n\\t\\t    map.put(ch++,code[i]);\\n\\t\\t}\\n        int n = words.length;\\n\\t\\t//Declaring a HashSet to store Unique set of Concatenated morse code\\n        HashSet<String> hs = new HashSet<String>();\\n\\t\\t\\n\\t\\t//iterating over the array words\\n        for(int i = 0; i < n; i++){\\n\\t\\t\\t//storing each words at index location to string and performing the concatenation\\n            String str = words[i];\\n\\t\\t\\t//declaring an empty string to store the concatenated code at each iteration of a letter of words\\n            String ans = \"\";\\n            for(int j = 0 ; j < str.length(); j++){\\n\\t\\t\\t\\t//concatenating the each letter corresponding code to ans to form proper morse code for the respective words\\n                ans = ans + map.get(str.charAt(j));\\n            }\\n\\t\\t\\t//Storing the generated String(ans) in HashSet to get only unique Strings\\n            hs.add(ans);\\n        }\\n\\t\\t//returning the length of HashSet to get the total no. of unique String obtain from the following words\\n        return hs.size();\\n    }\\n}\\n```\\n**Please Up Vote (if you liked the approach and solution)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        //Storing the code in the Array of Strings\\n        String[] code = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\t\\t\\n\\t\\t//Declaring an HashMap to map each key to its respective value such as {\\'a\\' = \".-\",\\'b\\' = \"-...\",....etc}\\n\\t\\tHashMap<Character,String> map = new HashMap<Character,String>();\\n\\t\\t//initializing a Character Count with value \\'a\\'\\n\\t\\tchar ch = \\'a\\';\\n\\t\\t\\n        for(int i = 0 ; i < code.length ; i ++){\\n\\t\\t\\t//at each iteration we are incrementing the character count by one \\n\\t\\t\\t//i.e from \\'a\\' to \\'b\\' and \\'b\\' to \\'c\\' and so on \\n\\t\\t\\t//and respectively storing the key value pair in HashMap\\n\\t\\t    map.put(ch++,code[i]);\\n\\t\\t}\\n        int n = words.length;\\n\\t\\t//Declaring a HashSet to store Unique set of Concatenated morse code\\n        HashSet<String> hs = new HashSet<String>();\\n\\t\\t\\n\\t\\t//iterating over the array words\\n        for(int i = 0; i < n; i++){\\n\\t\\t\\t//storing each words at index location to string and performing the concatenation\\n            String str = words[i];\\n\\t\\t\\t//declaring an empty string to store the concatenated code at each iteration of a letter of words\\n            String ans = \"\";\\n            for(int j = 0 ; j < str.length(); j++){\\n\\t\\t\\t\\t//concatenating the each letter corresponding code to ans to form proper morse code for the respective words\\n                ans = ans + map.get(str.charAt(j));\\n            }\\n\\t\\t\\t//Storing the generated String(ans) in HashSet to get only unique Strings\\n            hs.add(ans);\\n        }\\n\\t\\t//returning the length of HashSet to get the total no. of unique String obtain from the following words\\n        return hs.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436871,
                "title": "q387-c-100-faster-hash-map-simple-for-loop",
                "content": "### C++ Solution \\nResult:\\n![image](https://assets.leetcode.com/users/images/7d78cf65-202e-4ecc-adee-6ee904ce539f_1660705116.1725438.png)\\n\\nMy Method: \\n```\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morses = { \\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \\n            \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \\n            \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\" \\n            };\\n        map<string, bool> m;\\n        for (int i = 0; i < words.size(); i++) {\\n            string morse = \"\";\\n            for (int j = 0; j < words[i].size(); j++) {\\n                morse += morses[words[i][j] - \\'a\\'];\\n            }\\n            m[morse] = true;\\n        }\\n        return m.size();\\n    }\\n```\\n\\n**The complexity of this solution:**\\n-\\tTime: O( N^2 ) ...  // depend on the size of words\\n-\\tSpace: O( N ) ... // depend on the size of words\\n\\n**If you loved this solution then please up vote to motivate me \\uD83D\\uDE0A**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morses = { \\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \\n            \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \\n            \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\" \\n            };\\n        map<string, bool> m;\\n        for (int i = 0; i < words.size(); i++) {\\n            string morse = \"\";\\n            for (int j = 0; j < words[i].size(); j++) {\\n                morse += morses[words[i][j] - \\'a\\'];\\n            }\\n            m[morse] = true;\\n        }\\n        return m.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2436869,
                "title": "easy-solution-daily-leetcode-challenge-august-17-c-java",
                "content": "## if u find it helpful , please give it a upvote\\n\\n### Approach\\n1) creating a vector of codes.\\n2) convert a word to code by traversing each letter of a word and getting the code for the letter from vector \\n3) concatinating the code into a string \\n4) the string containing transformation of a word is inserted into a set\\n5) repeating for all words\\n6) set contains unique values , so will contain only unique tranformations\\n7) returning set size as the number of different transformations.\\n\\n### C++ solution\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> v = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        set<string> set;\\n        for(int i=0;i<words.size();i++){\\n            string temp = \"\";\\n            for(int j=0;j<words[i].size();j++){\\n                temp+=v[words[i][j]-\\'a\\'];\\n            }\\n            set.insert(temp);\\n            temp.clear();\\n        }\\n        return set.size();\\n    }\\n};\\n```\\n\\n### java code\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n         String[] v = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        Set<String> set = new HashSet<>();\\n        for(String i:words){\\n            StringBuilder temp = new StringBuilder();\\n            int j=0;\\n            while(j<i.length()){\\n                temp.append(v[i.charAt(j)-\\'a\\']);\\n                j++;\\n            }\\n            set.add(temp.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> v = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        set<string> set;\\n        for(int i=0;i<words.size();i++){\\n            string temp = \"\";\\n            for(int j=0;j<words[i].size();j++){\\n                temp+=v[words[i][j]-\\'a\\'];\\n            }\\n            set.insert(temp);\\n            temp.clear();\\n        }\\n        return set.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n         String[] v = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        Set<String> set = new HashSet<>();\\n        for(String i:words){\\n            StringBuilder temp = new StringBuilder();\\n            int j=0;\\n            while(j<i.length()){\\n                temp.append(v[i.charAt(j)-\\'a\\']);\\n                j++;\\n            }\\n            set.add(temp.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436494,
                "title": "simple-c-solution-100-faster-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n    vector<string>morse= {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    unordered_set<string>ans;\\n    for(auto word : words) {\\n        string code = \"\";\\n        for(auto ch : word)\\n            code += morse[ch - \\'a\\'];\\n        ans.insert(code);\\n    }\\n    \\n    return ans.size();\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n    vector<string>morse= {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    unordered_set<string>ans;\\n    for(auto word : words) {\\n        string code = \"\";\\n        for(auto ch : word)\\n            code += morse[ch - \\'a\\'];\\n        ans.insert(code);\\n    }\\n    \\n    return ans.size();\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326190,
                "title": "a-ts-solution-hasmap-and-set",
                "content": "```\\nconst morse: { [key: string]: string } = {\\n  a: \\'.-\\',\\n  b: \\'-...\\',\\n  c: \\'-.-.\\',\\n  d: \\'-..\\',\\n  e: \\'.\\',\\n  f: \\'..-.\\',\\n  g: \\'--.\\',\\n  h: \\'....\\',\\n  i: \\'..\\',\\n  j: \\'.---\\',\\n  k: \\'-.-\\',\\n  l: \\'.-..\\',\\n  m: \\'--\\',\\n  n: \\'-.\\',\\n  o: \\'---\\',\\n  p: \\'.--.\\',\\n  q: \\'--.-\\',\\n  r: \\'.-.\\',\\n  s: \\'...\\',\\n  t: \\'-\\',\\n  u: \\'..-\\',\\n  v: \\'...-\\',\\n  w: \\'.--\\',\\n  x: \\'-..-\\',\\n  y: \\'-.--\\',\\n  z: \\'--..\\',\\n};\\n\\nfunction uniqueMorseRepresentations(words: string[]): number {\\n  const transformations: Set<string> = new Set();\\n  \\n  for (let i = 0; i < words.length; i++) {\\n    let transformation = \\'\\';\\n    \\n    for (let j = 0; j < words[i].length; j++) {\\n      transformation += morse[words[i][j]];\\n    }\\n    \\n    transformations.add(transformation);\\n  }\\n  \\n  return transformations.size;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Ordered Set"
                ],
                "code": "```\\nconst morse: { [key: string]: string } = {\\n  a: \\'.-\\',\\n  b: \\'-...\\',\\n  c: \\'-.-.\\',\\n  d: \\'-..\\',\\n  e: \\'.\\',\\n  f: \\'..-.\\',\\n  g: \\'--.\\',\\n  h: \\'....\\',\\n  i: \\'..\\',\\n  j: \\'.---\\',\\n  k: \\'-.-\\',\\n  l: \\'.-..\\',\\n  m: \\'--\\',\\n  n: \\'-.\\',\\n  o: \\'---\\',\\n  p: \\'.--.\\',\\n  q: \\'--.-\\',\\n  r: \\'.-.\\',\\n  s: \\'...\\',\\n  t: \\'-\\',\\n  u: \\'..-\\',\\n  v: \\'...-\\',\\n  w: \\'.--\\',\\n  x: \\'-..-\\',\\n  y: \\'-.--\\',\\n  z: \\'--..\\',\\n};\\n\\nfunction uniqueMorseRepresentations(words: string[]): number {\\n  const transformations: Set<string> = new Set();\\n  \\n  for (let i = 0; i < words.length; i++) {\\n    let transformation = \\'\\';\\n    \\n    for (let j = 0; j < words[i].length; j++) {\\n      transformation += morse[words[i][j]];\\n    }\\n    \\n    transformations.add(transformation);\\n  }\\n  \\n  return transformations.size;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2166577,
                "title": "python3-o-n-m-o-n",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n#         O(n*m) || O(n)\\n        hashMap = {\\'a\\': \\'.-\\', \\'b\\': \\'-...\\', \\'c\\': \\'-.-.\\', \\'d\\': \\'-..\\', \\'e\\': \\'.\\', \\'f\\': \\'..-.\\', \\'g\\': \\'--.\\', \\'h\\': \\'....\\', \\'i\\': \\'..\\', \\'j\\': \\'.---\\', \\'k\\': \\'-.-\\', \\'l\\': \\'.-..\\', \\'m\\': \\'--\\', \\'n\\': \\'-.\\', \\'o\\': \\'---\\', \\'p\\': \\'.--.\\', \\'q\\': \\'--.-\\', \\'r\\': \\'.-.\\', \\'s\\': \\'...\\', \\'t\\': \\'-\\', \\'u\\': \\'..-\\', \\'v\\': \\'...-\\', \\'w\\': \\'.--\\', \\'x\\': \\'-..-\\', \\'y\\': \\'-.--\\', \\'z\\': \\'--..\\'}\\n            \\n        seen = set()\\n        for word in words:\\n            newList = []\\n            for code in word:\\n                newList.append(hashMap[code])\\n            seen.add(\\'\\'.join(newList))\\n\\n        return len(seen)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n#         O(n*m) || O(n)\\n        hashMap = {\\'a\\': \\'.-\\', \\'b\\': \\'-...\\', \\'c\\': \\'-.-.\\', \\'d\\': \\'-..\\', \\'e\\': \\'.\\', \\'f\\': \\'..-.\\', \\'g\\': \\'--.\\', \\'h\\': \\'....\\', \\'i\\': \\'..\\', \\'j\\': \\'.---\\', \\'k\\': \\'-.-\\', \\'l\\': \\'.-..\\', \\'m\\': \\'--\\', \\'n\\': \\'-.\\', \\'o\\': \\'---\\', \\'p\\': \\'.--.\\', \\'q\\': \\'--.-\\', \\'r\\': \\'.-.\\', \\'s\\': \\'...\\', \\'t\\': \\'-\\', \\'u\\': \\'..-\\', \\'v\\': \\'...-\\', \\'w\\': \\'.--\\', \\'x\\': \\'-..-\\', \\'y\\': \\'-.--\\', \\'z\\': \\'--..\\'}\\n            \\n        seen = set()\\n        for word in words:\\n            newList = []\\n            for code in word:\\n                newList.append(hashMap[code])\\n            seen.add(\\'\\'.join(newList))\\n\\n        return len(seen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153713,
                "title": "unique-morse-code-words-using-maps-and-sets-easy",
                "content": "\\'\\'\\'\\n\\n      vector<string>v{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n       string str=\"abcdefghijklmnopqrstuvwxyz\";\\n        vector<char>arr;\\n        for(auto val:str){\\n            arr.push_back(val);\\n        }\\n        unordered_map<char,string>m;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            m[arr[i]]=v[i];\\n        }\\n        set<string>s;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string str=\"\";\\n            for(int j=0;j<words[i].size();j++)\\n            {\\n                str=str+m[words[i][j]];\\n            }\\n            s.insert(str);\\n            \\n        }\\n        return s.size();\\n\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "\\'\\'\\'\\n\\n      vector<string>v{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n       string str=\"abcdefghijklmnopqrstuvwxyz\";\\n        vector<char>arr;\\n        for(auto val:str){\\n            arr.push_back(val);\\n        }\\n        unordered_map<char,string>m;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            m[arr[i]]=v[i];\\n        }\\n        set<string>s;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string str=\"\";\\n            for(int j=0;j<words[i].size();j++)\\n            {\\n                str=str+m[words[i][j]];\\n            }\\n            s.insert(str);\\n            \\n        }\\n        return s.size();\\n\\t\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1994527,
                "title": "my-easy-to-understand-fast-3ms-java-code",
                "content": "```\\nclass Solution \\n{\\n    public int uniqueMorseRepresentations(String[] words) \\n    {\\n        String[] arr = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        HashSet<String> hs = new HashSet<>();\\n        \\n        for(String s:words)\\n        {\\n            String morse=\"\";\\n            for(int i=0;i<s.length();i++)\\n            {\\n                int c = s.charAt(i)-97;\\n                morse+=arr[c];\\n            }\\n            hs.add(morse);\\n        }\\n        return hs.size();\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public int uniqueMorseRepresentations(String[] words) \\n    {\\n        String[] arr = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}",
                "codeTag": "Java"
            },
            {
                "id": 1966436,
                "title": "fp-scala-solution",
                "content": "```\\nobject Solution {\\n    def uniqueMorseRepresentations(words: Array[String]): Int = {\\n    val mapMorse = (0 until 26).zip(Array(\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",\\n      \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\")).toMap\\n    val arr = \"abcdefghijklmnopqrstuvwxyz\".zipWithIndex.toMap\\n    val result = words.foldLeft(List.empty[String]) { (list, e) =>\\n      val x = e.foldLeft(\"\") { (str, ch) =>\\n        str + mapMorse.get(arr.getOrElse(ch, -1)).mkString\\n      }\\n      list :+ x\\n    }\\n    result.toSet.size\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def uniqueMorseRepresentations(words: Array[String]): Int = {\\n    val mapMorse = (0 until 26).zip(Array(\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",\\n      \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\")).toMap\\n    val arr = \"abcdefghijklmnopqrstuvwxyz\".zipWithIndex.toMap\\n    val result = words.foldLeft(List.empty[String]) { (list, e) =>\\n      val x = e.foldLeft(\"\") { (str, ch) =>\\n        str + mapMorse.get(arr.getOrElse(ch, -1)).mkString\\n      }\\n      list :+ x\\n    }\\n    result.toSet.size\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1869086,
                "title": "faster-than-100-easy-to-understand-maps-beginer-friendly",
                "content": "PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\nASK IN COMMENTS IF FACING ANY DOUBTS\\nHAPPY LEARNING ;)\\n\\n```\\nint uniqueMorseRepresentations(vector<string>& words) {\\n        string p[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        int x=words.size();\\n        map<string,int > mp;\\n        for(int i=0;i<x;i++)\\n        {\\n            string s;\\n            int y=words[i].length();\\n            for(int j=0;j<y;j++)\\n                s+=p[words[i][j]-\\'a\\'];\\n           \\n            mp[s]++;\\n        }return mp.size();\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nint uniqueMorseRepresentations(vector<string>& words) {\\n        string p[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        int x=words.size();\\n        map<string,int > mp;\\n        for(int i=0;i<x;i++)\\n        {\\n            string s;\\n            int y=words[i].length();\\n            for(int j=0;j<y;j++)\\n                s+=p[words[i][j]-\\'a\\'];\\n           \\n            mp[s]++;\\n        }return mp.size();\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1692119,
                "title": "java-solution-using-arraylist-and-for-loop",
                "content": "class Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n       String[] mapOfMorse = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        ArrayList<String> list = new ArrayList<>();\\n        for (int i=0; i< words.length; i++){\\n            String newStr = \"\";\\n            for (int j=0; j<words[i].length(); j++){\\n                int ch = words[i].charAt(j) - \\'a\\';\\n                newStr += mapOfMorse[ch];\\n            }\\n            list.add(newStr);\\n        }\\n        Collections.sort(list);\\n        System.out.println(list);\\n        int transformation = 1;\\n        for (int z=0; z< list.size()-1; z++){\\n            if (!list.get(z).equals(list.get(z+1))){\\n                transformation++;\\n            }\\n        }\\n        return transformation;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n       String[] mapOfMorse = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"}",
                "codeTag": "Java"
            },
            {
                "id": 1646046,
                "title": "easiest-js-solution",
                "content": "var uniqueMorseRepresentations = function(words) {\\n    let final = new Set();\\n    let arr = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    let str;\\n    for(let val of words){\\n        str = \"\";\\n        for(let i=0; i<val.length; i++){\\n            let num = val.charCodeAt(i) - 97;\\n            str += arr[num];\\n        }\\n        final.add(str);\\n    }\\n    return final.size;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var uniqueMorseRepresentations = function(words) {\\n    let final = new Set();\\n    let arr = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    let str;\\n    for(let val of words){\\n        str = \"\";\\n        for(let i=0; i<val.length; i++){\\n            let num = val.charCodeAt(i) - 97;\\n            str += arr[num];\\n        }\\n        final.add(str);\\n    }\\n    return final.size;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1640131,
                "title": "solution-with-complete-explanation-c",
                "content": "**What Question is asking about:-**\\n** **\\nOk So lets see what the question is all about.\\n\\n<img src=\"https://assets.leetcode.com/users/images/40e79095-c826-4ac0-9880-3e04f77feb87_1640111990.1353734.png\" width=\"500px\">\\n\\nSo we have to find number of distinct set we can all make.\\nNote:- The morse code is made in such a way that on multiple combination of letter it shows the same output.(see below example!).\\n\\n**Lets see this from the example:-**\\n** **\\n<img src=\"https://assets.leetcode.com/users/images/3e11c816-f357-4dc1-95ef-a8da3634b586_1640112391.845648.png\" width=\"500px\">\\n\\nAs you can see we get two unique combination of morse code.\\n\\n** **\\n**Solution:-**\\n\\nWe will use ***set*** because we need distinct values so taking any other datatype will only add aditional steps to count all distinct elements.\\n\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n\\t\\n    vector<string> s={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        set<string> strSet;\\n \\n        for(int i=0;i<words.size();i++){\\n            string str=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                str=str+s[words[i][j]-\\'a\\'];\\n            }\\n            strSet.insert(str);\\n        }\\n        return strSet.size();\\n    }\\n\\t\\n};\\n```\\n\\n<br>\\n\\n**If you liked the answer, leave an upvote!\\nThank You So Much :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n\\t\\n    vector<string> s={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        set<string> strSet;\\n \\n        for(int i=0;i<words.size();i++){\\n            string str=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                str=str+s[words[i][j]-\\'a\\'];\\n            }\\n            strSet.insert(str);\\n        }\\n        return strSet.size();\\n    }\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615290,
                "title": "0-ms-faster-than-100-00-simple-easy-to-understand-with-explaination",
                "content": "Runtime: 0 ms, faster than 100.00% of C online submissions for Unique Morse Code Words.\\nMemory Usage: 5.7 MB, less than 79.41% of C online submissions for Unique Morse Code Words.\\n\\nsubmission link:\\nhttps://leetcode.com/submissions/detail/597923184/\\n\\n```\\nint uniqueMorseRepresentations(char ** words, int wordsSize)\\n{\\n    // array containing morse code corresponding to indices 0:a, 1:b, 2:c ...\\n    char *morse[26] = {\\n        \".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"\\n    };\\n\\n    // array to store morse code for each given words\\n    // max. length of an english character in morse code = 4\\n    // now, words[i].length <= 12\\n    // hence 12*4 = 48 + 1(\\'\\\\0\\') = 49(size of morse code of max. words[i].length)\\n    char store[wordsSize][49];\\n    \\n    // converting english characters to morse by accessing the morse array\\n    // english small letters start with ASCII 97, hence it is subtracted\\n    for(int i=0; i<wordsSize; i++)\\n    {\\n        strcpy(store[i], \"\");\\n        for(int j=0; words[i][j]!=\\'\\\\0\\'; j++)\\n            strcat(store[i], morse[words[i][j]-97]);\\n    }\\n     \\n    // counting the unique elements in the store array\\n    int ans=1, j=0;\\n    for(int i=1; i<wordsSize; i++)\\n    {\\n        for(j=0; j<i; j++)\\n            if(!strcmp(store[i], store[j]))\\n                break;\\n        if(i==j)\\n            ans++;\\n    }\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint uniqueMorseRepresentations(char ** words, int wordsSize)\\n{\\n    // array containing morse code corresponding to indices 0:a, 1:b, 2:c ...\\n    char *morse[26] = {\\n        \".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"\\n    };\\n\\n    // array to store morse code for each given words\\n    // max. length of an english character in morse code = 4\\n    // now, words[i].length <= 12\\n    // hence 12*4 = 48 + 1(\\'\\\\0\\') = 49(size of morse code of max. words[i].length)\\n    char store[wordsSize][49];\\n    \\n    // converting english characters to morse by accessing the morse array\\n    // english small letters start with ASCII 97, hence it is subtracted\\n    for(int i=0; i<wordsSize; i++)\\n    {\\n        strcpy(store[i], \"\");\\n        for(int j=0; words[i][j]!=\\'\\\\0\\'; j++)\\n            strcat(store[i], morse[words[i][j]-97]);\\n    }\\n     \\n    // counting the unique elements in the store array\\n    int ans=1, j=0;\\n    for(int i=1; i<wordsSize; i++)\\n    {\\n        for(j=0; j<i; j++)\\n            if(!strcmp(store[i], store[j]))\\n                break;\\n        if(i==j)\\n            ans++;\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1492492,
                "title": "2-line-solution-in-python-using-set-and-list",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse, a = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"], ord(\\'a\\')\\n        return len(set([\"\".join(morse[ord(c) - a] for c in word) for word in words]))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse, a = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"], ord(\\'a\\')\\n        return len(set([\"\".join(morse[ord(c) - a] for c in word) for word in words]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459311,
                "title": "java-solution-runtime-1-ms-faster-than-99-93",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String []strings = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\\n                \"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        HashSet<String> hashSet = new HashSet<>();\\n        for (String st : words){\\n            StringBuilder sb = new StringBuilder();\\n            for (int i=0;i<st.length();i++){\\n                int index = st.charAt(i);\\n                index = index %97;\\n                sb.append(strings[index]);\\n            }\\n            hashSet.add(sb.toString());\\n        }\\n        return hashSet.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String []strings = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\\n                \"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        HashSet<String> hashSet = new HashSet<>();\\n        for (String st : words){\\n            StringBuilder sb = new StringBuilder();\\n            for (int i=0;i<st.length();i++){\\n                int index = st.charAt(i);\\n                index = index %97;\\n                sb.append(strings[index]);\\n            }\\n            hashSet.add(sb.toString());\\n        }\\n        return hashSet.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438934,
                "title": "straightforward-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string morse[26] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\t\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        \\n        set<string> mp;\\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            string word = \"\";\\n            for(char ch : words[i])\\n            {\\n                int idx = ch - \\'a\\';\\n                word += morse[idx];\\n            }\\n            mp.insert(word);\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string morse[26] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\t\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        \\n        set<string> mp;\\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            string word = \"\";\\n            for(char ch : words[i])\\n            {\\n                int idx = ch - \\'a\\';\\n                word += morse[idx];\\n            }\\n            mp.insert(word);\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411931,
                "title": "easy-java-solution-no-hashset",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morseCodeLetterTranslations = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        List<String> convertedUniqueMorseCodes = new ArrayList<>();\\n        for(String indivWord : words){\\n            StringBuilder morseCodeWord = new StringBuilder(); //store morse code here\\n            for(char indivChar : indivWord.toCharArray()){\\n                String morseCodeChar = morseCodeLetterTranslations[indivChar - 97];\\n                morseCodeWord.append(morseCodeChar);\\n            }\\n            if(!convertedUniqueMorseCodes.contains(morseCodeWord.toString())){\\n                convertedUniqueMorseCodes.add(morseCodeWord.toString());\\n            }\\n        }\\n    \\n        return convertedUniqueMorseCodes.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morseCodeLetterTranslations = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        List<String> convertedUniqueMorseCodes = new ArrayList<>();\\n        for(String indivWord : words){\\n            StringBuilder morseCodeWord = new StringBuilder(); //store morse code here\\n            for(char indivChar : indivWord.toCharArray()){\\n                String morseCodeChar = morseCodeLetterTranslations[indivChar - 97];\\n                morseCodeWord.append(morseCodeChar);\\n            }\\n            if(!convertedUniqueMorseCodes.contains(morseCodeWord.toString())){\\n                convertedUniqueMorseCodes.add(morseCodeWord.toString());\\n            }\\n        }\\n    \\n        return convertedUniqueMorseCodes.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397714,
                "title": "simple-python",
                "content": "```\\ncode = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\", \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\nalp = \"abcdefghijklmnopqrstuvwxyz\"\\n        \\n        ls = []\\n        count = 0\\n        string = \"\"\\n        for i in words:\\n            for j in i:\\n                index = alp.index(j)\\n                string += code[index]\\n            ls.append(string)\\n            string = \"\"\\n            \\n        \\n        res = set(ls)\\n        for i in res:\\n            count += 1\\n            \\n        return count\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\ncode = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\", \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\nalp = \"abcdefghijklmnopqrstuvwxyz\"\\n        \\n        ls = []\\n        count = 0\\n        string = \"\"\\n        for i in words:\\n            for j in i:\\n                index = alp.index(j)\\n                string += code[index]\\n            ls.append(string)\\n            string = \"\"\\n            \\n        \\n        res = set(ls)\\n        for i in res:\\n            count += 1\\n            \\n        return count\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1270782,
                "title": "golang-solution-faster-than-100",
                "content": "```\\nfunc uniqueMorseRepresentations(words []string) int {\\n\\tletters := []string{\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",\\n\\t\\t\".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"}\\n\\tm := make(map[string]int)\\n\\n\\tfor _, word := range words {\\n\\t\\ts := \"\"\\n\\t\\tfor _, i := range word {\\n\\t\\t\\ts += letters[i - \\'a\\']\\n\\t\\t}\\n\\t\\tm[s]++\\n\\t}\\n\\treturn len(m)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc uniqueMorseRepresentations(words []string) int {\\n\\tletters := []string{\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",\\n\\t\\t\".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"}\\n\\tm := make(map[string]int)\\n\\n\\tfor _, word := range words {\\n\\t\\ts := \"\"\\n\\t\\tfor _, i := range word {\\n\\t\\t\\ts += letters[i - \\'a\\']\\n\\t\\t}\\n\\t\\tm[s]++\\n\\t}\\n\\treturn len(m)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 991040,
                "title": "o-n-time-o-n-space-easy-solution-using-hashmap",
                "content": "```\\npublic int uniqueMorseRepresentations(String[] words) \\n    {\\n        String[] morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        int count = 0;\\n        HashMap<String,Integer> hash = new HashMap<String,Integer>();\\n        for(String word : words){\\n            char[] chars = word.toCharArray();\\n            String rep = \"\";\\n            for(char c : chars)\\n            {\\n                rep+= morse[c - 97];\\n                \\n            }\\n            if(!hash.containsKey(rep)){\\n                count++;\\n                hash.put(rep,1);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```\\n\\nthought i\\'d share my solution. If anyone has any improvements please send them my way!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int uniqueMorseRepresentations(String[] words) \\n    {\\n        String[] morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        int count = 0;\\n        HashMap<String,Integer> hash = new HashMap<String,Integer>();\\n        for(String word : words){\\n            char[] chars = word.toCharArray();\\n            String rep = \"\";\\n            for(char c : chars)\\n            {\\n                rep+= morse[c - 97];\\n                \\n            }\\n            if(!hash.containsKey(rep)){\\n                count++;\\n                hash.put(rep,1);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 974860,
                "title": "c-and-python-solution",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse_code = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        unordered_set<string> unique_transformations;\\n        \\n        for (auto word: words)\\n        {\\n            string curr_transformation = \"\";\\n            for (auto letter: word)\\n            {\\n                curr_transformation += morse_code[letter - \\'a\\'];\\n\\n            }\\n            unique_transformations.insert(curr_transformation);\\n\\n        }\\n            \\n        return unique_transformations.size();\\n    }\\n};\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse_code = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        unique_transformations = set()\\n        \\n        for word in words:\\n            curr_transformation = \"\"\\n            for letter in word:\\n                curr_transformation += morse_code[ord(letter) - ord(\\'a\\')]\\n            unique_transformations.add(curr_transformation)\\n\\n        return len(unique_transformations)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse_code = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        unordered_set<string> unique_transformations;\\n        \\n        for (auto word: words)\\n        {\\n            string curr_transformation = \"\";\\n            for (auto letter: word)\\n            {\\n                curr_transformation += morse_code[letter - \\'a\\'];\\n\\n            }\\n            unique_transformations.insert(curr_transformation);\\n\\n        }\\n            \\n        return unique_transformations.size();\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse_code = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        unique_transformations = set()\\n        \\n        for word in words:\\n            curr_transformation = \"\"\\n            for letter in word:\\n                curr_transformation += morse_code[ord(letter) - ord(\\'a\\')]\\n            unique_transformations.add(curr_transformation)\\n\\n        return len(unique_transformations)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945604,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        myS=set()\\n        for word in words:\\n            res=\"\"\\n            for c in word:\\n                char=ord(c)\\n                res+=morse[char%97]\\n            myS.add(res)\\n            \\n            \\n        return len(myS)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        myS=set()\\n        for word in words:\\n            res=\"\"\\n            for c in word:\\n                char=ord(c)\\n                res+=morse[char%97]\\n            myS.add(res)\\n            \\n            \\n        return len(myS)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944891,
                "title": "c-99-100-memory-9-liner-crispy-af",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<string> morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        set<string> res;\\n        for (auto word : words) {\\n            string code;\\n            for (auto ch : word) {\\n                code += morse[ch - \\'a\\'];\\n            }\\n            res.insert(code);\\n        }\\n        return res.size();\\n    }\\n};\\n```\\n\\nExplanation -\\n\\n1. Find encoded string and insert in set\\n2. Return set size\\n3. ???\\n4. Profit! \\uD83E\\uDD19\\n\\nAs always,\\n\\uD83E\\uDD19 Stay crispy guys \\uD83E\\uDD19",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<string> morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        set<string> res;\\n        for (auto word : words) {\\n            string code;\\n            for (auto ch : word) {\\n                code += morse[ch - \\'a\\'];\\n            }\\n            res.insert(code);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 828074,
                "title": "java-solution-100-speed-98-memory",
                "content": "Simply create the morsecode and add it to a hashset, which removes any duplicates. Note that we subtract \\'a\\' in order to get the index. To see this, consider \\'a\\' itself. \\'a\\' = 97, or some value in either ASCII, Unicode. \\'a\\' - \\'a\\' will always get us 0. \\'b\\' will be 1 above a, at 98-97 and so on. This will get us 1. Our alphabet is arranged so the 0th item is \\'a\\', 1st item is b, and so on. Hence, we subtract to get the index. \\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] alphabet = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        HashSet<String> set = new HashSet<>();\\n        for(String word : words){\\n            StringBuilder build = new StringBuilder();\\n            for(int c : word.toCharArray()){\\n                c = c-\\'a\\';\\n                build.append(alphabet[c]);\\n            }\\n            set.add(build.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] alphabet = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        HashSet<String> set = new HashSet<>();\\n        for(String word : words){\\n            StringBuilder build = new StringBuilder();\\n            for(int c : word.toCharArray()){\\n                c = c-\\'a\\';\\n                build.append(alphabet[c]);\\n            }\\n            set.add(build.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696527,
                "title": "java-solution-clean-code",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String dict[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                         \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\\n                         \".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> set = new HashSet<>();\\n        for(int i=0;i<words.length;i++){\\n            StringBuilder sb = new StringBuilder(\"\");\\n            char[] str = words[i].toCharArray();\\n            for(char ch : str) sb.append(dict[ch-97]);\\n            set.add(sb.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String dict[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                         \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\\n                         \".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> set = new HashSet<>();\\n        for(int i=0;i<words.length;i++){\\n            StringBuilder sb = new StringBuilder(\"\");\\n            char[] str = words[i].toCharArray();\\n            for(char ch : str) sb.append(dict[ch-97]);\\n            set.add(sb.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652411,
                "title": "javascript-concat-fcn-to-build-strings-store-in-set",
                "content": "Note: In JavaScript, primitive values are immutable so we must use trans = trans.concat to make a copy of the variable and change it.\\n\\n```\\nlet uniqueMorseRepresentations = (words) => {\\n    const ca = \\'a\\'.charCodeAt(0);\\n    let morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    let record = new Set();\\n    for (let i in words){\\n        let trans = \"\";\\n        for (let c of words[i])\\n            trans = trans.concat(morse[c.charCodeAt(0)-ca]);\\n        record.add(trans);\\n    }\\n    return record.size;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet uniqueMorseRepresentations = (words) => {\\n    const ca = \\'a\\'.charCodeAt(0);\\n    let morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    let record = new Set();\\n    for (let i in words){\\n        let trans = \"\";\\n        for (let c of words[i])\\n            trans = trans.concat(morse[c.charCodeAt(0)-ca]);\\n        record.add(trans);\\n    }\\n    return record.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 549576,
                "title": "object-fromentries-not-working",
                "content": "How come this doesn\\'t work on LeetCode?\\n```\\nRuntime Error\\nLine 9 in solution.js\\n    const dict = Object.freeze(Object.fromEntries([\\n                                      ^\\nTypeError: Object.fromEntries is not a function\\n    Line 9: Char 39 in solution.js \\n```",
                "solutionTags": [],
                "code": "```\\nRuntime Error\\nLine 9 in solution.js\\n    const dict = Object.freeze(Object.fromEntries([\\n                                      ^\\nTypeError: Object.fromEntries is not a function\\n    Line 9: Char 39 in solution.js \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 545198,
                "title": "javascript-easy-readable-95-34",
                "content": "```\\nvar getMorseCodeByStr = str => {\\n  const morseMap = {\\n    a: \\'.-\\',\\n    b: \\'-...\\',\\n    c: \\'-.-.\\',\\n    d: \\'-..\\',\\n    e: \\'.\\',\\n    f: \\'..-.\\',\\n    g: \\'--.\\',\\n    h: \\'....\\',\\n    i: \\'..\\',\\n    j: \\'.---\\',\\n    k: \\'-.-\\',\\n    l: \\'.-..\\',\\n    m: \\'--\\',\\n    n: \\'-.\\',\\n    o: \\'---\\',\\n    p: \\'.--.\\',\\n    q: \\'--.-\\',\\n    r: \\'.-.\\',\\n    s: \\'...\\',\\n    t: \\'-\\',\\n    u: \\'..-\\',\\n    v: \\'...-\\',\\n    w: \\'.--\\',\\n    x: \\'-..-\\',\\n    y: \\'-.--\\',\\n    z: \\'--..\\',\\n  };\\n  let result = \\'\\';\\n  \\n  for (let i = 0; i < str.length; i += 1) {\\n    result += morseMap[str[i]];\\n  }\\n  \\n  return result;\\n};\\n\\nvar uniqueMorseRepresentations = function(words) {\\n  const set = new Set();\\n  \\n  for (let i = 0; i < words.length; i += 1) {\\n    set.add(getMorseCodeByStr(words[i]));\\n  }\\n  \\n  return set.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMorseCodeByStr = str => {\\n  const morseMap = {\\n    a: \\'.-\\',\\n    b: \\'-...\\',\\n    c: \\'-.-.\\',\\n    d: \\'-..\\',\\n    e: \\'.\\',\\n    f: \\'..-.\\',\\n    g: \\'--.\\',\\n    h: \\'....\\',\\n    i: \\'..\\',\\n    j: \\'.---\\',\\n    k: \\'-.-\\',\\n    l: \\'.-..\\',\\n    m: \\'--\\',\\n    n: \\'-.\\',\\n    o: \\'---\\',\\n    p: \\'.--.\\',\\n    q: \\'--.-\\',\\n    r: \\'.-.\\',\\n    s: \\'...\\',\\n    t: \\'-\\',\\n    u: \\'..-\\',\\n    v: \\'...-\\',\\n    w: \\'.--\\',\\n    x: \\'-..-\\',\\n    y: \\'-.--\\',\\n    z: \\'--..\\',\\n  };\\n  let result = \\'\\';\\n  \\n  for (let i = 0; i < str.length; i += 1) {\\n    result += morseMap[str[i]];\\n  }\\n  \\n  return result;\\n};\\n\\nvar uniqueMorseRepresentations = function(words) {\\n  const set = new Set();\\n  \\n  for (let i = 0; i < words.length; i += 1) {\\n    set.add(getMorseCodeByStr(words[i]));\\n  }\\n  \\n  return set.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 536814,
                "title": "python-3-set-map-solution-with-explanation-beats-98-61",
                "content": "```\\n## set + map--find all cases\\uFF0Cthen use len(set()) to get number of different cases\\n## Time complexity = O(n)\\uFF0CSpace complexity = O(1)        \\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        moorse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        trans = lambda x: moorse[ord(x) - ord(\\'a\\')]\\n        map_word = lambda word: \\'\\'.join([trans(x) for x in word])\\n        res = map(map_word, words)\\n        return len(set(res))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n## set + map--find all cases\\uFF0Cthen use len(set()) to get number of different cases\\n## Time complexity = O(n)\\uFF0CSpace complexity = O(1)        \\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        moorse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        trans = lambda x: moorse[ord(x) - ord(\\'a\\')]\\n        map_word = lambda word: \\'\\'.join([trans(x) for x in word])\\n        res = map(map_word, words)\\n        return len(set(res))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461805,
                "title": "rust-0ms-functional-solution",
                "content": "```rust\\npub fn unique_morse_representations(words: Vec<String>) -> i32 {\\n\\tconst TABLE: [&str; 26] = [\\n\\t\\t\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\",\\n\\t\\t\"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\",\\n\\t];\\n\\twords\\n\\t\\t.iter()\\n\\t\\t.map(|w| w.chars().map(|c| TABLE[c as usize - \\'a\\' as usize]).collect::<String>())\\n\\t\\t.collect::<std::collections::HashSet<_>>()\\n\\t\\t.len() as i32\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn unique_morse_representations(words: Vec<String>) -> i32 {\\n\\tconst TABLE: [&str; 26] = [\\n\\t\\t\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\",\\n\\t\\t\"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\",\\n\\t];\\n\\twords\\n\\t\\t.iter()\\n\\t\\t.map(|w| w.chars().map(|c| TABLE[c as usize - \\'a\\' as usize]).collect::<String>())\\n\\t\\t.collect::<std::collections::HashSet<_>>()\\n\\t\\t.len() as i32\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 361389,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Set<String> set = new HashSet<String>();\\n\\t\\tString[] encodes = { \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\",\\n\\t\\t\\t\\t\"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\" };\\n\\t\\tfor (String item : words) {\\n\\t\\t\\tString temp = \"\";\\n\\t\\t\\tfor (int i = 0; i < item.length(); i++) {\\n\\t\\t\\t\\ttemp += encodes[item.charAt(i) - \\'a\\'];\\n\\t\\t\\t}\\n\\t\\t\\tset.add(temp);\\n\\t\\t}\\n\\t\\treturn set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Set<String> set = new HashSet<String>();\\n\\t\\tString[] encodes = { \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\",\\n\\t\\t\\t\\t\"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\" };\\n\\t\\tfor (String item : words) {\\n\\t\\t\\tString temp = \"\";\\n\\t\\t\\tfor (int i = 0; i < item.length(); i++) {\\n\\t\\t\\t\\ttemp += encodes[item.charAt(i) - \\'a\\'];\\n\\t\\t\\t}\\n\\t\\t\\tset.add(temp);\\n\\t\\t}\\n\\t\\treturn set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338046,
                "title": "javascript-1-2-line-solution-using-set-charcodeat",
                "content": "```\\nvar uniqueMorseRepresentations = function (words) {\\n  const morse = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"];\\n  return [...(new Set(words.map(word => word.split(\"\").map(c => morse[c.charCodeAt() - 97]).join(\"\"))))].length;\\n};",
                "solutionTags": [],
                "code": "```\\nvar uniqueMorseRepresentations = function (words) {\\n  const morse = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"];\\n  return [...(new Set(words.map(word => word.split(\"\").map(c => morse[c.charCodeAt() - 97]).join(\"\"))))].length;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 330729,
                "title": "python-code",
                "content": "Runtime: 4 ms, faster than 100.00% of Python online submissions for Unique Morse Code Words.\\nMemory Usage: 11.7 MB, less than 75.08% of Python online submissions for Unique Morse Code Words.\\n\\n\\n```\\n\\t\\tmorse=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        s=[]\\n        for i in words:\\n            a=\\'\\'\\n            for ii in i:\\n                a=a+morse[ord(ii)-97]\\n            if a in s:\\n                continue\\n            else:\\n                s.append(a)\\n        return len(s)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\t\\tmorse=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        s=[]\\n        for i in words:\\n            a=\\'\\'\\n            for ii in i:\\n                a=a+morse[ord(ii)-97]\\n            if a in s:\\n                continue\\n            else:\\n                s.append(a)\\n        return len(s)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293028,
                "title": "easy-to-understand-modern-javascript-solution",
                "content": "Most time spent to array => map conversion. Could be done programmatically as well.\\n\\n```js\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nconst uniqueMorseRepresentations = (words) => {\\n    const set = new Set();\\n    \\n    for (let word of words) {\\n        set.add(toMorse(word));\\n    }\\n    \\n    return set.size\\n};\\n\\nconst toMorse = (word) => {\\n    let result = \\'\\';\\n\\n    for (let char of word) {\\n        result += map.get(char);\\n    }\\n    \\n    return result;\\n}\\n\\nconst map = new Map([\\n  [\\'a\\', \\'.-\\'],\\n  [\\'b\\', \\'-...\\'],\\n  [\\'c\\', \\'-.-.\\'],\\n  [\\'d\\', \\'-..\\'],\\n  [\\'e\\', \\'.\\'],\\n  [\\'f\\', \\'..-.\\'],\\n  [\\'g\\', \\'--.\\'],\\n  [\\'h\\', \\'....\\'],\\n  [\\'i\\', \\'..\\'],\\n  [\\'j\\', \\'.---\\'],\\n  [\\'k\\', \\'-.-\\'],\\n  [\\'l\\', \\'.-..\\'],\\n  [\\'m\\', \\'--\\'],\\n  [\\'n\\', \\'-.\\'],\\n  [\\'o\\', \\'---\\'],\\n  [\\'p\\', \\'.--.\\'],\\n  [\\'q\\', \\'--.-\\'],\\n  [\\'r\\', \\'.-.\\'],\\n  [\\'s\\', \\'...\\'],\\n  [\\'t\\', \\'-\\'],\\n  [\\'u\\', \\'..-\\'],\\n  [\\'v\\', \\'...-\\'],\\n  [\\'w\\', \\'.--\\'],\\n  [\\'x\\', \\'-..-\\'],\\n  [\\'y\\', \\'-.--\\'],\\n  [\\'z\\', \\'--..\\']\\n]);\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```js\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nconst uniqueMorseRepresentations = (words) => {\\n    const set = new Set();\\n    \\n    for (let word of words) {\\n        set.add(toMorse(word));\\n    }\\n    \\n    return set.size\\n};\\n\\nconst toMorse = (word) => {\\n    let result = \\'\\';\\n\\n    for (let char of word) {\\n        result += map.get(char);\\n    }\\n    \\n    return result;\\n}\\n\\nconst map = new Map([\\n  [\\'a\\', \\'.-\\'],\\n  [\\'b\\', \\'-...\\'],\\n  [\\'c\\', \\'-.-.\\'],\\n  [\\'d\\', \\'-..\\'],\\n  [\\'e\\', \\'.\\'],\\n  [\\'f\\', \\'..-.\\'],\\n  [\\'g\\', \\'--.\\'],\\n  [\\'h\\', \\'....\\'],\\n  [\\'i\\', \\'..\\'],\\n  [\\'j\\', \\'.---\\'],\\n  [\\'k\\', \\'-.-\\'],\\n  [\\'l\\', \\'.-..\\'],\\n  [\\'m\\', \\'--\\'],\\n  [\\'n\\', \\'-.\\'],\\n  [\\'o\\', \\'---\\'],\\n  [\\'p\\', \\'.--.\\'],\\n  [\\'q\\', \\'--.-\\'],\\n  [\\'r\\', \\'.-.\\'],\\n  [\\'s\\', \\'...\\'],\\n  [\\'t\\', \\'-\\'],\\n  [\\'u\\', \\'..-\\'],\\n  [\\'v\\', \\'...-\\'],\\n  [\\'w\\', \\'.--\\'],\\n  [\\'x\\', \\'-..-\\'],\\n  [\\'y\\', \\'-.--\\'],\\n  [\\'z\\', \\'--..\\']\\n]);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 278164,
                "title": "javascript-89-34",
                "content": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    \\n\\t// Define a set and variable morse (set to empty string);\\n    let morseSet = new Set;\\n    let morse = \"\";\\n    \\n\\t// Define object literal\\n    function decypher(elem) {\\n        var code = {\\n            \"a\": \".-\",\\n            \"b\":\"-...\",\\n            \"c\":\"-.-.\",\\n            \"d\":\"-..\",\\n            \"e\":\".\",\\n            \"f\":\"..-.\",\\n            \"g\":\"--.\",\\n            \"h\":\"....\",\\n            \"i\":\"..\",\\n            \"j\":\".---\",\\n            \"k\":\"-.-\",\\n            \"l\":\".-..\",\\n            \"m\":\"--\",\\n            \"n\":\"-.\",\\n            \"o\":\"---\",\\n            \"p\":\".--.\",\\n            \"q\":\"--.-\",\\n            \"r\":\".-.\",\\n            \"s\":\"...\",\\n            \"t\":\"-\",\\n            \"u\":\"..-\",\\n            \"v\":\"...-\",\\n            \"w\":\".--\",\\n            \"x\":\"-..-\",\\n            \"y\":\"-.--\",\\n            \"z\":\"--..\"\\n        };    \\n        return (code[elem]);\\n    }\\n    \\n\\t// Iterate through each character in each word\\n    for(let i = 0; i < words.length; i++) {\\n        for(let j = 0; j < words[i].length; j++) {\\n            morse += decypher(words[i][j]);\\n        }\\n\\t\\t// Add to set\\n        morseSet.add(morse);\\n\\t\\t\\n\\t\\t// Reset morse variable\\n        morse = \"\";\\n    }\\n\\n\\t// Return size of set \\n    return morseSet.size;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    \\n\\t// Define a set and variable morse (set to empty string);\\n    let morseSet = new Set;\\n    let morse = \"\";\\n    \\n\\t// Define object literal\\n    function decypher(elem) {\\n        var code = {\\n            \"a\": \".-\",\\n            \"b\":\"-...\",\\n            \"c\":\"-.-.\",\\n            \"d\":\"-..\",\\n            \"e\":\".\",\\n            \"f\":\"..-.\",\\n            \"g\":\"--.\",\\n            \"h\":\"....\",\\n            \"i\":\"..\",\\n            \"j\":\".---\",\\n            \"k\":\"-.-\",\\n            \"l\":\".-..\",\\n            \"m\":\"--\",\\n            \"n\":\"-.\",\\n            \"o\":\"---\",\\n            \"p\":\".--.\",\\n            \"q\":\"--.-\",\\n            \"r\":\".-.\",\\n            \"s\":\"...\",\\n            \"t\":\"-\",\\n            \"u\":\"..-\",\\n            \"v\":\"...-\",\\n            \"w\":\".--\",\\n            \"x\":\"-..-\",\\n            \"y\":\"-.--\",\\n            \"z\":\"--..\"\\n        };    \\n        return (code[elem]);\\n    }\\n    \\n\\t// Iterate through each character in each word\\n    for(let i = 0; i < words.length; i++) {\\n        for(let j = 0; j < words[i].length; j++) {\\n            morse += decypher(words[i][j]);\\n        }\\n\\t\\t// Add to set\\n        morseSet.add(morse);\\n\\t\\t\\n\\t\\t// Reset morse variable\\n        morse = \"\";\\n    }\\n\\n\\t// Return size of set \\n    return morseSet.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 275680,
                "title": "beats-97-85-simple-python-code",
                "content": "```\\nclass Solution:\\t\\n\\tdef uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\t   result_letter = \"\"\\n       result_word = []\\n\\t\\t\\n        morse_arr = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\n        for word in words:\\n            for letter in word:\\n                result_letter = result_letter +morse_arr[ord(letter)-97]\\n            result_word.append(result_letter)\\n            result_letter = \"\"              \\n               \\n        return(len(set(result_word)))\\n```\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\t\\n\\tdef uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\t   result_letter = \"\"\\n       result_word = []\\n\\t\\t\\n        morse_arr = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\n        for word in words:\\n            for letter in word:\\n                result_letter = result_letter +morse_arr[ord(letter)-97]\\n            result_word.append(result_letter)\\n            result_letter = \"\"              \\n               \\n        return(len(set(result_word)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 266684,
                "title": "c-4ms-faster-than-100-and-8-9-mb-less",
                "content": "``` \\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        string code[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> temp;\\n        string word;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            word=\"\";\\n            for(int j=0;j<words[i].length();j++)\\n            {\\n                word += code[words[i][j]-97];\\n            }\\n            temp.insert(word);\\n        }\\n        return temp.size();\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        string code[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}",
                "codeTag": "Java"
            },
            {
                "id": 244975,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        set<string> uniq;\\n        vector<string> abc = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        for(auto word : words){\\n            string trans = \"\";\\n            for(auto c : word){\\n                trans += abc[c - \\'a\\'];\\n            }\\n            uniq.insert(trans);\\n        }\\n        return uniq.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        set<string> uniq;\\n        vector<string> abc = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        for(auto word : words){\\n            string trans = \"\";\\n            for(auto c : word){\\n                trans += abc[c - \\'a\\'];\\n            }\\n            uniq.insert(trans);\\n        }\\n        return uniq.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201895,
                "title": "0ms-solution-in-c",
                "content": "```\\ntypedef struct {\\n    char len;\\n    char val;\\n} morseCode;\\n\\nmorseCode codeTable[] = {\\n    {2, 2}, /* a .-   10*/\\n    {4, 7}, /* b -... 0111*/\\n    {4, 5}, /* c -.-. 0101 */\\n    {3, 3},\\n    {1, 1},\\n    {4,13},\\n    {3, 1},\\n    {4,15},\\n    {2, 3},\\n    {4, 8},\\n    {3, 2},\\n    {4,11},\\n    {2, 0},\\n    {2, 1},\\n    {3, 0},\\n    {4, 9},\\n    {4, 2},\\n    {3, 5},\\n    {3, 7},\\n    {1, 0},\\n    {3, 6},\\n    {4,14},\\n    {3, 4},\\n    {4, 6},\\n    {4, 4},\\n    {4, 3}\\n};\\n\\ntypedef struct{\\n    int len;\\n    int val;\\n}morseString;\\n\\nmorseString getmorseString(char* s) {\\n    morseString str;\\n    str.len = 0;\\n    str.val = 0;\\n    \\n    char *p = s;\\n    while(*p != \\'\\\\0\\')\\n    {\\n        char c = *p;\\n        if (c < \\'a\\' || c > \\'z\\'){\\n            printf(\"Invalid input *p = %c\\\\n\", c);\\n            p++;\\n            continue;\\n        }\\n        \\n        morseCode code = codeTable[c - \\'a\\']; \\n        str.len += code.len;\\n        str.val = (str.val << (code.len)) + code.val;\\n        p++;\\n    }\\n    \\n    return str;\\n}\\n\\nint uniqueMorseRepresentations(char** words, int wordsSize) {\\n    int result = -1;\\n    morseString stack[100];\\n    \\n    for(int i = 0; i < wordsSize; i++)\\n    {\\n        morseString str = getmorseString(words[i]);\\n        bool foundone = false;\\n        for (int j = 0; j <= result; j++)\\n        {\\n            // check one by one if str in stack\\n            if (stack[j].len == str.len && stack[j].val == str.val) {\\n                foundone = true;\\n                break;\\n            }\\n        }\\n        \\n        if (!foundone)\\n        {\\n            stack[++result] = str;\\n        }\\n    }\\n    \\n    return result + 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct {\\n    char len;\\n    char val;\\n} morseCode;\\n\\nmorseCode codeTable[] = {\\n    {2, 2}, /* a .-   10*/\\n    {4, 7}, /* b -... 0111*/\\n    {4, 5}, /* c -.-. 0101 */\\n    {3, 3},\\n    {1, 1},\\n    {4,13},\\n    {3, 1},\\n    {4,15},\\n    {2, 3},\\n    {4, 8},\\n    {3, 2},\\n    {4,11},\\n    {2, 0},\\n    {2, 1},\\n    {3, 0},\\n    {4, 9},\\n    {4, 2},\\n    {3, 5},\\n    {3, 7},\\n    {1, 0},\\n    {3, 6},\\n    {4,14},\\n    {3, 4},\\n    {4, 6},\\n    {4, 4},\\n    {4, 3}\\n};\\n\\ntypedef struct{\\n    int len;\\n    int val;\\n}morseString;\\n\\nmorseString getmorseString(char* s) {\\n    morseString str;\\n    str.len = 0;\\n    str.val = 0;\\n    \\n    char *p = s;\\n    while(*p != \\'\\\\0\\')\\n    {\\n        char c = *p;\\n        if (c < \\'a\\' || c > \\'z\\'){\\n            printf(\"Invalid input *p = %c\\\\n\", c);\\n            p++;\\n            continue;\\n        }\\n        \\n        morseCode code = codeTable[c - \\'a\\']; \\n        str.len += code.len;\\n        str.val = (str.val << (code.len)) + code.val;\\n        p++;\\n    }\\n    \\n    return str;\\n}\\n\\nint uniqueMorseRepresentations(char** words, int wordsSize) {\\n    int result = -1;\\n    morseString stack[100];\\n    \\n    for(int i = 0; i < wordsSize; i++)\\n    {\\n        morseString str = getmorseString(words[i]);\\n        bool foundone = false;\\n        for (int j = 0; j <= result; j++)\\n        {\\n            // check one by one if str in stack\\n            if (stack[j].len == str.len && stack[j].val == str.val) {\\n                foundone = true;\\n                break;\\n            }\\n        }\\n        \\n        if (!foundone)\\n        {\\n            stack[++result] = str;\\n        }\\n    }\\n    \\n    return result + 1;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 185719,
                "title": "python-2-liner",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        letters=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return len(set(\"\".join(letters[ord(letter)-ord(\"a\")] for letter in word) for word in words))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        letters=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return len(set(\"\".join(letters[ord(letter)-ord(\"a\")] for letter in word) for word in words))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172828,
                "title": "python-3-line-simple-intuitive-pythonic",
                "content": "`zip()` to create `(alphabet-morse)` tuple, `dict()` to construct dictionary mapping. itereate word and letter and apply `join()` to construct string. Throw to `set()` to remove any duplicate and return its `len()` \\n```\\nfrom string import ascii_lowercase\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        \"\"\"\\n        morsecode = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        translation = dict(zip(ascii_lowercase,morsecode))\\n        return len(set([\"\".join(translation[letter] for letter in word) for word in words]))\\n```",
                "solutionTags": [],
                "code": "```\\nfrom string import ascii_lowercase\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        \"\"\"\\n        morsecode = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        translation = dict(zip(ascii_lowercase,morsecode))\\n        return len(set([\"\".join(translation[letter] for letter in word) for word in words]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141987,
                "title": "c-beats-100-100ms-clear-solution",
                "content": "Store the morse code letter representations in an array. \\nAccess that array by getting the index. You get the index by using ASCII math and taking the current letter you want and subtracting \\'a\\'. \\nUse StringBuilder to build the morse code version of the word and throw that into a HashSet.\\n\\n```\\npublic int UniqueMorseRepresentations(string[] words) {\\n        var letters = new string[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        var hash = new HashSet<string>();\\n        \\n        var sb = new StringBuilder();\\n        foreach (var word in words)\\n        {\\n            sb = new StringBuilder();\\n            var r = word.ToCharArray();\\n            for (int i = 0; i < r.Length; i++)\\n            {\\n                sb.Append(letters[r[i]-\\'a\\']);\\n            }\\n            hash.Add(sb.ToString());\\n        }\\n        \\n        return hash.Count;\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\npublic int UniqueMorseRepresentations(string[] words) {\\n        var letters = new string[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        var hash = new HashSet<string>();\\n        \\n        var sb = new StringBuilder();\\n        foreach (var word in words)\\n        {\\n            sb = new StringBuilder();\\n            var r = word.ToCharArray();\\n            for (int i = 0; i < r.Length; i++)\\n            {\\n                sb.Append(letters[r[i]-\\'a\\']);\\n            }\\n            hash.Add(sb.ToString());\\n        }\\n        \\n        return hash.Count;\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 138396,
                "title": "0ms-golang-solution",
                "content": "```\\nfunc uniqueMorseRepresentations(words []string) int {\\n    table := []string{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}\\n    \\n    result := make(map[string]bool)\\n    for _, w := range words {\\n        var res string\\n        for _, r  := range w {\\n            res += table[unicode.ToLower(r)-\\'a\\']\\n        }\\n        result[res] = true\\n    }\\n    \\n    return len(result)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc uniqueMorseRepresentations(words []string) int {\\n    table := []string{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}\\n    \\n    result := make(map[string]bool)\\n    for _, w := range words {\\n        var res string\\n        for _, r  := range w {\\n            res += table[unicode.ToLower(r)-\\'a\\']\\n        }\\n        result[res] = true\\n    }\\n    \\n    return len(result)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133135,
                "title": "c-beats-99-7-short-and-simple",
                "content": "```\\nstring decode(string a){\\n    string morse [26] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        string temp=\"\";\\n        for(int i = 0;i<a.size();i++){\\n            temp+=morse[int(a[i])-97];     \\n            }\\n            return temp;\\n        }\\n    class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> temp;\\n        for(int i = 0;i<words.size();i++){\\n            words[i]= decode(words[i]);\\n            bool found = false;\\n            for(int j = 0; j<temp.size();j++){\\n                if(words[i]==temp[j]){\\n                    found = true;\\n                }\\n            }\\n            if(!found){\\n                temp.push_back(words[i]);\\n            }\\n        }\\n        return temp.size();\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstring decode(string a){\\n    string morse [26] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        string temp=\"\";\\n        for(int i = 0;i<a.size();i++){\\n            temp+=morse[int(a[i])-97];     \\n            }\\n            return temp;\\n        }\\n    class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> temp;\\n        for(int i = 0;i<words.size();i++){\\n            words[i]= decode(words[i]);\\n            bool found = false;\\n            for(int j = 0; j<temp.size();j++){\\n                if(words[i]==temp[j]){\\n                    found = true;\\n                }\\n            }\\n            if(!found){\\n                temp.push_back(words[i]);\\n            }\\n        }\\n        return temp.size();\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131560,
                "title": "c-bits-99-7-with-no-strings-comparison",
                "content": "class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        unordered_set<unsigned long> results;\\n        vector<pair<int, unsigned>> alphabet = {{2, 0b01}, {4 ,0b1000}, {4 ,0b1010}, {3 ,0b100}, {1 ,0b0}, {4 ,0b0010}, {3 ,0b110}, {4 ,0b0000}, {2 ,0b00}, {4 ,0b0111}, {3 ,0b101}, {4 ,0b0100}, {2 ,0b11}, {2 ,0b10}, {3 ,0b111}, {4 ,0b0110}, {4 ,0b1101}, {3 ,0b010}, {3 ,0b000}, {1 ,0b1}, {3 ,0b001}, {4 ,0b0001}, {3 ,0b011}, {4 ,0b1001}, {4 ,0b1011}, {4 ,0b1100}};\\n        for(size_t i = 0; i < words.size(); ++i)\\n        {\\n            unsigned long result = 0;\\n            for(size_t j = 0; j < words[i].size(); ++j)\\n            {\\n                auto cur = alphabet[words[i][j] - \\'a\\'];\\n                result = result << cur.first | cur.second;\\n            }\\n            results.insert(result);\\n        }        \\n        return results.size();\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        unordered_set<unsigned long> results;\\n        vector<pair<int, unsigned>> alphabet = {{2, 0b01}",
                "codeTag": "Java"
            },
            {
                "id": 125655,
                "title": "ruby-solution-by-a-ruby-noob",
                "content": "```\\n# @param {String[]} words\\n# @return {Integer}\\ndef unique_morse_representations(words)\\n    \\n    letter = [\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n    morseLetter = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n    translation = {}\\n    morseWords = []\\n    \\n    # map each letter to its morse code equivalent\\n    letter.each_with_index {|k,v|translation[k] = morseLetter[v]}\\n\\n    # iterate through words and get morse code translation\\n    words.each{ |word| morseWords << word.split(\"\").map{ |char| translation[char] }.join(\"\") }\\n    \\n    # remove duplicates and return length\\n    return morseWords.uniq.length\\n    \\n    \\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {String[]} words\\n# @return {Integer}\\ndef unique_morse_representations(words)\\n    \\n    letter = [\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n    morseLetter = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n    translation = {}\\n    morseWords = []\\n    \\n    # map each letter to its morse code equivalent\\n    letter.each_with_index {|k,v|translation[k] = morseLetter[v]}\\n\\n    # iterate through words and get morse code translation\\n    words.each{ |word| morseWords << word.split(\"\").map{ |char| translation[char] }.join(\"\") }\\n    \\n    # remove duplicates and return length\\n    return morseWords.uniq.length\\n    \\n    \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 122225,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Set<String> uniqueMorse = new HashSet();\\n        String[] morseCodes = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        for(String word: words){\\n            String code=\"\";\\n            for(int i =0; i<word.length();i++){\\n                int n = word.charAt(i) - \\'a\\';\\n                code+=morseCodes[n];\\n            }\\n            uniqueMorse.add(code);\\n        }\\n        return uniqueMorse.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Set<String> uniqueMorse = new HashSet();\\n        String[] morseCodes = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        for(String word: words){\\n            String code=\"\";\\n            for(int i =0; i<word.length();i++){\\n                int n = word.charAt(i) - \\'a\\';\\n                code+=morseCodes[n];\\n            }\\n            uniqueMorse.add(code);\\n        }\\n        return uniqueMorse.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1775004,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1571919,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1566109,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1566857,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1714477,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1567297,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1569215,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1846798,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1756496,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1573307,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1775004,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1571919,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1566109,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1566857,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1714477,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1567297,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1569215,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1846798,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1756496,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1573307,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Chunked Palindrome Decomposition",
        "question_content": "<p>You are given a string <code>text</code>. You should split it to k substrings <code>(subtext<sub>1</sub>, subtext<sub>2</sub>, ..., subtext<sub>k</sub>)</code> such that:</p>\n\n<ul>\n\t<li><code>subtext<sub>i</sub></code> is a <strong>non-empty</strong> string.</li>\n\t<li>The concatenation of all the substrings is equal to <code>text</code> (i.e., <code>subtext<sub>1</sub> + subtext<sub>2</sub> + ... + subtext<sub>k</sub> == text</code>).</li>\n\t<li><code>subtext<sub>i</sub> == subtext<sub>k - i + 1</sub></code> for all valid values of <code>i</code> (i.e., <code>1 &lt;= i &lt;= k</code>).</li>\n</ul>\n\n<p>Return the largest possible value of <code>k</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;ghiabcdefhelloadamhelloabcdefghi&quot;\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> We can split the string on &quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;merchant&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We can split the string on &quot;(merchant)&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;antaprezatepzapreanta&quot;\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> We can split the string on &quot;(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a)&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 1000</code></li>\n\t<li><code>text</code> consists only of lowercase English characters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 350560,
                "title": "java-c-python-easy-greedy-with-prove",
                "content": "## **Intuition**\\nHonestly I wrote a DP solution first, to ensure it get accepted.\\nThen I realized greedy solution is right.\\n\\nGive a quick prove here.\\nIf we have long prefix matched and a shorter prefix matched at the same time.\\nThe longer prefix can always be divided in to smaller part.\\n\\n![image](https://assets.leetcode.com/users/lee215/image_1564892108.png)\\n\\nAssume we have a longer blue matched and a shorter red matched.\\nAs definition of the statement, we have `B1 = B2, R1 = R4`.\\n\\nBecause `B1 = B2`,\\nthe end part of `B1` = the end part of `B2`,\\nequal to `R2 = R4`,\\nSo we have `R1 = R4 = R2`.\\n\\n`B` is in a pattern of `R` + middle part + `R`.\\nInstead take a longer `B` with 1 point,\\nwe can cut it in to 3 parts to gain more points.\\n\\nThis proves that greedily take shorter matched it right.\\nNote that the above diagram shows cases when `shorter length <= longer length/ 2`\\nWhen `shorter length > longer length/ 2`, this conclusion is still correct.\\n<br>\\n\\nTo be more general,\\nthe longer prefix and shorter prefix will alway be in these patter:\\n\\n`longer = a + ab * N`\\n`shorter = a + ab * (N - 1)`\\n\\nfor example:\\nlonger = `\"abc\" + \"def\" + \"abc\"`\\nshorter = `\"abc\"`\\n\\nfor example:\\nlonger = `\"abc\" * M`\\nshorter = `\"abc\" * N`\\nwhere `M > N`\\n<br>\\n\\n## **Solution 1, very brute force**\\nWhen we know the greedy solution is right,\\nthe coding is easier.\\nJust take letters from the left and right side,\\nWhenever they match, `res++`.\\n<br>\\n\\n## **Complexity**\\nI just very brute force generate new string and loop the whole string.\\nComplexity can be improve on these two aspects.\\nPardon that I choose the concise over the performance.\\n\\nTime `O(N) * O(string)`\\nSpace `O(N)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int longestDecomposition(String S) {\\n        int res = 0, n = S.length();\\n        String l = \"\", r = \"\";\\n        for (int i = 0; i < n; ++i) {\\n            l = l + S.charAt(i);\\n            r = S.charAt(n - i - 1) + r;\\n            if (l.equals(r)) {\\n                ++res;\\n                l = \"\";\\n                r = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int longestDecomposition(string S) {\\n        int res = 0, n = S.length();\\n        string l = \"\", r = \"\";\\n        for (int i = 0; i < n; ++i) {\\n            l = l + S[i], r = S[n - i - 1] + r;\\n            if (l == r)\\n                ++res, l = \"\", r = \"\";\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def longestDecomposition(self, S):\\n        res, l, r = 0, \"\", \"\"\\n        for i, j in zip(S, S[::-1]):\\n            l, r = l + i, j + r\\n            if l == r:\\n                res, l, r = res + 1, \"\", \"\"\\n        return res\\n```\\n<br>\\n\\n## **Solution 2, Tail Recursion**\\nSame idea, just apply tail recursion.\\nAnd add a quick check before we slice the string.\\n<br>\\n**C++:**\\n```cpp\\n    int longestDecomposition(string S, int res = 0) {\\n        int n = S.length();\\n        for (int l = 1; l <= n / 2; ++l)\\n            if (S[0] == S[n - l] && S[l - 1] == S[n - 1])\\n                if (S.substr(0, l) == S.substr(n - l))\\n                    return longestDecomposition(S.substr(l, n - l - l), res + 2);\\n        return n ? res + 1 : res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def longestDecomposition(self, S, res=0):\\n        n = len(S)\\n        for l in xrange(1, n / 2 + 1):\\n            if S[0] == S[n - l] and S[l - 1] == S[n - 1]:\\n                if S[:l] == S[n - l:]:\\n                    return self.longestDecomposition(S[l:n - l], res + 2)\\n        return res + 1 if S else res\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int longestDecomposition(String S) {\\n        int res = 0, n = S.length();\\n        String l = \"\", r = \"\";\\n        for (int i = 0; i < n; ++i) {\\n            l = l + S.charAt(i);\\n            r = S.charAt(n - i - 1) + r;\\n            if (l.equals(r)) {\\n                ++res;\\n                l = \"\";\\n                r = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int longestDecomposition(string S) {\\n        int res = 0, n = S.length();\\n        string l = \"\", r = \"\";\\n        for (int i = 0; i < n; ++i) {\\n            l = l + S[i], r = S[n - i - 1] + r;\\n            if (l == r)\\n                ++res, l = \"\", r = \"\";\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def longestDecomposition(self, S):\\n        res, l, r = 0, \"\", \"\"\\n        for i, j in zip(S, S[::-1]):\\n            l, r = l + i, j + r\\n            if l == r:\\n                res, l, r = res + 1, \"\", \"\"\\n        return res\\n```\n```cpp\\n    int longestDecomposition(string S, int res = 0) {\\n        int n = S.length();\\n        for (int l = 1; l <= n / 2; ++l)\\n            if (S[0] == S[n - l] && S[l - 1] == S[n - 1])\\n                if (S.substr(0, l) == S.substr(n - l))\\n                    return longestDecomposition(S.substr(l, n - l - l), res + 2);\\n        return n ? res + 1 : res;\\n    }\\n```\n```python\\n    def longestDecomposition(self, S, res=0):\\n        n = len(S)\\n        for l in xrange(1, n / 2 + 1):\\n            if S[0] == S[n - l] and S[l - 1] == S[n - 1]:\\n                if S[:l] == S[n - l:]:\\n                    return self.longestDecomposition(S[l:n - l], res + 2)\\n        return res + 1 if S else res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 350762,
                "title": "java-0ms-concise-beats-100-both-time-and-memory-with-algo",
                "content": "Traverse from 0 to n/2 to find the smallest left side chunk and right side chunk which are equal.\\nOnce you find it(\\uD83E\\uDDD2 \\uD83D\\uDC64.........\\uD83D\\uDC64 \\uD83E\\uDDD2), add 2\\xA0(\\uD83E\\uDDD2\\uD83E\\uDDD2) to solution and then recursively call the function for remaining string(\\uD83D\\uDC64..........\\uD83D\\uDC64 ).\\nTerminating conditions:\\na. Either string will be empty : return 0 \\nb. Or there are no more equal right and left chunks left (just a single lonely chunk \\uD83D\\uDE47\\u200D\\u2642\\uFE0F ): return 1\\n\\n```\\n public int longestDecomposition(String text) {\\n        int n = text.length();   \\n        for (int i = 0; i < n/2; i++) \\n            if (text.substring(0, i + 1).equals(text.substring(n-1-i, n))) \\n                return 2+longestDecomposition(text.substring(i+1, n-1-i));\\n        return (n==0)?0:1;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n public int longestDecomposition(String text) {\\n        int n = text.length();   \\n        for (int i = 0; i < n/2; i++) \\n            if (text.substring(0, i + 1).equals(text.substring(n-1-i, n))) \\n                return 2+longestDecomposition(text.substring(i+1, n-1-i));\\n        return (n==0)?0:1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350711,
                "title": "close-to-o-n-python-rabin-karp-algorithm-with-two-pointer-technique-with-explanation-40ms",
                "content": "[Important edit: I stand corrected. This algorithm isn\\'t actually O(n), technically it\\'s O(n^2). But in practice, it\\'s very close to O(n), and will achieve substantially better performance than the more traditional O(n^2) approaches. In terms of real world performance/ progamming competitions, just pick a good big prime number and it\\'ll scale more like an O(n) algorithm, achieving the ultimate objective of fastness. :-) Thanks to those who pointed out the incorrectness in my analysis!]\\n\\nThe Rabin-Karp algorithm seems perfect for this situation, so it is the approach I took.\\n\\nhttps://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm\\n\\nSee code comments for an explanation of how it works. In essence, we keep track of a hash of the current substring at the start and the end of the string. **After the code I provide a few examples of the math and the ideas in the algorithm.**\\n\\nThis algorithm is **O(n)**, as we are only processing each character once, and we\\'re not doing costly string comparing operations (remember, comparing 2 strings of length n has a cost of O(n), which would bring an algorithm depending on it up to O(n^2)). \\n\\n```py\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        \\n\\t\\t# Used a prime number generator on the internet to grab a prime number to use.\\n        magic_prime = 32416189573\\n        \\n\\t\\t# Standard 2 pointer technique variables.\\n        low = 0\\n        high = len(text) - 1\\n        \\n\\t\\t# These are the hash tracking variables.\\n\\t\\tcur_low_hash = 0\\n        cur_high_hash = 0\\n        cur_hash_length = 0\\n        \\n\\t\\t# This is the number of parts we\\'ve found, i.e. the k value we need to return.\\n\\t\\tk = 0\\n        \\n        while low < high:\\n            \\n\\t\\t\\t# To put the current letter onto our low hash (i.e. the one that goes forward from\\n\\t\\t\\t# the start of the string, we shift up the existing hash by multiplying by the base\\n\\t\\t\\t# of 26, and then adding on the new character by converting it to a number from 0 - 25.\\n            cur_low_hash *= 26 # Shift up by the base of 26.\\n            cur_low_hash += ord(text[low]) - 97 # Take away 97 so that it\\'s between 0 and 25.\\n            \\n\\t\\t\\t\\n\\t\\t\\t# The high one, i.e. the one backwards from the end is a little more complex, as we want the \\n\\t\\t\\t# hash to represent the characters in forward order, not backwards. If we did the exact same\\n\\t\\t\\t# thing we did for low, the string abc would be represented as cba, which is not right.\\t\\n\\t\\t\\t\\n\\t\\t\\t# Start by getting the character\\'s 0 - 25 number.\\n\\t\\t\\thigh_char = ord(text[high]) - 97\\n\\t\\t\\t\\n\\t\\t\\t# The third argument to pow is modular arithmetic. It says to give the answer modulo the\\n\\t\\t\\t# magic prime (more on that below). Just pretend it isn\\'t doing that for now if it confuses you. \\n            # What we\\'re doing is making an int that puts the high character at the top, and then the \\n\\t\\t\\t# existing hash at the bottom.\\n\\t\\t\\tcur_high_hash = (high_char * pow(26, cur_hash_length, magic_prime)) + cur_high_hash            \\n            \\n\\t\\t\\t# Mathematically, we can safely do this. Impressive, huh? I\\'m not going to go into here, but\\n\\t\\t\\t# I recommend studying up on modular arithmetic if you\\'re confused.\\n\\t\\t\\t# The algorithm would be correct without doing this, BUT it\\'d be very slow as the numbers could\\n\\t\\t\\t# become tens of thousands of bits long. The problem with that of course is that comparing the\\n\\t\\t\\t# numbers would no longer be O(1) constant. So we need to keep them small.\\n\\t\\t\\tcur_low_hash %= magic_prime \\n            cur_high_hash %= magic_prime\\n            \\n\\t\\t\\t# And now some standard 2 pointer technique stuff.\\n            low += 1\\n            high -= 1\\n            cur_hash_length += 1\\n            \\n\\t\\t\\t# This piece of code checks if we currently have a match.\\n            # This is actually probabilistic, i.e. it is possible to get false positives.\\n            # For correctness, we should be verifying that this is actually correct.\\n            # We would do this by ensuring the characters in each hash (using\\n\\t\\t\\t# the low, high, and length variables we\\'ve been tracking) are\\n\\t\\t\\t# actually the same. But here I didn\\'t bother as I figured Leetcode\\n\\t\\t\\t# would not have a test case that broke my specific prime.\\n\\t\\t\\tif cur_low_hash == cur_high_hash:\\n                k += 2 # We have just added 2 new strings to k.\\n                # And reset our hashing variables.\\n\\t\\t\\t\\tcur_low_hash = 0\\n                cur_high_hash = 0\\n                cur_hash_length = 0\\n        \\n\\t\\t# At the end, there are a couple of edge cases we need to address....\\n\\t\\t# The first is if there is a middle character left.\\n\\t\\t# The second is a non-paired off string in the middle.\\n        if (cur_hash_length == 0 and low == high) or cur_hash_length > 0:\\n            k += 1\\n        \\n        return k\\n```\\n\\n# Representing a number as an integer.\\nWe can represent a string of lower case letters as a base-26 number. Each letter is assigned a value from 0 to 25, and then each letter is the string is converted into its number and multiplied by a power of the base, based on its position. The numbers are then added together. For example, the string \"cat\":\\nc = 2\\na = 0\\nt = 19\\n\\nnumber_for(\"cat\") => (26 ^ 2) * 2 + (26 ^ 1) * 0 + (26 ^ 0) * 19\\n\\nThis is very much like how numbers are converted from base 2 to base 10.\\n\\n# Keeping track of rolling hashes.\\nThe good thing about representing strings as a number is that it\\'s very easy to add and remove characters from each end of the string, allowing us to maintain a \"rolling hash\" in O(n) time.\\n\\nSo say we have the string \"foxyfox\".\\'\\nf = 5\\no = 14\\nx = 23\\ny = 24\\n\\nThe low hash will build up as follows.\\n\\nFirst letter: f\\nlower_hash = 5\\n\\nSecond letter: o\\nSo we multiply lower_hash by 26 and then add 14 (the number for \"o\").\\n5 * 26 = 130\\n130 + 14 = 144\\nSo we now have lower_hash = 144\\n\\nThird letter: x\\nSo we multply lower_hash by 26 and then add 23 (the number for \"x\").\\n144 * 26 = 3744\\n3744 + 23 = 3767\\nSo now we have lower_hash = 3767\\n\\nAnd at the same time, the high hash is building up.\\n\\nFirst letter: x\\nhigh_hash = 23\\n\\nSecond letter: o\\nBecause we want the o \"above\" the x in the hash, we need to do this a bit differently to before.\\n14 * (26 ** 1) = 364 (\"Slide up\" the new number making room for the old below).\\n364 + 23 = 387 (Add the old hash on)\\nhigh_hash = 387\\n\\nThird letter: f\\n5 * (26 ** 2) = 3380 (Slide up the new number)\\n3380 + 387 = 3767\\n\\nNow you might notice that when we add f->o->x onto the low high, and x->o->f onto the high hash, we end up with the same value: 3767. This is good, because it tells us we have a match. And it could be done in O(n) time.\\n\\n# Throwing modular arithmetic in\\nThere is one problem with this approach though. What if the strings are *massive*. How many bits are there in a 1000 letter string? We are multiplying by 26 for every letter, so that is 26^1000, a very massive number. Comparing 2 numbers of this size is NOT O(1) anymore. \\n\\nIt turns out that we can take it modulo a large prime number at each step of the algorithm. I\\'m not going to go into that here, but I recommend reading up on modular arithmetic if you\\'re confused.\\n# Resolving the potential bug\\nSo there is one potential problem. It\\'s possible for the hashes to be equal even if the strings weren\\'t. This is more likely to happen with a smaller prime number.\\n\\nFor example, if our prime was 7, then that would mean the hash could only ever be 0, 1, 2, 3, 4, 5, or 6. \"a\" would be 0, and so would \"h\", so the algorithm would give a false positive match.\\n\\nWith a much higher prime number, it becomes increasingly less likely. This is how I protected against it in the contest.\\n\\nBut the correct way would be, each time we get a match, to also check the actual strings. As long as we are getting far fewer false positives than true positives, it will still be O(n) overall. A high enough prime will keep the number of false positives low.\\n\\nWith lots of collisons though, it will become O(n^2). Think about what would happen if our prime was 2.\\n\\nThis is a classic hashing collision problem.",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```py\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        \\n\\t\\t# Used a prime number generator on the internet to grab a prime number to use.\\n        magic_prime = 32416189573\\n        \\n\\t\\t# Standard 2 pointer technique variables.\\n        low = 0\\n        high = len(text) - 1\\n        \\n\\t\\t# These are the hash tracking variables.\\n\\t\\tcur_low_hash = 0\\n        cur_high_hash = 0\\n        cur_hash_length = 0\\n        \\n\\t\\t# This is the number of parts we\\'ve found, i.e. the k value we need to return.\\n\\t\\tk = 0\\n        \\n        while low < high:\\n            \\n\\t\\t\\t# To put the current letter onto our low hash (i.e. the one that goes forward from\\n\\t\\t\\t# the start of the string, we shift up the existing hash by multiplying by the base\\n\\t\\t\\t# of 26, and then adding on the new character by converting it to a number from 0 - 25.\\n            cur_low_hash *= 26 # Shift up by the base of 26.\\n            cur_low_hash += ord(text[low]) - 97 # Take away 97 so that it\\'s between 0 and 25.\\n            \\n\\t\\t\\t\\n\\t\\t\\t# The high one, i.e. the one backwards from the end is a little more complex, as we want the \\n\\t\\t\\t# hash to represent the characters in forward order, not backwards. If we did the exact same\\n\\t\\t\\t# thing we did for low, the string abc would be represented as cba, which is not right.\\t\\n\\t\\t\\t\\n\\t\\t\\t# Start by getting the character\\'s 0 - 25 number.\\n\\t\\t\\thigh_char = ord(text[high]) - 97\\n\\t\\t\\t\\n\\t\\t\\t# The third argument to pow is modular arithmetic. It says to give the answer modulo the\\n\\t\\t\\t# magic prime (more on that below). Just pretend it isn\\'t doing that for now if it confuses you. \\n            # What we\\'re doing is making an int that puts the high character at the top, and then the \\n\\t\\t\\t# existing hash at the bottom.\\n\\t\\t\\tcur_high_hash = (high_char * pow(26, cur_hash_length, magic_prime)) + cur_high_hash            \\n            \\n\\t\\t\\t# Mathematically, we can safely do this. Impressive, huh? I\\'m not going to go into here, but\\n\\t\\t\\t# I recommend studying up on modular arithmetic if you\\'re confused.\\n\\t\\t\\t# The algorithm would be correct without doing this, BUT it\\'d be very slow as the numbers could\\n\\t\\t\\t# become tens of thousands of bits long. The problem with that of course is that comparing the\\n\\t\\t\\t# numbers would no longer be O(1) constant. So we need to keep them small.\\n\\t\\t\\tcur_low_hash %= magic_prime \\n            cur_high_hash %= magic_prime\\n            \\n\\t\\t\\t# And now some standard 2 pointer technique stuff.\\n            low += 1\\n            high -= 1\\n            cur_hash_length += 1\\n            \\n\\t\\t\\t# This piece of code checks if we currently have a match.\\n            # This is actually probabilistic, i.e. it is possible to get false positives.\\n            # For correctness, we should be verifying that this is actually correct.\\n            # We would do this by ensuring the characters in each hash (using\\n\\t\\t\\t# the low, high, and length variables we\\'ve been tracking) are\\n\\t\\t\\t# actually the same. But here I didn\\'t bother as I figured Leetcode\\n\\t\\t\\t# would not have a test case that broke my specific prime.\\n\\t\\t\\tif cur_low_hash == cur_high_hash:\\n                k += 2 # We have just added 2 new strings to k.\\n                # And reset our hashing variables.\\n\\t\\t\\t\\tcur_low_hash = 0\\n                cur_high_hash = 0\\n                cur_hash_length = 0\\n        \\n\\t\\t# At the end, there are a couple of edge cases we need to address....\\n\\t\\t# The first is if there is a middle character left.\\n\\t\\t# The second is a non-paired off string in the middle.\\n        if (cur_hash_length == 0 and low == high) or cur_hash_length > 0:\\n            k += 1\\n        \\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350589,
                "title": "python-simple-dp",
                "content": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        self.memo = {}\\n        def dp(i,j):\\n            if i > j:\\n                return 0\\n            if i == j:\\n                return 1\\n            if (i,j) not in self.memo:\\n                k = 0\\n                tmp = 1\\n                while i+k< j-k:\\n                    if text[i:i+k+1] == text[j-k:j+1]:\\n                        tmp = max(tmp,2+dp(i+k+1,j-k-1))\\n                    k += 1\\n                self.memo[(i,j)] = tmp\\n            return self.memo[(i,j)]\\n        return dp(0,len(text)-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        self.memo = {}\\n        def dp(i,j):\\n            if i > j:\\n                return 0\\n            if i == j:\\n                return 1\\n            if (i,j) not in self.memo:\\n                k = 0\\n                tmp = 1\\n                while i+k< j-k:\\n                    if text[i:i+k+1] == text[j-k:j+1]:\\n                        tmp = max(tmp,2+dp(i+k+1,j-k-1))\\n                    k += 1\\n                self.memo[(i,j)] = tmp\\n            return self.memo[(i,j)]\\n        return dp(0,len(text)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408184,
                "title": "java-rolling-hash-solution",
                "content": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int count = 0;\\n        int i = 0, j = text.length() - 1;\\n        long h1 = 0, h2 = 0;\\n        long base1 = 26, base2 = 1;\\n        \\n        while (i <= j) {\\n            char c1 = text.charAt(i), c2 = text.charAt(j);\\n            h1 = h1 * base1 + (c1 - \\'a\\' + 1);\\n            h2 = h2 + (c2 - \\'a\\' + 1) * base2;\\n            base2 *= base1;\\n            if (h1 == h2) {\\n                if (i == j) count += 1;\\n                else count += 2;\\n                h1 = 0;\\n                h2 = 0;\\n                base2 = 1;\\n            }\\n            i++;\\n            j--;\\n        }\\n        if (h1 != 0) count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int count = 0;\\n        int i = 0, j = text.length() - 1;\\n        long h1 = 0, h2 = 0;\\n        long base1 = 26, base2 = 1;\\n        \\n        while (i <= j) {\\n            char c1 = text.charAt(i), c2 = text.charAt(j);\\n            h1 = h1 * base1 + (c1 - \\'a\\' + 1);\\n            h2 = h2 + (c2 - \\'a\\' + 1) * base2;\\n            base2 *= base1;\\n            if (h1 == h2) {\\n                if (i == j) count += 1;\\n                else count += 2;\\n                h1 = 0;\\n                h2 = 0;\\n                base2 = 1;\\n            }\\n            i++;\\n            j--;\\n        }\\n        if (h1 != 0) count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003924,
                "title": "c-o-n-with-queue-and-stack-0ms-beats-100",
                "content": "```\\nint longestDecomposition(string text) {\\n        int res = 0;\\n        int l = 0, r = text.length() - 1;\\n        stack<int> s;\\n        queue<int> q;\\n        while (l < r) {\\n            s.push(text[l++]);\\n            q.push(text[r--]);\\n            while (!s.empty() && s.top() == q.front()) {\\n                q.pop();\\n                s.pop();\\n            }\\n            if (s.empty())\\n                res += l <= r ? 2 : 1;\\n        }\\n        return res + 1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nint longestDecomposition(string text) {\\n        int res = 0;\\n        int l = 0, r = text.length() - 1;\\n        stack<int> s;\\n        queue<int> q;\\n        while (l < r) {\\n            s.push(text[l++]);\\n            q.push(text[r--]);\\n            while (!s.empty() && s.top() == q.front()) {\\n                q.pop();\\n                s.pop();\\n            }\\n            if (s.empty())\\n                res += l <= r ? 2 : 1;\\n        }\\n        return res + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2913599,
                "title": "easy-two-pointer-0-ms-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe shall greedily form the smallest substrings that are equal on both sides.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use two pointer approach and maintain two strings(A & B) to keep track. The moment they become equal, we count it as one partition and increment out answer by 1.\\n\\n\\nNow there can be two cases possible. We can either have our whole string partitioned into either side like (S1)(S2)(S2)(S1) or a string may exist in middle i.e. S gets partitioned  in the form (S1)(S2)(S3)(S2)(S1)\\n\\nTo check for that, we just need to see if before two pointer loop\\nended, whether we had string A as empty or not. If it was non-empty, we can be sure that a string exists in the middle. However even in case of non-empty string, the loop might have ended at i=j (i<j was used instead of i<=j in order to avoid counting abcba as (abc)(cba)).\\n\\nFeel free to clarify any doubts, I would be happy to help.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n), where n=length of string; We only need to traverse the whole string once, and perform appened operation using assignment operator(which is also O(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), where n=length of string; Since we will be storing complete string in two halves in the worst case.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        string a,b;\\n        int i=0,j=text.size()-1,ans=0;\\n\\n        while(i<j)\\n        {\\n            //Appending characters from start and end\\n            a+=text[i];\\n            b=text[j]+b;\\n\\n            if(a==b)\\n            {\\n                ans++;\\n                a=\"\";\\n                b=\"\";\\n            }\\n            i++;\\n            j--;\\n        }\\n\\n        //We incremented answer by 1, but actually got two strings; so multiply answer by 2.\\n        ans*=2;\\n\\n        //If no string exists in middle, we can directly return answer.\\n        if(a==\"\" and i>j)\\n            return ans;\\n        //Account for the string in the middle\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        string a,b;\\n        int i=0,j=text.size()-1,ans=0;\\n\\n        while(i<j)\\n        {\\n            //Appending characters from start and end\\n            a+=text[i];\\n            b=text[j]+b;\\n\\n            if(a==b)\\n            {\\n                ans++;\\n                a=\"\";\\n                b=\"\";\\n            }\\n            i++;\\n            j--;\\n        }\\n\\n        //We incremented answer by 1, but actually got two strings; so multiply answer by 2.\\n        ans*=2;\\n\\n        //If no string exists in middle, we can directly return answer.\\n        if(a==\"\" and i>j)\\n            return ans;\\n        //Account for the string in the middle\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 547826,
                "title": "c-solution-rolling-hash-with-comments",
                "content": "```\\nclass Solution {\\n    const int Mod = int(1e9) + 123; // prime mod of polynomial hashing\\n    const int Base = 26;\\n    \\n    int helper(const string& s, int l, int r) {\\n        if (l >= r)\\n            return 0;\\n        // use rolling/polynomial hashes for prefix and suffix substrings\\n        long long prefix_hash = 0;\\n        long long suffix_hash = 0;\\n        long long pow = 1;\\n        for (int i = 0; i < (r - l) / 2; ++i) {\\n            // update hashes with the next letter\\n            prefix_hash = (prefix_hash + (s[l + i] - \\'a\\') * pow) % Mod;\\n            suffix_hash = (suffix_hash * Base + (s[r - i - 1] - \\'a\\')) % Mod;\\n            pow = (pow * Base) % Mod;\\n            // perform the expensive string check only for the equal hashes\\n            if (prefix_hash == suffix_hash) {\\n                if (s.substr(l, i + 1) == s.substr(r - i - 1, i + 1)) {\\n                    return 2 + helper(s, l + i + 1, r - i - 1);   \\n                }\\n            }\\n        }\\n        // there is no equal chunks\\n        return 1;\\n    }\\npublic:\\n    int longestDecomposition(string text) {\\n        return helper(text, 0, text.size());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const int Mod = int(1e9) + 123; // prime mod of polynomial hashing\\n    const int Base = 26;\\n    \\n    int helper(const string& s, int l, int r) {\\n        if (l >= r)\\n            return 0;\\n        // use rolling/polynomial hashes for prefix and suffix substrings\\n        long long prefix_hash = 0;\\n        long long suffix_hash = 0;\\n        long long pow = 1;\\n        for (int i = 0; i < (r - l) / 2; ++i) {\\n            // update hashes with the next letter\\n            prefix_hash = (prefix_hash + (s[l + i] - \\'a\\') * pow) % Mod;\\n            suffix_hash = (suffix_hash * Base + (s[r - i - 1] - \\'a\\')) % Mod;\\n            pow = (pow * Base) % Mod;\\n            // perform the expensive string check only for the equal hashes\\n            if (prefix_hash == suffix_hash) {\\n                if (s.substr(l, i + 1) == s.substr(r - i - 1, i + 1)) {\\n                    return 2 + helper(s, l + i + 1, r - i - 1);   \\n                }\\n            }\\n        }\\n        // there is no equal chunks\\n        return 1;\\n    }\\npublic:\\n    int longestDecomposition(string text) {\\n        return helper(text, 0, text.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593030,
                "title": "python-2-pointers-approach-o-n-t-o-1-s-explained-with-comments",
                "content": "```\\n    def longestDecomposition(self, text: str) -> int:\\n        i = count = 0\\n        j = len(text) - 1\\n        stop = len(text)\\n        \\n        while j >= i:\\n            # Keep decrementing j until we find a letter equal to text[i]\\n            while (j > i) and (text[j] != text[i]):\\n                j -= 1\\n                \\n            # If i becomes equal to j, we know that there is only one substring that we can add\\n            # We add that to the count and decrement j to break the loop\\n            if i == j:\\n                count += 1\\n                j -= 1\\n            \\n            else:\\n                # We keep the temp variables for the case where text[i] != text[j]; we will be able to reset the values of i and j using them\\n                temp_i = i\\n                temp_j = j\\n                # stop keeps track of the beginning of the previous substring\\n                while j < stop:\\n                    if text[i] == text[j]:\\n                        i += 1\\n                        j += 1\\n                    else:\\n                        i = temp_i\\n                        j = temp_j - 1\\n                        break\\n                        \\n                # This part is executed only if all the cases of text[i] == text[j] were true\\n                else:\\n                    count += 2\\n                    stop -= (i - temp_i)\\n                    j = stop - 1\\n                    \\n        return count\\n```\\nPlease upvote if you liked the solution :)",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n    def longestDecomposition(self, text: str) -> int:\\n        i = count = 0\\n        j = len(text) - 1\\n        stop = len(text)\\n        \\n        while j >= i:\\n            # Keep decrementing j until we find a letter equal to text[i]\\n            while (j > i) and (text[j] != text[i]):\\n                j -= 1\\n                \\n            # If i becomes equal to j, we know that there is only one substring that we can add\\n            # We add that to the count and decrement j to break the loop\\n            if i == j:\\n                count += 1\\n                j -= 1\\n            \\n            else:\\n                # We keep the temp variables for the case where text[i] != text[j]; we will be able to reset the values of i and j using them\\n                temp_i = i\\n                temp_j = j\\n                # stop keeps track of the beginning of the previous substring\\n                while j < stop:\\n                    if text[i] == text[j]:\\n                        i += 1\\n                        j += 1\\n                    else:\\n                        i = temp_i\\n                        j = temp_j - 1\\n                        break\\n                        \\n                # This part is executed only if all the cases of text[i] == text[j] were true\\n                else:\\n                    count += 2\\n                    stop -= (i - temp_i)\\n                    j = stop - 1\\n                    \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 350625,
                "title": "java-4-line-solution-1-ms-100",
                "content": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        for(int i = 1; i<=text.length()/2; i++)\\n            if(text.substring(0, i).equals(text.substring(text.length()-i, text.length())))\\n                return 2 + longestDecomposition(text.substring(i, text.length()-i));\\n        return text.length() == 0 ? 0 : 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        for(int i = 1; i<=text.length()/2; i++)\\n            if(text.substring(0, i).equals(text.substring(text.length()-i, text.length())))\\n                return 2 + longestDecomposition(text.substring(i, text.length()-i));\\n        return text.length() == 0 ? 0 : 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359555,
                "title": "no-code-proof-of-correctness-for-greedy-break-off-shortest-prefix-suffix-continue-approach",
                "content": "(I hope this proof might help some people understand the greedy strategy)\\n\\nLet s be the shortest nontrivial word which is both a prefix and suffix of *text*.\\nSuppose there is a longer word which is also a prefix and suffix of *text*: it is, like s, a prefix of *text*, so we can write this longer word as a concatenation, st, where t is a nontrivial word. So\\n```\\ntext = sWs = stVst\\n```\\nwhere W, V are the remaining \"middles\".\\n\\n **Claim**: longestDecomposition(W)>=longestDecomposition(V). Note this would justify the use of a greedy algorithm. \\n **Proof:** We consider two cases:\\n Case (i) If len(t)>=len(s), then s must be a suffix of t, since (as in the equation above) *text* ends with s and also ends with t. This means that t can be written t = es for some (posisbly empty) word e.\\n Then sWs = stVst = sesVses, hence W = esVse. So W has at least 2 more chunks V if e is empty, and at least 4 more chunks than V if e is nonempty. Done with case (i).\\n\\nCase (ii) If len(t)<len(s), then again, looking at the equation above, t must be a suffix of s, since *text* ends with t and also ends with s. Write s = s[1]s[2]...s[k] and t = s[i]s[i+1]...s[k] where i>1. Then just expanding the equation above, we get\\n```\\nsWs[1]...s[k] = stVs[1]...s[k]s[i]...s[k]\\n```\\nBut if you cancel k-i+1 letters from the end of each side, you see s[1]...s[i-1] = s[k-(i-1)]...s[k]. This is all to say that there is a proper prefix of s which is also a suffix, contradicting that s is the *shortest* word which is both a prefix and suffix of *text*:  the word s\\'=s[1]...s[i-1] would be shorter.",
                "solutionTags": [],
                "code": "```\\ntext = sWs = stVst\\n```\n```\\nsWs[1]...s[k] = stVs[1]...s[k]s[i]...s[k]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 351919,
                "title": "java-dp-solution-straight-forward-with-explanation",
                "content": "The greedy solution requires you to be able to prove by contradiction. Here is the dp solution. ```dp[i]``` here represents the max number of palin-decompositions that ```s[0:i] + s[len-i:len]``` can form, not counting the strings between [i+1:len-i-1]. Here\\'s the code\\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int N = text.length();\\n\\t\\t// instantiate dp array 1 longer than half the text, since we need dp[0] = 0 for base case, every i is stored with \"+1\" offset\\n        int[] dp = new int[N/2+1];\\n        int max = 0;\\n        for (int j=0; j<N/2; j++) {\\n            for (int i=0; i<=j; i++) {\\n\\t\\t\\t\\t// s[i:j] (inclusive both ends) has a matching palindrome\\n\\t\\t\\t\\t// and we need to make sure that i covers the entire string or it has matching pairs to its left\\n                if (text.substring(i, j+1).equals(text.substring(N-1-j, N-i)) && (i==0 || dp[i]!=0)) {\\n                    dp[j+1] = Math.max(dp[j+1], dp[i]+2);\\n                    max = Math.max(max, dp[i]+2);\\n                }\\n            }\\n        }\\n\\t\\t// I feel like this part is not as straight-forward and took me a while\\n\\t\\t// if string is even length and has dp[n/2] != 0 then we just want to return that, otherwise, we need to add 1 to the max(dp) (odd length string always has one unmatched segment in the middle)\\n        return ((N % 2 == 0) && dp[N/2] != 0) ? dp[N/2] : max+1;\\n    }\\n}\\n```\\n\\n*Time: O(n^2)  O(substring_match) = O(n^3) <- correct me if I\\'m wrong here\\nSpace: O(n)*\\n\\nHope you enjoyed that!",
                "solutionTags": [],
                "code": "```dp[i]```\n```s[0:i] + s[len-i:len]```\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int N = text.length();\\n\\t\\t// instantiate dp array 1 longer than half the text, since we need dp[0] = 0 for base case, every i is stored with \"+1\" offset\\n        int[] dp = new int[N/2+1];\\n        int max = 0;\\n        for (int j=0; j<N/2; j++) {\\n            for (int i=0; i<=j; i++) {\\n\\t\\t\\t\\t// s[i:j] (inclusive both ends) has a matching palindrome\\n\\t\\t\\t\\t// and we need to make sure that i covers the entire string or it has matching pairs to its left\\n                if (text.substring(i, j+1).equals(text.substring(N-1-j, N-i)) && (i==0 || dp[i]!=0)) {\\n                    dp[j+1] = Math.max(dp[j+1], dp[i]+2);\\n                    max = Math.max(max, dp[i]+2);\\n                }\\n            }\\n        }\\n\\t\\t// I feel like this part is not as straight-forward and took me a while\\n\\t\\t// if string is even length and has dp[n/2] != 0 then we just want to return that, otherwise, we need to add 1 to the max(dp) (odd length string always has one unmatched segment in the middle)\\n        return ((N % 2 == 0) && dp[N/2] != 0) ? dp[N/2] : max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534801,
                "title": "cpp-two-pointer-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int ans=0,i=0,j=text.size()-1;\\n        string s=\"\",t=\"\";\\n        \\n        while(i<j){\\n            s+=text[i];\\n            t+=text[j];\\n            string rev=t;\\n            reverse(rev.begin(),rev.end());\\n            \\n            if(s==rev){\\n                ans++;\\n                t=\"\";\\n                s=\"\";\\n            }\\n            \\n            i++;\\n            j--;\\n        }\\n        ans*=2;\\n        \\n        if(i==j || s.size()!=0)ans++;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int ans=0,i=0,j=text.size()-1;\\n        string s=\"\",t=\"\";\\n        \\n        while(i<j){\\n            s+=text[i];\\n            t+=text[j];\\n            string rev=t;\\n            reverse(rev.begin(),rev.end());\\n            \\n            if(s==rev){\\n                ans++;\\n                t=\"\";\\n                s=\"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 358105,
                "title": "java-easy-sol-palindrome-check-1ms",
                "content": "```\\n public int longestDecomposition(String text) {\\n        int n = text.length();\\n        int chunkCount = 0;\\n        int start=0;\\n        int end = n;\\n        int i=0,j=n-1;\\n        while(i<j) {\\n            String left = text.substring(start,i+1);\\n            String right = text.substring(j,end);\\n            if(left.equals(right)) {\\n                chunkCount+=2;\\n                start=i+1;\\n                end = j;\\n            }\\n            i++;j--;\\n        }\\n        if(start<end) {\\n            chunkCount++;\\n        }\\n        return chunkCount;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int longestDecomposition(String text) {\\n        int n = text.length();\\n        int chunkCount = 0;\\n        int start=0;\\n        int end = n;\\n        int i=0,j=n-1;\\n        while(i<j) {\\n            String left = text.substring(start,i+1);\\n            String right = text.substring(j,end);\\n            if(left.equals(right)) {\\n                chunkCount+=2;\\n                start=i+1;\\n                end = j;\\n            }\\n            i++;j--;\\n        }\\n        if(start<end) {\\n            chunkCount++;\\n        }\\n        return chunkCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 351174,
                "title": "java-real-space-o-1-iterative-greedy-solution-w-explanation-and-analysis",
                "content": "**Method 1: Iterative code**\\n\\nRead lots of java version without finding `O(1)` space solution. Some of them use `substring()`, which could cost `O(n / 2)` each, and some use recursion in addition, which cost more space due to recursion stack.\\n\\nHere is real space `O(1)` solution, idea is similar to the top voted:\\n1. Try to match the `substring(out[0], in[0])` and `substring(in[1], out[1])`; \\n2. If succeed, increase the `counter` by `2`, then continue to operate on the remaining parts; otherwise, expand by `1` the size of both substrings;\\n3. Repeat 2 till the 2 substrings meet.\\n\\n```\\n    public int longestDecomposition(String text) {\\n        int out[] = { 0, text.length() }, in[] = out.clone(), counter = 0;\\n        label:\\n        while (++in[0] <= --in[1]) {\\n            for (int i = out[0], j = in[1]; i < in[0]; ++i, ++j)\\n                if (text.charAt(i) != text.charAt(j))\\n                    continue label;\\n            counter += 2;\\n            out = in.clone();\\n        }\\n        return counter + (out[1] > out[0] ? 1 : 0);\\n    }\\n```\\n**Analysis:**\\n\\nTime: O(n ^ 2), space: O(1).\\n\\n----\\n**Method 2: Recursive code**:\\n\\n```\\n    public int longestDecomposition(String text) {\\n        return longestDecomposition(text, 0, text.length());\\n    }\\n    private int longestDecomposition(String text, int lo, int hi) {\\n        label:\\n        for (int len = 1; len <= (hi - lo) / 2; ++len) {\\n            for (int i = lo, j = hi - len; i < lo + len; ++i, ++j)\\n                if (text.charAt(i) != text.charAt(j))\\n                        continue label;\\n            return 2 + longestDecomposition(text, lo + len, hi - len);\\n        }\\n        return hi - lo < 2 ? hi - lo : 1;\\n    }\\n```\\n**Analysis:**\\n\\nTime: O(n ^ 2), space: O(n).\\n\\n",
                "solutionTags": [],
                "code": "```\\n    public int longestDecomposition(String text) {\\n        int out[] = { 0, text.length() }, in[] = out.clone(), counter = 0;\\n        label:\\n        while (++in[0] <= --in[1]) {\\n            for (int i = out[0], j = in[1]; i < in[0]; ++i, ++j)\\n                if (text.charAt(i) != text.charAt(j))\\n                    continue label;\\n            counter += 2;\\n            out = in.clone();\\n        }\\n        return counter + (out[1] > out[0] ? 1 : 0);\\n    }\\n```\n```\\n    public int longestDecomposition(String text) {\\n        return longestDecomposition(text, 0, text.length());\\n    }\\n    private int longestDecomposition(String text, int lo, int hi) {\\n        label:\\n        for (int len = 1; len <= (hi - lo) / 2; ++len) {\\n            for (int i = lo, j = hi - len; i < lo + len; ++i, ++j)\\n                if (text.charAt(i) != text.charAt(j))\\n                        continue label;\\n            return 2 + longestDecomposition(text, lo + len, hi - len);\\n        }\\n        return hi - lo < 2 ? hi - lo : 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3089276,
                "title": "easy-python-solution-two-pointers",
                "content": "# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        left = 0\\n        right = len(text)-1\\n        temp1 = \"\"\\n        temp2 = \"\"\\n        count = 0\\n        while left < right:\\n            temp1 += text[left]\\n            temp2 += text[right]\\n            if temp1 == temp2[::-1]:\\n                count += 2\\n                temp1 = \"\"\\n                temp2 = \"\"\\n                left += 1\\n                right -= 1\\n            else:\\n                left += 1\\n                right -= 1\\n        if left == right and len(temp1) == 0:\\n            count += 1\\n        if len(temp1) != 0:\\n            count += 1\\n        return count\\n```\\nDo upvote if you like the solution :)",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        left = 0\\n        right = len(text)-1\\n        temp1 = \"\"\\n        temp2 = \"\"\\n        count = 0\\n        while left < right:\\n            temp1 += text[left]\\n            temp2 += text[right]\\n            if temp1 == temp2[::-1]:\\n                count += 2\\n                temp1 = \"\"\\n                temp2 = \"\"\\n                left += 1\\n                right -= 1\\n            else:\\n                left += 1\\n                right -= 1\\n        if left == right and len(temp1) == 0:\\n            count += 1\\n        if len(temp1) != 0:\\n            count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416709,
                "title": "java-two-pointers",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        String l=\"\",r=\"\";\\n        int c=0;\\n        for(int i=0;i<text.length();i++){\\n            l=l+text.charAt(i);\\n            r=text.charAt(text.length()-i-1)+r;\\n            if(l.equals(r)){\\n                c++;\\n                l=\"\";\\n                r=\"\";\\n            }\\n        }\\n        return c;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int longestDecomposition(String text) {\\n        String l=\"\",r=\"\";\\n        int c=0;\\n        for(int i=0;i<text.length();i++){\\n            l=l+text.charAt(i);\\n            r=text.charAt(text.length()-i-1)+r;\\n            if(l.equals(r)){\\n                c++;\\n                l=\"\";\\n                r=\"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1925238,
                "title": "c-simple-approach-greedy",
                "content": "We are saving the indexes of of every letter\\'s occurrence from rear and with respect to that letter, checking if the word being formed by it matches our word from the beginning word or not. If not we will look for another index with that letter.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        vector<int> index[26]; //array to store indices of occurrence of each letter\\n        int count = 0;\\n        for(int i = text.size()-1; i >= 0; i--){\\n            index[text[i] - \\'a\\'].push_back(i); //taking the indices in\\n        }\\n        int i = 0;\\n        int n = text.size();\\n        int j = n;\\n        while(i < j){\\n            int temp = text[i] - \\'a\\'; //finding index of the current letter\\n            int track = i;\\n            for(auto x: index[temp]){\\n                if(x >= j) continue; //if the index we are looking for has already been counted in another tree\\n                int sz = j-x; //size of the word \\n                if(i + sz > x) break; // if the words are overlapping\\n                if(text.substr(i, sz) == text.substr(x, sz)){\\n                count+=2; //increasing count if the words are same\\n                j = x;\\n                i+=sz;\\n                break;\\n                }  \\n            }\\n            if(track == i) return count+=1; // taking the last reamaining word as whoel\\n        }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        vector<int> index[26]; //array to store indices of occurrence of each letter\\n        int count = 0;\\n        for(int i = text.size()-1; i >= 0; i--){\\n            index[text[i] - \\'a\\'].push_back(i); //taking the indices in\\n        }\\n        int i = 0;\\n        int n = text.size();\\n        int j = n;\\n        while(i < j){\\n            int temp = text[i] - \\'a\\'; //finding index of the current letter\\n            int track = i;\\n            for(auto x: index[temp]){\\n                if(x >= j) continue; //if the index we are looking for has already been counted in another tree\\n                int sz = j-x; //size of the word \\n                if(i + sz > x) break; // if the words are overlapping\\n                if(text.substr(i, sz) == text.substr(x, sz)){\\n                count+=2; //increasing count if the words are same\\n                j = x;\\n                i+=sz;\\n                break;\\n                }  \\n            }\\n            if(track == i) return count+=1; // taking the last reamaining word as whoel\\n        }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873970,
                "title": "cpp-0ms-faster-then-100",
                "content": "class Solution {\\npublic:\\n    \\n    int longestDecomposition(string s)\\n    {\\n        map<string,int> mp;\\n        int n=s.size();\\n        int i=0,j=n-1;\\n        int l=0,r=n-1;\\n        string ls,rs;\\n        int ans=0;\\n        while(i<j)\\n        {\\n            ls=s.substr(l,i-l+1);\\n            rs=s.substr(j,r-j+1);\\n            if(ls==rs)\\n            {\\n                mp[ls]++;\\n                l=i+1;\\n                r=j-1;\\n                \\n                ans+=2;\\n            }\\n            \\n            i++;\\n            j--;\\n        }\\n        \\n        if(mp.size()==0) //\"merchant\"\\n            return 1;\\n        if(l>r)   // (ghi)(abcdef)(hello)(adam)(adam)(hello)(abcdef)(ghi)\".\\n            return ans;\\n        return ans+1; //(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)\".\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int longestDecomposition(string s)\\n    {\\n        map<string,int> mp;\\n        int n=s.size();\\n        int i=0,j=n-1;\\n        int l=0,r=n-1;\\n        string ls,rs;\\n        int ans=0;\\n        while(i<j)\\n        {\\n            ls=s.substr(l,i-l+1);\\n            rs=s.substr(j,r-j+1);\\n            if(ls==rs)\\n            {\\n                mp[ls]++;\\n                l=i+1;\\n                r=j-1;\\n                \\n                ans+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 353581,
                "title": "intuitive-python-less-than-10-lines-greedy",
                "content": "```\\nclass Solution(object):\\n    def longestDecomposition(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        def helper(s):\\n            if not s:\\n                return 0\\n            for i in range(0,len(s)//2):\\n                if s[:i+1]==s[~i:]:\\n                    return 2+helper(s[i+1:~i])\\n            return 1\\n                \\n        return helper(text)\\n\\n\\n\\n```\\nSolution is greedy. Least Possible answer is 1 if it is a valid string else 0\\nGreedily compare k characters from starting and end. If it matches call it recursively to get the results for the newer substring.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestDecomposition(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        def helper(s):\\n            if not s:\\n                return 0\\n            for i in range(0,len(s)//2):\\n                if s[:i+1]==s[~i:]:\\n                    return 2+helper(s[i+1:~i])\\n            return 1\\n                \\n        return helper(text)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350691,
                "title": "easy-four-pointers-solutions",
                "content": "```\\n    public int longestDecomposition(String text) {\\n        //four pointers;\\n        if(text == null || text.length() == 0) return 0;\\n        int left = 0, right = text.length();\\n        int low = left + 1, high = right - 1;\\n        int count = 0;\\n        while(low <= high) {\\n            String sl = text.substring(left, low);\\n            String sr = text.substring(high, right);\\n            if(sl.equals(sr)) {\\n                count += 2;\\n                left = low;\\n                right = high;\\n            } \\n            low++;\\n            high--;\\n        }\\n        if(left < right) {\\n            count += 1;\\n        }\\n        //System.out.print(left + \" \" + right);\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestDecomposition(String text) {\\n        //four pointers;\\n        if(text == null || text.length() == 0) return 0;\\n        int left = 0, right = text.length();\\n        int low = left + 1, high = right - 1;\\n        int count = 0;\\n        while(low <= high) {\\n            String sl = text.substring(left, low);\\n            String sr = text.substring(high, right);\\n            if(sl.equals(sr)) {\\n                count += 2;\\n                left = low;\\n                right = high;\\n            } \\n            low++;\\n            high--;\\n        }\\n        if(left < right) {\\n            count += 1;\\n        }\\n        //System.out.print(left + \" \" + right);\\n        return count;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 350549,
                "title": "python-beats-100-two-pointer-approach",
                "content": "keep comparing first k and last k characters and remove both from the main string.\\nonly stop when:\\n1. len(text)<2, the if condition.\\n2. text remains same after one pass.\\n```\\nclass Solution(object):\\n    def longestDecomposition(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n    \\n        count = 0\\n        done = False\\n        while not done:\\n\\n            l,r = 0, len(text)-1\\n            if len(text) <2 :\\n                done = True\\n\\n            while(l<r):\\n                if text[0:l+1] == text[r:len(text)]:\\n                    text = text[l+1:r]\\n                    count+=1\\n                    done = False\\n                    break\\n\\n                done = True\\n                l +=1\\n                r-=1\\n\\n        return 2*count+1 if len(text) else 2*count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestDecomposition(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n    \\n        count = 0\\n        done = False\\n        while not done:\\n\\n            l,r = 0, len(text)-1\\n            if len(text) <2 :\\n                done = True\\n\\n            while(l<r):\\n                if text[0:l+1] == text[r:len(text)]:\\n                    text = text[l+1:r]\\n                    count+=1\\n                    done = False\\n                    break\\n\\n                done = True\\n                l +=1\\n                r-=1\\n\\n        return 2*count+1 if len(text) else 2*count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599546,
                "title": "c-2-pointer-approach-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int s=0,e=text.size()-1;\\n        int first_found=0,last_found=text.size()-1;\\n        int cnt=0;\\n        while(s<e){\\n            string a=text.substr(first_found,s-first_found+1);\\n            string b=text.substr(e,last_found-e+1);\\n            s++;\\n            e--;\\n            if(a==b){\\n                cnt+=2;\\n                first_found=s;\\n                last_found=e;\\n            }   \\n        }\\n        if(first_found<=last_found){\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int s=0,e=text.size()-1;\\n        int first_found=0,last_found=text.size()-1;\\n        int cnt=0;\\n        while(s<e){\\n            string a=text.substr(first_found,s-first_found+1);\\n            string b=text.substr(e,last_found-e+1);\\n            s++;\\n            e--;\\n            if(a==b){\\n                cnt+=2;\\n                first_found=s;\\n                last_found=e;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2266702,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s) {\\n        int n=s.size(),i=0,j=n-1,ans=0;\\n        string a=\"\";\\n        while(i<j){\\n            a+=s[i];\\n            if(s[i]==s[j]){\\n                int len=a.size();\\n                if(a==s.substr(j-len+1,len)){\\n                    ans+=2;j=j-len;\\n                    a=\"\";\\n                }\\n            }i++;            \\n        }\\n        if(i==j) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s) {\\n        int n=s.size(),i=0,j=n-1,ans=0;\\n        string a=\"\";\\n        while(i<j){\\n            a+=s[i];\\n            if(s[i]==s[j]){\\n                int len=a.size();\\n                if(a==s.substr(j-len+1,len)){\\n                    ans+=2;j=j-len;\\n                    a=\"\";\\n                }\\n            }i++;            \\n        }\\n        if(i==j) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641222,
                "title": "c-rolling-hash-two-pointer-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long mod = 1e9 + 7;\\n    \\n    long long power(long long a, long long b) {\\n        long long res = 1;\\n        while(b) {\\n            if(b%2) res = (res%mod * a%mod)%mod , b-=1;\\n            b/=2;\\n            a = ((a%mod) * (a%mod))%mod;\\n        }\\n        \\n        return res%mod;\\n    }\\n        \\n  \\n    // precalculate hash of each prefix\\n    void generateHashes(string &text, vector<long long> &hash, vector<long long> &invModulo) {\\n        long long p = 31;\\n        long long p_power = 1;\\n        invModulo[0] = 1;\\n        hash[0] = (text[0] - \\'a\\' + 1);\\n        \\n        for(int i=1; i < text.length(); i++) {\\n            char ch = text[i];\\n            p_power = (p_power%mod * p%mod)%mod;\\n            invModulo[i] = power(p_power, mod-2); // fermet\\'s little theorem for calculating inverse modulo\\n            hash[i] = (hash[i-1]%mod + ((ch - \\'a\\' + 1) * p_power%mod)%mod)%mod;\\n        }\\n        \\n    }\\n    \\n    // return hash of each substring in O(1)\\n    long long substringHash(int left, int right, vector<long long> &hash, vector<long long> &invModulo) {\\n        long long res = hash[right]%mod;\\n        if(left > 0) res = (res%mod -  hash[left - 1]%mod)%mod;\\n        \\n        return (mod + (res%mod * invModulo[left]%mod))%mod;\\n    }\\n    \\n    \\n    int longestDecomposition(string text) {\\n        int n = text.length();\\n        vector<long long> hash(n), invModulo(n);\\n        \\n        generateHashes(text, hash, invModulo);\\n        \\n        int start = 0, left = 0, right = n-1, end = n-1;\\n        int ans = 0;\\n        \\n        while(left < right) {\\n            \\n            // we found one substring matching so split from this point (we have to get the max number of times we can split the string (largest Possible value of k))\\n            if(substringHash(start, left, hash, invModulo) == substringHash(right, end, hash, invModulo)) {\\n                ans += 2; // because 2 parts are being created.\\n                \\n                start = left+1;\\n                end = right-1;\\n            } \\n            \\n            left += 1;\\n            right -= 1;\\n\\n            \\n        }\\n        \\n        if(start <= end) ans += 1; // if one of the substring is still remaining.\\n         \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long mod = 1e9 + 7;\\n    \\n    long long power(long long a, long long b) {\\n        long long res = 1;\\n        while(b) {\\n            if(b%2) res = (res%mod * a%mod)%mod , b-=1;\\n            b/=2;\\n            a = ((a%mod) * (a%mod))%mod;\\n        }\\n        \\n        return res%mod;\\n    }\\n        \\n  \\n    // precalculate hash of each prefix\\n    void generateHashes(string &text, vector<long long> &hash, vector<long long> &invModulo) {\\n        long long p = 31;\\n        long long p_power = 1;\\n        invModulo[0] = 1;\\n        hash[0] = (text[0] - \\'a\\' + 1);\\n        \\n        for(int i=1; i < text.length(); i++) {\\n            char ch = text[i];\\n            p_power = (p_power%mod * p%mod)%mod;\\n            invModulo[i] = power(p_power, mod-2); // fermet\\'s little theorem for calculating inverse modulo\\n            hash[i] = (hash[i-1]%mod + ((ch - \\'a\\' + 1) * p_power%mod)%mod)%mod;\\n        }\\n        \\n    }\\n    \\n    // return hash of each substring in O(1)\\n    long long substringHash(int left, int right, vector<long long> &hash, vector<long long> &invModulo) {\\n        long long res = hash[right]%mod;\\n        if(left > 0) res = (res%mod -  hash[left - 1]%mod)%mod;\\n        \\n        return (mod + (res%mod * invModulo[left]%mod))%mod;\\n    }\\n    \\n    \\n    int longestDecomposition(string text) {\\n        int n = text.length();\\n        vector<long long> hash(n), invModulo(n);\\n        \\n        generateHashes(text, hash, invModulo);\\n        \\n        int start = 0, left = 0, right = n-1, end = n-1;\\n        int ans = 0;\\n        \\n        while(left < right) {\\n            \\n            // we found one substring matching so split from this point (we have to get the max number of times we can split the string (largest Possible value of k))\\n            if(substringHash(start, left, hash, invModulo) == substringHash(right, end, hash, invModulo)) {\\n                ans += 2; // because 2 parts are being created.\\n                \\n                start = left+1;\\n                end = right-1;\\n            } \\n            \\n            left += 1;\\n            right -= 1;\\n\\n            \\n        }\\n        \\n        if(start <= end) ans += 1; // if one of the substring is still remaining.\\n         \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587221,
                "title": "c-linear-queue-and-stack-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n       int ans=0,l=0,r=text.size()-1;\\n        stack<int>st;\\n        queue<int>q;\\n        while(l<r){\\n            st.push(text[l++]);\\n            q.push(text[r--]);\\n            while(!st.empty() && q.front()==st.top()){\\n                q.pop();\\n                st.pop();\\n            }\\n            if(st.empty())ans+=l<=r?2:1;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Stack",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n       int ans=0,l=0,r=text.size()-1;\\n        stack<int>st;\\n        queue<int>q;\\n        while(l<r){\\n            st.push(text[l++]);\\n            q.push(text[r--]);\\n            while(!st.empty() && q.front()==st.top()){\\n                q.pop();\\n                st.pop();\\n            }\\n            if(st.empty())ans+=l<=r?2:1;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339182,
                "title": "cpp-super-simple-memozation-two-pointer-comments",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int dp[1001][1001];\\n    int solve(string txt, int b, int e){\\n        if(e<b) return 0;  // empty string\\n        int res=1;  // for nonempty string with no partition possible\\n        int len=1;  // length of the prefix that matches the suffix\\n        if(dp[b][e]!=-1) return dp[b][e];\\n        for(int i=e; i>b; i--,len++){\\n            if(txt[b]==txt[i]){\\n                string suff = txt.substr(i,len);\\n                string pref = txt.substr(b,len);\\n\\t\\t\\t\\t// if prefix and suffix are same, those two form a partition and then recursivley calculate for the inner subproblems. return the maximum value\\n                if(suff==pref) res = max(res,2+solve(txt,b+len,i-1));\\n            }\\n        }\\n        return dp[b][e]=res;\\n    }\\n    \\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        memset(dp,-1,sizeof dp);\\n        int ans = solve(text,0,n-1);\\n        return ans;\\n    }\\n};\\n```\\n\\nA better DP optimized\\n\\n```\\nclass Solution {\\npublic:\\n   \\n    int dp[1001][1001];\\n    int solve(string txt, int b, int e){\\n        if(e<b) return 0;  // empty string\\n        int res=1;  // for nonempty string with no partition possible\\n        int len=1;  // length of the prefix that matches the suffix\\n        if(dp[b][e]!=-1) return dp[b][e];\\n        for(int i=e; i>b; i--,len++){\\n            if(txt[b]==txt[i]){\\n                string suff = txt.substr(i,len);\\n                string pref = txt.substr(b,len);\\n\\t\\t\\t\\t// if prefix and suffix are same, those two form a partition and then recursivley calculate for the inner subproblems. return the maximum value\\n                if(suff==pref){\\n                    res = 2+solve(txt,b+len,i-1);\\n                    break;\\n                } \\n            }\\n        }\\n        return dp[b][e]=res;\\n    }\\n    \\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        memset(dp,-1,sizeof dp);\\n        int ans = solve(text,0,n-1);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nBelow is using 2 pointer greedy approach different from the DP one\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int n=text.size();\\n        int b=0,e=n-1;\\n        int count=0, lencompleted=0;\\n        string pref=\"\",suff=\"\";\\n        while(b<e){\\n            pref+=text[b++];\\n            suff=text[e--]+suff;\\n            if(pref==suff){\\n                count+=2;\\n                lencompleted+=2*pref.size();\\n                pref=\"\";\\n                suff=\"\";\\n            }\\n        }\\n        if(lencompleted==n) return count;\\n        return count+1; // one nonempty string in the middle was remaining\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int dp[1001][1001];\\n    int solve(string txt, int b, int e){\\n        if(e<b) return 0;  // empty string\\n        int res=1;  // for nonempty string with no partition possible\\n        int len=1;  // length of the prefix that matches the suffix\\n        if(dp[b][e]!=-1) return dp[b][e];\\n        for(int i=e; i>b; i--,len++){\\n            if(txt[b]==txt[i]){\\n                string suff = txt.substr(i,len);\\n                string pref = txt.substr(b,len);\\n\\t\\t\\t\\t// if prefix and suffix are same, those two form a partition and then recursivley calculate for the inner subproblems. return the maximum value\\n                if(suff==pref) res = max(res,2+solve(txt,b+len,i-1));\\n            }\\n        }\\n        return dp[b][e]=res;\\n    }\\n    \\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        memset(dp,-1,sizeof dp);\\n        int ans = solve(text,0,n-1);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n   \\n    int dp[1001][1001];\\n    int solve(string txt, int b, int e){\\n        if(e<b) return 0;  // empty string\\n        int res=1;  // for nonempty string with no partition possible\\n        int len=1;  // length of the prefix that matches the suffix\\n        if(dp[b][e]!=-1) return dp[b][e];\\n        for(int i=e; i>b; i--,len++){\\n            if(txt[b]==txt[i]){\\n                string suff = txt.substr(i,len);\\n                string pref = txt.substr(b,len);\\n\\t\\t\\t\\t// if prefix and suffix are same, those two form a partition and then recursivley calculate for the inner subproblems. return the maximum value\\n                if(suff==pref){\\n                    res = 2+solve(txt,b+len,i-1);\\n                    break;\\n                } \\n            }\\n        }\\n        return dp[b][e]=res;\\n    }\\n    \\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        memset(dp,-1,sizeof dp);\\n        int ans = solve(text,0,n-1);\\n        return ans;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int n=text.size();\\n        int b=0,e=n-1;\\n        int count=0, lencompleted=0;\\n        string pref=\"\",suff=\"\";\\n        while(b<e){\\n            pref+=text[b++];\\n            suff=text[e--]+suff;\\n            if(pref==suff){\\n                count+=2;\\n                lencompleted+=2*pref.size();\\n                pref=\"\";\\n                suff=\"\";\\n            }\\n        }\\n        if(lencompleted==n) return count;\\n        return count+1; // one nonempty string in the middle was remaining\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208172,
                "title": "python-recursion-beats-100",
                "content": "The idea is fairly simple. Just keeping a track of the shortest match where the string from start and end are equal. In case, such a string is found, apply the same logic on remaining string. In case, no match is found, return 0 if string is empty, else 1.\\n\\n```\\ndef longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        start = \\'\\'\\n        end = \\'\\'\\n        for i in range(n // 2):\\n            start += text[i]\\n            end = text[n - i - 1] + end\\n            if start == end:\\n                return 2 + self.longestDecomposition(text[i + 1: n - i - 1])\\n        return 0 if n == 0 else 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\ndef longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        start = \\'\\'\\n        end = \\'\\'\\n        for i in range(n // 2):\\n            start += text[i]\\n            end = text[n - i - 1] + end\\n            if start == end:\\n                return 2 + self.longestDecomposition(text[i + 1: n - i - 1])\\n        return 0 if n == 0 else 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 949854,
                "title": "c-two-pointer-technique-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int i = 0, j = text.size() - 1;\\n   \\n        int ans = 0;\\n        string s1 = \"\";\\n        string s2 = \"\";\\n        while(i < j){\\n          s1 += text[i];\\n          s2 = text[j] + s2;\\n          //cout << s1 << \" \" << s2 << endl;\\n          if(s1 == s2){\\n            ans += 2;\\n            s1 = \"\";\\n            s2 = \"\";\\n          }\\n          ++i;  --j;\\n        }\\n        if(s1.size() == 0 and s2.size() == 0 and text.size() % 2)  ans += 1;\\n        if(s1.size() or s2.size()) ans++;\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int i = 0, j = text.size() - 1;\\n   \\n        int ans = 0;\\n        string s1 = \"\";\\n        string s2 = \"\";\\n        while(i < j){\\n          s1 += text[i];\\n          s2 = text[j] + s2;\\n          //cout << s1 << \" \" << s2 << endl;\\n          if(s1 == s2){\\n            ans += 2;\\n            s1 = \"\";\\n            s2 = \"\";\\n          }\\n          ++i;  --j;\\n        }\\n        if(s1.size() == 0 and s2.size() == 0 and text.size() % 2)  ans += 1;\\n        if(s1.size() or s2.size()) ans++;\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 357272,
                "title": "o-n-solution-using-rolling-hash",
                "content": "Greedily match string from start and end using rolling hash\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s) {\\n        long long i = 0,j = s.length()-1,count=0;\\n        long long m = 1e9+7,sum1=0,sum2=0,prev2 = j;\\n        vector <long long> po(1005,0);\\n        po[0] = 1;\\n        for(int i=1;i<=s.length()+1;i++){\\n            po[i] = (po[i-1]*31)%m;\\n        }\\n        bool ismiddleleft = true;\\n        while(i<=j){\\n            sum1 = (((sum1 + (s[i]-\\'a\\'+1))%m)*31)%m;\\n            sum2 = (((s[j]-\\'a\\'+1)*po[prev2-j+1])%m + sum2)%m;\\n            if(i==j){\\n                count++;\\n                ismiddleleft = false;\\n                break;\\n            }\\n            if(sum1 == sum2){                \\n                count+=2;\\n                sum1 = 0;\\n                sum2 = 0;\\n                prev2 = j-1;       \\n                if(i+1==j)\\n                    ismiddleleft = false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        if(ismiddleleft)\\n            count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s) {\\n        long long i = 0,j = s.length()-1,count=0;\\n        long long m = 1e9+7,sum1=0,sum2=0,prev2 = j;\\n        vector <long long> po(1005,0);\\n        po[0] = 1;\\n        for(int i=1;i<=s.length()+1;i++){\\n            po[i] = (po[i-1]*31)%m;\\n        }\\n        bool ismiddleleft = true;\\n        while(i<=j){\\n            sum1 = (((sum1 + (s[i]-\\'a\\'+1))%m)*31)%m;\\n            sum2 = (((s[j]-\\'a\\'+1)*po[prev2-j+1])%m + sum2)%m;\\n            if(i==j){\\n                count++;\\n                ismiddleleft = false;\\n                break;\\n            }\\n            if(sum1 == sum2){                \\n                count+=2;\\n                sum1 = 0;\\n                sum2 = 0;\\n                prev2 = j-1;       \\n                if(i+1==j)\\n                    ismiddleleft = false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        if(ismiddleleft)\\n            count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350974,
                "title": "c-inward-traversal-greedy-chunk-matching",
                "content": "The main info you need to follow this algorithm is:\\n\\n* We\\'re comparing chunks, starting at the outer extremes of the text, traveling inward.\\n* Index `l` points at the first character of the current chunk.\\n* Index `r` points at one past the last character of the current chunk.\\n* Index `N-r` points at the first character of the equivalent chunk on the other side of the text.\\n* We want every match to be as small as possible. As soon as we match, we advance `l`.\\n* At the end we still need to check whether there\\'s a lone chunk left in the middle.\\n\\n```C++\\nint longestDecomposition(const string& text) {\\n  const int N = text.size();\\n  const auto tb = text.begin();\\n  int count = 0, l = 0;\\n  for (int r = 1; 2*r <= N; ++r)\\n    if (equal(tb+l, tb+r, tb+N-r))\\n      count += 2, l = r;\\n  return count + (2 * l < N);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nint longestDecomposition(const string& text) {\\n  const int N = text.size();\\n  const auto tb = text.begin();\\n  int count = 0, l = 0;\\n  for (int r = 1; 2*r <= N; ++r)\\n    if (equal(tb+l, tb+r, tb+N-r))\\n      count += 2, l = r;\\n  return count + (2 * l < N);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350618,
                "title": "java-recursion-memo",
                "content": "```\\nclass Solution {\\n    Map<String, Integer> map = new HashMap<>();\\n    public int longestDecomposition(String text) {\\n        if (map.containsKey(text)) return map.get(text);\\n        int len = text.length();\\n        if (len == 0) return 0;\\n        else if (len == 1) return 1;\\n        int count = 1;\\n        for (int i = 0; i <= len / 2 - 1; i++) {\\n            String sub = text.substring(0,  i + 1);\\n            if (text.startsWith(sub, len - i - 1)) {\\n                String s = text.substring(i + 1, text.length() - sub.length());\\n                count = Math.max(2 + longestDecomposition(s), count);\\n            }\\n        }\\n        map.put(text, count);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<String, Integer> map = new HashMap<>();\\n    public int longestDecomposition(String text) {\\n        if (map.containsKey(text)) return map.get(text);\\n        int len = text.length();\\n        if (len == 0) return 0;\\n        else if (len == 1) return 1;\\n        int count = 1;\\n        for (int i = 0; i <= len / 2 - 1; i++) {\\n            String sub = text.substring(0,  i + 1);\\n            if (text.startsWith(sub, len - i - 1)) {\\n                String s = text.substring(i + 1, text.length() - sub.length());\\n                count = Math.max(2 + longestDecomposition(s), count);\\n            }\\n        }\\n        map.put(text, count);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350597,
                "title": "simple-python-two-pointer-solution",
                "content": "```\\n    def longestDecomposition(self, text: str) -> int:\\n        res = 0\\n        l, r = 0, len(text) - 1\\n        while l <= r:\\n            j = 0\\n            while l + j < r:\\n                if text[l:l+j+1] != text[r-j:r+1]:\\n                    j += 1\\n                else:\\n                    break\\n            if l + j == r:\\n                res += 1\\n                break\\n            else:\\n                res += 2\\n                l, r = l + j + 1, r - j - 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def longestDecomposition(self, text: str) -> int:\\n        res = 0\\n        l, r = 0, len(text) - 1\\n        while l <= r:\\n            j = 0\\n            while l + j < r:\\n                if text[l:l+j+1] != text[r-j:r+1]:\\n                    j += 1\\n                else:\\n                    break\\n            if l + j == r:\\n                res += 1\\n                break\\n            else:\\n                res += 2\\n                l, r = l + j + 1, r - j - 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 350591,
                "title": "c-recursion-with-memoization",
                "content": "The entire idea is to create chunks from left and right and recursively.\\n![image](https://assets.leetcode.com/users/bangerlee/image_1564891466.png)\\n```\\nclass Solution {\\nprivate:\\n    int res=1;\\n    unordered_map<string,int> m;\\n    int helper(string& s,int l,int r){\\n        if(l>r) return 0;\\n        if(m.count(s.substr(l,r-l+1))) return m[s.substr(l,r-l+1)];\\n        for(int len=1;len<=(r-l+1)/2;len++){\\n            if(s.substr(l,len)==s.substr(r-len+1,len))\\n                res=max(res,2+helper(s,l+len,r-len));\\n        }\\n        m[s.substr(l,r-l+1)]=res;\\n        return res;\\n    }\\npublic:\\n    int longestDecomposition(string text) {\\n        return helper(text,0,text.length()-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int res=1;\\n    unordered_map<string,int> m;\\n    int helper(string& s,int l,int r){\\n        if(l>r) return 0;\\n        if(m.count(s.substr(l,r-l+1))) return m[s.substr(l,r-l+1)];\\n        for(int len=1;len<=(r-l+1)/2;len++){\\n            if(s.substr(l,len)==s.substr(r-len+1,len))\\n                res=max(res,2+helper(s,l+len,r-len));\\n        }\\n        m[s.substr(l,r-l+1)]=res;\\n        return res;\\n    }\\npublic:\\n    int longestDecomposition(string text) {\\n        return helper(text,0,text.length()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799803,
                "title": "beats-100-easy-understanding-c-two-pointers",
                "content": "**Approach**\\n\\n There is simple approach to solve this problem,we use two pointers to identify palindromic substrings from both ends of the string. When a valid palindrome is found, it increments the count and moves the pointers accordingly. The loop continues until both pointers meet at the middle or cross each other. The result returned is the count of valid palindromic decompositions found.\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int i=0, j=text.size()-1;\\n        int last=text.size();\\n        int ctr=0;\\n        int half=text.size()/2;\\n        while(i<=j && j>=half){\\n            if(i==j){\\n                ctr++;\\n                break;\\n            }\\n            \\n          \\n            if(text[i]==text[j]){\\n                int x=i;\\n                int y=j;\\n                int flag=0;\\n                while(y<last){\\n                    if(text[x]!=text[y]){\\n                        flag=1;\\n                        break;\\n                    }\\n                    x++;\\n                    y++;\\n                }\\n               \\n                if(flag==0){\\n                    ctr+=2;\\n                    last=j;\\n                    i=x;\\n                }\\n            }\\n            j--;\\n            \\n        }\\n        if(j<half && i>=half) return ctr;\\n        \\n        if(j<half && i<half)return ctr+1;\\n        return ctr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int i=0, j=text.size()-1;\\n        int last=text.size();\\n        int ctr=0;\\n        int half=text.size()/2;\\n        while(i<=j && j>=half){\\n            if(i==j){\\n                ctr++;\\n                break;\\n            }\\n            \\n          \\n            if(text[i]==text[j]){\\n                int x=i;\\n                int y=j;\\n                int flag=0;\\n                while(y<last){\\n                    if(text[x]!=text[y]){\\n                        flag=1;\\n                        break;\\n                    }\\n                    x++;\\n                    y++;\\n                }\\n               \\n                if(flag==0){\\n                    ctr+=2;\\n                    last=j;\\n                    i=x;\\n                }\\n            }\\n            j--;\\n            \\n        }\\n        if(j<half && i>=half) return ctr;\\n        \\n        if(j<half && i<half)return ctr+1;\\n        return ctr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731758,
                "title": "c-easiest-greedy-solution-top-down-dp",
                "content": "# **Greedy**\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s) {\\n        int n = s.size(), res = 0;\\n        string a = \"\", b = \"\";\\n        for(int i = 0; i < n; i++){\\n            a += s[i], b = s[n - 1 - i] + b;\\n            if(a == b)\\n                res++, a = \"\", b = \"\";\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# **Top-Down DP**\\n```\\nclass Solution {\\npublic:\\n    int memo[1001][1001];\\n    int n;\\n    int longestDecomposition(string s) {\\n        n = s.size();\\n        memset(memo, -1, sizeof(memo));\\n        return dp(s, 0, 1);\\n    }\\n    int dp(string& s, int idx, int sz){\\n        if(n % 2 == 0 && idx + sz == n / 2)\\n            return s.substr(idx, sz) == s.substr(n - sz - idx, sz) ? 2 : 1;\\n        if(idx + sz > n / 2) return 1;\\n        if(memo[idx][sz] != -1) return memo[idx][sz];\\n        return memo[idx][sz] = s.substr(idx, sz) == s.substr(n - sz - idx, sz) ? 2 + dp(s, idx + sz, 1) : dp(s, idx, sz + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s) {\\n        int n = s.size(), res = 0;\\n        string a = \"\", b = \"\";\\n        for(int i = 0; i < n; i++){\\n            a += s[i], b = s[n - 1 - i] + b;\\n            if(a == b)\\n                res++, a = \"\", b = \"\";\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int memo[1001][1001];\\n    int n;\\n    int longestDecomposition(string s) {\\n        n = s.size();\\n        memset(memo, -1, sizeof(memo));\\n        return dp(s, 0, 1);\\n    }\\n    int dp(string& s, int idx, int sz){\\n        if(n % 2 == 0 && idx + sz == n / 2)\\n            return s.substr(idx, sz) == s.substr(n - sz - idx, sz) ? 2 : 1;\\n        if(idx + sz > n / 2) return 1;\\n        if(memo[idx][sz] != -1) return memo[idx][sz];\\n        return memo[idx][sz] = s.substr(idx, sz) == s.substr(n - sz - idx, sz) ? 2 + dp(s, idx + sz, 1) : dp(s, idx, sz + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546784,
                "title": "c-simple-rolling-hash-no-recursion",
                "content": "This implementation is a simple rolling hash implementation in C++. It doesn\\'t involve string comparison that at times might be of O(N) time complexity magnitude.\\n\\n```cpp\\nclass Solution {\\n    #define ll long long\\n    const int MOD7 = 1e9+7;\\npublic:\\n    int longestDecomposition(string text) {\\n        int n = text.size(), l = 0, r = n-1, ans = 0, base = 26;\\n        \\n        ll pref = 0, suff = 0, pw = 1;\\n        while(l < r)\\n        {\\n            pref = ((pref*base) + (text[l++]-\\'a\\')) % MOD7;\\n            suff = (suff + (text[r--]-\\'a\\')*pw) % MOD7;\\n            pw = (pw*base) % MOD7;\\n            \\n            if (pref == suff)\\n            {\\n                ans += 2;\\n                pref = 0;\\n                suff = 0;\\n                pw = 1;\\n                if (l > r) return ans;\\n            }\\n        }\\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Rolling Hash"
                ],
                "code": "```cpp\\nclass Solution {\\n    #define ll long long\\n    const int MOD7 = 1e9+7;\\npublic:\\n    int longestDecomposition(string text) {\\n        int n = text.size(), l = 0, r = n-1, ans = 0, base = 26;\\n        \\n        ll pref = 0, suff = 0, pw = 1;\\n        while(l < r)\\n        {\\n            pref = ((pref*base) + (text[l++]-\\'a\\')) % MOD7;\\n            suff = (suff + (text[r--]-\\'a\\')*pw) % MOD7;\\n            pw = (pw*base) % MOD7;\\n            \\n            if (pref == suff)\\n            {\\n                ans += 2;\\n                pref = 0;\\n                suff = 0;\\n                pw = 1;\\n                if (l > r) return ans;\\n            }\\n        }\\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205665,
                "title": "c-dp-lps-solution",
                "content": "In the computation of LPS array, you get the length of the proper prefix that is also a suffix for all the indices in the length of the string. Create n such LPS array for the substring of a given string with increasing starting position. To maximize k, we will take greedy approach. Find the shortest prefix that is also suffix whille recursive drillling down in the LPS DP array. Reduce the size of the string by that lenght from both end and increment the `k` based on the following rule:\\n1. If the smallest prefix is less than the length of string, add 2\\n2. Else, add 1\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getDP(string& s){\\n        int l = s.length();\\n        vector<vector<int>> dp(l, vector<int>(l, 0));\\n        for(int start = 0; start < l; start++){\\n            int i = 0, j = 1;\\n            while(start + j < l){\\n                if(s[start+i] == s[start+j]){\\n                    i++;\\n                    dp[start][start+j] = i;\\n                    j++;\\n                }\\n                else{\\n                    if(i != 0){\\n                        i = dp[start][start+i-1];\\n                    }\\n                    else{\\n                        dp[start][start+j] = 0;\\n                        j++;\\n                    }\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n    int longestDecomposition(string text) {\\n        vector<vector<int>> lpsDP = getDP(text);\\n        int i = 0, j = text.length()-1, k = 0, l;\\n        while(i <= j){\\n            int s = text.length();\\n            int l = j;\\n            while(lpsDP[i][l]){\\n                s = lpsDP[i][l];\\n                l = i + s - 1;\\n            }\\n            if(s != text.length()){\\n                k += 2;\\n            }\\n            else{\\n                k++;\\n            }\\n            i += s;\\n            j -= s;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getDP(string& s){\\n        int l = s.length();\\n        vector<vector<int>> dp(l, vector<int>(l, 0));\\n        for(int start = 0; start < l; start++){\\n            int i = 0, j = 1;\\n            while(start + j < l){\\n                if(s[start+i] == s[start+j]){\\n                    i++;\\n                    dp[start][start+j] = i;\\n                    j++;\\n                }\\n                else{\\n                    if(i != 0){\\n                        i = dp[start][start+i-1];\\n                    }\\n                    else{\\n                        dp[start][start+j] = 0;\\n                        j++;\\n                    }\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n    int longestDecomposition(string text) {\\n        vector<vector<int>> lpsDP = getDP(text);\\n        int i = 0, j = text.length()-1, k = 0, l;\\n        while(i <= j){\\n            int s = text.length();\\n            int l = j;\\n            while(lpsDP[i][l]){\\n                s = lpsDP[i][l];\\n                l = i + s - 1;\\n            }\\n            if(s != text.length()){\\n                k += 2;\\n            }\\n            else{\\n                k++;\\n            }\\n            i += s;\\n            j -= s;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188097,
                "title": "two-pointer-easy-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint longestDecomposition(string s) {\\n\\t\\t\\tint i=0,j=s.size()-1;\\n\\t\\t\\tstring tmp,tmp1;\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\twhile(i < j)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttmp+=s[i];\\n\\t\\t\\t\\ttmp1=s[j]+tmp1;\\n\\t\\t\\t\\tif(tmp==tmp1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttmp=\"\",tmp1=\"\";\\n\\t\\t\\t\\t\\tcnt+=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++,j--;\\n\\t\\t\\t}\\n\\t\\t\\tif(i==j)return cnt+1;\\n\\t\\t\\telse if(tmp.size()==0 && tmp1.size()==0)return cnt;\\n\\n\\t\\t\\treturn cnt+1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint longestDecomposition(string s) {\\n\\t\\t\\tint i=0,j=s.size()-1;\\n\\t\\t\\tstring tmp,tmp1;\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\twhile(i < j)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttmp+=s[i];\\n\\t\\t\\t\\ttmp1=s[j]+tmp1;\\n\\t\\t\\t\\tif(tmp==tmp1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttmp=\"\",tmp1=\"\";\\n\\t\\t\\t\\t\\tcnt+=2;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2070317,
                "title": "python-easy-beats-94-deque-two-pointer",
                "content": "Appending a element to the left of a list (insert operation) takes `O(N)` time.\\nHence we can use a deque to append a element to the left of list in `O(1)` time.\\nWe maintain two deques `a` and `b` and keep checking if they are equal while traversing `text` in a 2-Pointer approach.\\nWe add characters to the right in `a` and add characters to the left in `b`.\\n```\\neg , text=\"abcabc\"\\nIteration 1: a=>[a] b=>[c]\\nIteration 2: a=>[a,b] b=>[b,c]\\nIteration 3: a=>[a,b,c] b=>[a,b,c]\\n```\\n\\n```py\\n\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        left, right = 0, len(text) - 1\\n        sol, last_left = 0, 0\\n        a, b = deque(), deque()\\n        while right > left:\\n            a.append(text[left])\\n            b.appendleft(text[right])\\n            if a == b:\\n                sol += 2\\n                last_left = left\\n                a, b = deque(), deque()\\n            right -= 1\\n            left += 1\\n        if left == right or left > last_left + 1:\\n            sol += 1\\n        return max(sol, 1)\\n\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2efaa2c9-9e82-4bad-8b14-f9ad1e3c9bdb_1653408173.8650315.png)\\n\\n**Happy Coding !!**\\n\\nIf you have any questions , feel free to ask.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\neg , text=\"abcabc\"\\nIteration 1: a=>[a] b=>[c]\\nIteration 2: a=>[a,b] b=>[b,c]\\nIteration 3: a=>[a,b,c] b=>[a,b,c]\\n```\n```py\\n\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        left, right = 0, len(text) - 1\\n        sol, last_left = 0, 0\\n        a, b = deque(), deque()\\n        while right > left:\\n            a.append(text[left])\\n            b.appendleft(text[right])\\n            if a == b:\\n                sol += 2\\n                last_left = left\\n                a, b = deque(), deque()\\n            right -= 1\\n            left += 1\\n        if left == right or left > last_left + 1:\\n            sol += 1\\n        return max(sol, 1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898032,
                "title": "simple-solution-in-java-easy-to-understand-dp-with-comments",
                "content": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        if(text.length() == 0) return 0;\\n        \\n        int n = text.length();\\n        int[] dp = new int[n/2+2];\\n        \\n        int max = 0; \\n        int maxIndex = -1;\\n        \\n        // i is length of the chunk \\n        for(int i=1; i<=n/2; i++){ \\n            for(int j=0; j<i; j++){\\n                if(text.substring(j, i).equals(text.substring(n-i, n-j))){\\n                    if(j == 0 || dp[j] != 0){\\n                        dp[i] = Math.max(dp[i], 2 + dp[j]);\\n                    }\\n                }\\n            }\\n            \\n            max = Math.max(max, dp[i]);\\n            if(dp[i] != 0) maxIndex = i;\\n        }\\n        \\n        if(maxIndex == -1) return 1; // There are no palindromes, take the entire string as one chunk\\n        if(n%2 == 0){\\n             /* \\n                The length is even, if the palindrome is possible at the middle like abba then ab -> 2nd position (i.e. size/2), It\\n                will give the max chunks\\n                And if the palindrome decomposition is not possible in the middle, take the middle as one chunk and return max + 1\\n                like if the text is \"abcdklmdcba\", here we will take \"klm\" as one chunk \\n             */\\n            if(maxIndex == n/2) return max;\\n            return max + 1;\\n        }\\n        \\n        // Max chunks plus the one chunk in the middle whose decomposition is not possible \\n        return max + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        if(text.length() == 0) return 0;\\n        \\n        int n = text.length();\\n        int[] dp = new int[n/2+2];\\n        \\n        int max = 0; \\n        int maxIndex = -1;\\n        \\n        // i is length of the chunk \\n        for(int i=1; i<=n/2; i++){ \\n            for(int j=0; j<i; j++){\\n                if(text.substring(j, i).equals(text.substring(n-i, n-j))){\\n                    if(j == 0 || dp[j] != 0){\\n                        dp[i] = Math.max(dp[i], 2 + dp[j]);\\n                    }\\n                }\\n            }\\n            \\n            max = Math.max(max, dp[i]);\\n            if(dp[i] != 0) maxIndex = i;\\n        }\\n        \\n        if(maxIndex == -1) return 1; // There are no palindromes, take the entire string as one chunk\\n        if(n%2 == 0){\\n             /* \\n                The length is even, if the palindrome is possible at the middle like abba then ab -> 2nd position (i.e. size/2), It\\n                will give the max chunks\\n                And if the palindrome decomposition is not possible in the middle, take the middle as one chunk and return max + 1\\n                like if the text is \"abcdklmdcba\", here we will take \"klm\" as one chunk \\n             */\\n            if(maxIndex == n/2) return max;\\n            return max + 1;\\n        }\\n        \\n        // Max chunks plus the one chunk in the middle whose decomposition is not possible \\n        return max + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427274,
                "title": "why-hard-it-should-be-in-easy-see-my-python-solution-no-dp-at-all",
                "content": "However we can make dp solution but as it is in hard section we can also solve this problem by simple checking using one while loop . \\n\\n<iframe src=\"https://leetcode.com/playground/jjeTAFQR/shared\" frameBorder=\"0\" width=\"600\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Python"
                ],
                "code": "However we can make dp solution but as it is in hard section we can also solve this problem by simple checking using one while loop . \\n\\n<iframe src=\"https://leetcode.com/playground/jjeTAFQR/shared\" frameBorder=\"0\" width=\"600\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1399637,
                "title": "c-easy-solution-with-diagram-representation",
                "content": "![image](https://assets.leetcode.com/users/images/2eaddbe4-7403-4ade-83a3-ecd9f11e5e18_1628777834.972519.png)\\n\\n\\nclass Solution {\\npublic:\\n#     int longestDecomposition(string text) {\\n        int ans = 0;\\n        int n = text.size();\\n        int i=0, j=n-1;\\n        int last = n;\\n        while(i<j)\\n        {\\n            if(text[i]==text[j])\\n            {\\n                bool ansb = true;\\n                \\n                for(int k=j+1; k<last; k++)\\n                {\\n                    if(text[k]!=text[k-j+i])\\n                    {\\n                        ansb = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(ansb)\\n                {\\n                    if(i!=j) ans+=2;\\n                 \\n                    else ans+=1;\\n                   \\n                    i+=last-j;\\n                    \\n                    last = j;\\n                    \\n                    j--;\\n                }\\n                else j--;   \\n            }\\n            else j--;   \\n        }\\n        \\n        if(i==j) ans++;\\n       \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n#     int longestDecomposition(string text) {\\n        int ans = 0;\\n        int n = text.size();\\n        int i=0, j=n-1;\\n        int last = n;\\n        while(i<j)\\n        {\\n            if(text[i]==text[j])\\n            {\\n                bool ansb = true;\\n                \\n                for(int k=j+1; k<last; k++)\\n                {\\n                    if(text[k]!=text[k-j+i])\\n                    {\\n                        ansb = false;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1268605,
                "title": "faster-than-100-submissions-rolling-hash-o-n-memory-usage-less-than-99-34-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        long long lh = 0LL, rh = 0LL, powers=1LL, MOD = 1000000007LL;\\n        int l =0, r = text.size()-1;\\n        int ans =0;\\n        while(l<r){\\n            lh = (lh*26LL + text[l++]-\\'a\\'+1) % MOD;\\n            rh = (rh + (text[r--]-\\'a\\'+1)*powers% MOD )% MOD;\\n            if(lh == rh){\\n                ans +=2;\\n                powers = 1;\\n                lh = rh =0LL;\\n            }\\n            else\\n                powers = (powers*26LL) % MOD;\\n        }\\n        if(l==r || powers > 1)\\n            return ans+1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        long long lh = 0LL, rh = 0LL, powers=1LL, MOD = 1000000007LL;\\n        int l =0, r = text.size()-1;\\n        int ans =0;\\n        while(l<r){\\n            lh = (lh*26LL + text[l++]-\\'a\\'+1) % MOD;\\n            rh = (rh + (text[r--]-\\'a\\'+1)*powers% MOD )% MOD;\\n            if(lh == rh){\\n                ans +=2;\\n                powers = 1;\\n                lh = rh =0LL;\\n            }\\n            else\\n                powers = (powers*26LL) % MOD;\\n        }\\n        if(l==r || powers > 1)\\n            return ans+1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213864,
                "title": "c-code-beats-100-time-and-99-9-space-simple-and-easy",
                "content": "class Solution {\\npublic:\\nint longestDecomposition(string text) {\\n        \\n        int ans=0;\\n        int l=0;\\n        int r=text.size()-1;\\n        stack<char>sd;\\n        queue<char>ds;\\n        while(l<r)\\n        {\\n            sd.push(text[l++]);\\n            ds.push(text[r--]);\\n            while(!sd.empty()&&sd.top()==ds.front())\\n            {\\n                ds.pop();\\n            sd.pop();\\n            }\\n            if(sd.empty())\\n            {\\n                ans+=l<=r?2:1;\\n            }\\n        }\\nreturn ans+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nint longestDecomposition(string text) {\\n        \\n        int ans=0;\\n        int l=0;\\n        int r=text.size()-1;\\n        stack<char>sd;\\n        queue<char>ds;\\n        while(l<r)\\n        {\\n            sd.push(text[l++]);\\n            ds.push(text[r--]);\\n            while(!sd.empty()&&sd.top()==ds.front())\\n            {\\n                ds.pop();\\n            sd.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1117465,
                "title": "javascript-solution",
                "content": "```\\nvar longestDecomposition = function(text) {\\n    var i = 1\\n    var output = 0\\n    while(i < text.length)\\n    {\\n        if(text.substring(0,i) == text.substring(text.length-i))\\n        {\\n            output += 2 //add 2 to simulate adding to both sides of output array\\n            text = text.substring(i,text.length-i) //cut text to simulate popping off of both sides\\n            i=1\\n        } else {\\n            i++\\n        }\\n    }\\n    \\n    return text ? output + 1 : output //if there\\'s any text leftover that didn\\'t have a match, it\\'s the middle and would add 1 to output array\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestDecomposition = function(text) {\\n    var i = 1\\n    var output = 0\\n    while(i < text.length)\\n    {\\n        if(text.substring(0,i) == text.substring(text.length-i))\\n        {\\n            output += 2 //add 2 to simulate adding to both sides of output array\\n            text = text.substring(i,text.length-i) //cut text to simulate popping off of both sides\\n            i=1\\n        } else {\\n            i++\\n        }\\n    }\\n    \\n    return text ? output + 1 : output //if there\\'s any text leftover that didn\\'t have a match, it\\'s the middle and would add 1 to output array\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 902898,
                "title": "java-rabin-karp-algorithm-rolling-hash-o-n-short-and-concise",
                "content": "```\\n// Using Rabin Karp Algorithm\\npublic int longestDecomposition(String text) {\\n\\tlong hash1 = 0;\\n\\tlong hash2 = 0;\\n\\n\\tlong mod = (long)Math.pow(2, 31);\\n\\n\\tint l = 0;\\n\\tint r = text.length() - 1;\\n\\n\\tlong rightPow = 1;\\n\\n\\tint count = 0;\\n\\twhile(l < r) {            \\n\\t\\thash1 *= 26;\\n\\t\\thash1 += text.charAt(l) - \\'a\\';\\n\\t\\thash1 %= mod;\\n\\n\\t\\thash2 += (text.charAt(r) - \\'a\\') * rightPow;\\n\\t\\thash2 %= mod;\\n\\n\\t\\trightPow *= 26;\\n\\t\\trightPow %= mod;\\n\\n\\t\\tif(hash1 == hash2) {\\n\\t\\t\\tcount += 2;\\n\\n\\t\\t\\thash1 = 0;\\n\\t\\t\\thash2 = 0;\\n\\t\\t\\trightPow = 1;\\n\\t\\t}\\n\\n\\t\\tl++;\\n\\t\\tr--;\\n\\t}\\n\\n\\tif(hash1 != 0 || l == r || count == 0)\\n\\t\\tcount++;\\n\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Using Rabin Karp Algorithm\\npublic int longestDecomposition(String text) {\\n\\tlong hash1 = 0;\\n\\tlong hash2 = 0;\\n\\n\\tlong mod = (long)Math.pow(2, 31);\\n\\n\\tint l = 0;\\n\\tint r = text.length() - 1;\\n\\n\\tlong rightPow = 1;\\n\\n\\tint count = 0;\\n\\twhile(l < r) {            \\n\\t\\thash1 *= 26;\\n\\t\\thash1 += text.charAt(l) - \\'a\\';\\n\\t\\thash1 %= mod;\\n\\n\\t\\thash2 += (text.charAt(r) - \\'a\\') * rightPow;\\n\\t\\thash2 %= mod;\\n\\n\\t\\trightPow *= 26;\\n\\t\\trightPow %= mod;\\n\\n\\t\\tif(hash1 == hash2) {\\n\\t\\t\\tcount += 2;\\n\\n\\t\\t\\thash1 = 0;\\n\\t\\t\\thash2 = 0;\\n\\t\\t\\trightPow = 1;\\n\\t\\t}\\n\\n\\t\\tl++;\\n\\t\\tr--;\\n\\t}\\n\\n\\tif(hash1 != 0 || l == r || count == 0)\\n\\t\\tcount++;\\n\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 897806,
                "title": "python-3-look-for-smallest-subtext-that-matches-at-beginning-and-end-if-any-recurse",
                "content": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        if n <= 1: return n\\n        for i in range(1,n//2+1):\\n            if text[:i] == text[-i:]:\\n                return 2+self.longestDecomposition(text[i:-i])\\n        return 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        if n <= 1: return n\\n        for i in range(1,n//2+1):\\n            if text[:i] == text[-i:]:\\n                return 2+self.longestDecomposition(text[i:-i])\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858169,
                "title": "python-greedy-deques-simple-explanation-and-example",
                "content": "```html5\\n<b>Time Complexity: O(n)\\nSpace complexity: O(n)</b>\\n```\\n\\nUse two double ended queues: \\n**left** to keep track of the current substring as we read text from the left\\n**right** to keep track of the current substring as we read text from the right.  \\n***See example at the end***\\n\\nDouble ended queues (deques) are used because they offer **O(1) time complexity** when adding a letter to the beginning or to the end of the queue.  \\n\\nWhenever **left == right** then we have found 2 chunks that match, so add 2 to res. \\n\\n```python\\ndef longestDecomposition(self, text: str) -> int:\\n\\n\\tres = 0\\n\\tleft = collections.deque()\\n\\tright = collections.deque()\\n\\ti, j = 0, len(text)-1\\n\\twhile i <= j:\\n\\t\\tleft.append(text[i])\\n\\t\\tright.appendleft(text[j])\\n\\t\\tif left == right:\\n\\t\\t\\tres += 2 - (i == j) # - (i == j) subtracts one chunk when left and right overlap i.e. text = \"a\" left = \"a\" right = \"a\"\\n\\t\\t\\tleft = collections.deque()\\n\\t\\t\\tright = collections.deque()\\n\\t\\ti += 1\\n\\t\\tj -= 1\\n\\telse:\\n\\t\\tres += bool(left) # If i >= j and left is not empty, then combine left and right into 1 chunk (res += 1)\\n\\n\\treturn res\\n```\\n\\n**Walk-through Example:**\\n```\\ntext = \"ghiabcdefhelloadamhelloabcdefghi\"\\n\\nleft = [\"g\"] ;                     right = [\"i\"] ; res = 0\\nleft = [\"g\",\"h\"] ;                 right = [\"h\",\"i\"] ; res = 0\\nleft = [\"g\",\"h\",\"i\"] ;             right = [\"g\",\"h\",\"i\"] ; res = 2\\n\\nleft = [\"a\"] ;                     right = [\"f\"] ; res = 2\\nleft = [\"a\",\"b\"] ;                 right = [\"e\",\"f\"] ; res = 2\\nleft = [\"a\",\"b\",\"c\"] ;             right = [\"d\",\"e\",\"f\"] ; res = 2\\nleft = [\"a\",\"b\",\"c\",\"d\"] ;         right = [\"c\",\"d\",\"e\",\"f\"] ; res = 2\\nleft = [\"a\",\"b\",\"c\",\"d\",\"e\"] ;     right = [\"b\",\"c\",\"d\",\"e\",\"f\"] ; res = 2\\nleft = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"] ; right = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"] ; res = 4\\n...\\nleft = [\"h\",\"e\",\"l\",\"l\",\"o\"] ;     right = [\"h\",\"e\",\"l\",\"l\",\"o\"] ; res = 6\\n...\\nleft = [\"a\",\"d\"] ; right = [\"a\", \"m\"] ; res = 6 + bool(left) = 7\\n```\\n\\n<img src=\"https://assets.leetcode.com/users/images/95fc1a59-3980-4002-a404-314d63602ef1_1600722431.3899684.png\" width=\"50%\">",
                "solutionTags": [],
                "code": "```html5\\n<b>Time Complexity: O(n)\\nSpace complexity: O(n)</b>\\n```\n```python\\ndef longestDecomposition(self, text: str) -> int:\\n\\n\\tres = 0\\n\\tleft = collections.deque()\\n\\tright = collections.deque()\\n\\ti, j = 0, len(text)-1\\n\\twhile i <= j:\\n\\t\\tleft.append(text[i])\\n\\t\\tright.appendleft(text[j])\\n\\t\\tif left == right:\\n\\t\\t\\tres += 2 - (i == j) # - (i == j) subtracts one chunk when left and right overlap i.e. text = \"a\" left = \"a\" right = \"a\"\\n\\t\\t\\tleft = collections.deque()\\n\\t\\t\\tright = collections.deque()\\n\\t\\ti += 1\\n\\t\\tj -= 1\\n\\telse:\\n\\t\\tres += bool(left) # If i >= j and left is not empty, then combine left and right into 1 chunk (res += 1)\\n\\n\\treturn res\\n```\n```\\ntext = \"ghiabcdefhelloadamhelloabcdefghi\"\\n\\nleft = [\"g\"] ;                     right = [\"i\"] ; res = 0\\nleft = [\"g\",\"h\"] ;                 right = [\"h\",\"i\"] ; res = 0\\nleft = [\"g\",\"h\",\"i\"] ;             right = [\"g\",\"h\",\"i\"] ; res = 2\\n\\nleft = [\"a\"] ;                     right = [\"f\"] ; res = 2\\nleft = [\"a\",\"b\"] ;                 right = [\"e\",\"f\"] ; res = 2\\nleft = [\"a\",\"b\",\"c\"] ;             right = [\"d\",\"e\",\"f\"] ; res = 2\\nleft = [\"a\",\"b\",\"c\",\"d\"] ;         right = [\"c\",\"d\",\"e\",\"f\"] ; res = 2\\nleft = [\"a\",\"b\",\"c\",\"d\",\"e\"] ;     right = [\"b\",\"c\",\"d\",\"e\",\"f\"] ; res = 2\\nleft = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"] ; right = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"] ; res = 4\\n...\\nleft = [\"h\",\"e\",\"l\",\"l\",\"o\"] ;     right = [\"h\",\"e\",\"l\",\"l\",\"o\"] ; res = 6\\n...\\nleft = [\"a\",\"d\"] ; right = [\"a\", \"m\"] ; res = 6 + bool(left) = 7\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 640029,
                "title": "simple-java",
                "content": "```\\npublic int longestDecomposition(String text) {\\n        \\n        int count = 0;\\n        int n = text.length();\\n        int i=0;\\n        int j = 1;\\n\\t\\t//to check if the middle most substring had a palindrome pair or not \\n        boolean flag = false; \\n        while(j<=text.length()/2){\\n                flag = false;\\n                if(text.substring(i,j).equals(text.substring(n-i-(j-i),n-i))){\\n                    count++;\\n                    i=j;\\n                    j=i+1;\\n                    flag = true;\\n                }else j++;\\n        }\\n        if(flag && n%2==0) return count*2;\\n        return count*2+1;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int longestDecomposition(String text) {\\n        \\n        int count = 0;\\n        int n = text.length();\\n        int i=0;\\n        int j = 1;\\n\\t\\t//to check if the middle most substring had a palindrome pair or not \\n        boolean flag = false; \\n        while(j<=text.length()/2){\\n                flag = false;\\n                if(text.substring(i,j).equals(text.substring(n-i-(j-i),n-i))){\\n                    count++;\\n                    i=j;\\n                    j=i+1;\\n                    flag = true;\\n                }else j++;\\n        }\\n        if(flag && n%2==0) return count*2;\\n        return count*2+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 528363,
                "title": "javascript-greedy",
                "content": "```javascript\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar longestDecomposition = function(text) {\\n    let count = 0;\\n    let left = 0;\\n    let right = text.length - 1;\\n    let leftStr = \\'\\';\\n    let rightStr = \\'\\';\\n    while (left < right) {\\n        leftStr += text[left++];\\n        rightStr = text[right--] + rightStr;\\n        if (leftStr === rightStr) {\\n            count += 2;\\n            leftStr = \\'\\';\\n            rightStr = \\'\\';\\n        }\\n    }\\n    if (leftStr || left === right) count++;\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```javascript\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar longestDecomposition = function(text) {\\n    let count = 0;\\n    let left = 0;\\n    let right = text.length - 1;\\n    let leftStr = \\'\\';\\n    let rightStr = \\'\\';\\n    while (left < right) {\\n        leftStr += text[left++];\\n        rightStr = text[right--] + rightStr;\\n        if (leftStr === rightStr) {\\n            count += 2;\\n            leftStr = \\'\\';\\n            rightStr = \\'\\';\\n        }\\n    }\\n    if (leftStr || left === right) count++;\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519791,
                "title": "java-rollinghash-dfs-memo",
                "content": "```\\nclass Solution {\\n    int mod=1000000007;\\n    long hash[];\\n    long pow[];\\n    int dp[][];\\n    public int longestDecomposition(String text) {\\n        dp=new int[text.length()+1][text.length()+1];\\n        hash=new long[text.length()];\\n        pow=new long[text.length()];\\n        pow[0]=1;\\n        hash[0]=text.charAt(0)%mod;\\n        for(int i=1;i<text.length();i++){\\n            hash[i]=(hash[i-1]*26+text.charAt(i))%mod;\\n            pow[i]=(pow[i-1]*26)%mod;\\n        }//seting up the hash\\n        int ans=dfs(text,0,text.length()-1);\\n        return ans;\\n    }\\n    \\n    public int dfs(String text,int left,int right){\\n        if(left==right)return 1;\\n        if(left>right)return 0;\\n        int res=1;\\n        for(int len=1;len<text.length();len++){\\n            long hash1=0;long hash2=0;\\n            int leftend=left+len-1;\\n            int rightstart=right-len+1;\\n            if(leftend>=rightstart){\\n                break;\\n            }\\n            hash1=gethash(text,left,leftend);\\n            hash2=gethash(text,rightstart,right);\\n            if(hash1==hash2){\\n                if(dp[leftend+1][rightstart-1]==0){\\n                   dp[leftend+1][rightstart-1]=dfs(text,leftend+1,rightstart-1); \\n                }\\n                if(dp[leftend+1][rightstart-1]!=-1){\\n                    res=Math.max(res,2+dp[leftend+1][rightstart-1]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public long gethash(String text,int left,int right){\\n        if(left==0)return hash[right];\\n        long res=(hash[right]-hash[left-1]*pow[right-left+1])%mod;\\n        if(res<0)res+=mod;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    long hash[];\\n    long pow[];\\n    int dp[][];\\n    public int longestDecomposition(String text) {\\n        dp=new int[text.length()+1][text.length()+1];\\n        hash=new long[text.length()];\\n        pow=new long[text.length()];\\n        pow[0]=1;\\n        hash[0]=text.charAt(0)%mod;\\n        for(int i=1;i<text.length();i++){\\n            hash[i]=(hash[i-1]*26+text.charAt(i))%mod;\\n            pow[i]=(pow[i-1]*26)%mod;\\n        }//seting up the hash\\n        int ans=dfs(text,0,text.length()-1);\\n        return ans;\\n    }\\n    \\n    public int dfs(String text,int left,int right){\\n        if(left==right)return 1;\\n        if(left>right)return 0;\\n        int res=1;\\n        for(int len=1;len<text.length();len++){\\n            long hash1=0;long hash2=0;\\n            int leftend=left+len-1;\\n            int rightstart=right-len+1;\\n            if(leftend>=rightstart){\\n                break;\\n            }\\n            hash1=gethash(text,left,leftend);\\n            hash2=gethash(text,rightstart,right);\\n            if(hash1==hash2){\\n                if(dp[leftend+1][rightstart-1]==0){\\n                   dp[leftend+1][rightstart-1]=dfs(text,leftend+1,rightstart-1); \\n                }\\n                if(dp[leftend+1][rightstart-1]!=-1){\\n                    res=Math.max(res,2+dp[leftend+1][rightstart-1]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public long gethash(String text,int left,int right){\\n        if(left==0)return hash[right];\\n        long res=(hash[right]-hash[left-1]*pow[right-left+1])%mod;\\n        if(res<0)res+=mod;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479247,
                "title": "o-n-2-c-dp-might-be-easier-to-figure-out-during-the-real-interview",
                "content": "I am aware of the O(n) greedy solution, just wrote this DP solution for fun.\\nCould transform to be the greedy solution by adding a break \\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int dfs(const string &text, int l, int r) {\\n        if(r < l) return 0;\\n        if(l == r) return 1;\\n        if(dp[l][r] > 0) return dp[l][r];\\n\\t\\t\\n        int n = r - l + 1;\\n        int ans = 1;\\n        for(int len = 1; len <= n / 2; len++) {\\n            auto left = text.substr(l, len);\\n            auto right = text.substr(r - len + 1, len);\\n            if(left == right) {\\n                ans = max(ans, 2 + dfs(text, l + len, r - len));\\n\\t\\t\\t\\t// break; // if you can prove the correctness of greedy to the interviewer :)\\n            }\\n        }\\n        return dp[l][r] = ans;\\n    }\\n    \\n    int longestDecomposition(string text) {\\n        return dfs(text, 0, text.size()-1);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[1001][1001];\\n    int dfs(const string &text, int l, int r) {\\n        if(r < l) return 0;\\n        if(l == r) return 1;\\n        if(dp[l][r] > 0) return dp[l][r];\\n\\t\\t\\n        int n = r - l + 1;\\n        int ans = 1;\\n        for(int len = 1; len <= n / 2; len++) {\\n            auto left = text.substr(l, len);\\n            auto right = text.substr(r - len + 1, len);\\n            if(left == right) {\\n                ans = max(ans, 2 + dfs(text, l + len, r - len));\\n\\t\\t\\t\\t// break; // if you can prove the correctness of greedy to the interviewer :)\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 444193,
                "title": "c-prefix-pattern-table-use-logical-annotated-4ms-runtime-and-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    //Return the largest possible number of chunk that forms palindromic relationship inside the given text\\n    int longestDecomposition(string text) {\\n        if(text.empty()){ //if the given string is empty, it cannot even have a single chunk.\\n            return 0;\\n        }\\n        vector<int> pTable(text.length());//prefix pattern table essentially used in KMP algorithm\\n        //1. No segfault: since we have checked empty string case at the beginig\\n        //2. should be 0, because we are comparing the same character(\"same\" as literally same, not about their value)\\n        pTable[0] = 0;\\n        \\n        int j = 0;//j pointer pointing the next prefix candidate\\n        int i = 1;//iterating through the text string to fill up the ptable\\n        while(i < text.length()){\\n            if(text[i] == text[j]){//if their character matches\\n                pTable[i] = j + 1; //record the length of recurring prefix the string(0, i) can have\\n                ++j;\\n                ++i;\\n            }\\n            else if(j == 0){\\n                /*to prevent the infinite loop:\\n                if the two characters are different and there are no more previous characters to be comoapred\\n                then just move onto the next char in the text to fill up the table\\n                */\\n                ++i;\\n            }\\n            else{\\n                //if not match, but still there can be another possible match to previous pattern\\n                //ex) abacabab == the last abab does not match with abac but the last two character ab matches with the first ab \\n                j = pTable[j-1];\\n            }\\n        }\\n        int len = pTable[pTable.size() - 1]; //the length of the last chunk that also occuring at the beginning\\n        if(len == 0){//if there is no such chunk, then we cannot form a palindrome with multiple chunks\\n            //Therefore, the smallest palindromic chunk is the string itself.\\n            return 1;\\n        }\\n        else if(len > text.length() / 2){ //Since the chunk is greater than the (text length / 2), so we know that that pattern is continuous\\n            //In other words, the entire string is made of many of one chunk.\\n            int chunkLen = text.length() - len;//calculating the shortest chucnk length because we have to maximize the number of chunks\\n            return text.length() / chunkLen;\\n        }\\n        else{\\n            //(chunkA)(ChunkB)(chunkA) case\\n            //treat each chunk as another \"text\" string and get the largest k value of that text thru recurisve call.\\n            string midStr = text.substr(len, text.length() - (2*len));\\n            string outerStr = text.substr(0, len);\\n            return longestDecomposition(midStr) + (2 * longestDecomposition(outerStr));\\n        }\\n    }\\n};\\n```\\nPoint:\\nCore: Use Prefix Pattern Table to deductively figure out the length of each side chunk.\\n3 cases:\\n1. If the length of each side chunk is 0 --> the only possible chunk is the string itself, so return 1\\n2. If the length of each side chunk is > (text string length / 2) --> the whole string is made of many of \"one type of chunk\" --> so find the shortest possible chunk length and return (text string length / the shortest possible chunk length)\\n3. If the length of each side chuck is <= (text string length / 2) --> (chunkA)(chunkB)(chunkA) case. *Note: chunkB can be an empty string\\n--> treat each chunk as another \"text\" and get their larget possible number of chunks through recursive call.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //Return the largest possible number of chunk that forms palindromic relationship inside the given text\\n    int longestDecomposition(string text) {\\n        if(text.empty()){ //if the given string is empty, it cannot even have a single chunk.\\n            return 0;\\n        }\\n        vector<int> pTable(text.length());//prefix pattern table essentially used in KMP algorithm\\n        //1. No segfault: since we have checked empty string case at the beginig\\n        //2. should be 0, because we are comparing the same character(\"same\" as literally same, not about their value)\\n        pTable[0] = 0;\\n        \\n        int j = 0;//j pointer pointing the next prefix candidate\\n        int i = 1;//iterating through the text string to fill up the ptable\\n        while(i < text.length()){\\n            if(text[i] == text[j]){//if their character matches\\n                pTable[i] = j + 1; //record the length of recurring prefix the string(0, i) can have\\n                ++j;\\n                ++i;\\n            }\\n            else if(j == 0){\\n                /*to prevent the infinite loop:\\n                if the two characters are different and there are no more previous characters to be comoapred\\n                then just move onto the next char in the text to fill up the table\\n                */\\n                ++i;\\n            }\\n            else{\\n                //if not match, but still there can be another possible match to previous pattern\\n                //ex) abacabab == the last abab does not match with abac but the last two character ab matches with the first ab \\n                j = pTable[j-1];\\n            }\\n        }\\n        int len = pTable[pTable.size() - 1]; //the length of the last chunk that also occuring at the beginning\\n        if(len == 0){//if there is no such chunk, then we cannot form a palindrome with multiple chunks\\n            //Therefore, the smallest palindromic chunk is the string itself.\\n            return 1;\\n        }\\n        else if(len > text.length() / 2){ //Since the chunk is greater than the (text length / 2), so we know that that pattern is continuous\\n            //In other words, the entire string is made of many of one chunk.\\n            int chunkLen = text.length() - len;//calculating the shortest chucnk length because we have to maximize the number of chunks\\n            return text.length() / chunkLen;\\n        }\\n        else{\\n            //(chunkA)(ChunkB)(chunkA) case\\n            //treat each chunk as another \"text\" string and get the largest k value of that text thru recurisve call.\\n            string midStr = text.substr(len, text.length() - (2*len));\\n            string outerStr = text.substr(0, len);\\n            return longestDecomposition(midStr) + (2 * longestDecomposition(outerStr));\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433019,
                "title": "one-pass-iteration-count-letters-very-very-esay-0-ms",
                "content": "### Solution 1\\n\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Longest Chunked Palindrome Decomposition.\\nMemory Usage: 9.3 MB, less than 100.00% of C++ online submissions for Longest Chunked Palindrome Decomposition.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestDecomposition(string& text) {\\n        string rtext(text.rbegin(), text.rend());   // reversed text\\n        map<char, int> cnts;\\n        int ret = 0, pos = 0, size = text.size();\\n        while (pos < size) {\\n            ++cnts[text[pos]];\\n            if (cnts[text[pos]] == 0) cnts.erase(text[pos]);\\n            --cnts[rtext[pos]];\\n            if (cnts[rtext[pos]] == 0) cnts.erase(rtext[pos]);\\n            if (cnts.empty()) ++ret;\\n            ++pos;\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\n\\n### Solution 2 ( Modified Solution 1, remove redundant memory and calculation)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestDecomposition(string& text) {\\n        map<char, int> cnts;\\n        int ret = 0, left = 0, right = text.size() - 1;\\n        while (left < right) {\\n            char ch = text[left];\\n            ++cnts[ch];\\n            if (cnts[ch] == 0) cnts.erase(ch);\\n\\n            ch = text[right];\\n            --cnts[ch];\\n            if (cnts[ch] == 0) cnts.erase(ch);\\n\\n            if (cnts.empty()) ret += 2;\\n            ++left;\\n            --right;\\n        }\\n        if (left == right || !cnts.empty()) ++ret;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestDecomposition(string& text) {\\n        string rtext(text.rbegin(), text.rend());   // reversed text\\n        map<char, int> cnts;\\n        int ret = 0, pos = 0, size = text.size();\\n        while (pos < size) {\\n            ++cnts[text[pos]];\\n            if (cnts[text[pos]] == 0) cnts.erase(text[pos]);\\n            --cnts[rtext[pos]];\\n            if (cnts[rtext[pos]] == 0) cnts.erase(rtext[pos]);\\n            if (cnts.empty()) ++ret;\\n            ++pos;\\n        }\\n        return ret;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int longestDecomposition(string& text) {\\n        map<char, int> cnts;\\n        int ret = 0, left = 0, right = text.size() - 1;\\n        while (left < right) {\\n            char ch = text[left];\\n            ++cnts[ch];\\n            if (cnts[ch] == 0) cnts.erase(ch);\\n\\n            ch = text[right];\\n            --cnts[ch];\\n            if (cnts[ch] == 0) cnts.erase(ch);\\n\\n            if (cnts.empty()) ret += 2;\\n            ++left;\\n            --right;\\n        }\\n        if (left == right || !cnts.empty()) ++ret;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416596,
                "title": "c-o-n-beats-100-simple-rolling-hash",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int l = 0;\\n        int r = text.size() - 1;\\n        int hl = 0;\\n        int hr = 0;\\n        int p = 100007;\\n        int d = 256;\\n        int countr = 1;\\n        int ans = 0;\\n        while(l < r) {\\n            hl = (hl*d+text[l])%p;\\n            hr = (countr*text[r] + hr)%p;\\n            countr = (countr*d)%p;\\n            if(hl == hr) {\\n                ans+=2;\\n                hl = 0;\\n                hr = 0;\\n                countr = 1;\\n            }\\n            l++;\\n            r--;\\n        }\\n        if(countr==1){\\n            if(l==r)\\n                ans++;\\n        } else {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int l = 0;\\n        int r = text.size() - 1;\\n        int hl = 0;\\n        int hr = 0;\\n        int p = 100007;\\n        int d = 256;\\n        int countr = 1;\\n        int ans = 0;\\n        while(l < r) {\\n            hl = (hl*d+text[l])%p;\\n            hr = (countr*text[r] + hr)%p;\\n            countr = (countr*d)%p;\\n            if(hl == hr) {\\n                ans+=2;\\n                hl = 0;\\n                hr = 0;\\n                countr = 1;\\n            }\\n            l++;\\n            r--;\\n        }\\n        if(countr==1){\\n            if(l==r)\\n                ans++;\\n        } else {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371020,
                "title": "java-rolling-hash-o-n-runtime-90",
                "content": "```\\n    int mod = 1000000007;\\n    public int longestDecomposition(String text) {\\n        int n = text.length();\\n        int p1 = 0, p2 = n-1;\\n        int res = 0;\\n        long h1 = 0;\\n        long h2 = 0;\\n        long base = 35;\\n        long pow = 1;\\n        while(p1<=p2){\\n            h1 = (h1*base%mod + (text.charAt(p1)-\\'a\\'+1))%mod;\\n            h2 = (h2+(text.charAt(p2)-\\'a\\'+1)*pow%mod)%mod;\\n            pow = pow*base%mod;\\n            if(h1==h2){\\n                res += p1==p2 ? 1 : 2;\\n                h1 = 0;\\n                h2 = 0;\\n                pow = 1;\\n            }\\n            p1++;\\n            p2--;\\n        }\\n        return h1>0 ? res+1 : res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    int mod = 1000000007;\\n    public int longestDecomposition(String text) {\\n        int n = text.length();\\n        int p1 = 0, p2 = n-1;\\n        int res = 0;\\n        long h1 = 0;\\n        long h2 = 0;\\n        long base = 35;\\n        long pow = 1;\\n        while(p1<=p2){\\n            h1 = (h1*base%mod + (text.charAt(p1)-\\'a\\'+1))%mod;\\n            h2 = (h2+(text.charAt(p2)-\\'a\\'+1)*pow%mod)%mod;\\n            pow = pow*base%mod;\\n            if(h1==h2){\\n                res += p1==p2 ? 1 : 2;\\n                h1 = 0;\\n                h2 = 0;\\n                pow = 1;\\n            }\\n            p1++;\\n            p2--;\\n        }\\n        return h1>0 ? res+1 : res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 357589,
                "title": "lc1147-longest-chunked-palindrome-greedy-in-disguise-with-console-output-for-better-understanding",
                "content": "This solution is taken from - [Java/C++/Python Easy Greedy with Proof](http://leetcode.com/problems/longest-chunked-palindrome-decomposition/discuss/350560/JavaC%2B%2BPython-Easy-Greedy-with-Prove) iterative solution.\\nand seems to be one of easier to understand in the discuss section. There are several variations of the same approach.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        string left= \"\", right=\"\";\\n        int count = 0, i=0;\\n        bool consumed;\\n        for(;i < n/2; i++){\\n            consumed = false;\\n            left = left + text[i];\\n            right= text[n-i-1] + right;\\n            if(left == right){\\n                count+=2;\\n                consumed = true;\\n                left = \"\"; right =\"\";\\n            }\\n        }\\n        \\n        return consumed && i == n/2 + n%2?count : count +1; \\n    }\\n};\\n```\\n\\n\\nBelow is the console log.\\nFormat is  **left_string--right_string; left_string--right string;  ... left_string--right string; count**\\n\\n1. `input string - \"ghiabcdefhelloadamhelloabcdefghi\"`\\n\\n```\\n\\tg--i ; gh--hi ; ghi--ghi ; 1\\n\\ta--f ; ab--ef ; abc--def ; abcd--cdef ; abcde--bcdef ; abcdef--abcdef ; 2\\n\\th--o ; he--lo ; hel--llo ; hell--ello ; hello--hello ; 3\\n\\ta--m ; ad--am ; ada--dam ; adam--adam ; 4\\n\\th--o ; he--lo ; hel--llo ; hell--ello ; hello--hello ; 5\\n\\ta--f ; ab--ef ; abc--def ; abcd--cdef ; abcde--bcdef ; abcdef--abcdef ; 6\\n\\tg--i ; gh--hi ; ghi--ghi ; 7\\n\\nreturns 7 as answer\\n```\\n\\n\\n2. `\"leetcodeshallcodeleet\"`\\n\\n```\\nl--t ; le--et ; lee--eet ; leet--leet ; 1\\nc--e ; co--de ; cod--ode ; code--code ; 2\\ns--l ; sh--ll ; sha--all ; shal--hall ; shall--shall ; 3\\nc--e ; co--de ; cod--ode ; code--code ; 4\\nl--t ; le--et ; lee--eet ; leet--leet ; 5\\n\\nreturns 5 as answer\\n```\\n\\n3. `\"merchant\"`\\n```\\nm--t ; me--nt ; mer--ant ; merc--hant ; merch--chant ; mercha--rchant ; merchan--erchant ; merchant--merchant ; 1\\n\\nreturns 1 as answer\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        string left= \"\", right=\"\";\\n        int count = 0, i=0;\\n        bool consumed;\\n        for(;i < n/2; i++){\\n            consumed = false;\\n            left = left + text[i];\\n            right= text[n-i-1] + right;\\n            if(left == right){\\n                count+=2;\\n                consumed = true;\\n                left = \"\"; right =\"\";\\n            }\\n        }\\n        \\n        return consumed && i == n/2 + n%2?count : count +1; \\n    }\\n};\\n```\n```\\n\\tg--i ; gh--hi ; ghi--ghi ; 1\\n\\ta--f ; ab--ef ; abc--def ; abcd--cdef ; abcde--bcdef ; abcdef--abcdef ; 2\\n\\th--o ; he--lo ; hel--llo ; hell--ello ; hello--hello ; 3\\n\\ta--m ; ad--am ; ada--dam ; adam--adam ; 4\\n\\th--o ; he--lo ; hel--llo ; hell--ello ; hello--hello ; 5\\n\\ta--f ; ab--ef ; abc--def ; abcd--cdef ; abcde--bcdef ; abcdef--abcdef ; 6\\n\\tg--i ; gh--hi ; ghi--ghi ; 7\\n\\nreturns 7 as answer\\n```\n```\\nl--t ; le--et ; lee--eet ; leet--leet ; 1\\nc--e ; co--de ; cod--ode ; code--code ; 2\\ns--l ; sh--ll ; sha--all ; shal--hall ; shall--shall ; 3\\nc--e ; co--de ; cod--ode ; code--code ; 4\\nl--t ; le--et ; lee--eet ; leet--leet ; 5\\n\\nreturns 5 as answer\\n```\n```\\nm--t ; me--nt ; mer--ant ; merc--hant ; merch--chant ; mercha--rchant ; merchan--erchant ; merchant--merchant ; 1\\n\\nreturns 1 as answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355702,
                "title": "beat-100-java-rolling-hash",
                "content": "\\n```java\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int leftHash = 0;\\n        int rightHash = 0;\\n        int n = text.length();\\n        int cur = 1;\\n        int res = 0;\\n        int l = 0;\\n        int r = n - 1;\\n        while(l < r) {\\n            leftHash = 26 * leftHash + (text.charAt(l) - \\'a\\') ;\\n            rightHash = rightHash + (text.charAt(r) - \\'a\\') * cur;\\n            cur *= 26;\\n            \\n            if (leftHash == rightHash) {\\n                leftHash = 0;\\n                rightHash = 0;\\n                res += 2;\\n                cur = 1;\\n            }\\n            l++;\\n            r--; \\n        }\\n        if (l > r && leftHash != rightHash) {\\n            res += 1;\\n        }\\n        if (l == r) {\\n            res += 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Rolling Hash"
                ],
                "code": "```java\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int leftHash = 0;\\n        int rightHash = 0;\\n        int n = text.length();\\n        int cur = 1;\\n        int res = 0;\\n        int l = 0;\\n        int r = n - 1;\\n        while(l < r) {\\n            leftHash = 26 * leftHash + (text.charAt(l) - \\'a\\') ;\\n            rightHash = rightHash + (text.charAt(r) - \\'a\\') * cur;\\n            cur *= 26;\\n            \\n            if (leftHash == rightHash) {\\n                leftHash = 0;\\n                rightHash = 0;\\n                res += 2;\\n                cur = 1;\\n            }\\n            l++;\\n            r--; \\n        }\\n        if (l > r && leftHash != rightHash) {\\n            res += 1;\\n        }\\n        if (l == r) {\\n            res += 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353298,
                "title": "simple-recursive-c",
                "content": "We simply want to find the shortest substring that exists on both ends of the larger string. If there no such pair exists, we return 1 representing the entire string. We can stop when we find the shortest as this will give us the max number of possibilities, i.e. any larger substrings that match on both ends can be split into more substrings giving us a larger total.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        if (text.empty()) return 0;\\n        int i = 1;\\n        while (i < text.size() && text.substr(0, i) != text.substr(text.size() - i, i)) i++;\\n        \\n        if (i >= text.size()) return 1;\\n        return 2 + longestDecomposition(text.substr(i, text.size() - 2*i));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        if (text.empty()) return 0;\\n        int i = 1;\\n        while (i < text.size() && text.substr(0, i) != text.substr(text.size() - i, i)) i++;\\n        \\n        if (i >= text.size()) return 1;\\n        return 2 + longestDecomposition(text.substr(i, text.size() - 2*i));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351120,
                "title": "greedy-9-lines",
                "content": "```\\n    int longestDecomposition(string text) {\\n        if(text.size() == 0){  return 0;}\\n        for(int i = 1;i <= text.size()/2; ++i){\\n           if(text.substr(0,i) == text.substr(n-i,i)){\\n               return 2 + longestDecomposition(text.substr(i,n-2*i));\\n           }\\n        }\\n        return 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int longestDecomposition(string text) {\\n        if(text.size() == 0){  return 0;}\\n        for(int i = 1;i <= text.size()/2; ++i){\\n           if(text.substr(0,i) == text.substr(n-i,i)){\\n               return 2 + longestDecomposition(text.substr(i,n-2*i));\\n           }\\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 351101,
                "title": "java-recursion",
                "content": "```\\n\\tpublic static int longestDecomposition(String text) {\\n        if (text.length() == 0) {\\n            return 0;\\n        }\\n        for (int i = 1; i * 2 <= text.length(); i++) {\\n            String front = text.substring(0, i);\\n            String end = text.substring(text.length() - i);\\n            if (front.equals(end)) {\\n                return 2 + longestDecomposition(text.substring(i,\\n                        text.length() - i));\\n            }\\n        }\\n        return 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic static int longestDecomposition(String text) {\\n        if (text.length() == 0) {\\n            return 0;\\n        }\\n        for (int i = 1; i * 2 <= text.length(); i++) {\\n            String front = text.substring(0, i);\\n            String end = text.substring(text.length() - i);\\n            if (front.equals(end)) {\\n                return 2 + longestDecomposition(text.substring(i,\\n                        text.length() - i));\\n            }\\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350780,
                "title": "java-dfs-memorization",
                "content": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        return dfs(text, new HashMap<>());\\n    }\\n    \\n    private int dfs(String text, Map<String, Integer> cache) {\\n        int n = text.length();\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (cache.containsKey(text)) {\\n            return cache.get(text);\\n        }\\n        int max = 1;\\n        for (int i = 0; i < n / 2; i++) {\\n            if (text.substring(0, i + 1).equals(text.substring(n - 1 - i))) {\\n                max = Math.max(max, 2 + dfs(text.substring(i + 1, n - 1 - i), cache));\\n            }\\n        }\\n        cache.put(text, max);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        return dfs(text, new HashMap<>());\\n    }\\n    \\n    private int dfs(String text, Map<String, Integer> cache) {\\n        int n = text.length();\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (cache.containsKey(text)) {\\n            return cache.get(text);\\n        }\\n        int max = 1;\\n        for (int i = 0; i < n / 2; i++) {\\n            if (text.substring(0, i + 1).equals(text.substring(n - 1 - i))) {\\n                max = Math.max(max, 2 + dfs(text.substring(i + 1, n - 1 - i), cache));\\n            }\\n        }\\n        cache.put(text, max);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350630,
                "title": "c-greedy-o-n-2",
                "content": "```\\nclass Solution {\\n    int solve(const string &text, int lo, int hi) {\\n        if(lo == hi) return 1;\\n        if(lo > hi) return 0;\\n        for(int len=1;lo+len-1<hi-len+1;len++) {\\n            if(text.substr(lo, len) == text.substr(hi-len+1, len)) return solve(text, lo + len, hi - len) + 2;\\n        }\\n        return 1;\\n    }\\npublic:\\n    int longestDecomposition(string text) {        \\n        int n = text.size();\\n        return solve(text, 0, n - 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int solve(const string &text, int lo, int hi) {\\n        if(lo == hi) return 1;\\n        if(lo > hi) return 0;\\n        for(int len=1;lo+len-1<hi-len+1;len++) {\\n            if(text.substr(lo, len) == text.substr(hi-len+1, len)) return solve(text, lo + len, hi - len) + 2;\\n        }\\n        return 1;\\n    }\\npublic:\\n    int longestDecomposition(string text) {        \\n        int n = text.size();\\n        return solve(text, 0, n - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093687,
                "title": "very-short-and-clean-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nVery beginner level solution\\niterating through the string and checking left and right are equal\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int i =0;\\n        int j = 0;\\n        int last = text.size()-1;\\n        int count = 0;\\n        for(int i =0;i<text.size();i++){\\n            if(text.substr(j, i-j+1)==text.substr(last-i+j, i-j+1)){\\n                count++;\\n                last-=(i-j+1);\\n                j= i+1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int i =0;\\n        int j = 0;\\n        int last = text.size()-1;\\n        int count = 0;\\n        for(int i =0;i<text.size();i++){\\n            if(text.substr(j, i-j+1)==text.substr(last-i+j, i-j+1)){\\n                count++;\\n                last-=(i-j+1);\\n                j= i+1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078310,
                "title": "easy-kotlin-solution-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun longestDecomposition(text: String): Int {\\n        val n = text.length\\n        var largestK = 0\\n        var left = \"\"\\n        var right = \"\"\\n        \\n        for (i in 0 until n) {\\n            left = left + text[i]\\n            right = text[n - i - 1] + right\\n            \\n            if (left == right) {\\n                largestK += 1\\n                left = \"\"\\n                right = \"\"\\n            }\\n        }\\n        \\n        return largestK\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun longestDecomposition(text: String): Int {\\n        val n = text.length\\n        var largestK = 0\\n        var left = \"\"\\n        var right = \"\"\\n        \\n        for (i in 0 until n) {\\n            left = left + text[i]\\n            right = text[n - i - 1] + right\\n            \\n            if (left == right) {\\n                largestK += 1\\n                left = \"\"\\n                right = \"\"\\n            }\\n        }\\n        \\n        return largestK\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061055,
                "title": "c-magic-happen-recursive-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\nIf anything wrong let me know...\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nonly recursive stack\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int recursion(string &s, int l, int r){\\n        if(l > r) return 0;\\n        if(l == r) return 1;\\n\\n        int boundary = (l + r - 1) / 2;\\n        int ans = 0;\\n        bool comp = false;\\n        for(int i = r; i > boundary; i--){\\n            bool flg = true;\\n            for(int j = 0; j <= (r-i); j++){\\n                if(s[l + j] != s[i + j]){\\n                    flg = false;\\n                    break;\\n                }\\n            }\\n            if(flg){\\n                comp = true;\\n                ans = max(ans, recursion(s, l + (r - i) + 1, r - (r - i) - 1));\\n            }\\n            if(flg) break;\\n        }\\n        if(!comp) return 1;\\n        return ans+2;\\n    }\\n\\n    int longestDecomposition(string text) {\\n        return recursion(text, 0, text.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int recursion(string &s, int l, int r){\\n        if(l > r) return 0;\\n        if(l == r) return 1;\\n\\n        int boundary = (l + r - 1) / 2;\\n        int ans = 0;\\n        bool comp = false;\\n        for(int i = r; i > boundary; i--){\\n            bool flg = true;\\n            for(int j = 0; j <= (r-i); j++){\\n                if(s[l + j] != s[i + j]){\\n                    flg = false;\\n                    break;\\n                }\\n            }\\n            if(flg){\\n                comp = true;\\n                ans = max(ans, recursion(s, l + (r - i) + 1, r - (r - i) - 1));\\n            }\\n            if(flg) break;\\n        }\\n        if(!comp) return 1;\\n        return ans+2;\\n    }\\n\\n    int longestDecomposition(string text) {\\n        return recursion(text, 0, text.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043630,
                "title": "dp-intuitive-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    int solve(string &text){\\n        if(text==\"\") return 0;\\n        int ans=1;\\n        if(mp.find(text)!=mp.end()) return mp[text];\\n        for(int i=1;i<text.size();i++){\\n            string sub=text.substr(0,i);\\n            string rev=text.substr(text.size()-i,i);\\n            if(sub==rev){\\n                string news=text.substr(i,text.size()-2*i);\\n                ans=max(ans,2+solve(news));\\n            }\\n        }\\n        return mp[text]=ans;\\n    }\\n\\n    int longestDecomposition(string text) {\\n        return solve(text);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    int solve(string &text){\\n        if(text==\"\") return 0;\\n        int ans=1;\\n        if(mp.find(text)!=mp.end()) return mp[text];\\n        for(int i=1;i<text.size();i++){\\n            string sub=text.substr(0,i);\\n            string rev=text.substr(text.size()-i,i);\\n            if(sub==rev){\\n                string news=text.substr(i,text.size()-2*i);\\n                ans=max(ans,2+solve(news));\\n            }\\n        }\\n        return mp[text]=ans;\\n    }\\n\\n    int longestDecomposition(string text) {\\n        return solve(text);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990682,
                "title": "begginer-friendly-java-code-beats-52-58",
                "content": "# Code\\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        Map<Character,Integer> map1=new HashMap<>();\\n        Map<Character,Integer> map2=new HashMap<>();\\n        StringBuilder check=new StringBuilder(text);\\n        char[] str=text.toCharArray();\\n        int i=0,j=str.length-1;\\n        int count=0;\\n        int start=0;\\n        int end=str.length;\\n        while(i<j){\\n            map1.put(str[i],map1.getOrDefault(str[i],0)+1);\\n            map2.put(str[j],map2.getOrDefault(str[j],0)+1);\\n            if(map1.equals(map2)){\\n                if(check.substring(start,i+1).equals(check.substring(j,end))){\\n                    start=i+1;\\n                    end=j;\\n                    count+=2;\\n                    map1.clear();\\n                    map2.clear();\\n                } \\n            }\\n            j--;\\n            i++;\\n        }\\n        if(str.length%2==0 && map1.size()==0) return count;\\n        return count+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        Map<Character,Integer> map1=new HashMap<>();\\n        Map<Character,Integer> map2=new HashMap<>();\\n        StringBuilder check=new StringBuilder(text);\\n        char[] str=text.toCharArray();\\n        int i=0,j=str.length-1;\\n        int count=0;\\n        int start=0;\\n        int end=str.length;\\n        while(i<j){\\n            map1.put(str[i],map1.getOrDefault(str[i],0)+1);\\n            map2.put(str[j],map2.getOrDefault(str[j],0)+1);\\n            if(map1.equals(map2)){\\n                if(check.substring(start,i+1).equals(check.substring(j,end))){\\n                    start=i+1;\\n                    end=j;\\n                    count+=2;\\n                    map1.clear();\\n                    map2.clear();\\n                } \\n            }\\n            j--;\\n            i++;\\n        }\\n        if(str.length%2==0 && map1.size()==0) return count;\\n        return count+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979969,
                "title": "lcp-array-and-dp",
                "content": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        lcp = [[0] * n for _ in range(n)]\\n        dp = [1] * n\\n        if n % 2 == 0:\\n            dp[n // 2] = 0\\n        for i in range(n - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                lcp[i][j] = 1 + lcp[i + 1][j + 1] if i + 1 < n and j + 1 < n else 1\\n                if text[i] != text[j]:\\n                    lcp[i][j] = 0\\n        for i in range(n // 2, -1, -1):\\n            for l in range(1, 1 + (n - 2 * i) // 2):\\n                if lcp[i][n - i - l] >= l:\\n                    dp[i] = max(dp[i], 2 + dp[i + l])\\n        return dp[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        lcp = [[0] * n for _ in range(n)]\\n        dp = [1] * n\\n        if n % 2 == 0:\\n            dp[n // 2] = 0\\n        for i in range(n - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                lcp[i][j] = 1 + lcp[i + 1][j + 1] if i + 1 < n and j + 1 < n else 1\\n                if text[i] != text[j]:\\n                    lcp[i][j] = 0\\n        for i in range(n // 2, -1, -1):\\n            for l in range(1, 1 + (n - 2 * i) // 2):\\n                if lcp[i][n - i - l] >= l:\\n                    dp[i] = max(dp[i], 2 + dp[i + l])\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978375,
                "title": "two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        int result = 0;\\n        \\n        string left = \"\";\\n        string right = \"\";\\n        \\n        for (int i = 0; i < n; ++i) {\\n            left += text[i];\\n            right = text[n - i - 1] + right;\\n            \\n            if (left == right) {\\n                ++result;\\n                left = \"\";\\n                right = \"\";\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        int result = 0;\\n        \\n        string left = \"\";\\n        string right = \"\";\\n        \\n        for (int i = 0; i < n; ++i) {\\n            left += text[i];\\n            right = text[n - i - 1] + right;\\n            \\n            if (left == right) {\\n                ++result;\\n                left = \"\";\\n                right = \"\";\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932951,
                "title": "dp-rabin-karp-c-easy-solution",
                "content": "# Intuition\\nComparison can be optimized using Rabin Karp other than that its simple dp problem\\n\\n# Approach\\nIterate through the starting point while keeping the ending point to be compared with and use dp to check the maximum value.\\n\\n# Complexity\\n\\n- Space complexity:\\n    O(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const long factor = 26;\\n    const long MOD = 1e9+7;\\n    bool check(string &text, int l, int r, int end, vector<long>&val, vector<long> &calc)\\n    {\\n        if(((val[r] - (l==0?0:val[l-1])+ MOD ) * calc[end - (r-l)]) % MOD == ((val[end] - val[end-(r-l)-1] + MOD) * calc[l])%MOD)\\n            return true;\\n        return false;   \\n    }\\n    int find(vector<vector<int>> &dp, int idx, int end, vector<long> &val, string &text, vector<long> &calc)\\n    {\\n        if(idx==end)\\n            return 1;\\n        if(idx>=text.length()/2)\\n            return 0;\\n        if(dp[idx][end]!=-1)\\n            return dp[idx][end];\\n        for(int i=idx;i<text.size()/2;i++)\\n        {\\n            if(check(text, idx, i, end, val, calc))\\n                dp[idx][end]=max(dp[idx][end], find(dp, i+1, end-(i-idx)-1, val, text, calc)+2);\\n        }\\n        return dp[idx][end]==-1?1:dp[idx][end];\\n    }\\n    int longestDecomposition(string text) {\\n        vector<long> calc(text.size()+1), val(text.size()+1);\\n        for(int i=0;i<calc.size();i++)\\n        {\\n            if(i==0)\\n                calc[i]=1;\\n            else\\n                calc[i]=(calc[i-1]*factor)%MOD;\\n        }\\n        int val_of_b=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            val_of_b = (val_of_b + ((text[i]-\\'a\\'+1) * calc[i])%MOD)%MOD;\\n            val[i]=val_of_b;\\n        }\\n        vector<vector<int>>dp(text.size(), vector<int>(text.size(), -1));\\n        return find(dp, 0, text.size()-1, val, text, calc);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const long factor = 26;\\n    const long MOD = 1e9+7;\\n    bool check(string &text, int l, int r, int end, vector<long>&val, vector<long> &calc)\\n    {\\n        if(((val[r] - (l==0?0:val[l-1])+ MOD ) * calc[end - (r-l)]) % MOD == ((val[end] - val[end-(r-l)-1] + MOD) * calc[l])%MOD)\\n            return true;\\n        return false;   \\n    }\\n    int find(vector<vector<int>> &dp, int idx, int end, vector<long> &val, string &text, vector<long> &calc)\\n    {\\n        if(idx==end)\\n            return 1;\\n        if(idx>=text.length()/2)\\n            return 0;\\n        if(dp[idx][end]!=-1)\\n            return dp[idx][end];\\n        for(int i=idx;i<text.size()/2;i++)\\n        {\\n            if(check(text, idx, i, end, val, calc))\\n                dp[idx][end]=max(dp[idx][end], find(dp, i+1, end-(i-idx)-1, val, text, calc)+2);\\n        }\\n        return dp[idx][end]==-1?1:dp[idx][end];\\n    }\\n    int longestDecomposition(string text) {\\n        vector<long> calc(text.size()+1), val(text.size()+1);\\n        for(int i=0;i<calc.size();i++)\\n        {\\n            if(i==0)\\n                calc[i]=1;\\n            else\\n                calc[i]=(calc[i-1]*factor)%MOD;\\n        }\\n        int val_of_b=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            val_of_b = (val_of_b + ((text[i]-\\'a\\'+1) * calc[i])%MOD)%MOD;\\n            val[i]=val_of_b;\\n        }\\n        vector<vector<int>>dp(text.size(), vector<int>(text.size(), -1));\\n        return find(dp, 0, text.size()-1, val, text, calc);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872115,
                "title": "not-hard-beats-97-41",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n      low = 0\\n      high = len(text)-1\\n      ans=0\\n      while high-low>0:\\n        if text[:low+1]==text[high:]:\\n          ans += 2\\n          text=text[low+1:high]\\n          low=0\\n          high=len(text)-1\\n          continue\\n        low +=1\\n        high -=1\\n      if len(text)>0:\\n        ans +=1\\n      return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n      low = 0\\n      high = len(text)-1\\n      ans=0\\n      while high-low>0:\\n        if text[:low+1]==text[high:]:\\n          ans += 2\\n          text=text[low+1:high]\\n          low=0\\n          high=len(text)-1\\n          continue\\n        low +=1\\n        high -=1\\n      if len(text)>0:\\n        ans +=1\\n      return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849429,
                "title": "o-nlogn-time-o-n-space-using-sa-lcp-segment-tree-for-lce",
                "content": "The regular two-pointer approach is good, but if we do a regular string comparison, that comparision takes `O(n)` worst case, and gives a runtime of `O(n^2)`.\\n\\nOur string comparisons can be considered \"longest common extension\" (LCE) queries -- given indices `i` and `j`, what is the longest length `l` where `s[i:i+l] == s[j:j+l]`.\\n\\nLCE queries can be implemented by range-maximum queries (RMQ) over the longest common prefix (LCP) array.\\n\\nThe LCP array is an augmentation of the suffix array (SA) that stores the longest common prefix between two lexicographically neighboring suffixes.\\n\\nThe SA construction takes `O(n)` using SA-IS, the LCP construction takes `O(n)` using Kasai\\'s, and a segment tree construction for RMQ takes `O(n)`.\\nThen, each LCE query takes `O(logn)`, and we do `O(n)` of them, so the total runtime is `O(nlogn)`.\\n\\n```\\n/**\\n * Suffix array\\n * Uses SA-IS\\n *\\n * @param str A sequence of characters, with unique lexicographically smallest\\n * sentinel at the end\\n */\\ntemplate <typename Ti, typename Ts>\\nstd::vector<Ti> sais(Ts str) {\\n        Ti len = str.size();\\n        //Keep track of S(maller)=false or L(arger)=true type suffix\\n        //Sentinel is implicitly set to S already\\n        std::vector<bool> types(len);\\n        //Build types array by iterating right to left\\n        for (Ti i = len - 1; i-- > 0; types[i] = str[i] > str[i + 1] || str[i] == str[i + 1] && types[i + 1]);\\n\\n        //Find Left-Most S-type suffixes\\n        std::vector<Ti> lms;\\n        std::vector<bool> is_lms(len);\\n        for (Ti i = 0; ++i < len; types[i - 1] && !types[i] && (lms.push_back(i), is_lms[i] = true));\\n\\n        //Count character frequencies\\n        std::vector<Ti> freq;\\n        for (Ti i = len; i-- > 0; str[i] < freq.size() || (freq.resize(str[i] + 1), true), freq[str[i]]++);\\n\\n        /**\\n         * Induced sorting procedure\\n         *\\n         * @param lms LMS suffixes to put into the buckets\\n         */\\n        const auto induced_sort = [&](const std::vector<Ti>& lms) {\\n                Ti alphalen = freq.size();\\n                //Calculate bucket begin and end indicies\\n                std::vector<Ti> bkt_begin, bkt_end;\\n                bkt_begin.reserve(alphalen);\\n                bkt_end.reserve(alphalen);\\n                bkt_begin.push_back(0);\\n                bkt_end.push_back(freq[0]);\\n                for (Ti i = 0; ++i < alphalen; (bkt_begin.push_back(bkt_begin[i - 1] + freq[i - 1]), bkt_end.push_back(bkt_begin[i] + freq[i])));\\n\\n                std::vector<Ti> ret(len);\\n\\n                //Put lms suffixes at ends of buckets\\n                std::vector<Ti> bkt_end_copy(bkt_end);\\n                for (Ti i = lms.size(); i-- > 0; ret[--bkt_end[str[lms[i]]]] = lms[i]);\\n\\n                //Restore bkt_end\\n                bkt_end = std::move(bkt_end_copy);\\n\\n                //Place L-type suffixes at beginning of buckets\\n                for (Ti i = -1; ++i < len; ret[i] && types[ret[i] - 1] && (ret[bkt_begin[str[ret[i] - 1]]++] = ret[i] - 1));\\n\\n                //Place S-type suffixes at end of buckets\\n                for (Ti i = len; i-- > 0; ret[i] && !types[ret[i] - 1] && (ret[--bkt_end[str[ret[i] - 1]]] = ret[i] - 1));\\n\\n                return ret;\\n        };\\n\\n        //Run induced sorting using the LMS suffixes in the order they appear\\n        std::vector<Ti> sorted_blocks = induced_sort(lms);\\n\\n        //Number the LMS blocks, assigning duplicate blocks the same number\\n        const auto lms_block_equal = [&](Ti a, Ti b) {\\n                for (bool seen_l = false; !seen_l || types[a] || types[b]; seen_l |= types[a++] | types[b++]) {\\n                        if (str[a] != str[b] || types[a] != types[b])\\n                                return false;\\n                }\\n                return str[a] == str[b];\\n        };\\n        std::vector<Ti> lms_number_map(len);\\n        bool all_unique = true;\\n        for (Ti i, last_used_num = i = 0, prevlms = len - 1, curlms; ++i < len; is_lms[curlms = sorted_blocks[i]] && (lms_number_map[curlms] = lms_block_equal(curlms, prevlms) ? (all_unique = false, last_used_num) : ++last_used_num, prevlms = curlms));\\n\\n        //Form reduced string from block numbers\\n        std::vector<Ti> reduced;\\n        reduced.reserve(lms.size());\\n        for (const auto& i : lms) reduced.push_back(lms_number_map[i]);\\n\\n        std::vector<Ti> reduced_sa;\\n        if (all_unique) {\\n                //If all blocks are unique, directly invert\\n                reduced_sa.resize(lms.size());\\n                for (Ti i = lms.size(); i-- > 0; reduced_sa[reduced[i]] = i);\\n        } else {\\n                //Otherwise, recurse\\n                reduced_sa = sais<Ti>(reduced);\\n        }\\n\\n        //Use reduced suffix array to sort the LMS suffixes\\n        std::vector<Ti> sorted_lms;\\n        sorted_lms.reserve(lms.size());\\n        for (const auto& i : reduced_sa) sorted_lms.push_back(lms[i]);\\n\\n        //Do a second induced sorting pass of T using the LMS suffixes in sorted order.\\n        return induced_sort(sorted_lms);\\n}\\n\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        text += \\'$\\';\\n        int n = text.size();\\n        auto sa = sais<int>(text);\\n        std::vector<int> sainv(n);\\n        for (int i = 0; i < n; ++i) {\\n            sainv[sa[i]] = i;\\n        }\\n        std::vector<int> lcp(2 * n);\\n        for (int i = 0, l = 0; i < n - 1; ++i) {\\n            int p = sa[sainv[i] - 1];\\n            while (text[i + l] == text[p + l]) ++l;\\n            lcp[n + sainv[i]] = l;\\n            if (l > 0) --l;\\n        }\\n        for (int i = n; --i; ) {\\n            lcp[i] = std::min(lcp[i << 1], lcp[i << 1 | 1]);\\n        }\\n        const auto lce = [&](int i, int j) {\\n            int l = sainv[i];\\n            int r = sainv[j];\\n            if (l > r) std::swap(l, r);\\n            int ret = n;\\n            for (l += 1 + n, r += 1 + n; l < r; l >>= 1, r >>= 1) {\\n                if (l & 1) ret = std::min(ret, lcp[l++]);\\n                if (r & 1) ret = std::min(ret, lcp[--r]);\\n            }\\n            return ret;\\n        };\\n        int groups = 0;\\n        int l = 0;\\n        // for (int i = 0; i < n; ++i) {\\n        //     std::cout << i << \":\" << sa[i] << \",\" << text.substr(sa[i]) << \",\" << lcp[n + i] << std::endl;\\n        // }\\n        for (int i = 0, j = n - 1; ++l, i < --j; ) {\\n            // std::cout << \"comparing\" << i << \",\" << j << \":\" << lce(i, j) << \">=\" << l << std::endl;\\n            if (lce(i, j) >= l) {\\n                i += l;\\n                groups += 2;\\n                l = 0;\\n                if (i >= j) break;\\n            }\\n        }\\n        if (l > 0) ++groups;\\n        return groups;\\n    }\\n};\\n```\\n\\nTheoretically, LCE queries can be improved to `O(1)` using a sparse table, but then the precomputation and space complexity goes up to `O(nlogn)`.\\nTo trim down on precomputation and get the resulting runtime to `O(n)`, it is possible to use Farach-Colton and Bender\\'s Algorithm.\\nThis uses least-common-ancestor (LCA) queries on the cartesian tree of the LCP array to identify the minimum element in the range.\\nLCA queries on a tree can be done by taking an euler tour of the tree to create an array of depths where adjacent elements differ by +-1, and doing RMQ on this +-1 array using the method of the four russians takes `O(n)` precomputation and `O(1)` per RMQ.",
                "solutionTags": [
                    "Tree",
                    "Suffix Array"
                ],
                "code": "```\\n/**\\n * Suffix array\\n * Uses SA-IS\\n *\\n * @param str A sequence of characters, with unique lexicographically smallest\\n * sentinel at the end\\n */\\ntemplate <typename Ti, typename Ts>\\nstd::vector<Ti> sais(Ts str) {\\n        Ti len = str.size();\\n        //Keep track of S(maller)=false or L(arger)=true type suffix\\n        //Sentinel is implicitly set to S already\\n        std::vector<bool> types(len);\\n        //Build types array by iterating right to left\\n        for (Ti i = len - 1; i-- > 0; types[i] = str[i] > str[i + 1] || str[i] == str[i + 1] && types[i + 1]);\\n\\n        //Find Left-Most S-type suffixes\\n        std::vector<Ti> lms;\\n        std::vector<bool> is_lms(len);\\n        for (Ti i = 0; ++i < len; types[i - 1] && !types[i] && (lms.push_back(i), is_lms[i] = true));\\n\\n        //Count character frequencies\\n        std::vector<Ti> freq;\\n        for (Ti i = len; i-- > 0; str[i] < freq.size() || (freq.resize(str[i] + 1), true), freq[str[i]]++);\\n\\n        /**\\n         * Induced sorting procedure\\n         *\\n         * @param lms LMS suffixes to put into the buckets\\n         */\\n        const auto induced_sort = [&](const std::vector<Ti>& lms) {\\n                Ti alphalen = freq.size();\\n                //Calculate bucket begin and end indicies\\n                std::vector<Ti> bkt_begin, bkt_end;\\n                bkt_begin.reserve(alphalen);\\n                bkt_end.reserve(alphalen);\\n                bkt_begin.push_back(0);\\n                bkt_end.push_back(freq[0]);\\n                for (Ti i = 0; ++i < alphalen; (bkt_begin.push_back(bkt_begin[i - 1] + freq[i - 1]), bkt_end.push_back(bkt_begin[i] + freq[i])));\\n\\n                std::vector<Ti> ret(len);\\n\\n                //Put lms suffixes at ends of buckets\\n                std::vector<Ti> bkt_end_copy(bkt_end);\\n                for (Ti i = lms.size(); i-- > 0; ret[--bkt_end[str[lms[i]]]] = lms[i]);\\n\\n                //Restore bkt_end\\n                bkt_end = std::move(bkt_end_copy);\\n\\n                //Place L-type suffixes at beginning of buckets\\n                for (Ti i = -1; ++i < len; ret[i] && types[ret[i] - 1] && (ret[bkt_begin[str[ret[i] - 1]]++] = ret[i] - 1));\\n\\n                //Place S-type suffixes at end of buckets\\n                for (Ti i = len; i-- > 0; ret[i] && !types[ret[i] - 1] && (ret[--bkt_end[str[ret[i] - 1]]] = ret[i] - 1));\\n\\n                return ret;\\n        };\\n\\n        //Run induced sorting using the LMS suffixes in the order they appear\\n        std::vector<Ti> sorted_blocks = induced_sort(lms);\\n\\n        //Number the LMS blocks, assigning duplicate blocks the same number\\n        const auto lms_block_equal = [&](Ti a, Ti b) {\\n                for (bool seen_l = false; !seen_l || types[a] || types[b]; seen_l |= types[a++] | types[b++]) {\\n                        if (str[a] != str[b] || types[a] != types[b])\\n                                return false;\\n                }\\n                return str[a] == str[b];\\n        };\\n        std::vector<Ti> lms_number_map(len);\\n        bool all_unique = true;\\n        for (Ti i, last_used_num = i = 0, prevlms = len - 1, curlms; ++i < len; is_lms[curlms = sorted_blocks[i]] && (lms_number_map[curlms] = lms_block_equal(curlms, prevlms) ? (all_unique = false, last_used_num) : ++last_used_num, prevlms = curlms));\\n\\n        //Form reduced string from block numbers\\n        std::vector<Ti> reduced;\\n        reduced.reserve(lms.size());\\n        for (const auto& i : lms) reduced.push_back(lms_number_map[i]);\\n\\n        std::vector<Ti> reduced_sa;\\n        if (all_unique) {\\n                //If all blocks are unique, directly invert\\n                reduced_sa.resize(lms.size());\\n                for (Ti i = lms.size(); i-- > 0; reduced_sa[reduced[i]] = i);\\n        } else {\\n                //Otherwise, recurse\\n                reduced_sa = sais<Ti>(reduced);\\n        }\\n\\n        //Use reduced suffix array to sort the LMS suffixes\\n        std::vector<Ti> sorted_lms;\\n        sorted_lms.reserve(lms.size());\\n        for (const auto& i : reduced_sa) sorted_lms.push_back(lms[i]);\\n\\n        //Do a second induced sorting pass of T using the LMS suffixes in sorted order.\\n        return induced_sort(sorted_lms);\\n}\\n\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        text += \\'$\\';\\n        int n = text.size();\\n        auto sa = sais<int>(text);\\n        std::vector<int> sainv(n);\\n        for (int i = 0; i < n; ++i) {\\n            sainv[sa[i]] = i;\\n        }\\n        std::vector<int> lcp(2 * n);\\n        for (int i = 0, l = 0; i < n - 1; ++i) {\\n            int p = sa[sainv[i] - 1];\\n            while (text[i + l] == text[p + l]) ++l;\\n            lcp[n + sainv[i]] = l;\\n            if (l > 0) --l;\\n        }\\n        for (int i = n; --i; ) {\\n            lcp[i] = std::min(lcp[i << 1], lcp[i << 1 | 1]);\\n        }\\n        const auto lce = [&](int i, int j) {\\n            int l = sainv[i];\\n            int r = sainv[j];\\n            if (l > r) std::swap(l, r);\\n            int ret = n;\\n            for (l += 1 + n, r += 1 + n; l < r; l >>= 1, r >>= 1) {\\n                if (l & 1) ret = std::min(ret, lcp[l++]);\\n                if (r & 1) ret = std::min(ret, lcp[--r]);\\n            }\\n            return ret;\\n        };\\n        int groups = 0;\\n        int l = 0;\\n        // for (int i = 0; i < n; ++i) {\\n        //     std::cout << i << \":\" << sa[i] << \",\" << text.substr(sa[i]) << \",\" << lcp[n + i] << std::endl;\\n        // }\\n        for (int i = 0, j = n - 1; ++l, i < --j; ) {\\n            // std::cout << \"comparing\" << i << \",\" << j << \":\" << lce(i, j) << \">=\" << l << std::endl;\\n            if (lce(i, j) >= l) {\\n                i += l;\\n                groups += 2;\\n                l = 0;\\n                if (i >= j) break;\\n            }\\n        }\\n        if (l > 0) ++groups;\\n        return groups;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3788908,
                "title": "dp-rolling-hash-solution-c-explained",
                "content": "# Intuition\\nwe can compare if two substrings are euqal in O(1) time using rolling hash, with O(N) precomputation\\n\\n# Approach\\nfirstly we will calculate hash till every index of string and store in an array\\nLet say we solving subproblem from idx1 to idx2,\\nNow if(idx1 == idx2) we can easily return 1\\nelse\\n    we can start traversing from idx1 to half ans we will check \\n    if(hash(idx1 , i) == hash(j , idx2))\\n        in this case we maximize our result with\\n            ans(i + 1 , j - 1) + 2;\\nNote: we are also decreasing j while increasing i because we want equal strins from both sides\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N * N)\\n\\n- Space complexity:\\nO(N * N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const long long mod = 1e9 + 7 ;\\n    int getHash(vector<long long>&hash, vector<long long>&power , int left , int right){\\n        if(left == 0)return hash[right];\\n        long long result = (hash[right] - (hash[left - 1] * power[right - left + 1] % mod) + mod) % mod;\\n        if(result < 0)\\n            result += mod ;\\n        return result % mod ;\\n    }\\n    vector<vector<int>>dp;\\n    int ans(int idx1 , int idx2 , vector<long long>&hash, vector<long long>&power){\\n        if(idx1 == idx2)return 1 ;\\n        if(idx1 > idx2)return 0 ;\\n        if(dp[idx1][idx2] != -1)return dp[idx1][idx2];\\n        int i = idx1 , j = idx2 ;\\n        int result = 1 ;\\n        while(i < j){\\n            int first = getHash(hash , power , idx1 , i);\\n            int second = getHash(hash , power , j , idx2);\\n            if(first == second){\\n                result = max(result , ans(i + 1 , j - 1 , hash , power) + 2);\\n            }\\n            i++ , j-- ;\\n        }\\n        return dp[idx1][idx2] = result  ;\\n    }\\n    int longestDecomposition(string text) {\\n        int n = text.length();\\n        long long base = 27;\\n        vector<long long>hash(n , 0);\\n        vector<long long>power(n , 0);\\n        power[0] = 1 ;\\n        long long h = 0 ;\\n        for(int i = 0 ; i < n ; i++){\\n            h = (h * base % mod + (text[i] - \\'a\\' + 1) % mod) % mod ;\\n            hash[i] = h ;\\n            if(i){\\n                power[i] = power[i - 1] * base ;\\n                power[i] %= mod ;\\n            }\\n        }\\n        dp = vector<vector<int>>(n , vector<int>(n , -1));\\n        return ans(0 , n - 1 , hash , power);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const long long mod = 1e9 + 7 ;\\n    int getHash(vector<long long>&hash, vector<long long>&power , int left , int right){\\n        if(left == 0)return hash[right];\\n        long long result = (hash[right] - (hash[left - 1] * power[right - left + 1] % mod) + mod) % mod;\\n        if(result < 0)\\n            result += mod ;\\n        return result % mod ;\\n    }\\n    vector<vector<int>>dp;\\n    int ans(int idx1 , int idx2 , vector<long long>&hash, vector<long long>&power){\\n        if(idx1 == idx2)return 1 ;\\n        if(idx1 > idx2)return 0 ;\\n        if(dp[idx1][idx2] != -1)return dp[idx1][idx2];\\n        int i = idx1 , j = idx2 ;\\n        int result = 1 ;\\n        while(i < j){\\n            int first = getHash(hash , power , idx1 , i);\\n            int second = getHash(hash , power , j , idx2);\\n            if(first == second){\\n                result = max(result , ans(i + 1 , j - 1 , hash , power) + 2);\\n            }\\n            i++ , j-- ;\\n        }\\n        return dp[idx1][idx2] = result  ;\\n    }\\n    int longestDecomposition(string text) {\\n        int n = text.length();\\n        long long base = 27;\\n        vector<long long>hash(n , 0);\\n        vector<long long>power(n , 0);\\n        power[0] = 1 ;\\n        long long h = 0 ;\\n        for(int i = 0 ; i < n ; i++){\\n            h = (h * base % mod + (text[i] - \\'a\\' + 1) % mod) % mod ;\\n            hash[i] = h ;\\n            if(i){\\n                power[i] = power[i - 1] * base ;\\n                power[i] %= mod ;\\n            }\\n        }\\n        dp = vector<vector<int>>(n , vector<int>(n , -1));\\n        return ans(0 , n - 1 , hash , power);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729007,
                "title": "detailed-commented-easy-c-solution-beats-100-memory",
                "content": "# Solution\\n\\n1. The solution begins by checking if the given string is empty. If so, it returns 1. This is an edge case which is separately addressed as technically an empty string doesn\\'t satisfy the problem\\'s criteria, but logically there is one substring, the empty string itself.\\n\\n2. Then a counter `k` is initialized to 0. This counter is utilized to keep track of the number of mirrored substrings found thus far.\\n\\n3. Two variables `left` and `len` are used to keep track of the starting point of the current left substring and the length of the current substring respectively.\\n\\n4. `halfSize` is calculated as half the length of the string. There can\\'t be a valid pair of mirrored substrings beyond this point. `isZ` checks if the string length is even. This boolean value is used later to determine whether or not to increment `k` an additional time.\\n\\n5. `ss` is a string_view of the input string, `text`, which provides more efficient substring operations. `firstStr` and `secondStr` are string_views that will represent the current pair of substrings being compared.\\n\\n6. The solution enters a loop which continues until the left starting point plus the current length exceed the halfway point. Inside the loop, it extracts two substrings from the original string: one starting from the left and one from the mirrored right position.\\n\\n7. If the two substrings are equal, `k` is incremented to indicate a match, `left` is moved forward by the length of the matched substring, and `len` is reset to 1 for the next round of substring extraction.\\n\\n8. If the two substrings are not equal, `len` is incremented to increase the length of the substring being compared in the next iteration.\\n\\n9. After the loop, `k` is doubled to account for the mirrored pairs of substrings found. If `left` hasn\\'t reached the halfway point, or if the string length is odd (which means there is a central unpaired character), `k` is incremented an additional time.\\n\\n10. Finally, `k` is returned as the largest possible number of substrings that satisfy the problem\\'s criteria.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string& text) {\\n\\n        if(text.length() == 0) return 1;\\n\\n        int k = 0;\\n        int left = 0;\\n        int len = 1;\\n        int halfSize =text.length()/2;\\n        bool isZ = !(text.length() % 2);\\n\\n        string_view ss =text;\\n        string_view firstStr;\\n        string_view secondStr;\\n\\n        while (left + len <= halfSize)\\n        {\\n            firstStr = ss.substr(left, len);\\n            secondStr = ss.substr(text.length() - left - len, len);if(firstStr == secondStr)\\n            {\\n                k++;\\n                left += len;\\n                len = 1;\\n            }\\n            else\\n            {\\n                len++;\\n            }\\n        }\\n        k *=2;\\n        if(left != halfSize || !isZ) k++;\\n\\n        return k;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string& text) {\\n\\n        if(text.length() == 0) return 1;\\n\\n        int k = 0;\\n        int left = 0;\\n        int len = 1;\\n        int halfSize =text.length()/2;\\n        bool isZ = !(text.length() % 2);\\n\\n        string_view ss =text;\\n        string_view firstStr;\\n        string_view secondStr;\\n\\n        while (left + len <= halfSize)\\n        {\\n            firstStr = ss.substr(left, len);\\n            secondStr = ss.substr(text.length() - left - len, len);if(firstStr == secondStr)\\n            {\\n                k++;\\n                left += len;\\n                len = 1;\\n            }\\n            else\\n            {\\n                len++;\\n            }\\n        }\\n        k *=2;\\n        if(left != halfSize || !isZ) k++;\\n\\n        return k;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705529,
                "title": "fast-solution-with-two-pointers",
                "content": "# Code\\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        char[] c = text.toCharArray();\\n        int highest = 0;\\n        int lowest = c.length;\\n        int ans = 0;\\n        while (highest < lowest){\\n            char letter = c[highest];\\n            int length = 0;\\n            for (int i = lowest - 1; i >= 0; i--){\\n                int temp_lowest;\\n                if (c[i] == letter){\\n                    length = lowest - i;\\n                    temp_lowest = i; //temporary lowest\\n                }\\n                else continue;\\n                \\n                if (highest >= temp_lowest){\\n                    if (highest < lowest) ans++; //there is at least one more unused letter\\n                    lowest = -1; //to break out of the while loop\\n                    break;\\n                }\\n                \\n                boolean same = true;\\n                for (int j = 0; j < length; j++){\\n                    char left = c[highest+j];\\n                    char right = c[temp_lowest+j];\\n                    if (left != right) same = false;\\n                }\\n                if (same){\\n                    ans += 2;\\n                    highest += length;\\n                    lowest = i;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        char[] c = text.toCharArray();\\n        int highest = 0;\\n        int lowest = c.length;\\n        int ans = 0;\\n        while (highest < lowest){\\n            char letter = c[highest];\\n            int length = 0;\\n            for (int i = lowest - 1; i >= 0; i--){\\n                int temp_lowest;\\n                if (c[i] == letter){\\n                    length = lowest - i;\\n                    temp_lowest = i; //temporary lowest\\n                }\\n                else continue;\\n                \\n                if (highest >= temp_lowest){\\n                    if (highest < lowest) ans++; //there is at least one more unused letter\\n                    lowest = -1; //to break out of the while loop\\n                    break;\\n                }\\n                \\n                boolean same = true;\\n                for (int j = 0; j < length; j++){\\n                    char left = c[highest+j];\\n                    char right = c[temp_lowest+j];\\n                    if (left != right) same = false;\\n                }\\n                if (same){\\n                    ans += 2;\\n                    highest += length;\\n                    lowest = i;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683670,
                "title": "simple-greedy-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int cnt = 0;\\n\\n        int i = 0 , j = text.length()-1;\\n\\n        string a , b;\\n\\n        while(i < j) {\\n            a += text[i];\\n            b = text[j] + b;\\n\\n            if(a == b) {\\n                cnt++;\\n                a = \"\";\\n                b = \"\";\\n            }\\n\\n            i++; j--;\\n        }\\n\\n        cnt *= 2;    // total 2*cnt partitions\\n\\n        if(i == j && a == \"\" && b == \"\") cnt++;    // think about tc : \"aaa\" (edge case)\\n        \\n        if(a != \"\" && b != \"\")cnt++;    // a & b were not matching so count them as a combined partition\\n\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int cnt = 0;\\n\\n        int i = 0 , j = text.length()-1;\\n\\n        string a , b;\\n\\n        while(i < j) {\\n            a += text[i];\\n            b = text[j] + b;\\n\\n            if(a == b) {\\n                cnt++;\\n                a = \"\";\\n                b = \"\";\\n            }\\n\\n            i++; j--;\\n        }\\n\\n        cnt *= 2;    // total 2*cnt partitions\\n\\n        if(i == j && a == \"\" && b == \"\") cnt++;    // think about tc : \"aaa\" (edge case)\\n        \\n        if(a != \"\" && b != \"\")cnt++;    // a & b were not matching so count them as a combined partition\\n\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682541,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def longestDecomposition(text: String): Int = {\\n      val n = text.length\\n      var result = 0\\n      var i = 0\\n      var found = false\\n\\n      while (i < n/2 && !found) {\\n        if (text.substring(0, i + 1) == text.substring(n-1-i, n)) {\\n          result = 2 + longestDecomposition(text.substring(i+1, n-1-i))\\n          found = true\\n        }\\n        i += 1\\n      }\\n\\n      if (!found) if (n == 0) 0 else 1\\n      else result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def longestDecomposition(text: String): Int = {\\n      val n = text.length\\n      var result = 0\\n      var i = 0\\n      var found = false\\n\\n      while (i < n/2 && !found) {\\n        if (text.substring(0, i + 1) == text.substring(n-1-i, n)) {\\n          result = 2 + longestDecomposition(text.substring(i+1, n-1-i))\\n          found = true\\n        }\\n        i += 1\\n      }\\n\\n      if (!found) if (n == 0) 0 else 1\\n      else result\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3671140,
                "title": "easy-to-understand-c-solution-2-pointers-approach",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Example : ghisghisghi\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        int left = 0, right = n - 1, count = 0;\\n        string substr1, substr2;\\n\\n        while (left < right) {\\n            substr1 = substr1 + text[left]; // append the letter at the end\\n            substr2 = text[right] + substr2; // append the letter at the front\\n\\n            if (substr1 == substr2) { // ghi (sghi) ghi\\n                count += 2;\\n                substr1 = \"\";\\n                substr2 = \"\";\\n            }\\n\\n            left++;\\n            right--; // sg hi .. after this left > right\\n        }\\n\\n        if (left == right || !substr1.empty()) { // substr of the form (s1)s2(s1)\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Example : ghisghisghi\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        int left = 0, right = n - 1, count = 0;\\n        string substr1, substr2;\\n\\n        while (left < right) {\\n            substr1 = substr1 + text[left]; // append the letter at the end\\n            substr2 = text[right] + substr2; // append the letter at the front\\n\\n            if (substr1 == substr2) { // ghi (sghi) ghi\\n                count += 2;\\n                substr1 = \"\";\\n                substr2 = \"\";\\n            }\\n\\n            left++;\\n            right--; // sg hi .. after this left > right\\n        }\\n\\n        if (left == right || !substr1.empty()) { // substr of the form (s1)s2(s1)\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630283,
                "title": "longest-chunked-palindrome-decomposition-o-n-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nitrate 1 side check other side \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        l=0\\n        r=1\\n        n=len(text)\\n        res=0\\n        while r<=n//2:\\n            print(text[l:r])\\n            if (l==0 and text[l:r]==text[-r:]) or text[l:r]==text[-r:-l]:\\n                res+=2\\n                l=r\\n                r+=1\\n            else:\\n                r+=1\\n        s=text[l:-l]\\n        print(s)\\n        if l==0:\\n            s=text\\n        \\n        if len(s)==1 or s[::-1]!=s:\\n            res+=1\\n    \\n        \\n        return res\\n                \\n            \\n                    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        l=0\\n        r=1\\n        n=len(text)\\n        res=0\\n        while r<=n//2:\\n            print(text[l:r])\\n            if (l==0 and text[l:r]==text[-r:]) or text[l:r]==text[-r:-l]:\\n                res+=2\\n                l=r\\n                r+=1\\n            else:\\n                r+=1\\n        s=text[l:-l]\\n        print(s)\\n        if l==0:\\n            s=text\\n        \\n        if len(s)==1 or s[::-1]!=s:\\n            res+=1\\n    \\n        \\n        return res\\n                \\n            \\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626223,
                "title": "antarnab-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   // public int longestDecomposition(String text) {\\n            public int longestDecomposition(String S) {\\n        int res = 0, n = S.length();\\n        String l = \"\", r = \"\";\\n        for (int i = 0; i < n; ++i) {\\n            l = l + S.charAt(i);\\n            r = S.charAt(n - i - 1) + r;\\n            if (l.equals(r)) {\\n                ++res;\\n                l = \"\";\\n                r = \"\";//Antarnab solution\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   // public int longestDecomposition(String text) {\\n            public int longestDecomposition(String S) {\\n        int res = 0, n = S.length();\\n        String l = \"\", r = \"\";\\n        for (int i = 0; i < n; ++i) {\\n            l = l + S.charAt(i);\\n            r = S.charAt(n - i - 1) + r;\\n            if (l.equals(r)) {\\n                ++res;\\n                l = \"\";\\n                r = \"\";//Antarnab solution\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625574,
                "title": "recursion-simple-logic",
                "content": "# Intuition\\nIt can be seen from the task that you need to split this string into the maximum number of substrings with the following list of requirements:\\n\\n1. The substrings must be the same.\\n1. Substrings should be placed at the beginning and end of the main line.\\n\\n# Approach\\nTo solve this problem, it is necessary to use a recursive algorithm. \\nWe need to check whether it is possible to isolate two pieces of a string that are identical to each other (one of the pairs), then remove them from the string and repeat for the remaining parts.\\nThe recursion ends when we can no longer get two comparable substrings.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\nThe algorithm goes through each character of the string twice (i.e. the complexity is $$O(n))$$, but we also have another loop inside - this is from `i=1 to n/2`. The loop finds potential pairs of substrings in the main string, so the entire time of the function is $$O(n^2)$$.\\n\\n- Space complexity: $$O(n)$$\\nIn the worst case, a new variable will be created for each character of the string - the complexity of the space will be $$O(n)$$.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestDecomposition(string text)\\n    {\\n        string helper = text;\\n        int count = 0;\\n\\n        void Recursive(string txt)\\n        {\\n            helper = txt;\\n            for (int i = 1; i <= txt.Length / 2; i++)\\n            {\\n                if (txt.Substring(0, i) == txt.Substring(txt.Length - i))\\n                {\\n                    count += 2;\\n                    Recursive(txt.Substring(i, txt.Length - 2 * i));\\n                    break;\\n                }\\n            }\\n        }\\n\\n        Recursive(text);\\n        return (helper == \"\") ? count : count + 1;\\n    }\\n}\\n```\\n\\nThis function takes the string text as an argument and returns an integer - the maximum number of substrings into which this string can be divided according to the rules from the task.\\n\\nThe function starts by storing the value of the original string in the helper variable, and then recursively calls itself to search for substrings. If a pair of substrings was found, the function increments the count counter by 2 and runs recursively with the trimmed string. The recursion continues until the end of the string is reached.\\n\\nThe return value is determined by the value of the helper variable. If after all the actions its value is an empty string, then we can return the current count value. Otherwise, i.e. if no pair of substrings could be found, the current value `count + 1` is returned.\\n",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestDecomposition(string text)\\n    {\\n        string helper = text;\\n        int count = 0;\\n\\n        void Recursive(string txt)\\n        {\\n            helper = txt;\\n            for (int i = 1; i <= txt.Length / 2; i++)\\n            {\\n                if (txt.Substring(0, i) == txt.Substring(txt.Length - i))\\n                {\\n                    count += 2;\\n                    Recursive(txt.Substring(i, txt.Length - 2 * i));\\n                    break;\\n                }\\n            }\\n        }\\n\\n        Recursive(text);\\n        return (helper == \"\") ? count : count + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606466,
                "title": "python3-consuming-shortest-palindrome-from-either-end-of-text",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        count = 0\\n        start = 0\\n        end = len(text) - 1\\n        while end - start > 0:\\n            if text[:start+1] == text[end:]:\\n                count += 2\\n                text = text[start+1:end]\\n                start = 0\\n                end = len(text) - 1\\n                continue\\n            start += 1\\n            end -= 1\\n        if len(text) > 0: count += 1\\n        return count \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        count = 0\\n        start = 0\\n        end = len(text) - 1\\n        while end - start > 0:\\n            if text[:start+1] == text[end:]:\\n                count += 2\\n                text = text[start+1:end]\\n                start = 0\\n                end = len(text) - 1\\n                continue\\n            start += 1\\n            end -= 1\\n        if len(text) > 0: count += 1\\n        return count \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600676,
                "title": "simple-question-greedy-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int cnt = 0;\\n        int n = text.length();\\n        int i = 0;\\n        int j = n-1;\\n        int e = j;\\n        while(i<=j){\\n            if(i==j){\\n                cnt++;\\n                break;\\n            }\\n            if(text[i]==text[j]){\\n                int d = e-j+1;\\n                int ind = i;\\n                bool flag = true;\\n                for(int k=j; k<=e; k++){\\n                    if(text[ind]!=text[k]){\\n                        flag = false;\\n                        break;\\n                    }\\n                    ind++;\\n                }\\n                if(flag){\\n                    i = ind;\\n                    cnt+=2;\\n                    e = j-1;\\n                }\\n                j--;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int cnt = 0;\\n        int n = text.length();\\n        int i = 0;\\n        int j = n-1;\\n        int e = j;\\n        while(i<=j){\\n            if(i==j){\\n                cnt++;\\n                break;\\n            }\\n            if(text[i]==text[j]){\\n                int d = e-j+1;\\n                int ind = i;\\n                bool flag = true;\\n                for(int k=j; k<=e; k++){\\n                    if(text[ind]!=text[k]){\\n                        flag = false;\\n                        break;\\n                    }\\n                    ind++;\\n                }\\n                if(flag){\\n                    i = ind;\\n                    cnt+=2;\\n                    e = j-1;\\n                }\\n                j--;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574849,
                "title": "golang-using-z-functions-dp",
                "content": "# Intuition\\nWe can use the Z function to efficiently identify the shortest suffix that is also a prefix of a particular string.\\n\\n# Code\\n```\\nfunc longestDecomposition(text string) int {\\n  return dp(text)\\n}\\n\\nfunc dp(s string) int {\\n  if len(s) == 0 {\\n    return 0\\n  }\\n  // Using Z functions check for prefix\\n  z := make([]int, len(s))\\n  l, r := 0, 0\\n  for i := 1; i < len(s); i++ {\\n    if i < r {\\n      z[i] = min(r - i, z[i - l])\\n    }\\n    for i+z[i] < len(s) && s[z[i]] == s[i+z[i]] {\\n      z[i]++\\n    }\\n    if i + z[i] > r {\\n      l = i\\n      r = i+z[i]\\n    }\\n  }\\n  i := len(s)-1\\n  sublen := 0\\n  for i >= 0 {\\n    if i + z[i] == len(s) {\\n      sublen = z[i]\\n      break\\n    }\\n    i--\\n  }\\n  // No substring match. Z[0] is undefined\\n  if i == -1 {\\n    return 1\\n  }\\n  return 2 + dp(s[sublen:len(s)-sublen])\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "String Matching"
                ],
                "code": "```\\nfunc longestDecomposition(text string) int {\\n  return dp(text)\\n}\\n\\nfunc dp(s string) int {\\n  if len(s) == 0 {\\n    return 0\\n  }\\n  // Using Z functions check for prefix\\n  z := make([]int, len(s))\\n  l, r := 0, 0\\n  for i := 1; i < len(s); i++ {\\n    if i < r {\\n      z[i] = min(r - i, z[i - l])\\n    }\\n    for i+z[i] < len(s) && s[z[i]] == s[i+z[i]] {\\n      z[i]++\\n    }\\n    if i + z[i] > r {\\n      l = i\\n      r = i+z[i]\\n    }\\n  }\\n  i := len(s)-1\\n  sublen := 0\\n  for i >= 0 {\\n    if i + z[i] == len(s) {\\n      sublen = z[i]\\n      break\\n    }\\n    i--\\n  }\\n  // No substring match. Z[0] is undefined\\n  if i == -1 {\\n    return 1\\n  }\\n  return 2 + dp(s[sublen:len(s)-sublen])\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3555557,
                "title": "two-pointer-approach-java-simple-solution-clean-code",
                "content": "# Complexity\\nLet `n` = length  of `text` string\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int k = 0;\\n        StringBuilder sb1 = new StringBuilder();\\n        StringBuilder sb2 = new StringBuilder();\\n        for(int i = 0,j = text.length() - 1;j >= 0;i++,--j){\\n            sb1.append(text.charAt(i));\\n            sb2.insert(0,text.charAt(j));\\n            if(sb1.toString().equals(sb2.toString())){\\n                k += 2;\\n                sb1.delete(0,sb1.length());\\n                sb2.delete(0,sb2.length());\\n            }\\n        }\\n        k++;\\n        return k / 2;\\n    }\\n}\\n```\\n\\n# Upvote if you like it \\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int k = 0;\\n        StringBuilder sb1 = new StringBuilder();\\n        StringBuilder sb2 = new StringBuilder();\\n        for(int i = 0,j = text.length() - 1;j >= 0;i++,--j){\\n            sb1.append(text.charAt(i));\\n            sb2.insert(0,text.charAt(j));\\n            if(sb1.toString().equals(sb2.toString())){\\n                k += 2;\\n                sb1.delete(0,sb1.length());\\n                sb2.delete(0,sb2.length());\\n            }\\n        }\\n        k++;\\n        return k / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543112,
                "title": "python-3-hashing-greedy-o-n-time",
                "content": "# Complexity\\n- Time complexity:\\n$O(n)$\\n\\n- Space complexity:\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution:\\n    X, X_INV, MOD = 31, 129032259, 1000000007\\n\\n    def longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        prefixHash = [0] * (n + 1)\\n        xiInvs = [0] * n\\n        h, xi, xiInv = 0, 1, 1\\n        for i, c in enumerate(text):\\n            val = ord(c) - 96\\n            h = (h + xi*val) % Solution.MOD\\n            prefixHash[i] = h\\n            xiInvs[i] = xiInv\\n            xi = (Solution.X * xi) % Solution.MOD\\n            xiInv = (Solution.X_INV * xiInv) % Solution.MOD\\n        \\n        def equal(i, j):\\n            h1 = ((prefixHash[j] - prefixHash[i - 1]) * xiInvs[i]) % Solution.MOD\\n            ir, jr = n - i - 1, n - j - 1\\n            h2 = ((prefixHash[ir] - prefixHash[jr - 1]) * xiInvs[jr]) % Solution.MOD\\n            if h1 != h2:\\n                return False\\n            return all(text[i + idx] == text[jr + idx] for idx in range(j - i + 1))\\n\\n        half = n >> 1\\n        res = i = j = 0\\n        while i < half:\\n            if j == half:\\n                return res + 1\\n            if equal(i, j):\\n                res += 2\\n                i = j + 1\\n            j += 1\\n        return res + (n & 1)\\n\\n                \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    X, X_INV, MOD = 31, 129032259, 1000000007\\n\\n    def longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        prefixHash = [0] * (n + 1)\\n        xiInvs = [0] * n\\n        h, xi, xiInv = 0, 1, 1\\n        for i, c in enumerate(text):\\n            val = ord(c) - 96\\n            h = (h + xi*val) % Solution.MOD\\n            prefixHash[i] = h\\n            xiInvs[i] = xiInv\\n            xi = (Solution.X * xi) % Solution.MOD\\n            xiInv = (Solution.X_INV * xiInv) % Solution.MOD\\n        \\n        def equal(i, j):\\n            h1 = ((prefixHash[j] - prefixHash[i - 1]) * xiInvs[i]) % Solution.MOD\\n            ir, jr = n - i - 1, n - j - 1\\n            h2 = ((prefixHash[ir] - prefixHash[jr - 1]) * xiInvs[jr]) % Solution.MOD\\n            if h1 != h2:\\n                return False\\n            return all(text[i + idx] == text[jr + idx] for idx in range(j - i + 1))\\n\\n        half = n >> 1\\n        res = i = j = 0\\n        while i < half:\\n            if j == half:\\n                return res + 1\\n            if equal(i, j):\\n                res += 2\\n                i = j + 1\\n            j += 1\\n        return res + (n & 1)\\n\\n                \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480710,
                "title": "c-recursion-but-beast-22",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i, string s) {\\n        int j=s.size()-1;\\n        if(i==j) return 1;\\n        if(i>j) return 0;\\n        while(i<j) {\\n            string a=s.substr(j);\\n            string b=s.substr(i,s.size()-j);\\n            if(a==b) {\\n                return 2+solve(0,s.substr(s.size()-j,j-(s.size()-j)));\\n                break ;\\n            }\\n            j--;\\n        }\\n        return 1;\\n    }\\n    int longestDecomposition(string text) {\\n        return solve(0,text);\\n    }\\n# };\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, string s) {\\n        int j=s.size()-1;\\n        if(i==j) return 1;\\n        if(i>j) return 0;\\n        while(i<j) {\\n            string a=s.substr(j);\\n            string b=s.substr(i,s.size()-j);\\n            if(a==b) {\\n                return 2+solve(0,s.substr(s.size()-j,j-(s.size()-j)));\\n                break ;\\n            }\\n            j--;\\n        }\\n        return 1;\\n    }\\n    int longestDecomposition(string text) {\\n        return solve(0,text);\\n    }\\n# };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411317,
                "title": "1147-longest-chunked-palindrome-decomposition-c-two-pointer-stack-prateek-ece",
                "content": "# Intuition (Ignore grammatical errors)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo Pointer and stack will come into you mind when you see the problem;\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbhut simple hai code dekh lo;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) + thoda sa jada ;\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N);\\n\\n\\n# Code\\n```\\n\\n#define For(i,a,b) for(int i=a; i<b; i++)\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        stack<int> st;\\n        int i=0;\\n        int j=text.size()-1;\\n        int cnt=0;\\n        while (i<=j){\\n            st.push(text[i]);\\n            stack<int>temp;\\n            int tempj=j;\\n            while(!st.empty() && text[j]==st.top()&& i!=j){\\n                temp.push(st.top());\\n                st.pop();\\n                j--;\\n            }\\n            \\n            if (st.empty()) {\\n                cnt++;\\n            }\\n            else{\\n                while(!temp.empty()){\\n                    st.push(temp.top());\\n                    temp.pop();\\n                }\\n                j=tempj;\\n            }\\n            i++;\\n        }\\n    \\n    cnt*=2;\\n\\n    if(!st.empty()) cnt++;\\n\\n    return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n#define For(i,a,b) for(int i=a; i<b; i++)\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        stack<int> st;\\n        int i=0;\\n        int j=text.size()-1;\\n        int cnt=0;\\n        while (i<=j){\\n            st.push(text[i]);\\n            stack<int>temp;\\n            int tempj=j;\\n            while(!st.empty() && text[j]==st.top()&& i!=j){\\n                temp.push(st.top());\\n                st.pop();\\n                j--;\\n            }\\n            \\n            if (st.empty()) {\\n                cnt++;\\n            }\\n            else{\\n                while(!temp.empty()){\\n                    st.push(temp.top());\\n                    temp.pop();\\n                }\\n                j=tempj;\\n            }\\n            i++;\\n        }\\n    \\n    cnt*=2;\\n\\n    if(!st.empty()) cnt++;\\n\\n    return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393406,
                "title": "kmp-algorithm-o-n-2-string-lps",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int compute_lps(string& s,int st,int en){\\n\\n        //  case 1\\n        if(s[st]==s[en]){\\n           return 1;\\n        }\\n\\n        // case 2 : lps\\n        int n = en-st+1;\\n        vector<int>lps(n,st);\\n\\n        int len = st;\\n        int i = st+1;\\n\\n        while(i<=en){\\n            if(s[i] == s[len]){\\n                lps[i-st] = len+1;\\n                i++;\\n                len++;\\n            }\\n            else if(len == st){\\n                lps[i-st] = st;\\n                i++;\\n            }\\n            else{\\n                len = lps[len-1-st];\\n            }\\n        }\\n        return len-st;\\n    }\\n\\n    int solve(string& text,int st,int en){\\n        // base case\\n        if(st>en) return 0;\\n        if(st == en) return 1;\\n\\n        // compute lps\\n        int lps_len = compute_lps(text,st,en);\\n        if(lps_len == 0) return 1;\\n        return 2 + solve(text,st+lps_len,en-lps_len);\\n    }\\n\\n    int longestDecomposition(string text) {\\n        return solve(text,0,text.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int compute_lps(string& s,int st,int en){\\n\\n        //  case 1\\n        if(s[st]==s[en]){\\n           return 1;\\n        }\\n\\n        // case 2 : lps\\n        int n = en-st+1;\\n        vector<int>lps(n,st);\\n\\n        int len = st;\\n        int i = st+1;\\n\\n        while(i<=en){\\n            if(s[i] == s[len]){\\n                lps[i-st] = len+1;\\n                i++;\\n                len++;\\n            }\\n            else if(len == st){\\n                lps[i-st] = st;\\n                i++;\\n            }\\n            else{\\n                len = lps[len-1-st];\\n            }\\n        }\\n        return len-st;\\n    }\\n\\n    int solve(string& text,int st,int en){\\n        // base case\\n        if(st>en) return 0;\\n        if(st == en) return 1;\\n\\n        // compute lps\\n        int lps_len = compute_lps(text,st,en);\\n        if(lps_len == 0) return 1;\\n        return 2 + solve(text,st+lps_len,en-lps_len);\\n    }\\n\\n    int longestDecomposition(string text) {\\n        return solve(text,0,text.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376687,
                "title": "c",
                "content": "```\\nint longestDecomposition(char * text){\\n    int n = strlen(text) ;\\n    int ret = 0 ;\\n    int left = 0, right ;\\n    for(right = 1; right <= n/2; right++){\\n        int len = right - left ;\\n        bool flag = true ;\\n        for(int i = 0; i < len; i++){\\n            if(text[left+i] != text[n-right+i]){\\n                flag = false ;\\n                break ;\\n            }\\n        }\\n        if(flag){\\n            ret += 2 ;\\n            left = right ;\\n        }\\n    }\\n    if(left * 2 < n)\\n        ret++ ;\\n    return ret ;\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nint longestDecomposition(char * text){\\n    int n = strlen(text) ;\\n    int ret = 0 ;\\n    int left = 0, right ;\\n    for(right = 1; right <= n/2; right++){\\n        int len = right - left ;\\n        bool flag = true ;\\n        for(int i = 0; i < len; i++){\\n            if(text[left+i] != text[n-right+i]){\\n                flag = false ;\\n                break ;\\n            }\\n        }\\n        if(flag){\\n            ret += 2 ;\\n            left = right ;\\n        }\\n    }\\n    if(left * 2 < n)\\n        ret++ ;\\n    return ret ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3358776,
                "title": "brute-force",
                "content": "**INTUTION :-** \\njust use brute force, save the all occurences of each characters in string in a map then start traversing from the starting find the first character that is same from the end of the string and check until u find the same string as from starting and ending add+=2 if u find the string otherwise add+=1 and break\\n\\n```\\n\\t    int ans = 0;\\n    bool check(string s)\\n    {\\n        sort(s.begin() , s.end());\\n        return s[0] == s[s.length()-1];\\n    }\\n    int longestDecomposition(string text) {\\n        \\n        if(check(text)) return text.length();\\n        map<char ,  vector<int>> mp;\\n        int i = text.length()-1;\\n        for(;i>=0 ; i--)\\n        {\\n            mp[text[i]].push_back(i);\\n        }\\n        i = 0;\\n        int j = text.length()-1;\\n        cout<<mp[\\'h\\'].size();\\n        for( ;i<=j ; )\\n        {\\n            cout<<text[i]<<\" \";\\n            int len = j - mp[text[i]].front()+1;\\n            while(mp[text[i]].size() > 0  && text.substr(i , len) != text.substr(mp[text[i]].front() , len) )\\n            {\\n                mp[text[i]].erase(mp[text[i]].begin());\\n                // cout<<mp[text[i]].front();\\n                // j = mp[text[i]].front()-1;\\n                len = j-mp[text[i]].front()+1;\\n            }\\n            if(mp[text[i]].front() == i)\\n            {\\n                ans+=1;\\n                break;\\n            }\\n            \\n            if(text.substr(i , len) == text.substr(mp[text[i]].front() , len))\\n            {\\n                ans+=2;\\n                j = mp[text[i]].front()-1;\\n                mp[text[i]].erase(mp[text[i]].begin());\\n            }\\n            else\\n            {\\n\\n                ans+=1;\\n                break;\\n            }\\n            i = i+len;\\n        }\\n        return ans;\\n        \\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\t    int ans = 0;\\n    bool check(string s)\\n    {\\n        sort(s.begin() , s.end());\\n        return s[0] == s[s.length()-1];\\n    }\\n    int longestDecomposition(string text) {\\n        \\n        if(check(text)) return text.length();\\n        map<char ,  vector<int>> mp;\\n        int i = text.length()-1;\\n        for(;i>=0 ; i--)\\n        {\\n            mp[text[i]].push_back(i);\\n        }\\n        i = 0;\\n        int j = text.length()-1;\\n        cout<<mp[\\'h\\'].size();\\n        for( ;i<=j ; )\\n        {\\n            cout<<text[i]<<\" \";\\n            int len = j - mp[text[i]].front()+1;\\n            while(mp[text[i]].size() > 0  && text.substr(i , len) != text.substr(mp[text[i]].front() , len) )\\n            {\\n                mp[text[i]].erase(mp[text[i]].begin());\\n                // cout<<mp[text[i]].front();\\n                // j = mp[text[i]].front()-1;\\n                len = j-mp[text[i]].front()+1;\\n            }\\n            if(mp[text[i]].front() == i)\\n            {\\n                ans+=1;\\n                break;\\n            }\\n            \\n            if(text.substr(i , len) == text.substr(mp[text[i]].front() , len))\\n            {\\n                ans+=2;\\n                j = mp[text[i]].front()-1;\\n                mp[text[i]].erase(mp[text[i]].begin());\\n            }\\n            else\\n            {\\n\\n                ans+=1;\\n                break;\\n            }\\n            i = i+len;\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3352965,
                "title": "easy-greedy-4-lines",
                "content": "# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, S, res=0):\\n        n = len(S)\\n        for l in range(1, n // 2 + 1):\\n            if S[0] == S[n - l] and S[l - 1] == S[n - 1]:\\n                if S[:l] == S[n - l:]: return self.longestDecomposition(S[l:n - l], res + 2)\\n        return res + 1 if S else res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, S, res=0):\\n        n = len(S)\\n        for l in range(1, n // 2 + 1):\\n            if S[0] == S[n - l] and S[l - 1] == S[n - 1]:\\n                if S[:l] == S[n - l:]: return self.longestDecomposition(S[l:n - l], res + 2)\\n        return res + 1 if S else res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328533,
                "title": "c-clean-and-concise",
                "content": "# Intuition\\nwhen equal string found both end -> recurse for remaining function\\n\\n# Approach\\nGreedly take strings from both ends, if equal strings found then call recursive function for remaining string\\n\\n# Complexity\\n- Time complexity:\\nO(N2)\\n\\n- Space complexity:\\nBased on recursive call\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int fun(string &s, int i)\\n    {\\n        int j=s.length()-1-i;\\n        int currLength=j-i+1;\\n        if(currLength<=1) return currLength;\\n\\n        for(int len=1;len<=currLength/2;len++)\\n        {\\n            if(s.substr(i,len)==s.substr(j-len+1,len))\\n            {\\n                return 2+fun(s,i+len);\\n            }\\n        }\\n        return 1;\\n    }\\n\\n\\n    int longestDecomposition(string text) {\\n        //greedy\\n        return fun(text,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int fun(string &s, int i)\\n    {\\n        int j=s.length()-1-i;\\n        int currLength=j-i+1;\\n        if(currLength<=1) return currLength;\\n\\n        for(int len=1;len<=currLength/2;len++)\\n        {\\n            if(s.substr(i,len)==s.substr(j-len+1,len))\\n            {\\n                return 2+fun(s,i+len);\\n            }\\n        }\\n        return 1;\\n    }\\n\\n\\n    int longestDecomposition(string text) {\\n        //greedy\\n        return fun(text,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291656,
                "title": "go-0ms-recursively-check-for-first-palindrome-substring",
                "content": "```go\\nfunc longestDecomposition(text string) int {\\n    return firstDecomp(text)\\n}\\n\\nfunc firstDecomp(text string) int {\\n    if len(text) == 0 {\\n        return 0\\n    }\\n    i := 1\\n    for ;i<len(text);i++ {\\n        if text[i-1] != text[len(text)-1] {\\n            continue\\n        }\\n        begin := text[:i]\\n        end := text[len(text)-i:]\\n        if begin == end {\\n            break\\n        }\\n    }\\n    if i == len(text) {\\n        return 1\\n    }\\n    decompedText := text[i:len(text)-i]\\n    return 2 + firstDecomp(decompedText)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```go\\nfunc longestDecomposition(text string) int {\\n    return firstDecomp(text)\\n}\\n\\nfunc firstDecomp(text string) int {\\n    if len(text) == 0 {\\n        return 0\\n    }\\n    i := 1\\n    for ;i<len(text);i++ {\\n        if text[i-1] != text[len(text)-1] {\\n            continue\\n        }\\n        begin := text[:i]\\n        end := text[len(text)-i:]\\n        if begin == end {\\n            break\\n        }\\n    }\\n    if i == len(text) {\\n        return 1\\n    }\\n    decompedText := text[i:len(text)-i]\\n    return 2 + firstDecomp(decompedText)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259057,
                "title": "100-fast-easy-to-understand-greedy-2-pointer-approach-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Two Pointer Approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe increase the prefix and suffix chunk unless they are equal.\\nOnce they are equal i.e, prefix == reverse( Suffix ), we increase the result by 2.\\nAnd reset the prefix and suffix.\\nTo handle odd lenght strings and non palindromic middle chunck we check if l == r or wether prefix and suffix are non empty ans increase result by one.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, t: str) -> int:\\n        # if string is already a palindrome return its length, as each element will get chuncked\\n        if(t == t[::-1]):\\n            return len(t)\\n\\n        out = []    # to store the result\\n        l, r = 0,len(t)-1   # two pointers pointing to start and end of string\\n        x,y=\"\",\"\"   # two empty string to check prefix and suffix\\n\\n        while l < r:\\n            x+=t[l]        # add prefix to x until x = reverse of y\\n            y+=t[r]        # add suffix to y \\n            if(x == y[::-1]):      # check if  x = reverse of y\\n                out.append(x)      # add the chunk to result\\n                x=\"\"               # reset the strings\\n                y=\"\"\\n            l+=1\\n            r-=1\\n    \\n        res = len(out)*2    # all the chuncked elements are apearing twice, hence multiply result by 2\\n        \\n        #if the string if odd length, middle element needs to be added and if middle window ex: (adam) is not a palindrome it needs to be added\\n        if(l == r or x != \"\" and y != \"\"):\\n            return res+1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, t: str) -> int:\\n        # if string is already a palindrome return its length, as each element will get chuncked\\n        if(t == t[::-1]):\\n            return len(t)\\n\\n        out = []    # to store the result\\n        l, r = 0,len(t)-1   # two pointers pointing to start and end of string\\n        x,y=\"\",\"\"   # two empty string to check prefix and suffix\\n\\n        while l < r:\\n            x+=t[l]        # add prefix to x until x = reverse of y\\n            y+=t[r]        # add suffix to y \\n            if(x == y[::-1]):      # check if  x = reverse of y\\n                out.append(x)      # add the chunk to result\\n                x=\"\"               # reset the strings\\n                y=\"\"\\n            l+=1\\n            r-=1\\n    \\n        res = len(out)*2    # all the chuncked elements are apearing twice, hence multiply result by 2\\n        \\n        #if the string if odd length, middle element needs to be added and if middle window ex: (adam) is not a palindrome it needs to be added\\n        if(l == r or x != \"\" and y != \"\"):\\n            return res+1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252333,
                "title": "using-z-function-c",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is best problem which can be solved using `z-function`. \\n\\n`Definition of z-function :` \\nSuppose we are given a string \\u200A$s$\\u200A of length \\u200A$n$\\u200A. The Z-function for this string is an array of length \\u200A$n$\\u200A where the \\u200A$i$\\u200A-th element is equal to the greatest number of characters starting from the position \\u200A$i$\\u200A that coincide with the first characters of \\u200A$s$\\u200A. \\n\\nHere we call Z_function and get the last best prefix. Untill last best prefix is zero.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int z_function(string s) {\\n        int n = s.size();\\n\\n        vector<int> z(n);\\n        for(int i = 1, l =0, r = 0; i<n; ++i) {\\n            if(i<=r)\\n                z[i] = min(r - i +1, z[i-l]);\\n            while(i+z[i] < n && s[z[i]] == s[i + z[i] ]) ++z[i];\\n\\n            if(i+ z[i] -1 > r) {\\n                l = i; r = i+z[i]-1;\\n            } \\n\\n        }\\n\\n        for(int i = n-1; i>=0; --i) {\\n            if(z[i] + i == n) return z[i];\\n        }\\n        return 0;\\n    }\\n\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        int start = 0, end = n-1, ans = 0;\\n        while(start <= end) {\\n            int len = z_function(text.substr(start, end-start+1));\\n\\n            start +=len;\\n            end -= len;\\n            if(len == 0) {\\n                ++ans;\\n                break;\\n            } else {\\n                ans+=2;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int z_function(string s) {\\n        int n = s.size();\\n\\n        vector<int> z(n);\\n        for(int i = 1, l =0, r = 0; i<n; ++i) {\\n            if(i<=r)\\n                z[i] = min(r - i +1, z[i-l]);\\n            while(i+z[i] < n && s[z[i]] == s[i + z[i] ]) ++z[i];\\n\\n            if(i+ z[i] -1 > r) {\\n                l = i; r = i+z[i]-1;\\n            } \\n\\n        }\\n\\n        for(int i = n-1; i>=0; --i) {\\n            if(z[i] + i == n) return z[i];\\n        }\\n        return 0;\\n    }\\n\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        int start = 0, end = n-1, ans = 0;\\n        while(start <= end) {\\n            int len = z_function(text.substr(start, end-start+1));\\n\\n            start +=len;\\n            end -= len;\\n            if(len == 0) {\\n                ++ans;\\n                break;\\n            } else {\\n                ans+=2;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234939,
                "title": "o-n-2-with-constant-memory-using-c-strings",
                "content": "# Intuition\\nFrom the offset, it\\'s clear that you can break this down into subproblems. Once you find the first palindrome, then you can apply the same algorithm to the original string minus the palindrome characters to get the next palindrome, and so on. The problem then becomes \"Find the smallest palindrome on the start/end of this string\", which is the problem I tried to focus on.\\n\\n# Approach\\nI couldn\\'t think of a way better than O(n), since we need to look at least the whole string\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1) - C strings are helpful here since the STL doesn\\'t provide a substring API that returns references.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/*\\npalindromes = 0\\ni = 0, end_start, end_last = text.size()\\nfirst = text.start\\n\\nfor (j = end_last - 1; j > i; --j)\\n    range = end_last - j\\n    check if [i, i + range] == [j, j + range] \\n    yes \\n        i = i + range\\n        end_last = j\\n\\n*/\\n    int longestDecomposition(string text) {\\n        int k = 0;\\n\\n        // left = i, right = j\\n        const char * left = text.c_str(), * end = text.c_str() + text.size(), *right;\\n        for (right = end - 1; right > left; --right) {\\n            // cout << \"i: \" << i << \" j: \" << j << endl;\\n            // cout << \"Comparing: \" << left << \" | \" << right << \", Range: \" << range << endl;\\n            if (strncmp(left, right, end - right) == 0) {\\n                // cout << \"Found a match!\" << endl;\\n                left = left + (end - right);\\n                end = right;\\n                k += 2;\\n            }\\n        }\\n        if (left != right + 1) {\\n            k += 1;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*\\npalindromes = 0\\ni = 0, end_start, end_last = text.size()\\nfirst = text.start\\n\\nfor (j = end_last - 1; j > i; --j)\\n    range = end_last - j\\n    check if [i, i + range] == [j, j + range] \\n    yes \\n        i = i + range\\n        end_last = j\\n\\n*/\\n    int longestDecomposition(string text) {\\n        int k = 0;\\n\\n        // left = i, right = j\\n        const char * left = text.c_str(), * end = text.c_str() + text.size(), *right;\\n        for (right = end - 1; right > left; --right) {\\n            // cout << \"i: \" << i << \" j: \" << j << endl;\\n            // cout << \"Comparing: \" << left << \" | \" << right << \", Range: \" << range << endl;\\n            if (strncmp(left, right, end - right) == 0) {\\n                // cout << \"Found a match!\" << endl;\\n                left = left + (end - right);\\n                end = right;\\n                k += 2;\\n            }\\n        }\\n        if (left != right + 1) {\\n            k += 1;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3211774,
                "title": "swift-0-ms",
                "content": "```\\nclass Solution {\\n    func longestDecomposition(_ text: String) -> Int {\\n        var k = 0\\n        var pos = 0\\n        let cc = Array(text)\\n        for i in 0 ..< cc.count / 2 {\\n            var isPalindrome = true\\n            for j in pos ... i {\\n                if cc[j] != cc[cc.count - 1 - pos - i + j] { \\n                    isPalindrome = false\\n                    break \\n                }\\n            }\\n            guard isPalindrome else { continue }\\n            k += 2\\n            pos = i + 1\\n        }\\n        return cc.count % 2 == 0 && pos == cc.count / 2 ? k : k + 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestDecomposition(_ text: String) -> Int {\\n        var k = 0\\n        var pos = 0\\n        let cc = Array(text)\\n        for i in 0 ..< cc.count / 2 {\\n            var isPalindrome = true\\n            for j in pos ... i {\\n                if cc[j] != cc[cc.count - 1 - pos - i + j] { \\n                    isPalindrome = false\\n                    break \\n                }\\n            }\\n            guard isPalindrome else { continue }\\n            k += 2\\n            pos = i + 1\\n        }\\n        return cc.count % 2 == 0 && pos == cc.count / 2 ? k : k + 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134951,
                "title": "100-beats-easy-to-understand-c-two-pointer-iit-roorkee",
                "content": "# Approach :- Two Pointer Approach\\n\\n# Complexity\\n\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) \\n    {\\n      int count=0;\\n      int i=0;\\n      int j=text.length()-1;\\n      string str1;\\n      string str2;\\n      while(i<j)\\n      {\\n          str1+=text[i];\\n          str2=text[j]+str2;\\n          if(str1==str2)\\n          {\\n              count+=2;\\n              str1.clear();\\n              str2.clear();\\n          }\\n          i++;\\n          j--;\\n      }\\n      if((i==j)||(str1.length()!=0))\\n      {\\n        count+=1;\\n      }\\n      return count;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) \\n    {\\n      int count=0;\\n      int i=0;\\n      int j=text.length()-1;\\n      string str1;\\n      string str2;\\n      while(i<j)\\n      {\\n          str1+=text[i];\\n          str2=text[j]+str2;\\n          if(str1==str2)\\n          {\\n              count+=2;\\n              str1.clear();\\n              str2.clear();\\n          }\\n          i++;\\n          j--;\\n      }\\n      if((i==j)||(str1.length()!=0))\\n      {\\n        count+=1;\\n      }\\n      return count;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098253,
                "title": "java-brute-force-recursion",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Brute Force\\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int count=0;\\n        int r=text.length()-1;\\n        int l=0;\\n        String leftStr=\"\";\\n        String rightStr=\"\";\\n        while(l<text.length()){\\n            leftStr+=text.charAt(l);\\n            rightStr=text.charAt(r)+rightStr;\\n            if(leftStr.equals(rightStr)){\\n                count++;\\n                leftStr=\"\";\\n                rightStr=\"\";\\n            }\\n            l++;\\n            r--;\\n        }\\n        return count;\\n    }\\n}\\n```\\n# Recursion\\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        //Recursion\\n        int n=text.length();\\n        for(int i=0;i<n/2;i++){\\n            if(text.substring(0,i+1).equals(text.substring(n-1-i,n))){\\n                return 2+longestDecomposition(text.substring(i+1,n-1-i));\\n            }\\n        }\\n        return n==0?0:1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int count=0;\\n        int r=text.length()-1;\\n        int l=0;\\n        String leftStr=\"\";\\n        String rightStr=\"\";\\n        while(l<text.length()){\\n            leftStr+=text.charAt(l);\\n            rightStr=text.charAt(r)+rightStr;\\n            if(leftStr.equals(rightStr)){\\n                count++;\\n                leftStr=\"\";\\n                rightStr=\"\";\\n            }\\n            l++;\\n            r--;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        //Recursion\\n        int n=text.length();\\n        for(int i=0;i<n/2;i++){\\n            if(text.substring(0,i+1).equals(text.substring(n-1-i,n))){\\n                return 2+longestDecomposition(text.substring(i+1,n-1-i));\\n            }\\n        }\\n        return n==0?0:1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079067,
                "title": "not-bad",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, arr: str) -> int:\\n        size=len(arr)\\n        arr=list(arr)\\n        x=1\\n        y=len(arr)-1\\n        count=0\\n        lol=0\\n        while y>=x:\\n            if arr[:x]==arr[y:]:\\n                lol+=len(arr[:x])\\n                lol+=len(arr[y:])\\n                for i in range(len(arr[:x])):\\n                \\n                    arr.pop(0)\\n                    arr.pop()\\n                x=1\\n                y=len(arr)-1\\n                count+=2\\n            else:\\n                x+=1\\n                y-=1\\n        if size==lol:return count\\n        return count +1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, arr: str) -> int:\\n        size=len(arr)\\n        arr=list(arr)\\n        x=1\\n        y=len(arr)-1\\n        count=0\\n        lol=0\\n        while y>=x:\\n            if arr[:x]==arr[y:]:\\n                lol+=len(arr[:x])\\n                lol+=len(arr[y:])\\n                for i in range(len(arr[:x])):\\n                \\n                    arr.pop(0)\\n                    arr.pop()\\n                x=1\\n                y=len(arr)-1\\n                count+=2\\n            else:\\n                x+=1\\n                y-=1\\n        if size==lol:return count\\n        return count +1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021007,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar longestDecomposition = function(text) {\\n    \\n};\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar longestDecomposition = function(text) {\\n    if(text==\\'\\')\\n        return 0;\\n    for(let i=1;i<text.length;i++){\\n        if(text.substring(0,i)==text.substring(text.length-i))\\n            return 2+longestDecomposition(text.substring(i,text.length-i));\\n    }\\n    return 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar longestDecomposition = function(text) {\\n    \\n};\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar longestDecomposition = function(text) {\\n    if(text==\\'\\')\\n        return 0;\\n    for(let i=1;i<text.length;i++){\\n        if(text.substring(0,i)==text.substring(text.length-i))\\n            return 2+longestDecomposition(text.substring(i,text.length-i));\\n    }\\n    return 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3018718,
                "title": "golang-dp-rolling-hash",
                "content": "```\\nfunc longestDecomposition(t string) int {\\n    mem := make([][]int, len(t))\\n\\tfor i := range mem {\\n\\t\\tmem[i] = make([]int, len(t))\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\n    \\n\\tvar p uint64 = 31\\n\\tpPow := make([]uint64, len(t))\\n\\tpPow[0] = 1\\n\\tfor i := 1; i < len(pPow); i++ {\\n\\t\\tpPow[i] = pPow[i-1] * p\\n\\t}\\n\\t\\n\\th := make([]uint64, len(t))\\n\\tfor i := 0; i < len(t); i++ {\\n\\t\\th[i] = (uint64(t[i]) - \\'a\\' + 1) * pPow[i]\\n\\t\\tif i > 0 {\\n\\t\\t\\th[i] += h[i-1]\\n\\t\\t}\\n\\t}\\n\\n\\tvar dp func(int, int) int\\n\\tdp = func(st int, end int) int {\\n\\t\\tif end >= len(t) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif mem[st][end] != -1 {\\n\\t\\t\\treturn mem[st][end]\\n\\t\\t}\\n\\t\\tcf := h[end]\\n\\t\\tif st > 0 {\\n\\t\\t\\tcf -= h[st-1]\\n\\t\\t}\\n\\n\\t\\txend := len(t) - 1 - st\\n\\t\\txst := xend - (end - st)\\n\\n\\t\\tcs := h[xend]\\n\\t\\tif xst > 0 {\\n\\t\\t\\tcs -= h[xst-1]\\n\\t\\t}\\n\\n\\t\\tmn := xst - st\\n\\t\\ttk := 0\\n\\t\\tif mn < 0 {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif cf*pPow[mn] == cs {\\n\\t\\t\\ta := 2\\n\\t\\t\\tif end >= len(t)/2 {\\n\\t\\t\\t\\ta = 1\\n\\t\\t\\t}\\n\\t\\t\\ttk = a + dp(end+1, end+1)\\n\\t\\t}\\n\\t\\tntk := dp(st, end+1)\\n\\t\\tif ntk > tk {\\n\\t\\t\\tmem[st][end] = ntk\\n\\t\\t\\treturn ntk\\n\\t\\t}\\n\\t\\tmem[st][end] = tk\\n\\t\\treturn tk\\n\\t}\\n\\n\\treturn dp(0, 0)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc longestDecomposition(t string) int {\\n    mem := make([][]int, len(t))\\n\\tfor i := range mem {\\n\\t\\tmem[i] = make([]int, len(t))\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\n    \\n\\tvar p uint64 = 31\\n\\tpPow := make([]uint64, len(t))\\n\\tpPow[0] = 1\\n\\tfor i := 1; i < len(pPow); i++ {\\n\\t\\tpPow[i] = pPow[i-1] * p\\n\\t}\\n\\t\\n\\th := make([]uint64, len(t))\\n\\tfor i := 0; i < len(t); i++ {\\n\\t\\th[i] = (uint64(t[i]) - \\'a\\' + 1) * pPow[i]\\n\\t\\tif i > 0 {\\n\\t\\t\\th[i] += h[i-1]\\n\\t\\t}\\n\\t}\\n\\n\\tvar dp func(int, int) int\\n\\tdp = func(st int, end int) int {\\n\\t\\tif end >= len(t) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif mem[st][end] != -1 {\\n\\t\\t\\treturn mem[st][end]\\n\\t\\t}\\n\\t\\tcf := h[end]\\n\\t\\tif st > 0 {\\n\\t\\t\\tcf -= h[st-1]\\n\\t\\t}\\n\\n\\t\\txend := len(t) - 1 - st\\n\\t\\txst := xend - (end - st)\\n\\n\\t\\tcs := h[xend]\\n\\t\\tif xst > 0 {\\n\\t\\t\\tcs -= h[xst-1]\\n\\t\\t}\\n\\n\\t\\tmn := xst - st\\n\\t\\ttk := 0\\n\\t\\tif mn < 0 {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif cf*pPow[mn] == cs {\\n\\t\\t\\ta := 2\\n\\t\\t\\tif end >= len(t)/2 {\\n\\t\\t\\t\\ta = 1\\n\\t\\t\\t}\\n\\t\\t\\ttk = a + dp(end+1, end+1)\\n\\t\\t}\\n\\t\\tntk := dp(st, end+1)\\n\\t\\tif ntk > tk {\\n\\t\\t\\tmem[st][end] = ntk\\n\\t\\t\\treturn ntk\\n\\t\\t}\\n\\t\\tmem[st][end] = tk\\n\\t\\treturn tk\\n\\t}\\n\\n\\treturn dp(0, 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2994516,
                "title": "100-faster-c-solution",
                "content": "The idea is pretty simple but the implementation is terrific.\\nHere is the idea :\\n  We know that if two strings are equal then their hash will be equal right ? Yeah\\n Compute the prefix hash for the entire string so we can get the hash for a substring in O(1)\\n\\nNow, after we have done that. we need to maximize how we split our string by comparing first and last string or first two and last two or first three and last three e.t.c. until we get the first match.\\ne.g \\ngcbagcb\\ng!=b\\ngc!=cb\\ngcb==gcb\\nwhen it becomes equal, we will do the necessary index adjustment and try again taking 1 or 2 or 3 e.tc strings at a time. \\ni.e s.substr(index, k) == s.substr(size-index-1, k) where k = 1,2,3,4...(size/2 + 1)\\nwe will repeat this until the substrings overlap\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int longestDecomposition(string s) {\\n         // ok we need to calculate the prefix hash of the string then compute \\n         // accordingly...\\n         int size = s.size(), prime = 53, mod = 1e9+9;\\n         vector<long long>hash(size),p(size);\\n         p[0]=1;\\n        \\n         for(int i =1; i < size; i++){\\n              p[i]= (p[i-1]*prime)%mod;\\n         }\\n         hash[0] = s[0]-\\'a\\'+1;\\n        \\n         for(int i = 1; i < size; i++){\\n             \\n               hash[i] = (hash[i-1]+ (s[i]-\\'a\\'+1)*p[i])%mod;\\n             \\n         }\\n        \\n         int maxi = size/2, answer = 0, index = 0;\\n         maxi++;\\n        \\n         \\n         for(int tryy = 1; tryy <= (maxi+1); tryy++){\\n              \\n              int begin1 = index, end1= index+tryy-1, begin2=size-index-tryy, end2=begin2+tryy-1;\\n             \\n              if(begin2  <= end1){\\n                   answer+=1;\\n                   break;\\n              }\\n             \\n              long long compute = (hash[end1]- ((begin1-1)>=0 ? hash[begin1-1]: 0)+mod)%mod;\\n              compute = (compute * p[size-index-1])%mod;\\n             \\n              long long compute2 = (hash[end2]-((begin2-1)>=0 ? hash[begin2-1]: 0)+mod)%mod;\\n              compute2 = (compute2* p[size-begin2-1])%mod;\\n             \\n              if(compute==compute2){\\n                  answer+=2;\\n                  index+=tryy;\\n                  tryy=0;\\n                  if(end1+1==begin2)break;\\n              }\\n             \\n         }\\n        \\n        return answer;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Rolling Hash",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int longestDecomposition(string s) {\\n         // ok we need to calculate the prefix hash of the string then compute \\n         // accordingly...\\n         int size = s.size(), prime = 53, mod = 1e9+9;\\n         vector<long long>hash(size),p(size);\\n         p[0]=1;\\n        \\n         for(int i =1; i < size; i++){\\n              p[i]= (p[i-1]*prime)%mod;\\n         }\\n         hash[0] = s[0]-\\'a\\'+1;\\n        \\n         for(int i = 1; i < size; i++){\\n             \\n               hash[i] = (hash[i-1]+ (s[i]-\\'a\\'+1)*p[i])%mod;\\n             \\n         }\\n        \\n         int maxi = size/2, answer = 0, index = 0;\\n         maxi++;\\n        \\n         \\n         for(int tryy = 1; tryy <= (maxi+1); tryy++){\\n              \\n              int begin1 = index, end1= index+tryy-1, begin2=size-index-tryy, end2=begin2+tryy-1;\\n             \\n              if(begin2  <= end1){\\n                   answer+=1;\\n                   break;\\n              }\\n             \\n              long long compute = (hash[end1]- ((begin1-1)>=0 ? hash[begin1-1]: 0)+mod)%mod;\\n              compute = (compute * p[size-index-1])%mod;\\n             \\n              long long compute2 = (hash[end2]-((begin2-1)>=0 ? hash[begin2-1]: 0)+mod)%mod;\\n              compute2 = (compute2* p[size-begin2-1])%mod;\\n             \\n              if(compute==compute2){\\n                  answer+=2;\\n                  index+=tryy;\\n                  tryy=0;\\n                  if(end1+1==begin2)break;\\n              }\\n             \\n         }\\n        \\n        return answer;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941020,
                "title": "c-beats-100-time-complexity-o-n-space-complexity-o-1",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n       int i=0,cnt=0,j=text.size(),ans=0;\\n       while(i<=j){\\n            cnt++;\\n            if(text.compare(i,cnt,text,j-cnt,cnt)==0){\\n             i=i+cnt;\\n             j=j-cnt;\\n             cnt=0;\\n             if(i<j) ans+=2;\\n             else ans++;\\n            }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n       int i=0,cnt=0,j=text.size(),ans=0;\\n       while(i<=j){\\n            cnt++;\\n            if(text.compare(i,cnt,text,j-cnt,cnt)==0){\\n             i=i+cnt;\\n             j=j-cnt;\\n             cnt=0;\\n             if(i<j) ans+=2;\\n             else ans++;\\n            }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924107,
                "title": "python-dp-solution-faster-than-70-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```text[left: start]``` means the first left chunk and ```text[end: right]``` means the second right chunk. If they are equal, find the next chunks i.e. ```text[start: start + 1]``` and ```text[end - 1: end]```. If not, increase the size of both the chunks by 1. Keep storing the results of all the sub-problems.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        self.res, sz = 0, len(text)\\n\\n        @cache\\n        def dp(left: int, start: int, end: int, right: int) -> int:\\n            if left == start == end == right:\\n                return 1\\n            if start >= end:\\n                return 0\\n            if text[left: start + 1] == text[end: right + 1]:\\n                return dp(start + 1, start + 1, end - 1, end - 1) + 2\\n            chunk = dp(left, start + 1, end - 1, right)\\n            return chunk if chunk > 0 else 1\\n\\n        return dp(0, 0, sz - 1, sz - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```text[left: start]```\n```text[end: right]```\n```text[start: start + 1]```\n```text[end - 1: end]```\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        self.res, sz = 0, len(text)\\n\\n        @cache\\n        def dp(left: int, start: int, end: int, right: int) -> int:\\n            if left == start == end == right:\\n                return 1\\n            if start >= end:\\n                return 0\\n            if text[left: start + 1] == text[end: right + 1]:\\n                return dp(start + 1, start + 1, end - 1, end - 1) + 2\\n            chunk = dp(left, start + 1, end - 1, right)\\n            return chunk if chunk > 0 else 1\\n\\n        return dp(0, 0, sz - 1, sz - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919040,
                "title": "rolling-hash-with-dynamic-programming-approach",
                "content": "\\n# Complexity\\n- Time complexity: O(n*n)\\n- Space complexity: O(n*n)\\n\\n# Code\\n```\\ntemplate<typename T>\\nclass RABIN_KARP_HASH {\\n    long long p{}, mod{};\\n    std::vector<long long> pref_hash;\\n    std::vector<int> p_pow;\\n\\npublic:\\n    RABIN_KARP_HASH (T &s, int p, int mod) {\\n        this->p = p;\\n        this->mod = mod;\\n        init(s);\\n    }\\n\\n    void init(T& s) {\\n        int n = s.size();\\n        pref_hash.resize(n);\\n        pref_hash[0] = s[0];\\n        for (int i = 1; i < n; i++) {\\n            pref_hash[i] = (pref_hash[i-1] * p + s[i]) % mod;\\n        }\\n        p_pow.resize(n);\\n        p_pow[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            p_pow[i] = (p_pow[i-1] * 1LL * p) % mod;\\n        }\\n    }\\n\\n    long long get_hash(int i, int j) {\\n        if (i == 0) return pref_hash[j];\\n        long long ans = pref_hash[j] - (pref_hash[i-1] * p_pow[j-i+1]) % mod;\\n        if (ans < 0) ans += mod;\\n        return ans;\\n    }\\n\\n};\\n\\nclass Solution {\\n\\npublic:\\n    int longestDecomposition(string& text) {\\n        RABIN_KARP_HASH<string> h1(text, 31, 1e9+7), h2(text, 67, 1e9+9);\\n        int n = text.size();\\n        int dp[n][n];\\n        memset(dp, -1, sizeof dp);\\n        function<int(int, int)> rec = [&] (int x, int y) {\\n            if (x > y) return 0;\\n            if (x == y) return 1;\\n            if (dp[x][y] != -1) return dp[x][y];\\n            int len = y-x+1;\\n            int ans = 1;\\n            for (int i = 0; i < (len>>1); i++) {\\n                if (h1.get_hash(x, x+i) == h1.get_hash(y-i, y) && h2.get_hash(x, x+i) == h2.get_hash(y-i, y)) {\\n                    ans = max(ans, rec(x+i+1, y-i-1)+2);\\n                }\\n            }\\n            return dp[x][y] = ans;\\n        };\\n        return rec(0, n-1);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntemplate<typename T>\\nclass RABIN_KARP_HASH {\\n    long long p{}, mod{};\\n    std::vector<long long> pref_hash;\\n    std::vector<int> p_pow;\\n\\npublic:\\n    RABIN_KARP_HASH (T &s, int p, int mod) {\\n        this->p = p;\\n        this->mod = mod;\\n        init(s);\\n    }\\n\\n    void init(T& s) {\\n        int n = s.size();\\n        pref_hash.resize(n);\\n        pref_hash[0] = s[0];\\n        for (int i = 1; i < n; i++) {\\n            pref_hash[i] = (pref_hash[i-1] * p + s[i]) % mod;\\n        }\\n        p_pow.resize(n);\\n        p_pow[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            p_pow[i] = (p_pow[i-1] * 1LL * p) % mod;\\n        }\\n    }\\n\\n    long long get_hash(int i, int j) {\\n        if (i == 0) return pref_hash[j];\\n        long long ans = pref_hash[j] - (pref_hash[i-1] * p_pow[j-i+1]) % mod;\\n        if (ans < 0) ans += mod;\\n        return ans;\\n    }\\n\\n};\\n\\nclass Solution {\\n\\npublic:\\n    int longestDecomposition(string& text) {\\n        RABIN_KARP_HASH<string> h1(text, 31, 1e9+7), h2(text, 67, 1e9+9);\\n        int n = text.size();\\n        int dp[n][n];\\n        memset(dp, -1, sizeof dp);\\n        function<int(int, int)> rec = [&] (int x, int y) {\\n            if (x > y) return 0;\\n            if (x == y) return 1;\\n            if (dp[x][y] != -1) return dp[x][y];\\n            int len = y-x+1;\\n            int ans = 1;\\n            for (int i = 0; i < (len>>1); i++) {\\n                if (h1.get_hash(x, x+i) == h1.get_hash(y-i, y) && h2.get_hash(x, x+i) == h2.get_hash(y-i, y)) {\\n                    ans = max(ans, rec(x+i+1, y-i-1)+2);\\n                }\\n            }\\n            return dp[x][y] = ans;\\n        };\\n        return rec(0, n-1);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914191,
                "title": "c-simple-approach-to-solve-this-question",
                "content": "# Intuition\\nbasically it is  a simple question on recusion and the main idea behind is to reduce the time complexity that we will do using dp.\\n\\n# Approach\\nIn the  Approach question is the we are just checking the substring from the first that are matching with substring from the last by increasing for first and last postioner if they matches a string \\nand i am try to memsorisation to reduce the time complexity.\\n\\n# Complexity\\n- Time complexity:  O(N*N); N  is the size of string;\\n  \\n- Space complexity:\\n O(N)->for N size of String +O(N)-->for running the recusion;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int dp[1005][1005];\\n  int fun(int i,int j,int a,int b,string &s){\\n      if(i>=s.size() || j<0){\\n          return 0;\\n      }\\n      if(dp[i][j]!=-1){\\n          return dp[i][j];\\n      }\\n      int ans=0;\\n     if(s.substr(a,i-a+1)==s.substr(j,b-j+1)){\\n        ans=max(ans,fun(i+1,j-1,i+1,j-1,s)+1);\\n     }\\n    ans=max(ans,fun(i+1,j-1,a,b,s));\\n    return dp[i][j]=ans;\\n  }\\n    int longestDecomposition(string text) {\\n      \\n      memset(dp,-1,sizeof(dp));\\n     return fun(0,text.size()-1,0,text.size()-1,text);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int dp[1005][1005];\\n  int fun(int i,int j,int a,int b,string &s){\\n      if(i>=s.size() || j<0){\\n          return 0;\\n      }\\n      if(dp[i][j]!=-1){\\n          return dp[i][j];\\n      }\\n      int ans=0;\\n     if(s.substr(a,i-a+1)==s.substr(j,b-j+1)){\\n        ans=max(ans,fun(i+1,j-1,i+1,j-1,s)+1);\\n     }\\n    ans=max(ans,fun(i+1,j-1,a,b,s));\\n    return dp[i][j]=ans;\\n  }\\n    int longestDecomposition(string text) {\\n      \\n      memset(dp,-1,sizeof(dp));\\n     return fun(0,text.size()-1,0,text.size()-1,text);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913555,
                "title": "top-down-4d-dp-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find maximum chunk length, decomposed string\\n\\nthis question tricky because of edge cases\\n- how to count last middle chunk which can\\'t be palindrome\\n- Last single letter chunk \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n(left, i ) means that first left chunk\\n(j, right) means that second right chunk\\n\\n### Compare if two chunks are same \\n- if same, decompose chunk , find next two chunk (i+1, i+1), (j-1,j-1)\\n- if not, extend chunk length (left, i+1) , (j-1, right)\\n- if can\\'t decompose (i>=j) -> end loof (return 0)\\n\\n### edge cases\\n- if decompose all letters, return chunk count \\n- if there is any left chunk, count + 1 \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        self.res = 1\\n        m = len(text)\\n\\n        @cache\\n        def dp(left, i, j, right):\\n            \\n            if left == i == j == right:\\n                return 1\\n\\n            if i>= j:\\n                return 0\\n\\n\\n            if text[left:i+1] == text[j:right+1]:\\n                decomposition = dp(i+1, i+1, j-1, j-1) + 2\\n                return decomposition\\n            \\n            chunk = dp(left, i+1, j-1, right)\\n            if chunk ==0:\\n                return 1\\n\\n            return chunk\\n        \\n        return dp(0,0, m-1,m-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        self.res = 1\\n        m = len(text)\\n\\n        @cache\\n        def dp(left, i, j, right):\\n            \\n            if left == i == j == right:\\n                return 1\\n\\n            if i>= j:\\n                return 0\\n\\n\\n            if text[left:i+1] == text[j:right+1]:\\n                decomposition = dp(i+1, i+1, j-1, j-1) + 2\\n                return decomposition\\n            \\n            chunk = dp(left, i+1, j-1, right)\\n            if chunk ==0:\\n                return 1\\n\\n            return chunk\\n        \\n        return dp(0,0, m-1,m-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913490,
                "title": "faster-than-100-solution-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake strings till you get same string in end and start then update answer and i and j\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/18b37ec3-cab0-406c-be0d-be6703c6dffc_1671085175.2209547.png)\\n\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int ans = 0;\\n        int i = 0, j = text.length()-1;\\n        while(i <= j){\\n            string ti = \"\";\\n            ti = text[i];\\n            string tj = \"\";\\n            tj = text[j];\\n            // we have to increase i till we get jth char\\n            while(ti != tj && i < j){\\n                i++;\\n                j--;\\n                ti = ti + text[i];\\n                tj = text[j] + tj;\\n            }\\n            if(i >= j){ ans++; break;}\\n            // we got same\\n            // now update j and i\\n            // and ans\\n            i++;\\n            j--;\\n            ans += 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int ans = 0;\\n        int i = 0, j = text.length()-1;\\n        while(i <= j){\\n            string ti = \"\";\\n            ti = text[i];\\n            string tj = \"\";\\n            tj = text[j];\\n            // we have to increase i till we get jth char\\n            while(ti != tj && i < j){\\n                i++;\\n                j--;\\n                ti = ti + text[i];\\n                tj = text[j] + tj;\\n            }\\n            if(i >= j){ ans++; break;}\\n            // we got same\\n            // now update j and i\\n            // and ans\\n            i++;\\n            j--;\\n            ans += 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913134,
                "title": "python-two-pointers-recursion-beats-92-74",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use two pointers combined with recursion to solve the problem. We start with left($l$) and right($r$) pointers at $0$ and $len(text) - 1$ respectively and compare the strings formed by the first $l$ characters and the last $r$ characters. As soon as we find a match, we remove the matched strings and solve the sub-problem on the remainder of $text$. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNotice that splitting into smaller chunks is favorable over splitting into larger chunks if both options are available.\\neg: in the string $text$ = \"antaprezatepzapreanta\" , we could choose the first 2 characters to match the last two characters (\"an\" = \"an\") or the first four characters to match the last four characters (\"anta\" = \"anta\"). In this case, it is favorible to choose the chunk of two characters. This allows us to stop at the very first match we find.\\n\\nThe algorithm is as follows: \\n1. Initialize $l=0$ and $r = len(text) - 1$\\n2. Until you find a match or $l$ becomes greater than $r$, move each pointer closer to the center\\n3. If match is found, solve the subproblem obtained by removing the matching chunks from $text$. Since we get two additional chunks as compared to the sub-problem, return 2 + (sub-problem solution) \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nString comparison: $O(n)$ in the worst case, as we could potentially end up comparing the first $n/2$ and last $n/2$ characters\\n\\nThere are a total of ~ $n/2$ comparisons since either $l$ or $r$ goes over each character exactly once.\\n\\nHence, time complexity is $O(n^2)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$ since substrings are allocated additional memory in Python.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        if text == \"\": \\n            return 0\\n        if len(text) == 1:\\n            return 1 \\n        l, r = 0, len(text) - 1\\n\\n        # print(\\'Text: \\', text)\\n        found = False\\n\\n        while l < r: \\n            print(\\'testing:\\', text[:l+1], text[r:])\\n            if text[:l+1] == text[r:]: \\n                found = True\\n                # print(\\'Match:\\', l, r)\\n                break\\n            l += 1\\n            r -= 1\\n        \\n        if not found: \\n            return 1\\n        \\n        return 2*found + self.longestDecomposition(text[l+1:r])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        if text == \"\": \\n            return 0\\n        if len(text) == 1:\\n            return 1 \\n        l, r = 0, len(text) - 1\\n\\n        # print(\\'Text: \\', text)\\n        found = False\\n\\n        while l < r: \\n            print(\\'testing:\\', text[:l+1], text[r:])\\n            if text[:l+1] == text[r:]: \\n                found = True\\n                # print(\\'Match:\\', l, r)\\n                break\\n            l += 1\\n            r -= 1\\n        \\n        if not found: \\n            return 1\\n        \\n        return 2*found + self.longestDecomposition(text[l+1:r])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912862,
                "title": "python-simple-rolling-hash",
                "content": "# Approach\\nIterate the string from both ends simultaneously and update hash function of both substrings. Whenever the hashes are equal, increment answer by 2 and reset hashes to 0. \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nmod = int(1e18)+7\\nB = 31\\n\\nclass Solution(object):\\n    def longestDecomposition(self, s):\\n        hL, hR = 0, 0\\n        kL = 1\\n        n = len(s)\\n        ans = 0\\n        for i in range(n):\\n            hL = (hL + ord(s[i])*kL)%mod\\n            kL = (kL*B)%mod\\n\\n            hR = (hR*B)%mod\\n            hR = (hR + ord(s[n-1-i]))%mod \\n            if hL==hR:\\n                ans+=2\\n                hL, hR = 0, 0\\n                kL = 1\\n        \\n        return ans//2\\n```",
                "solutionTags": [
                    "Python",
                    "Rolling Hash",
                    "Hash Function"
                ],
                "code": "```\\nmod = int(1e18)+7\\nB = 31\\n\\nclass Solution(object):\\n    def longestDecomposition(self, s):\\n        hL, hR = 0, 0\\n        kL = 1\\n        n = len(s)\\n        ans = 0\\n        for i in range(n):\\n            hL = (hL + ord(s[i])*kL)%mod\\n            kL = (kL*B)%mod\\n\\n            hR = (hR*B)%mod\\n            hR = (hR + ord(s[n-1-i]))%mod \\n            if hL==hR:\\n                ans+=2\\n                hL, hR = 0, 0\\n                kL = 1\\n        \\n        return ans//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910364,
                "title": "python-two-pointer-and-recursion-solution-with-explanation",
                "content": "### two-pointer\\n```\\n\\'\\'\\'\\nif we find two subtexts are the same,  pre_l, pre_r are on the head of subtexts,  l, r are on the tail of subtexts\\nwalk through text from head and tail to find subtexts,\\nstr_l  and str_r is to store subtexts, if they are the same, cnt += 2, initialize str_l  and str_r, and update the pointer\\nIn the end, l and r are on the same position, but pre_l, pre maybe not\\nif pre_l == pre_r, there is one letter left, cnt +=1\\nif pre_l < pre_r, there is one subtext left, cnt +=1\\n\\ne.g., abcdfdabc\\npre_l, l, pre_r, r, cnt, explanation\\n 0, 2, 8, 6, 2 (abc)dfd(abd)\\n 3, 3, 5, 5, 4 (d)f(d)\\n 4, 4, 4, 4, 4 l == r, end\\n pre_l == pre_r -> cnt = 5\\n tc is O(len(text)) * O(len(subtext)) because of string concatenation, sc is O(len(subtext))\\n\\'\\'\\'\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        pre_l, pre_r, l, r = 0, n-1, 0, n-1\\n        str_l, str_r = \"\", \"\"\\n        cnt = 0\\n        while l < r:\\n            str_l += text[l]\\n            str_r = text[r] + str_r\\n            if str_l == str_r:\\n                pre_l, pre_r = l+1, r-1\\n                cnt += 2\\n                str_l, str_r = \"\", \"\"\\n            l += 1\\n            r -= 1\\n        if pre_l <= pre_r:\\n            cnt += 1\\n        return cnt\\n```\\n\\n### recursion\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        if not text: return 0\\n        n = len(text)\\n        for i in range(n//2):\\n            if text[:i+1] == text[n-i-1:]:\\n                return 2 + self.longestDecomposition(text[i+1:n-i-1])\\n        return 1\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\n\\'\\'\\'\\nif we find two subtexts are the same,  pre_l, pre_r are on the head of subtexts,  l, r are on the tail of subtexts\\nwalk through text from head and tail to find subtexts,\\nstr_l  and str_r is to store subtexts, if they are the same, cnt += 2, initialize str_l  and str_r, and update the pointer\\nIn the end, l and r are on the same position, but pre_l, pre maybe not\\nif pre_l == pre_r, there is one letter left, cnt +=1\\nif pre_l < pre_r, there is one subtext left, cnt +=1\\n\\ne.g., abcdfdabc\\npre_l, l, pre_r, r, cnt, explanation\\n 0, 2, 8, 6, 2 (abc)dfd(abd)\\n 3, 3, 5, 5, 4 (d)f(d)\\n 4, 4, 4, 4, 4 l == r, end\\n pre_l == pre_r -> cnt = 5\\n tc is O(len(text)) * O(len(subtext)) because of string concatenation, sc is O(len(subtext))\\n\\'\\'\\'\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        pre_l, pre_r, l, r = 0, n-1, 0, n-1\\n        str_l, str_r = \"\", \"\"\\n        cnt = 0\\n        while l < r:\\n            str_l += text[l]\\n            str_r = text[r] + str_r\\n            if str_l == str_r:\\n                pre_l, pre_r = l+1, r-1\\n                cnt += 2\\n                str_l, str_r = \"\", \"\"\\n            l += 1\\n            r -= 1\\n        if pre_l <= pre_r:\\n            cnt += 1\\n        return cnt\\n```\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        if not text: return 0\\n        n = len(text)\\n        for i in range(n//2):\\n            if text[:i+1] == text[n-i-1:]:\\n                return 2 + self.longestDecomposition(text[i+1:n-i-1])\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855834,
                "title": "java-kmp-using-next-array",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public int longestDecomposition(String s) {\\n        while (true) {\\n            s = skip(s);\\n            if (s.isEmpty()) {\\n                break;\\n            }\\n            int t = maxSP(s);\\n            if (t == 0) {\\n                break;\\n            }\\n            s = s.substring(t, s.length() - t);\\n            ans += 2;\\n        }\\n        return s.isEmpty() ? ans : ans + 1;\\n    }\\n    \\n    String skip(String s) {\\n        int l = 0;\\n        int r = s.length() - 1;\\n        while (l < r && s.charAt(l) == s.charAt(r)) {\\n            ans += 2;\\n            l++;\\n            r--;\\n        }\\n        return s.substring(l, r + 1);\\n    }\\n    \\n    int maxSP(String s) {\\n        int[] next = new int[s.length()];\\n        int j = -1;\\n        next[0] = j;\\n        for (int i = 1; i < s.length(); i++) {\\n            while (j >= 0 && s.charAt(i) != s.charAt(j + 1)) {\\n                j = next[j];\\n            }\\n            if (s.charAt(i) == s.charAt(j + 1)) {\\n                j++;\\n            }\\n            next[i] = j;\\n        }\\n        return next[s.length() - 1] + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int longestDecomposition(String s) {\\n        while (true) {\\n            s = skip(s);\\n            if (s.isEmpty()) {\\n                break;\\n            }\\n            int t = maxSP(s);\\n            if (t == 0) {\\n                break;\\n            }\\n            s = s.substring(t, s.length() - t);\\n            ans += 2;\\n        }\\n        return s.isEmpty() ? ans : ans + 1;\\n    }\\n    \\n    String skip(String s) {\\n        int l = 0;\\n        int r = s.length() - 1;\\n        while (l < r && s.charAt(l) == s.charAt(r)) {\\n            ans += 2;\\n            l++;\\n            r--;\\n        }\\n        return s.substring(l, r + 1);\\n    }\\n    \\n    int maxSP(String s) {\\n        int[] next = new int[s.length()];\\n        int j = -1;\\n        next[0] = j;\\n        for (int i = 1; i < s.length(); i++) {\\n            while (j >= 0 && s.charAt(i) != s.charAt(j + 1)) {\\n                j = next[j];\\n            }\\n            if (s.charAt(i) == s.charAt(j + 1)) {\\n                j++;\\n            }\\n            next[i] = j;\\n        }\\n        return next[s.length() - 1] + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829348,
                "title": "java-greedy-recursive-approach",
                "content": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int n = text.length();\\n        return solve(0, n-1, text);\\n    }\\n    \\n    int solve(int start, int end, String s) {\\n        if(start > end)\\n            return 0;\\n        \\n        for(int i = start; i < end; i++) {\\n            if(s.charAt(i) == s.charAt(end) && i < end  + start - i && s.substring(start, i + 1).equals(s.substring(end + start - i, end + 1))) {\\n                return 2 + solve(i+1, end + start - i - 1, s);\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int n = text.length();\\n        return solve(0, n-1, text);\\n    }\\n    \\n    int solve(int start, int end, String s) {\\n        if(start > end)\\n            return 0;\\n        \\n        for(int i = start; i < end; i++) {\\n            if(s.charAt(i) == s.charAt(end) && i < end  + start - i && s.substring(start, i + 1).equals(s.substring(end + start - i, end + 1))) {\\n                return 2 + solve(i+1, end + start - i - 1, s);\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811418,
                "title": "fastest-and-also-rather-straight-forward-rust-solution-by-matching-substrings-o-n",
                "content": "# Intuition\\ngo through the list from back and front simultanously and check whether a token (substring) matches\\n\\n# Approach\\nThe simplest approach would look like this\\n```\\nimpl Solution {\\n    pub fn longest_decomposition(text: String) -> i32 {\\n        let mut tokencount = 0;\\n        let mut prevtokenend = 0;\\n        let tl = text.len();\\n        let maxi = (tl)/2+1;\\n        for i in 1..maxi{\\n            if (i<=prevtokenend){continue;} //length of token would be 0, skip\\n            if text[prevtokenend..i] == text[(tl-i)..(tl-prevtokenend)]{\\n                //the token matched, count it and set start for next token to current end\\n                tokencount +=1;\\n                prevtokenend = i;\\n            }\\n        }\\n        tokencount\\n    }\\n}\\n```\\nbut with this approach we would check every token twice, we can shortcut this by only going through half the string and checking for edge cases with the middle token\\n\\n# Complexity\\n- Time complexity: $O(n)$; or $O(n*l)$ when we assume substring equality check takes $O(l)$, $l$ would be the longest token length\\n\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn longest_decomposition(text: String) -> i32 {\\n        let mut singlecentre = true;\\n        let mut tokencount = 0;\\n        let mut prevtokenend = 0;\\n        let tl = text.len();\\n        let maxi = (tl)/2+1;\\n        for i in 1..maxi{\\n            if (i<=prevtokenend){continue;}\\n            if text[prevtokenend..i] == text[(tl-i)..(tl-prevtokenend)]{\\n                tokencount +=1;\\n                if i >= maxi-1 && tl % 2 !=1{\\n                    singlecentre = false;\\n                    if prevtokenend>i-1 {\\n                        tokencount -=1;\\n                    }\\n                }\\n                prevtokenend = i;\\n            }\\n        }\\n        tokencount *2 + if singlecentre {1} else {0}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_decomposition(text: String) -> i32 {\\n        let mut tokencount = 0;\\n        let mut prevtokenend = 0;\\n        let tl = text.len();\\n        let maxi = (tl)/2+1;\\n        for i in 1..maxi{\\n            if (i<=prevtokenend){continue;} //length of token would be 0, skip\\n            if text[prevtokenend..i] == text[(tl-i)..(tl-prevtokenend)]{\\n                //the token matched, count it and set start for next token to current end\\n                tokencount +=1;\\n                prevtokenend = i;\\n            }\\n        }\\n        tokencount\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn longest_decomposition(text: String) -> i32 {\\n        let mut singlecentre = true;\\n        let mut tokencount = 0;\\n        let mut prevtokenend = 0;\\n        let tl = text.len();\\n        let maxi = (tl)/2+1;\\n        for i in 1..maxi{\\n            if (i<=prevtokenend){continue;}\\n            if text[prevtokenend..i] == text[(tl-i)..(tl-prevtokenend)]{\\n                tokencount +=1;\\n                if i >= maxi-1 && tl % 2 !=1{\\n                    singlecentre = false;\\n                    if prevtokenend>i-1 {\\n                        tokencount -=1;\\n                    }\\n                }\\n                prevtokenend = i;\\n            }\\n        }\\n        tokencount *2 + if singlecentre {1} else {0}\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2773968,
                "title": "python3-simple-fast-am-i-missing-something",
                "content": "Usually find the \"hard\" problems much harder, maybe I\\'m missing something, maybe I lucked out?\\n\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        \\n        count = 0\\n        \\n        curr = \"\" \\n        \\n        while len(curr) < len(text) / 2 and len(text) > 1:\\n            \\n            curr = curr + text[len(curr)]\\n       \\n            if text.endswith(curr):\\n                count += 2\\n                text = text[len(curr):-len(curr)]\\n                curr = \"\"\\n                \\n        if len(text) > 0:\\n            count += 1\\n        \\n        return count\\n   ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        \\n        count = 0\\n        \\n        curr = \"\" \\n        \\n        while len(curr) < len(text) / 2 and len(text) > 1:\\n            \\n            curr = curr + text[len(curr)]\\n       \\n            if text.endswith(curr):\\n                count += 2\\n                text = text[len(curr):-len(curr)]\\n                curr = \"\"\\n                \\n        if len(text) > 0:\\n            count += 1\\n        \\n        return count\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 2746035,
                "title": "java-o-n-time-o-1-memory-rolling-hash-simple",
                "content": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int hl = 0, hr = 0, exp = 1, ans = 0;\\n        int i = 0, j = text.length() - 1, p = 0;\\n        for (; j > i; ++i, --j) {\\n            hl = 31 * hl + (text.charAt(i) - \\'a\\');\\n            hr += exp * (text.charAt(j) - \\'a\\');\\n            if (hl == hr) {\\n                // check for conflicts\\n                int x = p;\\n                for (int y = j; x <= i && text.charAt(x) == text.charAt(y); ++x, ++y) {\\n                }\\n                if (x > i) {\\n                    exp = 1;\\n                    hl = hr = 0;\\n                    p = x;\\n                    ans += 2;\\n                    continue;\\n                }\\n            }\\n            exp *= 31;\\n        }\\n        return (p < i || i == j) ? ans + 1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int hl = 0, hr = 0, exp = 1, ans = 0;\\n        int i = 0, j = text.length() - 1, p = 0;\\n        for (; j > i; ++i, --j) {\\n            hl = 31 * hl + (text.charAt(i) - \\'a\\');\\n            hr += exp * (text.charAt(j) - \\'a\\');\\n            if (hl == hr) {\\n                // check for conflicts\\n                int x = p;\\n                for (int y = j; x <= i && text.charAt(x) == text.charAt(y); ++x, ++y) {\\n                }\\n                if (x > i) {\\n                    exp = 1;\\n                    hl = hr = 0;\\n                    p = x;\\n                    ans += 2;\\n                    continue;\\n                }\\n            }\\n            exp *= 31;\\n        }\\n        return (p < i || i == j) ? ans + 1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697185,
                "title": "java-greedy",
                "content": "```\\npublic class LongestChunkedPalindromeDecomposition1147 {\\n    public static void main(String[] args) {\\n        System.out.println(longestDecomposition(\"antaprezatepzapreanta\"));\\n    }\\n    public static int longestDecomposition(String text) {\\n\\n        int start = 0;\\n        int end = text.length() -1 ;\\n\\n        String startTemp = \"\";\\n        String endTemp = \"\";\\n\\n        int sameCount = 0;\\n        while( end != -1){\\n            startTemp += text.charAt(start++);\\n            endTemp = text.charAt(end--) + endTemp;\\n\\n            if(startTemp.equals(endTemp)){\\n                sameCount++;\\n                startTemp = \"\";\\n                endTemp = \"\";\\n            }\\n\\n        }\\n\\n        if(sameCount == 0){\\n            return 1;\\n        }\\n        return sameCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\npublic class LongestChunkedPalindromeDecomposition1147 {\\n    public static void main(String[] args) {\\n        System.out.println(longestDecomposition(\"antaprezatepzapreanta\"));\\n    }\\n    public static int longestDecomposition(String text) {\\n\\n        int start = 0;\\n        int end = text.length() -1 ;\\n\\n        String startTemp = \"\";\\n        String endTemp = \"\";\\n\\n        int sameCount = 0;\\n        while( end != -1){\\n            startTemp += text.charAt(start++);\\n            endTemp = text.charAt(end--) + endTemp;\\n\\n            if(startTemp.equals(endTemp)){\\n                sameCount++;\\n                startTemp = \"\";\\n                endTemp = \"\";\\n            }\\n\\n        }\\n\\n        if(sameCount == 0){\\n            return 1;\\n        }\\n        return sameCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695526,
                "title": "c-memoization",
                "content": "**Here I used the string_view(c++ 17 >=) instead of simple string to get string comparison in O(1)**\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int solve(string_view & s,int i,int j)\\n    {\\n        if(i == j) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int res = 1;\\n        for(int k = 1;k<=s.length()/2;k++)\\n        {\\n            if(s.substr(0,k) == s.substr(s.length()-k))\\n            {\\n                string_view t = s.substr(k,s.length()-2*k);\\n                if(t.length() ==  0)\\n                {\\n                    res = max(res,solve(t,i,j-k)+1);\\n                }else\\n                {\\n                    res = max(res,solve(t,i,j-k)+2);\\n                }\\n            }\\n        }\\n        return dp[i][j] = res;\\n    }\\n    int longestDecomposition(string text) {\\n        memset(dp,-1,sizeof(dp));\\n        string_view ss = string_view(text);\\n        return solve(ss,0,text.length()-1);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int solve(string_view & s,int i,int j)\\n    {\\n        if(i == j) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int res = 1;\\n        for(int k = 1;k<=s.length()/2;k++)\\n        {\\n            if(s.substr(0,k) == s.substr(s.length()-k))\\n            {\\n                string_view t = s.substr(k,s.length()-2*k);\\n                if(t.length() ==  0)\\n                {\\n                    res = max(res,solve(t,i,j-k)+1);\\n                }else\\n                {\\n                    res = max(res,solve(t,i,j-k)+2);\\n                }\\n            }\\n        }\\n        return dp[i][j] = res;\\n    }\\n    int longestDecomposition(string text) {\\n        memset(dp,-1,sizeof(dp));\\n        string_view ss = string_view(text);\\n        return solve(ss,0,text.length()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617431,
                "title": "simplified-two-pointers-all-edge-cases-handled-neat-and-clean-code",
                "content": "Very sure, Two Pointers will be used in this problem.\\n\\nBut `How can we optimize it so that it covers all edge cases ?` \\n\\nIn most solutions, we are running ith pointer till half of the array and incrementing the result twice everytime.\\n\\nBut now, ith pointer will loop from start to end and res will be increased by one only.\\n\\nBecause every state of division will be witnessed twice as we are looping till the end.\\n\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int n=text.length();\\n        \\n        String l=\"\";\\n        String r=\"\";\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            l+=text.charAt(i);\\n            r=text.charAt(n-i-1)+r;\\n            \\n            if(l.equals(r)){\\n                l=\"\";\\n                r=\"\";\\n                ans++;\\n            }\\n           \\n            \\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n   \\n}\\n```\\n\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int n=text.length();\\n        \\n        String l=\"\";\\n        String r=\"\";\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            l+=text.charAt(i);\\n            r=text.charAt(n-i-1)+r;\\n            \\n            if(l.equals(r)){\\n                l=\"\";\\n                r=\"\";\\n                ans++;\\n            }\\n           \\n            \\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611727,
                "title": "c-100-2-pointer-approach-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int start = 0, end = text.length()-1;\\n        int count = 0, endL = end+1;\\n        while (start < end) {\\n            if (text[end] == text[start]) {\\n                int i = start, j = end;\\n                while (j < endL && (text[i] == text[j])) {\\n                    i++; j++;\\n                }\\n                if (std::abs(start - i)==std::abs(end-endL)) {\\n                    endL = end;\\n                    end--;\\n                    start = i;\\n                    count+=2;\\n                } else {\\n                    end--;\\n                }\\n            } else {\\n                end--;\\n            }\\n        }\\n        if (start == end) count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int start = 0, end = text.length()-1;\\n        int count = 0, endL = end+1;\\n        while (start < end) {\\n            if (text[end] == text[start]) {\\n                int i = start, j = end;\\n                while (j < endL && (text[i] == text[j])) {\\n                    i++; j++;\\n                }\\n                if (std::abs(start - i)==std::abs(end-endL)) {\\n                    endL = end;\\n                    end--;\\n                    start = i;\\n                    count+=2;\\n                } else {\\n                    end--;\\n                }\\n            } else {\\n                end--;\\n            }\\n        }\\n        if (start == end) count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567646,
                "title": "python3-recursive-dp",
                "content": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        n=len(text)-1\\n        dp=[[-1 for i in range(n+1)] for j in range(n+1)]\\n        def dfs(start,end):\\n            if start>end:\\n                return 0\\n            if dp[start][end]!=-1:\\n                return dp[start][end]\\n            best=1\\n            l,r=start,end\\n            mid=(r+l)//2\\n            while r>mid:\\n                chunk=end-r+1\\n                if text[l:l+chunk]==text[r:end+1]:\\n                    val=dfs(l+chunk,r-1)+2\\n                    best=max(best,val)\\n                r-=1\\n            dp[start][end]=best\\n            return dp[start][end]\\n        return dfs(0,n)\\n                    \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        n=len(text)-1\\n        dp=[[-1 for i in range(n+1)] for j in range(n+1)]\\n        def dfs(start,end):\\n            if start>end:\\n                return 0\\n            if dp[start][end]!=-1:\\n                return dp[start][end]\\n            best=1\\n            l,r=start,end\\n            mid=(r+l)//2\\n            while r>mid:\\n                chunk=end-r+1\\n                if text[l:l+chunk]==text[r:end+1]:\\n                    val=dfs(l+chunk,r-1)+2\\n                    best=max(best,val)\\n                r-=1\\n            dp[start][end]=best\\n            return dp[start][end]\\n        return dfs(0,n)\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557831,
                "title": "faster-than-99-38-of-java-solution-o-n-complexity",
                "content": "public int longestDecomposition(String text) {\\n        int start = 0;\\n        int end = text.length()-1;\\n        int count=0;\\n        int leng = 0;\\n        while(start <= end){\\n            if(start==end){\\n                count++;\\n                break;\\n            }\\n            if(text.charAt(start)==text.charAt(end) && text.substring(start,start+leng+1).equals(text.substring(end,end+leng+1))) {\\n                count += 2;\\n                start = start + leng + 1;\\n                leng = 0;\\n                end = end - 1;\\n            }\\n            else{\\n                end--;\\n                leng++;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "public int longestDecomposition(String text) {\\n        int start = 0;\\n        int end = text.length()-1;\\n        int count=0;\\n        int leng = 0;\\n        while(start <= end){\\n            if(start==end){\\n                count++;\\n                break;\\n            }\\n            if(text.charAt(start)==text.charAt(end) && text.substring(start,start+leng+1).equals(text.substring(end,end+leng+1))) {\\n                count += 2;\\n                start = start + leng + 1;\\n                leng = 0;\\n                end = end - 1;\\n            }\\n            else{\\n                end--;\\n                leng++;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2546083,
                "title": "c-kmp-dp",
                "content": "```\\nconst int                   N   = 10 + 1e3;\\n\\nint     n;\\nint     Next[N];\\nint     f[N][N];\\n\\n\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s) {\\n        n = s.size();\\n        s = \"#\" + s;\\n        \\n        memset(f, 0, sizeof(f));\\n\\n        int k = 0;\\n        for (int l = n; l >= 1; l--) {          Next[l] = k = l-1;      f[l][l] = 1;\\n            for (int r = l+1; r <= n; r++) {                            f[l][r] = 1;\\n                while (k>=l && s[k+1] != s[r]) k = Next[k];\\n                if (s[k+1] == s[r]) k++;\\n                Next[r] = k;\\n                \\n                for (int i = k; i >= l; i = Next[i]) if ((i-l+1)*2 <= (r-l+1)){\\n                    f[l][r] = max(f[l][r], f[i+1][r-(i-l+1)] + 2);\\n                }\\n            }\\n        }\\n        return f[1][n];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nconst int                   N   = 10 + 1e3;\\n\\nint     n;\\nint     Next[N];\\nint     f[N][N];\\n\\n\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s) {\\n        n = s.size();\\n        s = \"#\" + s;\\n        \\n        memset(f, 0, sizeof(f));\\n\\n        int k = 0;\\n        for (int l = n; l >= 1; l--) {          Next[l] = k = l-1;      f[l][l] = 1;\\n            for (int r = l+1; r <= n; r++) {                            f[l][r] = 1;\\n                while (k>=l && s[k+1] != s[r]) k = Next[k];\\n                if (s[k+1] == s[r]) k++;\\n                Next[r] = k;\\n                \\n                for (int i = k; i >= l; i = Next[i]) if ((i-l+1)*2 <= (r-l+1)){\\n                    f[l][r] = max(f[l][r], f[i+1][r-(i-l+1)] + 2);\\n                }\\n            }\\n        }\\n        return f[1][n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541214,
                "title": "two-pointers-approach-c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int s=0,e=text.size()-1;\\n        int first_found=0,last_found=text.size()-1;\\n        int cnt=0;\\n        while(s<e){\\n            string a=text.substr(first_found,s-first_found+1);\\n            string b=text.substr(e,last_found-e+1);\\n            s++;\\n            e--;\\n            if(a==b){\\n                cnt+=2;\\n                first_found=s;\\n                last_found=e;\\n            }   \\n        }\\n        if(first_found<=last_found){\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int s=0,e=text.size()-1;\\n        int first_found=0,last_found=text.size()-1;\\n        int cnt=0;\\n        while(s<e){\\n            string a=text.substr(first_found,s-first_found+1);\\n            string b=text.substr(e,last_found-e+1);\\n            s++;\\n            e--;\\n            if(a==b){\\n                cnt+=2;\\n                first_found=s;\\n                last_found=e;\\n            }   \\n        }\\n        if(first_found<=last_found){\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539927,
                "title": "javascript-100-fast-easy",
                "content": "```\\nvar longestDecomposition = function(text) {\\n    let counter = 0\\n    let len = text.length\\n\\n    for (let i = 1; i <= len / 2; i++) {\\n        const start = text.substr(0, i)\\n        const end = text.substr(len - i, i)\\n        if (start == end) {\\n            // Cut palindromes from text, increase counter, loop again\\n            text = text.substr(0, len - i).substr(i)\\n            len = text.length\\n            i = 0\\n            counter += 2\\n        }\\n    }\\n\\n    return counter + (text.length ? 1 : 0)\\n};\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/1fbaeec9-f8b9-4a43-b5e3-5a2ad890fcb6_1662467617.2266948.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nvar longestDecomposition = function(text) {\\n    let counter = 0\\n    let len = text.length\\n\\n    for (let i = 1; i <= len / 2; i++) {\\n        const start = text.substr(0, i)\\n        const end = text.substr(len - i, i)\\n        if (start == end) {\\n            // Cut palindromes from text, increase counter, loop again\\n            text = text.substr(0, len - i).substr(i)\\n            len = text.length\\n            i = 0\\n            counter += 2\\n        }\\n    }\\n\\n    return counter + (text.length ? 1 : 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2539337,
                "title": "golang-two-pointer",
                "content": "Simple two pointer solution. \\n\\nRuntime: 4 ms, faster than 75.00% of Go online submissions for Longest Chunked Palindrome Decomposition.\\nMemory Usage: 2 MB, less than 75.00% of Go online submissions for Longest Chunked Palindrome Decomposition.\\n\\n```\\nfunc longestDecomposition(text string) int {\\n\\t// used for right pointer\\n\\tn := len(text)-1\\n\\t// last is used to keep track of the last word\\'s index that we find\\n    last, ans := 0, 0\\n    for i := range text {\\n\\t    // check if the first word matches the second word\\n\\t\\t// we make use of the `last` pointer here to search for the next matching words\\n        if text[last:i+1] == text[n-i:n-last+1] {\\n\\t\\t\\t// update answer and move last pointer\\n            ans++\\n            last = i+1\\n        }\\n    }\\n    \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestDecomposition(text string) int {\\n\\t// used for right pointer\\n\\tn := len(text)-1\\n\\t// last is used to keep track of the last word\\'s index that we find\\n    last, ans := 0, 0\\n    for i := range text {\\n\\t    // check if the first word matches the second word\\n\\t\\t// we make use of the `last` pointer here to search for the next matching words\\n        if text[last:i+1] == text[n-i:n-last+1] {\\n\\t\\t\\t// update answer and move last pointer\\n            ans++\\n            last = i+1\\n        }\\n    }\\n    \\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2537039,
                "title": "c-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s)\\n    {\\n        int n=s.size(),i=0,res=0;\\n        string l=\"\",r=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            l=l+s[i];\\n            r=s[n-1-i]+r;\\n            if(l==r)\\n            {\\n                res++;\\n                l=\"\";\\n                r=\"\";\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int longestDecomposition(string s)\\n    {\\n        int n=s.size(),i=0,res=0;\\n        string l=\"\",r=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            l=l+s[i];\\n            r=s[n-1-i]+r;\\n            if(l==r)\\n            {\\n                res++;\\n                l=\"\";\\n                r=\"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2532852,
                "title": "c-pointer-and-sliding-window-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/ba72f1b8-90e6-4b2f-b5c6-9ad27833ee41_1662354871.486079.jpeg)\\n\\n\\n<br/><br/>\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int left_bound=0, right_bound=text.size()-1, left=0, right=text.size()-1, left_itr, right_itr, count=0;\\n        \\n        while(left<=right) {\\n            right_itr=right;\\n            // right_itr will find a matched char same as at left_bound\\n            while(right_itr>=0 and text[right_itr]!=text[left_bound]) \\n                right_itr--;\\n            right=right_itr;      // now we consider right window as [right, right_bound]\\n            left_itr=left_bound;\\n            // to check if we find a matched window in the left side same as right window\\n            while(right_itr<=right_bound and text[right_itr]==text[left_itr]) {\\n                right_itr++;\\n                left_itr++;\\n            }\\n            \\n            right_itr--;\\n            left_itr--;\\n            left=left_itr;\\n            // if both left window and right window matched\\n            if(right_itr==right_bound) {\\n                if(left_itr==right_itr) count+=1;      // both are actually same window\\n                else count+=2;                         // different window\\n                left_bound=left+1;\\n                left=left+1;\\n                right_bound=right-1;\\n                right=right-1;\\n            } else {\\n                right--;         // left window and right window didn\\'t matched\\n            }\\n            \\n        }\\n        \\n        return text.size()<2 ? text.size() : count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int left_bound=0, right_bound=text.size()-1, left=0, right=text.size()-1, left_itr, right_itr, count=0;\\n        \\n        while(left<=right) {\\n            right_itr=right;\\n            // right_itr will find a matched char same as at left_bound\\n            while(right_itr>=0 and text[right_itr]!=text[left_bound]) \\n                right_itr--;\\n            right=right_itr;      // now we consider right window as [right, right_bound]\\n            left_itr=left_bound;\\n            // to check if we find a matched window in the left side same as right window\\n            while(right_itr<=right_bound and text[right_itr]==text[left_itr]) {\\n                right_itr++;\\n                left_itr++;\\n            }\\n            \\n            right_itr--;\\n            left_itr--;\\n            left=left_itr;\\n            // if both left window and right window matched\\n            if(right_itr==right_bound) {\\n                if(left_itr==right_itr) count+=1;      // both are actually same window\\n                else count+=2;                         // different window\\n                left_bound=left+1;\\n                left=left+1;\\n                right_bound=right-1;\\n                right=right-1;\\n            } else {\\n                right--;         // left window and right window didn\\'t matched\\n            }\\n            \\n        }\\n        \\n        return text.size()<2 ? text.size() : count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518112,
                "title": "string-two-pointer",
                "content": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        return solve(text,0);\\n    }\\n    public int solve(String text,int i){\\n        //System.out.println(text);\\n        if(text.equals(\"\"))\\n            return 0;\\n        if(i>=text.length()/2)\\n            return 1;\\n        String prefix=text.substring(0,i+1);\\n        String suffix=text.substring(text.length()-i-1,text.length());\\n        \\n        if(prefix.equals(suffix)){\\n            //System.out.println(prefix);\\n            return 2+solve(text.substring(i+1,text.length()-i-1),0);\\n        }\\n        else{\\n            return solve(text,i+1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        return solve(text,0);\\n    }\\n    public int solve(String text,int i){\\n        //System.out.println(text);\\n        if(text.equals(\"\"))\\n            return 0;\\n        if(i>=text.length()/2)\\n            return 1;\\n        String prefix=text.substring(0,i+1);\\n        String suffix=text.substring(text.length()-i-1,text.length());\\n        \\n        if(prefix.equals(suffix)){\\n            //System.out.println(prefix);\\n            return 2+solve(text.substring(i+1,text.length()-i-1),0);\\n        }\\n        else{\\n            return solve(text,i+1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497821,
                "title": "python-solution-greedy-recursive",
                "content": "```\\nclass Solution:\\n    # This question asks for COMPLETE split\\n    # So, the strategy is to construct substring from two ends of the string\\n    # if see perfect match, we add 2 to the result\\n    # When both pointers reaches the end, we return 1\\n\\t# Edge case: text is empty, return 0\\n    def longestDecomposition(self, text: str) -> int:\\n        if not text:\\n            return 0\\n        l, r = 0, len(text)-1\\n        prefix, suffix, match = \"\", \"\", False \\n        while l < len(text) and r >= 0 and not match:\\n            prefix += text[l]\\n            suffix = text[r] + suffix\\n            if prefix == suffix:\\n                match = True\\n            l += 1\\n            r -= 1\\n        if l == len(text) and r == -1:\\n            return 1\\n        else:\\n            return 2 + self.longestDecomposition(text[l:r+1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # This question asks for COMPLETE split\\n    # So, the strategy is to construct substring from two ends of the string\\n    # if see perfect match, we add 2 to the result\\n    # When both pointers reaches the end, we return 1\\n\\t# Edge case: text is empty, return 0\\n    def longestDecomposition(self, text: str) -> int:\\n        if not text:\\n            return 0\\n        l, r = 0, len(text)-1\\n        prefix, suffix, match = \"\", \"\", False \\n        while l < len(text) and r >= 0 and not match:\\n            prefix += text[l]\\n            suffix = text[r] + suffix\\n            if prefix == suffix:\\n                match = True\\n            l += 1\\n            r -= 1\\n        if l == len(text) and r == -1:\\n            return 1\\n        else:\\n            return 2 + self.longestDecomposition(text[l:r+1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461596,
                "title": "java-easy-to-understand-two-pointers",
                "content": "The approach is very simple. Start collecting the characters from left and right separately. \\n\\n```\\npublic int longestDecomposition(String text) {\\n        if(text == null || text.length() == 0) return 0;\\n\\n        int n = text.length();\\n        StringBuilder left = new StringBuilder();\\n        String right = \"\";\\n\\n        int matchedCount = 0;\\n\\n        for(int i=0; i < text.length(); i++) {\\n            left.append(text.charAt(i));\\n            right = text.charAt(n - i - 1) + right;\\n            if(left.toString().equals(right)){\\n                matchedCount++;\\n                left = new StringBuilder();\\n                right = \"\";\\n            }\\n        }\\n\\n        return matchedCount;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic int longestDecomposition(String text) {\\n        if(text == null || text.length() == 0) return 0;\\n\\n        int n = text.length();\\n        StringBuilder left = new StringBuilder();\\n        String right = \"\";\\n\\n        int matchedCount = 0;\\n\\n        for(int i=0; i < text.length(); i++) {\\n            left.append(text.charAt(i));\\n            right = text.charAt(n - i - 1) + right;\\n            if(left.toString().equals(right)){\\n                matchedCount++;\\n                left = new StringBuilder();\\n                right = \"\";\\n            }\\n        }\\n\\n        return matchedCount;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2458452,
                "title": "simple-short-c-code",
                "content": "```\\n//The logic part is preety straightforward we just have to compare prefix string \\n//and suffix string (mentioned as start & end)\\n//There are two cases :\\n//1. n is even - in this case the edge case is that from the ith position till n/2-1\\n//if it is not equal to corresponding suffix then that complete whole string is \\n//considered to be 1. how do we check this ?? by placing continue statement \\n// in the comparison (start==end)\\n\\n//2.n is odd- this is somewhat in continuation to even case if suppose from the \\n// ith position till n/2-1 is equal to corresponding suffix then flag still remains //true and as the length is odd there must be some character left which will be\\n//cnt as 1 therefore increament in ans as ans++;\\n\\n int longestDecomposition(string text) {\\n     \\n        string start,end;\\n        int n=text.size();\\n        \\n        int ans=0,lastIndx=n;\\n        int flag=1;\\n        for(int i=0;i<n/2;i++){\\n          start+=text[i];\\n          end=\"\";  \\n          for(int j=n-1-i;j<lastIndx;j++){\\n              end+=text[j];\\n          }\\n          if(start==end){\\n              ans+=2;\\n              start=\"\";\\n             lastIndx=n-1-i;\\n              continue;\\n          }\\n          if(i==n/2-1)flag=0,ans++; \\n        }\\n        if(flag && n%2)ans++;\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n//The logic part is preety straightforward we just have to compare prefix string \\n//and suffix string (mentioned as start & end)\\n//There are two cases :\\n//1. n is even - in this case the edge case is that from the ith position till n/2-1\\n//if it is not equal to corresponding suffix then that complete whole string is \\n//considered to be 1. how do we check this ?? by placing continue statement \\n// in the comparison (start==end)\\n\\n//2.n is odd- this is somewhat in continuation to even case if suppose from the \\n// ith position till n/2-1 is equal to corresponding suffix then flag still remains //true and as the length is odd there must be some character left which will be\\n//cnt as 1 therefore increament in ans as ans++;\\n\\n int longestDecomposition(string text) {\\n     \\n        string start,end;\\n        int n=text.size();\\n        \\n        int ans=0,lastIndx=n;\\n        int flag=1;\\n        for(int i=0;i<n/2;i++){\\n          start+=text[i];\\n          end=\"\";  \\n          for(int j=n-1-i;j<lastIndx;j++){\\n              end+=text[j];\\n          }\\n          if(start==end){\\n              ans+=2;\\n              start=\"\";\\n             lastIndx=n-1-i;\\n              continue;\\n          }\\n          if(i==n/2-1)flag=0,ans++; \\n        }\\n        if(flag && n%2)ans++;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2449835,
                "title": "c-simple-c-code",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    bool issame(string &lst, string &rst)\\n    {\\n        for(int i = 0; i < lst.size(); i++)\\n        {\\n            if(lst[i] != rst[i])\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        int left = 0, right = n-1, ans = 0;\\n        string lst = \"\", rst = \"\";\\n        while(left < right)\\n        {\\n            lst.push_back(text[left]);\\n            rst = text[right] + rst;\\n            if(issame(lst,rst))\\n            {\\n                ans +=2;\\n                lst = \"\";\\n                rst = \"\";\\n            }\\n            if(left+1 == right && lst == rst)\\n                return ans;\\n            left++;\\n            right--;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    bool issame(string &lst, string &rst)\\n    {\\n        for(int i = 0; i < lst.size(); i++)\\n        {\\n            if(lst[i] != rst[i])\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        int left = 0, right = n-1, ans = 0;\\n        string lst = \"\", rst = \"\";\\n        while(left < right)\\n        {\\n            lst.push_back(text[left]);\\n            rst = text[right] + rst;\\n            if(issame(lst,rst))\\n            {\\n                ans +=2;\\n                lst = \"\";\\n                rst = \"\";\\n            }\\n            if(left+1 == right && lst == rst)\\n                return ans;\\n            left++;\\n            right--;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439732,
                "title": "easy-to-understand-python-solution",
                "content": "\\t\\tclass Solution:\\n\\t\\t\\tdef longestDecomposition(self, text: str) -> int:\\n\\t\\t\\t\\n\\t\\t\\t\\treverse = text[::-1]\\n\\t\\t\\t\\tk = 0\\n\\t\\t\\t\\tpreviousIdx = 0\\n\\t\\t\\t\\tnextIdx = 1\\n\\n\\t\\t\\t\\twhile nextIdx < len(reverse) + 1:\\n\\t\\t\\t\\t\\tif reverse[previousIdx:nextIdx][::-1] == text[previousIdx:nextIdx]:\\n\\t\\t\\t\\t\\t\\tpreviousIdx = nextIdx\\n\\t\\t\\t\\t\\t\\tk += 1\\n\\t\\t\\t\\t\\tnextIdx += 1\\n\\n\\t\\t\\t\\treturn(k)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\tclass Solution:\\n\\t\\t\\tdef longestDecomposition(self, text: str) -> int:\\n\\t\\t\\t\\n\\t\\t\\t\\treverse = text[::-1]\\n\\t\\t\\t\\tk = 0\\n\\t\\t\\t\\tpreviousIdx = 0\\n\\t\\t\\t\\tnextIdx = 1\\n\\n\\t\\t\\t\\twhile nextIdx < len(reverse) + 1:\\n\\t\\t\\t\\t\\tif reverse[previousIdx:nextIdx][::-1] == text[previousIdx:nextIdx]:\\n\\t\\t\\t\\t\\t\\tpreviousIdx = nextIdx\\n\\t\\t\\t\\t\\t\\tk += 1\\n\\t\\t\\t\\t\\tnextIdx += 1\\n\\n\\t\\t\\t\\treturn(k)",
                "codeTag": "Java"
            },
            {
                "id": 2421223,
                "title": "c-faster-than-100-o-n-time-complexity",
                "content": "int longestDecomposition(string s) {\\n        \\n        int n = s.length();\\n        \\n        int i=0,j=n-1;\\n        int count=0;\\n        string left=\"\",right=\"\";\\n        while(i<j){\\n            left+=s[i];\\n            right = s[j]+right;\\n            \\n            if(left==right){\\n                count+=2;\\n                left=\"\";\\n                right=\"\";\\n            }\\n            if(i+1==j && left==right){\\n                return count;\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        return count+1;\\n    }\\n};",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "int longestDecomposition(string s) {\\n        \\n        int n = s.length();\\n        \\n        int i=0,j=n-1;\\n        int count=0;\\n        string left=\"\",right=\"\";\\n        while(i<j){\\n            left+=s[i];\\n            right = s[j]+right;\\n            \\n            if(left==right){\\n                count+=2;\\n                left=\"\";\\n                right=\"\";\\n            }\\n            if(i+1==j && left==right){\\n                return count;\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        return count+1;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2411362,
                "title": "c-100-fast-solution",
                "content": "\\'\\'\\' \\nclass Solution { \\npublic:\\n\\n    int longestDecomposition(string text) {\\n\\t\\n        int ans = 0 , n = text.size();\\n\\t\\t\\n        int i = -1 , j = n;\\n        \\n        while(i < j-1){\\n            \\n            int k = j-1;\\n            while(k >i && text.substr(k , (j-k)) != text.substr(i+1,(j-k)) ){\\n                k--;\\n            }\\n            \\n            if(k == i+1){\\n                ans +=1;\\n            }else{\\n                ans +=2;\\n            }\\n            i = i+ (j-k);\\n            j = k;\\n        }\\n        return ans;\\n    }\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution { \\npublic:\\n\\n    int longestDecomposition(string text) {\\n\\t\\n        int ans = 0 , n = text.size();\\n\\t\\t\\n        int i = -1 , j = n;\\n        \\n        while(i < j-1){\\n            \\n            int k = j-1;\\n            while(k >i && text.substr(k , (j-k)) != text.substr(i+1,(j-k)) ){\\n                k--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2340593,
                "title": "python-3-rolling-hash",
                "content": "\\tclass Solution:\\n\\t\\tdef longestDecomposition(self, text: str) -> int:\\n\\t\\t\\tdef get_val(ch):\\n\\t\\t\\t\\treturn ord(ch)-ord(\\'a\\')\\n\\t\\t\\tn=len(text)\\n\\t\\t\\tl,r=0,n-1\\n\\t\\t\\tp,mod=26,pow(10,9)+7\\n\\t\\t\\tc=1\\n\\t\\t\\th1=h2=count=size=0\\n\\t\\t\\twhile l<r:\\n\\t\\t\\t\\th1=(h1*p+get_val(text[l]))%mod\\n\\t\\t\\t\\th2=(c*get_val(text[r])+h2)%mod\\n\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\tr-=1\\n\\t\\t\\t\\tsize+=1\\n\\t\\t\\t\\tif h1==h2:\\n\\t\\t\\t\\t\\tcount+=2\\n\\t\\t\\t\\t\\tc=1\\n\\t\\t\\t\\t\\th1=h2=size=0\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tc*=p\\n\\t\\t\\treturn count+ int((size == 0 and l == r) or size > 0)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef longestDecomposition(self, text: str) -> int:\\n\\t\\t\\tdef get_val(ch):\\n\\t\\t\\t\\treturn ord(ch)-ord(\\'a\\')\\n\\t\\t\\tn=len(text)\\n\\t\\t\\tl,r=0,n-1\\n\\t\\t\\tp,mod=26,pow(10,9)+7\\n\\t\\t\\tc=1\\n\\t\\t\\th1=h2=count=size=0\\n\\t\\t\\twhile l<r:\\n\\t\\t\\t\\th1=(h1*p+get_val(text[l]))%mod\\n\\t\\t\\t\\th2=(c*get_val(text[r])+h2)%mod\\n\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\tr-=1\\n\\t\\t\\t\\tsize+=1\\n\\t\\t\\t\\tif h1==h2:\\n\\t\\t\\t\\t\\tcount+=2\\n\\t\\t\\t\\t\\tc=1\\n\\t\\t\\t\\t\\th1=h2=size=0\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tc*=p\\n\\t\\t\\treturn count+ int((size == 0 and l == r) or size > 0)",
                "codeTag": "Java"
            },
            {
                "id": 2331574,
                "title": "2-ms-faster-then-83-56-java-solution",
                "content": "2 ms , Faster then 83.56% || JAVA SOLUTION\\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int n = text.length();\\n        int i=0,j=text.length()-1,ans = 0;\\n        StringBuilder s = new StringBuilder();\\n        while(i<=j){\\n            //find the start char from last and add it in string;\\n            while(text.charAt(j)!=text.charAt(i)){ \\n                s.append(text.charAt(j)); \\n                j--;\\n            }\\n            // when both char are same we terminate from while loop so add explicitly\\n            s.append(text.charAt(j));\\n            \\n            //check string from start is equal to string from back\\n            if(text.substring(i,n-j).equals(s.reverse().toString())){\\n                ans++;\\n                i=n-j; \\n                s.setLength(0);\\n            }\\n            // while checking in if condition we reverse s ,to get back we again reverse it\\n            else{\\n                s.reverse();   \\n            }\\n            j--;\\n        }\\n        //when each substring in string occur twice\\n        if(i==j+1){\\n            return (2*ans);\\n        }\\n        return (2*ans)-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int n = text.length();\\n        int i=0,j=text.length()-1,ans = 0;\\n        StringBuilder s = new StringBuilder();\\n        while(i<=j){\\n            //find the start char from last and add it in string;\\n            while(text.charAt(j)!=text.charAt(i)){ \\n                s.append(text.charAt(j)); \\n                j--;\\n            }\\n            // when both char are same we terminate from while loop so add explicitly\\n            s.append(text.charAt(j));\\n            \\n            //check string from start is equal to string from back\\n            if(text.substring(i,n-j).equals(s.reverse().toString())){\\n                ans++;\\n                i=n-j; \\n                s.setLength(0);\\n            }\\n            // while checking in if condition we reverse s ,to get back we again reverse it\\n            else{\\n                s.reverse();   \\n            }\\n            j--;\\n        }\\n        //when each substring in string occur twice\\n        if(i==j+1){\\n            return (2*ans);\\n        }\\n        return (2*ans)-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2302425,
                "title": "java-string-prefix-solution",
                "content": "class Solution {\\n\\n    public int longestDecomposition(String text) {\\n        \\n        //prefix, suffix check\\n        //prefix == suffix result+=2;\\n        //prefix == text result+1 return;\\n        int result = 0;\\n        int start = 0;\\n        int left = 1;\\n        \\n        while(text.length() > 0) {\\n            String pre = text.substring(start, left);\\n\\n            if(text.equals(pre) == true) return ++result;\\n            \\n            else if(text.endsWith(pre) == true) {\\n                result+=2;\\n                text = text.substring(start + pre.length(), text.length() - pre.length());\\n                left = 1;\\n            }\\n\\n            else left++;\\n        }\\n    return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n\\n    public int longestDecomposition(String text) {\\n        \\n        //prefix, suffix check\\n        //prefix == suffix result+=2;\\n        //prefix == text result+1 return;\\n        int result = 0;\\n        int start = 0;\\n        int left = 1;\\n        \\n        while(text.length() > 0) {\\n            String pre = text.substring(start, left);\\n\\n            if(text.equals(pre) == true) return ++result;\\n            \\n            else if(text.endsWith(pre) == true) {\\n                result+=2;\\n                text = text.substring(start + pre.length(), text.length() - pre.length());\\n                left = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2298613,
                "title": "o-n-c-solution-using-rolling-hash",
                "content": "```\\n#define ll long long\\n#define mod 1000000007\\n#define p 31\\n\\nclass Solution {\\npublic:\\n    ll hash[1002];\\n    ll p_pow[1003];\\n\\n    int cal(int l,int r){\\n        // to calculate hash between l to r\\n        ll var=(hash[r]-hash[l-1]+mod)%mod;\\n        var=var*(p_pow[1001-l])%mod;\\n        return var;\\n    }\\n    \\n    int longestDecomposition(string s) {\\n      int n=s.size();\\n        p_pow[0]=1;\\n      for(int i=1;i<=1002;i++){\\n         p_pow[i]=(p_pow[i-1]*p)%mod;\\n      }\\n      s=\"#\"+s;\\n      for(int i=1;i<=n;i++){\\n          hash[i]=(hash[i-1]+(s[i]-\\'a\\'+1)*p_pow[i])%mod;\\n      }\\n        // hash is calculated\\n        \\n      int l=1,r=n;// initially we have to calculate between [1-n]\\n        int ans=0;\\n        for(int i=1;i<=n;i++){// now we simply traversing greedily \\n            if(l>r)break;     // and updating l and r\\n            if(i>=r+l-i){\\n                ans++;\\n                break;\\n            }\\n            cout<<l<<\" \"<<r<<endl;\\n            if(cal(l,i)==cal(r-i+l,r)){\\n                ans+=2;\\n                r=r-i+l-1;  // l,r will be updated\\n                l=i+1;\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};``\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n#define mod 1000000007\\n#define p 31\\n\\nclass Solution {\\npublic:\\n    ll hash[1002];\\n    ll p_pow[1003];\\n\\n    int cal(int l,int r){\\n        // to calculate hash between l to r\\n        ll var=(hash[r]-hash[l-1]+mod)%mod;\\n        var=var*(p_pow[1001-l])%mod;\\n        return var;\\n    }\\n    \\n    int longestDecomposition(string s) {\\n      int n=s.size();\\n        p_pow[0]=1;\\n      for(int i=1;i<=1002;i++){\\n         p_pow[i]=(p_pow[i-1]*p)%mod;\\n      }\\n      s=\"#\"+s;\\n      for(int i=1;i<=n;i++){\\n          hash[i]=(hash[i-1]+(s[i]-\\'a\\'+1)*p_pow[i])%mod;\\n      }\\n        // hash is calculated\\n        \\n      int l=1,r=n;// initially we have to calculate between [1-n]\\n        int ans=0;\\n        for(int i=1;i<=n;i++){// now we simply traversing greedily \\n            if(l>r)break;     // and updating l and r\\n            if(i>=r+l-i){\\n                ans++;\\n                break;\\n            }\\n            cout<<l<<\" \"<<r<<endl;\\n            if(cal(l,i)==cal(r-i+l,r)){\\n                ans+=2;\\n                r=r-i+l-1;  // l,r will be updated\\n                l=i+1;\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};``\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2211214,
                "title": "greedy-c",
                "content": "Start with an example: \"abcabc\"\\nWe want to start from either side and construct 2 strings simultaneously: ```left``` & ```right```\\n```left``` is the first ```lo``` characters of ```text```, \\n```right``` is the last ```hi``` characters of ```text``` \\n\\nIf ```left == reverse(right)```, we have found a palindromic decompostion, hence we add 2 to the ```count```, and reset ```left``` and ```right```\\nWe shrink our two pointers (```lo++``` and ```hi--```)\\n\\n\\nCorner case: if there\\'s no palindromic decomposition, ```count=1```\\nOr if only one character left at the end (```lo == hi```), increment ```count``` by 1\\n\\n\\nI guess the tricky part was to figure out the \"greedy-ness\" of the solution. Since we want to maximize the number of palindromic decompositions, as soon as we come across a palindromic decomposition, we create a split. \\n\\nWe can prove this using contradiction:\\nConsider the ```subtext_i``` and suffix ```subtext_k-i+1``` of ```text```. \\nAnd let\\'s say we have already found the \"max\" palindromic decomposition by breaking ```text``` into ```k``` substrings. \\n\\nBut if ```subtext_i[0:x] == (subtext_k-i+1[end-x:end] = reverse(subtext_k-i+1)[0:x]``` for any ```0 < x < len(subtext_i)```, then we can break down ```subtext_i``` & ```subtext_k-i+1``` into 2 pairs: ```subtext_i[0:x] & subtext_k-i+1[end-x:end]``` & ```subtext_i[x:end] & subtext_k-i+1[0:x]```.\\nHence resulting in ```k+2``` decompositions rather than ```k``` which is a contradiction.\\n\\n\\nHope that makes it clear. \\n\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        string left, right;\\n        int n = text.size();\\n        int lo = 0, hi = n-1;\\n        int count = 0;\\n        \\n        while (lo < hi) {\\n            left.push_back(text[lo++]);\\n            right.push_back(text[hi--]);\\n            reverse(right.begin(), right.end());\\n            if (left == right) {\\n                count += 2;\\n                left = \"\";\\n                right = \"\";\\n            }\\n            else {\\n                reverse(right.begin(), right.end());\\n            }\\n        }\\n        \\n        if (!left.empty() || !right.empty() || lo == hi) ++count;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```left```\n```right```\n```left```\n```lo```\n```text```\n```right```\n```hi```\n```text```\n```left == reverse(right)```\n```count```\n```left```\n```right```\n```lo++```\n```hi--```\n```count=1```\n```lo == hi```\n```count```\n```subtext_i```\n```subtext_k-i+1```\n```text```\n```text```\n```k```\n```subtext_i[0:x] == (subtext_k-i+1[end-x:end] = reverse(subtext_k-i+1)[0:x]```\n```0 < x < len(subtext_i)```\n```subtext_i```\n```subtext_k-i+1```\n```subtext_i[0:x] & subtext_k-i+1[end-x:end]```\n```subtext_i[x:end] & subtext_k-i+1[0:x]```\n```k+2```\n```k```\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        string left, right;\\n        int n = text.size();\\n        int lo = 0, hi = n-1;\\n        int count = 0;\\n        \\n        while (lo < hi) {\\n            left.push_back(text[lo++]);\\n            right.push_back(text[hi--]);\\n            reverse(right.begin(), right.end());\\n            if (left == right) {\\n                count += 2;\\n                left = \"\";\\n                right = \"\";\\n            }\\n            else {\\n                reverse(right.begin(), right.end());\\n            }\\n        }\\n        \\n        if (!left.empty() || !right.empty() || lo == hi) ++count;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146285,
                "title": "c-solution-based-on-recusion-and-memorization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> records;\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        this->records = vector<int>(n / 2 + 1, -1);\\n        return helper(text, n, 0);\\n    }\\n    /*\\n        initially, call helper(text, n, 0)\\n    */\\n    int helper(string text, int n, int p){\\n        \\n        int mirror_p = n - p - 1;\\n        if (p > mirror_p){\\n            return 0;\\n        }\\n        if (p == mirror_p){\\n            return 1;\\n        }\\n        if (this->records[p] != -1){\\n            return this->records[p];\\n        }\\n        // regular case:\\n        int sub, result = 1;\\n        for (int i = p; i < n / 2; i++){\\n            // [p, i] ------ [, mirror_p]\\n            int length = i - p + 1;\\n            string sub_left = text.substr(p, length);\\n            string sub_right = text.substr(n - i - 1, length);\\n            if (sub_left.compare(sub_right) == 0){\\n                sub = 2 + helper(text, n, i + 1);\\n                result = max(result, sub);\\n            }\\n        }\\n        this->records[p] = result;\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> records;\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        this->records = vector<int>(n / 2 + 1, -1);\\n        return helper(text, n, 0);\\n    }\\n    /*\\n        initially, call helper(text, n, 0)\\n    */\\n    int helper(string text, int n, int p){\\n        \\n        int mirror_p = n - p - 1;\\n        if (p > mirror_p){\\n            return 0;\\n        }\\n        if (p == mirror_p){\\n            return 1;\\n        }\\n        if (this->records[p] != -1){\\n            return this->records[p];\\n        }\\n        // regular case:\\n        int sub, result = 1;\\n        for (int i = p; i < n / 2; i++){\\n            // [p, i] ------ [, mirror_p]\\n            int length = i - p + 1;\\n            string sub_left = text.substr(p, length);\\n            string sub_right = text.substr(n - i - 1, length);\\n            if (sub_left.compare(sub_right) == 0){\\n                sub = 2 + helper(text, n, i + 1);\\n                result = max(result, sub);\\n            }\\n        }\\n        this->records[p] = result;\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141642,
                "title": "javascript-iterative-two-pointers-o-n-time-o-1-space-69-time-100-space",
                "content": "```\\nvar longestDecomposition = function(text) {\\n    let l = 0, r = text.length - 1, rEnd = text.length;\\n    let output = 0;\\n    while (l <= r) {\\n        if (text[l] === text[r]) {\\n            if (l === r) {\\n                output++;\\n                break;\\n            }\\n            let tempL = l, tempR = r;\\n            // Check if l matches r all the way until rEnd\\n            // r must reach the rEnd, otherwise there is no valid match\\n            while (tempR < rEnd) {\\n                if (text[tempL] === text[tempR]) {\\n                    tempL++, tempR++;\\n                    continue;\\n                } else break;\\n            }\\n            // If matched, set l to its new position at tempL and set rEnd to r, thereby shrinking the window\\n            if (tempR === rEnd) {\\n                l = tempL;\\n                rEnd = r;\\n                output += 2;\\n            }\\n        }\\n        r--;\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestDecomposition = function(text) {\\n    let l = 0, r = text.length - 1, rEnd = text.length;\\n    let output = 0;\\n    while (l <= r) {\\n        if (text[l] === text[r]) {\\n            if (l === r) {\\n                output++;\\n                break;\\n            }\\n            let tempL = l, tempR = r;\\n            // Check if l matches r all the way until rEnd\\n            // r must reach the rEnd, otherwise there is no valid match\\n            while (tempR < rEnd) {\\n                if (text[tempL] === text[tempR]) {\\n                    tempL++, tempR++;\\n                    continue;\\n                } else break;\\n            }\\n            // If matched, set l to its new position at tempL and set rEnd to r, thereby shrinking the window\\n            if (tempR === rEnd) {\\n                l = tempL;\\n                rEnd = r;\\n                output += 2;\\n            }\\n        }\\n        r--;\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113842,
                "title": "easy-c-solutions-faster-than-100-simple-rolling-hash",
                "content": "```\\nclass Solution {\\n    bool check(string &t, int front, int end, int mover){\\n        string a = t.substr(front-mover,mover);\\n        string b = t.substr(end+1,mover);\\n        return a==b;\\n    }\\n    bool rh(string &t, int &front,int &end){\\n        int first=0,second =0;\\n        int mover=0;\\n        while(front<=end){\\n            mover++;\\n            first+=int(t[front]);\\n            second+=int(t[end]);\\n            front++;\\n            end--;\\n            if(first==second && check(t,front,end,mover))\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int longestDecomposition(string t) {\\n        int count=0;\\n        int front=0,end=t.size()-1;\\n        while(front<=end){\\n            if(t[front]==t[end]){\\n                if(front==end) count++;\\n                else count+=2;\\n                front++,end--;\\n            }\\n            else{\\n                if(rh(t,front,end)==true) count+=2;\\n                else count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool check(string &t, int front, int end, int mover){\\n        string a = t.substr(front-mover,mover);\\n        string b = t.substr(end+1,mover);\\n        return a==b;\\n    }\\n    bool rh(string &t, int &front,int &end){\\n        int first=0,second =0;\\n        int mover=0;\\n        while(front<=end){\\n            mover++;\\n            first+=int(t[front]);\\n            second+=int(t[end]);\\n            front++;\\n            end--;\\n            if(first==second && check(t,front,end,mover))\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int longestDecomposition(string t) {\\n        int count=0;\\n        int front=0,end=t.size()-1;\\n        while(front<=end){\\n            if(t[front]==t[end]){\\n                if(front==end) count++;\\n                else count+=2;\\n                front++,end--;\\n            }\\n            else{\\n                if(rh(t,front,end)==true) count+=2;\\n                else count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106207,
                "title": "go-simple-two-pointer",
                "content": "```\\nfunc longestDecomposition(text string) int {\\n    if len(text) == 1 {\\n        return 1\\n    }\\n    \\n    k := 0\\n    str := text\\n    for len(str) > 0 {\\n        l := 1\\n        r := len(str)-1\\n        for l <= r {\\n            if str[:l] == str[r:] {\\n                k+=2\\n                str = str[l:r]\\n                break\\n            }\\n            \\n            l++\\n            r--\\n        }\\n        \\n        if l > r && len(str) > 0 {\\n            k++\\n            break\\n        }\\n    }\\n    return k\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers"
                ],
                "code": "```\\nfunc longestDecomposition(text string) int {\\n    if len(text) == 1 {\\n        return 1\\n    }\\n    \\n    k := 0\\n    str := text\\n    for len(str) > 0 {\\n        l := 1\\n        r := len(str)-1\\n        for l <= r {\\n            if str[:l] == str[r:] {\\n                k+=2\\n                str = str[l:r]\\n                break\\n            }\\n            \\n            l++\\n            r--\\n        }\\n        \\n        if l > r && len(str) > 0 {\\n            k++\\n            break\\n        }\\n    }\\n    return k\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2075437,
                "title": "easy-peasy-standard-hashing-rabin-karp-implementation",
                "content": "```\\n#define ll long\\nclass Solution {\\npublic:\\n    // 1-indexed string needed\\n    struct Hashs\\n    {\\n        vector<ll> hash;\\n        vector<ll> pows;\\n        ll P;\\n        ll mod;\\n\\n        Hashs() {}\\n\\n        Hashs(string &s,ll P,ll M) : P(P), mod(M)\\n        {\\n            ll n=s.size();\\n            pows.resize(n+1, 0);\\n            hash.resize(n+1, 0);\\n            pows[0] = 1;\\n            for(ll i=1;i<=n;i++)\\n            {\\n                pows[i]=(pows[i-1]*P)%mod;\\n                hash[i]=(hash[i-1]*P+(s[i-1]-\\'a\\'+1))%mod;\\n            }\\n        }\\n\\n        ll get_hash(ll l,ll r)  // [l,r]\\n        {\\n            return ( hash[r] - (hash[l-1]*pows[r-l+1])%mod + mod ) % mod;\\n        }\\n    };\\n\\n    int longestDecomposition(string s) \\n    {\\n        Hashs hs(s,31,1e9+7);\\n        int l=1,i=1,r=s.length(),j=s.length();\\n        int ans=0;\\n        while(i<=r && j>=l)\\n        {\\n            if(hs.get_hash(l,i)==hs.get_hash(j,r))\\n            {\\n                if(j==l) ans++;\\n                else ans+=2;\\n                l=i+1;\\n                r=j-1;\\n            }\\n            i++; j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long\\nclass Solution {\\npublic:\\n    // 1-indexed string needed\\n    struct Hashs\\n    {\\n        vector<ll> hash;\\n        vector<ll> pows;\\n        ll P;\\n        ll mod;\\n\\n        Hashs() {}\\n\\n        Hashs(string &s,ll P,ll M) : P(P), mod(M)\\n        {\\n            ll n=s.size();\\n            pows.resize(n+1, 0);\\n            hash.resize(n+1, 0);\\n            pows[0] = 1;\\n            for(ll i=1;i<=n;i++)\\n            {\\n                pows[i]=(pows[i-1]*P)%mod;\\n                hash[i]=(hash[i-1]*P+(s[i-1]-\\'a\\'+1))%mod;\\n            }\\n        }\\n\\n        ll get_hash(ll l,ll r)  // [l,r]\\n        {\\n            return ( hash[r] - (hash[l-1]*pows[r-l+1])%mod + mod ) % mod;\\n        }\\n    };\\n\\n    int longestDecomposition(string s) \\n    {\\n        Hashs hs(s,31,1e9+7);\\n        int l=1,i=1,r=s.length(),j=s.length();\\n        int ans=0;\\n        while(i<=r && j>=l)\\n        {\\n            if(hs.get_hash(l,i)==hs.get_hash(j,r))\\n            {\\n                if(j==l) ans++;\\n                else ans+=2;\\n                l=i+1;\\n                r=j-1;\\n            }\\n            i++; j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565401,
                "content": [
                    {
                        "username": "cuiaoxiang",
                        "content": "The original constraint is 1 <= text.length <= 200, it changed to 1 <= text.length <= 1000 in the middle the contest without announcement, which is improfessional and disappointing.\\n\\nMy first and second submission get RTE b/c there are test cases with text.length > 200."
                    },
                    {
                        "username": "shai_halud",
                        "content": "I built it using a suffix tree. The run-time sucked !\\n\\nBut, the memory was orders of magnitude better than everyone else !"
                    },
                    {
                        "username": "czjnbb",
                        "content": "This is medium."
                    },
                    {
                        "username": "julkar9",
                        "content": "Spoilers...\\n\\n\\n\\n\\n\\nNot a dynamic programming problem, greedy works just fine"
                    },
                    {
                        "username": "Nitish_KSingh1",
                        "content": "unbelievable answer @"
                    }
                ]
            },
            {
                "id": 1572915,
                "content": [
                    {
                        "username": "cuiaoxiang",
                        "content": "The original constraint is 1 <= text.length <= 200, it changed to 1 <= text.length <= 1000 in the middle the contest without announcement, which is improfessional and disappointing.\\n\\nMy first and second submission get RTE b/c there are test cases with text.length > 200."
                    },
                    {
                        "username": "shai_halud",
                        "content": "I built it using a suffix tree. The run-time sucked !\\n\\nBut, the memory was orders of magnitude better than everyone else !"
                    },
                    {
                        "username": "czjnbb",
                        "content": "This is medium."
                    },
                    {
                        "username": "julkar9",
                        "content": "Spoilers...\\n\\n\\n\\n\\n\\nNot a dynamic programming problem, greedy works just fine"
                    },
                    {
                        "username": "Nitish_KSingh1",
                        "content": "unbelievable answer @"
                    }
                ]
            },
            {
                "id": 1948154,
                "content": [
                    {
                        "username": "cuiaoxiang",
                        "content": "The original constraint is 1 <= text.length <= 200, it changed to 1 <= text.length <= 1000 in the middle the contest without announcement, which is improfessional and disappointing.\\n\\nMy first and second submission get RTE b/c there are test cases with text.length > 200."
                    },
                    {
                        "username": "shai_halud",
                        "content": "I built it using a suffix tree. The run-time sucked !\\n\\nBut, the memory was orders of magnitude better than everyone else !"
                    },
                    {
                        "username": "czjnbb",
                        "content": "This is medium."
                    },
                    {
                        "username": "julkar9",
                        "content": "Spoilers...\\n\\n\\n\\n\\n\\nNot a dynamic programming problem, greedy works just fine"
                    },
                    {
                        "username": "Nitish_KSingh1",
                        "content": "unbelievable answer @"
                    }
                ]
            },
            {
                "id": 1876288,
                "content": [
                    {
                        "username": "cuiaoxiang",
                        "content": "The original constraint is 1 <= text.length <= 200, it changed to 1 <= text.length <= 1000 in the middle the contest without announcement, which is improfessional and disappointing.\\n\\nMy first and second submission get RTE b/c there are test cases with text.length > 200."
                    },
                    {
                        "username": "shai_halud",
                        "content": "I built it using a suffix tree. The run-time sucked !\\n\\nBut, the memory was orders of magnitude better than everyone else !"
                    },
                    {
                        "username": "czjnbb",
                        "content": "This is medium."
                    },
                    {
                        "username": "julkar9",
                        "content": "Spoilers...\\n\\n\\n\\n\\n\\nNot a dynamic programming problem, greedy works just fine"
                    },
                    {
                        "username": "Nitish_KSingh1",
                        "content": "unbelievable answer @"
                    }
                ]
            },
            {
                "id": 1717212,
                "content": [
                    {
                        "username": "cuiaoxiang",
                        "content": "The original constraint is 1 <= text.length <= 200, it changed to 1 <= text.length <= 1000 in the middle the contest without announcement, which is improfessional and disappointing.\\n\\nMy first and second submission get RTE b/c there are test cases with text.length > 200."
                    },
                    {
                        "username": "shai_halud",
                        "content": "I built it using a suffix tree. The run-time sucked !\\n\\nBut, the memory was orders of magnitude better than everyone else !"
                    },
                    {
                        "username": "czjnbb",
                        "content": "This is medium."
                    },
                    {
                        "username": "julkar9",
                        "content": "Spoilers...\\n\\n\\n\\n\\n\\nNot a dynamic programming problem, greedy works just fine"
                    },
                    {
                        "username": "Nitish_KSingh1",
                        "content": "unbelievable answer @"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sort Array by Increasing Frequency",
        "question_content": "<p>Given an array of integers <code>nums</code>, sort the array in <strong>increasing</strong> order based on the frequency of the values. If multiple values have the same frequency, sort them in <strong>decreasing</strong> order.</p>\n\n<p>Return the <em>sorted array</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,2,2,2,3]\n<strong>Output:</strong> [3,1,1,2,2,2]\n<strong>Explanation:</strong> &#39;3&#39; has a frequency of 1, &#39;1&#39; has a frequency of 2, and &#39;2&#39; has a frequency of 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,1,3,2]\n<strong>Output:</strong> [1,3,3,2,2]\n<strong>Explanation:</strong> &#39;2&#39; and &#39;3&#39; both have a frequency of 2, so they are sorted in decreasing order.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,1,-6,4,5,-6,1,4,1]\n<strong>Output:</strong> [5,-1,4,4,-6,-6,1,1,1]</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1065249,
                "title": "python-3-solution-with-process-of-thinking-and-improvement",
                "content": "# Part 1\\n\\nSunday morning, Spotify, coffee, console... Task from the list of tasks to solve later.\\nLet\\'s go!\\n\\n```python\\n~ \\u276F python3                                                                                                                     at 10:38:03\\nPython 3.9.1 (default, Feb  3 2021, 07:38:02)\\n[Clang 12.0.0 (clang-1200.0.32.29)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums = [1,1,2,2,2,6,6,4,4,5,5,3]\\n```\\n\\nOk, so I need to count frequency of each of the unique values... First idea - use `Counter`. This returns `collection` type of object:\\n\\n```python\\n>>> d = Counter(nums)\\n>>> d\\nCounter({2: 3, 1: 2, 6: 2, 4: 2, 5: 2, 3: 1})\\n>>> type(d)\\n<class \\'collections.Counter\\'>\\n```\\n\\nNow I need to sort those values following the requirements in the description. \\'Counter\\' object has no attribute \\'sort\\', and \\'sorted\\' will only sort values, not frequencies. Googling options, found this [StackOverflow question](https://stackoverflow.com/q/20950650/4440387) with lots of useful answers. Reading... Let\\'s try easier object:\\n\\n```python\\n>>> r = Counter(nums).most_common()\\n```\\n\\nThis returns a list of tuples, where first number is value and second - its\\' frequency. Can I sort it in the same command? Jumping to the [official documentation](https://docs.python.org/3/library/collections.html#collections.Counter.most_common). Nope, not sortable in the command itself, moreover: \"*Elements with equal counts are ordered in the order first encountered*\". Ok, let\\'s sort it directly, first by values in the decreasing order, then by frequencies in the increasing.\\n\\n```\\n>>> r.sort(key = lambda x: x[0], reverse=True)\\n>>> r.sort(key = lambda x: x[1])\\n>>> r\\n[(3, 1), (6, 2), (5, 2), (4, 2), (1, 2), (2, 3)]\\n```\\n\\nLooks promising. Now I want to expand those tuples into a single list... Still browsing answers to the same [question](https://stackoverflow.com/q/20950650/4440387). Remembering that I can expand tuple and get every number from it by using this:\\n\\n```\\n>>> a, b = (3, 2)\\n>>> a\\n3\\n>>> b\\n2\\n```\\n\\nso then I can repeat every value by the number of its\\' frequency like so:\\n\\n```\\n>>> [3]*2\\n[3, 3]\\n```\\n\\nAha. Now I need an empty list to combine all those tuples into a single list:\\n\\n```\\nt = []\\nfor i in r:\\n    a, b = i\\n    t.extend([a] * b)\\n\\n>>> t\\n[3, 6, 6, 5, 5, 4, 4, 1, 1, 2, 2, 2]\\n```\\n\\nWoo-hoo! That\\'s what I need. So the complete solution now looks like this:\\n\\n```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        \\n        r = Counter(nums).most_common()\\n        r.sort(key = lambda x: x[0], reverse=True)\\n        r.sort(key = lambda x: x[1])\\n        \\n        t = []\\n        for i in r:\\n            a, b = i\\n            t.extend([a]*b)\\n            \\n        return t\\n```\\n\\n**Result**:\\nRuntime: 52 ms, faster than 63.30% of Python3 online submissions for Sort Array by Increasing Frequency.\\nMemory Usage: 14.2 MB, less than 58.20% of Python3 online submissions for Sort Array by Increasing Frequency.\\n\\nNot the best, but the task is solved.\\n\\n# Part 2\\n\\nNow it\\'s time for another *fun* - can I make it one-liner or optimize the solution in any other way?\\n\\nLooking at sorting lines... Can I sort it in one go? Yes! So, first we sort by values in the reverse order (`-x[0]`) and then by their frequencies (`x[1]`) in direct order. \\n```\\n>>> r.sort(key = lambda x: (x[1], -x[0]))\\n```\\n\\nBasically, it\\'s the same operation as the above but now coded in one line. Love Python :) Same logic applies to the tuple expansion part and it allows to save another line:\\n\\n```\\nt = []\\nfor i in r:\\n\\tt += ([i[0]] * i[1])\\n```\\n\\nAnd then I thought - if I can sort by value and its\\' frequency why do I need intermediate list? Can I sort the original list the same way?! Let\\'s see...\\n\\n```python\\n>>> nums\\n[1, 1, 2, 2, 2, 6, 6, 4, 4, 5, 5, 3]\\n>>> r = Counter(nums)\\n>>> r\\nCounter({2: 3, 1: 2, 6: 2, 4: 2, 5: 2, 3: 1})\\n>>> nums.sort(key=lambda x: (r[x], -x))\\n>>> nums\\n[3, 6, 6, 5, 5, 4, 4, 1, 1, 2, 2, 2]\\n```\\n\\nVoila! That feels sooo good. But `x.sort` makes it in-place and I need to return an object... So, I need to change it to `sorted` then:\\n\\n```\\n>>> result = sorted(nums, key=lambda x: (r[x], -x))\\n>>> result\\n[3, 6, 6, 5, 5, 4, 4, 1, 1, 2, 2, 2]\\n```\\n\\nPerfect. So the final variant would be:\\n```python\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        r = Counter(nums)\\n        return sorted(nums, key=lambda x: (r[x], -x))\\n```\\n\\nAnd it\\'s even faster!\\n\\nRuntime: 44 ms, faster than 95.07% of Python3 online submissions for Sort Array by Increasing Frequency.\\nMemory Usage: 14.3 MB, less than 58.20% of Python3 online submissions for Sort Array by Increasing Frequency.\\n\\n**NOTE**\\n* If you want to downvote this post, please, be brave and comment why. This will help me and others to learn from it.\\n* If you think that others can learn something from this post, then please, upvote it. Thanks.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n~ \\u276F python3                                                                                                                     at 10:38:03\\nPython 3.9.1 (default, Feb  3 2021, 07:38:02)\\n[Clang 12.0.0 (clang-1200.0.32.29)] on darwin\\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\\n>>> nums = [1,1,2,2,2,6,6,4,4,5,5,3]\\n```\n```python\\n>>> d = Counter(nums)\\n>>> d\\nCounter({2: 3, 1: 2, 6: 2, 4: 2, 5: 2, 3: 1})\\n>>> type(d)\\n<class \\'collections.Counter\\'>\\n```\n```python\\n>>> r = Counter(nums).most_common()\\n```\n```\\n>>> r.sort(key = lambda x: x[0], reverse=True)\\n>>> r.sort(key = lambda x: x[1])\\n>>> r\\n[(3, 1), (6, 2), (5, 2), (4, 2), (1, 2), (2, 3)]\\n```\n```\\n>>> a, b = (3, 2)\\n>>> a\\n3\\n>>> b\\n2\\n```\n```\\n>>> [3]*2\\n[3, 3]\\n```\n```\\nt = []\\nfor i in r:\\n    a, b = i\\n    t.extend([a] * b)\\n\\n>>> t\\n[3, 6, 6, 5, 5, 4, 4, 1, 1, 2, 2, 2]\\n```\n```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        \\n        r = Counter(nums).most_common()\\n        r.sort(key = lambda x: x[0], reverse=True)\\n        r.sort(key = lambda x: x[1])\\n        \\n        t = []\\n        for i in r:\\n            a, b = i\\n            t.extend([a]*b)\\n            \\n        return t\\n```\n```\\n>>> r.sort(key = lambda x: (x[1], -x[0]))\\n```\n```\\nt = []\\nfor i in r:\\n\\tt += ([i[0]] * i[1])\\n```\n```python\\n>>> nums\\n[1, 1, 2, 2, 2, 6, 6, 4, 4, 5, 5, 3]\\n>>> r = Counter(nums)\\n>>> r\\nCounter({2: 3, 1: 2, 6: 2, 4: 2, 5: 2, 3: 1})\\n>>> nums.sort(key=lambda x: (r[x], -x))\\n>>> nums\\n[3, 6, 6, 5, 5, 4, 4, 1, 1, 2, 2, 2]\\n```\n```\\n>>> result = sorted(nums, key=lambda x: (r[x], -x))\\n>>> result\\n[3, 6, 6, 5, 5, 4, 4, 1, 1, 2, 2, 2]\\n```\n```python\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        r = Counter(nums)\\n        return sorted(nums, key=lambda x: (r[x], -x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917993,
                "title": "java-simple-custom-sort-with-detailed-explanation",
                "content": "```\\npublic int[] frequencySort(int[] nums) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\t// count frequency of each number\\n\\tArrays.stream(nums).forEach(n -> map.put(n, map.getOrDefault(n, 0) + 1));\\n\\t// custom sort\\n\\treturn Arrays.stream(nums).boxed()\\n\\t\\t\\t.sorted((a,b) -> map.get(a) != map.get(b) ? map.get(a) - map.get(b) : b - a)\\n\\t\\t\\t.mapToInt(n -> n)\\n\\t\\t\\t.toArray();\\n}\\n```\\n\\ncustom sort explanation:\\n**.stream(nums)**\\niterates through the nums array\\n\\n**.boxed()**\\nconverts each int to Integer object, this is because .sorted() can only operate on objects\\n\\n**.sorted((a,b) -> map.get(a) != map.get(b) ? map.get(a) - map.get(b) : b - a)**\\nif frequency of two numbers are not the same, sort by ascending frequency. If frequencies are the same, sort by decending numeric value\\n\\n**.mapToInt(n -> n)**\\nconverts Integer to int\\n\\n**.toArray()**\\nreturns array",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\npublic int[] frequencySort(int[] nums) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\t// count frequency of each number\\n\\tArrays.stream(nums).forEach(n -> map.put(n, map.getOrDefault(n, 0) + 1));\\n\\t// custom sort\\n\\treturn Arrays.stream(nums).boxed()\\n\\t\\t\\t.sorted((a,b) -> map.get(a) != map.get(b) ? map.get(a) - map.get(b) : b - a)\\n\\t\\t\\t.mapToInt(n -> n)\\n\\t\\t\\t.toArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 917795,
                "title": "c-python-sort",
                "content": "## **Explanation**\\nSort by 2 keys.\\n@v_paliy note that:\\n\"count[x] sorts by frequency, and if two values are equal, it will sort the keys in decreasing order.\"\\n<br>\\n\\n## **Complexity**\\nTime `O(NlogN)`\\nSpace `O(N)`\\n<br>\\n\\n**C++**\\n```cpp\\n    vector<int> frequencySort(vector<int>& A) {\\n        unordered_map<int, int> count;\\n        for (int a: A)\\n            count[a]++;\\n        sort(begin(A), end(A), [&](int a, int b) {\\n            return count[a] == count[b] ? a > b : count[a] < count[b];\\n        });\\n        return A;\\n    }\\n```\\n**Python:**\\n```py\\n    def frequencySort(self, A):\\n        count = collections.Counter(A)\\n        return sorted(A, key=lambda x: (count[x], -x))\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n    vector<int> frequencySort(vector<int>& A) {\\n        unordered_map<int, int> count;\\n        for (int a: A)\\n            count[a]++;\\n        sort(begin(A), end(A), [&](int a, int b) {\\n            return count[a] == count[b] ? a > b : count[a] < count[b];\\n        });\\n        return A;\\n    }\\n```\n```py\\n    def frequencySort(self, A):\\n        count = collections.Counter(A)\\n        return sorted(A, key=lambda x: (count[x], -x))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 917835,
                "title": "java-sorted-the-occurrence-by-using-collections-sort",
                "content": "Looks like there is no others using this in Java at this moment yet, so I post my solution here for your reference.\\n```\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        List<Map.Entry<Integer, Integer>> list = new ArrayList(map.entrySet());\\n        Collections.sort(list, (a,b) -> a.getValue() == b.getValue() ? b.getKey() - a.getKey() : a.getValue() - b.getValue());\\n        int index = 0;\\n        int[] res = new int[nums.length];\\n        for (Map.Entry<Integer, Integer> entry : list) {\\n            \\n            int count = entry.getValue();\\n            int key = entry.getKey();\\n            \\n            for (int i=0; i<count; i++) {\\n                res[index++] = key;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        List<Map.Entry<Integer, Integer>> list = new ArrayList(map.entrySet());\\n        Collections.sort(list, (a,b) -> a.getValue() == b.getValue() ? b.getKey() - a.getKey() : a.getValue() - b.getValue());\\n        int index = 0;\\n        int[] res = new int[nums.length];\\n        for (Map.Entry<Integer, Integer> entry : list) {\\n            \\n            int count = entry.getValue();\\n            int key = entry.getKey();\\n            \\n            for (int i=0; i<count; i++) {\\n                res[index++] = key;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1146525,
                "title": "c-solution-using-maps",
                "content": "This is question is a very slight modifictaion of https://leetcode.com/problems/sort-characters-by-frequency/\\nThis is just a basic implementation :-)\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(pair<int,int>&a, pair<int,int>&b) {\\n        return  (a.second==b.second) ? a.first>b.first : a.second<b.second;\\n    }\\n    \\n    \\n    vector<int> frequencySort(vector<int>& nums) {\\n        if(nums.size()==1) \\n            return nums;\\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++) \\n        {\\n            mp[nums[i]]++;\\n        }\\n        vector<pair<int,int>> val_freq;\\n        for(auto m : mp) \\n        {\\n            val_freq.push_back(m);\\n        }\\n        sort(val_freq.begin(),val_freq.end(),cmp);\\n        vector<int> result;\\n        for(auto v : val_freq) {\\n            for(int i=0;i<v.second;i++) {\\n                result.push_back(v.first);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\nTry this too: https://leetcode.com/problems/sort-characters-by-frequency/\\nSolution: https://leetcode.com/problems/sort-characters-by-frequency/discuss/1146549/C%2B%2B-map-solution",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(pair<int,int>&a, pair<int,int>&b) {\\n        return  (a.second==b.second) ? a.first>b.first : a.second<b.second;\\n    }\\n    \\n    \\n    vector<int> frequencySort(vector<int>& nums) {\\n        if(nums.size()==1) \\n            return nums;\\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++) \\n        {\\n            mp[nums[i]]++;\\n        }\\n        vector<pair<int,int>> val_freq;\\n        for(auto m : mp) \\n        {\\n            val_freq.push_back(m);\\n        }\\n        sort(val_freq.begin(),val_freq.end(),cmp);\\n        vector<int> result;\\n        for(auto v : val_freq) {\\n            for(int i=0;i<v.second;i++) {\\n                result.push_back(v.first);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917839,
                "title": "1636-sort-array-by-increasing-frequency-javascript-solution",
                "content": "```\\n\\nvar frequencySort = function(nums) {\\n    const map = new Map();\\n    for (let n of nums) {\\n        map.set(n, (map.get(n) + 1) || 1);\\n    }\\n    return nums.sort((a, b) => map.get(a) - map.get(b) || b - a)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar frequencySort = function(nums) {\\n    const map = new Map();\\n    for (let n of nums) {\\n        map.set(n, (map.get(n) + 1) || 1);\\n    }\\n    return nums.sort((a, b) => map.get(a) - map.get(b) || b - a)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 917674,
                "title": "c-python3-sort-by-count",
                "content": "**C++**\\nSince the range of numbers is limited, and I am using array to collect count for the performance.\\n```cpp\\nvector<int> frequencySort(vector<int>& nums) {\\n    int cnt[201] = {};\\n    for (auto n : nums)\\n        ++cnt[n + 100];\\n    sort(begin(nums), end(nums), [&](int a, int b) {\\n       return cnt[a + 100] == cnt[b + 100] ? a > b : cnt[a + 100] < cnt[b + 100];\\n    });\\n    return nums;\\n}\\n```\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        cnt = collections.Counter(nums)\\n        return sorted(nums, key = lambda n: (cnt[n], -n))\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> frequencySort(vector<int>& nums) {\\n    int cnt[201] = {};\\n    for (auto n : nums)\\n        ++cnt[n + 100];\\n    sort(begin(nums), end(nums), [&](int a, int b) {\\n       return cnt[a + 100] == cnt[b + 100] ? a > b : cnt[a + 100] < cnt[b + 100];\\n    });\\n    return nums;\\n}\\n```\n```python\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        cnt = collections.Counter(nums)\\n        return sorted(nums, key = lambda n: (cnt[n], -n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033255,
                "title": "java-hashmap-collections-sort-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        List<Integer> list = new ArrayList<>(map.keySet());\\n        Collections.sort(list, (a, b) -> {\\n            return (map.get(a) == map.get(b))? b - a : map.get(a) - map.get(b);\\n        });\\n            \\n        int[] res = new int[nums.length];\\n        int i = 0;\\n        for (int num : list) {\\n            for (int j = 0; j < map.get(num); j++) {\\n                res[i++] = num;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        List<Integer> list = new ArrayList<>(map.keySet());\\n        Collections.sort(list, (a, b) -> {\\n            return (map.get(a) == map.get(b))? b - a : map.get(a) - map.get(b);\\n        });\\n            \\n        int[] res = new int[nums.length];\\n        int i = 0;\\n        for (int num : list) {\\n            for (int j = 0; j < map.get(num); j++) {\\n                res[i++] = num;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279845,
                "title": "c-100-faster-easy-to-understand-fast-and-efficient-code-using-comparator-function",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome***\\n```\\nclass Solution {\\npublic:\\n    bool static comp(pair<int,int> a,pair<int,int> b)\\n    {\\n        if(a.second==b.second)\\n        return a>b;   \\n        else\\n        return a.second<b.second;\\n    }\\n    vector<int> frequencySort(vector<int>& nums) {\\n         unordered_map<int,int> mp;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             mp[nums[i]]++;\\n         }\\n         vector<pair<int,int> > vec;\\n         for(auto pr:mp)\\n         {\\n             vec.push_back(pr);\\n         }\\n         sort(vec.begin(),vec.end(),comp);\\n         \\n vector<int> ans;\\n    for(int i=0;i<vec.size();i++)\\n    {\\n     while(vec[i].second>0)\\n     {\\n         ans.push_back(vec[i].first);\\n         vec[i].second--;\\n     }\\n    }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool static comp(pair<int,int> a,pair<int,int> b)\\n    {\\n        if(a.second==b.second)\\n        return a>b;   \\n        else\\n        return a.second<b.second;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 918883,
                "title": "easy-python-solution-with-explanation",
                "content": "\\tfrom collections import Counter\\n\\tclass Solution:\\n\\t\\tdef frequencySort(self, nums: List[int]) -> List[int]:\\n\\t\\t\\td = Counter(nums)\\n\\t\\t\\tdef check(x):\\n\\t\\t\\t\\treturn d[x]\\n\\n\\t\\t\\tnums.sort(reverse=True)\\n\\t\\t\\tnums.sort(key=check)\\n\\t\\t\\treturn nums\\n\\t\\t\\t\\nSo the basic idea is we use the Python\\'s inbuilt sort function with a custom method which returns the frequency of that element in the array to sort. So, first we create a frequency array using the Python\\'s Counter function *(This returns a dictionary, the same could have been manually using a blank dictionary but since we can utilise the capabilities of Python, that is what we do here.)* \\n\\nand we create a new function which returns the frequency of that element in our array *(The same could have been done easier with a lambda function as well, but this was my first instinct so I went with this)*\\n\\nNow, we reversed sorted the list first normally so that when sorting the second time using our custom sort, our answer comes out to be what we want, *(decreasing order for elements with the same frequency)* \\n\\nNext we use our custom sort function which generates a frequency wise + decreasing order for same frequency elements. Our inbuilt custom sort is stable, meaning it won\\'t change the relative order among elements. \\n\\nExample:\\n\\tIn Stable Frequency Wise Sort:\\n\\t`[1,3,3,2,4] --> [1,2,4,3,3] (relative order of 1,2,4 is maintained)`\\n\\tIn Unstable Frequency Wise Sort:\\n\\t`[1,3,3,2,4] --> [4,1,2,3,3] (relative order of 1,2,4 is not maintained)`\\n\\t\\n\\n**Note:** We can achieve this in one sort also by instead of returning a single key in our *check* function, we return a tuple of keys. \\n\\nSo that would make our *check* function something like: \\n\\n```\\ndef check(x):\\n\\treturn (d[x], -x)\\n```\\nThe purpose of *-x* is because in case of elements with the same frequency, we want them sorted in reverse sorted order.\\n\\nExample: `nums = [1,2,3,4]`\\n\\nSo, for this list, the element:\\n* 1 --> (1, -1)\\n* 2 --> (1, -2)\\n* 3 --> (1, -3)\\n* 4 --> (1, -4)\\n* element --> (frequency of element, -element)\\n\\nSo, first our list is sorted based on the first element, so since all are 1. Nothing happens. Next, we sort all the 1s based on the second element. So, -4 is the smallest so, that comes first, then -3 then -2 and lastly -1.\\n\\nSo the order becomes: (1, -4) , (1, -3), (1, -2), (1, -1) which means [4,3,2,1]. Which is what we wanted. \\n\\nPlease feel free to ask anything here, I will be happy to help/respond.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef check(x):\\n\\treturn (d[x], -x)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2622771,
                "title": "java-hashmap-sorting-explained",
                "content": "# Please Upvote :D\\n---\\n- We create a frequency map as well as an arraylist to store the values in nums  so that we can custom sort it.\\n\\n- We then sort the list in increasing order of map values (i.e. the frequency of nums elements).\\n\\n- If two or more values (frequencies) happens to be same, then we sort the elements itself in decreasing order. (Look at the example testcases for a better understanding).\\n\\n- We return the list by convertng it to an array.\\n``` java []\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for (int n : nums) {                            \\n            ans.add(n);\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n\\n        Collections.sort(ans, (a, b) ->                 \\n            (map.get(a) == map.get(b))? b - a : map.get(a) - map.get(b)\\n        );\\n\\n        return ans.stream().mapToInt(i -> i).toArray(); // O(n)\\n    }\\n}\\n\\n// TC: O(n) + O(n * logn) + O(n) => O(n * logn)\\n// SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for (int n : nums) {                            \\n            ans.add(n);\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n\\n        Collections.sort(ans, (a, b) ->                 \\n            (map.get(a) == map.get(b))? b - a : map.get(a) - map.get(b)\\n        );\\n\\n        return ans.stream().mapToInt(i -> i).toArray(); // O(n)\\n    }\\n}\\n\\n// TC: O(n) + O(n * logn) + O(n) => O(n * logn)\\n// SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917826,
                "title": "java-python-3-sort-frequency-followed-by-value",
                "content": "\\n```java\\n    public int[] frequencySort(int[] nums) {\\n        var freq = new HashMap<Integer, Integer>();\\n        for (int n : nums) {\\n            freq.put(n, 1 + freq.getOrDefault(n, 0));\\n        }\\n        var pq = new PriorityQueue<Integer>(Comparator.<Integer, Integer>comparing(i -> freq.get(i)).thenComparing(i -> -i));\\n        for (int n : nums) {\\n            pq.offer(n);\\n        }\\n        int[] ans = new int[nums.length];\\n        for (int i = 0; !pq.isEmpty(); ++i) {\\n            ans[i]= pq.poll();\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        freq = Counter(nums)\\n        return sorted(nums, key=lambda x : (freq[x], -x))\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int[] frequencySort(int[] nums) {\\n        var freq = new HashMap<Integer, Integer>();\\n        for (int n : nums) {\\n            freq.put(n, 1 + freq.getOrDefault(n, 0));\\n        }\\n        var pq = new PriorityQueue<Integer>(Comparator.<Integer, Integer>comparing(i -> freq.get(i)).thenComparing(i -> -i));\\n        for (int n : nums) {\\n            pq.offer(n);\\n        }\\n        int[] ans = new int[nums.length];\\n        for (int i = 0; !pq.isEmpty(); ++i) {\\n            ans[i]= pq.poll();\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        freq = Counter(nums)\\n        return sorted(nums, key=lambda x : (freq[x], -x))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1474205,
                "title": "c-sort-array-by-increasing-frequency",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        priority_queue<pair<int,int>> pq;\\n        for(auto it : mp){\\n            pq.push({-it.second,it.first});\\n        }\\n        vector<int> result;\\n        while(!pq.empty()){\\n            int x = pq.top().first;\\n            for(int i=0;i<abs(x);i++){\\n                result.push_back(pq.top().second);\\n            }\\n            pq.pop();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        priority_queue<pair<int,int>> pq;\\n        for(auto it : mp){\\n            pq.push({-it.second,it.first});\\n        }\\n        vector<int> result;\\n        while(!pq.empty()){\\n            int x = pq.top().first;\\n            for(int i=0;i<abs(x);i++){\\n                result.push_back(pq.top().second);\\n            }\\n            pq.pop();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963292,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        return sorted(sorted(nums,reverse=1),key=nums.count)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        return sorted(sorted(nums,reverse=1),key=nums.count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738672,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map <int,int> mp;\\n        priority_queue <pair <int,int>> q;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto &i:mp){\\n            q.push({-i.second,i.first});\\n        }\\n        nums.clear();\\n        while(!q.empty()){\\n            for(int i=0;i<-(q.top().first);i++){\\n                nums.push_back(q.top().second);\\n            }\\n            q.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map <int,int> mp;\\n        priority_queue <pair <int,int>> q;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto &i:mp){\\n            q.push({-i.second,i.first});\\n        }\\n        nums.clear();\\n        while(!q.empty()){\\n            for(int i=0;i<-(q.top().first);i++){\\n                nums.push_back(q.top().second);\\n            }\\n            q.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075339,
                "title": "simple-python-solution-with-explanation",
                "content": "We are going to use a dictionary to keep track of the frequeny that a number appears in the array. After we have done that we first sort the array in decreasing order and then sort it in increasing order by frequency. This works because sorts are guarenteed to be stable. Read this if you need help understanding why this works. https://docs.python.org/3/howto/sorting.html#sort-stability-and-complex-sorts \\n```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        d = {}\\n        for num in nums:\\n            if num not in d:\\n                d[num] = 1\\n            else:\\n                d[num] += 1\\n        return sorted(sorted(nums, reverse=True), key=lambda x: d[x])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        d = {}\\n        for num in nums:\\n            if num not in d:\\n                d[num] = 1\\n            else:\\n                d[num] += 1\\n        return sorted(sorted(nums, reverse=True), key=lambda x: d[x])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020506,
                "title": "easy-c-solution-heaps-maps",
                "content": "```\\nvector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        unordered_map<int, int>::iterator it;\\n        priority_queue<pair<int, int>> pq;\\n        \\n        vector<int> v;\\n        int n = nums.size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            m[nums[i]]++;\\n        }\\n        \\n        for (it = m.begin(); it != m.end(); it++) {\\n            pq.push({-1 * it->second, it->first});\\n        }\\n        \\n        while(pq.size() > 0) {\\n            int freq = -1 * pq.top().first;\\n            int elem = pq.top().second;\\n            \\n            for (int i = 0; i < freq; i++) v.push_back(elem);\\n            pq.pop();\\n        }\\n        \\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        unordered_map<int, int>::iterator it;\\n        priority_queue<pair<int, int>> pq;\\n        \\n        vector<int> v;\\n        int n = nums.size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            m[nums[i]]++;\\n        }\\n        \\n        for (it = m.begin(); it != m.end(); it++) {\\n            pq.push({-1 * it->second, it->first});\\n        }\\n        \\n        while(pq.size() > 0) {\\n            int freq = -1 * pq.top().first;\\n            int elem = pq.top().second;\\n            \\n            for (int i = 0; i < freq; i++) v.push_back(elem);\\n            pq.pop();\\n        }\\n        \\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1540596,
                "title": "python-one-line-solution",
                "content": "**Python :**\\n\\n```\\ndef frequencySort(self, nums: List[int]) -> List[int]:\\n\\treturn sorted(sorted(nums, reverse=True), key=nums.count)\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef frequencySort(self, nums: List[int]) -> List[int]:\\n\\treturn sorted(sorted(nums, reverse=True), key=nums.count)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1193718,
                "title": "easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        nums.sort(reverse=True)\\n\\n        res = sorted(nums, key=nums.count)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        nums.sort(reverse=True)\\n\\n        res = sorted(nums, key=nums.count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917717,
                "title": "c-sort-by-frequency",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Sort\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-38/problems/sort-array-by-increasing-frequency/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& A) {\\n        unordered_map<int, int> cnt;\\n        for (int n : A) cnt[n]++;\\n        sort(begin(A), end(A), [&](int a, int b) { return cnt[a] != cnt[b] ? cnt[a] < cnt[b] : a > b; });\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-38/problems/sort-array-by-increasing-frequency/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& A) {\\n        unordered_map<int, int> cnt;\\n        for (int n : A) cnt[n]++;\\n        sort(begin(A), end(A), [&](int a, int b) { return cnt[a] != cnt[b] ? cnt[a] < cnt[b] : a > b; });\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917705,
                "title": "java-easy-solution-sort-method",
                "content": "```\\npublic int[] frequencySort(int[] nums) {\\n        Map<Integer,Integer> map=new HashMap<>();//map to store count of each number\\n        List<Integer> list=new ArrayList<>();\\n        for(int num:nums){\\n            if(map.containsKey(num))\\n                map.put(num,map.get(num)+1);\\n            else{\\n                list.add(num);\\n                map.put(num,1);\\n            }\\n        }\\n        Collections.sort(list,(a,b)->map.get(a)==map.get(b)?(b-a):map.get(a)-map.get(b));//sorting based on count value first and then number value\\n        int arr[]=new int[nums.length];\\n        int k=0;\\n        for(int num:list){\\n            int cnt=map.get(num);\\n            while(cnt>0){\\n                arr[k++]=num;\\n                cnt--;\\n            }\\n        }\\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int[] frequencySort(int[] nums) {\\n        Map<Integer,Integer> map=new HashMap<>();//map to store count of each number\\n        List<Integer> list=new ArrayList<>();\\n        for(int num:nums){\\n            if(map.containsKey(num))\\n                map.put(num,map.get(num)+1);\\n            else{\\n                list.add(num);\\n                map.put(num,1);\\n            }\\n        }\\n        Collections.sort(list,(a,b)->map.get(a)==map.get(b)?(b-a):map.get(a)-map.get(b));//sorting based on count value first and then number value\\n        int arr[]=new int[nums.length];\\n        int k=0;\\n        for(int num:list){\\n            int cnt=map.get(num);\\n            while(cnt>0){\\n                arr[k++]=num;\\n                cnt--;\\n            }\\n        }\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1173453,
                "title": "java-easy-to-understand-using-comparator-class",
                "content": "```\\nclass Solution {\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    \\n    class Sorter implements Comparator<Integer>{\\n\\t//comparing the frequencies \\n        public int compare(Integer a, Integer b){\\n            if(map.get(a) == map.get(b)){\\n                return b-a;\\n            }else{\\n                return map.get(a) - map.get(b);\\n            }\\n        }\\n    }\\n    public int[] frequencySort(int[] nums) {\\n\\t//using arraylist beacuse of collection\\n\\t\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0; i<nums.length; i++){\\n            list.add(nums[i]);\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) +1);\\n        }\\n        //modifying the inbuilt collection.sort to use our sorter class\\n        Collections.sort(list , new Sorter());\\n        \\n        for(int i=0; i<list.size(); i++){\\n            nums[i] = list.get(i);\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    \\n    class Sorter implements Comparator<Integer>{\\n\\t//comparing the frequencies \\n        public int compare(Integer a, Integer b){\\n            if(map.get(a) == map.get(b)){\\n                return b-a;\\n            }else{\\n                return map.get(a) - map.get(b);\\n            }\\n        }\\n    }\\n    public int[] frequencySort(int[] nums) {\\n\\t//using arraylist beacuse of collection\\n\\t\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0; i<nums.length; i++){\\n            list.add(nums[i]);\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) +1);\\n        }\\n        //modifying the inbuilt collection.sort to use our sorter class\\n        Collections.sort(list , new Sorter());\\n        \\n        for(int i=0; i<list.size(); i++){\\n            nums[i] = list.get(i);\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917913,
                "title": "java-simple-solution-using-treemap-and-with-explanation-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        int[] bucket = new int[201]; //An array bucket to store frequency of numbers ranged between -100 to 100\\n        for(int num : nums) {\\n            bucket[num+100]++;\\n        }\\n        TreeMap<Integer, List<Integer>> map = new TreeMap(); //TreeMap to store numbers list by their frequency and in case of same frequency the list will be in descending order\\n        for(int i=200; i>=0; i--) {\\n            if(bucket[i] > 0) {\\n                if(!map.containsKey(bucket[i]))\\n                    map.put(bucket[i], new ArrayList<Integer>());\\n                List<Integer> temp = map.get(bucket[i]);\\n                temp.add(i-100);\\n                map.put(bucket[i], temp);\\n            }\\n        }\\n        int[] result = new int[nums.length];\\n        int index = 0;\\n        for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {  //Finally generate the result array\\n            int freq = entry.getKey();\\n            for(int num : entry.getValue())\\n                for(int i=0; i<freq; i++)\\n                    result[index++] = num;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        int[] bucket = new int[201]; //An array bucket to store frequency of numbers ranged between -100 to 100\\n        for(int num : nums) {\\n            bucket[num+100]++;\\n        }\\n        TreeMap<Integer, List<Integer>> map = new TreeMap(); //TreeMap to store numbers list by their frequency and in case of same frequency the list will be in descending order\\n        for(int i=200; i>=0; i--) {\\n            if(bucket[i] > 0) {\\n                if(!map.containsKey(bucket[i]))\\n                    map.put(bucket[i], new ArrayList<Integer>());\\n                List<Integer> temp = map.get(bucket[i]);\\n                temp.add(i-100);\\n                map.put(bucket[i], temp);\\n            }\\n        }\\n        int[] result = new int[nums.length];\\n        int index = 0;\\n        for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {  //Finally generate the result array\\n            int freq = entry.getKey();\\n            for(int num : entry.getValue())\\n                for(int i=0; i<freq; i++)\\n                    result[index++] = num;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257389,
                "title": "easiest-one-line-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        return sorted(sorted(nums,reverse=1),key=nums.count)\\n\\n    #please do upvote it will encourage me alot\\n\\t\\t\\n\\t\\t\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        return sorted(sorted(nums,reverse=1),key=nums.count)\\n\\n    #please do upvote it will encourage me alot\\n\\t\\t\\n\\t\\t\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586929,
                "title": "sort-array-by-increasing-frequency-c-96-faster-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirsly as we see frequecy the intuition is to use map. We store the freq in map and then think of how to use heap for sorting.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMap stores te frequency of each element so we iterate through the map and push into the min heap the elements one by one based on frequency but there is a catch where two elements have same frequency they need to be arranged in descending order so we need a special comparator to perform this operation on heap.\\nSo we make use of \\nbool operator()(pair<int,int> a,pair<int,int> b)\\n{\\n    if(a.first==b.first)\\n    {\\n        a.second < b.second;\\n    }\\n    return a.first > b.first;\\n}\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass MyComp\\n{\\n    public:\\n        bool operator()(pair<int,int> a,pair<int,int> b)\\n        {\\n            if(a.first==b.first)\\n            {\\n                return a.second < b.second;\\n            }\\n            return a.first > b.first;\\n\\n        }\\n};\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        map<int,int> m;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,MyComp>pq;\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n                pq.push({it->second,it->first});\\n        }\\n        while(!pq.empty())\\n        {\\n            int freq=pq.top().first;\\n            int el=pq.top().second;\\n            pq.pop();\\n            for(int i=0;i<freq;i++)\\n            {\\n                ans.push_back(el);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MyComp\\n{\\n    public:\\n        bool operator()(pair<int,int> a,pair<int,int> b)\\n        {\\n            if(a.first==b.first)\\n            {\\n                return a.second < b.second;\\n            }\\n            return a.first > b.first;\\n\\n        }\\n};\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        map<int,int> m;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,MyComp>pq;\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n                pq.push({it->second,it->first});\\n        }\\n        while(!pq.empty())\\n        {\\n            int freq=pq.top().first;\\n            int el=pq.top().second;\\n            pq.pop();\\n            for(int i=0;i<freq;i++)\\n            {\\n                ans.push_back(el);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139655,
                "title": "java-simple-hashmap-priorityqueue-solution",
                "content": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        //init hashmap and count occurences of elements in nums\\n        //init minHeap based on occurence, if two elements have same freq sort in decreasing order\\n        //add elements in map into minHeap as array, containing element and occurence\\n\\t\\t//init index to traverse array\\n        //loop while minHeap is not empty\\n        //grab min element \\n        //keep inserting element into nums while in bounds and occurence > 0\\n        //return nums\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i : nums)\\n        {\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b) -> a[1] == b[1] ? b[0] - a[0] : a[1] - b[1]);\\n        \\n        for(Map.Entry<Integer, Integer> entry : map.entrySet())\\n        {\\n            minHeap.add(new int[] {entry.getKey(), entry.getValue()});\\n        }\\n        \\n        int index = 0;\\n        \\n        while(!minHeap.isEmpty())\\n        {\\n            int[] min = minHeap.poll();\\n            \\n            while(index < nums.length && min[1] > 0)\\n            {\\n                nums[index++] = min[0];\\n                min[1]--;\\n            }\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        //init hashmap and count occurences of elements in nums\\n        //init minHeap based on occurence, if two elements have same freq sort in decreasing order\\n        //add elements in map into minHeap as array, containing element and occurence\\n\\t\\t//init index to traverse array\\n        //loop while minHeap is not empty\\n        //grab min element \\n        //keep inserting element into nums while in bounds and occurence > 0\\n        //return nums\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i : nums)\\n        {\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b) -> a[1] == b[1] ? b[0] - a[0] : a[1] - b[1]);\\n        \\n        for(Map.Entry<Integer, Integer> entry : map.entrySet())\\n        {\\n            minHeap.add(new int[] {entry.getKey(), entry.getValue()});\\n        }\\n        \\n        int index = 0;\\n        \\n        while(!minHeap.isEmpty())\\n        {\\n            int[] min = minHeap.poll();\\n            \\n            while(index < nums.length && min[1] > 0)\\n            {\\n                nums[index++] = min[0];\\n                min[1]--;\\n            }\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948665,
                "title": "javascript-sort",
                "content": "```\\nvar frequencySort = function(nums) {\\n  const map = new Map()\\n  for(let n of nums){\\n    map.set(n, (map.get(n) || 0)+1)\\n  }\\n  return nums.sort((a,b)=>{\\n    if(map.get(a) === map.get(b)){\\n      return b-a\\n    }else{\\n      return map.get(a) - map.get(b)\\n    }\\n  })\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar frequencySort = function(nums) {\\n  const map = new Map()\\n  for(let n of nums){\\n    map.set(n, (map.get(n) || 0)+1)\\n  }\\n  return nums.sort((a,b)=>{\\n    if(map.get(a) === map.get(b)){\\n      return b-a\\n    }else{\\n      return map.get(a) - map.get(b)\\n    }\\n  })\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1579142,
                "title": "bucket-sort",
                "content": "I know the answer can be in several lines...but during a real interview, what is the interverer expected to see? More from algorithm level, to evaluate your algorithm skills (instead of checking how many default libraries/built-in you can remember)?\\n\\nHere is a pure bucket sort...\\n\\n```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        if (nums.length == 1) {\\n            return nums;\\n        }\\n        \\n        int[] result = new int[nums.length];\\n        Map<Integer, Integer> numCountMap = new HashMap<>();\\n        int maxCount = 0;\\n        \\n        for (int num : nums) {\\n            int count = numCountMap.getOrDefault(num, 0);\\n            count++;\\n            maxCount = Math.max(maxCount, count);\\n            numCountMap.put(num, count);\\n        }\\n        \\n        List<Integer>[] bucket = new List[maxCount + 1];\\n        \\n        for (Map.Entry<Integer, Integer> entry : numCountMap.entrySet()) {\\n            int num = entry.getKey();\\n            int count = entry.getValue();\\n            \\n            List<Integer> tempList;\\n            \\n            if (bucket[count] == null) {\\n                tempList = new ArrayList<>();\\n            } else {\\n                tempList = bucket[count];\\n            }\\n            \\n            tempList.add(num);\\n            bucket[count] = tempList;\\n        }\\n        \\n        int p = 0;\\n        for (int i = 1; i <= bucket.length - 1; i++) {\\n            List<Integer> list = bucket[i];\\n            if (list != null) {\\n                Collections.sort(list, Collections.reverseOrder());\\n                for (Integer num : list) {\\n                    int count = i;\\n                    while(count > 0) {\\n                        result[p] = num;\\n                        p++;\\n                        count--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        if (nums.length == 1) {\\n            return nums;\\n        }\\n        \\n        int[] result = new int[nums.length];\\n        Map<Integer, Integer> numCountMap = new HashMap<>();\\n        int maxCount = 0;\\n        \\n        for (int num : nums) {\\n            int count = numCountMap.getOrDefault(num, 0);\\n            count++;\\n            maxCount = Math.max(maxCount, count);\\n            numCountMap.put(num, count);\\n        }\\n        \\n        List<Integer>[] bucket = new List[maxCount + 1];\\n        \\n        for (Map.Entry<Integer, Integer> entry : numCountMap.entrySet()) {\\n            int num = entry.getKey();\\n            int count = entry.getValue();\\n            \\n            List<Integer> tempList;\\n            \\n            if (bucket[count] == null) {\\n                tempList = new ArrayList<>();\\n            } else {\\n                tempList = bucket[count];\\n            }\\n            \\n            tempList.add(num);\\n            bucket[count] = tempList;\\n        }\\n        \\n        int p = 0;\\n        for (int i = 1; i <= bucket.length - 1; i++) {\\n            List<Integer> list = bucket[i];\\n            if (list != null) {\\n                Collections.sort(list, Collections.reverseOrder());\\n                for (Integer num : list) {\\n                    int count = i;\\n                    while(count > 0) {\\n                        result[p] = num;\\n                        p++;\\n                        count--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380432,
                "title": "java-easy-approach-with-explanation-hashmap-heap-min-max",
                "content": "```\\nclass Solution \\n{//T-> O( N log N ) S->O( N )\\n    public int[] frequencySort(int[] nums)\\n    {\\n        Map<Integer, Integer> map= new HashMap<>();//data -- frequency\\n        \\n        for(int data: nums)//calculating and putting the frequency of data \\n            map.put(data, map.getOrDefault(data, 0)+1);\\n        \\n        PriorityQueue<Map.Entry<Integer, Integer>> heap= new PriorityQueue<>((a, b)->{\\n            return (a.getValue() == b.getValue())? b.getKey() - a.getKey() : a.getValue() - b.getValue();//maxHeap(data) (when frequency are same)//false impression tro priority Queue || minHeap(frequency)\\n        });\\n        \\n        for(Map.Entry<Integer, Integer> entry: map.entrySet())//putting all the Entry into the heap \\n            heap.offer(entry);\\n        \\n        int index= 0;//index is for insering into the same array\\n        \\n        while(heap.size() != 0)//doing the operation till the heapis Empty\\n        {\\n           Map.Entry<Integer, Integer> temp= heap.poll();//getting the min frequency Entry\\n \\n           int val= temp.getKey();//extracting the data from the Entry\\n           int freq= temp.getValue();//extracting the frequency of the data from the Entry\\n           \\n           for(int i= 0; i< freq; i++)//overwridding the values into the Array, to reduce the space \\n               nums[index+i]= val;//adding the value \\n           index+= freq;//index position maintaining \\n        }\\n        \\n        return nums;//returning the resultant array \\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution \\n{//T-> O( N log N ) S->O( N )\\n    public int[] frequencySort(int[] nums)\\n    {\\n        Map<Integer, Integer> map= new HashMap<>();//data -- frequency\\n        \\n        for(int data: nums)//calculating and putting the frequency of data \\n            map.put(data, map.getOrDefault(data, 0)+1);\\n        \\n        PriorityQueue<Map.Entry<Integer, Integer>> heap= new PriorityQueue<>((a, b)->{\\n            return (a.getValue() == b.getValue())? b.getKey() - a.getKey() : a.getValue() - b.getValue();//maxHeap(data) (when frequency are same)//false impression tro priority Queue || minHeap(frequency)\\n        });\\n        \\n        for(Map.Entry<Integer, Integer> entry: map.entrySet())//putting all the Entry into the heap \\n            heap.offer(entry);\\n        \\n        int index= 0;//index is for insering into the same array\\n        \\n        while(heap.size() != 0)//doing the operation till the heapis Empty\\n        {\\n           Map.Entry<Integer, Integer> temp= heap.poll();//getting the min frequency Entry\\n \\n           int val= temp.getKey();//extracting the data from the Entry\\n           int freq= temp.getValue();//extracting the frequency of the data from the Entry\\n           \\n           for(int i= 0; i< freq; i++)//overwridding the values into the Array, to reduce the space \\n               nums[index+i]= val;//adding the value \\n           index+= freq;//index position maintaining \\n        }\\n        \\n        return nums;//returning the resultant array \\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961984,
                "title": "c-simple-and-short-with-custom-comparator-lambda-function",
                "content": "```\\nvector<int> frequencySort(vector<int>& nums) {\\n\\tmap<int, int> freq;\\n\\tfor (int n : nums)\\n\\t\\tfreq[n]++;\\n\\tsort(nums.begin(), nums.end(),\\n\\t\\t\\t[&freq](const int& a, const int& b) {\\n\\t\\t\\t\\treturn (freq[a] == freq[b]) ? a > b : freq[a] < freq[b];\\n\\t});\\n\\treturn nums;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> frequencySort(vector<int>& nums) {\\n\\tmap<int, int> freq;\\n\\tfor (int n : nums)\\n\\t\\tfreq[n]++;\\n\\tsort(nums.begin(), nums.end(),\\n\\t\\t\\t[&freq](const int& a, const int& b) {\\n\\t\\t\\t\\treturn (freq[a] == freq[b]) ? a > b : freq[a] < freq[b];\\n\\t});\\n\\treturn nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257579,
                "title": "one-line-code-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        return sorted(sorted(nums,reverse=True),key=nums.count)\\n#please upvote me it would encourage me alot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        return sorted(sorted(nums,reverse=True),key=nums.count)\\n#please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873438,
                "title": "easy-c-solution-using-unordered-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i : nums){\\n            mp[i]++;\\n        }\\n        sort(nums.begin(), nums.end(), [&](int n1, int n2){\\n            if(mp[n1] == mp[n2]){\\n                return n1 > n2;\\n            }\\n            return mp[n1] < mp[n2];\\n        });\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i : nums){\\n            mp[i]++;\\n        }\\n        sort(nums.begin(), nums.end(), [&](int n1, int n2){\\n            if(mp[n1] == mp[n2]){\\n                return n1 > n2;\\n            }\\n            return mp[n1] < mp[n2];\\n        });\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873885,
                "title": "c-solution-using-priority-queue-beginner-friendly",
                "content": "``` I have used unordered map instead of ordered map because insertion of an element in unordered map is O(1) time complexity.```\\n```\\n vector<int> frequencySort(vector<int>& a) {\\n        int n=a.size();\\n        vector<int>v;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n            mp[a[i]]++;\\n        priority_queue<pair<int,int>>pq;\\n        for(auto it:mp)\\n            pq.push({-(it.second),(it.first)});    // (-) sign is used to make it a min heap.\\n         while(!pq.empty()) {  \\n             int num1= -pq.top().first; \\n\\t\\t\\t int num2 = pq.top().second; \\n             while(num1--)\\n\\t\\t\\t  v.push_back(num2);\\n\\n\\t\\t\\tpq.pop();\\n\\t\\t}\\n        return v;\\n    }\\n```\\n```If you like my approach then please upvote me.```",
                "solutionTags": [],
                "code": "``` I have used unordered map instead of ordered map because insertion of an element in unordered map is O(1) time complexity.```\n```\\n vector<int> frequencySort(vector<int>& a) {\\n        int n=a.size();\\n        vector<int>v;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n            mp[a[i]]++;\\n        priority_queue<pair<int,int>>pq;\\n        for(auto it:mp)\\n            pq.push({-(it.second),(it.first)});    // (-) sign is used to make it a min heap.\\n         while(!pq.empty()) {  \\n             int num1= -pq.top().first; \\n\\t\\t\\t int num2 = pq.top().second; \\n             while(num1--)\\n\\t\\t\\t  v.push_back(num2);\\n\\n\\t\\t\\tpq.pop();\\n\\t\\t}\\n        return v;\\n    }\\n```\n```If you like my approach then please upvote me.```",
                "codeTag": "Unknown"
            },
            {
                "id": 1286282,
                "title": "faster-than-95-using-lambda-function-and-sort",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        \\n        di=Counter(nums)\\n        li=list(di.items())\\n        \\n        #keep a list of frequency elements and their values[val,freq]\\n        \\n        li.sort(key=lambda x:(x[1],-x[0]))\\n        \\n        #LARGEST POSITIVE NUMBER IS SMALLEST NEGATIVE NUMBER\\n        res=[]\\n        for val,freq in (li):\\n            res+=[val]*freq\\n        return res\\n\\t\\t\\n```\\n\\tAfter making list of frequency and values, we sort the list using custom lambda function.\\nIn case the frequency is same, the value is sorted in reverse(as we consider it a negative value).",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        \\n        di=Counter(nums)\\n        li=list(di.items())\\n        \\n        #keep a list of frequency elements and their values[val,freq]\\n        \\n        li.sort(key=lambda x:(x[1],-x[0]))\\n        \\n        #LARGEST POSITIVE NUMBER IS SMALLEST NEGATIVE NUMBER\\n        res=[]\\n        for val,freq in (li):\\n            res+=[val]*freq\\n        return res\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882102,
                "title": "aditya-verma-approach-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(auto it : nums) m[it]++;\\n\\n        priority_queue<pair<int,int>> h; \\n        for(auto &i:m) h.push({-i.second,i.first});\\n        \\n        vector<int> v;\\n        while(!h.empty())\\n        {\\n            for(int i = 0; i<-(h.top().first); i++)\\n            {\\n                v.push_back(h.top().second);\\n            }\\n            h.pop();\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(auto it : nums) m[it]++;\\n\\n        priority_queue<pair<int,int>> h; \\n        for(auto &i:m) h.push({-i.second,i.first});\\n        \\n        vector<int> v;\\n        while(!h.empty())\\n        {\\n            for(int i = 0; i<-(h.top().first); i++)\\n            {\\n                v.push_back(h.top().second);\\n            }\\n            h.pop();\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915329,
                "title": "java-most-possible-solution",
                "content": "\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        int[] cnt = new int[201];\\n        List<Integer> t = new ArrayList<>();\\n        for (int v : nums) {\\n            v += 100;\\n            ++cnt[v];\\n            t.add(v);\\n        }\\n        t.sort((a, b) -> cnt[a] == cnt[b] ? b - a : cnt[a] - cnt[b]);\\n        int[] ans = new int[nums.length];\\n        int i = 0;\\n        for (int v : t) {\\n            ans[i++] = v - 100;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        int[] cnt = new int[201];\\n        List<Integer> t = new ArrayList<>();\\n        for (int v : nums) {\\n            v += 100;\\n            ++cnt[v];\\n            t.add(v);\\n        }\\n        t.sort((a, b) -> cnt[a] == cnt[b] ? b - a : cnt[a] - cnt[b]);\\n        int[] ans = new int[nums.length];\\n        int i = 0;\\n        for (int v : t) {\\n            ans[i++] = v - 100;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380310,
                "title": "c-using-map-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n  static bool comp(pair<int,int>p,pair<int,int>q)\\n      //first column stores frequency i.e duplicates and second column stores value\\n  {//if the duplicates are equal then we will return by greater value first...\\n  if(p.first==q.first)\\n  {\\n  return p.second>q.second;\\n  }\\n      ///else we will return as per frequency.\\n  return p.first<q.first;\\n  }\\n        vector<int> frequencySort(vector<int>& nums) {\\n            \\n        map<int,int>sk; \\n        for(int i=0;i<nums.size();i++){ ///inserting value and its duplicate in map...\\n            sk[nums[i]]++;   \\n        }\\n        vector<int>ans;\\n        vector<pair<int,int>>temp; //creating pair so that we can sort\\n        for(auto i:sk){\\n            temp.push_back({i.second,i.first});  ///now adding duplicate in first and value in second column...\\n        }\\n        sort(temp.begin(),temp.end(),comp); ///sorting by function...\\n        for(auto z:temp){\\n            int a=z.first;\\n            int b=z.second;\\n            for(int j=0;j<a;j++){\\n                ans.push_back(b);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  static bool comp(pair<int,int>p,pair<int,int>q)\\n      //first column stores frequency i.e duplicates and second column stores value\\n  {//if the duplicates are equal then we will return by greater value first...\\n  if(p.first==q.first)\\n  {\\n  return p.second>q.second;\\n  }\\n      ///else we will return as per frequency.\\n  return p.first<q.first;\\n  }\\n        vector<int> frequencySort(vector<int>& nums) {\\n            \\n        map<int,int>sk; \\n        for(int i=0;i<nums.size();i++){ ///inserting value and its duplicate in map...\\n            sk[nums[i]]++;   \\n        }\\n        vector<int>ans;\\n        vector<pair<int,int>>temp; //creating pair so that we can sort\\n        for(auto i:sk){\\n            temp.push_back({i.second,i.first});  ///now adding duplicate in first and value in second column...\\n        }\\n        sort(temp.begin(),temp.end(),comp); ///sorting by function...\\n        for(auto z:temp){\\n            int a=z.first;\\n            int b=z.second;\\n            for(int j=0;j<a;j++){\\n                ans.push_back(b);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689934,
                "title": "c-map-and-priority-queue",
                "content": "Approach: Use an unordered map for storing frequency of numbers present. Then, a priority queue with custom comparator class is used to store the numbers accordingly. Here is the code implementation.\\n\\n```\\nclass compare{\\n    public:\\n    bool operator()(pair<int,int> n1, pair<int,int> n2){\\n        if(n1.second==n2.second){\\n            return n1.first<n2.first;\\n        }\\n        return n1.second>n2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        vector<int> res;\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, compare> pq;\\n        for(auto x: m){\\n            pq.push({x.first, x.second});\\n        }\\n        \\n        while(!pq.empty()){\\n            while(m[pq.top().first]>0){\\n                res.push_back(pq.top().first);\\n                m[pq.top().first]--;\\n            }\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Please upvote!**",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass compare{\\n    public:\\n    bool operator()(pair<int,int> n1, pair<int,int> n2){\\n        if(n1.second==n2.second){\\n            return n1.first<n2.first;\\n        }\\n        return n1.second>n2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        vector<int> res;\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, compare> pq;\\n        for(auto x: m){\\n            pq.push({x.first, x.second});\\n        }\\n        \\n        while(!pq.empty()){\\n            while(m[pq.top().first]>0){\\n                res.push_back(pq.top().first);\\n                m[pq.top().first]--;\\n            }\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630842,
                "title": "c-solution-using-qsort",
                "content": "```\\n// Let it be global to be used in cmp(). \\nint count[201];\\n\\nint cmp(const void *a, const void *b){\\n    if(count[*(int*)a + 100] != count[*(int*)b + 100])\\n        return count[*(int*)a + 100] > count[*(int*)b + 100];\\n    else\\n        return *(int*)a < *(int*)b;\\n}\\n\\nint* frequencySort(int* nums, int numsSize, int* returnSize){\\n    int i, l = numsSize;\\n    memset(count, 0, sizeof(count));\\n    \\n    for(i = 0; i < l; i++){\\n        count[nums[i] + 100]++;\\n    }\\n    \\n    qsort(nums, l, sizeof(int), cmp);\\n    *returnSize = l;\\n    \\n    return nums;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Let it be global to be used in cmp(). \\nint count[201];\\n\\nint cmp(const void *a, const void *b){\\n    if(count[*(int*)a + 100] != count[*(int*)b + 100])\\n        return count[*(int*)a + 100] > count[*(int*)b + 100];\\n    else\\n        return *(int*)a < *(int*)b;\\n}\\n\\nint* frequencySort(int* nums, int numsSize, int* returnSize){\\n    int i, l = numsSize;\\n    memset(count, 0, sizeof(count));\\n    \\n    for(i = 0; i < l; i++){\\n        count[nums[i] + 100]++;\\n    }\\n    \\n    qsort(nums, l, sizeof(int), cmp);\\n    *returnSize = l;\\n    \\n    return nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352276,
                "title": "c-priority-queue-map-comments-for-easy-understanding",
                "content": "**Before you see this solution, I would highly suggest you to try this below problem :**\\n\\uD83D\\uDC49  ***https://leetcode.com/problems/top-k-frequent-elements/***\\n\\n**If you solved the above problem, that\\'s great. You can try again this problem and if still can\\'t, then continue seeing this solution.** \\n**In case you couldn\\'t solve above link problem, see the below link solution and then see this solution, everything will become crystal-clear to you.**\\n\\uD83D\\uDC49 ***https://leetcode.com/problems/top-k-frequent-elements/discuss/1352094/c-8ms-9932-faster-priority-queue-comments-for-easy-understanding***\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/f6bf1b3b-bc3c-4f0f-9c59-a2690006eaa5_1626855499.9966238.png)\\n\\n```\\nclass Solution {\\npublic:\\n    class compare_fun\\n    {    \\n        public:\\n        // Since as you can see we have to sort decreasing order if frequency of two elements\\n        // is same, so we need *Custom Comparator Function* which is this \\uD83D\\uDC47\\n        bool operator()(pair<int, int> p1, pair<int, int> p2) \\n        {    \\n            if(p1.first==p2.first)\\n                return p1.second < p2.second;\\n            return p1.first > p2.first;\\n        }\\n    };\\n    \\n    vector<int> frequencySort(vector<int>& nums) {\\n        \\n        //Creating map of array elements with their count\\n        unordered_map<int, int> mp;\\n        for(auto x: nums)\\n            mp[x]++;\\n        \\n        // *Min Heap*\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, compare_fun> minH;\\n        vector<int> v;\\n        \\n        //Traversing through map and pushing it in heap\\n        for(auto x: mp){\\n            minH.push(make_pair(x.second, x.first)); // Making pair of count and the number\\n        }\\n        \\n        //Pushing the heap elements in vector multiplied with it\\'s frequency\\n        while(minH.size() > 0){\\n            for(int i=0; i<minH.top().first; i++)\\n                v.push_back(minH.top().second);\\n            minH.pop();\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class compare_fun\\n    {    \\n        public:\\n        // Since as you can see we have to sort decreasing order if frequency of two elements\\n        // is same, so we need *Custom Comparator Function* which is this \\uD83D\\uDC47\\n        bool operator()(pair<int, int> p1, pair<int, int> p2) \\n        {    \\n            if(p1.first==p2.first)\\n                return p1.second < p2.second;\\n            return p1.first > p2.first;\\n        }\\n    };\\n    \\n    vector<int> frequencySort(vector<int>& nums) {\\n        \\n        //Creating map of array elements with their count\\n        unordered_map<int, int> mp;\\n        for(auto x: nums)\\n            mp[x]++;\\n        \\n        // *Min Heap*\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, compare_fun> minH;\\n        vector<int> v;\\n        \\n        //Traversing through map and pushing it in heap\\n        for(auto x: mp){\\n            minH.push(make_pair(x.second, x.first)); // Making pair of count and the number\\n        }\\n        \\n        //Pushing the heap elements in vector multiplied with it\\'s frequency\\n        while(minH.size() > 0){\\n            for(int i=0; i<minH.top().first; i++)\\n                v.push_back(minH.top().second);\\n            minH.pop();\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144092,
                "title": "java-solution-with-minheap-and-hashmap",
                "content": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int sortedArr[] = new int[nums.length];\\n        for(int num: nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        Queue<Integer> minHeap = new PriorityQueue<Integer>((a,b)-> (map.get(a) == map.get(b)) ? b-a: map.get(a)-map.get(b) );\\n        for(int num: nums) {\\n            minHeap.add(num);\\n        }\\n        int i=0;\\n        while(!minHeap.isEmpty()) {\\n            sortedArr[i++] = minHeap.remove();\\n        }\\n        \\n        return sortedArr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int sortedArr[] = new int[nums.length];\\n        for(int num: nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        Queue<Integer> minHeap = new PriorityQueue<Integer>((a,b)-> (map.get(a) == map.get(b)) ? b-a: map.get(a)-map.get(b) );\\n        for(int num: nums) {\\n            minHeap.add(num);\\n        }\\n        int i=0;\\n        while(!minHeap.isEmpty()) {\\n            sortedArr[i++] = minHeap.remove();\\n        }\\n        \\n        return sortedArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092566,
                "title": "java-solution-using-custom-sort",
                "content": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i : nums)\\n            map.put(i, map.getOrDefault(i,0) + 1);\\n        List<Map.Entry<Integer, Integer>> list = new ArrayList(map.entrySet());\\n        Collections.sort(list, (a,b) -> a.getValue() == b.getValue() ? b.getKey() - a.getKey() : a.getValue() - b.getValue());\\n        int j = 0;\\n        int[] res = new int[nums.length];\\n        for (Map.Entry<Integer, Integer> entry : list) \\n            for (int i=0; i<entry.getValue(); i++) res[j++] = entry.getKey();\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i : nums)\\n            map.put(i, map.getOrDefault(i,0) + 1);\\n        List<Map.Entry<Integer, Integer>> list = new ArrayList(map.entrySet());\\n        Collections.sort(list, (a,b) -> a.getValue() == b.getValue() ? b.getKey() - a.getKey() : a.getValue() - b.getValue());\\n        int j = 0;\\n        int[] res = new int[nums.length];\\n        for (Map.Entry<Integer, Integer> entry : list) \\n            for (int i=0; i<entry.getValue(); i++) res[j++] = entry.getKey();\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933568,
                "title": "go-solution",
                "content": "```go\\nfunc frequencySort(nums []int) []int {\\n    seen := map[int]int{}\\n\\n\\tfor _, v := range nums {\\n\\t\\tseen[v]++\\n\\t}\\n\\n    sort.Slice(nums, func(i, j int) bool{\\n        if seen[nums[i]] == seen[nums[j]] {\\n            return nums[j] < nums[i]\\n        }\\n        \\n        return seen[nums[i]] < seen[nums[j]]\\n    })\\n\\n\\treturn nums\\n}\\n \\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc frequencySort(nums []int) []int {\\n    seen := map[int]int{}\\n\\n\\tfor _, v := range nums {\\n\\t\\tseen[v]++\\n\\t}\\n\\n    sort.Slice(nums, func(i, j int) bool{\\n        if seen[nums[i]] == seen[nums[j]] {\\n            return nums[j] < nums[i]\\n        }\\n        \\n        return seen[nums[i]] < seen[nums[j]]\\n    })\\n\\n\\treturn nums\\n}\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569340,
                "title": "java-treemap-arraylist-sorting-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer,Integer> map1 = new TreeMap<>();\\n        for(int i: nums)\\n            map1.put(i,map1.getOrDefault(i,0)+1);\\n        Map<Integer,List<Integer>> map2 = new TreeMap<>();\\n        for(Map.Entry m: map1.entrySet()){\\n            int num = (int)m.getKey();\\n            int fre = (int)m.getValue();\\n            if(map2.containsKey(fre)){\\n                List<Integer> l = new ArrayList<>(map2.get(fre));\\n                l.add(num);\\n                map2.replace(fre,l);\\n            }\\n            else{\\n                List<Integer> l = new ArrayList<>();\\n                l.add(num);\\n                map2.put(fre,l);\\n            }\\n        }\\n        int arr[] = new int[nums.length];\\n        int index=0;\\n        for(Map.Entry m: map2.entrySet()){\\n            int fre = (int)m.getKey();\\n            List<Integer> l = new ArrayList<>(map2.get(fre));\\n            Collections.sort(l);\\n            for(int i=l.size()-1;i>=0;i--){\\n                for(int k=0;k<fre;k++){\\n                    arr[index]=l.get(i);\\n                    index++;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer,Integer> map1 = new TreeMap<>();\\n        for(int i: nums)\\n            map1.put(i,map1.getOrDefault(i,0)+1);\\n        Map<Integer,List<Integer>> map2 = new TreeMap<>();\\n        for(Map.Entry m: map1.entrySet()){\\n            int num = (int)m.getKey();\\n            int fre = (int)m.getValue();\\n            if(map2.containsKey(fre)){\\n                List<Integer> l = new ArrayList<>(map2.get(fre));\\n                l.add(num);\\n                map2.replace(fre,l);\\n            }\\n            else{\\n                List<Integer> l = new ArrayList<>();\\n                l.add(num);\\n                map2.put(fre,l);\\n            }\\n        }\\n        int arr[] = new int[nums.length];\\n        int index=0;\\n        for(Map.Entry m: map2.entrySet()){\\n            int fre = (int)m.getKey();\\n            List<Integer> l = new ArrayList<>(map2.get(fre));\\n            Collections.sort(l);\\n            for(int i=l.size()-1;i>=0;i--){\\n                for(int k=0;k<fre;k++){\\n                    arr[index]=l.get(i);\\n                    index++;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386081,
                "title": "simple-java-solution-using-hashmap-and-comparator",
                "content": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        HashMap<Integer,Integer> hm=new HashMap<>(); //Creating frequency map\\n        for(int x : nums)\\n        {\\n            if(hm.containsKey(x))\\n            {\\n                hm.put(x,hm.get(x)+1);\\n            }\\n            else\\n            {\\n                hm.put(x,1);\\n            }\\n        }\\n        Integer arr[]=new Integer[nums.length]; //since comparator cant be applied to primitive types\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            arr[i]=nums[i]; //boxing\\n        }\\n        Arrays.sort(arr,new Comparator<Integer> ()\\n                    {\\n                        @Override\\n                        public int compare(Integer a , Integer b)\\n                        {\\n                            if(hm.get(a)> hm.get(b))\\n                                return 1;\\n                            else if(hm.get(a)<hm.get(b))\\n                                return -1;\\n                            else\\n                                return b-a;\\n                        }\\n                    });\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            nums[i]=arr[i]; //unboxing\\n        }\\n        return nums;\\n    }\\n}\\n```\\n\\n**Please Upvote If It Helps**\\n**Happy Coding : )**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        HashMap<Integer,Integer> hm=new HashMap<>(); //Creating frequency map\\n        for(int x : nums)\\n        {\\n            if(hm.containsKey(x))\\n            {\\n                hm.put(x,hm.get(x)+1);\\n            }\\n            else\\n            {\\n                hm.put(x,1);\\n            }\\n        }\\n        Integer arr[]=new Integer[nums.length]; //since comparator cant be applied to primitive types\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            arr[i]=nums[i]; //boxing\\n        }\\n        Arrays.sort(arr,new Comparator<Integer> ()\\n                    {\\n                        @Override\\n                        public int compare(Integer a , Integer b)\\n                        {\\n                            if(hm.get(a)> hm.get(b))\\n                                return 1;\\n                            else if(hm.get(a)<hm.get(b))\\n                                return -1;\\n                            else\\n                                return b-a;\\n                        }\\n                    });\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            nums[i]=arr[i]; //unboxing\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827081,
                "title": "javascript-easy-to-understand-detailed-explanation-with-map-or-array",
                "content": "## Core Strategy\\n\\nThe purpose of this problem is to sort the array with custom rules. It\\'s straightforward, but we need to do more:\\n- we need to count the frequency first since we don\\'t have it\\n- we need to do the sorting with frequency and value\\n\\nFor the first step, we coud use a map or an array to do the counting.\\nFor the second step, we could use JS native `sort` method for an array to do custom sorting.\\n\\n## Using a map\\n\\nFor this solution, we use a map to do the frequency counting. It\\'s straightforward.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst frequencySort = (nums) => {\\n  const freq = {};\\n  for (const num of nums) {\\n    freq[num] = (freq[num] || 0) + 1;\\n  }\\n  return nums.sort((a, b) => freq[a] === freq[b] ? b - a : freq[a] - freq[b]);\\n};\\n```\\n\\n## Using an array and some tricks\\n\\nFor this solution, since the range of `num[i]` is small, so we could use a fixed-length array to do the counting. Take care of that `OFFSET` since the index of array should be non-negative.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst frequencySort = (nums) => {\\n  const freq = new Uint8Array(201);\\n  const OFFSET = 100;\\n  for (const num of nums) {\\n    ++freq[num + OFFSET];\\n  }\\n  return nums.sort((a, b, a2 = a + OFFSET, b2 = b + OFFSET) => freq[a2] === freq[b2] ? b - a : freq[a2] - freq[b2]);\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst frequencySort = (nums) => {\\n  const freq = {};\\n  for (const num of nums) {\\n    freq[num] = (freq[num] || 0) + 1;\\n  }\\n  return nums.sort((a, b) => freq[a] === freq[b] ? b - a : freq[a] - freq[b]);\\n};\\n```\n```js\\nconst frequencySort = (nums) => {\\n  const freq = new Uint8Array(201);\\n  const OFFSET = 100;\\n  for (const num of nums) {\\n    ++freq[num + OFFSET];\\n  }\\n  return nums.sort((a, b, a2 = a + OFFSET, b2 = b + OFFSET) => freq[a2] === freq[b2] ? b - a : freq[a2] - freq[b2]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822883,
                "title": "java-self-explanatory-easy-to-understand-98-faster",
                "content": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i:nums) map.put(i,map.getOrDefault(i,0)+1);\\n        int[][] arr = new int[map.size()][2];\\n        int idx=0;\\n        for(int i:map.keySet()){\\n            arr[idx][0] = i;\\n            arr[idx++][1] = map.get(i);\\n        } \\n        Arrays.sort(arr,(i,j) -> {if(i[1] > j[1]) return 1; if(i[1] < j[1]) return -1; if(i[0] > j[0]) return -1;return 1;});\\n        idx=0;\\n        for(int i=0;i<arr.length;i++){\\n            while(arr[i][1]-->0) nums[idx++] = arr[i][0];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i:nums) map.put(i,map.getOrDefault(i,0)+1);\\n        int[][] arr = new int[map.size()][2];\\n        int idx=0;\\n        for(int i:map.keySet()){\\n            arr[idx][0] = i;\\n            arr[idx++][1] = map.get(i);\\n        } \\n        Arrays.sort(arr,(i,j) -> {if(i[1] > j[1]) return 1; if(i[1] < j[1]) return -1; if(i[0] > j[0]) return -1;return 1;});\\n        idx=0;\\n        for(int i=0;i<arr.length;i++){\\n            while(arr[i][1]-->0) nums[idx++] = arr[i][0];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786171,
                "title": "easy-and-explained-c-code-lambda-expression",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map <int,int> mp;\\n        // we need to modify our sort function to do that we\\'ll use \\n        // lambda fnction\\n        for(auto x: nums) mp[x]++;\\n\\t\\t// [&](int a , int b) -> syntax of lambda exp. takes two input as we compare two values AND also use refrence as in our case ,need to acces mp (hashmap).\\n        sort(nums.begin(),nums.end(),[&](int a , int b){\\n            return mp[a]!=mp[b]?mp[a]<mp[b] : a>b;\\n            // mp[a]<mp[b] --> it. corresponds to lesser frequncy \\n            // a>b --> this to whose value is greater as said in que. store in dec.\\n        });\\n            return nums;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map <int,int> mp;\\n        // we need to modify our sort function to do that we\\'ll use \\n        // lambda fnction\\n        for(auto x: nums) mp[x]++;\\n\\t\\t// [&](int a , int b) -> syntax of lambda exp. takes two input as we compare two values AND also use refrence as in our case ,need to acces mp (hashmap).\\n        sort(nums.begin(),nums.end(),[&](int a , int b){\\n            return mp[a]!=mp[b]?mp[a]<mp[b] : a>b;\\n            // mp[a]<mp[b] --> it. corresponds to lesser frequncy \\n            // a>b --> this to whose value is greater as said in que. store in dec.\\n        });\\n            return nums;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721347,
                "title": "java-easy-to-understand-solution",
                "content": "-> The idea is to use hashmap for storing frequency of the values and then iterate over hashmap and store values and their frequency in 2d array then sort the 2d array on the basis of two columns and then fill the new ans[] array and return it.\\n-> We will sort the array on the basis of two columns because values having equal frequencies should be sorted in decreasing order.\\n-> So, we will first sort the 2d array on the basis of values (decreasing order) and then on the basis of frequency (increasing order).\\n******Please upvote if it helps you to solve the problem******* as it motivates me to post solutions.\\n    \\n\\tpublic int[] frequencySort(int[] nums) {\\n\\t\\t //hashmap for storing frequency of the values\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        \\n\\t\\tint c = 0; //for counting distinct values \\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                int v = hm.get(nums[i]);\\n                v++;\\n                hm.put(nums[i],v);\\n            }else{\\n                hm.put(nums[i],1);\\n                c++;\\n            }\\n        }\\n\\t\\t\\n        int[][] arr = new int[c][2];  //2d array which contains values in first column and frequency in second column\\n\\t\\t\\n\\t\\t//iterate over hashmap to store value and frequency in 2d array\\n        int i=0;\\n\\t\\tfor(Map.Entry<Integer,Integer> entry:hm.entrySet()){\\n            arr[i][0] = entry.getKey();\\n            arr[i][1] = entry.getValue();\\n            i++;\\n        }\\n\\t\\t// values are sorted in decreasing order as per given in the question\\n        Arrays.sort(arr,(a,b)->b[0]-a[0]);\\n\\t\\t\\n\\t\\t//frequency in increasing order\\n        Arrays.sort(arr,(a,b)->a[1]-b[1]);  \\n        \\n\\t\\tint[] ans = new int[nums.length];  //ans array to return the answer\\n        int j=0;\\n        for(i=0;i<arr.length;i++){\\n            int count = 0;\\n            while(count<arr[i][1]){\\n                ans[j] = arr[i][0];\\n                j++;\\n                count++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t}```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "-> The idea is to use hashmap for storing frequency of the values and then iterate over hashmap and store values and their frequency in 2d array then sort the 2d array on the basis of two columns and then fill the new ans[] array and return it.\\n-> We will sort the array on the basis of two columns because values having equal frequencies should be sorted in decreasing order.\\n-> So, we will first sort the 2d array on the basis of values (decreasing order) and then on the basis of frequency (increasing order).\\n******Please upvote if it helps you to solve the problem******* as it motivates me to post solutions.\\n    \\n\\tpublic int[] frequencySort(int[] nums) {\\n\\t\\t //hashmap for storing frequency of the values\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        \\n\\t\\tint c = 0; //for counting distinct values \\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                int v = hm.get(nums[i]);\\n                v++;\\n                hm.put(nums[i],v);\\n            }else{\\n                hm.put(nums[i],1);\\n                c++;\\n            }\\n        }\\n\\t\\t\\n        int[][] arr = new int[c][2];  //2d array which contains values in first column and frequency in second column\\n\\t\\t\\n\\t\\t//iterate over hashmap to store value and frequency in 2d array\\n        int i=0;\\n\\t\\tfor(Map.Entry<Integer,Integer> entry:hm.entrySet()){\\n            arr[i][0] = entry.getKey();\\n            arr[i][1] = entry.getValue();\\n            i++;\\n        }\\n\\t\\t// values are sorted in decreasing order as per given in the question\\n        Arrays.sort(arr,(a,b)->b[0]-a[0]);\\n\\t\\t\\n\\t\\t//frequency in increasing order\\n        Arrays.sort(arr,(a,b)->a[1]-b[1]);  \\n        \\n\\t\\tint[] ans = new int[nums.length];  //ans array to return the answer\\n        int j=0;\\n        for(i=0;i<arr.length;i++){\\n            int count = 0;\\n            while(count<arr[i][1]){\\n                ans[j] = arr[i][0];\\n                j++;\\n                count++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t}```",
                "codeTag": "Unknown"
            },
            {
                "id": 1585693,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * Time Complexity: O(nlogn)\\n * Space Complexity: O(n)\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst frequencySort = function (nums) {   \\n  return nums.sort(compareFrequency(mapFrequency(nums)));\\n};\\n\\n/**\\n * @param {number[]} nums\\n * @return {number{}}\\n */\\nconst mapFrequency = function (nums) {\\n  return nums.reduce(\\n    (acc, cur) => (acc[cur] = (acc[cur] || 0) + 1, acc)\\n  , {}); \\n}\\n\\n/**\\n * @param {number{}} frequency\\n * @return {number}\\n */\\nconst compareFrequency = function (frequency) {\\n  return function (a, b) {\\n    return (frequency[a] - frequency[b]) || b - a;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Time Complexity: O(nlogn)\\n * Space Complexity: O(n)\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst frequencySort = function (nums) {   \\n  return nums.sort(compareFrequency(mapFrequency(nums)));\\n};\\n\\n/**\\n * @param {number[]} nums\\n * @return {number{}}\\n */\\nconst mapFrequency = function (nums) {\\n  return nums.reduce(\\n    (acc, cur) => (acc[cur] = (acc[cur] || 0) + 1, acc)\\n  , {}); \\n}\\n\\n/**\\n * @param {number{}} frequency\\n * @return {number}\\n */\\nconst compareFrequency = function (frequency) {\\n  return function (a, b) {\\n    return (frequency[a] - frequency[b]) || b - a;\\n  }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1541471,
                "title": "ez-python-code-for-beginners-o-nlogn",
                "content": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        d={}\\n        nums.sort()\\n        nums=nums[::-1]\\n        for i in nums:\\n            if i not in d:\\n                d[i]=0\\n            d[i]+=1\\n        ans=[]\\n        d=dict(sorted(d.items(),key=lambda x:x[1]))\\n        for i,j in d.items():\\n            while d[i]!=0:\\n                ans.append(i)\\n                d[i]-=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        d={}\\n        nums.sort()\\n        nums=nums[::-1]\\n        for i in nums:\\n            if i not in d:\\n                d[i]=0\\n            d[i]+=1\\n        ans=[]\\n        d=dict(sorted(d.items(),key=lambda x:x[1]))\\n        for i,j in d.items():\\n            while d[i]!=0:\\n                ans.append(i)\\n                d[i]-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450501,
                "title": "simple-solution-in-java",
                "content": "- Use map to store element & count/frequency\\n- Use priority queue to store key-value pair is custom sorted format (as required in question)\\n- Store the elements as required in array\\n\\n```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->(a[1]==b[1])?b[0]-a[0]:a[1]-b[1]);\\n        \\n        //Find count\\n        for(int n:nums){\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n        //Sort\\n        //Insert to pq\\n        for(int key:map.keySet()){\\n            pq.add(new int[]{key,map.get(key)});\\n        }\\n        \\n        int[] res=new int[nums.length];\\n        int idx=0;\\n        \\n        while(!pq.isEmpty()){\\n            int[] tmp=pq.poll();\\n            while(tmp[1]-->0){\\n                res[idx]=tmp[0];\\n                idx++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->(a[1]==b[1])?b[0]-a[0]:a[1]-b[1]);\\n        \\n        //Find count\\n        for(int n:nums){\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n        //Sort\\n        //Insert to pq\\n        for(int key:map.keySet()){\\n            pq.add(new int[]{key,map.get(key)});\\n        }\\n        \\n        int[] res=new int[nums.length];\\n        int idx=0;\\n        \\n        while(!pq.isEmpty()){\\n            int[] tmp=pq.poll();\\n            while(tmp[1]-->0){\\n                res[idx]=tmp[0];\\n                idx++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279574,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        \\n        Map<Integer,Integer> map = new HashMap<>();\\n        \\n        int L = nums.length;\\n\\t\\t\\n\\t\\t//Store numbers with their occurences in Map\\n\\t\\t\\n        for(int i=0;i<L;i++){\\n            if(!map.containsKey(nums[i])){\\n                map.put(nums[i],1);\\n            }\\n            else{\\n                int g = map.get(nums[i]);\\n                ++g;\\n                map.put(nums[i],g);\\n            }\\n        }\\n       \\n        int index=0;\\n        while(!map.isEmpty()){\\n            int min=1000,k=0,v=0;\\n\\t\\t\\t\\n\\t\\t\\t//Select min occuring number and add it in array.\\n\\t\\t\\t\\n            for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n              \\n                \\n                v=entry.getValue();\\n                if(v<min){\\n                    k= entry.getKey();\\n                    min=v;\\n                }\\n                else if(v==min){\\n                    if(k<entry.getKey()){\\n                        k=entry.getKey();\\n                    }\\n                }\\n            }\\n            while(min!=0){\\n                nums[index]=k;\\n                index++;\\n                min--;\\n            }\\n            \\n            map.remove(k);\\n            \\n        }\\n        return nums;\\n        \\n    }\\n}\\n```\\n\\nDo let me know in comments if this code can be improved.\\nHappy Coding!!!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        \\n        Map<Integer,Integer> map = new HashMap<>();\\n        \\n        int L = nums.length;\\n\\t\\t\\n\\t\\t//Store numbers with their occurences in Map\\n\\t\\t\\n        for(int i=0;i<L;i++){\\n            if(!map.containsKey(nums[i])){\\n                map.put(nums[i],1);\\n            }\\n            else{\\n                int g = map.get(nums[i]);\\n                ++g;\\n                map.put(nums[i],g);\\n            }\\n        }\\n       \\n        int index=0;\\n        while(!map.isEmpty()){\\n            int min=1000,k=0,v=0;\\n\\t\\t\\t\\n\\t\\t\\t//Select min occuring number and add it in array.\\n\\t\\t\\t\\n            for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n              \\n                \\n                v=entry.getValue();\\n                if(v<min){\\n                    k= entry.getKey();\\n                    min=v;\\n                }\\n                else if(v==min){\\n                    if(k<entry.getKey()){\\n                        k=entry.getKey();\\n                    }\\n                }\\n            }\\n            while(min!=0){\\n                nums[index]=k;\\n                index++;\\n                min--;\\n            }\\n            \\n            map.remove(k);\\n            \\n        }\\n        return nums;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222027,
                "title": "python-easy-solution",
                "content": "\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        nums.sort(reverse=True)\\n        ans = sorted(nums, key = nums.count)\\n        return ans",
                "solutionTags": [],
                "code": "\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        nums.sort(reverse=True)\\n        ans = sorted(nums, key = nums.count)\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 1112554,
                "title": "java-simple-solution-faster-than-95",
                "content": "JAVA CODE IS:\\n#    \\n```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n      Map<Integer,Integer>map=new HashMap<>();\\n        for(int val : nums)\\n            map.put(val,map.getOrDefault(val,0)+1);\\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a,b)->b[1]!=a[1] ? a[1]-b[1] : b[0]-a[0]);\\n        for(Map.Entry<Integer,Integer>m : map.entrySet())\\n            pq.add(new int[]{m.getKey(),m.getValue()});\\n        int i=0;\\n        while(!pq.isEmpty()){\\n            int a[]=pq.poll();\\n            while(a[1]-->0)\\n                nums[i++]=a[0];\\n        }\\n        return nums;\\n    }\\n}\\n```\\nTime : O(nlogn)\\nSpace : O(n)\\n***PLEASE,UPVOTE IF THIS IS HELPFUL***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n      Map<Integer,Integer>map=new HashMap<>();\\n        for(int val : nums)\\n            map.put(val,map.getOrDefault(val,0)+1);\\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a,b)->b[1]!=a[1] ? a[1]-b[1] : b[0]-a[0]);\\n        for(Map.Entry<Integer,Integer>m : map.entrySet())\\n            pq.add(new int[]{m.getKey(),m.getValue()});\\n        int i=0;\\n        while(!pq.isEmpty()){\\n            int a[]=pq.poll();\\n            while(a[1]-->0)\\n                nums[i++]=a[0];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094015,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int, int> counter;\\n        \\n        for (const auto& num : nums) counter[num]++; \\n        \\n        sort(nums.begin(), nums.end(), [&](int a, int b) {\\n            return counter[a] < counter[b] || (counter[a] == counter[b] && b < a);\\n        });\\n        \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int, int> counter;\\n        \\n        for (const auto& num : nums) counter[num]++; \\n        \\n        sort(nums.begin(), nums.end(), [&](int a, int b) {\\n            return counter[a] < counter[b] || (counter[a] == counter[b] && b < a);\\n        });\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963789,
                "title": "go-solution-using-sort",
                "content": "```\\nfunc frequencySort(nums []int) []int {\\n    freq := make(map[int]int)\\n    for _,v := range nums { freq[v] ++ }\\n    sort.Slice(nums, func (a,b int) bool {\\n        if freq[nums[a]] == freq[nums[b]] { return nums[a] > nums[b] }\\n        return freq[nums[a]] < freq[nums[b]]\\n    })\\n    return nums\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc frequencySort(nums []int) []int {\\n    freq := make(map[int]int)\\n    for _,v := range nums { freq[v] ++ }\\n    sort.Slice(nums, func (a,b int) bool {\\n        if freq[nums[a]] == freq[nums[b]] { return nums[a] > nums[b] }\\n        return freq[nums[a]] < freq[nums[b]]\\n    })\\n    return nums\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 917759,
                "title": "java-sort-using-custom-frequency-comparator",
                "content": "1. Calculate the occurence of each number and store it in a hashmap\\n2. Define a custom comparator to sort first based on frequency and then based on value\\n3. Fill into the result array\\n\\n```\\npublic int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> freqCount = new HashMap();\\n        for (int n : nums) {\\n            freqCount.put(n, freqCount.getOrDefault(n, 0) + 1);\\n        }\\n        Comparator<Map.Entry<Integer, Integer>> valueComparator = new Comparator<Map.Entry<Integer, Integer>>() {\\n            @Override\\n            public int compare(Map.Entry<Integer, Integer> e1, Map.Entry<Integer, Integer> e2) {\\n                return e1.getValue() == e2.getValue() ? (e1.getKey() < e2.getKey() ? 1 : -1) : (e1.getValue() < e2.getValue() ? -1 : 1);\\n            }\\n        };\\n        \\n        List<Map.Entry<Integer, Integer>> sortedList = new ArrayList<Map.Entry<Integer, Integer>>(freqCount.entrySet());\\n        Collections.sort(sortedList, valueComparator);\\n        int[] result = new int[nums.length];\\n        int i = 0;\\n        for (Map.Entry<Integer, Integer> e : sortedList) {\\n            for (int j = 0; j < e.getValue(); ++j) {\\n                result[i++] = e.getKey();\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> freqCount = new HashMap();\\n        for (int n : nums) {\\n            freqCount.put(n, freqCount.getOrDefault(n, 0) + 1);\\n        }\\n        Comparator<Map.Entry<Integer, Integer>> valueComparator = new Comparator<Map.Entry<Integer, Integer>>() {\\n            @Override\\n            public int compare(Map.Entry<Integer, Integer> e1, Map.Entry<Integer, Integer> e2) {\\n                return e1.getValue() == e2.getValue() ? (e1.getKey() < e2.getKey() ? 1 : -1) : (e1.getValue() < e2.getValue() ? -1 : 1);\\n            }\\n        };\\n        \\n        List<Map.Entry<Integer, Integer>> sortedList = new ArrayList<Map.Entry<Integer, Integer>>(freqCount.entrySet());\\n        Collections.sort(sortedList, valueComparator);\\n        int[] result = new int[nums.length];\\n        int i = 0;\\n        for (Map.Entry<Integer, Integer> e : sortedList) {\\n            for (int j = 0; j < e.getValue(); ++j) {\\n                result[i++] = e.getKey();\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 917712,
                "title": "python-sort-on-count-value-3-lines",
                "content": "Have the sort key be the count of occurrences, and the negative of the value. O(nlogn),O(n) time and space.\\n\\n```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        counter = collections.Counter(nums)\\n        nums.sort(key=lambda x: (counter[x],-x))\\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        counter = collections.Counter(nums)\\n        nums.sort(key=lambda x: (counter[x],-x))\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798314,
                "title": "simple-10-line-solution-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> hashmap;\\n        for (int i = 0; i < n; i++)hashmap[nums[i]]++;\\n        priority_queue<pair<int, int>> pq;\\n        for (auto it : hashmap)pq.push({-it.second, it.first}); \\n        vector<int> ans;\\n        while (!pq.empty()) {\\n            for(int i=0;i<-pq.top().first;i++)ans.emplace_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> hashmap;\\n        for (int i = 0; i < n; i++)hashmap[nums[i]]++;\\n        priority_queue<pair<int, int>> pq;\\n        for (auto it : hashmap)pq.push({-it.second, it.first}); \\n        vector<int> ans;\\n        while (!pq.empty()) {\\n            for(int i=0;i<-pq.top().first;i++)ans.emplace_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434003,
                "title": "using-hashmap-priorityqueue-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    class Pair\\n    {\\n        int num;\\n        int freq;\\n        Pair(int num, int freq)\\n        {\\n            this.num=num;\\n            this.freq=freq;\\n        }\\n    }\\n    public int[] frequencySort(int[] nums) {\\n      HashMap<Integer, Integer>h=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            h.put(nums[i],h.getOrDefault(nums[i],0)+1);\\n        }\\n        PriorityQueue<Pair>pq=new PriorityQueue<>((a,b)->a.freq==b.freq?b.num-a.num: a.freq-b.freq);\\n        for(int i: h.keySet()){\\n            pq.add(new Pair(i, h.get(i)));\\n        }\\n        int arr[]=new int[nums.length];\\n        int j=0;\\n        while(!pq.isEmpty()){\\n            int n=pq.peek().num;\\n            int f=pq.peek().freq;\\n            pq.poll();\\n            for(int i=0; i<f; i++){\\n                arr[j]=n;\\n                j++;\\n            }\\n        }\\n        return arr;  \\n     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    class Pair\\n    {\\n        int num;\\n        int freq;\\n        Pair(int num, int freq)\\n        {\\n            this.num=num;\\n            this.freq=freq;\\n        }\\n    }\\n    public int[] frequencySort(int[] nums) {\\n      HashMap<Integer, Integer>h=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            h.put(nums[i],h.getOrDefault(nums[i],0)+1);\\n        }\\n        PriorityQueue<Pair>pq=new PriorityQueue<>((a,b)->a.freq==b.freq?b.num-a.num: a.freq-b.freq);\\n        for(int i: h.keySet()){\\n            pq.add(new Pair(i, h.get(i)));\\n        }\\n        int arr[]=new int[nums.length];\\n        int j=0;\\n        while(!pq.isEmpty()){\\n            int n=pq.peek().num;\\n            int f=pq.peek().freq;\\n            pq.poll();\\n            for(int i=0; i<f; i++){\\n                arr[j]=n;\\n                j++;\\n            }\\n        }\\n        return arr;  \\n     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972361,
                "title": "java-efficient-1-ms-priorityqueue-hashmap",
                "content": "\\n# Complexity\\n- Time complexity:\\nO ( n )\\n\\n- Space complexity:\\nO ( n )\\n\\n# Code\\n```\\nclass Solution {\\n    class Pair{\\n        int num;\\n        int freq;\\n        Pair(int num, int freq){\\n            this.num=num;\\n            this.freq=freq;\\n        }\\n    }\\n    public int[] frequencySort(int[] nums) {\\n        HashMap<Integer, Integer>h=new HashMap<>();\\n        for(int i=0; i<nums.length; i++){\\n            h.put(nums[i], h.getOrDefault(nums[i],0)+1);\\n        }\\n        PriorityQueue<Pair>pq=new PriorityQueue<>((a,b)->a.freq==b.freq?b.num-a.num: a.freq-b.freq);\\n        for(int i: h.keySet()){\\n            pq.add(new Pair(i, h.get(i)));\\n        }\\n        int arr[]=new int[nums.length];\\n        int j=0;\\n        while(!pq.isEmpty()){\\n            int n=pq.peek().num;\\n            int f=pq.peek().freq;\\n            pq.poll();\\n            for(int i=0; i<f; i++){\\n                arr[j]=n;\\n                j++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int num;\\n        int freq;\\n        Pair(int num, int freq){\\n            this.num=num;\\n            this.freq=freq;\\n        }\\n    }\\n    public int[] frequencySort(int[] nums) {\\n        HashMap<Integer, Integer>h=new HashMap<>();\\n        for(int i=0; i<nums.length; i++){\\n            h.put(nums[i], h.getOrDefault(nums[i],0)+1);\\n        }\\n        PriorityQueue<Pair>pq=new PriorityQueue<>((a,b)->a.freq==b.freq?b.num-a.num: a.freq-b.freq);\\n        for(int i: h.keySet()){\\n            pq.add(new Pair(i, h.get(i)));\\n        }\\n        int arr[]=new int[nums.length];\\n        int j=0;\\n        while(!pq.isEmpty()){\\n            int n=pq.peek().num;\\n            int f=pq.peek().freq;\\n            pq.poll();\\n            for(int i=0; i<f; i++){\\n                arr[j]=n;\\n                j++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904426,
                "title": "heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom heapq import heappush,heappop\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        d={}\\n        for i in range(len(nums)):\\n            if(nums[i] in d):\\n                d[nums[i]]+=1\\n            else:\\n                d[nums[i]]=1\\n        heap=[]\\n        arr=[]\\n        for i in d:\\n            heappush(heap,[d[i],-i])\\n        while(heap):\\n            m,n=heappop(heap)\\n            for i in range(m):\\n                arr.append(n*(-1))\\n        return(arr)\\n                \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappush,heappop\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        d={}\\n        for i in range(len(nums)):\\n            if(nums[i] in d):\\n                d[nums[i]]+=1\\n            else:\\n                d[nums[i]]=1\\n        heap=[]\\n        arr=[]\\n        for i in d:\\n            heappush(heap,[d[i],-i])\\n        while(heap):\\n            m,n=heappop(heap)\\n            for i in range(m):\\n                arr.append(n*(-1))\\n        return(arr)\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872097,
                "title": "solution-by-using-priority-queue-and-comparator-in-c",
                "content": "\\n```\\n\\n#define pii pair<int, int>\\n\\nclass MyComp\\n{\\npublic:\\n    bool operator()(pii const &p1, pii p2)\\n    {\\n        if (p1.first == p2.first)\\n        {\\n            return p1.second <p2.second;\\n        }\\n        return p1.first >p2.first;\\n    }\\n};\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> frequencySort(vector<int> &nums)\\n    {\\n        vector<int> ans;\\n        priority_queue<pii, vector<pii>, MyComp> pq;\\n\\n        unordered_map<int, int> mp;\\n        for (int n : nums)\\n            mp[n]++;\\n\\n        for (auto it : mp)\\n            pq.push({it.second, it.first});\\n\\n        while (not pq.empty())\\n        {\\n            int freq = pq.top().first;\\n            int n = pq.top().second;\\n\\n            pq.pop();\\n            while (freq--)\\n            {\\n                ans.push_back(n);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n#define pii pair<int, int>\\n\\nclass MyComp\\n{\\npublic:\\n    bool operator()(pii const &p1, pii p2)\\n    {\\n        if (p1.first == p2.first)\\n        {\\n            return p1.second <p2.second;\\n        }\\n        return p1.first >p2.first;\\n    }\\n};\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> frequencySort(vector<int> &nums)\\n    {\\n        vector<int> ans;\\n        priority_queue<pii, vector<pii>, MyComp> pq;\\n\\n        unordered_map<int, int> mp;\\n        for (int n : nums)\\n            mp[n]++;\\n\\n        for (auto it : mp)\\n            pq.push({it.second, it.first});\\n\\n        while (not pq.empty())\\n        {\\n            int freq = pq.top().first;\\n            int n = pq.top().second;\\n\\n            pq.pop();\\n            while (freq--)\\n            {\\n                ans.push_back(n);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466203,
                "title": "simple-python3-solution",
                "content": "1) Use Counter to collect the frequency for each of the unique numbers in the nums list\\n2) Convert it into dictionary (list defaultdict) with keys as the frequncies and the values as a list of unique elements with that frequency\\n3) Iterate through the sorted list of frequencies\\n4) For each ferquency iterate through the list of unique elements in descending/reverse order\\n5) Append each element (times frequnecy) to the resultant list\\n6) Return resultant list\\n\\n```\\nfrom collections import Counter\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        res = []\\n        freq_count = Counter(nums)\\n        freq_map = defaultdict(list)\\n        for k, v in freq_count.items():\\n            freq_map[v].append(k)\\n        for f in sorted(freq_map):\\n            for num in sorted(freq_map[f], reverse=True):\\n                res = res + [num]*f\\n\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        res = []\\n        freq_count = Counter(nums)\\n        freq_map = defaultdict(list)\\n        for k, v in freq_count.items():\\n            freq_map[v].append(k)\\n        for f in sorted(freq_map):\\n            for num in sorted(freq_map[f], reverse=True):\\n                res = res + [num]*f\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434681,
                "title": "java-stream-solution",
                "content": "`NOT FASTER SOLUTION`\\n\\n```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        return Arrays.stream(nums)\\n                .boxed()\\n                .collect(Collectors.toMap(item -> item, item -> 1, Integer::sum))\\n                .entrySet()\\n                .stream()\\n                .sorted((item1, item2) -> item1.getValue().equals(item2.getValue()) ? item2.getKey().compareTo(item1.getKey()) : item1.getValue().compareTo(item2.getValue()))\\n                .flatMap(item -> Stream.iterate(item.getKey(), n -> n).limit(item.getValue()))\\n                .mapToInt(item -> item)\\n                .toArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        return Arrays.stream(nums)\\n                .boxed()\\n                .collect(Collectors.toMap(item -> item, item -> 1, Integer::sum))\\n                .entrySet()\\n                .stream()\\n                .sorted((item1, item2) -> item1.getValue().equals(item2.getValue()) ? item2.getKey().compareTo(item1.getKey()) : item1.getValue().compareTo(item2.getValue()))\\n                .flatMap(item -> Stream.iterate(item.getKey(), n -> n).limit(item.getValue()))\\n                .mapToInt(item -> item)\\n                .toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361740,
                "title": "java-hashmap-custom-sort",
                "content": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums.length; i++) \\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n        \\n        List<Integer> keys = new ArrayList<>(map.keySet());\\n        Collections.sort(keys, (a,b) -> (map.get(a) == map.get(b))? b - a : map.get(a) - map.get(b));\\n        \\n        int p = 0;\\n        while(keys.size() > 0) {\\n            int ele = keys.get(0);\\n            int freq = map.get(ele);\\n            \\n            for(int i=0; i<freq; i++)\\n                nums[p++] = ele;\\n            keys.remove(0);\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums.length; i++) \\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n        \\n        List<Integer> keys = new ArrayList<>(map.keySet());\\n        Collections.sort(keys, (a,b) -> (map.get(a) == map.get(b))? b - a : map.get(a) - map.get(b));\\n        \\n        int p = 0;\\n        while(keys.size() > 0) {\\n            int ele = keys.get(0);\\n            int freq = map.get(ele);\\n            \\n            for(int i=0; i<freq; i++)\\n                nums[p++] = ele;\\n            keys.remove(0);\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359779,
                "title": "c-easy-optmized-solution",
                "content": "Solution 1-\\nTime Complexity- O(N^2)\\nSpace Complexity- O(N)\\n\\n1.Here we storing frequency of element in the hashmap \\n2.and then storing pair of freq and element in one vector.\\n3.Sorting the vector ccording to frequency and value of element with the help of cmp function\\n4.Created new vector ans and now adding element in the ans vector accrding to elements frequency.\\n```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tstatic bool cmp(pair<int,int>p,pair<int,int>q)\\n\\t\\t{\\n\\t\\t\\tif(p.first==q.first)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn p.second>q.second;\\n\\t\\t\\t}\\n\\t\\t\\treturn p.first<q.first;\\n\\t\\t}\\n\\t\\tvector<int> frequencySort(vector<int>& nums) \\n\\t\\t{\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tmap<int,int>freq;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfreq[nums[i]]++;\\n\\t\\t\\t}\\n\\t\\t\\tvector<pair<int,int>>v;\\n\\t\\t\\tfor(auto i:freq)\\n\\t\\t\\t{\\n\\t\\t\\t\\tv.push_back({i.second,i.first});\\n\\t\\t\\t}\\n\\n\\t\\t\\tsort(v.begin(),v.end(),cmp);\\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint n=v[i].first;\\n\\t\\t\\t\\tint val=v[i].second;\\n\\t\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans.push_back(val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n};\\n\\n```\\n\\nSolution 2-\\nTIme Complexity- O(NlogN)\\nSpace Complexity- O(N) \\n\\n1.Here we storing frequency of element in the hashmap \\n2.Sorting the given vector according to frequency and value of element with the help of cmp function.\\n\\n```\\nmap<int,int>freq;\\nbool cmp(int a,int b)\\n{\\n        return freq[a]==freq[b]?a>b:freq[a]<freq[b];\\n}\\nclass Solution\\n{\\n\\tpublic:\\n\\n\\t\\tvector<int> frequencySort(vector<int>& nums) \\n\\t\\t{\\n\\t\\t\\tfreq.clear();\\n\\n\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfreq[nums[i]]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tsort(nums.begin(),nums.end(),cmp);\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n};\\n```\\n\\nUpvote the solution, If you like the explanation.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tstatic bool cmp(pair<int,int>p,pair<int,int>q)\\n\\t\\t{\\n\\t\\t\\tif(p.first==q.first)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn p.second>q.second;\\n\\t\\t\\t}\\n\\t\\t\\treturn p.first<q.first;\\n\\t\\t}\\n\\t\\tvector<int> frequencySort(vector<int>& nums) \\n\\t\\t{\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tmap<int,int>freq;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfreq[nums[i]]++;\\n\\t\\t\\t}\\n\\t\\t\\tvector<pair<int,int>>v;\\n\\t\\t\\tfor(auto i:freq)\\n\\t\\t\\t{\\n\\t\\t\\t\\tv.push_back({i.second,i.first});\\n\\t\\t\\t}\\n\\n\\t\\t\\tsort(v.begin(),v.end(),cmp);\\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint n=v[i].first;\\n\\t\\t\\t\\tint val=v[i].second;\\n\\t\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans.push_back(val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n};\\n\\n```\n```\\nmap<int,int>freq;\\nbool cmp(int a,int b)\\n{\\n        return freq[a]==freq[b]?a>b:freq[a]<freq[b];\\n}\\nclass Solution\\n{\\n\\tpublic:\\n\\n\\t\\tvector<int> frequencySort(vector<int>& nums) \\n\\t\\t{\\n\\t\\t\\tfreq.clear();\\n\\n\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfreq[nums[i]]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tsort(nums.begin(),nums.end(),cmp);\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182145,
                "title": "c-easy-solution-using-max-heap",
                "content": "TIP  : We cant use min heap because in question a condition is given \"If multiple values have the same frequency, sort them in **decreasing order**.\" So what we will do we will use a max heap priority_queue<pair<int,int>.   pq.push({-1* freq, element}) will have -1* frequency of element and second will have the corresponding element. So the max heap will work as a min heap because of negative frequency and if we have same frequencies if will work as max heap because of second value (which is positive). \\n\\ntypedef pair<int,int> ppi;\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        vector<int> ans;\\n        unordered_map<int,int> fq;\\n        priority_queue<ppi> pq;       //minheap\\n        for(int i=0; i<nums.size(); i++){\\n            fq[nums[i]]++;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            pq.push({-1*fq[nums[i]],nums[i]});  \\n        }\\n        while(!pq.empty()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        vector<int> ans;\\n        unordered_map<int,int> fq;\\n        priority_queue<ppi> pq;       //minheap\\n        for(int i=0; i<nums.size(); i++){\\n            fq[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1672114,
                "title": "c-map-and-comparator",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static comparator(pair<int,int>m,pair<int,int>n){\\n        if(m.second==n.second)\\n            return m.first>n.first;//m>n can also be written it will return the same\\n        else\\n            return m.second<n.second;\\n    }\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto k:nums)\\n            mp[k]++;\\n        vector<pair<int,int>>v1;\\n        for(auto k:mp)\\n            v1.push_back(k);\\n        sort(v1.begin(),v1.end(),comparator);\\n        vector<int>v;\\n        for(auto k:v1){\\n            while(k.second!=0){\\n                v.push_back(k.first);\\n                k.second--;\\n            }\\n                \\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static comparator(pair<int,int>m,pair<int,int>n){\\n        if(m.second==n.second)\\n            return m.first>n.first;//m>n can also be written it will return the same\\n        else\\n            return m.second<n.second;\\n    }\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto k:nums)\\n            mp[k]++;\\n        vector<pair<int,int>>v1;\\n        for(auto k:mp)\\n            v1.push_back(k);\\n        sort(v1.begin(),v1.end(),comparator);\\n        vector<int>v;\\n        for(auto k:v1){\\n            while(k.second!=0){\\n                v.push_back(k.first);\\n                k.second--;\\n            }\\n                \\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1565890,
                "title": "c-using-unordered-map-and-sort-function",
                "content": "```\\nclass Solution {\\npublic:\\n   static bool cmp(pair<int,int> &l, pair<int, int> &r){\\n        if (l.second == r.second)\\n            return l.first > r.first;\\n        return l.second < r.second;\\n    }\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        for(auto i: nums){\\n            mp[i]++;\\n        }\\n        vector<pair<int,int>> v(mp.begin(), mp.end());\\n        sort(v.begin(), v.end(), cmp);\\n        int x = 0;\\n        for(auto i: v){\\n            while(i.second!=0){\\n                nums[x++] = i.first;\\n                i.second--;\\n            }\\n        }\\n        return nums;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   static bool cmp(pair<int,int> &l, pair<int, int> &r){\\n        if (l.second == r.second)\\n            return l.first > r.first;\\n        return l.second < r.second;\\n    }\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        for(auto i: nums){\\n            mp[i]++;\\n        }\\n        vector<pair<int,int>> v(mp.begin(), mp.end());\\n        sort(v.begin(), v.end(), cmp);\\n        int x = 0;\\n        for(auto i: v){\\n            while(i.second!=0){\\n                nums[x++] = i.first;\\n                i.second--;\\n            }\\n        }\\n        return nums;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448948,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar frequencySort = function (nums) {\\n    let map = new Map();\\n\\n    for (i = 0; i < nums.length; i++) {\\n        map.set(nums[i], (map.get(nums[i]) || 0) + 1);\\n    }\\n\\n    nums.sort((a, b) => (map.get(a) - map.get(b)) || (b - a));\\n\\n    return nums;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar frequencySort = function (nums) {\\n    let map = new Map();\\n\\n    for (i = 0; i < nums.length; i++) {\\n        map.set(nums[i], (map.get(nums[i]) || 0) + 1);\\n    }\\n\\n    nums.sort((a, b) => (map.get(a) - map.get(b)) || (b - a));\\n\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1446521,
                "title": "using-counter-95-speed",
                "content": "![image](https://assets.leetcode.com/users/images/b924d992-71f0-4875-b0cb-d79bec257702_1630861109.3894417.png)\\n\\n```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        lst = sorted([(key, freq) for key, freq in Counter(nums).items()],\\n                     key=lambda tpl: (tpl[1], -tpl[0]))\\n        ans = []\\n        for key, freq in lst:\\n            ans += [key] * freq\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        lst = sorted([(key, freq) for key, freq in Counter(nums).items()],\\n                     key=lambda tpl: (tpl[1], -tpl[0]))\\n        ans = []\\n        for key, freq in lst:\\n            ans += [key] * freq\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405535,
                "title": "python-using-merge-sort-technique",
                "content": "```\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        m = {}\\n        l = []\\n        for i in nums:\\n            if i not in m:\\n                m[i] = 1\\n            else:\\n                m[i] += 1\\n        def merge_sort_freq(arr):\\n            if len(arr) > 1:\\n                mid = len(arr) //2\\n                left = arr[0:mid]\\n                right = arr[mid:]\\n                merge_sort_freq(left)\\n                merge_sort_freq(right)       \\n                l = r = i = 0 \\n                while l < len(left) and r < len(right):\\n                    if m[left[l]] > m[right[r]]:\\n                        arr[i] = right[r]\\n                        r +=1\\n                    elif  m[left[l]] == m[right[r]]:\\n                        if left[l] > right[r]:\\n                            arr[i] = left[l]\\n                            l +=1\\n                        else:\\n                            arr[i] = right[r]\\n                            r +=1    \\n                    else:    \\n                        arr[i] = left[l]\\n                        l += 1\\n                    i += 1\\n                    \\n                while r < len(right) and i < len(arr):\\n                    arr[i] = right[r]\\n                    i += 1\\n                    r += 1                    \\n                while l < len(left) and i < len(arr):\\n                    arr[i] = left[l]\\n                    i += 1\\n                    l += 1\\n        merge_sort_freq(nums)\\n        return nums\\n```\\n\\nNot the prettiest solution, but if an interviewer wants to get into \"how would you actually sort\" I figure this isn\\'t a terrible solution.",
                "solutionTags": [
                    "Python",
                    "Merge Sort"
                ],
                "code": "```\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        m = {}\\n        l = []\\n        for i in nums:\\n            if i not in m:\\n                m[i] = 1\\n            else:\\n                m[i] += 1\\n        def merge_sort_freq(arr):\\n            if len(arr) > 1:\\n                mid = len(arr) //2\\n                left = arr[0:mid]\\n                right = arr[mid:]\\n                merge_sort_freq(left)\\n                merge_sort_freq(right)       \\n                l = r = i = 0 \\n                while l < len(left) and r < len(right):\\n                    if m[left[l]] > m[right[r]]:\\n                        arr[i] = right[r]\\n                        r +=1\\n                    elif  m[left[l]] == m[right[r]]:\\n                        if left[l] > right[r]:\\n                            arr[i] = left[l]\\n                            l +=1\\n                        else:\\n                            arr[i] = right[r]\\n                            r +=1    \\n                    else:    \\n                        arr[i] = left[l]\\n                        l += 1\\n                    i += 1\\n                    \\n                while r < len(right) and i < len(arr):\\n                    arr[i] = right[r]\\n                    i += 1\\n                    r += 1                    \\n                while l < len(left) and i < len(arr):\\n                    arr[i] = left[l]\\n                    i += 1\\n                    l += 1\\n        merge_sort_freq(nums)\\n        return nums\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1237152,
                "title": "simple-java-soln-using-hashmap-priorityqueue",
                "content": "Do upvote if you like the solution to keep me motivated \\uD83D\\uDE0A\\u270C\\n\\n```\\n\\nclass Solution {\\n    public int[] frequencySort(int[] arr) {\\n        int n = arr.length;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int ele:  arr)\\n          map.put(ele,map.getOrDefault(ele,0)+1);\\n          \\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->{\\n            if(map.get(a) != map.get(b))\\n              return map.get(a) - map.get(b);\\n            else\\n              return b - a;\\n        });\\n        \\n        for(Integer ele : map.keySet()){\\n            pq.add(ele);\\n        }\\n        int count = 0;\\n        int[] ans = new int[n];\\n        while(pq.size() != 0){\\n         int key = pq.remove();    \\n          for(int i=0;i<map.get(key);i++)\\n            ans[count++] = key;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int[] frequencySort(int[] arr) {\\n        int n = arr.length;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int ele:  arr)\\n          map.put(ele,map.getOrDefault(ele,0)+1);\\n          \\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->{\\n            if(map.get(a) != map.get(b))\\n              return map.get(a) - map.get(b);\\n            else\\n              return b - a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1220726,
                "title": "c-2-approaches-map-priority-queue",
                "content": "```\\n//Approach-1 (Priority_queue)\\ntypedef pair<int, int> P;\\nclass Solution {\\npublic:\\n     //Comparator lambda function for priority_queue\\n    struct myFunction {\\n        bool operator() (P& p1, P& p2) {\\n            if(p1.second == p2.second)\\n                return p1.first < p2.first;\\n        \\n            return p1.second > p2.second;   \\n        }\\n    };\\n    vector<int> frequencySort(vector<int>& nums) {\\n        \\n        unordered_map<int, int> mp;\\n        \\n        int n = nums.size();\\n        for(int i = 0; i<n; i++) {\\n            mp[nums[i]]++;\\n        }\\n        priority_queue<P, vector<P>, myFunction> pq(mp.begin(), mp.end());\\n        \\n        vector<int> result;\\n        while(!pq.empty()) {\\n            int curr  = pq.top().first;\\n            int times = pq.top().second;\\n            while(times--)\\n                result.push_back(curr);\\n            pq.pop();\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```\\n\\n```\\n//Approach-2\\ntypedef pair<int, int> P;\\nclass Solution {\\npublic:\\n    bool static comp(P& p1, P& p2) {\\n        if(p1.second == p2.second)\\n            return p1.first > p2.first;\\n        return p1.second < p2.second;\\n    }\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int n = nums.size();\\n        \\n        for(int i = 0; i<n; i++) {\\n            mp[nums[i]]++;\\n        }\\n        \\n        vector<P> result(mp.begin(), mp.end());\\n        sort(begin(result), end(result), comp);\\n        \\n        vector<int> finalResult;\\n        \\n        for(const P& p:result) {\\n            int curr  = p.first;\\n            int times = p.second;\\n            while(times--)\\n                finalResult.push_back(curr);\\n        }\\n        \\n        \\n        return finalResult;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Priority_queue)\\ntypedef pair<int, int> P;\\nclass Solution {\\npublic:\\n     //Comparator lambda function for priority_queue\\n    struct myFunction {\\n        bool operator() (P& p1, P& p2) {\\n            if(p1.second == p2.second)\\n                return p1.first < p2.first;\\n        \\n            return p1.second > p2.second;   \\n        }\\n    };\\n    vector<int> frequencySort(vector<int>& nums) {\\n        \\n        unordered_map<int, int> mp;\\n        \\n        int n = nums.size();\\n        for(int i = 0; i<n; i++) {\\n            mp[nums[i]]++;\\n        }\\n        priority_queue<P, vector<P>, myFunction> pq(mp.begin(), mp.end());\\n        \\n        vector<int> result;\\n        while(!pq.empty()) {\\n            int curr  = pq.top().first;\\n            int times = pq.top().second;\\n            while(times--)\\n                result.push_back(curr);\\n            pq.pop();\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```\n```\\n//Approach-2\\ntypedef pair<int, int> P;\\nclass Solution {\\npublic:\\n    bool static comp(P& p1, P& p2) {\\n        if(p1.second == p2.second)\\n            return p1.first > p2.first;\\n        return p1.second < p2.second;\\n    }\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int n = nums.size();\\n        \\n        for(int i = 0; i<n; i++) {\\n            mp[nums[i]]++;\\n        }\\n        \\n        vector<P> result(mp.begin(), mp.end());\\n        sort(begin(result), end(result), comp);\\n        \\n        vector<int> finalResult;\\n        \\n        for(const P& p:result) {\\n            int curr  = p.first;\\n            int times = p.second;\\n            while(times--)\\n                finalResult.push_back(curr);\\n        }\\n        \\n        \\n        return finalResult;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203083,
                "title": "max-heap-c-4ms",
                "content": "```\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        map<int,priority_queue<int>> pq;\\n        for(auto &x: nums)\\n            mp[x]++;\\n        for(auto &x : mp)\\n            pq[x.second].push(x.first);\\n        vector<int> v;\\n        for( auto &x: pq){\\n            int a = x.first;\\n            while(!x.second.empty()){\\n                while(a--)\\n                v.push_back(x.second.top());\\n                a = x.first;\\n                x.second.pop();\\n            }\\n        }\\n        return v;\\n               \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        map<int,priority_queue<int>> pq;\\n        for(auto &x: nums)\\n            mp[x]++;\\n        for(auto &x : mp)\\n            pq[x.second].push(x.first);\\n        vector<int> v;\\n        for( auto &x: pq){\\n            int a = x.first;\\n            while(!x.second.empty()){\\n                while(a--)\\n                v.push_back(x.second.top());\\n                a = x.first;\\n                x.second.pop();\\n            }\\n        }\\n        return v;\\n               \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1092260,
                "title": "four-golang-solutions-with-explanation-and-images",
                "content": "The main idea of the first two solutions is to add all the numbers to a matrix of lengths `[len(nums)][2]` and then sort each frequency of numbers by the max frequency. Suppose two values have the same frequency sort them by the value in descending order. After they are sorted, add all the values back to `nums` and return `nums`.\\n\\n**This is the sort:**\\n\\n```\\nfor i := 1; i < len(arr); i++ {\\n    if i >= 1 && ((arr[i-1][0] > arr[i][0]) || \\n    (arr[i-1][0] == arr[i][0] && arr[i-1][1] < arr[i][1])) {\\n        arr[i], arr[i-1] = arr[i-1], arr[i]\\n        i -= 2\\n    }\\n}\\n```\\n\\nThe idea of it is to start at the second item (first if 0 indexed) and then check whether the frequency of the number before the current is greater than the frequency of the current number. This is show like this in the code: `((arr[i-1][0] > arr[i][0])`. Or it checks whether the frequency is the same and whether the current number is greater than the number before the current number, this is show in the code as this: `arr[i-1][0] == arr[i][0] && arr[i-1][1] < arr[i][1]`. If either of these things is true, then switch the current and number before the current element and subtracts `2` from `i`. We subtract `2` from `i` to move back if we have to switch the next current and number before the current numbers. And we subtract `2`, not `1` because the loops `i++` cancel out one of the subtracts. Since we have an `i -= 2`, we have to check whether `i >= 1` because if we don\\'t and `i == 0`, we would have an out-of-bounds exception.\\n\\nIf you dont understand the explaination look at these images:\\n\\n![image](https://assets.leetcode.com/users/images/e0b432c2-5e05-42c8-951a-d67656b5db84_1614805285.342058.png)\\n![image](https://assets.leetcode.com/users/images/5bdfb469-9333-4f88-a75d-c4053c0ce778_1614805285.3951283.png)\\n![image](https://assets.leetcode.com/users/images/56115be1-93b3-4a63-85dc-8fd07f852d06_1614805285.5365767.png)\\n\\n\\n\\nThe second code has better space complexity because in the first solution we use a `map` of size `len(nums)` and an `array` of size `[len(nums)][2]`. In the second solution we just use an `array` of size `[len(nums)][2]`.\\n\\n\\n\\n**Code One:**\\n\\n``` go\\nfunc frequencySort(nums []int) []int {\\n    m := make(map[int]int)\\n    arr := [][]int{}\\n    counter := 0\\n\\n    for _, num := range nums {\\n        m[num]++\\n    }\\n    for i, i2 := range m {\\n        arr = append(arr, []int{i2, i})\\n    }\\n\\n    for i := 1; i < len(arr); i++ {\\n        if i >= 1 && ((arr[i-1][0] > arr[i][0]) || \\n        (arr[i-1][0] == arr[i][0] && arr[i-1][1] < arr[i][1])) {\\n            arr[i], arr[i-1] = arr[i-1], arr[i]\\n            i -= 2\\n        }\\n    }\\n\\n    for i := 0; i < len(arr); i++ {\\n        for j := 0; j < arr[i][0]; j++ {\\n            nums[counter] = arr[i][1]\\n            counter++\\n        }\\n    }\\n\\n    return nums\\n}\\n```\\n\\n**Code Two:**\\n\\n``` go\\nfunc frequencySort(nums []int) []int {\\n    arr := [][]int{}\\n    counter := 0\\n\\n    for _, num := range nums {\\n        contains := false\\n\\n        for _, ints := range arr {\\n            if ints[1] == num {\\n                ints[0]++\\n                contains = true\\n                break\\n            }\\n        }\\n\\n        if !contains {\\n            arr = append(arr, []int{1, num})\\n        }\\n    }\\n\\n    for i := 1; i < len(arr); i++ {\\n        if i >= 1 && ((arr[i-1][0] > arr[i][0]) ||\\n        (arr[i-1][0] == arr[i][0] && arr[i-1][1] < arr[i][1])) {\\n            arr[i], arr[i-1] = arr[i-1], arr[i]\\n            i -= 2\\n        }\\n    }\\n\\n    for i := 0; i < len(arr); i++ {\\n        for j := 0; j < arr[i][0]; j++ {\\n            nums[counter] = arr[i][1]\\n            counter++\\n        }\\n    }\\n\\n    return nums\\n}\\n```\\n\\nThe idea of the third and fourth solutions are pretty similar to each other. The main difference is that in the third solution we use `sort.Slice`, while in the fourth solution we use a heap.\\n\\n\\n``` go\\nfunc frequencySort(nums []int) []int {\\n    m := make( map[int] int ) // map[val] index in arr\\n    arr := [][]int{}\\n    res := []int{}\\n    \\n    for _, num := range nums {\\n        if _, ok := m[num]; !ok {\\n            arr = append(arr, []int{})\\n            m[num] = len(arr) - 1\\n        }\\n        arr[m[num]] = append(arr[m[num]], num)\\n    }\\n    \\n    sort.Slice(arr, func(i, j int) bool {\\n        if len(arr[i]) == len(arr[j]) { return arr[i][0] > arr[j][0] }\\n        return len(arr[i]) < len(arr[j])\\n    })\\n    \\n    for _, a := range arr {\\n        res = append(res, a...)\\n    }\\n    \\n    return res\\n}\\n```\\n\\n``` go\\nfunc frequencySort(nums []int) []int {\\n    m := make( map[int] []int )\\n    h := &IntHeap{}\\n    res := []int{}\\n    for _, num := range nums {\\n        m[num] = append(m[num], num)\\n    }\\n    \\n    for _, b := range m {\\n        heap.Push(h, b)\\n    }\\n    \\n    for h.Len() > 0 {\\n        res = append(res, heap.Pop(h).([]int)...)\\n    }\\n    \\n    return res\\n}\\n\\ntype IntHeap [][]int\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { \\n    if len(h[i]) == len(h[j]) {\\n        return h[i][0] > h[j][0]\\n    }\\n    return len(h[i]) < len(h[j]) \\n}\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.([]int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfor i := 1; i < len(arr); i++ {\\n    if i >= 1 && ((arr[i-1][0] > arr[i][0]) || \\n    (arr[i-1][0] == arr[i][0] && arr[i-1][1] < arr[i][1])) {\\n        arr[i], arr[i-1] = arr[i-1], arr[i]\\n        i -= 2\\n    }\\n}\\n```\n``` go\\nfunc frequencySort(nums []int) []int {\\n    m := make(map[int]int)\\n    arr := [][]int{}\\n    counter := 0\\n\\n    for _, num := range nums {\\n        m[num]++\\n    }\\n    for i, i2 := range m {\\n        arr = append(arr, []int{i2, i})\\n    }\\n\\n    for i := 1; i < len(arr); i++ {\\n        if i >= 1 && ((arr[i-1][0] > arr[i][0]) || \\n        (arr[i-1][0] == arr[i][0] && arr[i-1][1] < arr[i][1])) {\\n            arr[i], arr[i-1] = arr[i-1], arr[i]\\n            i -= 2\\n        }\\n    }\\n\\n    for i := 0; i < len(arr); i++ {\\n        for j := 0; j < arr[i][0]; j++ {\\n            nums[counter] = arr[i][1]\\n            counter++\\n        }\\n    }\\n\\n    return nums\\n}\\n```\n``` go\\nfunc frequencySort(nums []int) []int {\\n    arr := [][]int{}\\n    counter := 0\\n\\n    for _, num := range nums {\\n        contains := false\\n\\n        for _, ints := range arr {\\n            if ints[1] == num {\\n                ints[0]++\\n                contains = true\\n                break\\n            }\\n        }\\n\\n        if !contains {\\n            arr = append(arr, []int{1, num})\\n        }\\n    }\\n\\n    for i := 1; i < len(arr); i++ {\\n        if i >= 1 && ((arr[i-1][0] > arr[i][0]) ||\\n        (arr[i-1][0] == arr[i][0] && arr[i-1][1] < arr[i][1])) {\\n            arr[i], arr[i-1] = arr[i-1], arr[i]\\n            i -= 2\\n        }\\n    }\\n\\n    for i := 0; i < len(arr); i++ {\\n        for j := 0; j < arr[i][0]; j++ {\\n            nums[counter] = arr[i][1]\\n            counter++\\n        }\\n    }\\n\\n    return nums\\n}\\n```\n``` go\\nfunc frequencySort(nums []int) []int {\\n    m := make( map[int] int ) // map[val] index in arr\\n    arr := [][]int{}\\n    res := []int{}\\n    \\n    for _, num := range nums {\\n        if _, ok := m[num]; !ok {\\n            arr = append(arr, []int{})\\n            m[num] = len(arr) - 1\\n        }\\n        arr[m[num]] = append(arr[m[num]], num)\\n    }\\n    \\n    sort.Slice(arr, func(i, j int) bool {\\n        if len(arr[i]) == len(arr[j]) { return arr[i][0] > arr[j][0] }\\n        return len(arr[i]) < len(arr[j])\\n    })\\n    \\n    for _, a := range arr {\\n        res = append(res, a...)\\n    }\\n    \\n    return res\\n}\\n```\n``` go\\nfunc frequencySort(nums []int) []int {\\n    m := make( map[int] []int )\\n    h := &IntHeap{}\\n    res := []int{}\\n    for _, num := range nums {\\n        m[num] = append(m[num], num)\\n    }\\n    \\n    for _, b := range m {\\n        heap.Push(h, b)\\n    }\\n    \\n    for h.Len() > 0 {\\n        res = append(res, heap.Pop(h).([]int)...)\\n    }\\n    \\n    return res\\n}\\n\\ntype IntHeap [][]int\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { \\n    if len(h[i]) == len(h[j]) {\\n        return h[i][0] > h[j][0]\\n    }\\n    return len(h[i]) < len(h[j]) \\n}\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.([]int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1089981,
                "title": "95-faster-86-less-space-in-python",
                "content": "1. First find the frequencies using a dictionary\\n2. Make the key as negative since we need to reverse sort incase of conflict.\\n3. Append in list based on the frequencies while reversing the sign.\\n```\\nclass Solution(object):\\n    def frequencySort(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        dic = {}\\n        for item in nums:\\n            if item in dic:\\n                dic[item]+=1\\n            else:\\n                dic[item]=1\\n        a = [list(i) for i in zip([-1*b for b in dic.keys()], dic.values())]\\n        a.sort(key = lambda x: (x[1],x[0]))\\n        res = []\\n        for x in a:\\n            i,j = -1*x[0], x[1]\\n            for y in range(x[1]):\\n                res.append(i)\\n        return res\\n```\\nSame operation can be done using libraries, with equivalent time complexity(95%): (Thanks to @kingofratz)\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        c = Counter(nums)\\n        return sorted(nums, key=lambda x:(c[x], -x))\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def frequencySort(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        dic = {}\\n        for item in nums:\\n            if item in dic:\\n                dic[item]+=1\\n            else:\\n                dic[item]=1\\n        a = [list(i) for i in zip([-1*b for b in dic.keys()], dic.values())]\\n        a.sort(key = lambda x: (x[1],x[0]))\\n        res = []\\n        for x in a:\\n            i,j = -1*x[0], x[1]\\n            for y in range(x[1]):\\n                res.append(i)\\n        return res\\n```\n```\\nfrom collections import Counter\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        c = Counter(nums)\\n        return sorted(nums, key=lambda x:(c[x], -x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043713,
                "title": "c-simple-linq",
                "content": "```\\npublic class Solution {\\n    public int[] FrequencySort(int[] nums) {\\n        return nums.GroupBy(key => key, _ => _)\\n                .OrderBy(_ => _.Count())\\n                .ThenByDescending(_ => _.Key)\\n                .SelectMany(_ => _)\\n                .ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] FrequencySort(int[] nums) {\\n        return nums.GroupBy(key => key, _ => _)\\n                .OrderBy(_ => _.Count())\\n                .ThenByDescending(_ => _.Key)\\n                .SelectMany(_ => _)\\n                .ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014188,
                "title": "c-code-beats-100-soln-and-space-97",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int> &a,pair<int,int> &b){\\n        if(a.first==b.first){\\n            return a.second>b.second;\\n        }\\n       else  return a.first<b.first; \\n        // compare intially in ascending order on pair\\'s first value...if pairs first value is equal then return that pair whose second value is greater as mentioned in if condition above\\n    }\\n    vector<int> frequencySort(vector<int>& nums) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        \\n        pair<int,int> p;\\n        vector<pair<int,int>> v;\\n        for(auto i=m.begin();i!=m.end();i++){\\n            p.first = i->second;\\n            p.second = i->first;\\n            v.push_back(p);\\n        }\\n        \\n        nums.clear();\\n        sort(v.begin(),v.end(),comp);\\n        int n = v.size();\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<v[i].first;j++){\\n                nums.push_back(v[i].second);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int> &a,pair<int,int> &b){\\n        if(a.first==b.first){\\n            return a.second>b.second;\\n        }\\n       else  return a.first<b.first; \\n        // compare intially in ascending order on pair\\'s first value...if pairs first value is equal then return that pair whose second value is greater as mentioned in if condition above\\n    }\\n    vector<int> frequencySort(vector<int>& nums) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        \\n        pair<int,int> p;\\n        vector<pair<int,int>> v;\\n        for(auto i=m.begin();i!=m.end();i++){\\n            p.first = i->second;\\n            p.second = i->first;\\n            v.push_back(p);\\n        }\\n        \\n        nums.clear();\\n        sort(v.begin(),v.end(),comp);\\n        int n = v.size();\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<v[i].first;j++){\\n                nums.push_back(v[i].second);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1005047,
                "title": "solution-in-c-yeah-u-read-correctly",
                "content": "\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint cmpfunc (const void * a, const void * b) {\\n   return ( *(int*)a - *(int*)b );\\n}\\n\\n\\nint* frequencySort(int* nums, int numsSize, int* returnSize){\\n\\n    int index[201]={0};\\n    int value[201]={0};\\n    int *arr;\\n    int temp1=0;\\n    int temp2=0;\\n    int temp=1000;\\n    int k=-1;\\n    int n=0;\\n    arr=(int*)malloc(numsSize*sizeof(int));\\n    int i=0;\\n    qsort(nums,numsSize,sizeof(int),cmpfunc);\\n   \\n    for(int i=0;i<numsSize;i++)\\n    {   \\n        if(temp==nums[i])\\n        {\\n        index[k]=nums[i];\\n        value[k]++;\\n        }\\n        else{\\n            temp=nums[i];\\n            k++;\\n            index[k]=nums[i];\\n            value[k]++;\\n        }\\n    }\\n    for(int m=0;m<=k;m++)\\n        printf(\" %d %d \",index[m],value[m]);\\n    \\n   \\n    for(int i=0;i<=k;i++)\\n    {\\n        for(int j=0;j<=k;j++)\\n        {\\n            if(value[j]<value[j+1])\\n            {\\n                temp1=value[j];\\n                temp2=index[j];\\n                value[j]=value[j+1];\\n                index[j]=index[j+1];\\n                value[j+1]=temp1;\\n                index[j+1]=temp2;\\n            }\\n        }\\n    }\\n    \\n    for(int i=k;i>=0;i--)\\n    {\\n        temp1=value[i];\\n        while(temp1)\\n        {\\n            arr[n]=index[i];\\n            n++;\\n            temp1--;\\n        }\\n        \\n    }\\n    \\n    *returnSize=numsSize;\\n    \\n    \\n    \\n    \\n    return arr;\\n}",
                "solutionTags": [],
                "code": "\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint cmpfunc (const void * a, const void * b) {\\n   return ( *(int*)a - *(int*)b );\\n}\\n\\n\\nint* frequencySort(int* nums, int numsSize, int* returnSize){\\n\\n    int index[201]={0};\\n    int value[201]={0};\\n    int *arr;\\n    int temp1=0;\\n    int temp2=0;\\n    int temp=1000;\\n    int k=-1;\\n    int n=0;\\n    arr=(int*)malloc(numsSize*sizeof(int));\\n    int i=0;\\n    qsort(nums,numsSize,sizeof(int),cmpfunc);\\n   \\n    for(int i=0;i<numsSize;i++)\\n    {   \\n        if(temp==nums[i])\\n        {\\n        index[k]=nums[i];\\n        value[k]++;\\n        }\\n        else{\\n            temp=nums[i];\\n            k++;\\n            index[k]=nums[i];\\n            value[k]++;\\n        }\\n    }\\n    for(int m=0;m<=k;m++)\\n        printf(\" %d %d \",index[m],value[m]);\\n    \\n   \\n    for(int i=0;i<=k;i++)\\n    {\\n        for(int j=0;j<=k;j++)\\n        {\\n            if(value[j]<value[j+1])\\n            {\\n                temp1=value[j];\\n                temp2=index[j];\\n                value[j]=value[j+1];\\n                index[j]=index[j+1];\\n                value[j+1]=temp1;\\n                index[j+1]=temp2;\\n            }\\n        }\\n    }\\n    \\n    for(int i=k;i>=0;i--)\\n    {\\n        temp1=value[i];\\n        while(temp1)\\n        {\\n            arr[n]=index[i];\\n            n++;\\n            temp1--;\\n        }\\n        \\n    }\\n    \\n    *returnSize=numsSize;\\n    \\n    \\n    \\n    \\n    return arr;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 963858,
                "title": "c-sort-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int> &a,pair<int,int> &b)\\n\\t{\\n        if(a.second==b.second)\\n            return a.first>b.first;\\n\\t    return a.second<b.second;\\n\\t}\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int,int> map{};\\n        for(auto n:nums)\\n            map[n]++;\\n        vector<pair<int,int>> vec;\\n        for(auto p: map)\\n            vec.push_back(p);\\n        sort(vec.begin(), vec.end(), comp);\\n        \\n        vector<int> ans{};\\n        for(auto p: vec){     \\n            while(p.second--)\\n\\t\\t\\t\\tans.push_back(p.first);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    static bool comp(pair<int,int> &a,pair<int,int> &b)\\n\\t{\\n        if(a.second==b.second)\\n            return a.first>b.first;\\n\\t    return a.second<b.second;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 955412,
                "title": "python-solution-using-lamda",
                "content": "First create a dictionary maps from the value to its frequency.\\nUse lambda function to sort nums, the second element in the tuple is -x because we have to sort in decreasingly if encounter same frequency.\\n```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        d={}\\n        for i in range(len(nums)):\\n            if nums[i] in d:\\n                d[nums[i]] +=1\\n            else:\\n                d[nums[i]] = 1\\n        nums.sort(key= lambda x:(d[x],-x))\\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        d={}\\n        for i in range(len(nums)):\\n            if nums[i] in d:\\n                d[nums[i]] +=1\\n            else:\\n                d[nums[i]] = 1\\n        nums.sort(key= lambda x:(d[x],-x))\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925136,
                "title": "java-simple-solution-using-priority-queue-beats-97",
                "content": "First use a map to track integer and their frequency. Then feed the pairs to a PriorityQueue. Then it\\'s a simple operation to reconstruct the sorted array.\\n\\n```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i : nums) \\n            map.put(i, map.getOrDefault(i, 0)+1);\\n        \\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<Map.Entry<Integer, Integer>>\\n            (new Comparator<Map.Entry<Integer, Integer>>() {\\n                public int compare(Map.Entry<Integer, Integer> e1, Map.Entry<Integer, Integer> e2) {\\n                    return e1.getValue() != e2.getValue() ? e1.getValue()-e2.getValue() : e2.getKey()-e1.getKey();\\n                }\\n            });\\n        \\n        for (Map.Entry<Integer, Integer> e : map.entrySet()) {\\n            pq.offer(e);\\n        }\\n        \\n        int[] arr = new int[nums.length];\\n        int j = 0;\\n        while (!pq.isEmpty()) {\\n            Map.Entry<Integer, Integer> e = pq.poll();\\n            for (int i = 0; i < e.getValue(); i++) {\\n                arr[j++] = e.getKey();\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i : nums) \\n            map.put(i, map.getOrDefault(i, 0)+1);\\n        \\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<Map.Entry<Integer, Integer>>\\n            (new Comparator<Map.Entry<Integer, Integer>>() {\\n                public int compare(Map.Entry<Integer, Integer> e1, Map.Entry<Integer, Integer> e2) {\\n                    return e1.getValue() != e2.getValue() ? e1.getValue()-e2.getValue() : e2.getKey()-e1.getKey();\\n                }\\n            });\\n        \\n        for (Map.Entry<Integer, Integer> e : map.entrySet()) {\\n            pq.offer(e);\\n        }\\n        \\n        int[] arr = new int[nums.length];\\n        int j = 0;\\n        while (!pq.isEmpty()) {\\n            Map.Entry<Integer, Integer> e = pq.poll();\\n            for (int i = 0; i < e.getValue(); i++) {\\n                arr[j++] = e.getKey();\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919709,
                "title": "swift-two-lines-solution-explained",
                "content": "Explained:\\n```\\nclass Solution {\\n\\t// e.g. nums is [2, 3, 1, 3, 2]\\n    func frequencySort(_ nums: [Int]) -> [Int] {\\n        // dict is frequency of values in nums, e.g. [3: 2, 2: 2, 1: 1]\\n        var dict = [Int: Int]()\\n        for num in nums {\\n            dict[num, default: Int(0)] += 1\\n        }\\n        // let\\'s sort dict by rule (count a < count b) || (count a == count b && b > a ) and put result into arr\\n        // e.g. [(key: 1, value: 1), (key: 3, value: 2), (key: 2, value: 2)]\\n        var arr = dict.sorted(by: { $0.1 < $1.1 || $0.1 == $1.1 && $0.0 > $1.0 })\\n\\t\\t// let\\'s calc result\\n\\t\\tvar result = [Int]()\\n        for item in arr {\\n            result += [Int](repeating: item.key, count: item.value)\\n        }\\n        // result is [1, 3, 3, 2, 2]\\n        return result\\n    }\\n}\\n```\\nTwo-lines solution:\\n```\\nclass Solution {\\n    func frequencySort(_ nums: [Int]) -> [Int] {\\n        let dict = nums.reduce(into: [Int: Int](), { $0[$1, default: Int(0)] += 1 })\\n        return dict.sorted(by: { $0.1 < $1.1 || $0.1 == $1.1 && $0.0 > $1.0 }).reduce(into: [Int](), { $0 += [Int](repeating: $1.0, count: $1.1) })\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\t// e.g. nums is [2, 3, 1, 3, 2]\\n    func frequencySort(_ nums: [Int]) -> [Int] {\\n        // dict is frequency of values in nums, e.g. [3: 2, 2: 2, 1: 1]\\n        var dict = [Int: Int]()\\n        for num in nums {\\n            dict[num, default: Int(0)] += 1\\n        }\\n        // let\\'s sort dict by rule (count a < count b) || (count a == count b && b > a ) and put result into arr\\n        // e.g. [(key: 1, value: 1), (key: 3, value: 2), (key: 2, value: 2)]\\n        var arr = dict.sorted(by: { $0.1 < $1.1 || $0.1 == $1.1 && $0.0 > $1.0 })\\n\\t\\t// let\\'s calc result\\n\\t\\tvar result = [Int]()\\n        for item in arr {\\n            result += [Int](repeating: item.key, count: item.value)\\n        }\\n        // result is [1, 3, 3, 2, 2]\\n        return result\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func frequencySort(_ nums: [Int]) -> [Int] {\\n        let dict = nums.reduce(into: [Int: Int](), { $0[$1, default: Int(0)] += 1 })\\n        return dict.sorted(by: { $0.1 < $1.1 || $0.1 == $1.1 && $0.0 > $1.0 }).reduce(into: [Int](), { $0 += [Int](repeating: $1.0, count: $1.1) })\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917824,
                "title": "rust-solution",
                "content": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn frequency_sort(mut nums: Vec<i32>) -> Vec<i32> {\\n        \\n        // Count the frequency of each num\\n        let mut freq: HashMap<i32, u32> = HashMap::new();\\n        for e in &nums {\\n            *freq.entry(*e).or_insert(0) += 1;\\n        }\\n\\n        nums.sort_by(|a,b| freq[a].cmp(&freq[b]).then(b.cmp(a)));\\n        nums        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn frequency_sort(mut nums: Vec<i32>) -> Vec<i32> {\\n        \\n        // Count the frequency of each num\\n        let mut freq: HashMap<i32, u32> = HashMap::new();\\n        for e in &nums {\\n            *freq.entry(*e).or_insert(0) += 1;\\n        }\\n\\n        nums.sort_by(|a,b| freq[a].cmp(&freq[b]).then(b.cmp(a)));\\n        nums        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 917706,
                "title": "clean-python-3-counting-sort-o-n",
                "content": "Counting sort\\nTime: `O(N)`\\nSpace: `O(N)`\\n```\\nimport collections\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        counter = collections.Counter(nums)\\n        buckets = [[0] * 201 for _ in range((len(nums) + 1))]\\n        for num, count in counter.items():\\n            buckets[count][num] = 1\\n        result = []\\n        for feq, bucket in enumerate(buckets):\\n            for i in reversed(range(-100, 101)):\\n                if bucket[i] > 0:\\n                    result += [i] * feq\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        counter = collections.Counter(nums)\\n        buckets = [[0] * 201 for _ in range((len(nums) + 1))]\\n        for num, count in counter.items():\\n            buckets[count][num] = 1\\n        result = []\\n        for feq, bucket in enumerate(buckets):\\n            for i in reversed(range(-100, 101)):\\n                if bucket[i] > 0:\\n                    result += [i] * feq\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622705,
                "title": "simple-brute-force-approach-in-java",
                "content": "# Approach\\nSo, firstly I have copied all the array elements and putted in the list, then inside the new array arr[] i have added frequency of all list elements, then according to the frequency array i have sorted the original array nums[] as well as the frequency array, also i have added one more condition for equal frequency in that i have arranged the elements in decreasing order by swapping.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n# Request\\nPlease upvote :)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        \\n        int[] arr = new int[nums.length];\\n\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int val: nums){\\n\\n            list.add(val);\\n        }\\n\\n        for (int i=0; i< list.size(); ++i){\\n\\n            arr[i] = Collections.frequency(list, list.get(i));\\n        }\\n\\n        for (int i=0; i<arr.length; ++i){\\n\\n            for (int j=i+1; j< arr.length; ++j){\\n\\n                if (arr[i]>arr[j]){\\n\\n                    int temp = nums[i];\\n                    nums[i] = nums[j];\\n                    nums[j] = temp;\\n\\n                    int temp1 = arr[i];\\n                    arr[i] = arr[j];\\n                    arr[j] = temp1;\\n\\n\\n                }\\n                else if(arr[i] == arr[j]){\\n\\n                    if(nums[i]<nums[j]){\\n\\n                        int temp = nums[i];\\n                        nums[i] = nums[j];\\n                        nums[j] = temp;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        \\n        int[] arr = new int[nums.length];\\n\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int val: nums){\\n\\n            list.add(val);\\n        }\\n\\n        for (int i=0; i< list.size(); ++i){\\n\\n            arr[i] = Collections.frequency(list, list.get(i));\\n        }\\n\\n        for (int i=0; i<arr.length; ++i){\\n\\n            for (int j=i+1; j< arr.length; ++j){\\n\\n                if (arr[i]>arr[j]){\\n\\n                    int temp = nums[i];\\n                    nums[i] = nums[j];\\n                    nums[j] = temp;\\n\\n                    int temp1 = arr[i];\\n                    arr[i] = arr[j];\\n                    arr[j] = temp1;\\n\\n\\n                }\\n                else if(arr[i] == arr[j]){\\n\\n                    if(nums[i]<nums[j]){\\n\\n                        int temp = nums[i];\\n                        nums[i] = nums[j];\\n                        nums[j] = temp;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462633,
                "title": "fast-and-understanable-way-with-java-beats-95",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> tempList = new TreeMap<>();// to counting each number\\n        Map<Integer, ArrayList<Integer>> countList = new TreeMap<>();//Counting numbers in arrayList\\n        // Counting and adding\\n        for(int a: nums){\\n           if(tempList.containsKey(a)) tempList.put(a, tempList.get(a)+1);\\n           else tempList.put(a,1);\\n        } \\n        // numbers with the same numbers adding same array\\n        for(Map.Entry<Integer,Integer> entry: tempList.entrySet()){\\n            int val = entry.getValue(); int key = entry.getKey();\\n            if(!countList.containsKey(val)) countList.put(val, new ArrayList<Integer>());\\n            countList.get(val).add(key);\\n        }\\n\\n        int index = 0;\\n        for(Map.Entry<Integer,ArrayList<Integer>> entry: countList.entrySet()){\\n            int val = entry.getKey(); ArrayList<Integer> array = entry.getValue();\\n            Collections.sort(array);// Sort each Array\\n            for(int a = array.size()-1; a>-1; a--){\\n                int value = array.get(a);\\n                for(int b = 0; b < val; b++){\\n                    nums[index] = value;\\n                    index++;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> tempList = new TreeMap<>();// to counting each number\\n        Map<Integer, ArrayList<Integer>> countList = new TreeMap<>();//Counting numbers in arrayList\\n        // Counting and adding\\n        for(int a: nums){\\n           if(tempList.containsKey(a)) tempList.put(a, tempList.get(a)+1);\\n           else tempList.put(a,1);\\n        } \\n        // numbers with the same numbers adding same array\\n        for(Map.Entry<Integer,Integer> entry: tempList.entrySet()){\\n            int val = entry.getValue(); int key = entry.getKey();\\n            if(!countList.containsKey(val)) countList.put(val, new ArrayList<Integer>());\\n            countList.get(val).add(key);\\n        }\\n\\n        int index = 0;\\n        for(Map.Entry<Integer,ArrayList<Integer>> entry: countList.entrySet()){\\n            int val = entry.getKey(); ArrayList<Integer> array = entry.getValue();\\n            Collections.sort(array);// Sort each Array\\n            for(int a = array.size()-1; a>-1; a--){\\n                int value = array.get(a);\\n                for(int b = 0; b < val; b++){\\n                    nums[index] = value;\\n                    index++;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254794,
                "title": "easiest-solution-using-map-heap-and-comparator-operator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define pii pair<int, int>\\n\\nclass MyComp\\n{\\npublic:\\n    bool operator()(pii const &p1, pii p2)\\n    {\\n        if (p1.first == p2.first)\\n        {\\n            return p1.second <p2.second;\\n        }\\n        return p1.first >p2.first;\\n    }\\n};\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> frequencySort(vector<int> &nums)\\n    {\\n        vector<int> ans;\\n        priority_queue<pii, vector<pii>, MyComp> pq;\\n\\n        unordered_map<int, int> mp;\\n        for (int n : nums)\\n            mp[n]++;\\n\\n        for (auto it : mp)\\n            pq.push({it.second, it.first});\\n\\n        while (not pq.empty())\\n        {\\n            int freq = pq.top().first;\\n            int n = pq.top().second;\\n\\n            pq.pop();\\n            while (freq--)\\n            {\\n                ans.push_back(n);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define pii pair<int, int>\\n\\nclass MyComp\\n{\\npublic:\\n    bool operator()(pii const &p1, pii p2)\\n    {\\n        if (p1.first == p2.first)\\n        {\\n            return p1.second <p2.second;\\n        }\\n        return p1.first >p2.first;\\n    }\\n};\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> frequencySort(vector<int> &nums)\\n    {\\n        vector<int> ans;\\n        priority_queue<pii, vector<pii>, MyComp> pq;\\n\\n        unordered_map<int, int> mp;\\n        for (int n : nums)\\n            mp[n]++;\\n\\n        for (auto it : mp)\\n            pq.push({it.second, it.first});\\n\\n        while (not pq.empty())\\n        {\\n            int freq = pq.top().first;\\n            int n = pq.top().second;\\n\\n            pq.pop();\\n            while (freq--)\\n            {\\n                ans.push_back(n);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247476,
                "title": "beginner-friendly-using-maps",
                "content": "# Code\\n```\\nfunction frequencySort(nums: number[]): number[] {\\n    let map = new Map();\\n    let res = [];\\n    nums = nums.sort((a, b) => b - a);\\n    for(let i = 0; i < nums.length; i++){\\n        if(!map.has(nums[i])){\\n            map.set(nums[i], 1);\\n        } else {\\n            let count = map.get(nums[i]);\\n            map.set(nums[i], count + 1);\\n        }\\n    }\\n    \\n    new Map([...map.entries()].sort((a, b) => a[1] - b[1])).forEach((k, v) => {\\n        let x = Array(k).fill(v)\\n        res.push(x);\\n    });\\n\\n    return res.flatMap(num => num);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction frequencySort(nums: number[]): number[] {\\n    let map = new Map();\\n    let res = [];\\n    nums = nums.sort((a, b) => b - a);\\n    for(let i = 0; i < nums.length; i++){\\n        if(!map.has(nums[i])){\\n            map.set(nums[i], 1);\\n        } else {\\n            let count = map.get(nums[i]);\\n            map.set(nums[i], count + 1);\\n        }\\n    }\\n    \\n    new Map([...map.entries()].sort((a, b) => a[1] - b[1])).forEach((k, v) => {\\n        let x = Array(k).fill(v)\\n        res.push(x);\\n    });\\n\\n    return res.flatMap(num => num);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2949982,
                "title": "easiest-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(auto i:nums) mp[i]++;\\n        vector<pair<int,int>> temp;\\n        for(auto i:mp) temp.push_back({i.second,i.first});\\n        sort(temp.begin(),temp.end(),[](pair<int,int> p1,pair<int,int> p2){\\n            if(p1.first<p2.first) return true;\\n            else if(p1.first==p2.first) return p1.second>p2.second;\\n            return false;\\n        });\\n        vector<int> ans;\\n        for(auto i:temp){\\n            while(i.first>0){\\n                ans.push_back(i.second);\\n                i.first--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(auto i:nums) mp[i]++;\\n        vector<pair<int,int>> temp;\\n        for(auto i:mp) temp.push_back({i.second,i.first});\\n        sort(temp.begin(),temp.end(),[](pair<int,int> p1,pair<int,int> p2){\\n            if(p1.first<p2.first) return true;\\n            else if(p1.first==p2.first) return p1.second>p2.second;\\n            return false;\\n        });\\n        vector<int> ans;\\n        for(auto i:temp){\\n            while(i.first>0){\\n                ans.push_back(i.second);\\n                i.first--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910978,
                "title": "92-99-faster-python-solution-and-less-code",
                "content": "![Screenshot 2022-12-14 at 17.03.29.png](https://assets.leetcode.com/users/images/3a5ee447-6a02-47d8-a06a-250576af3855_1671019421.0084846.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        a = Counter(nums)\\n        an = sorted(sorted([[i, a[i]] for i in a], reverse=True), key=lambda j: j[1])\\n        ans = []\\n        for i in an:\\n            ans += [i[0]]*i[1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        a = Counter(nums)\\n        an = sorted(sorted([[i, a[i]] for i in a], reverse=True), key=lambda j: j[1])\\n        ans = []\\n        for i in an:\\n            ans += [i[0]]*i[1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872288,
                "title": "step-by-step-procedure-using-min-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom heapq import *\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        if len(nums)<=2:\\n            nums.sort(reverse=True)\\n            return nums\\n        dic=collections.Counter(nums)\\n        ans=[]\\n        res=[]\\n        h={}\\n        for i,j in dic.items():\\n            if j in h:\\n                h[j].append(i)\\n            else:\\n                h[j]=[i]\\n        l=[]\\n        for i,j in h.items():\\n            if len(h[i])>1:\\n                ans.extend([i,(i*j)])            \\n        \\n        if len(ans)>=1:\\n            for i in range(1,len(ans),2):\\n                ans[i].sort(reverse=True)\\n                l.extend([ans[i-1],ans[i]])\\n        heap=[]\\n        m=[]\\n        for i,j in dic.items():\\n            if j not in l:\\n                l.append([j,i])\\n        d=0\\n        while d<len(l):\\n            if type(l[d])==int:\\n                heappush(heap,[l[d],l[d+1]])\\n                d+=2\\n            else:\\n                heappush(heap,[l[d][0],l[d][1]])\\n                d+=1\\n        final=[]\\n        while heap:\\n            a=heappop(heap)\\n            if type(a[1])!=list and a[1]>=0:\\n                while a[0]!=0:\\n                    final.append(str(a[1]))\\n                    a[0]-=1\\n            elif type(a[1])!=list and a[1]<0:\\n                final.append([a[1]]*a[0])\\n            else:\\n                final.append(a[1])\\n        q=[]\\n        for i in final:\\n            if type(i)==int:\\n                q.append(i)\\n            elif type(i)==str:\\n                q.append(int(i))\\n            else:\\n                q.extend(i)\\n        return q\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import *\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        if len(nums)<=2:\\n            nums.sort(reverse=True)\\n            return nums\\n        dic=collections.Counter(nums)\\n        ans=[]\\n        res=[]\\n        h={}\\n        for i,j in dic.items():\\n            if j in h:\\n                h[j].append(i)\\n            else:\\n                h[j]=[i]\\n        l=[]\\n        for i,j in h.items():\\n            if len(h[i])>1:\\n                ans.extend([i,(i*j)])            \\n        \\n        if len(ans)>=1:\\n            for i in range(1,len(ans),2):\\n                ans[i].sort(reverse=True)\\n                l.extend([ans[i-1],ans[i]])\\n        heap=[]\\n        m=[]\\n        for i,j in dic.items():\\n            if j not in l:\\n                l.append([j,i])\\n        d=0\\n        while d<len(l):\\n            if type(l[d])==int:\\n                heappush(heap,[l[d],l[d+1]])\\n                d+=2\\n            else:\\n                heappush(heap,[l[d][0],l[d][1]])\\n                d+=1\\n        final=[]\\n        while heap:\\n            a=heappop(heap)\\n            if type(a[1])!=list and a[1]>=0:\\n                while a[0]!=0:\\n                    final.append(str(a[1]))\\n                    a[0]-=1\\n            elif type(a[1])!=list and a[1]<0:\\n                final.append([a[1]]*a[0])\\n            else:\\n                final.append(a[1])\\n        q=[]\\n        for i in final:\\n            if type(i)==int:\\n                q.append(i)\\n            elif type(i)==str:\\n                q.append(int(i))\\n            else:\\n                q.extend(i)\\n        return q\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795502,
                "title": "c-using-map-and-pair-int-int",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstatic bool comp(pair<int,int>p,pair<int,int>q)\\n      //first column stores frequency i.e duplicates and second column stores value\\n  {//if the duplicates are equal then we will return by greater value first...\\n  if(p.first==q.first)\\n  {\\n  return p.second>q.second;\\n  }\\n      ///else we will return as per frequency.\\n  return p.first<q.first;\\n  }\\n    vector<int> frequencySort(vector<int>& nums)\\n    {\\n        map<int,int> m;\\n        for(auto it:nums)\\n        {\\n            m[it]++;\\n        }\\n        vector<pair<int,int>> v;\\n        for(auto it:m)\\n        {\\n           v.push_back({it.second,it.first});     \\n        }\\n        vector<int> ans;int cnt=0;\\n        sort(v.begin(),v.end(),comp);\\n        for(auto it: v)\\n        {  \\n            cnt=it.first;\\n            while(cnt--)\\n            {\\n                ans.push_back(it.second);\\n            }\\n\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstatic bool comp(pair<int,int>p,pair<int,int>q)\\n      //first column stores frequency i.e duplicates and second column stores value\\n  {//if the duplicates are equal then we will return by greater value first...\\n  if(p.first==q.first)\\n  {\\n  return p.second>q.second;\\n  }\\n      ///else we will return as per frequency.\\n  return p.first<q.first;\\n  }\\n    vector<int> frequencySort(vector<int>& nums)\\n    {\\n        map<int,int> m;\\n        for(auto it:nums)\\n        {\\n            m[it]++;\\n        }\\n        vector<pair<int,int>> v;\\n        for(auto it:m)\\n        {\\n           v.push_back({it.second,it.first});     \\n        }\\n        vector<int> ans;int cnt=0;\\n        sort(v.begin(),v.end(),comp);\\n        for(auto it: v)\\n        {  \\n            cnt=it.first;\\n            while(cnt--)\\n            {\\n                ans.push_back(it.second);\\n            }\\n\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748995,
                "title": "java-solution-using-custom-comparator",
                "content": "```\\nclass CustomCom implements Comparator<Map.Entry<Integer, Integer>>{\\n\\n    public int compare(Map.Entry<Integer, Integer> m1, Map.Entry<Integer, Integer> m2){\\n\\n        if(m1.getValue() == m2.getValue())\\n            return m2.getKey() - m1.getKey();\\n        else\\n            return m1.getValue() - m2.getValue();\\n    }\\n}\\nclass Solution {\\n    public int[] frequencySort(int[] arr) {\\n       HashMap <Integer,Integer> map=new HashMap<>();\\n        for (int i = 0; i < arr.length ; i++) {\\n            map.put(arr[i],map.getOrDefault(arr[i],0)+1 );\\n        }\\n\\n        PriorityQueue <Map.Entry<Integer,Integer>> maxHeap=new PriorityQueue<>(\\n                new CustomCom()\\n        );\\n        maxHeap.addAll(map.entrySet());\\n        ArrayList <Integer> lst=new ArrayList<>();\\n        while (!maxHeap.isEmpty())\\n        {\\n         Map.Entry<Integer,Integer> entry=maxHeap.poll();\\n\\n            for (int i = 0; i <entry.getValue() ; i++) {\\n                lst.add(entry.getKey());\\n            }\\n\\n\\n        }\\n        int arr2[]=new int[arr.length]; \\n        for (int i = 0; i < arr.length ; i++) {\\n            arr2[i]=lst.get(i);\\n        }\\nreturn arr2;\\n       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomCom implements Comparator<Map.Entry<Integer, Integer>>{\\n\\n    public int compare(Map.Entry<Integer, Integer> m1, Map.Entry<Integer, Integer> m2){\\n\\n        if(m1.getValue() == m2.getValue())\\n            return m2.getKey() - m1.getKey();\\n        else\\n            return m1.getValue() - m2.getValue();\\n    }\\n}\\nclass Solution {\\n    public int[] frequencySort(int[] arr) {\\n       HashMap <Integer,Integer> map=new HashMap<>();\\n        for (int i = 0; i < arr.length ; i++) {\\n            map.put(arr[i],map.getOrDefault(arr[i],0)+1 );\\n        }\\n\\n        PriorityQueue <Map.Entry<Integer,Integer>> maxHeap=new PriorityQueue<>(\\n                new CustomCom()\\n        );\\n        maxHeap.addAll(map.entrySet());\\n        ArrayList <Integer> lst=new ArrayList<>();\\n        while (!maxHeap.isEmpty())\\n        {\\n         Map.Entry<Integer,Integer> entry=maxHeap.poll();\\n\\n            for (int i = 0; i <entry.getValue() ; i++) {\\n                lst.add(entry.getKey());\\n            }\\n\\n\\n        }\\n        int arr2[]=new int[arr.length]; \\n        for (int i = 0; i < arr.length ; i++) {\\n            arr2[i]=lst.get(i);\\n        }\\nreturn arr2;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732480,
                "title": "priority-queue-custom-comparator-cpp-stl",
                "content": "```\\n#define pi pair<int,int>\\nclass Solution {\\npublic:\\n    //map with constructor could also be employed (efficient space , as min heap is kinda extra)\\n    vector<int> frequencySort(vector<int>& nums) {\\n       unordered_map<int,int>mp;\\n        for(auto x:nums) mp[x]++;\\n        auto cmp=[&](pi &a,pi&b){\\n            if(a.first==b.first)\\n                return a.second<b.second;\\n            return a.first>b.first;\\n        };\\n        // top would acc to min heap i.e top would be the minimum pair acc to comparator\\n        priority_queue<pi,vector<pi>,decltype(cmp)>pq(cmp);\\n        for(auto p:mp){\\n            pq.push({p.second,p.first});\\n        }\\n        vector<int>ans;\\n        while(!pq.empty()){\\n            int num=pq.top().second;\\n            int f=pq.top().first;pq.pop();\\n            while(f--) ans.push_back(num);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    //map with constructor could also be employed (efficient space , as min heap is kinda extra)\\n    vector<int> frequencySort(vector<int>& nums) {\\n       unordered_map<int,int>mp;\\n        for(auto x:nums) mp[x]++;\\n        auto cmp=[&](pi &a,pi&b){\\n            if(a.first==b.first)\\n                return a.second<b.second;\\n            return a.first>b.first;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2731929,
                "title": "easy-c-solution-using-hashmap-minheap",
                "content": "**PLEASE UPVOTE iF IT HELPS YOU**\\n\\n```\\nclass Solution {\\npublic:\\n    struct cmp{\\n        bool operator()(pair<int,int>&a,pair<int,int>&b){\\n            if(a.first==b.first){\\n                return b.second>a.second;\\n            }\\n            else{\\n                return a.first>b.first;\\n            }\\n        }\\n    };\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        \\n        priority_queue<pair<int,int> , vector<pair<int,int>> , cmp> pq;\\n        for(auto it: nums){\\n            mp[it]++;\\n        }\\n        \\n        for(auto it: mp){\\n            pq.push({it.second,it.first});\\n        }\\n        \\n        nums.clear();\\n        while(!pq.empty()){\\n            int x = pq.top().first;\\n            int y = pq.top().second;\\n            while(x--){\\n                nums.push_back(y);\\n            }\\n            pq.pop();\\n        }\\n     return nums;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct cmp{\\n        bool operator()(pair<int,int>&a,pair<int,int>&b){\\n            if(a.first==b.first){\\n                return b.second>a.second;\\n            }\\n            else{\\n                return a.first>b.first;\\n            }\\n        }\\n    };\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        \\n        priority_queue<pair<int,int> , vector<pair<int,int>> , cmp> pq;\\n        for(auto it: nums){\\n            mp[it]++;\\n        }\\n        \\n        for(auto it: mp){\\n            pq.push({it.second,it.first});\\n        }\\n        \\n        nums.clear();\\n        while(!pq.empty()){\\n            int x = pq.top().first;\\n            int y = pq.top().second;\\n            while(x--){\\n                nums.push_back(y);\\n            }\\n            pq.pop();\\n        }\\n     return nums;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649448,
                "title": "c",
                "content": "```\\n//Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\n//Any suggestions and improvements are always welcome\\n\\nclass Solution {\\npublic:\\n    bool static comp(pair<int,int> a,pair<int,int> b)\\n    {\\n        if(a.second==b.second)\\n        return a>b;   \\n        else\\n        return a.second<b.second;\\n    }\\n    vector<int> frequencySort(vector<int>& nums) {\\n         unordered_map<int,int> mp;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             mp[nums[i]]++;\\n         }\\n         vector<pair<int,int> > vec;\\n         for(auto pr:mp)\\n         {\\n             vec.push_back(pr);\\n         }\\n         sort(vec.begin(),vec.end(),comp);\\n         \\n vector<int> ans;\\n    for(int i=0;i<vec.size();i++)\\n    {\\n     while(vec[i].second>0)\\n     {\\n         ans.push_back(vec[i].first);\\n         vec[i].second--;\\n     }\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\n//Any suggestions and improvements are always welcome\\n\\nclass Solution {\\npublic:\\n    bool static comp(pair<int,int> a,pair<int,int> b)\\n    {\\n        if(a.second==b.second)\\n        return a>b;   \\n        else\\n        return a.second<b.second;\\n    }\\n    vector<int> frequencySort(vector<int>& nums) {\\n         unordered_map<int,int> mp;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             mp[nums[i]]++;\\n         }\\n         vector<pair<int,int> > vec;\\n         for(auto pr:mp)\\n         {\\n             vec.push_back(pr);\\n         }\\n         sort(vec.begin(),vec.end(),comp);\\n         \\n vector<int> ans;\\n    for(int i=0;i<vec.size();i++)\\n    {\\n     while(vec[i].second>0)\\n     {\\n         ans.push_back(vec[i].first);\\n         vec[i].second--;\\n     }\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645695,
                "title": "c-solution-easy",
                "content": "```\\npublic class Solution {\\n    public int[] FrequencySort(int[] nums) {\\n            int n = nums.Length;\\n            int[] result = new int[n];\\n            Dictionary<int, int> dic = new Dictionary<int, int>();\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (dic.ContainsKey(nums[i]))\\n                    dic[nums[i]]++;\\n                else\\n                    dic.Add(nums[i], 1);\\n            }\\n            var sortedDict = from entry in dic\\n                             orderby entry.Key descending\\n                             orderby entry.Value ascending\\n                             select entry;\\n            int j = 0;\\n            foreach (var item in sortedDict)\\n            {\\n                for (int i = 0; i < item.Value; i++)\\n                    result[j++] = item.Key;\\n            }\\n            return result;\\n    }\\n}",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "class Solution {\\n    public int[] FrequencySort(int[] nums) {\\n            int n = nums.Length;\\n            int[] result = new int[n];\\n            Dictionary<int, int> dic = new Dictionary<int, int>();\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (dic.ContainsKey(nums[i]))\\n                    dic[nums[i]]++;\\n                else\\n                    dic.Add(nums[i], 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2591467,
                "title": "beats-98-c-solution-using-hashing-with-comments",
                "content": "```\\n//compartor function that sorts according to the frequency of occurance\\nbool cmp (pair<int,int>a,pair<int,int>b) {\\n\\t\\t//in case the frequency is same we need to return the number which is greater\\n        if(a.second == b.second) return a.first > b.first;\\n        return a.second < b.second;\\n}\\nclass Solution {\\npublic:\\n\\n\\tvector<int> frequencySort(vector<int>& nums) {\\n\\t\\t//unordered map to store the frequency of the elements\\n        unordered_map<int,int>m;\\n\\t\\t//adding elements to the map\\n        for(auto it : nums) m[it]++;\\n\\t\\t//vector in order to store the pair of element side by side its frequency to perform the sort operation\\n        vector<pair<int,int>>v;\\n\\t\\t//addition of elements to the vector\\n        for(auto it : m) v.push_back(it);\\n\\t\\t//sorting using the comparator\\n        sort(v.begin(),v.end(),cmp);\\n\\t\\t//vector to store the result\\n        vector<int>ans;\\n\\t\\t//for loop to traverse the vector with pair\\n        for(int i=0;i<v.size();i++) {\\n\\t\\t\\t//for loop to add the element in the answer number of times it occurs\\n            for(int j=0;j<v[i].second;j++) {\\n\\t\\t\\t\\t//adding the element to the answer\\n                ans.push_back(v[i].first);\\n            }\\n        }\\n\\t\\t//returns answer\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/25c26a69-db31-42f0-9773-c8facbbe0e06_1663484047.2930412.png)\\nUpvote if I could help :)\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n//compartor function that sorts according to the frequency of occurance\\nbool cmp (pair<int,int>a,pair<int,int>b) {\\n\\t\\t//in case the frequency is same we need to return the number which is greater\\n        if(a.second == b.second) return a.first > b.first;\\n        return a.second < b.second;\\n}\\nclass Solution {\\npublic:\\n\\n\\tvector<int> frequencySort(vector<int>& nums) {\\n\\t\\t//unordered map to store the frequency of the elements\\n        unordered_map<int,int>m;\\n\\t\\t//adding elements to the map\\n        for(auto it : nums) m[it]++;\\n\\t\\t//vector in order to store the pair of element side by side its frequency to perform the sort operation\\n        vector<pair<int,int>>v;\\n\\t\\t//addition of elements to the vector\\n        for(auto it : m) v.push_back(it);\\n\\t\\t//sorting using the comparator\\n        sort(v.begin(),v.end(),cmp);\\n\\t\\t//vector to store the result\\n        vector<int>ans;\\n\\t\\t//for loop to traverse the vector with pair\\n        for(int i=0;i<v.size();i++) {\\n\\t\\t\\t//for loop to add the element in the answer number of times it occurs\\n            for(int j=0;j<v[i].second;j++) {\\n\\t\\t\\t\\t//adding the element to the answer\\n                ans.push_back(v[i].first);\\n            }\\n        }\\n\\t\\t//returns answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563249,
                "title": "custom-sorting-map-entryset-java-code",
                "content": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        \\n      HashMap <Integer,Integer> map= new HashMap<>();\\n        for(int i:nums){\\nif(map.containsKey(i))  map.put(i,map.get(i)+1);\\nelse   map.put(i,1);\\n            }  \\n        List<Map.Entry<Integer, Integer>> list = new ArrayList(map.entrySet());\\n        Collections.sort(list, (a,b) -> a.getValue() == b.getValue() ? b.getKey() - a.getKey() : a.getValue() - b.getValue());\\n        int index = 0;\\n        int[] ans = new int[nums.length];\\n        for (Map.Entry<Integer, Integer> entry : list) {\\n            \\n            int count = entry.getValue();\\n            int key = entry.getKey();\\n            \\n            for (int i=0; i<count; i++) {\\n                ans[index++] = key;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        \\n      HashMap <Integer,Integer> map= new HashMap<>();\\n        for(int i:nums){\\nif(map.containsKey(i))  map.put(i,map.get(i)+1);\\nelse   map.put(i,1);\\n            }  \\n        List<Map.Entry<Integer, Integer>> list = new ArrayList(map.entrySet());\\n        Collections.sort(list, (a,b) -> a.getValue() == b.getValue() ? b.getKey() - a.getKey() : a.getValue() - b.getValue());\\n        int index = 0;\\n        int[] ans = new int[nums.length];\\n        for (Map.Entry<Integer, Integer> entry : list) {\\n            \\n            int count = entry.getValue();\\n            int key = entry.getKey();\\n            \\n            for (int i=0; i<count; i++) {\\n                ans[index++] = key;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435908,
                "title": "java-custom-comparator-in-integer-array-hashmap",
                "content": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer,Integer> freq = new HashMap<>();\\n        for(int i:nums){\\n            freq.put(i,freq.getOrDefault(i,0)+1);\\n        }\\n        Comparator<Integer> comp = (a,b)->{\\n          return freq.get(a)!=freq.get(b)?freq.get(a)-freq.get(b):b-a;  \\n        };\\n        \\n        Integer[] ans = new Integer[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i] = nums[i];\\n        }\\n        Arrays.sort(ans,comp);\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = ans[i];\\n        }\\n        return nums;\\n    }\\n}\\n```\\nBonus:\\nYou can replace following lines of code \\n```\\n\\t\\tInteger[] ans = new Integer[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i] = nums[i];\\n        }\\n        Arrays.sort(ans,comp);\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = ans[i];\\n        }\\n        return nums;\\n```\\nby one line \\n```\\nreturn Arrays.stream(nums).boxed().sorted(comp).mapToInt(Integer::intValue).toArray();\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer,Integer> freq = new HashMap<>();\\n        for(int i:nums){\\n            freq.put(i,freq.getOrDefault(i,0)+1);\\n        }\\n        Comparator<Integer> comp = (a,b)->{\\n          return freq.get(a)!=freq.get(b)?freq.get(a)-freq.get(b):b-a;  \\n        };\\n        \\n        Integer[] ans = new Integer[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i] = nums[i];\\n        }\\n        Arrays.sort(ans,comp);\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = ans[i];\\n        }\\n        return nums;\\n    }\\n}\\n```\n```\\n\\t\\tInteger[] ans = new Integer[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i] = nums[i];\\n        }\\n        Arrays.sort(ans,comp);\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = ans[i];\\n        }\\n        return nums;\\n```\n```\\nreturn Arrays.stream(nums).boxed().sorted(comp).mapToInt(Integer::intValue).toArray();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382948,
                "title": "java-solution-using-streams-4-lines-of-code",
                "content": "```\\n    int i = 0;\\n    public int[] frequencySort(int[] nums) {\\n        Arrays.stream(nums).boxed()\\n                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\\n                .entrySet().stream()\\n                .sorted((x1, x2) -> x1.getValue() == x2.getValue() ? x2.getKey() - x1.getKey() : (int) (x1.getValue() - x2.getValue()))\\n                .forEach(x -> Stream.iterate(0, n -> n + 1).limit(x.getValue()).forEach(n -> nums[i++] = x.getKey()));\\n        return nums;\\n    }\\t\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    int i = 0;\\n    public int[] frequencySort(int[] nums) {\\n        Arrays.stream(nums).boxed()\\n                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\\n                .entrySet().stream()\\n                .sorted((x1, x2) -> x1.getValue() == x2.getValue() ? x2.getKey() - x1.getKey() : (int) (x1.getValue() - x2.getValue()))\\n                .forEach(x -> Stream.iterate(0, n -> n + 1).limit(x.getValue()).forEach(n -> nums[i++] = x.getKey()));\\n        return nums;\\n    }\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2345329,
                "title": "c-o-n-log-n-time-solution",
                "content": "Solution using Priority Queue, lambda functions, and custom comparator.\\n\\n\\n```c++\\nvector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int,int> um;\\n        for(auto ch : nums){\\n            um[ch]++;\\n        }\\n        \\n        \\n        auto compare = [](pair<int,int> &p1, pair<int,int> &p2){\\n            if(p1.second == p2.second){\\n                return p1.first < p2.first;\\n            }\\n            return p1.second > p2.second;    \\n        };\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype(compare)> pq(um.begin(),um.end(),compare);\\n        \\n        vector<int> ans(nums.size(),0);\\n        \\n        for(int i = 0 ; i < ans.size() ; i++){\\n            int ch = pq.top().first;\\n            int freq = pq.top().second;\\n            \\n            while(freq > 0){\\n                ans[i] = ch;\\n                i++;\\n                freq--;\\n            }\\n            i--;\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```c++\\nvector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int,int> um;\\n        for(auto ch : nums){\\n            um[ch]++;\\n        }\\n        \\n        \\n        auto compare = [](pair<int,int> &p1, pair<int,int> &p2){\\n            if(p1.second == p2.second){\\n                return p1.first < p2.first;\\n            }\\n            return p1.second > p2.second;    \\n        };\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype(compare)> pq(um.begin(),um.end(),compare);\\n        \\n        vector<int> ans(nums.size(),0);\\n        \\n        for(int i = 0 ; i < ans.size() ; i++){\\n            int ch = pq.top().first;\\n            int freq = pq.top().second;\\n            \\n            while(freq > 0){\\n                ans[i] = ch;\\n                i++;\\n                freq--;\\n            }\\n            i--;\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2299510,
                "title": "python-2-liner-solution",
                "content": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        nums.sort(reverse=True)\\n        d=sorted(nums,key=nums.count)\\n        \\n        return d \\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        nums.sort(reverse=True)\\n        d=sorted(nums,key=nums.count)\\n        \\n        return d \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269806,
                "title": "javscript-easy-solution",
                "content": "```\\nvar frequencySort = function(nums) {\\n  const obj = {};\\n  for (const num of nums) {\\n    obj[num] = (obj[num] || 0) + 1;\\n  }\\n  return nums.sort((a, b) => obj[a] === obj[b] ? b - a : obj[a] - obj[b]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar frequencySort = function(nums) {\\n  const obj = {};\\n  for (const num of nums) {\\n    obj[num] = (obj[num] || 0) + 1;\\n  }\\n  return nums.sort((a, b) => obj[a] === obj[b] ? b - a : obj[a] - obj[b]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230646,
                "title": "simple-c-soln-using-hashmap-and-vector-pair",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int>a,pair<int,int>b){\\n        \\n        if(a.first!=b.first)\\n            return a.first<b.first;\\n        \\n        return(a.second>b.second)?true:false;\\n        \\n    }\\n    \\n    vector<int> frequencySort(vector<int>& nums) {\\n        \\n        vector<pair<int,int>>p;\\n        unordered_map<int,int>m;\\n        vector<int>v;\\n        \\n        for(int x:nums){\\n            m[x]++;\\n        }\\n        \\n        for(auto x:m){\\n            p.push_back({x.second,x.first});\\n        }\\n        \\n        sort(p.begin(),p.end(),cmp);\\n        for(auto x:p){\\n            for(int i=0;i<x.first;i++){\\n                v.push_back(x.second);\\n            }\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int>a,pair<int,int>b){\\n        \\n        if(a.first!=b.first)\\n            return a.first<b.first;\\n        \\n        return(a.second>b.second)?true:false;\\n        \\n    }\\n    \\n    vector<int> frequencySort(vector<int>& nums) {\\n        \\n        vector<pair<int,int>>p;\\n        unordered_map<int,int>m;\\n        vector<int>v;\\n        \\n        for(int x:nums){\\n            m[x]++;\\n        }\\n        \\n        for(auto x:m){\\n            p.push_back({x.second,x.first});\\n        }\\n        \\n        sort(p.begin(),p.end(),cmp);\\n        for(auto x:p){\\n            for(int i=0;i<x.first;i++){\\n                v.push_back(x.second);\\n            }\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223423,
                "title": "java-2-simple-solutions-easy-to-understand",
                "content": "**Solution 1: Using HashMap + Sorted List**\\n```\\n// Time complexity: O(n  + m log m)\\n// Space complexity: O(m)\\n\\npublic int[] frequencySort(int[] nums) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\t\\n\\tfor (int num : nums) \\n\\t\\tmap.put(num, map.getOrDefault(num, 0) + 1);\\n\\t\\n\\tList<Integer> list = new ArrayList<>(map.keySet());\\n\\tCollections.sort(list, (a, b) -> map.get(a) == map.get(b) ? b - a : map.get(a) - map.get(b));\\n\\t\\t\\n\\tint[] res = new int[nums.length];\\n\\tint i = 0;\\n\\t\\n\\tfor (int num : list) {\\n\\t\\tfor (int j = 0; j < map.get(num); j++) {\\n\\t\\t\\tres[i++] = num;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn res;\\n}\\n```\\n\\n**Solution 2: Using HashMap + Priority Queue**\\n\\n```\\n// Time complexity: O(n + m log m)\\n// Space complexity: O(m)\\n\\npublic int[] frequencySort(int[] nums) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\n\\tfor (int num : nums) \\n\\t\\tmap.put(num, map.getOrDefault(num, 0) + 1);\\n\\n\\tPriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> map.get(a) == map.get(b) ? b - a : map.get(a) - map.get(b));\\n\\tpq.addAll(map.keySet());\\n\\n\\tint[] res = new int[nums.length];\\n\\tint i = 0;\\n\\n\\twhile (!pq.isEmpty()) {\\n\\t\\tint key = pq.poll();\\n\\t\\tfor (int j = 0; j < map.get(key); j++) {\\n\\t\\t\\tres[i++] = key;\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n```\\n\\nPlease upvote if you find it useful.",
                "solutionTags": [],
                "code": "```\\n// Time complexity: O(n  + m log m)\\n// Space complexity: O(m)\\n\\npublic int[] frequencySort(int[] nums) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\t\\n\\tfor (int num : nums) \\n\\t\\tmap.put(num, map.getOrDefault(num, 0) + 1);\\n\\t\\n\\tList<Integer> list = new ArrayList<>(map.keySet());\\n\\tCollections.sort(list, (a, b) -> map.get(a) == map.get(b) ? b - a : map.get(a) - map.get(b));\\n\\t\\t\\n\\tint[] res = new int[nums.length];\\n\\tint i = 0;\\n\\t\\n\\tfor (int num : list) {\\n\\t\\tfor (int j = 0; j < map.get(num); j++) {\\n\\t\\t\\tres[i++] = num;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn res;\\n}\\n```\n```\\n// Time complexity: O(n + m log m)\\n// Space complexity: O(m)\\n\\npublic int[] frequencySort(int[] nums) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\n\\tfor (int num : nums) \\n\\t\\tmap.put(num, map.getOrDefault(num, 0) + 1);\\n\\n\\tPriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> map.get(a) == map.get(b) ? b - a : map.get(a) - map.get(b));\\n\\tpq.addAll(map.keySet());\\n\\n\\tint[] res = new int[nums.length];\\n\\tint i = 0;\\n\\n\\twhile (!pq.isEmpty()) {\\n\\t\\tint key = pq.poll();\\n\\t\\tfor (int j = 0; j < map.get(key); j++) {\\n\\t\\t\\tres[i++] = key;\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2178748,
                "title": "c-solution-using-ordered-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) \\n    {\\n        map<int,int>umap;\\n        map<int,vector<int>> map_freq;\\n        vector<int> final_vec;\\n        for(auto a:nums)\\n        {\\n            umap[a]++;//Saves numbers and their frequency\\n        }\\n        for(auto k:umap)\\n        {\\n            map_freq[k.second].push_back(k.first);// map like frequency->(vector containing numbers \\n            //having that frequency)\\n        }\\n        for(auto j:map_freq)\\n        {\\n            for(int i=j.second.size()-1;i>=0;i--)//reversing vector so that it can be sorted in descending order when frequency is same \\n            {\\n                for(int l=0;l<j.first;l++)//no of times to save in vector\\n                {final_vec.push_back(j.second[i]);}\\n            }\\n        }\\n        return final_vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) \\n    {\\n        map<int,int>umap;\\n        map<int,vector<int>> map_freq;\\n        vector<int> final_vec;\\n        for(auto a:nums)\\n        {\\n            umap[a]++;//Saves numbers and their frequency\\n        }\\n        for(auto k:umap)\\n        {\\n            map_freq[k.second].push_back(k.first);// map like frequency->(vector containing numbers \\n            //having that frequency)\\n        }\\n        for(auto j:map_freq)\\n        {\\n            for(int i=j.second.size()-1;i>=0;i--)//reversing vector so that it can be sorted in descending order when frequency is same \\n            {\\n                for(int l=0;l<j.first;l++)//no of times to save in vector\\n                {final_vec.push_back(j.second[i]);}\\n            }\\n        }\\n        return final_vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123017,
                "title": "easy-java-solution-using-hashmap-stream",
                "content": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) \\n    {\\n        HashMap<Integer,Integer> hmap = new HashMap<>();\\n        for(int num:nums)\\n            hmap.put(num,hmap.getOrDefault(num,0)+1);\\n        return Arrays.stream(nums).boxed().sorted((a,b)-> hmap.get(a)!=hmap.get(b)?hmap.get(a)-hmap.get(b):b-a).mapToInt(n->n).toArray();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] frequencySort(int[] nums) \\n    {\\n        HashMap<Integer,Integer> hmap = new HashMap<>();\\n        for(int num:nums)\\n            hmap.put(num,hmap.getOrDefault(num,0)+1);\\n        return Arrays.stream(nums).boxed().sorted((a,b)-> hmap.get(a)!=hmap.get(b)?hmap.get(a)-hmap.get(b):b-a).mapToInt(n->n).toArray();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2109560,
                "title": "c-priority-queue-map",
                "content": "\\n    vector<int> frequencySort(vector<int>& nums) {\\n        vector<int > v;\\n        int n=nums.size();\\n        map<int,int>m;\\n        priority_queue<pair<int,int>> maxh;\\n        for(int x:nums)\\n          m[x]++;\\n        for(auto a:m)\\n            maxh.push({-a.second,a.first});\\n        while(!maxh.empty()){\\n            int x=maxh.top().first;\\n            for(int i=0;i<abs(x);i++){\\n            v.push_back(maxh.top().second);\\n        }\\n            maxh.pop();\\n        }\\n        \\n        return v;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    vector<int> frequencySort(vector<int>& nums) {\\n        vector<int > v;\\n        int n=nums.size();\\n        map<int,int>m;\\n        priority_queue<pair<int,int>> maxh;\\n        for(int x:nums)\\n          m[x]++;\\n        for(auto a:m)\\n            maxh.push({-a.second,a.first});\\n        while(!maxh.empty()){\\n            int x=maxh.top().first;\\n            for(int i=0;i<abs(x);i++){\\n            v.push_back(maxh.top().second);\\n        }\\n            maxh.pop();\\n        }\\n        \\n        return v;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2074376,
                "title": "python3-1-line",
                "content": "```\\nreturn sorted(nums, key = lambda x: (nums.count(x), -x))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nreturn sorted(nums, key = lambda x: (nums.count(x), -x))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1992565,
                "title": "python-o-n-log-n",
                "content": "First we create a dictonary with frequency of each item and then we sort the list with two criteria, where the second criteria is the number multiplied by -1 so we can sort in decreasing order if the frequency of two numbers is the same.\\n\\n```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        f = Counter(nums)\\n        nums.sort(key=lambda x: (f[x], -1*x))\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        f = Counter(nums)\\n        nums.sort(key=lambda x: (f[x], -1*x))\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944926,
                "title": "java-priority-queue-hashmap-solution-fast-beats-98",
                "content": "```\\nclass Element {\\n    int value, frequency;\\n    Element(int value, int frequency) {\\n        this.value = value;\\n        this.frequency = frequency;\\n    }\\n}\\n\\nclass ElementComparator implements Comparator<Element> {\\n    @Override\\n    public int compare(Element e1, Element e2) {\\n        if(e1.frequency == e2.frequency) {\\n            return e2.value - e1.value;\\n        } else {\\n            return e1.frequency - e2.frequency;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        PriorityQueue<Element> minHeap = new PriorityQueue<>(new ElementComparator());\\n        Map<Integer, Integer> freqMap = new HashMap<>();\\n        for(int num: nums) {\\n            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\\n        }\\n        for(Map.Entry<Integer, Integer> entry: freqMap.entrySet()) {\\n            minHeap.offer(new Element(entry.getKey(), entry.getValue()));\\n        }\\n        int[] answer = new int[nums.length];\\n        int j = 0;\\n        while(!minHeap.isEmpty()) {\\n            Element element = minHeap.poll();\\n            int i = element.frequency;\\n            while(i > 0) {\\n                answer[j++] = element.value;\\n                i--;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Element {\\n    int value, frequency;\\n    Element(int value, int frequency) {\\n        this.value = value;\\n        this.frequency = frequency;\\n    }\\n}\\n\\nclass ElementComparator implements Comparator<Element> {\\n    @Override\\n    public int compare(Element e1, Element e2) {\\n        if(e1.frequency == e2.frequency) {\\n            return e2.value - e1.value;\\n        } else {\\n            return e1.frequency - e2.frequency;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        PriorityQueue<Element> minHeap = new PriorityQueue<>(new ElementComparator());\\n        Map<Integer, Integer> freqMap = new HashMap<>();\\n        for(int num: nums) {\\n            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\\n        }\\n        for(Map.Entry<Integer, Integer> entry: freqMap.entrySet()) {\\n            minHeap.offer(new Element(entry.getKey(), entry.getValue()));\\n        }\\n        int[] answer = new int[nums.length];\\n        int j = 0;\\n        while(!minHeap.isEmpty()) {\\n            Element element = minHeap.poll();\\n            int i = element.frequency;\\n            while(i > 0) {\\n                answer[j++] = element.value;\\n                i--;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914346,
                "title": "c-easy-solution-using-unorderd-map",
                "content": "class Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        \\n        unordered_map<int ,int> umap;\\n        \\n        for( auto x : nums)\\n        {\\n            umap[x]++;\\n            \\n        }\\n        \\n        sort(nums.begin(), nums.end(), [&](int a ,int b) \\n        {\\n            return umap[a]!= umap[b] ? umap[a]<umap[b] : a>b ;} );\\n        \\n        return nums;\\n        \\n         \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        \\n        unordered_map<int ,int> umap;\\n        \\n        for( auto x : nums)\\n        {\\n            umap[x]++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1870522,
                "title": "python-clean-and-concise-multiple-solutions-one-liners",
                "content": "**Built-in sort (2x)**:\\n```\\nclass Solution:\\n    def frequencySort(self, nums):\\n        c = Counter(nums)\\n        nums.sort(reverse=True)\\n        nums.sort(key=lambda x: c[x])\\n        return nums\\n```\\n\\n**One-Liner**:\\n```\\nclass Solution:\\n    def frequencySort(self, nums):\\n        return (lambda c : sorted(sorted(nums, reverse=True), key=lambda x: c[x]))(Counter(nums))\\n```\\n\\n**Built-in sort (1x) using tuple**:\\n```\\nclass Solution:\\n    def frequencySort(self, nums):\\n        c = Counter(nums)\\n        nums.sort(key=lambda x: (c[x], -x))\\n        return nums\\n```\\n\\n**One-Liner**:\\n```\\nclass Solution:\\n    def frequencySort(self, nums):\\n        return (lambda c : sorted(nums, key=lambda x: (c[x], -x)))(Counter(nums))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums):\\n        c = Counter(nums)\\n        nums.sort(reverse=True)\\n        nums.sort(key=lambda x: c[x])\\n        return nums\\n```\n```\\nclass Solution:\\n    def frequencySort(self, nums):\\n        return (lambda c : sorted(sorted(nums, reverse=True), key=lambda x: c[x]))(Counter(nums))\\n```\n```\\nclass Solution:\\n    def frequencySort(self, nums):\\n        c = Counter(nums)\\n        nums.sort(key=lambda x: (c[x], -x))\\n        return nums\\n```\n```\\nclass Solution:\\n    def frequencySort(self, nums):\\n        return (lambda c : sorted(nums, key=lambda x: (c[x], -x)))(Counter(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851859,
                "title": "simple-python-dictionary",
                "content": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        d = defaultdict(int)\\n        for i in nums:\\n            d[i] += 1\\n        output = []\\n        for i in sorted(d.items(), key=lambda kv: (kv[1],-kv[0])):\\n            output.extend([i[0]]*i[1])\\n        return output\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        d = defaultdict(int)\\n        for i in nums:\\n            d[i] += 1\\n        output = []\\n        for i in sorted(d.items(), key=lambda kv: (kv[1],-kv[0])):\\n            output.extend([i[0]]*i[1])\\n        return output\\n",
                "codeTag": "Java"
            },
            {
                "id": 1795337,
                "title": "c-code-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    static  bool comp(pair<int,int>&a, pair<int,int>&b)\\n         // freq,ele ->pair\\n    {\\n        if(a.first==b.first)\\n            //having same freq\\n            return a.second>b.second;\\n            return a.first<b.first;\\n         //return having more freq\\n    }\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int,int>mp;  \\n        for(auto x:nums)\\n            mp[x]++;\\n        \\n        vector<pair<int,int>>v;\\n        \\n        for(auto i:mp)\\n        {\\n            v.push_back({i.second,i.first}); // frq , element\\n        }\\n        \\n        sort(v.begin(),v.end(),comp);\\n        \\n        vector<int>res;\\n        \\n        for(int i=0; i<v.size(); i++)\\n            while(v[i].first--)\\n            res.push_back(v[i].second);\\n        \\n        return res;\\n    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    static  bool comp(pair<int,int>&a, pair<int,int>&b)\\n         // freq,ele ->pair\\n    {\\n        if(a.first==b.first)\\n            //having same freq\\n            return a.second>b.second;\\n            return a.first<b.first;\\n         //return having more freq\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1776822,
                "title": "python-sort-using-heap",
                "content": "Use a Heap to sort by using a tuple consisting of the count, and the negative value of the key. The reason we use the negative values to sort the keys in decreasing order as we are implementing a min heap.\\n \\n```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        \\n        counts = Counter(nums)\\n    \\n        heap = []\\n        for key in counts:\\n            heapq.heappush(heap, (counts[key], (-1 *key)))\\n        \\n        output = []\\n        while heap:\\n            count, val = heapq.heappop(heap)\\n            val *= -1\\n            \\n            for i in range(count):\\n                output.append(val)\\n        return output\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        \\n        counts = Counter(nums)\\n    \\n        heap = []\\n        for key in counts:\\n            heapq.heappush(heap, (counts[key], (-1 *key)))\\n        \\n        output = []\\n        while heap:\\n            count, val = heapq.heappop(heap)\\n            val *= -1\\n            \\n            for i in range(count):\\n                output.append(val)\\n        return output\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670771,
                "title": "java-solution-using-map-and-comparator",
                "content": "Using  lambda expression-->\\n```\\nclass Solution {\\n    public int[] frequencySort(int[] arr) {\\n        int n=arr.length;\\n        Map<Integer,Integer>map=new HashMap<>();\\n        List<Integer>al=new ArrayList<>();\\n        for(int x:arr){\\n            map.put(x,map.getOrDefault(x,0)+1);\\n            al.add(x);\\n        }\\n        Collections.sort(al,(a,b)->map.get(a)!=map.get(b)?map.get(a)-map.get(b):b-a);\\n        for(int i=0;i<n;i++)arr[i]=al.get(i);\\n        return arr;\\n    }\\n}\\n```\\nUsing custom comparator\\n```\\nclass Solution {\\n    public int[] frequencySort(int[] arr) {\\n        int n=arr.length;\\n        Map<Integer,Integer>map=new HashMap<>();\\n        ArrayList<Integer>al=new ArrayList<>();\\n        for(int x:arr){\\n            map.put(x,map.getOrDefault(x,0)+1);\\n            al.add(x);\\n        }\\n        Collections.sort(al,new Comparator<Integer>(){\\n            public int compare(Integer e1,Integer e2){\\n                if(map.get(e1)!=map.get(e2)){\\n                    return map.get(e1)-map.get(e2);\\n                }\\n                else return e2-e1;\\n            }\\n        });\\n        for(int i=0;i<n;i++)arr[i]=al.get(i);\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] arr) {\\n        int n=arr.length;\\n        Map<Integer,Integer>map=new HashMap<>();\\n        List<Integer>al=new ArrayList<>();\\n        for(int x:arr){\\n            map.put(x,map.getOrDefault(x,0)+1);\\n            al.add(x);\\n        }\\n        Collections.sort(al,(a,b)->map.get(a)!=map.get(b)?map.get(a)-map.get(b):b-a);\\n        for(int i=0;i<n;i++)arr[i]=al.get(i);\\n        return arr;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] frequencySort(int[] arr) {\\n        int n=arr.length;\\n        Map<Integer,Integer>map=new HashMap<>();\\n        ArrayList<Integer>al=new ArrayList<>();\\n        for(int x:arr){\\n            map.put(x,map.getOrDefault(x,0)+1);\\n            al.add(x);\\n        }\\n        Collections.sort(al,new Comparator<Integer>(){\\n            public int compare(Integer e1,Integer e2){\\n                if(map.get(e1)!=map.get(e2)){\\n                    return map.get(e1)-map.get(e2);\\n                }\\n                else return e2-e1;\\n            }\\n        });\\n        for(int i=0;i<n;i++)arr[i]=al.get(i);\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657488,
                "title": "java-2-ms-98-58-no-need-to-use-customized-sort-or-heap-12-30-2021",
                "content": "Just use frequency to modify original value and sort\\n```java\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        int[] count = new int[201];\\n        for (int num : nums) {\\n            count[num + 100]++;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = count[nums[i] + 100] * 201 + 100 - nums[i];\\n        }\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = 100 - nums[i] % 201;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        int[] count = new int[201];\\n        for (int num : nums) {\\n            count[num + 100]++;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = count[nums[i] + 100] * 201 + 100 - nums[i];\\n        }\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = 100 - nums[i] % 201;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629100,
                "title": "faster-than-95-63-map-c",
                "content": "```\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        //freq count\\n        for(auto &it:nums){\\n            mp[it]++;\\n        }\\n        vector<pair<int,int>>arr;\\n        vector<int>ans;\\n        for(auto &it:mp){\\n            int ele=it.first;\\n            int count=it.second;\\n            arr.push_back({ele,count});\\n        }\\n        sort(arr.begin(),arr.end(),[](const auto &a,const auto &b){\\n            if(a.second==b.second){\\n                return a.first>b.first;\\n            }else{\\n                return a.second<b.second;\\n            }\\n        });\\n        for(auto &it:arr){\\n            int cnt=it.second;\\n            while(cnt--){\\n            ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        //freq count\\n        for(auto &it:nums){\\n            mp[it]++;\\n        }\\n        vector<pair<int,int>>arr;\\n        vector<int>ans;\\n        for(auto &it:mp){\\n            int ele=it.first;\\n            int count=it.second;\\n            arr.push_back({ele,count});\\n        }\\n        sort(arr.begin(),arr.end(),[](const auto &a,const auto &b){\\n            if(a.second==b.second){\\n                return a.first>b.first;\\n            }else{\\n                return a.second<b.second;\\n            }\\n        });\\n        for(auto &it:arr){\\n            int cnt=it.second;\\n            while(cnt--){\\n            ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534333,
                "title": "java-3-methods-reuse-lc-347",
                "content": "**T/S:** O(n lg n)/O(n)\\n\\n**Method 1:** Bucket Sort\\n ```\\npublic int[] frequencySort(int[] nums) {\\n\\tvar map = getFrequencyMap(nums);\\n\\n\\tvar buckets = new ArrayList<List<Integer>>();\\n\\tfor (var i = Collections.max(map.values()); i >= 0; i--)\\n\\t\\tbuckets.add(new ArrayList<>());\\n\\n\\tfor (var key : map.keySet())\\n\\t\\tbuckets.get(map.get(key)).add(key);\\n\\n\\tvar sorted = new int[nums.length];\\n\\tfor (int i = 0, j = 0; i < buckets.size(); i++) {\\n\\t\\t\\n\\t\\tvar bucket = buckets.get(i);\\n\\t\\tbucket.sort(Collections.reverseOrder());\\n\\n\\t\\tfor (var num : bucket)\\n\\t\\t\\tfor (var k = map.get(num); k > 0; k--)\\n\\t\\t\\t\\tsorted[j++] = num;\\n\\t}\\n\\treturn sorted;\\n}\\n\\nprivate Map<Integer, Integer> getFrequencyMap(int[] nums) {\\n\\tvar map = new HashMap<Integer, Integer>();\\n\\tfor (var num : nums)\\n\\t\\tmap.compute(num, (n, frequency) -> (frequency == null) ? 1 : frequency + 1);\\n\\treturn map;\\n}\\n```\\n**Method 2:** Priority Queue\\n```\\npublic int[] frequencySort(int[] nums) {\\n\\tvar map = getFrequencyMap(nums);\\n\\tvar minHeap = new PriorityQueue<Map.Entry<Integer, Integer>>((e1, e2) ->\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  e1.getValue().equals(e2.getValue()) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  Integer.compare(e2.getKey(), e1.getKey()) :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  Integer.compare(e1.getValue(), e2.getValue()));\\n\\tminHeap.addAll(map.entrySet());\\n\\n\\tvar sorted = new int[nums.length];\\n\\tvar i = 0;\\n\\twhile (!minHeap.isEmpty()) {\\n\\t\\tvar head = minHeap.poll();\\n\\t\\tfor (var j = 0; j < head.getValue(); j++)\\n\\t\\t\\tsorted[i++] = head.getKey();\\n\\t}\\n\\treturn sorted;\\n}\\n```\\n \\n**Method 3:** Custom comparator\\n```\\npublic int[] frequencySort(int[] nums) {\\n\\tvar map = getFrequencyMap(nums);\\n\\treturn Arrays.stream(nums) // create a stream of int from the int[] array\\n\\t\\t\\t\\t .boxed() // convert int to Integer\\n\\t\\t\\t\\t .sorted((i1, i2) -> map.get(i1).equals(map.get(i2)) ? // if frequencies are same\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t Integer.compare(i2, i1) :         // then compare the values for descending order\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t Integer.compare(map.get(i1), map.get(i2))) // else compare the frequencies\\n\\t\\t\\t\\t .mapToInt(Integer::intValue) // convert Integer to int\\n\\t\\t\\t\\t .toArray(); // collect in an int[] array\\n}\\n```\\n\\nQuestions with identical solutions (methods 1 and 2):\\n* [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/discuss/292371/Java-or-Bucket-Sort-or-Explained)\\n* [Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words/discuss/292405/Java.-7-ms.-With-comments.-Java-7-and-8-versions.)\\n* [Sort Characters By Frequency](https://leetcode.com/problems/sort-characters-by-frequency/discuss/1534125/Java-or-2-progressive-methods-or-Explained)",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "```\\npublic int[] frequencySort(int[] nums) {\\n\\tvar map = getFrequencyMap(nums);\\n\\n\\tvar buckets = new ArrayList<List<Integer>>();\\n\\tfor (var i = Collections.max(map.values()); i >= 0; i--)\\n\\t\\tbuckets.add(new ArrayList<>());\\n\\n\\tfor (var key : map.keySet())\\n\\t\\tbuckets.get(map.get(key)).add(key);\\n\\n\\tvar sorted = new int[nums.length];\\n\\tfor (int i = 0, j = 0; i < buckets.size(); i++) {\\n\\t\\t\\n\\t\\tvar bucket = buckets.get(i);\\n\\t\\tbucket.sort(Collections.reverseOrder());\\n\\n\\t\\tfor (var num : bucket)\\n\\t\\t\\tfor (var k = map.get(num); k > 0; k--)\\n\\t\\t\\t\\tsorted[j++] = num;\\n\\t}\\n\\treturn sorted;\\n}\\n\\nprivate Map<Integer, Integer> getFrequencyMap(int[] nums) {\\n\\tvar map = new HashMap<Integer, Integer>();\\n\\tfor (var num : nums)\\n\\t\\tmap.compute(num, (n, frequency) -> (frequency == null) ? 1 : frequency + 1);\\n\\treturn map;\\n}\\n```\n```\\npublic int[] frequencySort(int[] nums) {\\n\\tvar map = getFrequencyMap(nums);\\n\\tvar minHeap = new PriorityQueue<Map.Entry<Integer, Integer>>((e1, e2) ->\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  e1.getValue().equals(e2.getValue()) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  Integer.compare(e2.getKey(), e1.getKey()) :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  Integer.compare(e1.getValue(), e2.getValue()));\\n\\tminHeap.addAll(map.entrySet());\\n\\n\\tvar sorted = new int[nums.length];\\n\\tvar i = 0;\\n\\twhile (!minHeap.isEmpty()) {\\n\\t\\tvar head = minHeap.poll();\\n\\t\\tfor (var j = 0; j < head.getValue(); j++)\\n\\t\\t\\tsorted[i++] = head.getKey();\\n\\t}\\n\\treturn sorted;\\n}\\n```\n```\\npublic int[] frequencySort(int[] nums) {\\n\\tvar map = getFrequencyMap(nums);\\n\\treturn Arrays.stream(nums) // create a stream of int from the int[] array\\n\\t\\t\\t\\t .boxed() // convert int to Integer\\n\\t\\t\\t\\t .sorted((i1, i2) -> map.get(i1).equals(map.get(i2)) ? // if frequencies are same\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t Integer.compare(i2, i1) :         // then compare the values for descending order\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t Integer.compare(map.get(i1), map.get(i2))) // else compare the frequencies\\n\\t\\t\\t\\t .mapToInt(Integer::intValue) // convert Integer to int\\n\\t\\t\\t\\t .toArray(); // collect in an int[] array\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529350,
                "title": "c-lambda-function",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> frequencySort(vector<int> &nums)\\n    {\\n        unordered_map<int, int> mp;\\n\\n        for (auto i : nums)\\n        {\\n            mp[i]++;\\n        }\\n\\n        auto cam = [&](int a, int b)\\n        {\\n            return mp[a] == mp[b] ? a > b : mp[a] < mp[b];\\n        };\\n\\n        sort(nums.begin(), nums.end(), cam);\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> frequencySort(vector<int> &nums)\\n    {\\n        unordered_map<int, int> mp;\\n\\n        for (auto i : nums)\\n        {\\n            mp[i]++;\\n        }\\n\\n        auto cam = [&](int a, int b)\\n        {\\n            return mp[a] == mp[b] ? a > b : mp[a] < mp[b];\\n        };\\n\\n        sort(nums.begin(), nums.end(), cam);\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486646,
                "title": "typescript-clean-and-simple-solution",
                "content": "```\\nfunction frequencySort(nums: number[]): number[] {\\n    \\n    const freq: Record<number, number> = {};\\n    \\n    nums.forEach(num => freq[num] = (freq[num] || 0) + 1);\\n\\n    return nums.sort((a, b) => freq[a] != freq[b] ? freq[a] - freq[b] : b - a);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction frequencySort(nums: number[]): number[] {\\n    \\n    const freq: Record<number, number> = {};\\n    \\n    nums.forEach(num => freq[num] = (freq[num] || 0) + 1);\\n\\n    return nums.sort((a, b) => freq[a] != freq[b] ? freq[a] - freq[b] : b - a);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1452296,
                "title": "c-using-custom-compare",
                "content": "```\\n    static bool comp(pair<int, int> a, pair<int, int> b) {\\n        if(a.second == b.second) {\\n            return a.first > b.first;\\n        }\\n        return a.second < b.second;\\n    }\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int, int> M;\\n        for(auto x: nums) {\\n            M[x]++;\\n        }\\n        \\n        vector<pair<int, int>> elems(M.begin(), M.end());\\n        sort(elems.begin(), elems.end(), comp);\\n        vector<int> res;\\n        for(auto x : elems) {\\n            while(x.second--)\\n                res.push_back(x.first);\\n        }\\n        return res;\\n\\t}",
                "solutionTags": [],
                "code": "```\\n    static bool comp(pair<int, int> a, pair<int, int> b) {\\n        if(a.second == b.second) {\\n            return a.first > b.first;\\n        }\\n        return a.second < b.second;\\n    }\\n    vector<int> frequencySort(vector<int>& nums) {\\n        unordered_map<int, int> M;\\n        for(auto x: nums) {\\n            M[x]++;\\n        }\\n        \\n        vector<pair<int, int>> elems(M.begin(), M.end());\\n        sort(elems.begin(), elems.end(), comp);\\n        vector<int> res;\\n        for(auto x : elems) {\\n            while(x.second--)\\n                res.push_back(x.first);\\n        }\\n        return res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1448133,
                "title": "java-using-map-and-list",
                "content": "# **It\\'s an easy solution. Please, click the arrow up if you like the solution.\\n\\n\\tpublic int[] frequencySort(int[] nums) {\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\n\\t\\t\\tfor(int i = 0;i < nums.length;i++) {\\n\\t\\t\\t\\tlist.add(nums[i]);\\n\\t\\t\\t\\tmap.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tCollections.sort(list, (n1, n2) -> {\\n\\t\\t\\t\\tint freq1 = map.get(n1);\\n\\t\\t\\t\\tint freq2 = map.get(n2);\\n\\n\\t\\t\\t\\tif(freq1 != freq2) {\\n\\t\\t\\t\\t\\treturn freq2 - freq1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn n1 - n2;\\n\\t\\t\\t});\\n\\n\\t\\t\\tCollections.reverse(list);\\n\\n\\t\\t\\tfor(int i = 0;i < nums.length;i++) {\\n\\t\\t\\t\\tnums[i] = list.get(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn nums;\\n\\t\\t}",
                "solutionTags": [],
                "code": "# **It\\'s an easy solution. Please, click the arrow up if you like the solution.\\n\\n\\tpublic int[] frequencySort(int[] nums) {\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\n\\t\\t\\tfor(int i = 0;i < nums.length;i++) {\\n\\t\\t\\t\\tlist.add(nums[i]);\\n\\t\\t\\t\\tmap.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tCollections.sort(list, (n1, n2) -> {\\n\\t\\t\\t\\tint freq1 = map.get(n1);\\n\\t\\t\\t\\tint freq2 = map.get(n2);\\n\\n\\t\\t\\t\\tif(freq1 != freq2) {\\n\\t\\t\\t\\t\\treturn freq2 - freq1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn n1 - n2;\\n\\t\\t\\t});\\n\\n\\t\\t\\tCollections.reverse(list);\\n\\n\\t\\t\\tfor(int i = 0;i < nums.length;i++) {\\n\\t\\t\\t\\tnums[i] = list.get(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn nums;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1440226,
                "title": "c-pairs-easy",
                "content": "```\\nclass Solution {\\n     static bool sortbysec(const pair<int,int>a,const pair<int,int>b){\\n        if(a.second==b.second)\\n            return (a.first>b.first);\\n            \\n        return (a.second<b.second);\\n    }\\npublic:\\n  \\n    vector<int> frequencySort(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<pair<int,int>>v;\\n        vector<int>v1;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++){\\n           m[nums[i]]++;\\n        }\\n        \\n        for(auto it:m){\\n            v.push_back({it.first,it.second});\\n        }\\n        sort(v.begin(),v.end(),sortbysec);\\n        for(auto it:v){\\n            while(it.second--){\\n            v1.push_back(it.first);}\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n     static bool sortbysec(const pair<int,int>a,const pair<int,int>b){\\n        if(a.second==b.second)\\n            return (a.first>b.first);\\n            \\n        return (a.second<b.second);\\n    }\\npublic:\\n  \\n    vector<int> frequencySort(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<pair<int,int>>v;\\n        vector<int>v1;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++){\\n           m[nums[i]]++;\\n        }\\n        \\n        for(auto it:m){\\n            v.push_back({it.first,it.second});\\n        }\\n        sort(v.begin(),v.end(),sortbysec);\\n        for(auto it:v){\\n            while(it.second--){\\n            v1.push_back(it.first);}\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411793,
                "title": "python3-faster-than-94-95-of-the-solutions",
                "content": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        count = {}\\n        for num in nums:\\n            if num not in count:\\n                count[num] = 1\\n            else:\\n                count[num] += 1\\n        l = [(k,v) for k,v in count.items()]\\n        l.sort(key = lambda x:x[0], reverse=True)\\n        l.sort(key = lambda x:x[1])\\n        result = []\\n        for i in l:\\n            result.extend([i[0]]*i[1])\\n        return result",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        count = {}",
                "codeTag": "Java"
            },
            {
                "id": 1336262,
                "title": "c-solution",
                "content": "```csharp\\npublic int[] FrequencySort(int[] nums)\\n{\\n\\treturn nums\\n\\t\\t\\t.GroupBy(x => x)\\n\\t\\t\\t.OrderBy(x => x.Count())\\n\\t\\t\\t.ThenByDescending(x => x.Key)\\n\\t\\t\\t.SelectMany(x => Enumerable.Repeat(x.Key, x.Count()))\\n\\t\\t\\t.ToArray();\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int[] FrequencySort(int[] nums)\\n{\\n\\treturn nums\\n\\t\\t\\t.GroupBy(x => x)\\n\\t\\t\\t.OrderBy(x => x.Count())\\n\\t\\t\\t.ThenByDescending(x => x.Key)\\n\\t\\t\\t.SelectMany(x => Enumerable.Repeat(x.Key, x.Count()))\\n\\t\\t\\t.ToArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1296742,
                "title": "java-map-priorityqueue",
                "content": "```\\npublic int[] frequencySort(int[] nums) {\\n        \\n    Map<Integer, Integer> map = new HashMap<>();\\n\\n\\t\\tfor (int i : nums) {\\n\\t\\t\\tif (!map.containsKey(i)) {\\n\\t\\t\\t\\tmap.put(i, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap.put(i, map.get(i) + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tPriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> a.getValue()==b.getValue() ? b.getKey()-a.getKey() : a.getValue()-b.getValue());\\n\\n\\t\\tfor (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n\\t\\t\\tpq.offer(entry);\\n\\t\\t}\\n\\n\\t\\tint[] array = new int[nums.length];\\n\\t\\tList<Integer> li = new ArrayList<>();\\n\\t\\twhile (!pq.isEmpty()) {\\n\\n\\t\\t\\tint key = pq.peek().getKey();\\n\\t\\t\\tint numoftimes = pq.poll().getValue();\\n\\t\\t\\tfor (int i = 0; i < numoftimes; i++) {\\n\\t\\t\\t\\tli.add(key);\\n\\t\\t\\t}\\n\\t\\t}\\n \\n\\t\\t\\n\\t\\tfor(int i=0;i<li.size();i++){\\n\\t\\t\\tarray[i] = li.get(i);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn array;\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "```\\npublic int[] frequencySort(int[] nums) {\\n        \\n    Map<Integer, Integer> map = new HashMap<>();\\n\\n\\t\\tfor (int i : nums) {\\n\\t\\t\\tif (!map.containsKey(i)) {\\n\\t\\t\\t\\tmap.put(i, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap.put(i, map.get(i) + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tPriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> a.getValue()==b.getValue() ? b.getKey()-a.getKey() : a.getValue()-b.getValue());\\n\\n\\t\\tfor (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n\\t\\t\\tpq.offer(entry);\\n\\t\\t}\\n\\n\\t\\tint[] array = new int[nums.length];\\n\\t\\tList<Integer> li = new ArrayList<>();\\n\\t\\twhile (!pq.isEmpty()) {\\n\\n\\t\\t\\tint key = pq.peek().getKey();\\n\\t\\t\\tint numoftimes = pq.poll().getValue();\\n\\t\\t\\tfor (int i = 0; i < numoftimes; i++) {\\n\\t\\t\\t\\tli.add(key);\\n\\t\\t\\t}\\n\\t\\t}\\n \\n\\t\\t\\n\\t\\tfor(int i=0;i<li.size();i++){\\n\\t\\t\\tarray[i] = li.get(i);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn array;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1292610,
                "title": "simple-easy-understand-java-solution",
                "content": "```\\n  public int[] frequencySort(int[] nums) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int n : nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n        return Arrays.\\n            stream(nums).    //convert array to int stream\\n            boxed().             //convert int to Integer object\\n            sorted(((a,b) -> map.get(a) == map.get(b) ? b - a : map.get(a) - map.get(b))).      //use lamda function as custom sort function\\n            mapToInt(Integer::intValue).   //convert Integer back to int\\n            toArray();       //convert stream back to array\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public int[] frequencySort(int[] nums) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int n : nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n        return Arrays.\\n            stream(nums).    //convert array to int stream\\n            boxed().             //convert int to Integer object\\n            sorted(((a,b) -> map.get(a) == map.get(b) ? b - a : map.get(a) - map.get(b))).      //use lamda function as custom sort function\\n            mapToInt(Integer::intValue).   //convert Integer back to int\\n            toArray();       //convert stream back to array\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1195064,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        #sort the nums in reverse order so maching values are sorted by decreasing order of their keys\\n        nums.sort(reverse = True)\\n\\n        #Sort them according to their counts\\n        ans = sorted(nums, key = nums.count)\\n        \\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        #sort the nums in reverse order so maching values are sorted by decreasing order of their keys\\n        nums.sort(reverse = True)\\n\\n        #Sort them according to their counts\\n        ans = sorted(nums, key = nums.count)\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1126753,
                "title": "kotlin-1-line",
                "content": "```\\nfun frequencySort(ar: IntArray) = ar.sortedWith(compareBy<Int> { n -> ar.count { it == n } }.thenByDescending { it }).toIntArray()\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun frequencySort(ar: IntArray) = ar.sortedWith(compareBy<Int> { n -> ar.count { it == n } }.thenByDescending { it }).toIntArray()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1124134,
                "title": "simple-heap-java-solution",
                "content": "```\\n    private static int[] frequencySort(int[] nums) {\\n        // nums -> [1,1,2,2,2,3]\\n        Map<Integer, Integer> numberToOccurances = new HashMap<>();\\n        for (Integer i : nums) {\\n            numberToOccurances.put(i, numberToOccurances.getOrDefault(i, 0) + 1);\\n        }\\n        // numberToOccurances-> {1:2},{2:3}, {3:1}\\n        Queue<Integer> heap = new PriorityQueue<>((e1, e2) -> numberToOccurances.get(e1).equals(numberToOccurances.get(e2)) ?\\n                e2 - e1 :\\n                numberToOccurances.get(e1) - numberToOccurances.get(e2));\\n\\n        for (Integer i : numberToOccurances.keySet()) {\\n            heap.offer(i);\\n        }\\n        // heap -> 3, 1, 2 - according to frequencies 3 is met 1 time, 1 -> 2 times & 2 -> 3 times\\n        int[] result = new int[nums.length];\\n        int index = 0;\\n        while (!heap.isEmpty()) {\\n            Integer num = heap.poll();\\n            int iterations = numberToOccurances.get(num);\\n            for (int i = 1; i <= iterations; i++) {\\n                result[index] = num;\\n                index++;\\n            }\\n\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private static int[] frequencySort(int[] nums) {\\n        // nums -> [1,1,2,2,2,3]\\n        Map<Integer, Integer> numberToOccurances = new HashMap<>();\\n        for (Integer i : nums) {\\n            numberToOccurances.put(i, numberToOccurances.getOrDefault(i, 0) + 1);\\n        }\\n        // numberToOccurances-> {1:2},{2:3}, {3:1}\\n        Queue<Integer> heap = new PriorityQueue<>((e1, e2) -> numberToOccurances.get(e1).equals(numberToOccurances.get(e2)) ?\\n                e2 - e1 :\\n                numberToOccurances.get(e1) - numberToOccurances.get(e2));\\n\\n        for (Integer i : numberToOccurances.keySet()) {\\n            heap.offer(i);\\n        }\\n        // heap -> 3, 1, 2 - according to frequencies 3 is met 1 time, 1 -> 2 times & 2 -> 3 times\\n        int[] result = new int[nums.length];\\n        int index = 0;\\n        while (!heap.isEmpty()) {\\n            Integer num = heap.poll();\\n            int iterations = numberToOccurances.get(num);\\n            for (int i = 1; i <= iterations; i++) {\\n                result[index] = num;\\n                index++;\\n            }\\n\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1099565,
                "title": "java-count-sort-variation-2ms-beats-99-31-o-nums-length",
                "content": "\\n    public int[] frequencySort(int[] nums) {\\n\\n\\t\\tint[] count = new int[201];\\n\\t\\tList<Integer>[] temp = new ArrayList[101];\\n\\t\\tfor (int i = 0; i < 101; i++)\\n\\t\\t\\ttemp[i] = new ArrayList<Integer>();\\n\\n\\t\\tfor (int num : nums)\\n\\t\\t\\tcount[num + 100]++;\\n\\n\\t\\tfor (int i = 0; i < 201; i++) {\\n\\t\\t\\tif (count[i] > 0)\\n\\t\\t\\t\\ttemp[count[i]].add(i - 100);\\n\\t\\t}\\n\\n\\t\\tint idx = 0;\\n\\t\\tfor (int i = 0; i < 101; i++) {\\n\\t\\t\\tif (temp[i].size() != 0) {\\n\\t\\t\\t\\tList<Integer> freq = temp[i];\\n\\t\\t\\t\\tint len = freq.size();\\n\\t\\t\\t\\tfor (int j = len - 1; j >= 0; j--) {\\n\\t\\t\\t\\t\\tfor (int k = 0; k < i; k++)\\n\\t\\t\\t\\t\\t\\tnums[idx++] = freq.get(j);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn nums;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    public int[] frequencySort(int[] nums) {\\n\\n\\t\\tint[] count = new int[201];\\n\\t\\tList<Integer>[] temp = new ArrayList[101];\\n\\t\\tfor (int i = 0; i < 101; i++)\\n\\t\\t\\ttemp[i] = new ArrayList<Integer>();\\n\\n\\t\\tfor (int num : nums)\\n\\t\\t\\tcount[num + 100]++;\\n\\n\\t\\tfor (int i = 0; i < 201; i++) {\\n\\t\\t\\tif (count[i] > 0)\\n\\t\\t\\t\\ttemp[count[i]].add(i - 100);\\n\\t\\t}\\n\\n\\t\\tint idx = 0;\\n\\t\\tfor (int i = 0; i < 101; i++) {\\n\\t\\t\\tif (temp[i].size() != 0) {\\n\\t\\t\\t\\tList<Integer> freq = temp[i];\\n\\t\\t\\t\\tint len = freq.size();\\n\\t\\t\\t\\tfor (int j = len - 1; j >= 0; j--) {\\n\\t\\t\\t\\t\\tfor (int k = 0; k < i; k++)\\n\\t\\t\\t\\t\\t\\tnums[idx++] = freq.get(j);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn nums;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1068061,
                "title": "c-easy-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& arr) {\\n        \\n        unordered_map<int,int> mp;        // count the values and no need of ordering\\n        \\n        for(int i = 0;i < arr.size();i++){\\n            mp[arr[i]]++;\\n        }\\n        \\n        map<int,vector<int>> temp;       \\n        \\n        for(auto it : mp){          // reverse the map \\'mp\\' and order based on count\\n            temp[it.second].push_back(it.first);\\n        }\\n        \\n        arr = {};\\n        for(auto it : temp){\\n            sort(it.second.begin(),it.second.end());        // sort the same counted numbers and start adding it to new array\\n            for(int i = it.second.size() - 1;i >= 0;i--){\\n                for(int j = 0;j < it.first;j++)\\n                    arr.push_back(it.second[i]);\\n            }\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> frequencySort(vector<int>& arr) {\\n        \\n        unordered_map<int,int> mp;        // count the values and no need of ordering\\n        \\n        for(int i = 0;i < arr.size();i++){\\n            mp[arr[i]]++;\\n        }\\n        \\n        map<int,vector<int>> temp;       \\n        \\n        for(auto it : mp){          // reverse the map \\'mp\\' and order based on count\\n            temp[it.second].push_back(it.first);\\n        }\\n        \\n        arr = {};\\n        for(auto it : temp){\\n            sort(it.second.begin(),it.second.end());        // sort the same counted numbers and start adding it to new array\\n            for(int i = it.second.size() - 1;i >= 0;i--){\\n                for(int j = 0;j < it.first;j++)\\n                    arr.push_back(it.second[i]);\\n            }\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063132,
                "title": "javascript-solution-using-maps",
                "content": "```\\nvar frequencySort = function(nums) {\\n    let result = [];\\n    let map =new Map();\\n    for(let i=0;i<nums.length;i++){\\n        if(map.has(nums[i])) map.set(nums[i],map.get(nums[i])+1);\\n        else map.set(nums[i],1);\\n    }\\n    map = new Map([...map].sort((a,b)=>a[1]===b[1]?b[0]-a[0] :a[1]-b[1]));\\n    for(let [key,value] of map){\\n        while(value>0){\\n            result.push(key);\\n            value--;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar frequencySort = function(nums) {\\n    let result = [];\\n    let map =new Map();\\n    for(let i=0;i<nums.length;i++){\\n        if(map.has(nums[i])) map.set(nums[i],map.get(nums[i])+1);\\n        else map.set(nums[i],1);\\n    }\\n    map = new Map([...map].sort((a,b)=>a[1]===b[1]?b[0]-a[0] :a[1]-b[1]));\\n    for(let [key,value] of map){\\n        while(value>0){\\n            result.push(key);\\n            value--;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1049340,
                "title": "bucket-sort-java-o-n",
                "content": "```\\n    public int[] frequencySort(int[] nums) {\\n        int[] freq = new int[201];\\n        for (int num : nums)\\n            freq[num+100]++;\\n        \\n        int n = nums.length;\\n        List<Integer>[] buckets = new List[n+1];\\n        for (int num = 0; num < 201; ++num) {\\n            if (freq[num] == 0) continue;\\n            \\n            if (buckets[freq[num]] == null)\\n                buckets[freq[num]] = new ArrayList<>();\\n            buckets[freq[num]].add(num-100);\\n        }\\n        \\n        int i = 0;\\n        for (int f = 1; f <= n; ++f) {\\n            if (buckets[f] == null) continue;\\n            \\n            for (int b = buckets[f].size()-1; b >= 0; --b) { // since we added elements in incresing order\\n                for (int j = 1; j <= f; ++j) \\n                    nums[i++] = buckets[f].get(b);\\n            }\\n        }\\n        \\n        return nums;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] frequencySort(int[] nums) {\\n        int[] freq = new int[201];\\n        for (int num : nums)\\n            freq[num+100]++;\\n        \\n        int n = nums.length;\\n        List<Integer>[] buckets = new List[n+1];\\n        for (int num = 0; num < 201; ++num) {\\n            if (freq[num] == 0) continue;\\n            \\n            if (buckets[freq[num]] == null)\\n                buckets[freq[num]] = new ArrayList<>();\\n            buckets[freq[num]].add(num-100);\\n        }\\n        \\n        int i = 0;\\n        for (int f = 1; f <= n; ++f) {\\n            if (buckets[f] == null) continue;\\n            \\n            for (int b = buckets[f].size()-1; b >= 0; --b) { // since we added elements in incresing order\\n                for (int j = 1; j <= f; ++j) \\n                    nums[i++] = buckets[f].get(b);\\n            }\\n        }\\n        \\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1038217,
                "title": "javascript-1-line-solution",
                "content": "```\\nreturn nums.sort((a,b)=>nums.filter(x=>x===a).length-nums.filter(x=>x===b).length || b-a);\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nreturn nums.sort((a,b)=>nums.filter(x=>x===a).length-nums.filter(x=>x===b).length || b-a);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1033968,
                "title": "python-beat-97-using-counter-and-sort",
                "content": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        freq = collections.Counter(nums)\\n        nums.sort(key = lambda x : (freq[x], -x))\\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        freq = collections.Counter(nums)\\n        nums.sort(key = lambda x : (freq[x], -x))\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027101,
                "title": "java-w-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        \\n                int[] sorted = new int[nums.length];\\n\\n        Map<Integer, Integer> numsMap = new HashMap<>();\\n\\n        for(int num : nums) numsMap.put(num, numsMap.getOrDefault(num, 0)+1);\\n\\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<Map.Entry<Integer, Integer>>(new Comparator<Map.Entry<Integer, Integer>>() {\\n            @Override\\n            public int compare(Map.Entry<Integer, Integer> e1, Map.Entry<Integer, Integer> e2) {\\n                int c = e1.getValue() - e2.getValue();\\n                if(c == 0) return e2.getKey() - e1.getKey();\\n                else return c;\\n            }\\n        });\\n\\n        //for(Map.Entry<Integer, Integer> numsMapentry : numsMap.entrySet()) pq.add(numsMapentry);\\n        pq.addAll(numsMap.entrySet());\\n        int index = 0;\\n        while(!pq.isEmpty()) {\\n            Map.Entry<Integer, Integer> current = pq.poll();\\n            for(int i=0; i< current.getValue(); i++) sorted[index++] = current.getKey();\\n        }\\n\\n        \\n        //System.out.println(numsMap);\\n\\n        return sorted;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        \\n                int[] sorted = new int[nums.length];\\n\\n        Map<Integer, Integer> numsMap = new HashMap<>();\\n\\n        for(int num : nums) numsMap.put(num, numsMap.getOrDefault(num, 0)+1);\\n\\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<Map.Entry<Integer, Integer>>(new Comparator<Map.Entry<Integer, Integer>>() {\\n            @Override\\n            public int compare(Map.Entry<Integer, Integer> e1, Map.Entry<Integer, Integer> e2) {\\n                int c = e1.getValue() - e2.getValue();\\n                if(c == 0) return e2.getKey() - e1.getKey();\\n                else return c;\\n            }\\n        });\\n\\n        //for(Map.Entry<Integer, Integer> numsMapentry : numsMap.entrySet()) pq.add(numsMapentry);\\n        pq.addAll(numsMap.entrySet());\\n        int index = 0;\\n        while(!pq.isEmpty()) {\\n            Map.Entry<Integer, Integer> current = pq.poll();\\n            for(int i=0; i< current.getValue(); i++) sorted[index++] = current.getKey();\\n        }\\n\\n        \\n        //System.out.println(numsMap);\\n\\n        return sorted;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025399,
                "title": "java-using-heap",
                "content": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int m = 0;\\n        int [] result = new int[nums.length];\\n        for(int i=0;i<nums.length;i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i],0)+1);\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(nums.length, (a,b) -> map.get(a).equals(map.get(b))? b-a : map.get(a)-map.get(b));\\n        for(int i: map.keySet()) {\\n            pq.add(i);\\n        }\\n        while(pq.size() > 0) {\\n            int num  = pq.poll();\\n            int freq =  map.get(num);\\n            for(int i=0;i<freq;i++) {\\n                result[m++] = num;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int m = 0;\\n        int [] result = new int[nums.length];\\n        for(int i=0;i<nums.length;i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i],0)+1);\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(nums.length, (a,b) -> map.get(a).equals(map.get(b))? b-a : map.get(a)-map.get(b));\\n        for(int i: map.keySet()) {\\n            pq.add(i);\\n        }\\n        while(pq.size() > 0) {\\n            int num  = pq.poll();\\n            int freq =  map.get(num);\\n            for(int i=0;i<freq;i++) {\\n                result[m++] = num;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986778,
                "title": "swift-easy-way-hashmap-dictionary",
                "content": "\\n```swift\\n    func frequencySort(_ nums: [Int]) -> [Int] {\\n        var dict = [Int: Int]()\\n        \\n        for num in nums {\\n            dict[num] = (dict[num] ?? 0) + 1\\n        }\\n\\n        return dict\\n            .sorted { $1.key < $0.key }\\n            .sorted { $0.value < $1.value }\\n            .map { [Int](repeating: $0.key, count: $0.value) }\\n            .flatMap { $0 }\\n    }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\n    func frequencySort(_ nums: [Int]) -> [Int] {\\n        var dict = [Int: Int]()\\n        \\n        for num in nums {\\n            dict[num] = (dict[num] ?? 0) + 1\\n        }\\n\\n        return dict\\n            .sorted { $1.key < $0.key }\\n            .sorted { $0.value < $1.value }\\n            .map { [Int](repeating: $0.key, count: $0.value) }\\n            .flatMap { $0 }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 939586,
                "title": "straight-forward-with-custom-comparator",
                "content": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n        List l<Integer> = new ArrayList();\\n        for (int i : nums){\\n            int oc = m.getOrDefault(i,0);\\n            l.add(i);\\n            m.put(i, ++oc);\\n        }\\n\\n        l.sort((a, b) -> {\\n            int c = Integer.compare(m.get(a), m.get(b));\\n            if (c == 0) return Integer.compare((Integer) a, (Integer) b) * -1;\\n            return c;\\n        });\\n        for (int i = 0; i < l.size(); i++) {\\n            nums[i] = (Integer) l.get(i);\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] frequencySort(int[] nums) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n        List l<Integer> = new ArrayList();\\n        for (int i : nums){\\n            int oc = m.getOrDefault(i,0);\\n            l.add(i);\\n            m.put(i, ++oc);\\n        }\\n\\n        l.sort((a, b) -> {\\n            int c = Integer.compare(m.get(a), m.get(b));\\n            if (c == 0) return Integer.compare((Integer) a, (Integer) b) * -1;\\n            return c;\\n        });\\n        for (int i = 0; i < l.size(); i++) {\\n            nums[i] = (Integer) l.get(i);\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923712,
                "title": "python-counting-sort-time-o-n-space-o-n",
                "content": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        counts = [0] * 201  # -100 <= nums[i] <= 100      \\n        for n in nums:\\n            counts[n + 100] += 1\\n            \\n        freqs = [[] for _ in range(101)]  # 1 <= nums.length <= 100\\n        for n in range(200, -1, -1):\\n            if counts[n]:\\n                freqs[counts[n]].append(n-100)\\n        \\n        result = []\\n        for freq, arr in enumerate(freqs):\\n            for n in arr:\\n                result.extend([n] * freq)\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        counts = [0] * 201  # -100 <= nums[i] <= 100      \\n        for n in nums:\\n            counts[n + 100] += 1\\n            \\n        freqs = [[] for _ in range(101)]  # 1 <= nums.length <= 100\\n        for n in range(200, -1, -1):\\n            if counts[n]:\\n                freqs[counts[n]].append(n-100)\\n        \\n        result = []\\n        for freq, arr in enumerate(freqs):\\n            for n in arr:\\n                result.extend([n] * freq)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923008,
                "title": "java-priorityqueue",
                "content": "```\\npublic int[] frequencySort(int[] nums) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tPriorityQueue<Integer> queue = new PriorityQueue<>((x,y) -> map.get(x) == map.get(y) ? y-x:map.get(x) - map.get(y));\\n\\tfor(int i: nums) \\n\\t\\tmap.put(i, map.getOrDefault(i, 0) + 1);\\n\\tfor(int i: nums) \\n\\t\\tqueue.offer(i);\\n\\tint[] result = new int[nums.length];\\n\\tint currentIndex = 0;\\n\\twhile(!queue.isEmpty())\\n\\t\\tresult[currentIndex++] = queue.poll();\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] frequencySort(int[] nums) {\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tPriorityQueue<Integer> queue = new PriorityQueue<>((x,y) -> map.get(x) == map.get(y) ? y-x:map.get(x) - map.get(y));\\n\\tfor(int i: nums) \\n\\t\\tmap.put(i, map.getOrDefault(i, 0) + 1);\\n\\tfor(int i: nums) \\n\\t\\tqueue.offer(i);\\n\\tint[] result = new int[nums.length];\\n\\tint currentIndex = 0;\\n\\twhile(!queue.isEmpty())\\n\\t\\tresult[currentIndex++] = queue.poll();\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 920751,
                "title": "python-o-n-log-n-by-sorting-w-comment",
                "content": "Sort number by pair of (frequency, and negative value)\\n\\n---\\n\\n**Implementation**\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        \\n\\t\\t# key: distinct number\\n\\t\\t# value: frequency of number\\n        num_occ_dict = Counter(nums)\\n        \\n\\t\\t# Sort number by pair of (frequency, and negative value)\\n        nums.sort( key=lambda x:(num_occ_dict[x], -x) )\\n        \\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def frequencySort(self, nums: List[int]) -> List[int]:\\n        \\n\\t\\t# key: distinct number\\n\\t\\t# value: frequency of number\\n        num_occ_dict = Counter(nums)\\n        \\n\\t\\t# Sort number by pair of (frequency, and negative value)\\n        nums.sort( key=lambda x:(num_occ_dict[x], -x) )\\n        \\n        return nums\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1743182,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 1734524,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 1787486,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 1759022,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 1963831,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 1901893,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 1879239,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 2033335,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 2019134,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 2015081,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 1743182,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 1734524,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 1787486,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 1759022,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 1963831,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 1901893,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 1879239,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 2033335,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 2019134,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            },
            {
                "id": 2015081,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "How can this be an easy problem ?\\nIt includes combination of advance topics of comparator and hashmap..\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\uD83D\\uDE25"
                    },
                    {
                        "username": "NoobCoder21Id",
                        "content": "How is comparator advanced? \\uD83E\\uDD14"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "[@bparanj](/bparanj)  3242 submissions this year crazy!!!\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "There should be a new category called Super Easy. This will stay in Easy."
                    },
                    {
                        "username": "stan5050",
                        "content": "As I\\'ve realized, some easy problems for one language are difficult for another and vice versa. In Python it took me 3 mins. But some other easy task I even can not start solving them :))))"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "brother comparator and hashmap is basics\\n"
                    },
                    {
                        "username": "Partharora_07",
                        "content": "This is not a easy ;__;"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not easy!"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        // for(auto x:nums){\\n        //     mp[x]++;\\n        // }\\n        sort(nums.begin(),nums.end(),[&](int a,int b){\\n           return mp[a]!=mp[b]?mp[a]<mp[b]:a>b;\\n        });\\n        return nums;\\n    }"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "okay bye\\n"
                    },
                    {
                        "username": "abhishektwistedlimestone",
                        "content": "Why the Testcase [1,5,0,5] doesn\\'t accept the answer [0,1,5,5]?"
                    },
                    {
                        "username": "Gellert_Grindelwald",
                        "content": "because it will expect [1, 0, 5, 5] as elements of same frequency has to be sorted in decreasing order"
                    },
                    {
                        "username": "HackSparrow",
                        "content": "Frequency of 0 and 1 is same, so you have to push them in decreasing order, so correct answer would be [1,0,5,5]"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "imo this is a very easy problem (atleast in terms of getting intuition) .But without knowledge of comparators it maybe challenging!!!"
                    },
                    {
                        "username": "District_12",
                        "content": "Pretty interesting problem for low level languages."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Even if you know comparator, it is a medium!"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.groupBy { it }.entries.sortedBy { it.value.size }.groupBy { it.value.size }.values\\n            .flatMap { it.flatMap { it.value }.sortedDescending() }.toIntArray()"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Strings That Appear as Substrings in Word",
        "question_content": "<p>Given an array of strings <code>patterns</code> and a string <code>word</code>, return <em>the <strong>number</strong> of strings in </em><code>patterns</code><em> that exist as a <strong>substring</strong> in </em><code>word</code>.</p>\n\n<p>A <strong>substring</strong> is a contiguous sequence of characters within a string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> patterns = [&quot;a&quot;,&quot;abc&quot;,&quot;bc&quot;,&quot;d&quot;], word = &quot;abc&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\n- &quot;a&quot; appears as a substring in &quot;<u>a</u>bc&quot;.\n- &quot;abc&quot; appears as a substring in &quot;<u>abc</u>&quot;.\n- &quot;bc&quot; appears as a substring in &quot;a<u>bc</u>&quot;.\n- &quot;d&quot; does not appear as a substring in &quot;abc&quot;.\n3 of the strings in patterns appear as a substring in word.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> patterns = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], word = &quot;aaaaabbbbb&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\n- &quot;a&quot; appears as a substring in &quot;a<u>a</u>aaabbbbb&quot;.\n- &quot;b&quot; appears as a substring in &quot;aaaaabbbb<u>b</u>&quot;.\n- &quot;c&quot; does not appear as a substring in &quot;aaaaabbbbb&quot;.\n2 of the strings in patterns appear as a substring in word.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> patterns = [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;], word = &quot;ab&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Each of the patterns appears as a substring in word &quot;<u>a</u>b&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= patterns.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= patterns[i].length &lt;= 100</code></li>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>patterns[i]</code> and <code>word</code> consist of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1404046,
                "title": "c-no-fancy-o-nm-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count=0;\\n        for(int i=0;i<patterns.size();i++)\\n        {\\n            if(word.find(patterns[i])!=string::npos)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count=0;\\n        for(int i=0;i<patterns.size();i++)\\n        {\\n            if(word.find(patterns[i])!=string::npos)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404687,
                "title": "python-aho-corasick-algorithm-kmp-trie-o-n-m",
                "content": "Construct Tree by Trie and KMP, also known as **Aho\\u2013Corasick Algorithm**, that we can just traversal the word in one time then getting all matched patterns.\\nIt can support large patterns and word.\\n\\n- N = total patterns length\\n- M = word length\\n\\nIf we find \"cba\" in the Trie, that means we also find \"ba\" and \"a\" respectively.\\nSo for each current node, we need to traversal all fail nodes to check whether it is also the end of some ptterns.\\nBut we just want to find each pattern once, so I define **node.used** to prevent the duplicate checking.\\n\\n![image](https://assets.leetcode.com/users/images/7dfb3bb4-79ae-457f-ac59-94cd364d6f0a_1629090564.6261506.png)\\n\\n```Python\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = dict()\\n        self.end = 0\\n        self.fail = None\\n        self.used = False\\n\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        root = Node(\\'ROOT\\')\\n        for pattern in patterns:\\n            node = root\\n            for x in pattern:\\n                if x not in node.next:\\n                    node.next[x] = Node(x)\\n                node = node.next[x]\\n            node.end += 1\\n            \\n        queue = collections.deque([root])\\n        while queue:\\n            pnode = queue.popleft()\\n            for x, nnode in pnode.next.items():\\n                if pnode == root:\\n                    nnode.fail = pnode\\n                else:\\n                    ptr = pnode.fail\\n                    while ptr != root and x not in ptr.next:\\n                        ptr = ptr.fail\\n                    if x in ptr.next:\\n                        ptr = ptr.next[x]\\n                    nnode.fail = ptr\\n                queue.append(nnode)\\n        \\n        res = 0\\n        ptr = root\\n        for x in word:\\n            while ptr != root and x not in ptr.next:\\n                ptr = ptr.fail\\n            if x in ptr.next:\\n                ptr = ptr.next[x]\\n            tmp = ptr\\n            while tmp != root and tmp.used == False:\\n                res += tmp.end\\n                tmp.used = True\\n                tmp = tmp.fail\\n                \\n        return res\\n```\\n\\n",
                "solutionTags": [],
                "code": "```Python\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = dict()\\n        self.end = 0\\n        self.fail = None\\n        self.used = False\\n\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        root = Node(\\'ROOT\\')\\n        for pattern in patterns:\\n            node = root\\n            for x in pattern:\\n                if x not in node.next:\\n                    node.next[x] = Node(x)\\n                node = node.next[x]\\n            node.end += 1\\n            \\n        queue = collections.deque([root])\\n        while queue:\\n            pnode = queue.popleft()\\n            for x, nnode in pnode.next.items():\\n                if pnode == root:\\n                    nnode.fail = pnode\\n                else:\\n                    ptr = pnode.fail\\n                    while ptr != root and x not in ptr.next:\\n                        ptr = ptr.fail\\n                    if x in ptr.next:\\n                        ptr = ptr.next[x]\\n                    nnode.fail = ptr\\n                queue.append(nnode)\\n        \\n        res = 0\\n        ptr = root\\n        for x in word:\\n            while ptr != root and x not in ptr.next:\\n                ptr = ptr.fail\\n            if x in ptr.next:\\n                ptr = ptr.next[x]\\n            tmp = ptr\\n            while tmp != root and tmp.used == False:\\n                res += tmp.end\\n                tmp.used = True\\n                tmp = tmp.fail\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404073,
                "title": "python3-1-line",
                "content": "\\n```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return sum(x in word for x in patterns)\\n```\\n\\nYou can find the solutions to weekly 254 in this [repo](https://github.com/gaosanyong/leetcode/commit/dcc452fea7d159bd4fae8318c14d546f17783894).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return sum(x in word for x in patterns)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403958,
                "title": "java-c-python-brute-force-o-nm",
                "content": "For every pattern, check if it is contained within the `word`.\\nChecking if a word is contained inside another word is O(N+M) if the underlying library usages KMP.\\n\\n\\nJava\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int res = 0;\\n        for(String p: patterns){\\n            if(word.contains(p)){\\n                res ++;\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```\\n\\n\\nPython\\n```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        res = 0\\n        for p in patterns:\\n            if p in word:\\n                res +=1\\n        return res\\n            \\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int res = 0;\\n        for(string &p: patterns){\\n            if(word.find(p) != std::string::npos){\\n                res ++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int res = 0;\\n        for(String p: patterns){\\n            if(word.contains(p)){\\n                res ++;\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        res = 0\\n        for p in patterns:\\n            if p in word:\\n                res +=1\\n        return res\\n            \\n```\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int res = 0;\\n        for(string &p: patterns){\\n            if(word.find(p) != std::string::npos){\\n                res ++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484131,
                "title": "java-clean-and-easy-solution-2-approaches",
                "content": "**Do vote up if you like it :)**\\n\\nUsing contains() method of String class, \\nInternal implementaion of contains() method maybe:\\n->Boyer-moore takes O(nm) time in the worst case.\\n->KMP takes O(n) time in the worst case.\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(String pattern : patterns) {\\n            if(word.contains(pattern)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n-------------------------------------------------------------\\nBrute Force Solution\\nAll Substring Solution\\nTC: O(N^2)\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int wordLen = word.length();\\n        Set<String> set = new HashSet<>();\\n        for(int start = 0; start < wordLen; start++) {\\n            StringBuilder sb = new StringBuilder();\\n            for(int end = start; end < wordLen; end++){\\n                sb.append(word.charAt(end));\\n                set.add(sb.toString());\\n            }\\n        }\\n        \\n        int count = 0, pattLen = patterns.length;\\n        for(int i = 0; i < pattLen; i++){\\n            if(set.contains(patterns[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(String pattern : patterns) {\\n            if(word.contains(pattern)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int wordLen = word.length();\\n        Set<String> set = new HashSet<>();\\n        for(int start = 0; start < wordLen; start++) {\\n            StringBuilder sb = new StringBuilder();\\n            for(int end = start; end < wordLen; end++){\\n                sb.append(word.charAt(end));\\n                set.add(sb.toString());\\n            }\\n        }\\n        \\n        int count = 0, pattLen = patterns.length;\\n        for(int i = 0; i < pattLen; i++){\\n            if(set.contains(patterns[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520913,
                "title": "c-python-1-line-simple-solution",
                "content": "**C++ :**\\n\\n```\\nint numOfStrings(vector<string>& patterns, string word) {\\n        int counter = 0;\\n        \\n        for(auto p: patterns)\\n            if(word.find(p) != std::string::npos)\\n                ++counter;\\n        \\n        return counter;\\n    }\\n```\\n\\n**Python :**\\n\\n```\\ndef numOfStrings(self, patterns: List[str], word: str) -> int:\\n\\treturn len([p for p in patterns if p in word])\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nint numOfStrings(vector<string>& patterns, string word) {\\n        int counter = 0;\\n        \\n        for(auto p: patterns)\\n            if(word.find(p) != std::string::npos)\\n                ++counter;\\n        \\n        return counter;\\n    }\\n```\n```\\ndef numOfStrings(self, patterns: List[str], word: str) -> int:\\n\\treturn len([p for p in patterns if p in word])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1404381,
                "title": "c-one-liner",
                "content": "Note that the `find` function in C++ is O(n + m), as it uses KPM.\\n**C++**\\n```cpp\\nint numOfStrings(vector<string>& ps, string word) {\\n    return count_if(begin(ps), end(ps), [&](const auto &p) { return word.find(p) != string::npos; });\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint numOfStrings(vector<string>& ps, string word) {\\n    return count_if(begin(ps), end(ps), [&](const auto &p) { return word.find(p) != string::npos; });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1404065,
                "title": "cpp-kmp",
                "content": "```\\nclass Solution {\\npublic:\\n    void compute(int lps[],string pat){\\n        \\n         int n = pat.size();\\n         int i = 1;\\n         int len = 0;\\n         lps[0] = 0;\\n         while(i < n){\\n             \\n              if(pat[i] == pat[len]){\\n                  \\n                    len += 1;\\n                    lps[i] = len;\\n                    i++;\\n              }\\n              else{\\n                  \\n                    if(len != 0){\\n                        \\n                        len = lps[len-1];\\n                    }\\n                    else{\\n                           lps[i] = 0;\\n                           i+=1;\\n                    }\\n              }\\n         }\\n    }\\n    \\n    bool check(string word,string pat){\\n        \\n          int lps[pat.size()];\\n          int i = 0, j = 0;\\n        \\n          compute(lps,pat);\\n        \\n          while(i<word.size()  &&  j < pat.size()){\\n              \\n                 if(word[i] == pat[j]){\\n                      i++;\\n                      j++;\\n                 }\\n                 if(j == pat.size()) return true;\\n                 if(i < word.size() && word[i] != pat[j]){\\n                     \\n                       if(j != 0){\\n                             j = lps[j-1];\\n                       }\\n                       else{\\n                             i++;\\n                       }\\n                 }\\n          }\\n        return false;\\n    }\\n    \\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int ans = 0;\\n        for(auto s : patterns){\\n            \\n             if(check(word,s)){\\n                 \\n                  ans += 1;\\n             }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void compute(int lps[],string pat){\\n        \\n         int n = pat.size();\\n         int i = 1;\\n         int len = 0;\\n         lps[0] = 0;\\n         while(i < n){\\n             \\n              if(pat[i] == pat[len]){\\n                  \\n                    len += 1;\\n                    lps[i] = len;\\n                    i++;\\n              }\\n              else{\\n                  \\n                    if(len != 0){\\n                        \\n                        len = lps[len-1];\\n                    }\\n                    else{\\n                           lps[i] = 0;\\n                           i+=1;\\n                    }\\n              }\\n         }\\n    }\\n    \\n    bool check(string word,string pat){\\n        \\n          int lps[pat.size()];\\n          int i = 0, j = 0;\\n        \\n          compute(lps,pat);\\n        \\n          while(i<word.size()  &&  j < pat.size()){\\n              \\n                 if(word[i] == pat[j]){\\n                      i++;\\n                      j++;\\n                 }\\n                 if(j == pat.size()) return true;\\n                 if(i < word.size() && word[i] != pat[j]){\\n                     \\n                       if(j != 0){\\n                             j = lps[j-1];\\n                       }\\n                       else{\\n                             i++;\\n                       }\\n                 }\\n          }\\n        return false;\\n    }\\n    \\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int ans = 0;\\n        for(auto s : patterns){\\n            \\n             if(check(word,s)){\\n                 \\n                  ans += 1;\\n             }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407755,
                "title": "c-c-two-simple-and-easy-3-line-solutions-0ms-faster-than-100",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int res = 0;\\n        for (auto p : patterns) if (word.find(p) != -1) res++;\\n        return res;\\n    }\\n};\\n```\\n**C:**\\n```\\nint numOfStrings(char ** patterns, int patternsSize, char * word){\\n    int res = 0;\\n    for (int i = 0; i < patternsSize; i++)\\n        if (strstr(word, patterns[i])) res++;\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int res = 0;\\n        for (auto p : patterns) if (word.find(p) != -1) res++;\\n        return res;\\n    }\\n};\\n```\n```\\nint numOfStrings(char ** patterns, int patternsSize, char * word){\\n    int res = 0;\\n    for (int i = 0; i < patternsSize; i++)\\n        if (strstr(word, patterns[i])) res++;\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033599,
                "title": "c-easy-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count=0;\\n        for(auto ch:patterns){\\n                if(word.find(ch)!=-1) //means few wrds has matched thats\\'s why its nt equal to -1\\n                count++;\\n            }  \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count=0;\\n        for(auto ch:patterns){\\n                if(word.find(ch)!=-1) //means few wrds has matched thats\\'s why its nt equal to -1\\n                count++;\\n            }  \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745088,
                "title": "java-easy-efficient-3-lines-code",
                "content": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int words = 0;\\n        for(int i = 0; i < patterns.length; i++) if(word.contains(patterns[i])) words++;\\n        return words;\\n    }\\n}\\n```\\nPlease  **UPVOTE** if you find this helpful : )\\nThanks.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int words = 0;\\n        for(int i = 0; i < patterns.length; i++) if(word.contains(patterns[i])) words++;\\n        return words;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411204,
                "title": "brute-force-solution-o-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int n = patterns.size(), count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            string temp = patterns[i];\\n            int len = temp.length();\\n            \\n            // for each word in pattern, search it in word\\n            \\n            for(int j = 0; j < word.length(); j++)\\n            {\\n                if(temp == word.substr(j, len))\\n                {\\n                    count++;\\n                    break;\\n                }    \\n            }\\n        }       \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int n = patterns.size(), count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            string temp = patterns[i];\\n            int len = temp.length();\\n            \\n            // for each word in pattern, search it in word\\n            \\n            for(int j = 0; j < word.length(); j++)\\n            {\\n                if(temp == word.substr(j, len))\\n                {\\n                    count++;\\n                    break;\\n                }    \\n            }\\n        }       \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523906,
                "title": "simple-java-solution-100-faster",
                "content": "\\n\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(int i=0;i<patterns.length;i++){\\n            if(word.contains(patterns[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(int i=0;i<patterns.length;i++){\\n            if(word.contains(patterns[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404563,
                "title": "c-javascript-typescript-1-liner-easysimple",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        return count_if(begin(patterns),end(patterns),\\n\\t\\t\\t[&word](string &a){return word.find(a)!=string::npos;});\\n    }\\n};\\n```\\n\\n# JavaScript\\n```\\n/**\\n * @param {string[]} patterns\\n * @param {string} word\\n * @return {number}\\n */\\nvar numOfStrings = function(patterns, word) {\\n    return [...patterns].filter(x=>word.includes(x)).length;\\n};\\n```\\n# TypeScript\\n```\\nfunction numOfStrings(patterns: string[], word: string): number {\\n    return [...patterns].filter(x=>word.includes(x)).length;\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        return count_if(begin(patterns),end(patterns),\\n\\t\\t\\t[&word](string &a){return word.find(a)!=string::npos;});\\n    }\\n};\\n```\n```\\n/**\\n * @param {string[]} patterns\\n * @param {string} word\\n * @return {number}\\n */\\nvar numOfStrings = function(patterns, word) {\\n    return [...patterns].filter(x=>word.includes(x)).length;\\n};\\n```\n```\\nfunction numOfStrings(patterns: string[], word: string): number {\\n    return [...patterns].filter(x=>word.includes(x)).length;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401389,
                "title": "c-and-c-very-easy-solution",
                "content": "![photo_2023-04-10_21-56-52.jpg](https://assets.leetcode.com/users/images/f4068c3d-500b-4a83-aec8-67297973dd98_1681145957.8050785.jpeg)\\n![photo_2023-04-10_21-56-58.jpg](https://assets.leetcode.com/users/images/36415b2b-ab7c-4e4d-bc4f-7a1e525a31c9_1681145965.33581.jpeg)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count=0;\\n        for(string s:patterns){\\n          if(word.find(s)!=string::npos)\\n          count++;\\n        }//If you like it,please upvote me.\\n    return count;\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public int NumOfStrings(string[] patterns, string word) {\\n       int count=0;\\n       foreach(string item in patterns){\\n           if(word.Contains(item))\\n           count++;\\n       } //If you find it helpful,please upvote.\\n       return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count=0;\\n        for(string s:patterns){\\n          if(word.find(s)!=string::npos)\\n          count++;\\n        }//If you like it,please upvote me.\\n    return count;\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public int NumOfStrings(string[] patterns, string word) {\\n       int count=0;\\n       foreach(string item in patterns){\\n           if(word.Contains(item))\\n           count++;\\n       } //If you find it helpful,please upvote.\\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532405,
                "title": "python-easy-1-line-solution",
                "content": "```\\ndef numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return sum(i in word for i in patterns)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return sum(i in word for i in patterns)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1412635,
                "title": "java-simple-easy-and-concise-brute-force-solution-of-o-n-m",
                "content": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n    \\tint ans = 0;\\n    \\tfor(int i = 0; i < patterns.length; i++) {\\n    \\t\\tchar ch = patterns[i].charAt(0);\\n    \\t\\tint len = patterns[i].length();\\n    \\t\\tfor(int j = 0; j < word.length(); j++) {\\n    \\t\\t\\tif(word.charAt(j) == ch) {\\n                    if(j + len <= word.length()){\\n                        if(patterns[i].equals(word.substring(j, j + len))) {\\n                            ans++;\\n                            break;\\n                        }\\n                    }\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n    \\tint ans = 0;\\n    \\tfor(int i = 0; i < patterns.length; i++) {\\n    \\t\\tchar ch = patterns[i].charAt(0);\\n    \\t\\tint len = patterns[i].length();\\n    \\t\\tfor(int j = 0; j < word.length(); j++) {\\n    \\t\\t\\tif(word.charAt(j) == ch) {\\n                    if(j + len <= word.length()){\\n                        if(patterns[i].equals(word.substring(j, j + len))) {\\n                            ans++;\\n                            break;\\n                        }\\n                    }\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497690,
                "title": "0ms-easy-approach-beasts-100-contains",
                "content": "\\n# Intutions\\n Simplest approach by finding if a string contains array elements aa substring or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n - Using **string.contains()** function to check wheather the given String contains the elements of the array of the array or not.\\n - If the string contains an elements then the **counter** is incremented else nothing happens.  \\n\\n# Complexity\\n- Time complexity:    **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/5ab96d4d-6fcc-4cae-a5c8-c288b3c14a8c_1683483098.8501859.png)\\n\\n# Please - Upvote :) \\uD83D\\uDD25\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int counter = 0 ;\\n        for(int i = 0 ; i < patterns.length ; i++){\\n            if(word.contains(patterns[i])){\\n                counter++;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```java []\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int counter = 0 ;\\n        for(int i = 0 ; i < patterns.length ; i++){\\n            if(word.contains(patterns[i])){\\n                counter++;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401681,
                "title": "golang-solution",
                "content": "\\n# Complexity\\n- Time complexity:54%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:85%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc numOfStrings(patterns []string, word string) int {\\n    count := 0\\n    for _, s := range patterns {\\n        if strings.Contains(word, s) {\\n            count++\\n        }\\n    }\\n    return count\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numOfStrings(patterns []string, word string) int {\\n    count := 0\\n    for _, s := range patterns {\\n        if strings.Contains(word, s) {\\n            count++\\n        }\\n    }\\n    return count\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2911495,
                "title": "java-count-2-line-code-100-faster",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n         int count = 0;\\n\\n        for (String pattern : patterns) {\\n            if (word.contains(pattern)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n         int count = 0;\\n\\n        for (String pattern : patterns) {\\n            if (word.contains(pattern)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401368,
                "title": "one-liner-javascript-solution",
                "content": "One Liner\\n``` js\\nvar numOfStrings = ((patterns, word) => patterns.filter(x => word.includes(x)).length)\\n```\\nPlease upvote if helpful!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` js\\nvar numOfStrings = ((patterns, word) => patterns.filter(x => word.includes(x)).length)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1586852,
                "title": "c-faster-than-100-two-line",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL);\\n        return count_if(patterns.begin(), patterns.end(), [&](const string& a){\\n            return (word.find(a)!=string::npos);\\n        });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL);\\n        return count_if(patterns.begin(), patterns.end(), [&](const string& a){\\n            return (word.find(a)!=string::npos);\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404222,
                "title": "javascript-direct-way-107ms",
                "content": "```\\nconst numOfStrings = (patterns, word) => {\\n    let cnt = 0\\n    for (const p of patterns) {\\n        if (word.indexOf(p) != -1) cnt++;\\n    }\\n    return cnt;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst numOfStrings = (patterns, word) => {\\n    let cnt = 0\\n    for (const p of patterns) {\\n        if (word.indexOf(p) != -1) cnt++;\\n    }\\n    return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2557721,
                "title": "java-solution-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(String s:patterns){\\n            boolean flag = word.contains(s);\\n            if(flag) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/bad89b3f-c294-4e20-a3d5-9a5b28c6088c_1662811291.8253834.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(String s:patterns){\\n            boolean flag = word.contains(s);\\n            if(flag) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617546,
                "title": "faster-than-100-of-javascript-online-submissions",
                "content": "```\\n/**\\n * @param {string[]} patterns\\n * @param {string} word\\n * @return {number}\\n */\\nvar numOfStrings = function(patterns, word) {\\n    let result = 0; \\n    \\n    for(let char of patterns){\\n        if(word.includes(char)){\\n            result++;\\n           } else{\\n               result += 0;\\n           }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * @param {string[]} patterns\\n * @param {string} word\\n * @return {number}\\n */\\nvar numOfStrings = function(patterns, word) {\\n    let result = 0; \\n    \\n    for(let char of patterns){\\n        if(word.includes(char)){\\n            result++;\\n           } else{\\n               result += 0;\\n           }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1538647,
                "title": "python-one-line-approach-explanation",
                "content": "1. Check each item ``pat`` in ``patterns`` if it is a substring of ``word`` by ``word.find(pat) != -1``\\n2. Count the number of such ``pat``\\n\\n```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return sum(1 for pat in patterns if word.find(pat) != -1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return sum(1 for pat in patterns if word.find(pat) != -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404783,
                "title": "rust-simple-solution",
                "content": "```\\nimpl Solution {\\n    pub fn num_of_strings(patterns: Vec<String>, word: String) -> i32 {\\n        patterns\\n            .iter()\\n            .filter(|&pattern| word.contains(pattern))\\n            .count() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_of_strings(patterns: Vec<String>, word: String) -> i32 {\\n        patterns\\n            .iter()\\n            .filter(|&pattern| word.contains(pattern))\\n            .count() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1403981,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int cntt=0;\\n        for(auto s:patterns)\\n        {\\n//             if the string is substring of word\\n            if(word.find(s)!=string::npos)\\n            {\\n                cntt++;\\n            }\\n//             if it\\'s equal to the word\\n            else if(s==word)\\n                cntt++;\\n        }\\n        return cntt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int cntt=0;\\n        for(auto s:patterns)\\n        {\\n//             if the string is substring of word\\n            if(word.find(s)!=string::npos)\\n            {\\n                cntt++;\\n            }\\n//             if it\\'s equal to the word\\n            else if(s==word)\\n                cntt++;\\n        }\\n        return cntt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403904,
                "title": "a-few-solutions",
                "content": "Return the count of strings `s` of the input array `A` which are substrings of the target `t`.\\n\\nNote: we can use [Rabin-Karp](https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm) or [Boyer-Moore](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm) as optimizations for finding a substring within a string.\\n\\n---\\n\\n**1-Liner Solutions:**\\n   \\n*Kotlin*\\n```\\nclass Solution {\\n    var numOfStrings = { A: Array<String>, t: String -> A.filter{ -1 < t.indexOf(it) }.size }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet numOfStrings = (A, t) => A.filter(s => -1 < t.indexOf(s)).length;\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def numOfStrings(self, A: List[str], t: str) -> int:\\n        return len([s for s in A if -1 < t.find(s)])\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def numOfStrings(self, A: List[str], t: str) -> int:\\n        return len(list(filter(lambda s: -1 < t.find(s), A)))\\n```\\n    \\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    int numOfStrings(VS& A, string t) {\\n        return count_if(A.begin(), A.end(), [&](auto& s) { return t.find(s) != string::npos; });\\n    }\\n};\\n```\\n\\n---\\n\\n**Verbose + Naive Solutions:**\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun numOfStrings(A: Array<String>, t: String): Int {\\n        var cnt = 0\\n        for (s in A) {\\n            for (i in 0 until t.length) {\\n                var j = 0\\n                var k = i\\n                while (j < s.length && k < t.length && s[j] == t[k]) {\\n                    ++j; ++k\\n                }\\n                if (j == s.length) {\\n                    ++cnt\\n                    break\\n                }\\n            }\\n        }\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet numOfStrings = (A, t, cnt = 0) => {\\n    for (let s of A) {\\n        for (let i = 0; i < t.length; ++i) {\\n            let j = 0,\\n                k = i;\\n            while (j < s.length && k < t.length && s[j] == t[k])\\n                ++j, ++k;\\n            if (j == s.length) {\\n                ++cnt;\\n                break;\\n            }\\n        }\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def numOfStrings(self, A: List[str], t: str, cnt = 0) -> int:\\n        for s in A:\\n            for i in range(len(t)):\\n                j = 0\\n                k = i\\n                while j < len(s) and k < len(t) and s[j] == t[k]:\\n                    j += 1; k += 1\\n                if j == len(s):\\n                    cnt += 1\\n                    break\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    int numOfStrings(VS& A, string t, int cnt = 0) {\\n        for (auto& s: A) {\\n            for (auto i{ 0 }; i < t.size(); ++i) {\\n                auto j = 0,\\n                     k = i;\\n                while (j < s.size() && k < t.size() && s[j] == t[k])\\n                    ++j, ++k;\\n                if (j == s.size()) {\\n                    ++cnt;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var numOfStrings = { A: Array<String>, t: String -> A.filter{ -1 < t.indexOf(it) }.size }\\n}\\n```\n```\\nlet numOfStrings = (A, t) => A.filter(s => -1 < t.indexOf(s)).length;\\n```\n```\\nclass Solution:\\n    def numOfStrings(self, A: List[str], t: str) -> int:\\n        return len([s for s in A if -1 < t.find(s)])\\n```\n```\\nclass Solution:\\n    def numOfStrings(self, A: List[str], t: str) -> int:\\n        return len(list(filter(lambda s: -1 < t.find(s), A)))\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    int numOfStrings(VS& A, string t) {\\n        return count_if(A.begin(), A.end(), [&](auto& s) { return t.find(s) != string::npos; });\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun numOfStrings(A: Array<String>, t: String): Int {\\n        var cnt = 0\\n        for (s in A) {\\n            for (i in 0 until t.length) {\\n                var j = 0\\n                var k = i\\n                while (j < s.length && k < t.length && s[j] == t[k]) {\\n                    ++j; ++k\\n                }\\n                if (j == s.length) {\\n                    ++cnt\\n                    break\\n                }\\n            }\\n        }\\n        return cnt\\n    }\\n}\\n```\n```\\nlet numOfStrings = (A, t, cnt = 0) => {\\n    for (let s of A) {\\n        for (let i = 0; i < t.length; ++i) {\\n            let j = 0,\\n                k = i;\\n            while (j < s.length && k < t.length && s[j] == t[k])\\n                ++j, ++k;\\n            if (j == s.length) {\\n                ++cnt;\\n                break;\\n            }\\n        }\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def numOfStrings(self, A: List[str], t: str, cnt = 0) -> int:\\n        for s in A:\\n            for i in range(len(t)):\\n                j = 0\\n                k = i\\n                while j < len(s) and k < len(t) and s[j] == t[k]:\\n                    j += 1; k += 1\\n                if j == len(s):\\n                    cnt += 1\\n                    break\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    int numOfStrings(VS& A, string t, int cnt = 0) {\\n        for (auto& s: A) {\\n            for (auto i{ 0 }; i < t.size(); ++i) {\\n                auto j = 0,\\n                     k = i;\\n                while (j < s.size() && k < t.size() && s[j] == t[k])\\n                    ++j, ++k;\\n                if (j == s.size()) {\\n                    ++cnt;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332286,
                "title": "smallest-solution-in-python-by-smarthood",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        count=0\\n        for i in patterns:\\n            if i in word:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        count=0\\n        for i in patterns:\\n            if i in word:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239593,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for (String p : patterns) {\\n            if (word.contains(p)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for (String p : patterns) {\\n            if (word.contains(p)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979395,
                "title": "number-of-strings-that-appear-as-substrings-in-word-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for (String pattern : patterns) {\\n            if (word.indexOf(pattern) >= 0)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for (String pattern : patterns) {\\n            if (word.indexOf(pattern) >= 0)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954784,
                "title": "c-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patt, string word) {\\n        int count = 0;\\n        for(int i=0;i<patt.size();i++) {\\n            int k = 0;\\n            while(k < word.size()) {\\n                string s = word.substr(k);\\n                // if(s.starts_with(patt[i]) == true) {\\n                //     count++;\\n                //     break;\\n                // }\\n                if(patt[i] == s.substr(0, patt[i].size())){\\n                    count++;\\n                    break;\\n                }\\n                else {\\n                    k++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patt, string word) {\\n        int count = 0;\\n        for(int i=0;i<patt.size();i++) {\\n            int k = 0;\\n            while(k < word.size()) {\\n                string s = word.substr(k);\\n                // if(s.starts_with(patt[i]) == true) {\\n                //     count++;\\n                //     break;\\n                // }\\n                if(patt[i] == s.substr(0, patt[i].size())){\\n                    count++;\\n                    break;\\n                }\\n                else {\\n                    k++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792549,
                "title": "java-simple-and-fast-solution",
                "content": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(String i:patterns){\\n            if(word.startsWith(i) || word.endsWith(i)){\\n                count++;\\n            }\\n            else if(word.contains(i)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(String i:patterns){\\n            if(word.startsWith(i) || word.endsWith(i)){\\n                count++;\\n            }\\n            else if(word.contains(i)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642630,
                "title": "python-o-n",
                "content": "# Intuition  \\nbrute force \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        count=0\\n        for i in patterns:\\n            if i in word:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        count=0\\n        for i in patterns:\\n            if i in word:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589979,
                "title": "c-brute-force",
                "content": "class Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count=0;\\n        for(int i=0;i<patterns.size();i++){\\n            if(word.find(patterns[i])!=-1){\\n            count++;\\n        }\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count=0;\\n        for(int i=0;i<patterns.size();i++){\\n            if(word.find(patterns[i])!=-1){\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2298967,
                "title": "easist-to-understand-1-line-solution-using-c-stl-find-function",
                "content": "**Please upvote if u like it**\\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        \\n        int count=0;\\n        for(int i=0; i<patterns.size(); i++)\\n        {\\n            if(word.find(patterns[i]) != string::npos )\\n                count++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        \\n        int count=0;\\n        for(int i=0; i<patterns.size(); i++)\\n        {\\n            if(word.find(patterns[i]) != string::npos )\\n                count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1907980,
                "title": "javascript-one-liner",
                "content": "```\\nvar numOfStrings = (patterns, word) => patterns.filter(p => word.indexOf(p) !== -1).length\\n```",
                "solutionTags": [],
                "code": "```\\nvar numOfStrings = (patterns, word) => patterns.filter(p => word.indexOf(p) !== -1).length\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1801511,
                "title": "c-2-approach-explained-with-code",
                "content": "```\\n\\n1. **Using  Brute Force**\\n   bool isSubstring(string s1, string s2)\\n{\\n    int M = s1.length();\\n    int N = s2.length();\\n \\n    /* A loop to slide pat[] one by one */\\n    for (int i = 0; i <= N - M; i++) {\\n        int j;\\n \\n        /* For current index i, check for\\n pattern match */\\n        for (j = 0; j < M; j++)\\n            if (s2[i + j] != s1[j])\\n                break;\\n \\n        if (j == M)\\n            return true;\\n    }\\n \\n    return false;\\n}\\n    int numOfStrings(vector<string>& p, string word) {\\n     \\n        \\n        \\n        int count =0 ; \\n         for(auto elem : p)\\n         {\\n               if (isSubstring(elem,word))\\n               {\\n                    count++;\\n               }\\n         }\\n        \\n        return count ;\\n  \\n        \\n              \\n        \\n    }\\n};\\n\\n\\n\\n\\n2. **Using String Algorithm \".find\"**\\n\\nclass Solution {\\npublic:\\n   \\n    int numOfStrings(vector<string>& p, string word) {\\n     \\n        int count =0 ; \\n         for(auto elem : p)\\n         {\\n              if (word.find(elem) != std::string::npos)\\n              {\\n                   count++;\\n              }\\n         }\\n        \\n        return count ;\\n  \\n        \\n              \\n        \\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n\\n1. **Using  Brute Force**\\n   bool isSubstring(string s1, string s2)\\n{\\n    int M = s1.length();\\n    int N = s2.length();\\n \\n    /* A loop to slide pat[] one by one */\\n    for (int i = 0; i <= N - M; i++) {\\n        int j;\\n \\n        /* For current index i, check for\\n pattern match */\\n        for (j = 0; j < M; j++)\\n            if (s2[i + j] != s1[j])\\n                break;\\n \\n        if (j == M)\\n            return true;\\n    }\\n \\n    return false;\\n}\\n    int numOfStrings(vector<string>& p, string word) {\\n     \\n        \\n        \\n        int count =0 ; \\n         for(auto elem : p)\\n         {\\n               if (isSubstring(elem,word))\\n               {\\n                    count++;\\n               }\\n         }\\n        \\n        return count ;\\n  \\n        \\n              \\n        \\n    }\\n};\\n\\n\\n\\n\\n2. **Using String Algorithm \".find\"**\\n\\nclass Solution {\\npublic:\\n   \\n    int numOfStrings(vector<string>& p, string word) {\\n     \\n        int count =0 ; \\n         for(auto elem : p)\\n         {\\n              if (word.find(elem) != std::string::npos)\\n              {\\n                   count++;\\n              }\\n         }\\n        \\n        return count ;\\n  \\n        \\n              \\n        \\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632902,
                "title": "c-easy-solution",
                "content": "using string.find() function\\n1-str.find(srt1)  returns the first occurance of the given substring\\n2-str.find(srt1,size_tpos) size_tpos is the position from which it will start searching the substring\\n\\n\\nHere  std::string::npos  is a constant static member value with the highest possible value for an element of type size_t.\\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count=0;\\n        for(auto i: patterns)\\n            if(word.find(i)!=string::npos)count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count=0;\\n        for(auto i: patterns)\\n            if(word.find(i)!=string::npos)count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560131,
                "title": "100-fast-java",
                "content": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(int i=0;i<patterns.length;i++)\\n        {\\n            if(word.contains(patterns[i]))\\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(int i=0;i<patterns.length;i++)\\n        {\\n            if(word.contains(patterns[i]))\\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406527,
                "title": "simple-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word)\\n    {\\n        int count = 0;\\n        for(auto i:patterns)\\n        {\\n            if(word.find(i) != string::npos)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word)\\n    {\\n        int count = 0;\\n        for(auto i:patterns)\\n        {\\n            if(word.find(i) != string::npos)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406345,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int numOfStrings(String[] p, String w) {\\n        int i,c=0;\\n        for(i=0;i<p.length;i++)\\n        {\\n            if(w.contains(p[i]))\\n                c++;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int numOfStrings(String[] p, String w) {\\n        int i,c=0;\\n        for(i=0;i<p.length;i++)\\n        {\\n            if(w.contains(p[i]))\\n                c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1405097,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {string[]} patterns\\n * @param {string} word\\n * @return {number}\\n */\\nvar numOfStrings = function (patterns, word) {\\n  let a = 0;\\n\\n  for (let i = 0; i < patterns.length; i++) {\\n    if (word.includes(patterns[i])) {\\n      a++;\\n    }\\n  }\\n\\n  return a;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} patterns\\n * @param {string} word\\n * @return {number}\\n */\\nvar numOfStrings = function (patterns, word) {\\n  let a = 0;\\n\\n  for (let i = 0; i < patterns.length; i++) {\\n    if (word.includes(patterns[i])) {\\n      a++;\\n    }\\n  }\\n\\n  return a;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1404862,
                "title": "kotlin-1-line-solution",
                "content": "```\\nclass Solution {\\n    fun numOfStrings(patterns: Array<String>, word: String): Int {\\n        return patterns.count { word.contains(it) }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun numOfStrings(patterns: Array<String>, word: String): Int {\\n        return patterns.count { word.contains(it) }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404567,
                "title": "java-0ms-clean-solution",
                "content": "\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0; \\n \\n        for( String s : patterns)\\n        {\\n            if(word.indexOf(s) != -1) count++;\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0; \\n \\n        for( String s : patterns)\\n        {\\n            if(word.indexOf(s) != -1) count++;\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1404346,
                "title": "c-faster-than-100",
                "content": "```\\nint numOfStrings(vector<string>& p, string s) {\\n        int l = s.length(), n = p.size(), count = 0;\\n        for(int i=0; i<n; i++) {\\n             size_t found = s.find(p[i]);\\n             if(found != string::npos) count++;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numOfStrings(vector<string>& p, string s) {\\n        int l = s.length(), n = p.size(), count = 0;\\n        for(int i=0; i<n; i++) {\\n             size_t found = s.find(p[i]);\\n             if(found != string::npos) count++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1403926,
                "title": "java-3-lines-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(String i : patterns)if(word.contains(i))count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(String i : patterns)if(word.contains(i))count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919950,
                "title": "js-one-liner-using-reduce",
                "content": "# Intuition\\nWe have an array and want a number, this is a nice use case for reduce, I think it is more elegant than filtering and taking the length.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\n/**\\n * @param {string[]} patterns\\n * @param {string} word\\n * @return {number}\\n */\\nvar numOfStrings = function(patterns, word) {\\n    return patterns.reduce((a,c) => a + (word.includes(c) ? 1 : 0), 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} patterns\\n * @param {string} word\\n * @return {number}\\n */\\nvar numOfStrings = function(patterns, word) {\\n    return patterns.reduce((a,c) => a + (word.includes(c) ? 1 : 0), 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3821099,
                "title": "number-of-strings-that-appears-as-substrings-in-a-word",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n<i>From fairest creatures we desire increase,\\nThat thereby beauty\\u2019s rose might never die,\\nBut as the riper should by time decrease,\\nHis tender heir mught bear his memeory:\\nBut thou, contracted to thine own bright eyes,\\nFeed\\u2019st thy light\\u2019st flame with self-substantial fuel,\\nMaking a famine where abundance lies,\\nThyself thy foe, to thy sweet self too cruel.\\nThou that art now the world\\u2019s fresh ornament\\nAnd only herald to the gaudy spring,\\nWithin thine own bud buriest thy content\\nAnd, tender churl, makest waste in niggarding.\\nPity the world, or else this glutton be,\\nTo eat the world\\u2019s due, by the grave and thee.</i>\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int ans = 0;\\n        for(String s : patterns)\\n            if(word.indexOf(s) != -1)   \\n                ans++;\\n        return ans;\\n}\\n}\\n```\\n![unknown.png](https://assets.leetcode.com/users/images/8249fb85-6046-4e0c-bf53-3a288b08756b_1690404965.8413827.png)\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int ans = 0;\\n        for(String s : patterns)\\n            if(word.indexOf(s) != -1)   \\n                ans++;\\n        return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791462,
                "title": "swift-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func numOfStrings(_ patterns: [String], _ word: String) -> Int {\\n        patterns.filter { word.contains($0) }.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    func numOfStrings(_ patterns: [String], _ word: String) -> Int {\\n        patterns.filter { word.contains($0) }.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554490,
                "title": "number-of-strings-that-appear-as-substrings-in-word-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int i, j, k, count=0;\\n        for(i=0 ; i<patterns.size() ; i++)\\n        {\\n            for(j=0 ; j<word.length() ; j++)\\n            {\\n                if(patterns[i][0]==word[j])\\n                {\\n                    for(k=0 ; k<patterns[i].length() ; k++)\\n                    {\\n                        if(patterns[i][k]!=word[j+k])\\n                        {\\n                            break;\\n                        }\\n                    }\\n                    if(k==patterns[i].length())\\n                    {\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/60919b26-ae89-4d3c-9327-67ec0bc5538f_1684820442.6604297.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int i, j, k, count=0;\\n        for(i=0 ; i<patterns.size() ; i++)\\n        {\\n            for(j=0 ; j<word.length() ; j++)\\n            {\\n                if(patterns[i][0]==word[j])\\n                {\\n                    for(k=0 ; k<patterns[i].length() ; k++)\\n                    {\\n                        if(patterns[i][k]!=word[j+k])\\n                        {\\n                            break;\\n                        }\\n                    }\\n                    if(k==patterns[i].length())\\n                    {\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965721,
                "title": "java-4-line-faster-than-100-0-ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for (int i = 0; i < patterns.length; i++) {\\n            if (word.contains(patterns[i])) count++;\\n        } return count;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/f29fa0dd-24f7-4747-a794-d4d3a8fa7fdd_1672291488.2865329.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for (int i = 0; i < patterns.length; i++) {\\n            if (word.contains(patterns[i])) count++;\\n        } return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963244,
                "title": "c-o-n-m-solution-beats-97",
                "content": "\\n\\n# Complexity\\n- Time complexity:$$O(n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patt, string word) {\\n        int count = 0;\\n        for(auto i : patt) {\\n            // if(word.find(i) != string::npos) count++;\\n            // OR\\n            if(word.find(i) != -1) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patt, string word) {\\n        int count = 0;\\n        for(auto i : patt) {\\n            // if(word.find(i) != string::npos) count++;\\n            // OR\\n            if(word.find(i) != -1) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953153,
                "title": "easy-java-solution-with-0ms-runtime-tc-o-n-beats-100",
                "content": "**If you found it easy to understand, Please do upvote :)\\nThankyou!!**\\n**--------------------------------------------------------------------------------------------------**\\n![Today Leetcode Pic.JPG](https://assets.leetcode.com/users/images/600be5ed-d151-4a70-8fc4-f61ad5d36244_1672050500.8851278.jpeg)\\n**--------------------------------------------------------------------------------------------------**\\n# Code\\n```\\nclass Solution \\n{\\n   public int numOfStrings(String[] patterns, String word) \\n   {\\n        int count = 0;\\n        for(String pattern : patterns)\\n        {\\n            if(word.contains(pattern)) count++;\\n        }\\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution \\n{\\n   public int numOfStrings(String[] patterns, String word) \\n   {\\n        int count = 0;\\n        for(String pattern : patterns)\\n        {\\n            if(word.contains(pattern)) count++;\\n        }\\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742395,
                "title": "java-easy-100-3-liner",
                "content": "# Please Upvote \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n> indexOf function searches for the substring in the string word and returns the index from where it starts.\\n> if not found, it returns -1\\n\\n```\\n\\t\\tint ans = 0;\\n        for(String s : patterns)\\n            if(word.indexOf(s) != -1)   ans++;\\n        return ans;\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n\\t\\tint ans = 0;\\n        for(String s : patterns)\\n            if(word.indexOf(s) != -1)   ans++;\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735624,
                "title": "number-of-strings-that-appear-as-substrings-in-word",
                "content": "class Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count=0;\\n        for(int i=0;i<patterns.size();i++){\\n            auto itr = word.find(patterns[i]);\\n            if(itr != string :: npos){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count=0;\\n        for(int i=0;i<patterns.size();i++){\\n            auto itr = word.find(patterns[i]);\\n            if(itr != string :: npos){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2705387,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& arr, string word) {\\n        int count=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(word.find(arr[i])==-1)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& arr, string word) {\\n        int count=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(word.find(arr[i])==-1)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530681,
                "title": "java-easy-substring-string-methods",
                "content": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count =0;\\n        for(int i=0;i<patterns.length;i++){\\n            if(word.contains(patterns[i]))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count =0;\\n        for(int i=0;i<patterns.length;i++){\\n            if(word.contains(patterns[i]))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430094,
                "title": "traditional-sliding-window-python",
                "content": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        \\n        res = 0\\n        for pattern in patterns:\\n            winL = 0\\n            winR = len(pattern)\\n\\t\\t\\t\\n            while winR<=len(word):    \\n                if word[winL:winR] == pattern:\\n                    res+=1\\n                    break\\n                winL+=1\\n                winR+=1\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        \\n        res = 0\\n        for pattern in patterns:\\n            winL = 0\\n            winR = len(pattern)\\n\\t\\t\\t\\n            while winR<=len(word):    \\n                if word[winL:winR] == pattern:\\n                    res+=1\\n                    break\\n                winL+=1\\n                winR+=1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408778,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(int i = 0; i < patterns.length; i++){\\n            if(word.contains(patterns[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(int i = 0; i < patterns.length; i++){\\n            if(word.contains(patterns[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393581,
                "title": "c-easy-solution-with-find",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count = 0;\\n        \\n        for(auto it:patterns)\\n        {\\n            if(word.find(it) != -1)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count = 0;\\n        \\n        for(auto it:patterns)\\n        {\\n            if(word.find(it) != -1)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389642,
                "title": "easy-1-line-solution-100-fast",
                "content": "class Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        \\n        int count=0;\\n        for(int i=0; i<patterns.size(); i++)\\n        {\\n            if(word.find(patterns[i]) != -1 )\\n                count++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        \\n        int count=0;\\n        for(int i=0; i<patterns.size(); i++)\\n        {\\n            if(word.find(patterns[i]) != -1 )\\n                count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2383410,
                "title": "rust-single-line-100-faster",
                "content": "```rust\\nimpl Solution {\\n    pub fn num_of_strings(patterns: Vec<String>, word: String) -> i32 {\\n        patterns.iter().filter(|&it| word.contains(it)).count() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn num_of_strings(patterns: Vec<String>, word: String) -> i32 {\\n        patterns.iter().filter(|&it| word.contains(it)).count() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2364475,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return len([pattern for pattern in patterns if pattern in word])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return len([pattern for pattern in patterns if pattern in word])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348822,
                "title": "number-of-strings-that-appear-as-substrings-in-word-java-easy-solution",
                "content": "// we only have to check whether the pattern string is present in word or not\\nclass Solution {\\n\\n    public int numOfStrings(String[] patterns, String word) {\\n        \\n       int count=0;\\n        for(int i=0;i<patterns.length;i++){\\n            if(word.contains(patterns[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n     }\\n }",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int numOfStrings(String[] patterns, String word) {\\n        \\n       int count=0;\\n        for(int i=0;i<patterns.length;i++){\\n            if(word.contains(patterns[i])){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2344267,
                "title": "simple-java-solution",
                "content": "**Solution Code :**\\n\\n```\\npublic int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(String pattern : patterns) {\\n            if (word.contains(pattern)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```\\n\\nHere, we loop throgh all the patterns and check weather it is present in the word ot not.\\n\\nif present increase count.\\n\\nfinally return count.\\n\\n\\nThank You :)",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\npublic int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(String pattern : patterns) {\\n            if (word.contains(pattern)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2305826,
                "title": "java-explianed-simple-fastest",
                "content": "```\\nclass Solution {\\npublic int numOfStrings(String[] patterns, String word) {\\n    int count=0;\\n    for(int i=0;i<patterns.length;i++){\\n        // just check weather it contains or not\\n    if(word.contains(patterns[i])){\\n    count++;\\n    }\\n  }\\n    return count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int numOfStrings(String[] patterns, String word) {\\n    int count=0;\\n    for(int i=0;i<patterns.length;i++){\\n        // just check weather it contains or not\\n    if(word.contains(patterns[i])){\\n    count++;\\n    }\\n  }\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291474,
                "title": "easy-javascript-solution-with-memory-usage-42-2-mb",
                "content": "```\\nvar numOfStrings = function(patterns, word) {\\n    let count=0;\\n    \\n    for(let i=0; i<patterns.length; i++){\\n        if(word.includes(patterns[i])){\\n            count +=1;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numOfStrings = function(patterns, word) {\\n    let count=0;\\n    \\n    for(let i=0; i<patterns.length; i++){\\n        if(word.includes(patterns[i])){\\n            count +=1;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2273418,
                "title": "java-one-line-solution",
                "content": "class Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        \\n        int count=0;\\n        \\n        for(String s:patterns){\\n            if(word.indexOf(s)!=-1) count++;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        \\n        int count=0;\\n        \\n        for(String s:patterns){\\n            if(word.indexOf(s)!=-1) count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2219024,
                "title": "1ms-java-solution",
                "content": "class Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n\\t\\t\\n\\t\\tint count=0; \\n\\t\\t\\n\\t\\tfor(int i=0; i<patterns.length; i++) {\\n\\t\\t\\t\\n\\t\\t\\tif(word.indexOf(patterns[i])!=-1) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n    \\treturn count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n\\t\\t\\n\\t\\tint count=0; \\n\\t\\t\\n\\t\\tfor(int i=0; i<patterns.length; i++) {\\n\\t\\t\\t\\n\\t\\t\\tif(word.indexOf(patterns[i])!=-1) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2186996,
                "title": "javascript-solution-with-using-map",
                "content": "```\\nvar numOfStrings = function(patterns, word) {\\n    let counter = 0;\\n    patterns.map((pattern) => word.match(pattern) ? counter++ : counter );\\n    return counter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numOfStrings = function(patterns, word) {\\n    let counter = 0;\\n    patterns.map((pattern) => word.match(pattern) ? counter++ : counter );\\n    return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139969,
                "title": "java-0ms-simple-and-best-solution",
                "content": "\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(int i=0;i<patterns.length;i++)\\n        {\\n            if(word.contains(patterns[i]))\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}****\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(int i=0;i<patterns.length;i++)\\n        {\\n            if(word.contains(patterns[i]))\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}****\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131905,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for (int i = 0; i < patterns.length; i++) {\\n            if (word.contains(patterns[i])) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n***Upvote my solution if you likes it***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for (int i = 0; i < patterns.length; i++) {\\n            if (word.contains(patterns[i])) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060505,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool isSubstring(string a, string b){\\n        int i=0, j=0;\\n        int k=a.size();\\n        while(j< b.size()){\\n            if(a[i]==b[j]){\\n                if(b.substr(j,k)==a) return 1;\\n            }\\n            j++;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count=0;\\n        for(int i=0; i<patterns.size(); i++){\\n            if(isSubstring(patterns[i], word)) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isSubstring(string a, string b){\\n        int i=0, j=0;\\n        int k=a.size();\\n        while(j< b.size()){\\n            if(a[i]==b[j]){\\n                if(b.substr(j,k)==a) return 1;\\n            }\\n            j++;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count=0;\\n        for(int i=0; i<patterns.size(); i++){\\n            if(isSubstring(patterns[i], word)) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033795,
                "title": "faster-than-87-less-than-72-and-easy-to-understand-js-solution",
                "content": "```\\nvar numOfStrings = function(patterns, word) {\\n  return patterns.reduce((prev, curr) => {\\n    const isSubStr = word.indexOf(curr) !== -1;\\n    \\n    if (isSubStr) {\\n      return ++prev\\n    } else {\\n      return prev;\\n    }\\n    \\n  }, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numOfStrings = function(patterns, word) {\\n  return patterns.reduce((prev, curr) => {\\n    const isSubStr = word.indexOf(curr) !== -1;\\n    \\n    if (isSubStr) {\\n      return ++prev\\n    } else {\\n      return prev;\\n    }\\n    \\n  }, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1973289,
                "title": "typescript-solution-one-line-of-code",
                "content": "```\\nfunction numOfStrings(patterns: string[], word: string): number {\\n    \\n    return (patterns.filter(a => word.includes(a))).length;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction numOfStrings(patterns: string[], word: string): number {\\n    \\n    return (patterns.filter(a => word.includes(a))).length;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1928124,
                "title": "simple-java-solution-only-4-lines-of-code",
                "content": "class Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n    \\n        for(String str:patterns){\\n            if(word.indexOf(str) >= 0)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n    \\n        for(String str:patterns){\\n            if(word.indexOf(str) >= 0)\\n                count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1891898,
                "title": "easy-c-sol-using-set",
                "content": "class Solution {\\npublic:\\n```\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        set<string>st;\\n        string s;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            s=\"\";\\n            s+=word[i];\\n            st.insert(s);\\n            for(int j=i+1;j<word.size();j++)\\n            {\\n                s+=word[j];\\n                st.insert(s);\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<patterns.size();i++)\\n        {\\n            if(st.find(patterns[i])!=st.end())\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        set<string>st;\\n        string s;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            s=\"\";\\n            s+=word[i];\\n            st.insert(s);\\n            for(int j=i+1;j<word.size();j++)\\n            {\\n                s+=word[j];\\n                st.insert(s);\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<patterns.size();i++)\\n        {\\n            if(st.find(patterns[i])!=st.end())\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1890466,
                "title": "number-of-strings-that-appear-as-substrings-in-word",
                "content": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for (String p:patterns) {\\n            if(word.contains(p))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for (String p:patterns) {\\n            if(word.contains(p))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854867,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int c=0;\\n        for(int i=0;i<patterns.length;i++)\\n        {\\n            if(word.indexOf(patterns[i])>-1)\\n                c++;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int c=0;\\n        for(int i=0;i<patterns.length;i++)\\n        {\\n            if(word.indexOf(patterns[i])>-1)\\n                c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1810661,
                "title": "c-easy-to-understand",
                "content": "# C++\\n\\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int sol = 0;\\n        \\n        for (auto pattern : patterns) {\\n            if (pattern.size() > word.size()) {\\n                continue;\\n            }\\n            else if (word.find(pattern) != string::npos){\\n                sol++;                \\n            }\\n        }\\n        \\n        return sol;\\n    }\\n};\\n```\\n\\n**Feel Free To Ask Doubts\\nAnd Please Share Suggestions\\nHAPPY CODING :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int sol = 0;\\n        \\n        for (auto pattern : patterns) {\\n            if (pattern.size() > word.size()) {\\n                continue;\\n            }\\n            else if (word.find(pattern) != string::npos){\\n                sol++;                \\n            }\\n        }\\n        \\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778673,
                "title": "faster100-simplest-3-line-sol",
                "content": "![image](https://assets.leetcode.com/users/images/7b7eae77-9ae8-41c7-947f-092842491a19_1645115168.2559361.png)\\n\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n       for(String s:patterns)\\n           if(word.contains(s))\\n               count++;\\n       \\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n       for(String s:patterns)\\n           if(word.contains(s))\\n               count++;\\n       \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760790,
                "title": "3-javascript-solution",
                "content": "The problem statement said that we have to match each ```pattern``` element character with ```word``` substring. \\n\\n### Algorithm:\\n- First we assign a variable ```count``` to ```0```.\\n- We iterate all the element of the array.\\n- Check whether each element character match  with ```word``` substring or not \\n- If the above condition fulfiled then we increment ```count``` variable ```1```\\n- After finish the execution of iteration, we will return ```count``` \\n\\n#### Solve with JavaScript ```includes``` method\\n```\\nvar numOfStrings = function(patterns, word) {\\n    let count =0;\\n    for(value of patterns){\\n        if(word.includes(value)){\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```\\n\\n#### Solve with JavaScript ```indexOf``` method\\n\\n```\\nvar numOfStrings = function(patterns, word) {\\n    let count = 0;\\n    for(let i=0;i<patterns.length;i++){\\n        if(word.indexOf(patterns[i])!== -1){\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```\\n#### Solve with JavaScript ```reduce``` method\\n\\n```\\nvar numOfStrings = function(patterns, word) {\\n    let result = patterns.reduce((acc,curr)=>{\\n        if(word.includes(curr)){\\n            acc++\\n        }\\n        return acc\\n    },0);\\n    \\n    return result;\\n};\\n```\\n\\n### Upvote if you find these solutions helpful :)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```pattern```\n```word```\n```count```\n```0```\n```word```\n```count```\n```1```\n```count```\n```includes```\n```\\nvar numOfStrings = function(patterns, word) {\\n    let count =0;\\n    for(value of patterns){\\n        if(word.includes(value)){\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```\n```indexOf```\n```\\nvar numOfStrings = function(patterns, word) {\\n    let count = 0;\\n    for(let i=0;i<patterns.length;i++){\\n        if(word.indexOf(patterns[i])!== -1){\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```\n```reduce```\n```\\nvar numOfStrings = function(patterns, word) {\\n    let result = patterns.reduce((acc,curr)=>{\\n        if(word.includes(curr)){\\n            acc++\\n        }\\n        return acc\\n    },0);\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1750233,
                "title": "fastest-python-code",
                "content": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return len([i for i in patterns if i in word])\\n```\\nMade use of list comprehension to filter elements of the patterns list by taking only those elements that are present in word and then returning the length of the list which is actually the number of patterns present in the word. \\n\\nAttached is the SS of my working soln: ![image](https://assets.leetcode.com/users/images/4a0f75e6-9d8c-408a-9f54-9ef811ead0ce_1644160135.1576364.png)\\n",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return len([i for i in patterns if i in word])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683288,
                "title": "swift-solution",
                "content": "```\\nfunc numOfStrings(_ patterns: [String], _ word: String) -> Int {\\n    return patterns.map{word.contains($0)}.filter({ (bol) -> Bool in\\n        return bol == true\\n    }).count\\n}",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc numOfStrings(_ patterns: [String], _ word: String) -> Int {\\n    return patterns.map{word.contains($0)}.filter({ (bol) -> Bool in\\n        return bol == true\\n    }).count\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1642580,
                "title": "python-solution",
                "content": "class Solution:\\n\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        answer = 0\\n        for substr in patterns:\\n            if substr in word:\\n                answer += 1\\n        return answer",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        answer = 0\\n        for substr in patterns:\\n            if substr in word:\\n                answer += 1\\n        return answer",
                "codeTag": "Java"
            },
            {
                "id": 1617582,
                "title": "faster-than-100-of-java-submissions",
                "content": "```\\npublic int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(int i=0;i<patterns.length;i++){\\n            if(word.contains(patterns[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(int i=0;i<patterns.length;i++){\\n            if(word.contains(patterns[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1611033,
                "title": "python-simple-solution-using-map",
                "content": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        li = list(map(lambda x: x in word, patterns))\\n        return li.count(True)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        li = list(map(lambda x: x in word, patterns))\\n        return li.count(True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597820,
                "title": "python-one-liner-making-use-of-bool-to-int",
                "content": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return sum(i in word for i in patterns)\\n        ```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return sum(i in word for i in patterns)\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 1525567,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        count = 0\\n        \\n        for i in patterns:\\n            if i in word:\\n                count += 1\\n        \\n        return count\\n```\\n",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        count = 0\\n        \\n        for i in patterns:\\n            if i in word:\\n                count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523448,
                "title": "python-interview-explainable",
                "content": "Easy to understand and explain to an interviewer\\n```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        counter = 0\\n        for x in patterns:\\n            if x in word:\\n                counter+= 1\\n        return counter\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        counter = 0\\n        for x in patterns:\\n            if x in word:\\n                counter+= 1\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520130,
                "title": "c-one-liner-stl-find-3ms-faster-than-96",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word, int ans=0) {\\n        for(auto k:patterns)if(word.find(k)!=-1)ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word, int ans=0) {\\n        for(auto k:patterns)if(word.find(k)!=-1)ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516184,
                "title": "golang-0ms",
                "content": "```\\nfunc numOfStrings(patterns []string, word string) int {\\n\\tcount := 0\\n\\tfor _, s := range patterns {\\n\\t\\tfor i := 0; i <= len(word)-len(s); i++ {\\n\\t\\t\\tif word[i:i+len(s)] == s {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t\\tbreak \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numOfStrings(patterns []string, word string) int {\\n\\tcount := 0\\n\\tfor _, s := range patterns {\\n\\t\\tfor i := 0; i <= len(word)-len(s); i++ {\\n\\t\\t\\tif word[i:i+len(s)] == s {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t\\tbreak \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486555,
                "title": "phyton-number-of-strings-that-appear-as-substrings-in-word",
                "content": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        count=0\\n        for i in patterns:\\n            if i in word:\\n                count=count+1\\n        return(count)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        count=0\\n        for i in patterns:\\n            if i in word:\\n                count=count+1\\n        return(count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482703,
                "title": "eazy-java-solution",
                "content": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int times = 0;\\n        for(String key: patterns)\\n            if(word.indexOf(key) != -1)\\n                times++;\\n        \\n        return times;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int times = 0;\\n        for(String key: patterns)\\n            if(word.indexOf(key) != -1)\\n                times++;\\n        \\n        return times;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477707,
                "title": "c-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(const vector<string>& patterns, const string& word) {\\n        int count=0;\\n        for(const auto& i:patterns)\\n            if(word.find(i)!=string::npos) ++count;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(const vector<string>& patterns, const string& word) {\\n        int count=0;\\n        for(const auto& i:patterns)\\n            if(word.find(i)!=string::npos) ++count;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472211,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(String string:patterns) {\\n            if(word.contains(string))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(String string:patterns) {\\n            if(word.contains(string))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469427,
                "title": "javascript-one-liner",
                "content": "```\\nconst numOfStrings = (p, w) => p.filter(i=>w.includes(i)).length;\\n```",
                "solutionTags": [],
                "code": "```\\nconst numOfStrings = (p, w) => p.filter(i=>w.includes(i)).length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1466204,
                "title": "simple-faster-than-100-java-solution",
                "content": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(int i=0;i<patterns.length;i++)\\n        {\\n            if(word.contains(patterns[i]))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(int i=0;i<patterns.length;i++)\\n        {\\n            if(word.contains(patterns[i]))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457118,
                "title": "easiest-java-solution-0-ms-indexof",
                "content": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(int i=0;i<patterns.length;i++){\\n            if(word.indexOf(patterns[i])!=-1){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(int i=0;i<patterns.length;i++){\\n            if(word.indexOf(patterns[i])!=-1){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456098,
                "title": "java-indexof",
                "content": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(String pattern : patterns){\\n            if(word.indexOf(pattern) >= 0)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(String pattern : patterns){\\n            if(word.indexOf(pattern) >= 0)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453246,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return [p in word for p in patterns].count(True)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return [p in word for p in patterns].count(True)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453216,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word)\\n    {\\n        int count=0;\\n        for(int i=0;i<patterns.size();i++)\\n        {\\n            if(word.find(patterns[i])!=string::npos)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word)\\n    {\\n        int count=0;\\n        for(int i=0;i<patterns.size();i++)\\n        {\\n            if(word.find(patterns[i])!=string::npos)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452728,
                "title": "python3-very-easily-understandable",
                "content": "```\\n  def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        count = 0\\n        for i in patterns:\\n            if i in word:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\n  def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        count = 0\\n        for i in patterns:\\n            if i in word:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1444063,
                "title": "golang-0ms-solution",
                "content": "```\\nfunc numOfStrings(patterns []string, word string) int {\\n    \\n    count :=0\\n    for i := range patterns {\\n        if strings.Contains(word,patterns[i]) {\\n            count++\\n        }\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc numOfStrings(patterns []string, word string) int {\\n    \\n    count :=0\\n    for i := range patterns {\\n        if strings.Contains(word,patterns[i]) {\\n            count++\\n        }\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1416207,
                "title": "easy-java-3-lines-of-code",
                "content": "**Upvote if you got help..**\\n\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int c=0;\\n        for(String pattern:patterns) {\\n            if(word.contains(pattern)) {\\n                c++;\\n            }\\n        }\\n        return c++;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int c=0;\\n        for(String pattern:patterns) {\\n            if(word.contains(pattern)) {\\n                c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1414587,
                "title": "ruby-one-liner",
                "content": "```\\ndef num_of_strings(patterns, word)\\n  patterns.count {|pattern| word.include? pattern}\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef num_of_strings(patterns, word)\\n  patterns.count {|pattern| word.include? pattern}\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1413817,
                "title": "java-0ms-faster-than-100-memory-less-than-96-33",
                "content": "![image](https://assets.leetcode.com/users/images/117cf315-059b-4f39-9a26-513c41ecce84_1629392816.5581415.png)\\n\\n\\n```java\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(String pattern : patterns)\\n            if(word.indexOf(pattern) > -1) count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(String pattern : patterns)\\n            if(word.indexOf(pattern) > -1) count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406594,
                "title": "rust-oneline-solution",
                "content": "```\\nimpl Solution {\\n    pub fn num_of_strings(patterns: Vec<String>, word: String) -> i32 {\\n            patterns.iter().filter(|each_word| word.contains(*each_word)).count() as i32\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn num_of_strings(patterns: Vec<String>, word: String) -> i32 {\\n            patterns.iter().filter(|each_word| word.contains(*each_word)).count() as i32\\n\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1406042,
                "title": "go-golang-solution",
                "content": ">Runtime: 8 ms, faster than 100.00% of Go online submissions for Number of Strings That Appear as Substrings in Word.\\nMemory Usage: 7.1 MB, less than 100.00% of Go online submissions for Number of Strings That Appear as Substrings in Word.\\n\\n```go\\nfunc numOfStrings(patterns []string, word string) int {\\n    ans, n, tmp := 0, len(word), make(map[string]bool)\\n    for i := 1; i <= n; i++ {\\n        for j := 0; j + i <= n; j++ {\\n            tmp[word[j:j+i]] = true\\n        }\\n    }\\n    for _, p := range patterns { if tmp[p] { ans++ } }\\n    return ans\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc numOfStrings(patterns []string, word string) int {\\n    ans, n, tmp := 0, len(word), make(map[string]bool)\\n    for i := 1; i <= n; i++ {\\n        for j := 0; j + i <= n; j++ {\\n            tmp[word[j:j+i]] = true\\n        }\\n    }\\n    for _, p := range patterns { if tmp[p] { ans++ } }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1405851,
                "title": "python-simple-1-liner",
                "content": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return sum(pattern in word for pattern in patterns)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return sum(pattern in word for pattern in patterns)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405227,
                "title": "golang-0ms-2-7mb",
                "content": "```\\nfunc isSubString(s string, sub string) bool {\\n    if len(s) < len(sub) {\\n        return false\\n    }\\n    \\n    for i:=0; i <= len(s) - len(sub); i++ {\\n        if s[i:i+len(sub)] == sub {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n\\nfunc numOfStrings(patterns []string, word string) int {\\n    count := 0\\n    for _, s := range patterns {\\n        if isSubString(word, s) {\\n            count ++\\n        }\\n    }\\n    \\n    return count\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isSubString(s string, sub string) bool {\\n    if len(s) < len(sub) {\\n        return false\\n    }\\n    \\n    for i:=0; i <= len(s) - len(sub); i++ {\\n        if s[i:i+len(sub)] == sub {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n\\nfunc numOfStrings(patterns []string, word string) int {\\n    count := 0\\n    for _, s := range patterns {\\n        if isSubString(word, s) {\\n            count ++\\n        }\\n    }\\n    \\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1404538,
                "title": "c-linq",
                "content": "```\\npublic int NumOfStrings(string[] patterns, string word) \\n        => patterns.Count(p => word.Contains(p));\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumOfStrings(string[] patterns, string word) \\n        => patterns.Count(p => word.Contains(p));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1404137,
                "title": "c-straight-forward-and-1-liner",
                "content": "The intuition here is to loop through the strings in \"patterns\" and check if the current word is a substring of \"word\". If it is, add one to your counter!\\n\\n1-liner:\\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {    \\n        return count_if(patterns.begin(), patterns.end(), [&](string x){return word.find(x) != word.npos;});\\n    }\\n};\\n```\\n\\nStraight-forward:\\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int ans = 0;\\n        \\n        for (string x : patterns)\\n            if (word.find(x) != word.npos)\\n                ans++;\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nShort circuiting the && operator:\\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int ans = 0;\\n        \\n        for (string x : patterns)\\n            word.find(x) != word.npos && ans++;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {    \\n        return count_if(patterns.begin(), patterns.end(), [&](string x){return word.find(x) != word.npos;});\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int ans = 0;\\n        \\n        for (string x : patterns)\\n            if (word.find(x) != word.npos)\\n                ans++;\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int ans = 0;\\n        \\n        for (string x : patterns)\\n            word.find(x) != word.npos && ans++;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404028,
                "title": "c-using-find-funtion",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count=0;\\n        for(auto a:patterns)\\n        {\\n             size_t f = word.find(a);\\n            if(f!=string::npos)count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count=0;\\n        for(auto a:patterns)\\n        {\\n             size_t f = word.find(a);\\n            if(f!=string::npos)count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404020,
                "title": "python-3-line",
                "content": "```\\ndef numOfStrings(self, patterns: List[str], word: str) -> int:\\n        cnt = 0\\n        for i in range(len(patterns)):\\n            if patterns[i] in word:\\n                cnt = cnt+1\\n        return cnt\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef numOfStrings(self, patterns: List[str], word: str) -> int:\\n        cnt = 0\\n        for i in range(len(patterns)):\\n            if patterns[i] in word:\\n                cnt = cnt+1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1403999,
                "title": "c-1967-number-of-strings-that-appear-as-substrings-in-word",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int ans = 0; \\n        for (auto& x : patterns) \\n            if (word.find(x) != string::npos) ++ans; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int ans = 0; \\n        for (auto& x : patterns) \\n            if (word.find(x) != string::npos) ++ans; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403977,
                "title": "c-simple",
                "content": "```\\n//Approach-1 (Simple loop)\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count = 0;\\n        \\n        for(const string &s : patterns)\\n            count += word.find(s) != string::npos ? 1 : 0;\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Using C++ STL std::count_if)\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        \\n        auto lambda = [&word](string &s) {\\n            return word.find(s) != string::npos;\\n        };\\n        \\n        return count_if(begin(patterns), end(patterns), lambda);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Simple loop)\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int count = 0;\\n        \\n        for(const string &s : patterns)\\n            count += word.find(s) != string::npos ? 1 : 0;\\n        \\n        return count;\\n    }\\n};\\n```\n```\\n//Approach-2 (Using C++ STL std::count_if)\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        \\n        auto lambda = [&word](string &s) {\\n            return word.find(s) != string::npos;\\n        };\\n        \\n        return count_if(begin(patterns), end(patterns), lambda);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4106960,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        count=0\\n        for i in patterns:\\n            if i in word:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        count=0\\n        for i in patterns:\\n            if i in word:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4104710,
                "title": "simple-straightforward-java-solution-memory-optimized",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        \\n        int count = 0;\\n        for(int i = 0; i < patterns.length; ++i) {\\n            if (word.contains(patterns[i])) {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        \\n        int count = 0;\\n        for(int i = 0; i < patterns.length; ++i) {\\n            if (word.contains(patterns[i])) {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098754,
                "title": "faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity :\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(String s : patterns){\\n            if(word.contains(s)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(String s : patterns){\\n            if(word.contains(s)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093244,
                "title": "easiest-solution-with-100-beats-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(int i=0;i<patterns.length;i++){\\n            if(word.contains(patterns[i]))\\n            count++;\\n        }\\n     return count;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(int i=0;i<patterns.length;i++){\\n            if(word.contains(patterns[i]))\\n            count++;\\n        }\\n     return count;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090894,
                "title": "test",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        count = 0\\n        for x in patterns:\\n            if x in word:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        count = 0\\n        for x in patterns:\\n            if x in word:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089711,
                "title": "one-line-python-answer",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return sum([1 if patt in word else 0 for patt in patterns ])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return sum([1 if patt in word else 0 for patt in patterns ])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087848,
                "title": "simple-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int ans =0;\\n        for(String pattern:patterns){\\n            if(word.contains(pattern)) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int ans =0;\\n        for(String pattern:patterns){\\n            if(word.contains(pattern)) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084732,
                "title": "c-two-difference-approaches-1-powerset-2-iterative-solution",
                "content": "**1: Powerset approach** \\nPlease note that this approach is a possible solution, it takes longer to run.\\n```\\nclass Solution {\\npublic:   \\n    std::set<std::string> generatePowerSet(const std::string& str) {\\n        \\n        std::set<std::string> result;\\n        int n = str.length();\\n        int powerSetSize = 1 << n; \\n\\n        for (int i = 0; i < powerSetSize; ++i) {\\n            std::string subset;\\n            for (int j = 0; j < n; ++j) {\\n                if ((i & (1 << j)) != 0) {\\n                    subset += str[j];\\n                }\\n            }\\n            result.insert(subset);\\n        }\\n\\n        return result;\\n    }\\n    \\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int ans {};\\n        std::set<std::string> powerSet = generatePowerSet(word);\\n        \\n        for (int i = 0; i < patterns.size(); i++) {\\n\\t\\t\\tif (powerSet.count(patterns[i]) == 1) ans++;\\n        }  \\n        return ans;    \\n    }\\n};\\n```\\n\\n**2. Iterative approach**\\n```\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int ans {};        \\n        for (int i = 0; i < patterns.size(); i++) { \\n            if (word.find(patterns[i]) != std::string::npos) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:   \\n    std::set<std::string> generatePowerSet(const std::string& str) {\\n        \\n        std::set<std::string> result;\\n        int n = str.length();\\n        int powerSetSize = 1 << n; \\n\\n        for (int i = 0; i < powerSetSize; ++i) {\\n            std::string subset;\\n            for (int j = 0; j < n; ++j) {\\n                if ((i & (1 << j)) != 0) {\\n                    subset += str[j];\\n                }\\n            }\\n            result.insert(subset);\\n        }\\n\\n        return result;\\n    }\\n    \\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int ans {};\\n        std::set<std::string> powerSet = generatePowerSet(word);\\n        \\n        for (int i = 0; i < patterns.size(); i++) {\\n\\t\\t\\tif (powerSet.count(patterns[i]) == 1) ans++;\\n        }  \\n        return ans;    \\n    }\\n};\\n```\n```\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int ans {};        \\n        for (int i = 0; i < patterns.size(); i++) { \\n            if (word.find(patterns[i]) != std::string::npos) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084695,
                "title": "using-contains-method-of-java-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(int i=0;i<patterns.length;i++){\\n            if(word.contains(patterns[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(int i=0;i<patterns.length;i++){\\n            if(word.contains(patterns[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084639,
                "title": "list-comprehension",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return sum([i in word for i in patterns])\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        return sum([i in word for i in patterns])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084059,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0 ; \\n        for(int i = 0; i<patterns.length ; i++) {\\n            if( word.contains(patterns[i])) {\\n                count++ ; \\n            }\\n        }\\n\\n        return count ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0 ; \\n        for(int i = 0; i<patterns.length ; i++) {\\n            if( word.contains(patterns[i])) {\\n                count++ ; \\n            }\\n        }\\n\\n        return count ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081664,
                "title": "java-easy-soolution-100-effucient-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n       for(int i=0;i<patterns.length;i++)\\n       {\\n           if(word.contains(patterns[i]))\\n           count++;\\n       }\\n       return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n       for(int i=0;i<patterns.length;i++)\\n       {\\n           if(word.contains(patterns[i]))\\n           count++;\\n       }\\n       return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079437,
                "title": "easy-best-solution-ever",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        count = 0\\n        for ch in patterns:\\n            if ch in word:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\\n        count = 0\\n        for ch in patterns:\\n            if ch in word:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078694,
                "title": "simple-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n       int numberString = 0;\\n\\n        for(String pattern : patterns){\\n            if(word.indexOf(pattern) > -1)\\n                numberString++;\\n        }\\n\\n        return numberString;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n       int numberString = 0;\\n\\n        for(String pattern : patterns){\\n            if(word.indexOf(pattern) > -1)\\n                numberString++;\\n        }\\n\\n        return numberString;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076858,
                "title": "easy-solution-in-javascript",
                "content": "\\n# Code\\n```\\n\\nvar numOfStrings = function(patterns,word) {\\n    let count = 0;\\n    patterns.filter(function(e) {\\n        word.includes(e) === true ? count++ : \\'null\\';\\n    });\\n    return count;\\n}\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar numOfStrings = function(patterns,word) {\\n    let count = 0;\\n    patterns.filter(function(e) {\\n        word.includes(e) === true ? count++ : \\'null\\';\\n    });\\n    return count;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072646,
                "title": "one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func numOfStrings(_ patterns: [String], _ word: String) -> Int {\\n        patterns.filter({word.contains($0)}).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numOfStrings(_ patterns: [String], _ word: String) -> Int {\\n        patterns.filter({word.contains($0)}).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072645,
                "title": "one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func numOfStrings(_ patterns: [String], _ word: String) -> Int {\\n        patterns.filter({word.contains($0)}).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numOfStrings(_ patterns: [String], _ word: String) -> Int {\\n        patterns.filter({word.contains($0)}).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069641,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int c=0;\\n        for(int i=0;i<patterns.size();i++)\\n        {\\n            if(word.find(patterns[i])!=string::npos)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int c=0;\\n        for(int i=0;i<patterns.size();i++)\\n        {\\n            if(word.find(patterns[i])!=string::npos)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064908,
                "title": "java-super-simple-100-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int result = 0;\\n        for (String pattern : patterns) {\\n            if (word.contains(pattern)) result++;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int result = 0;\\n        for (String pattern : patterns) {\\n            if (word.contains(pattern)) result++;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064328,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(String s:patterns){\\n            if(word.contains(s)){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(String s:patterns){\\n            if(word.contains(s)){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061015,
                "title": "swift-one-line-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func numOfStrings(_ patterns: [String], _ word: String) -> Int {\\n        return patterns.reduce(.zero) { word.contains($1) ? $0 + 1: $0 }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numOfStrings(_ patterns: [String], _ word: String) -> Int {\\n        return patterns.reduce(.zero) { word.contains($1) ? $0 + 1: $0 }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058317,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int ans=0;\\n        for (int i=0;i<patterns.size();i++)\\n        {\\n            if (word.find(patterns[i])!=string::npos) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& patterns, string word) {\\n        int ans=0;\\n        for (int i=0;i<patterns.size();i++)\\n        {\\n            if (word.find(patterns[i])!=string::npos) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052706,
                "title": "beats-100-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(int i = 0; i< patterns.length ; i++){\\n            if(word.contains(patterns[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count=0;\\n        for(int i = 0; i< patterns.length ; i++){\\n            if(word.contains(patterns[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036337,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] p, String w) {\\n        int c=0;\\n        for(int i=0;i<p.length;i++){\\n            if(w.indexOf(p[i])!=-1){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] p, String w) {\\n        int c=0;\\n        for(int i=0;i<p.length;i++){\\n            if(w.indexOf(p[i])!=-1){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027304,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe goal of this problem is to count the number of strings in the given array strs that are substrings of the given string word. In other words, we want to find how many strings in the array can be found within the word as substrings.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable count to keep track of the number of strings in strs that are substrings of word.\\n\\n2. Iterate through each string str in the strs array.\\n\\n3. For each str, check if it is a substring of word. We can use the contains method to perform this check.\\n\\n4. If str is a substring of word, increment the count variable.\\n\\n5. After iterating through all strings in strs, return the final value of count, which represents the number of strings that are substrings of word.\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] strs, String word) {\\n        int count = 0;\\n\\n        for (String str : strs){\\n            if (word.contains(str)){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n![Frame 76.png](https://assets.leetcode.com/users/images/4098163a-64c4-41a9-bd79-4df9a76b0b76_1694356474.9300086.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] strs, String word) {\\n        int count = 0;\\n\\n        for (String str : strs){\\n            if (word.contains(str)){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026158,
                "title": "beats-100-00-of-users-with-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(int i=0;i<patterns.length;i++)\\n        {\\n            if(word.contains(patterns[i]))\\n            {\\n                count=count+1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(int i=0;i<patterns.length;i++)\\n        {\\n            if(word.contains(patterns[i]))\\n            {\\n                count=count+1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024356,
                "title": "100-beats-simple-java-solution-tc-o-n",
                "content": "# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int noOfSubstrings=0;\\n        for(String pattern:patterns){\\n            if(word.indexOf(pattern)!=-1){\\n                noOfSubstrings++;\\n            }\\n        }\\n        return noOfSubstrings;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int noOfSubstrings=0;\\n        for(String pattern:patterns){\\n            if(word.indexOf(pattern)!=-1){\\n                noOfSubstrings++;\\n            }\\n        }\\n        return noOfSubstrings;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023301,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& arr, string word) {\\n        int count=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(word.find(arr[i])==-1)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfStrings(vector<string>& arr, string word) {\\n        int count=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(word.find(arr[i])==-1)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022992,
                "title": "easy-solution-for-beginners-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public int numOfStrings(String[] patterns, String word) {\\n\\t\\tint count = 0;\\n        for(String pattern:patterns) {\\n        \\tboolean patternMatched = check(pattern , word);\\n        \\tif(patternMatched) {\\n        \\t\\tcount++;\\n        \\t}\\n        }\\n        return count;\\n    }\\n\\tpublic boolean check(String pattern , String word) {\\n\\t\\tif(word.contains(pattern)) {\\n\\t\\t\\treturn true;\\n\\t\\t}else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n public int numOfStrings(String[] patterns, String word) {\\n\\t\\tint count = 0;\\n        for(String pattern:patterns) {\\n        \\tboolean patternMatched = check(pattern , word);\\n        \\tif(patternMatched) {\\n        \\t\\tcount++;\\n        \\t}\\n        }\\n        return count;\\n    }\\n\\tpublic boolean check(String pattern , String word) {\\n\\t\\tif(word.contains(pattern)) {\\n\\t\\t\\treturn true;\\n\\t\\t}else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021146,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count =0;\\n       for (String p : patterns) {\\n            if (word.contains(p)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count =0;\\n       for (String p : patterns) {\\n            if (word.contains(p)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020571,
                "title": "const-js-ts-single-line-solution-great-explanation",
                "content": "Certainly! Here are the missing details filled in for the provided code:\\n\\n**Intuition:** The intuition behind this code is to count how many patterns from the `patterns` array can be found as substrings in the `word` string. It\\'s essentially looking for matches between the patterns and the word.\\n\\n**Approach:**\\n1. The code uses the `filter` function to iterate through each element (pattern) in the `patterns` array.\\n2. For each pattern, it checks if the `word` string includes the pattern as a substring using the `includes` method.\\n3. If the pattern is found in the `word`, it is included in the filtered array.\\n4. Finally, the code returns the length of the filtered array, which represents the number of patterns found in the `word`.\\n\\n**Complexity:**\\n- Time complexity: The time complexity of this code is O(N * M), where N is the length of the `patterns` array (number of patterns) and M is the length of the `word` string. In the worst case, it may need to check each pattern against the entire `word`.\\n- Space complexity: The space complexity is O(1) because the code only uses a constant amount of additional memory to store the length of the filtered array.\\n\\n**Code:**\\n```typescript\\nfunction numOfStrings(patterns: string[], word: string): number {\\n    // Filter patterns that are substrings of the word and return the count.\\n    return patterns.filter(pattern => word.includes(pattern)).length;\\n}\\n```\\n\\nThis function efficiently counts the number of patterns that appear as substrings in the given `word` string and returns the count as an integer.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction numOfStrings(patterns: string[], word: string): number {\\n    // Filter patterns that are substrings of the word and return the count.\\n    return patterns.filter(pattern => word.includes(pattern)).length;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2074501,
                "content": [
                    {
                        "username": "RajuBudhoju",
                        "content": "Can anyone without using \"word.contains()\" functinality ?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Time to revise your string built in functions guys"
                    },
                    {
                        "username": "rohit-1802",
                        "content": " `class Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(int i = 0; i < patterns.length; i++){\\n            if(word.contains(patterns[i])){\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "mahimashetty369",
                        "content": "I am not getting all testcases passed.. I can\\'t get where I went wrong...\\n\\n\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int[] arr = new int[26];\\n\\n        for(int i  = 0; i<word.length(); i++){\\n            arr[word.charAt(i) - \\'a\\']++;\\n        }\\n        boolean status = true;\\n        int count = 0;\\n\\n        for(String w : patterns){\\n            for(char c : w.toCharArray()){\\n                if(arr[c - \\'a\\'] <= 0)\\n                {\\n                    status = false;\\n                    break;\\n                }\\n                \\n            }\\n            if(status){\\n                count++;\\n            }\\n            status = true;\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "you are updating the same ``` arr ```, you have to create an new Array with that newly created array, You have to compare this ``` arr <= 0```.  OR You may can compare this with ``` arr[c-'a'] - (c-'a') <= 0 ```."
                    },
                    {
                        "username": "vghoghari82",
                        "content": "Are we allowed to use built-in `string::find()` in C++ ?"
                    }
                ]
            },
            {
                "id": 1956298,
                "content": [
                    {
                        "username": "RajuBudhoju",
                        "content": "Can anyone without using \"word.contains()\" functinality ?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Time to revise your string built in functions guys"
                    },
                    {
                        "username": "rohit-1802",
                        "content": " `class Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(int i = 0; i < patterns.length; i++){\\n            if(word.contains(patterns[i])){\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "mahimashetty369",
                        "content": "I am not getting all testcases passed.. I can\\'t get where I went wrong...\\n\\n\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int[] arr = new int[26];\\n\\n        for(int i  = 0; i<word.length(); i++){\\n            arr[word.charAt(i) - \\'a\\']++;\\n        }\\n        boolean status = true;\\n        int count = 0;\\n\\n        for(String w : patterns){\\n            for(char c : w.toCharArray()){\\n                if(arr[c - \\'a\\'] <= 0)\\n                {\\n                    status = false;\\n                    break;\\n                }\\n                \\n            }\\n            if(status){\\n                count++;\\n            }\\n            status = true;\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "you are updating the same ``` arr ```, you have to create an new Array with that newly created array, You have to compare this ``` arr <= 0```.  OR You may can compare this with ``` arr[c-'a'] - (c-'a') <= 0 ```."
                    },
                    {
                        "username": "vghoghari82",
                        "content": "Are we allowed to use built-in `string::find()` in C++ ?"
                    }
                ]
            },
            {
                "id": 1795072,
                "content": [
                    {
                        "username": "RajuBudhoju",
                        "content": "Can anyone without using \"word.contains()\" functinality ?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Time to revise your string built in functions guys"
                    },
                    {
                        "username": "rohit-1802",
                        "content": " `class Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(int i = 0; i < patterns.length; i++){\\n            if(word.contains(patterns[i])){\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "mahimashetty369",
                        "content": "I am not getting all testcases passed.. I can\\'t get where I went wrong...\\n\\n\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int[] arr = new int[26];\\n\\n        for(int i  = 0; i<word.length(); i++){\\n            arr[word.charAt(i) - \\'a\\']++;\\n        }\\n        boolean status = true;\\n        int count = 0;\\n\\n        for(String w : patterns){\\n            for(char c : w.toCharArray()){\\n                if(arr[c - \\'a\\'] <= 0)\\n                {\\n                    status = false;\\n                    break;\\n                }\\n                \\n            }\\n            if(status){\\n                count++;\\n            }\\n            status = true;\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "you are updating the same ``` arr ```, you have to create an new Array with that newly created array, You have to compare this ``` arr <= 0```.  OR You may can compare this with ``` arr[c-'a'] - (c-'a') <= 0 ```."
                    },
                    {
                        "username": "vghoghari82",
                        "content": "Are we allowed to use built-in `string::find()` in C++ ?"
                    }
                ]
            },
            {
                "id": 1782886,
                "content": [
                    {
                        "username": "RajuBudhoju",
                        "content": "Can anyone without using \"word.contains()\" functinality ?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Time to revise your string built in functions guys"
                    },
                    {
                        "username": "rohit-1802",
                        "content": " `class Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(int i = 0; i < patterns.length; i++){\\n            if(word.contains(patterns[i])){\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "mahimashetty369",
                        "content": "I am not getting all testcases passed.. I can\\'t get where I went wrong...\\n\\n\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int[] arr = new int[26];\\n\\n        for(int i  = 0; i<word.length(); i++){\\n            arr[word.charAt(i) - \\'a\\']++;\\n        }\\n        boolean status = true;\\n        int count = 0;\\n\\n        for(String w : patterns){\\n            for(char c : w.toCharArray()){\\n                if(arr[c - \\'a\\'] <= 0)\\n                {\\n                    status = false;\\n                    break;\\n                }\\n                \\n            }\\n            if(status){\\n                count++;\\n            }\\n            status = true;\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "you are updating the same ``` arr ```, you have to create an new Array with that newly created array, You have to compare this ``` arr <= 0```.  OR You may can compare this with ``` arr[c-'a'] - (c-'a') <= 0 ```."
                    },
                    {
                        "username": "vghoghari82",
                        "content": "Are we allowed to use built-in `string::find()` in C++ ?"
                    }
                ]
            },
            {
                "id": 1743904,
                "content": [
                    {
                        "username": "RajuBudhoju",
                        "content": "Can anyone without using \"word.contains()\" functinality ?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Time to revise your string built in functions guys"
                    },
                    {
                        "username": "rohit-1802",
                        "content": " `class Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int count = 0;\\n        for(int i = 0; i < patterns.length; i++){\\n            if(word.contains(patterns[i])){\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "mahimashetty369",
                        "content": "I am not getting all testcases passed.. I can\\'t get where I went wrong...\\n\\n\\nclass Solution {\\n    public int numOfStrings(String[] patterns, String word) {\\n        int[] arr = new int[26];\\n\\n        for(int i  = 0; i<word.length(); i++){\\n            arr[word.charAt(i) - \\'a\\']++;\\n        }\\n        boolean status = true;\\n        int count = 0;\\n\\n        for(String w : patterns){\\n            for(char c : w.toCharArray()){\\n                if(arr[c - \\'a\\'] <= 0)\\n                {\\n                    status = false;\\n                    break;\\n                }\\n                \\n            }\\n            if(status){\\n                count++;\\n            }\\n            status = true;\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "you are updating the same ``` arr ```, you have to create an new Array with that newly created array, You have to compare this ``` arr <= 0```.  OR You may can compare this with ``` arr[c-'a'] - (c-'a') <= 0 ```."
                    },
                    {
                        "username": "vghoghari82",
                        "content": "Are we allowed to use built-in `string::find()` in C++ ?"
                    }
                ]
            }
        ]
    }
]