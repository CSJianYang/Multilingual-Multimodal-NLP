[
    {
        "title": "Minimum Time to Repair Cars",
        "question_content": "You are given an integer array ranks representing the ranks of some mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank r can repair n cars in r * n2 minutes.\nYou are also given an integer cars representing the total number of cars waiting in the garage to be repaired.\nReturn the minimum time taken to repair all the cars.\nNote: All the mechanics can repair the cars simultaneously.\n&nbsp;\nExample 1:\n\nInput: ranks = [4,2,3,1], cars = 10\nOutput: 16\nExplanation: \n- The first mechanic will repair two cars. The time required is 4 * 2 * 2 = 16 minutes.\n- The second mechanic will repair two cars. The time required is 2 * 2 * 2 = 8 minutes.\n- The third mechanic will repair two cars. The time required is 3 * 2 * 2 = 12 minutes.\n- The fourth mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.\nIt can be proved that the cars cannot be repaired in less than 16 minutes.​​​​​\n\nExample 2:\n\nInput: ranks = [5,1,8], cars = 6\nOutput: 16\nExplanation: \n- The first mechanic will repair one car. The time required is 5 * 1 * 1 = 5 minutes.\n- The second mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.\n- The third mechanic will repair one car. The time required is 8 * 1 * 1 = 8 minutes.\nIt can be proved that the cars cannot be repaired in less than 16 minutes.​​​​​\n\n&nbsp;\nConstraints:\n\n\t1 <= ranks.length <= 105\n\t1 <= ranks[i] <= 100\n\t1 <= cars <= 106",
        "solutions": [
            {
                "id": 3311975,
                "title": "c-java-python3-binary-search-1-liner",
                "content": "\\n# Intuition\\nA mechanic can repair `n` cars in `r * n * n` minutes. So in `mid` minutes a mechanic can repair `n` cars where, `n = sqrt(mid / r)` \\nLet\\'s assume that the correct answer is `mid` minutes, we can find the number of cars each mechanic can repair in `mid` minutes, then find the find the total number of cars fixed. If total number of cars fixed is greater than or equal to the cars we have to repair, `mid` minutes is a valid answer, else we have to increase `mid`. We can not linearly calculate total cars fixed for each mid in (0 to 10^14), we must use binary search to lower the time complexity.\\n\\n# Approach\\n* Total cars repaired by all workers in `mid` minutes must be greater than or equal to total cars that have to be repaired\\n* Binary search over the range `0 to 10^14` to find what is the minimum time required to repair all cars\\n* We use high as `10^14` because `max(rank) = 100` and `max(cars) = 10^6` so, `r * n * n = 100 * 10^6 * 10^6 = 10^14`\\n\\n# Complexity\\n- Time complexity: `O(nlog(10^14))`\\n\\n- Space complexity: `O(1)`\\n\\n# Code\\n**C++**:\\n```\\nlong long repairCars(vector<int>& ranks, int cars) {\\n    long long low = 0, high = 1e14;\\n    while (low < high) {\\n        long long mid = low + (high - low) / 2, repaired_cars = 0;\\n        for (int& r: ranks)\\n            repaired_cars += sqrt(mid / r);\\n        if (repaired_cars < cars) low = mid + 1;\\n        else high = mid;\\n    }\\n    return low;\\n}\\n```\\n\\n**Java**:\\n```\\npublic long repairCars(int[] ranks, int cars) {\\n    long low = 0, high = (long)1e14;\\n    while (low < high) {\\n        long mid = low + (high - low) / 2, repaired_cars = 0;\\n        for (int r: ranks)\\n            repaired_cars += Math.sqrt(mid / r);\\n        if (repaired_cars < cars) low = mid + 1;\\n        else high = mid;\\n    }\\n    return low;\\n}\\n```\\n\\n**Python3**:\\n```\\ndef repairCars(self, A: List[int], cars: int) -> int:\\n    return bisect_left(range(10**14), cars, key=lambda x: sum(int(sqrt(x / a)) for a in A))\\n```\\n\\nSimilar Questions:\\n[Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/1802415/python3-java-c-binary-search-1-liner/)\\n[Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/solutions/3262163/c-java-python3-1-line-ologn/)\\n[Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/solutions/2947983/c-java-python-binary-search-and-sorting/)\\n[Number of Flowers in Full Bloom](https://leetcode.com/problems/number-of-flowers-in-full-bloom/solutions/1976804/python3-2-lines-sort-and-binary-search/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nlong long repairCars(vector<int>& ranks, int cars) {\\n    long long low = 0, high = 1e14;\\n    while (low < high) {\\n        long long mid = low + (high - low) / 2, repaired_cars = 0;\\n        for (int& r: ranks)\\n            repaired_cars += sqrt(mid / r);\\n        if (repaired_cars < cars) low = mid + 1;\\n        else high = mid;\\n    }\\n    return low;\\n}\\n```\n```\\npublic long repairCars(int[] ranks, int cars) {\\n    long low = 0, high = (long)1e14;\\n    while (low < high) {\\n        long mid = low + (high - low) / 2, repaired_cars = 0;\\n        for (int r: ranks)\\n            repaired_cars += Math.sqrt(mid / r);\\n        if (repaired_cars < cars) low = mid + 1;\\n        else high = mid;\\n    }\\n    return low;\\n}\\n```\n```\\ndef repairCars(self, A: List[int], cars: int) -> int:\\n    return bisect_left(range(10**14), cars, key=lambda x: sum(int(sqrt(x / a)) for a in A))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3312003,
                "title": "java-c-python-binary-search-and-heap-solution",
                "content": "# **Intuition**\\nBinary search the result.\\n<br>\\n\\n# **Explanation**\\nBecause `cars > 0`,\\n`left = 1`.\\n\\nBecause mechanic `A[i]` can repair `n` cars in `A[i] * n * n `minutes.\\nright = `A[0] * cars * cars`.\\n\\nBinary search the time taken to repair all the cars.\\nAssume we have `mid` minutes,\\nthen the `i`th mechanic can repaire `sqrt(mid / A[i]` cars,\\nand we round to floor integer here.\\nWe calculate all the `cur` cars we can repair,\\nIf `cur < cars`, not enough time, `left = mid + 1`\\nIf `cur >= cars`, enough time, `right = mid`.\\n\\nFinally return the binary search result.\\n<br>\\n\\n# **Complexity**\\nIf count the frequency of all `A[i]`,\\nsince `A[i] <= 100`,\\nthen don\\'t have to `O(n)` pass the whole `A` each time.\\n\\nTime `O(100 * (logA[0] + logcars))`,\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public long repairCars(int[] A, int cars) {\\n        long left = 1, right = 1L * A[0] * cars * cars;\\n        while (left < right) {\\n            long mid = (left + right) / 2, cur = 0;\\n            for (int a : A)\\n                cur += (long)(Math.sqrt(1.0 * mid / a));\\n            if (cur < cars)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long repairCars(vector<int>& A, int cars) {\\n        long long left = 1, right = 1L * A[0] * cars * cars;\\n        while (left < right) {\\n            long long mid = (left + right) / 2, cur = 0;\\n            for (int a : A)\\n                cur += int(sqrt(1.0 * mid / a));\\n            if (cur < cars)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def repairCars(self, A: List[int], cars: int) -> int:\\n        count = Counter(A)\\n        left, right = 1, min(count) * cars * cars\\n        while left < right:\\n            mid = (left + right) // 2\\n            if sum(isqrt(mid // a) * count[a] for a in count) < cars:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return left\\n```\\n<br>\\n\\n\\n# Solution 2: Heap\\n\\nAdd all worker in the a heap,\\nand find out the next worker that can repair cars.\\n\\nTime `O(cars * log100)`,\\nSpace `O(log100)`\\n\\n**Python**\\n```py\\n    def repairCars(self, A: List[int], cars: int) -> int:\\n        count = Counter(A)\\n        h = [[a, a, 1, count[a]] for a in count]\\n        heapify(h)\\n        while cars > 0:\\n            time, rank, k, count = heappop(h)\\n            cars -= count\\n            k += 1\\n            heappush(h, [rank * k * k, rank, k, count])\\n        return time\\n```\\n<br>\\n\\n\\n# More Good Binary Search Problems\\nHere are some similar binary search problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\n- 2560. [House Robber IV](https://leetcode.com/problems/house-robber-iv/discuss/3143697/JavaC%2B%2BPython-Binary-Search-O(1)-Space)\\n- 2226. [Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/1908888/JavaC%2B%2BPython-Binary-Search-with-Explanation)\\n- 1802. [Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/discuss/1119801/Python-Binary-Search)\\n- 1539. [Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/discuss/779999/JavaC++Python-O(logN))\\n- 1482. [Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/686316/javacpython-binary-search)\\n- 1283. [Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446376/javacpython-bianry-search)\\n- 1231. [Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/408503/Python-Binary-Search)\\n- 1011. [Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/256729/javacpython-binary-search/)\\n- 875. [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/152324/C++JavaPython-Binary-Search)\\n- 774. [Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/113633/Easy-and-Concise-Solution-using-Binary-Search-C++JavaPython)\\n- 410. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long repairCars(int[] A, int cars) {\\n        long left = 1, right = 1L * A[0] * cars * cars;\\n        while (left < right) {\\n            long mid = (left + right) / 2, cur = 0;\\n            for (int a : A)\\n                cur += (long)(Math.sqrt(1.0 * mid / a));\\n            if (cur < cars)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n```\n```cpp\\n    long long repairCars(vector<int>& A, int cars) {\\n        long long left = 1, right = 1L * A[0] * cars * cars;\\n        while (left < right) {\\n            long long mid = (left + right) / 2, cur = 0;\\n            for (int a : A)\\n                cur += int(sqrt(1.0 * mid / a));\\n            if (cur < cars)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n```\n```py\\n    def repairCars(self, A: List[int], cars: int) -> int:\\n        count = Counter(A)\\n        left, right = 1, min(count) * cars * cars\\n        while left < right:\\n            mid = (left + right) // 2\\n            if sum(isqrt(mid // a) * count[a] for a in count) < cars:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return left\\n```\n```py\\n    def repairCars(self, A: List[int], cars: int) -> int:\\n        count = Counter(A)\\n        h = [[a, a, 1, count[a]] for a in count]\\n        heapify(h)\\n        while cars > 0:\\n            time, rank, k, count = heappop(h)\\n            cars -= count\\n            k += 1\\n            heappush(h, [rank * k * k, rank, k, count])\\n        return time\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3312137,
                "title": "explained-binary-search-very-simple-easy-to-understand-solution",
                "content": "# Approach \\nNeed to figure out the time limit that will allow the all cars to repair.\\nSo do this, we will keep checking each and every time value. \\nBut in place of just checking each time we can use binary serach to \\ncheck if a time value is fisible to repair all car or not.\\n\\nIf a time value is fisible we will store it as answer and try to check lower time value for fisibility.\\n\\nIf a time value is not fisible then we mark it as lower limit and then keep \\nchecking for higher time value for the fisibility.\\n\\n\\nTo check if a time value is fisible or not, simply start repairing cars\\nfor each rank with max possible value.\\nTo do this for a rank r & time t, max car it can repir, n = sqrt(t / r);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(long long time, int cars, vector<int>& ranks){\\n        int i = 0;\\n        while(i < ranks.size() && cars > 0){\\n            int t = sqrt(time /ranks[i]);\\n            cars -= t; \\n            i++;\\n        }\\n        return cars > 0? false: true;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long l = 1, h = (long long)cars * (long long)cars * 100;\\n        long long ans = h;\\n        while(l <= h){\\n            long long mid = l + (h - l)/2; \\n            if(check(mid, cars, ranks)) { ans = mid; h = mid - 1; }\\n            else{ l = mid + 1; }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long time, int cars, vector<int>& ranks){\\n        int i = 0;\\n        while(i < ranks.size() && cars > 0){\\n            int t = sqrt(time /ranks[i]);\\n            cars -= t; \\n            i++;\\n        }\\n        return cars > 0? false: true;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long l = 1, h = (long long)cars * (long long)cars * 100;\\n        long long ans = h;\\n        while(l <= h){\\n            long long mid = l + (h - l)/2; \\n            if(check(mid, cars, ranks)) { ans = mid; h = mid - 1; }\\n            else{ l = mid + 1; }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312209,
                "title": "java-python-3-binary-search",
                "content": "**Q & A:**\\n\\n*Q1:* What is the logic behind setting higher bound for binary search as `hi = 1L * maxRank * cars * cars`?\\n \\n *A1:* The one with highest rank repairing all cars will cost longest time, and there is no way that we could spend more time to finish all jobs. Therefore, we set the worst case of `L * maxRank * cars * cars` as the higher bound of our search space.\\n\\n**Q & A:**\\n\\n----\\n\\n1. The worst case is that the max rank repairs all cars, and the corresponding time cost is the higher bound of our search space;\\n2. Set the lower bound as `0`;\\n3. Binary search the minimum time need to repair all cars.\\n\\n```java\\n    public long repairCars(int[] ranks, int cars) {\\n        int maxRank = IntStream.of(ranks).max().getAsInt();\\n        long lo = 0, hi = 1L * maxRank * cars * cars;\\n        while (lo < hi) {\\n            long time = lo + (hi - lo) / 2;\\n            if (canFinish(ranks, cars, time)) {\\n                hi = time;\\n            }else {\\n                lo = time + 1;\\n            }\\n        }\\n        return lo;\\n    }\\n    private boolean canFinish(int[] ranks, int cars, long time) {\\n        long finish = 0;\\n        for (int r : ranks) {\\n            finish += (int)Math.floor(Math.sqrt(time / r));\\n            if (finish >= cars) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\n```python\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        \\n        def canFinish(time: int) -> bool:\\n            finish = 0\\n            for r in ranks:\\n                finish += floor(math.sqrt(time / r))\\n                if finish >= cars:\\n                    return True\\n            return False\\n\\n        lo, hi = 0, max(ranks) * cars * cars\\n        while lo < hi:\\n            time = lo + (hi - lo) // 2\\n            if canFinish(time):\\n                hi = time\\n            else:\\n                lo = time + 1\\n        return lo\\n```\\nSince Python 3.10 we can simplify the above code as follows:\\n```python\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        return bisect_left(range(max(ranks) * cars * cars), cars, key=lambda x: sum(floor(math.sqrt(x // r)) for r in ranks))\\n```\\n\\n**Analysis:**\\n\\nTime: `O(nlog(max(ranks) * m * m))`, space: `O(1)`, where `n = ranks.length, m = cars`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long repairCars(int[] ranks, int cars) {\\n        int maxRank = IntStream.of(ranks).max().getAsInt();\\n        long lo = 0, hi = 1L * maxRank * cars * cars;\\n        while (lo < hi) {\\n            long time = lo + (hi - lo) / 2;\\n            if (canFinish(ranks, cars, time)) {\\n                hi = time;\\n            }else {\\n                lo = time + 1;\\n            }\\n        }\\n        return lo;\\n    }\\n    private boolean canFinish(int[] ranks, int cars, long time) {\\n        long finish = 0;\\n        for (int r : ranks) {\\n            finish += (int)Math.floor(Math.sqrt(time / r));\\n            if (finish >= cars) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\n```python\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        \\n        def canFinish(time: int) -> bool:\\n            finish = 0\\n            for r in ranks:\\n                finish += floor(math.sqrt(time / r))\\n                if finish >= cars:\\n                    return True\\n            return False\\n\\n        lo, hi = 0, max(ranks) * cars * cars\\n        while lo < hi:\\n            time = lo + (hi - lo) // 2\\n            if canFinish(time):\\n                hi = time\\n            else:\\n                lo = time + 1\\n        return lo\\n```\n```python\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        return bisect_left(range(max(ranks) * cars * cars), cars, key=lambda x: sum(floor(math.sqrt(x // r)) for r in ranks))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3312109,
                "title": "bs-c-clean-and-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* This is a binary search (**minimum maximum** )problem since we have to find the minimum possible maximum time taken by a mechanic to repair a car.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* we set `mid` as the maximum allowable time a mechanic can take.\\n* maximum cars a mechanic can repair can be found by using equation \\n$${rank_i*n*n<=mid}$$;\\n* we loop over all mechanics and count maximum possible cars that can be repaired by all mechanics such that each mechanic must not take more than mid time to repair them. \\n* hi=1e14 is taken because maximum value of $${r*n*n}$$= $${100*1e6*1e6}$$=1e14.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long lo=0, hi=1e14;\\n        while( lo<hi ){\\n            ll mid=(lo+hi)/2;\\n            ll count=0;\\n            for(int i=0;i<ranks.size();i++){\\n                count+=sqrt(mid / ranks[i]);\\n            }\\n            if(count>=cars) hi=mid;\\n            else  lo=mid+1;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long lo=0, hi=1e14;\\n        while( lo<hi ){\\n            ll mid=(lo+hi)/2;\\n            ll count=0;\\n            for(int i=0;i<ranks.size();i++){\\n                count+=sqrt(mid / ranks[i]);\\n            }\\n            if(count>=cars) hi=mid;\\n            else  lo=mid+1;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311982,
                "title": "binary-search",
                "content": "Time complexity is O(n log m), where m is maximum time.\\n\\nNote that we could argue that finding the square root is O(log m). However, processors implement `sqrt` efficiently so it takes O(1), so it would not be a big mistake if we ignore it.\\n\\n**Python 3**\\nTIL: `isqrt`.\\n\\n```python\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        l, r = 1, 100 * 1000000 * 1000000  # rank * n * n\\n        while l < r:\\n            m = (l + r) // 2\\n            rep = sum(isqrt(m // rank) for rank in ranks)\\n            r = m if rep >= cars else r\\n            l = m + 1 if rep < cars else l\\n        return l\\n```\\n\\n**C++**\\n```cpp    \\nlong long repairCars(vector<int>& ranks, int cars) {\\n    long long l = 1, r = 100LL * 1000000 * 1000000; // rank * n * n\\n    while (l < r) {\\n        long long m = (l + r) / 2, rep = accumulate(begin(ranks), end(ranks), 0LL, \\n            [m](long long sum, int rank){ return sum  + sqrt(m / rank); });\\n        r = rep >= cars ? m : r;\\n        l = rep >= cars ? l : m + 1;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        l, r = 1, 100 * 1000000 * 1000000  # rank * n * n\\n        while l < r:\\n            m = (l + r) // 2\\n            rep = sum(isqrt(m // rank) for rank in ranks)\\n            r = m if rep >= cars else r\\n            l = m + 1 if rep < cars else l\\n        return l\\n```\n```cpp    \\nlong long repairCars(vector<int>& ranks, int cars) {\\n    long long l = 1, r = 100LL * 1000000 * 1000000; // rank * n * n\\n    while (l < r) {\\n        long long m = (l + r) / 2, rep = accumulate(begin(ranks), end(ranks), 0LL, \\n            [m](long long sum, int rank){ return sum  + sqrt(m / rank); });\\n        r = rep >= cars ? m : r;\\n        l = rep >= cars ? l : m + 1;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319287,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& v, int cars) {\\n        long long i=1,j=100000000000000;\\n        long long ans=j;\\n        while(i<=j){\\n            long long m=(i+j)/2;\\n            long long tt=0;\\n            for(int i=0;i<v.size();i++){\\n                long long c=sqrt(m/v[i]);\\n                tt += c;\\n            }\\n            if(tt>=cars){\\n                ans=m;\\n                j=m-1;\\n            }\\n            else i=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/83884030-74d1-4086-9b9a-c78d5aec91e7_1679303171.2753437.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& v, int cars) {\\n        long long i=1,j=100000000000000;\\n        long long ans=j;\\n        while(i<=j){\\n            long long m=(i+j)/2;\\n            long long tt=0;\\n            for(int i=0;i<v.size();i++){\\n                long long c=sqrt(m/v[i]);\\n                tt += c;\\n            }\\n            if(tt>=cars){\\n                ans=m;\\n                j=m-1;\\n            }\\n            else i=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753730,
                "title": "best-c-solution-list-of-8-similar-very-imp-binary-search-questions",
                "content": "# List of similar binary search questions \\n- [Koko Eating bananas - Leetcode](https://leetcode.com/problems/koko-eating-bananas/solutions/3750804/best-c-solution-list-of-7-similar-very-imp-binary-search-questions/)\\n- [Find the Smallest Divisor Given a Threshold - Leetcode](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/solutions/3746201/best-c-solution-pure-binary-search-approach-beats-98-84/)\\n- [Minimum Number of Days to Make m Bouquets - Leetcode](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/solutions/3751751/best-c-solution-list-of-similar-very-imp-binary-search-questions/)\\n- [Capacity To Ship Packages Within D Days - Leetcode](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/solutions/3751752/best-c-solution-list-of-similar-very-imp-binary-search-questions/)\\n- [Minimized Maximum of Products Distributed to Any Store - Leetcode](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/solutions/3750918/best-c-solution-list-of-similar-very-imp-binary-search-questions/) \\n- [Book Allocation - Coding Ninjas](https://www.codingninjas.com/studio/problems/ayush-and-ninja-test_1097574?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=0)\\n- [Aggressive cows - Coding Ninjas](https://www.codingninjas.com/studio/problems/aggressive-cows_1082559?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=1)\\n- [Painter\\'s partition - Coding Ninjas](https://www.codingninjas.com/studio/problems/painter\\'s-partition-problem_1089557?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=0)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int start = 1, end = 1e14, ans = 0;\\n        while(start<=end){\\n            long long mid = start+(end-start)/2, carCount = 0;\\n            for(int i=0; i<ranks.size(); i++){\\n                carCount += sqrt(mid/ranks[i]);\\n            }\\n            if(carCount >= cars)\\n                ans = mid, end = mid-1;\\n            else\\n                start = mid+1;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int start = 1, end = 1e14, ans = 0;\\n        while(start<=end){\\n            long long mid = start+(end-start)/2, carCount = 0;\\n            for(int i=0; i<ranks.size(); i++){\\n                carCount += sqrt(mid/ranks[i]);\\n            }\\n            if(carCount >= cars)\\n                ans = mid, end = mid-1;\\n            else\\n                start = mid+1;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541750,
                "title": "binary-search-c-easy-to-understad",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int mn = 0, mx = 1e15, mid = 0;\\n        long long int ans,k=0;\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            k = 0;\\n            for(auto &i: ranks){\\n                k += sqrt(mid/i);\\n            }\\n            if(k>=cars){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int mn = 0, mx = 1e15, mid = 0;\\n        long long int ans,k=0;\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            k = 0;\\n            for(auto &i: ranks){\\n                k += sqrt(mid/i);\\n            }\\n            if(k>=cars){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313414,
                "title": "c-easy-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long l=1;\\n        long long r=1e18;\\n        auto isgood=[&](const long long mid){\\n            long long cnt=0;\\n            for(int i=0;i<ranks.size();i++){\\n                cnt+=sqrt(mid/ranks[i]);\\n            }\\n            return cnt>=cars;\\n        };\\n        while(l<=r){\\n            long long mid=(l+(r-l)/2);\\n            if(isgood(mid)){\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long l=1;\\n        long long r=1e18;\\n        auto isgood=[&](const long long mid){\\n            long long cnt=0;\\n            for(int i=0;i<ranks.size();i++){\\n                cnt+=sqrt(mid/ranks[i]);\\n            }\\n            return cnt>=cars;\\n        };\\n        while(l<=r){\\n            long long mid=(l+(r-l)/2);\\n            if(isgood(mid)){\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312142,
                "title": "binary-search-simplest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will do Binary Search Over time \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn helper function we will check if it is possible to repairs cars in <= \\'mid\\' time\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog((int)1e14))\\n\\n# Code\\n```\\nclass Solution {\\n    public long repairCars(int[] arr, int c) {\\n        long[] ranks = new long[arr.length];\\n        int idx = 0;\\n        for(int ele : arr)\\n        {\\n            ranks[idx++] = (ele * 1l);\\n        }\\n        Arrays.sort(ranks);\\n        long cars = (c * 1l);\\n        \\n        int n = ranks.length;\\n        long time = (int)1e14;\\n        long si = 0;\\n        long ei = Long.MAX_VALUE;\\n\\n        while(si <= ei)\\n        {\\n            long mid = (si) + (ei - si)/2;\\n            if(helper(mid, ranks, cars))\\n            {\\n                time = mid;\\n                ei = mid - 1;\\n            }\\n            else\\n            {\\n                si = mid + 1;\\n            }\\n        }\\n        return time; \\n    }\\n    \\n    public boolean helper(long mid, long[] ranks, long cars)\\n    {\\n        for(int i = 0; i < ranks.length; i++)\\n        {\\n            long x = (long)Math.floor(Math.sqrt((mid * 1.0)/(ranks[i] * 1.0)));\\n            if(x >= cars)\\n                return true;\\n            cars-= x;\\n            if(cars == 0)\\n                return true;\\n        }\\n        return (cars == 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long repairCars(int[] arr, int c) {\\n        long[] ranks = new long[arr.length];\\n        int idx = 0;\\n        for(int ele : arr)\\n        {\\n            ranks[idx++] = (ele * 1l);\\n        }\\n        Arrays.sort(ranks);\\n        long cars = (c * 1l);\\n        \\n        int n = ranks.length;\\n        long time = (int)1e14;\\n        long si = 0;\\n        long ei = Long.MAX_VALUE;\\n\\n        while(si <= ei)\\n        {\\n            long mid = (si) + (ei - si)/2;\\n            if(helper(mid, ranks, cars))\\n            {\\n                time = mid;\\n                ei = mid - 1;\\n            }\\n            else\\n            {\\n                si = mid + 1;\\n            }\\n        }\\n        return time; \\n    }\\n    \\n    public boolean helper(long mid, long[] ranks, long cars)\\n    {\\n        for(int i = 0; i < ranks.length; i++)\\n        {\\n            long x = (long)Math.floor(Math.sqrt((mid * 1.0)/(ranks[i] * 1.0)));\\n            if(x >= cars)\\n                return true;\\n            cars-= x;\\n            if(cars == 0)\\n                return true;\\n        }\\n        return (cars == 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321055,
                "title": "python-3-3-lines-bisect-left-t-m-1712-ms-17-7-mb",
                "content": "Note that we can use integer division and integer square root `isqrt` because of the nature of the problem. \\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        \\n        arr = range(cars*cars * max(ranks))\\n\\n        f = lambda t: sum(isqrt(t//r) for r in ranks)\\n\\n        return  bisect_left(arr,cars, key = lambda t: f(t))\\n```\\n[https://leetcode.com/problems/minimum-time-to-repair-cars/submissions/918948065/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        \\n        arr = range(cars*cars * max(ranks))\\n\\n        f = lambda t: sum(isqrt(t//r) for r in ranks)\\n\\n        return  bisect_left(arr,cars, key = lambda t: f(t))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321044,
                "title": "python-3-3-lines-bisect-left-t-m-1712-ms-17-7-mb",
                "content": "Note that we can use integer division and integer square root `isqrt` because of the nature of the problem. \\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        \\n        arr = range(cars*cars * max(ranks))\\n\\n        f = lambda t: sum(isqrt(t//r) for r in ranks)\\n\\n        return  bisect_left(arr,cars, key = lambda t: f(t))\\n```\\n[https://leetcode.com/problems/minimum-time-to-repair-cars/submissions/918948065/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        \\n        arr = range(cars*cars * max(ranks))\\n\\n        f = lambda t: sum(isqrt(t//r) for r in ranks)\\n\\n        return  bisect_left(arr,cars, key = lambda t: f(t))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313508,
                "title": "java-beats-100-not-binary-search-min-heap-of-mechanic-groups-sorted-by-least-next-cost",
                "content": "# Intuition\\nWe want to sort and choose mechanics (to take on a next car) by the *minimum total cost to repair their existing cars plus the next car*. This lets us keep the total time at a minimum *at all times* as we assign each car. We can calculate this cost, which means we can sort by it. To keep the code readable, we\\'ll create a `Mechanic` class and encapsulate this total time to repair the next car in our `Mechanic` class. We\\'ll also need to track the total time to repair current cars, so we can find our maximum (though we can keep a running maximum).\\n\\nAlso, there are at most 100 distinct ranks, so instead of tracking individual mechanics, we could track groups of mechanics of the same rank and potentially save a lot of time.\\n\\nSo, there are two key ideas:\\n* Group mechanics by rank, since there are only 100 ranks but up to 100,000 mechanics.\\n* For each group of mechanics, track how much time it would take them to repair their current assignment of cars _and_ the assignment of one more car, so we can use this to select the next mechanic group to which to assign more cars to repair.\\n\\n# Approach\\nWe create a `Mechanic` class to encapsulate a group of mechanics of the same rank.  Its fields are:\\n * `rank`: the rank of the mechanics\\n * `count`: the number of mechanics with this rank\\n * `repairing`: the number of cars the mechanics are currently repairing\\n   * this is not actually needed, but may be helpful for debugging; you can omit it for speed\\n* `time`: the time to repair the current number of cars (`repairing`) being repaired\\n* `costOfNextCar`: the amount of additional time it would take to repair one more car (per mechanic in this group)\\n* `timeWithNextCar`: the total amount of time it would take to repair one more car (per mechanic in this group), equivalent to `time + costOfNextCar`\\n\\nThen we make `Mechanic` implement `Comparable<Mechanic>` with a sort order based on `timeWithNextCar` ascending. This ensures when we keep our mechanic (groups) in a `PriorityQueue<Mechanic>` then the first mechanic group polled is the one that has the least total time if we add another car for each to repair.\\n\\nFinally, we can poll our mechanic groups one at a time, and add a car to them (updating all of the time totals); then we remove their count from the total number of cars needing repair (as the group is taking on as many cars as there are mechanics in the group), continuing until the remaining count is no longer greater than zero. If we go negative, it\\'s okay, it just means that some mechanics within the last group don\\'t actually get an additional car to repair, but at least one does, so the maximum time is potentially impacted.\\n\\n# Code (Java)\\n```\\nclass Solution {\\n\\n    public long repairCars(int[] ranks, int cars) {\\n        // Intuition: we want to sort mechanics by least time to add a car.\\n        // Let\\'s group them by rank to make this faster, since there are only 100 ranks\\n        final Map<Integer, Integer> rankFreqMap = new HashMap<>();\\n        for (int rank : ranks) {\\n            rankFreqMap.compute(rank, (k, v) -> (v == null ? 1 : v + 1));\\n        }\\n        final PriorityQueue<Mechanic> pq = new PriorityQueue<>();\\n        for (Map.Entry<Integer, Integer> rankFreqEntry : rankFreqMap.entrySet()) {\\n            pq.offer(new Mechanic(rankFreqEntry.getKey(), rankFreqEntry.getValue()));\\n        }\\n        long maxTime = 0;\\n        int remaining = cars;\\n        while (remaining > 0) {\\n            final Mechanic mechanicGroup = pq.poll();\\n            mechanicGroup.addCarPerMechanic();\\n            maxTime = Math.max(maxTime, mechanicGroup.getTime());\\n            remaining -= mechanicGroup.getCount();\\n            pq.offer(mechanicGroup);\\n        }\\n        return maxTime;\\n    }\\n\\n    static class Mechanic implements Comparable<Mechanic> {\\n\\n        final int rank;\\n        final int count;\\n        private int repairing;\\n        private long time;\\n        private long costOfNextCar;\\n        private long timeWithNextCar;\\n\\n        public Mechanic(int rank, int count) {\\n            this.rank = rank;\\n            this.count = count;\\n            this.repairing = 0;\\n            this.time = 0;\\n            this.costOfNextCar = rank;\\n            this.timeWithNextCar = rank;\\n        }\\n\\n        public int getCount() {\\n            return this.count;\\n        }\\n\\n        public long getTime() {\\n            return this.time;\\n        }\\n\\n        public void addCarPerMechanic() {\\n            this.repairing++;\\n            this.time = timeWithNextCar;\\n            this.costOfNextCar += (long) (rank << 1);\\n            this.timeWithNextCar = this.time + this.costOfNextCar;\\n        }\\n\\n        @Override\\n        public int compareTo(final Mechanic other) {\\n            return Long.compare(this.timeWithNextCar, other.timeWithNextCar);\\n        }\\n    }\\n}\\n\\n```\\n\\n# Complexity\\n- Time complexity: This is complicated. We have at most 100 mechanic groups. Let\\'s talk about average time complexity for a large number of mechanic ranks. If we have N cars and M ranks of which R ranks are distinct we\\'ll have an average of M/R mechanics per group, and our loop will run (N/(M/R)) or RN/M times.  Each time it runs, we poll and requeue one mechanic, which are O(log R) operations, and we do this RN/M times.  So we have a time complexity of O(RN/M log R).  We know R has an upper bound of 100, and if we consider this a constant for R, we really have an O(N/M) time complexity.  (I think - please chime in in the comments if you have a better analysis, I\\'ll be happy to fix this if I\\'m making things more complex than necessary).\\n\\n- Space complexity: We need at most R mechanics, so O(R) space, where R is the number of distinct mechanic ranks. If we consider R a constant (max 100) then O(1) space.\\n\\n# Runtime\\n129ms as of 2023-03-18 (faster than 100% as of submission).  May run faster with removal of the count of cars being repaired (the `repairing` field).\\n\\n# Why This Solution Matters\\nA binary search approach (as given in the hint) will work. And it will be reasonably fast. But in the end, you only have the answer; you do not have the number of cars repaired by each mechanic, nor do you see the solution evolve with each mechanic group taking on additional repairs over time. As a result, a solution like this sets you up to better handle certain obvious follow-up questions, like \"in your solution, how many cars do the best-ranked mechanics repair versus the worst-ranked mechanics\" and so on. There\\'s nothing wrong with the binary search solution, but this solution gives you more information which is immediately available alongside the answer when it completes.\\n\\n# Standard Plea\\nIf you found this useful, interesting, or worth a read, **I\\'d appreciate your upvote**. Even if not, I\\'d **greatly appreciate any comments to help me write better solutions** (in general, or specific comments on how to improve this one). Thanks for your time and happy coding!\\n\\n--\\n[Edit on 2023-03-21: variable name improvements for clarity.]\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long repairCars(int[] ranks, int cars) {\\n        // Intuition: we want to sort mechanics by least time to add a car.\\n        // Let\\'s group them by rank to make this faster, since there are only 100 ranks\\n        final Map<Integer, Integer> rankFreqMap = new HashMap<>();\\n        for (int rank : ranks) {\\n            rankFreqMap.compute(rank, (k, v) -> (v == null ? 1 : v + 1));\\n        }\\n        final PriorityQueue<Mechanic> pq = new PriorityQueue<>();\\n        for (Map.Entry<Integer, Integer> rankFreqEntry : rankFreqMap.entrySet()) {\\n            pq.offer(new Mechanic(rankFreqEntry.getKey(), rankFreqEntry.getValue()));\\n        }\\n        long maxTime = 0;\\n        int remaining = cars;\\n        while (remaining > 0) {\\n            final Mechanic mechanicGroup = pq.poll();\\n            mechanicGroup.addCarPerMechanic();\\n            maxTime = Math.max(maxTime, mechanicGroup.getTime());\\n            remaining -= mechanicGroup.getCount();\\n            pq.offer(mechanicGroup);\\n        }\\n        return maxTime;\\n    }\\n\\n    static class Mechanic implements Comparable<Mechanic> {\\n\\n        final int rank;\\n        final int count;\\n        private int repairing;\\n        private long time;\\n        private long costOfNextCar;\\n        private long timeWithNextCar;\\n\\n        public Mechanic(int rank, int count) {\\n            this.rank = rank;\\n            this.count = count;\\n            this.repairing = 0;\\n            this.time = 0;\\n            this.costOfNextCar = rank;\\n            this.timeWithNextCar = rank;\\n        }\\n\\n        public int getCount() {\\n            return this.count;\\n        }\\n\\n        public long getTime() {\\n            return this.time;\\n        }\\n\\n        public void addCarPerMechanic() {\\n            this.repairing++;\\n            this.time = timeWithNextCar;\\n            this.costOfNextCar += (long) (rank << 1);\\n            this.timeWithNextCar = this.time + this.costOfNextCar;\\n        }\\n\\n        @Override\\n        public int compareTo(final Mechanic other) {\\n            return Long.compare(this.timeWithNextCar, other.timeWithNextCar);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316423,
                "title": "c-binary-search",
                "content": "# Code\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n#define LL long long\\nclass Solution {\\npublic:\\n    LL repairCars(vector<int>& ranks, int cars) {\\n        LL lo=0,hi=1E15;\\n        LL res=0;\\n        while(lo<=hi){\\n            LL mid=(lo+hi)/2;\\n            LL op=0;\\n            for(auto x:ranks){\\n                op+=(LL)sqrtl(mid/x);\\n            }\\n            if(op>=cars){\\n                res=mid;\\n                hi=mid-1;\\n            }\\n            else{\\n                lo=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n#define LL long long\\nclass Solution {\\npublic:\\n    LL repairCars(vector<int>& ranks, int cars) {\\n        LL lo=0,hi=1E15;\\n        LL res=0;\\n        while(lo<=hi){\\n            LL mid=(lo+hi)/2;\\n            LL op=0;\\n            for(auto x:ranks){\\n                op+=(LL)sqrtl(mid/x);\\n            }\\n            if(op>=cars){\\n                res=mid;\\n                hi=mid-1;\\n            }\\n            else{\\n                lo=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3314036,
                "title": "binary-search-c-short-sweet-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        int n = ranks.size();\\n        for(int i = 0; i < n; i++){};\\n        long long int mn = 1, mx = (1e14),mid,ans;\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            long long int k = 0;\\n            for(auto &i: ranks){\\n                k += sqrt(mid/i);\\n            }\\n            if(k==cars){\\n                ans = mid;\\n                mx = mid-1;\\n            }else if(k>cars){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        int n = ranks.size();\\n        for(int i = 0; i < n; i++){};\\n        long long int mn = 1, mx = (1e14),mid,ans;\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            long long int k = 0;\\n            for(auto &i: ranks){\\n                k += sqrt(mid/i);\\n            }\\n            if(k==cars){\\n                ans = mid;\\n                mx = mid-1;\\n            }else if(k>cars){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312237,
                "title": "concise-binary-search-c",
                "content": "```\\nclass Solution {\\n    bool good2(long long x, long long i, long long t) {\\n        return i * x * x < t;\\n    }\\n    bool good1(long long x, vector<int>& ranks, int cars) {\\n        long long cnt = 0;\\n        for(int i : ranks) {\\n            long long s = 0, e = cars, a = 0;\\n            while(s <= e) {\\n                long long m = (s + e) / 2;\\n                if(good2(m, i, x)) s = m + 1, a = m;\\n                else e = m - 1;\\n            }\\n            cnt += a;\\n        }\\n        return cnt >= cars;\\n    }\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long s = 0, e = 1e18, ans;\\n        while(s <= e) {\\n            long long m = (s + e) / 2;\\n            if(good1(m, ranks, cars)) e = m - 1, ans = m;\\n            else s = m + 1;\\n        }\\n        return ans - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool good2(long long x, long long i, long long t) {\\n        return i * x * x < t;\\n    }\\n    bool good1(long long x, vector<int>& ranks, int cars) {\\n        long long cnt = 0;\\n        for(int i : ranks) {\\n            long long s = 0, e = cars, a = 0;\\n            while(s <= e) {\\n                long long m = (s + e) / 2;\\n                if(good2(m, i, x)) s = m + 1, a = m;\\n                else e = m - 1;\\n            }\\n            cnt += a;\\n        }\\n        return cnt >= cars;\\n    }\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long s = 0, e = 1e18, ans;\\n        while(s <= e) {\\n            long long m = (s + e) / 2;\\n            if(good1(m, ranks, cars)) e = m - 1, ans = m;\\n            else s = m + 1;\\n        }\\n        return ans - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312129,
                "title": "python-3-binary-search",
                "content": "The helper function *repair(time)* determines if *cars* can be repaired within *time*.\\n\\n# Code\\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        lo,hi = 0,100*cars*cars\\n        def repair(time):\\n            n = cars\\n            for r in ranks:\\n                n -= floor(sqrt(time/r))\\n                if n<=0:\\n                    break\\n            return n<=0\\n        while lo<=hi:\\n            m = (lo+hi)//2\\n            if repair(m):\\n                ans = m\\n                hi = m-1\\n            else:\\n                lo = m+1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        lo,hi = 0,100*cars*cars\\n        def repair(time):\\n            n = cars\\n            for r in ranks:\\n                n -= floor(sqrt(time/r))\\n                if n<=0:\\n                    break\\n            return n<=0\\n        while lo<=hi:\\n            m = (lo+hi)//2\\n            if repair(m):\\n                ans = m\\n                hi = m-1\\n            else:\\n                lo = m+1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311998,
                "title": "easy-binary-search-n-log-n-c-list-of-bs-problems",
                "content": "# Intuition\\nIf we are asked for the minimum time to do something, it is possibly a binary search :)   \\n\\n# Approach\\n\\nFirst we define a classical binary search for the problem, we define the function $check$ that tells the number of cars that all workers can repair in $T$ time, it is clear that we just need to get this sum: $TotalCarsRepaired = \\\\Sigma \\\\frac{T}{t_i}$ and as that means the number of cars that the whole team can repair we just need to compare with $cars$ to know if that time is valid, i.e. $TotalCarsRepaired \\\\geq cars$.\\n\\nThis is a classic binary search problem, but in our problem the time $t_i$  that some worker uses to repair $1$ car is not given, but the problem gives a total time depending on the number of cars, which forces to change a little the summation. \\n\\nNow instead of obtaining $t_i$ for each worker we obtain $n_i$ (maximum number of cars that worker $i$ can repair in $T$ time). For each worker $i$,the problem states that. \\n$t_i$ depends on the number of cars he repaired. $r_i \\\\times n_i^2$ so here we have the value $n_i$ we are looking for, let\\'s define the inequation $r_i \\\\times n_i^2 \\\\leq T$ which must be true for some $T$. \\n\\nTherefore, we can manipulate the equation to obtain the maximum possible $n_i$ \\n$$ r_i \\\\times n_i^2 \\\\leq T$$\\n$$ n_i^2 \\\\leq \\\\frac{T}{r_i} $$\\n$$ n_i^2 \\\\sqrt \\\\frac{T}{r_i} $$\\n\\nSo for each worker we can know the maximum number of cars that can be repaired by them, now the summation is $TotalCarsRepaired = \\\\Sigma n_i$ now we can use this function to properly move our binary search.\\n\\n# More problems \\nA list of similar problems including the easy version of this.\\n[Medium - the easy version](https://leetcode.com/problems/minimum-time-to-complete-trips/)\\n[Medium - similar](https://leetcode.com/problems/koko-eating-bananas/)\\n[Medium - similar](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n[Hard - similar](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\\n[Medium](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/)\\n[Hard](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\\n\\n# Complexity\\n- Time complexity:\\n$O(n log(n))$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &v,int N,long long t){\\n        long long pos = 0;\\n        for(int i = 0;i<v.size();i++){\\n            long long n = sqrt(t/v[i]);\\n            pos+=n;\\n            if(pos>=N)return true;\\n        }\\n        if(pos>=N)return true;\\n        return false;\\n    }\\n    \\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long l = 0,r = 1e16;\\n        while(l+1<r){\\n            long long m = (l+r)>>1;\\n            if(check(ranks,cars,m))r = m;\\n            else l = m;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &v,int N,long long t){\\n        long long pos = 0;\\n        for(int i = 0;i<v.size();i++){\\n            long long n = sqrt(t/v[i]);\\n            pos+=n;\\n            if(pos>=N)return true;\\n        }\\n        if(pos>=N)return true;\\n        return false;\\n    }\\n    \\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long l = 0,r = 1e16;\\n        while(l+1<r){\\n            long long m = (l+r)>>1;\\n            if(check(ranks,cars,m))r = m;\\n            else l = m;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098186,
                "title": "98-44-3-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        \\n        arr = range(cars*cars * max(ranks))\\n\\n        f = lambda t: sum(isqrt(t//r) for r in ranks)\\n\\n        return  bisect_left(arr,cars, key = lambda t: f(t))\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        \\n        arr = range(cars*cars * max(ranks))\\n\\n        f = lambda t: sum(isqrt(t//r) for r in ranks)\\n\\n        return  bisect_left(arr,cars, key = lambda t: f(t))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464723,
                "title": "python-binary-search-with-explanation",
                "content": "# Intuition\\n1. Find minimum time within which given number of cars could be repaired.\\n2. Count cars that can be repaired by each person within x time. If more cars can be repaired during x time than given number of cars, search for a lesser time.\\n3. If lesser cars can be repaired during x time than given number of cars, search for higher time.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        ans,low,high = -1,1,10**14\\n        while low <= high:\\n            mid = (low+high)//2\\n            i=0\\n            cars_temp=0\\n            while i < len(ranks):\\n                cars_temp += math.floor((mid/ranks[i])**0.5)\\n#count cars for given rank and selected time\\n\\n                i+=1\\n            if cars_temp >= cars:\\n                ans=mid\\n                high = mid-1 #If more cars can be repaired during x time than given number of cars, search for a lesser time.\\n\\n            else:\\n                low=mid+1 #If lesser cars can be repaired during x time than given number of cars, search for higher time.\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        ans,low,high = -1,1,10**14\\n        while low <= high:\\n            mid = (low+high)//2\\n            i=0\\n            cars_temp=0\\n            while i < len(ranks):\\n                cars_temp += math.floor((mid/ranks[i])**0.5)\\n#count cars for given rank and selected time\\n\\n                i+=1\\n            if cars_temp >= cars:\\n                ans=mid\\n                high = mid-1 #If more cars can be repaired during x time than given number of cars, search for a lesser time.\\n\\n            else:\\n                low=mid+1 #If lesser cars can be repaired during x time than given number of cars, search for higher time.\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407365,
                "title": "c-100-faster-binary-search-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& ranks, long long cars, long long time)  {\\n        long long cnt = 0;\\n        for(auto it : ranks)   {\\n            cnt += sqrt(time / it);\\n            if(cnt >= cars) return true;\\n        }\\n        return cnt >= cars;\\n    }\\n\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long s=0, e=ranks[0]*1LL*cars*cars, ans = e;\\n        while(s <= e)   {\\n            long long mid = s + (e - s) / 2;\\n            if(isPossible(ranks, cars, mid))    {\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else     s = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& ranks, long long cars, long long time)  {\\n        long long cnt = 0;\\n        for(auto it : ranks)   {\\n            cnt += sqrt(time / it);\\n            if(cnt >= cars) return true;\\n        }\\n        return cnt >= cars;\\n    }\\n\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long s=0, e=ranks[0]*1LL*cars*cars, ans = e;\\n        while(s <= e)   {\\n            long long mid = s + (e - s) / 2;\\n            if(isPossible(ranks, cars, mid))    {\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else     s = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392489,
                "title": "100-working-solution-in-java-binary-search-on-answer-concept",
                "content": "```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long st=1, end=(long)(1e14);\\n        \\n        while(st<end){\\n            long mid= st + (end-st)/2;\\n            if(solve(ranks,cars,mid)==true){\\n                end=mid;\\n            } else {\\n                st=mid+1;\\n            }\\n        }\\n        \\n        return st;\\n    }\\n    \\n    public boolean solve(int[] ranks, int cars, long div){\\n        long sum= 0;\\n        \\n        for(int i=0; i<ranks.length; i++){\\n            sum+= (long)(Math.sqrt(1.0 * div/ranks[i]));\\n        }\\n        \\n        if(sum>=cars){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long st=1, end=(long)(1e14);\\n        \\n        while(st<end){\\n            long mid= st + (end-st)/2;\\n            if(solve(ranks,cars,mid)==true){\\n                end=mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3328487,
                "title": "accepted-c-simple-3-lines-explanation-time-o-nlogn",
                "content": "\\n\\n\\n# \\u2714\\uFE0F Approach\\n## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- Suppose that the answer is k minutes, then we check if all the cars can be repaired in k minutes.\\n- If it can be repaired in k minutes, then it is possibly an answer but we look to optimise it further.\\n- If it cant be repaired in k minutes, we check for some greater value than k.\\n- We use the Binary Search to do so.\\n\\n\\n\\n- ### Time complexity:  O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- ### Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n\\n    // check if all the cars can be repaired in the t time\\n    // OUTPUT -> True Or False \\n    bool can_all_be_repaired(vector<int>& ranks, int cars, ll time){\\n        // for every merchanic, we check how many cars he/she can repaired in given \"time\";\\n        ll total_cars_repaired = 0;\\n        int ranks_size = ranks.size();\\n        for(int i=0; i<ranks_size; i++){\\n            total_cars_repaired += (ll)sqrt(time/(ll)ranks[i]);\\n            // cout << total_cars_repaired << \" \";\\n        }\\n        // cout << endl;\\n        return total_cars_repaired >= cars;\\n\\n    }\\n\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        \\n        ll maxVal = 0;\\n        int size = ranks.size();\\n        for(int i=0; i<size; i++){\\n            if(maxVal < ranks[i]){\\n                maxVal = (ll) ranks[i];\\n            }\\n        }\\n\\n        // let assume the range to be [ 1 , maxVal* cars^2 ]\\n        ll low = 1, high = maxVal*((ll)cars*(ll)cars);\\n\\n        while(low <= high){\\n            ll mid = (low + high)>>1;\\n\\n            if(can_all_be_repaired(ranks, cars, mid)){\\n                high = mid-1;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return high+1;\\n        \\n    }\\n};\\n \\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n\\n    // check if all the cars can be repaired in the t time\\n    // OUTPUT -> True Or False \\n    bool can_all_be_repaired(vector<int>& ranks, int cars, ll time){\\n        // for every merchanic, we check how many cars he/she can repaired in given \"time\";\\n        ll total_cars_repaired = 0;\\n        int ranks_size = ranks.size();\\n        for(int i=0; i<ranks_size; i++){\\n            total_cars_repaired += (ll)sqrt(time/(ll)ranks[i]);\\n            // cout << total_cars_repaired << \" \";\\n        }\\n        // cout << endl;\\n        return total_cars_repaired >= cars;\\n\\n    }\\n\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        \\n        ll maxVal = 0;\\n        int size = ranks.size();\\n        for(int i=0; i<size; i++){\\n            if(maxVal < ranks[i]){\\n                maxVal = (ll) ranks[i];\\n            }\\n        }\\n\\n        // let assume the range to be [ 1 , maxVal* cars^2 ]\\n        ll low = 1, high = maxVal*((ll)cars*(ll)cars);\\n\\n        while(low <= high){\\n            ll mid = (low + high)>>1;\\n\\n            if(can_all_be_repaired(ranks, cars, mid)){\\n                high = mid-1;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return high+1;\\n        \\n    }\\n};\\n \\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3314883,
                "title": "beats-100-java-easy-to-understand-code-binary-search",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$ O(N log T)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$ O(1)$$\\n# Code\\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long ans = (long) 1e14;\\n        long l = 1;\\n        long h = (long) 1e14;\\n        while(l < h){\\n            long mid = l + (h - l)/2;\\n            if(canRepare(ranks, mid) >= cars){\\n                ans = mid;\\n                h = mid;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public long canRepare(int[] ranks, long time){\\n        long totalCar = 0;\\n        for(int i = 0; i < ranks.length; i++){\\n            totalCar += (long)Math.sqrt(time/ranks[i]);\\n        }\\n\\n        \\n        return totalCar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long ans = (long) 1e14;\\n        long l = 1;\\n        long h = (long) 1e14;\\n        while(l < h){\\n            long mid = l + (h - l)/2;\\n            if(canRepare(ranks, mid) >= cars){\\n                ans = mid;\\n                h = mid;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public long canRepare(int[] ranks, long time){\\n        long totalCar = 0;\\n        for(int i = 0; i < ranks.length; i++){\\n            totalCar += (long)Math.sqrt(time/ranks[i]);\\n        }\\n\\n        \\n        return totalCar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313360,
                "title": "java-binary-searching-on-answers",
                "content": "## Solution 1:\\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long lo = 1, hi = (long) 1e14;\\n        long ans = 0;\\n        while (lo <= hi) {\\n            long mid = lo + (hi - lo) / 2;\\n            if (canRepair(ranks, mid) >= cars) {\\n                ans = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private long canRepair(int[] ranks, long time) {\\n        long cars = 0;\\n        for (int r : ranks) {\\n            cars += (long) Math.sqrt(time / r);\\n        }\\n        return cars;\\n    }\\n}\\n\\n// TC: O(n.log(10^14))\\n```\\n# Or\\n## Solution 2:\\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long lo = 1, hi = (long) 100 * cars * cars;\\n        long ans = 0;\\n        while (lo <= hi) {\\n            long mid = lo + (hi - lo) / 2; \\n            long canRepair = 0;\\n            for (int r : ranks) {\\n                canRepair += (long) Math.sqrt(mid / r);\\n            }\\n            if (canRepair >= cars) {\\n                hi = mid - 1;\\n                ans = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(n.log(cars^2))\\n```\\n---\\n*You can check out my video explanation (Channel link in profile bio).*",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long lo = 1, hi = (long) 1e14;\\n        long ans = 0;\\n        while (lo <= hi) {\\n            long mid = lo + (hi - lo) / 2;\\n            if (canRepair(ranks, mid) >= cars) {\\n                ans = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private long canRepair(int[] ranks, long time) {\\n        long cars = 0;\\n        for (int r : ranks) {\\n            cars += (long) Math.sqrt(time / r);\\n        }\\n        return cars;\\n    }\\n}\\n\\n// TC: O(n.log(10^14))\\n```\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long lo = 1, hi = (long) 100 * cars * cars;\\n        long ans = 0;\\n        while (lo <= hi) {\\n            long mid = lo + (hi - lo) / 2; \\n            long canRepair = 0;\\n            for (int r : ranks) {\\n                canRepair += (long) Math.sqrt(mid / r);\\n            }\\n            if (canRepair >= cars) {\\n                hi = mid - 1;\\n                ans = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(n.log(cars^2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313014,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func repairCars(_ ranks: [Int], _ cars: Int) -> Int {\\n        \\n        var (l, r) = (1, ranks.min()!*cars*cars)\\n        \\n        while l < r{\\n            var (res, mid) = (0, (l+r)/2)\\n            \\n            for rank in ranks{\\n                res += Int(sqrt(Double(mid)/Double(rank)))\\n            }\\n\\n            res < cars ? (l = mid + 1) : (r = mid)\\n        }\\n        \\n        return l\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func repairCars(_ ranks: [Int], _ cars: Int) -> Int {\\n        \\n        var (l, r) = (1, ranks.min()!*cars*cars)\\n        \\n        while l < r{\\n            var (res, mid) = (0, (l+r)/2)\\n            \\n            for rank in ranks{\\n                res += Int(sqrt(Double(mid)/Double(rank)))\\n            }\\n\\n            res < cars ? (l = mid + 1) : (r = mid)\\n        }\\n        \\n        return l\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312550,
                "title": "simple-binary-search-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: nlog(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean fun(int ranks[],int cars,long t){\\n        long a=0;\\n        for(int i:ranks){\\n            a+=Math.sqrt(t/i);\\n        }\\n        if(a>=cars) return true;\\n        return false;\\n    }\\n    public long repairCars(int[] ranks, int cars) {\\n        long min=ranks[0];\\n        for(int i:ranks){\\n            min=Math.min(min,i);\\n        }\\n        long h=min*cars*cars;\\n        long l=1;\\n        long ans=h;\\n        while(l<h){\\n            long mid=(l+h)/2;\\n            if(fun(ranks,cars,mid)){\\n                h=mid;\\n                ans=mid;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean fun(int ranks[],int cars,long t){\\n        long a=0;\\n        for(int i:ranks){\\n            a+=Math.sqrt(t/i);\\n        }\\n        if(a>=cars) return true;\\n        return false;\\n    }\\n    public long repairCars(int[] ranks, int cars) {\\n        long min=ranks[0];\\n        for(int i:ranks){\\n            min=Math.min(min,i);\\n        }\\n        long h=min*cars*cars;\\n        long l=1;\\n        long ans=h;\\n        while(l<h){\\n            long mid=(l+h)/2;\\n            if(fun(ranks,cars,mid)){\\n                h=mid;\\n                ans=mid;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312461,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        count=Counter(ranks)\\n        left=1\\n        right=min(count)*cars*cars\\n        while left<right:\\n            mid=(left+right)//2\\n            if sum(isqrt(mid//a)*count[a] for a in count)<cars:\\n                left=mid+1\\n\\n            else:\\n                right=mid\\n\\n        return left            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        count=Counter(ranks)\\n        left=1\\n        right=min(count)*cars*cars\\n        while left<right:\\n            mid=(left+right)//2\\n            if sum(isqrt(mid//a)*count[a] for a in count)<cars:\\n                left=mid+1\\n\\n            else:\\n                right=mid\\n\\n        return left            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312280,
                "title": "go-binary-search",
                "content": "# Code\\n```\\nfunc repairCars(ranks []int, cars int) int64 {\\n    left, right := int64(0), int64(ranks[0]) * int64(cars) * int64(cars)\\n    for left <= right {\\n        mid := (left + right) / 2\\n        if solve(mid, ranks, cars) <= 0 {\\n            right = mid - 1\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n    return left\\n}\\n\\nfunc solve(mid int64, ranks []int, cars int) int {\\n    for _, rank := range ranks {\\n        x := mid / int64(rank)\\n        cars -= int(math.Sqrt(float64(x)))\\n        if cars <= 0 { break }\\n    }\\n    return cars\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc repairCars(ranks []int, cars int) int64 {\\n    left, right := int64(0), int64(ranks[0]) * int64(cars) * int64(cars)\\n    for left <= right {\\n        mid := (left + right) / 2\\n        if solve(mid, ranks, cars) <= 0 {\\n            right = mid - 1\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n    return left\\n}\\n\\nfunc solve(mid int64, ranks []int, cars int) int {\\n    for _, rank := range ranks {\\n        x := mid / int64(rank)\\n        cars -= int(math.Sqrt(float64(x)))\\n        if cars <= 0 { break }\\n    }\\n    return cars\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3312181,
                "title": "binary-search-c-short-sweet-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int mn = 1, mx = (1e14),mid,ans;\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            long long int k = 0;\\n            for(auto &i: ranks){\\n                k += sqrt(mid/i);\\n            }\\n            if(k==cars){\\n                ans = mid;\\n                mx = mid-1;\\n            }else if(k>cars){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int mn = 1, mx = (1e14),mid,ans;\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            long long int k = 0;\\n            for(auto &i: ranks){\\n                k += sqrt(mid/i);\\n            }\\n            if(k==cars){\\n                ans = mid;\\n                mx = mid-1;\\n            }else if(k>cars){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312158,
                "title": "c-simple-binary-search",
                "content": "# Intuition\\n- We have to find min time to repair all cars. \\n- The max time is required by highest rank mechanic. \\n- The number of cars repaired in X minutes by ith mechanic \\n    = `Math.sqrt (x / Rank[i])`\\n- We have to find min minutes when all cars are repaired. Since time is linearly increasing, we can use binary search\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(N log T)$$ where T = (cars ^ 2) * MaxRank\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public long RepairCars(int[] ranks, int cars)\\n    {\\n        Array.Sort(ranks);\\n        long low = 1, high = 1L * ranks[^1] * cars * cars;\\n\\n        while (low < high)\\n        {\\n            long mid = low + (high - low) / 2;\\n            long carsRepaired = 0;\\n\\n            for (int i = 0; i < ranks.Length; i++)\\n            {\\n                carsRepaired += (int)Math.Sqrt(1.0d * mid / ranks[i]);                \\n            }\\n\\n            if (carsRepaired < cars)\\n            {\\n                low = mid + 1;                \\n            }\\n            else\\n            {\\n                high = mid;\\n            }\\n        }\\n\\n        return low;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public long RepairCars(int[] ranks, int cars)\\n    {\\n        Array.Sort(ranks);\\n        long low = 1, high = 1L * ranks[^1] * cars * cars;\\n\\n        while (low < high)\\n        {\\n            long mid = low + (high - low) / 2;\\n            long carsRepaired = 0;\\n\\n            for (int i = 0; i < ranks.Length; i++)\\n            {\\n                carsRepaired += (int)Math.Sqrt(1.0d * mid / ranks[i]);                \\n            }\\n\\n            if (carsRepaired < cars)\\n            {\\n                low = mid + 1;                \\n            }\\n            else\\n            {\\n                high = mid;\\n            }\\n        }\\n\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312125,
                "title": "priority-queue-tle",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        int i=1;\\n        long long sq[cars + 1];\\n        sq[0] = 1;\\n        while (i < cars + 1){\\n            sq[i] = sq[i - 1] + (i + 1) * 2 - 1;\\n            i++;\\n        }\\n        priority_queue<pair<long long, long long>, std::vector<pair<long long, long long>>, std::greater<pair< long long, long long> > > pq;\\n        for (auto &a: ranks){\\n            pq.push({a * sq[0], 0});\\n        }\\n        while (cars > 1){\\n            auto top = pq.top();\\n            pq.pop();\\n            pq.push({(top.first / sq[top.second]) * sq[top.second + 1], top.second + 1});\\n            cars--;\\n        }\\n        return pq.top().first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        int i=1;\\n        long long sq[cars + 1];\\n        sq[0] = 1;\\n        while (i < cars + 1){\\n            sq[i] = sq[i - 1] + (i + 1) * 2 - 1;\\n            i++;\\n        }\\n        priority_queue<pair<long long, long long>, std::vector<pair<long long, long long>>, std::greater<pair< long long, long long> > > pq;\\n        for (auto &a: ranks){\\n            pq.push({a * sq[0], 0});\\n        }\\n        while (cars > 1){\\n            auto top = pq.top();\\n            pq.pop();\\n            pq.push({(top.first / sq[top.second]) * sq[top.second + 1], top.second + 1});\\n            cars--;\\n        }\\n        return pq.top().first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312001,
                "title": "python-binary-search",
                "content": "```python\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        \\n        def possible(m):\\n            rest = cars\\n            for r in ranks:\\n                rest -= int(math.sqrt(m // r))\\n            return rest <= 0\\n    \\n        lo, hi = 1, 10**15        \\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if possible(mid):\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n\\n        return lo\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        \\n        def possible(m):\\n            rest = cars\\n            for r in ranks:\\n                rest -= int(math.sqrt(m // r))\\n            return rest <= 0\\n    \\n        lo, hi = 1, 10**15        \\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if possible(mid):\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311995,
                "title": "binary-search-on-answer",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool canRepairAllCars(long long potentialMinTime, int totalCars, vector<int>& ranks)\\n    {\\n        long long repairCapacityWithPotentialMinTime = 0;\\n        for(auto rank : ranks) repairCapacityWithPotentialMinTime += sqrt(potentialMinTime/rank);\\n        return repairCapacityWithPotentialMinTime >= totalCars;\\n    }\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        \\n        long long low = 1, high = LONG_MAX, potentialMinTime, minTimeToRepairCars = LONG_MAX;\\n        \\n        while(low <= high)\\n        {\\n            potentialMinTime = low + (high - low) / 2;\\n            \\n            if(canRepairAllCars(potentialMinTime, cars, ranks)){\\n                minTimeToRepairCars = potentialMinTime;\\n                high = potentialMinTime - 1;\\n            }\\n            else low = potentialMinTime + 1;\\n        }\\n        return minTimeToRepairCars;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool canRepairAllCars(long long potentialMinTime, int totalCars, vector<int>& ranks)\\n    {\\n        long long repairCapacityWithPotentialMinTime = 0;\\n        for(auto rank : ranks) repairCapacityWithPotentialMinTime += sqrt(potentialMinTime/rank);\\n        return repairCapacityWithPotentialMinTime >= totalCars;\\n    }\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        \\n        long long low = 1, high = LONG_MAX, potentialMinTime, minTimeToRepairCars = LONG_MAX;\\n        \\n        while(low <= high)\\n        {\\n            potentialMinTime = low + (high - low) / 2;\\n            \\n            if(canRepairAllCars(potentialMinTime, cars, ranks)){\\n                minTimeToRepairCars = potentialMinTime;\\n                high = potentialMinTime - 1;\\n            }\\n            else low = potentialMinTime + 1;\\n        }\\n        return minTimeToRepairCars;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096289,
                "title": "c-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars)\\n    {\\n        int n = ranks.size();\\n        sort(ranks.begin(), ranks.end());\\n        long long l = 1;\\n        long long r = 1e14;\\n        while(l<r)\\n        {\\n            long long mid =l+(r-l)/2;\\n            int cnt = 0;\\n            int i = 0;\\n            while(cnt<cars && i<n)\\n            {\\n                cnt+=sqrt(mid/ranks[i]);\\n                i++;\\n            }\\n            if(cnt>=cars){r=mid;}\\n            else{l=mid+1;}\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars)\\n    {\\n        int n = ranks.size();\\n        sort(ranks.begin(), ranks.end());\\n        long long l = 1;\\n        long long r = 1e14;\\n        while(l<r)\\n        {\\n            long long mid =l+(r-l)/2;\\n            int cnt = 0;\\n            int i = 0;\\n            while(cnt<cars && i<n)\\n            {\\n                cnt+=sqrt(mid/ranks[i]);\\n                i++;\\n            }\\n            if(cnt>=cars){r=mid;}\\n            else{l=mid+1;}\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089910,
                "title": "binary-search-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search on answer\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmake sample space of maximum time to repair all the cars and do binary search on time \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(long long time, vector<int>& ranks, int cars){\\n        long long repaired_cars = 0;\\n        for(auto r:ranks){\\n            repaired_cars += floor(sqrt(time/r));\\n        }\\n        return repaired_cars>=cars;\\n    }\\n\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        int n = ranks.size();\\n        long long  lo = 1;\\n        long long hi = (long long)cars*(long long)cars*(*max_element(ranks.begin(), ranks.end()));\\n        long long ans = hi;\\n        while(lo<=hi){\\n            long long mid = (hi-lo)/2 + lo;\\n            if(check(mid, ranks,cars)){\\n                ans = mid;\\n                hi = mid-1;\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long time, vector<int>& ranks, int cars){\\n        long long repaired_cars = 0;\\n        for(auto r:ranks){\\n            repaired_cars += floor(sqrt(time/r));\\n        }\\n        return repaired_cars>=cars;\\n    }\\n\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        int n = ranks.size();\\n        long long  lo = 1;\\n        long long hi = (long long)cars*(long long)cars*(*max_element(ranks.begin(), ranks.end()));\\n        long long ans = hi;\\n        while(lo<=hi){\\n            long long mid = (hi-lo)/2 + lo;\\n            if(check(mid, ranks,cars)){\\n                ans = mid;\\n                hi = mid-1;\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085140,
                "title": "using-binary-search-to-get-the-mintime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nfind the minTime & maxTime (lower & upper bounds) & get the mintime by using binary search. \\n<!-- Describe your approach to solving the problem. -->\\n\\nAdded another solution using DP, which may not be optimal solution. \\n\\n# Code\\n```\\nclass Solution{\\n    public long repairCars(int[] ranks, int cars) {\\n        long highestRank = 0;\\n        long lowestRank = 0;\\n        for(int rank: ranks){\\n            highestRank = Math.max(highestRank, rank);\\n            lowestRank = Math.min(lowestRank, rank);\\n        }\\n        \\n        long low = lowestRank * cars * cars;\\n        long high = highestRank * cars * cars;\\n\\n        long minTime = high;\\n        while (low <= high) {\\n            long mid = low + (high - low) / 2;\\n            if(canRepair(ranks, cars, mid)){\\n                minTime = mid; \\n                high = mid-1; \\n            }else{\\n                low = mid+1; \\n            }\\n        }\\n        return minTime;\\n    }\\n\\n    boolean canRepair(int[] ranks, int cars, long time){\\n        for(int rank : ranks){\\n            int carsCanBeRepaired = (int) Math.sqrt((long)time/ (long)rank);\\n            cars -= carsCanBeRepaired; \\n            if(cars <= 0)\\n                return true; \\n        }\\n        return cars <= 0; \\n    }\\n}\\n\\nclass SolutionDP{\\n    public long repairCars(int[] ranks, int cars) {\\n        return solve(ranks, 0, cars, new HashMap<>());\\n    }\\n\\n    int solve(int[] ranks, int index, int cars, Map<Integer, Map<Integer,Integer>> memo){\\n        int currentRank = ranks[index];\\n        int N = ranks.length;\\n        if(index == N-1)\\n            return getRepairTime(currentRank, cars);\\n        \\n        if(memo.containsKey(index) && memo.get(index).containsKey(cars))\\n            return memo.get(index).get(cars);\\n\\n        int min = Integer.MAX_VALUE; \\n\\n        int repairedCars = 0;\\n        while(repairedCars <= cars){\\n            int timeForRepairing = Math.max(getRepairTime(currentRank, repairedCars) , solve(ranks, index+1, cars-repairedCars, memo));\\n            min = Math.min(min, timeForRepairing);\\n            repairedCars++; \\n        }\\n\\n        memo.computeIfAbsent(index, k-> new HashMap<>());\\n\\n        memo.get(index).put(cars, min);\\n\\n        return min; \\n    }\\n\\n    int getRepairTime(int rank, int cars){\\n        return rank * cars * cars; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public long repairCars(int[] ranks, int cars) {\\n        long highestRank = 0;\\n        long lowestRank = 0;\\n        for(int rank: ranks){\\n            highestRank = Math.max(highestRank, rank);\\n            lowestRank = Math.min(lowestRank, rank);\\n        }\\n        \\n        long low = lowestRank * cars * cars;\\n        long high = highestRank * cars * cars;\\n\\n        long minTime = high;\\n        while (low <= high) {\\n            long mid = low + (high - low) / 2;\\n            if(canRepair(ranks, cars, mid)){\\n                minTime = mid; \\n                high = mid-1; \\n            }else{\\n                low = mid+1; \\n            }\\n        }\\n        return minTime;\\n    }\\n\\n    boolean canRepair(int[] ranks, int cars, long time){\\n        for(int rank : ranks){\\n            int carsCanBeRepaired = (int) Math.sqrt((long)time/ (long)rank);\\n            cars -= carsCanBeRepaired; \\n            if(cars <= 0)\\n                return true; \\n        }\\n        return cars <= 0; \\n    }\\n}\\n\\nclass SolutionDP{\\n    public long repairCars(int[] ranks, int cars) {\\n        return solve(ranks, 0, cars, new HashMap<>());\\n    }\\n\\n    int solve(int[] ranks, int index, int cars, Map<Integer, Map<Integer,Integer>> memo){\\n        int currentRank = ranks[index];\\n        int N = ranks.length;\\n        if(index == N-1)\\n            return getRepairTime(currentRank, cars);\\n        \\n        if(memo.containsKey(index) && memo.get(index).containsKey(cars))\\n            return memo.get(index).get(cars);\\n\\n        int min = Integer.MAX_VALUE; \\n\\n        int repairedCars = 0;\\n        while(repairedCars <= cars){\\n            int timeForRepairing = Math.max(getRepairTime(currentRank, repairedCars) , solve(ranks, index+1, cars-repairedCars, memo));\\n            min = Math.min(min, timeForRepairing);\\n            repairedCars++; \\n        }\\n\\n        memo.computeIfAbsent(index, k-> new HashMap<>());\\n\\n        memo.get(index).put(cars, min);\\n\\n        return min; \\n    }\\n\\n    int getRepairTime(int rank, int cars){\\n        return rank * cars * cars; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074992,
                "title": "c-binary-search-on-answer-algorithm-with-intuition-step-by-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nHere in the question, we have to minimise the total repair time.\\nsearch space will be `time` and,\\nsolution will be monotoinic in nature.\\n F, F, F, T, T\\nwe have to find first True, in order to minimise the time\\nHence, we will be using Binary Search on Answer Approach\\n\\nIt\\'s given in question,\\nthat to repair car by mechanic with r rank, and total cars repair n, then total time taken will, `t=r*n^2`\\nSo,\\nwith given time `t` and rank `r`, we can calculate total cars repair using,\\n`n=sqrt(t/r)`\\nand after iterating through array, let total cars repaired be tota_cars\\nthen,\\nif `total_cars>cars` it\\'s a `True` case, else `False`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(vector<int>& ranks,long long int m,int cars){\\n        long long int c=0;\\n        for(auto i:ranks){\\n            c+=sqrt(m/i);\\n        }\\n        return c>=cars;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int res=-1;\\n        long long int l=1,h=1e14;\\n        \\n        while(l<=h){\\n            long long m=l+(h-l)/2;\\n            if(solve(ranks,m,cars)){\\n                res=m;\\n                h=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool solve(vector<int>& ranks,long long int m,int cars){\\n        long long int c=0;\\n        for(auto i:ranks){\\n            c+=sqrt(m/i);\\n        }\\n        return c>=cars;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int res=-1;\\n        long long int l=1,h=1e14;\\n        \\n        while(l<=h){\\n            long long m=l+(h-l)/2;\\n            if(solve(ranks,m,cars)){\\n                res=m;\\n                h=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029215,
                "title": "simplier-5-line-understandable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    long carRepired(int [] ranks, long mid){\\n        long count=0;\\n        for(int r : ranks){\\n            count += (long)Math.sqrt(mid/r);\\n        }\\n        return count;\\n    }\\n\\n    public long repairCars(int[] ranks, int cars) {\\n // Minimum time to repair car: 1*(sqrt(1)) ---> for 1 car and 1 is the ith rank\\n // Maximum time to repair car: 100*(sqrt(1e6))=1e14 --->for 1e6 Car and 100 is the ith rank       \\n        long low =1, high=(long)1e14; \\n        long res=0;\\n\\n        while(low <= high){\\n            long mid = low + (high-low)/2;\\n            long carR = carRepired(ranks, mid);\\n\\n            if(carR >= cars){\\n                high = mid-1;\\n                res = mid; \\n            } else{\\n                low = mid+1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    long carRepired(int [] ranks, long mid){\\n        long count=0;\\n        for(int r : ranks){\\n            count += (long)Math.sqrt(mid/r);\\n        }\\n        return count;\\n    }\\n\\n    public long repairCars(int[] ranks, int cars) {\\n // Minimum time to repair car: 1*(sqrt(1)) ---> for 1 car and 1 is the ith rank\\n // Maximum time to repair car: 100*(sqrt(1e6))=1e14 --->for 1e6 Car and 100 is the ith rank       \\n        long low =1, high=(long)1e14; \\n        long res=0;\\n\\n        while(low <= high){\\n            long mid = low + (high-low)/2;\\n            long carR = carRepired(ranks, mid);\\n\\n            if(carR >= cars){\\n                high = mid-1;\\n                res = mid; \\n            } else{\\n                low = mid+1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011924,
                "title": "simple-beginner-level-c-solution-runtime-90-ms-beats-100-easy-binary-search-method",
                "content": "\\n# Complexity\\n- Time complexity:  ```O(log(min(ranks) * cars^2))```\\n- Space complexity: ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp\\n// Runtime 90 ms Beats 100% Memory 10.4 MB Beats 50%\\ninline int min(int a, int b) {\\n    return (a < b) ? a : b;\\n}\\nint min_element(const int* const ranks, int ranksSize) {\\n    int result = INT_MAX;\\n    for (int i = 0; i < ranksSize; i++) {\\n        result = min(result, ranks[i]);\\n    }\\n    return result; \\n}\\nlong long numCarsFixed(const int* const ranks, int ranksSize, long long minutes) {\\n    long long cars_fixed = 0;\\n    //     r * n^2 = minutes\\n    // --> n = sqrt(minutes / r)\\n    for (int i = 0; i < ranksSize; i++) {\\n        cars_fixed += sqrt(minutes / ranks[i]);\\n    }\\n    return cars_fixed;\\n}\\nlong long repairCars(int* ranks, int ranksSize, int cars) {\\n    // Binary search\\n\\n    // Time complexity: O(log(min(ranks) * cars^2))\\n    // Space complexity: O(1)\\n    \\n    long long left = 0LL;\\n    long long right = 1LL * min_element(ranks, ranksSize) * cars * cars;  // r * n^2\\n\\n    while (left < right) {\\n        const long long middle = left + (right - left) / 2;\\n        if (numCarsFixed(ranks, ranksSize, middle) >= cars) \\n            right = middle;\\n        else\\n            left = middle + 1;\\n    }\\n    return left;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Search"
                ],
                "code": "```O(log(min(ranks) * cars^2))```\n```O(1)```\n```cpp\\n// Runtime 90 ms Beats 100% Memory 10.4 MB Beats 50%\\ninline int min(int a, int b) {\\n    return (a < b) ? a : b;\\n}\\nint min_element(const int* const ranks, int ranksSize) {\\n    int result = INT_MAX;\\n    for (int i = 0; i < ranksSize; i++) {\\n        result = min(result, ranks[i]);\\n    }\\n    return result; \\n}\\nlong long numCarsFixed(const int* const ranks, int ranksSize, long long minutes) {\\n    long long cars_fixed = 0;\\n    //     r * n^2 = minutes\\n    // --> n = sqrt(minutes / r)\\n    for (int i = 0; i < ranksSize; i++) {\\n        cars_fixed += sqrt(minutes / ranks[i]);\\n    }\\n    return cars_fixed;\\n}\\nlong long repairCars(int* ranks, int ranksSize, int cars) {\\n    // Binary search\\n\\n    // Time complexity: O(log(min(ranks) * cars^2))\\n    // Space complexity: O(1)\\n    \\n    long long left = 0LL;\\n    long long right = 1LL * min_element(ranks, ranksSize) * cars * cars;  // r * n^2\\n\\n    while (left < right) {\\n        const long long middle = left + (right - left) / 2;\\n        if (numCarsFixed(ranks, ranksSize, middle) >= cars) \\n            right = middle;\\n        else\\n            left = middle + 1;\\n    }\\n    return left;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009429,
                "title": "binary-search-simple-english-no-confusion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->simple binary search \\nto find total cars r*n^2=x  (minutes)\\nn^2=x/r\\nn=sqrt(x/r)\\napply standard binary search on answer\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long ans=0,low=0,high=(long)1e15;\\n       \\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n            long temp=isanswer(ranks,mid);\\n            if(temp>=cars)\\n            {\\n               \\n           ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                \\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    long isanswer(int nums[],long mid)\\n    {\\n        long temp=0;\\n        for(int aa:nums)\\n        {\\n            temp+=(long)Math.sqrt((double)mid/aa);\\n        }\\n        return temp;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long ans=0,low=0,high=(long)1e15;\\n       \\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n            long temp=isanswer(ranks,mid);\\n            if(temp>=cars)\\n            {\\n               \\n           ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                \\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    long isanswer(int nums[],long mid)\\n    {\\n        long temp=0;\\n        for(int aa:nums)\\n        {\\n            temp+=(long)Math.sqrt((double)mid/aa);\\n        }\\n        return temp;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945204,
                "title": "range-bs",
                "content": "**time: `O(NlogR)`; space: `O(1)`**\\n```\\nlong long repairCars(vector<int>& r, int c)\\n{\\n\\tlong long l{}, h{LONG_MAX};\\n\\tfor( ; l+1<h; )\\n\\t{\\n\\t\\tlong long m = (l+h)/2;\\n\\t\\t(accumulate(begin(r), end(r), 0ll, [&](auto s, auto & x){ return s+(long long)sqrt(m/x); })<c ? l : h) = m;\\n\\t}\\n\\treturn h;\\n}\\n```\\n\\n**Similar problems:**\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/2053517/bs?currentPage=1&orderBy=most_relevant&query=android)\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2963593/bs)\\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/discuss/2127417/binary-search)\\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/discuss/1676227/binary-search)\\n[1300. Sum of Mutated Array Closest to Target](https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/discuss/2969866/bs)\\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/3251398/ok)\\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/discuss/3251393/ok)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/3253585/bs)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/3254564/bs)\\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/3807049/bs)\\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/discuss/3808940/bs)\\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/discuss/3945204/range-bs)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long repairCars(vector<int>& r, int c)\\n{\\n\\tlong long l{}, h{LONG_MAX};\\n\\tfor( ; l+1<h; )\\n\\t{\\n\\t\\tlong long m = (l+h)/2;\\n\\t\\t(accumulate(begin(r), end(r), 0ll, [&](auto s, auto & x){ return s+(long long)sqrt(m/x); })<c ? l : h) = m;\\n\\t}\\n\\treturn h;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937374,
                "title": "python-solution-faster-than-98-42",
                "content": "![Screenshot 2023-08-20 at 9.41.37 PM.png](https://assets.leetcode.com/users/images/80fa6a43-cfd0-4494-8aaa-57df63d11bc6_1692547923.1268427.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        count = Counter(ranks)\\n        left = 1\\n        right = min(count) * cars * cars\\n        \\n        while (left < right):\\n            mid = (left + right) // 2\\n            if sum(isqrt(mid//a) * count[a] for a in count) < cars:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        \\n        return left\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        count = Counter(ranks)\\n        left = 1\\n        right = min(count) * cars * cars\\n        \\n        while (left < right):\\n            mid = (left + right) // 2\\n            if sum(isqrt(mid//a) * count[a] for a in count) < cars:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        \\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917625,
                "title": "c-python-binary-search-solution-with-explanation",
                "content": "we can use binary search to enumerate the time to repair all cars.\\n\\ntc is O(nlogx), sc is O(1).\\n\\n### python\\n```python\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        avg = cars // len(ranks) + int(cars % len(ranks) > 0)\\n        mn, mx = min(ranks) * avg * avg, max(ranks) * avg * avg\\n        def check(second):\\n            cnt_cars = 0\\n            for x in ranks:\\n                cnt_cars += int((second / x) ** 0.5)\\n                if cnt_cars >= cars: return True\\n            return False\\n        return mn + bisect_left(range(mn, mx + 1), True, key=check)\\n```\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long min = INT_MAX, max = INT_MIN;\\n        int avg = cars / ranks.size() + (int) (cars % ranks.size() > 0);\\n        for (int& x: ranks) {\\n            if (x < min) min = x;\\n            if (x > max) max = x;\\n        }\\n        min *= (long long) avg * avg;\\n        max *= (long long) avg * avg;\\n        long long &left = min, &right = max, mid;\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (this -> check(ranks, cars, mid)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n    \\n    bool check(vector<int>& ranks, int cars, long long second) {\\n        int cnt_cars = 0;\\n        for (int &x: ranks) {\\n            cnt_cars += (int) sqrt((double) second / x);\\n            if (cnt_cars >= cars) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        avg = cars // len(ranks) + int(cars % len(ranks) > 0)\\n        mn, mx = min(ranks) * avg * avg, max(ranks) * avg * avg\\n        def check(second):\\n            cnt_cars = 0\\n            for x in ranks:\\n                cnt_cars += int((second / x) ** 0.5)\\n                if cnt_cars >= cars: return True\\n            return False\\n        return mn + bisect_left(range(mn, mx + 1), True, key=check)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long min = INT_MAX, max = INT_MIN;\\n        int avg = cars / ranks.size() + (int) (cars % ranks.size() > 0);\\n        for (int& x: ranks) {\\n            if (x < min) min = x;\\n            if (x > max) max = x;\\n        }\\n        min *= (long long) avg * avg;\\n        max *= (long long) avg * avg;\\n        long long &left = min, &right = max, mid;\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (this -> check(ranks, cars, mid)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n    \\n    bool check(vector<int>& ranks, int cars, long long second) {\\n        int cnt_cars = 0;\\n        for (int &x: ranks) {\\n            cnt_cars += (int) sqrt((double) second / x);\\n            if (cnt_cars >= cars) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910238,
                "title": "c-clean-easy-code-binary-search-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& p, int c) {\\n        long long int l=1,r=LLONG_MAX;\\n        long long int ans=r;\\n        while(l<=r)\\n        {\\n           long long int m=l+(r-l)/2;\\n           long long int s=0;\\n           for(auto i : p)\\n              s+=sqrt((m/i));\\n           \\n           if(s>=c)\\n           {\\n               ans=min(ans,m);\\n               r=m-1;\\n           }\\n           else\\n           l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& p, int c) {\\n        long long int l=1,r=LLONG_MAX;\\n        long long int ans=r;\\n        while(l<=r)\\n        {\\n           long long int m=l+(r-l)/2;\\n           long long int s=0;\\n           for(auto i : p)\\n              s+=sqrt((m/i));\\n           \\n           if(s>=c)\\n           {\\n               ans=min(ans,m);\\n               r=m-1;\\n           }\\n           else\\n           l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909696,
                "title": "python-solution-with-simple-math-and-binary-search-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(nlog(1000000000000000))\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        # with rank r, we have time to repair = r * n2\\n        # => So, conclude r more less with have time to repair faster \\n        ranks.sort()\\n        n = len(ranks)\\n        def checkIsValid(timeLimit):\\n            # with x, we have number * x * x = timeLimit\\n            #           => x = sqrt(timeLimit / number)\\n            # => if total car can earn >= cars => pass\\n            cntCar = 0\\n            for v in ranks:\\n                cntCar += int((timeLimit / v)**(0.5))\\n            return cntCar >= cars\\n        l = 1\\n        r = 1000000000000000\\n        ans = 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if checkIsValid(mid):\\n                ans = mid\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        # with rank r, we have time to repair = r * n2\\n        # => So, conclude r more less with have time to repair faster \\n        ranks.sort()\\n        n = len(ranks)\\n        def checkIsValid(timeLimit):\\n            # with x, we have number * x * x = timeLimit\\n            #           => x = sqrt(timeLimit / number)\\n            # => if total car can earn >= cars => pass\\n            cntCar = 0\\n            for v in ranks:\\n                cntCar += int((timeLimit / v)**(0.5))\\n            return cntCar >= cars\\n        l = 1\\n        r = 1000000000000000\\n        ans = 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if checkIsValid(mid):\\n                ans = mid\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895561,
                "title": "golang-binary-search-100-solution",
                "content": "# Code\\n```go\\nfunc repairCars(ranks []int, cars int) int64 {\\n\\tl, r := 1, math.MaxInt64-1\\n\\tfor l <= r {\\n\\t\\tresCar := cars\\n\\t\\tm := (l+r)>>1\\n\\t\\tfor _, rank := range ranks {\\n\\t\\t\\trepair := int(math.Sqrt(float64(m / rank)))\\n\\t\\t\\tresCar -= repair\\n\\t\\t\\tif resCar <= 0 {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif resCar <= 0 {\\n\\t\\t\\tr = m - 1\\n\\t\\t} else {\\n\\t\\t\\tl = m + 1\\n\\t\\t}\\n\\t}\\n\\treturn int64(r+1)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```go\\nfunc repairCars(ranks []int, cars int) int64 {\\n\\tl, r := 1, math.MaxInt64-1\\n\\tfor l <= r {\\n\\t\\tresCar := cars\\n\\t\\tm := (l+r)>>1\\n\\t\\tfor _, rank := range ranks {\\n\\t\\t\\trepair := int(math.Sqrt(float64(m / rank)))\\n\\t\\t\\tresCar -= repair\\n\\t\\t\\tif resCar <= 0 {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif resCar <= 0 {\\n\\t\\t\\tr = m - 1\\n\\t\\t} else {\\n\\t\\t\\tl = m + 1\\n\\t\\t}\\n\\t}\\n\\treturn int64(r+1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3890796,
                "title": "simple-binary-search-and-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& nums, int cars) {\\n        long long s=0,e=1e15;\\n\\n        while(s<e)\\n        {\\n            long long mid=(s+e)/2;\\n            auto check=[&]() {\\n                long long  c=0;\\n                for(int i=0;i<nums.size() && c<cars;i++)\\n                {\\n                    long long min=mid/nums[i];\\n                    c+=sqrt(min);\\n                }\\n                return c>=cars;\\n            };\\n            if(check( ))\\n            {\\n                e=mid;\\n            }\\n            else\\n            s=mid+1;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& nums, int cars) {\\n        long long s=0,e=1e15;\\n\\n        while(s<e)\\n        {\\n            long long mid=(s+e)/2;\\n            auto check=[&]() {\\n                long long  c=0;\\n                for(int i=0;i<nums.size() && c<cars;i++)\\n                {\\n                    long long min=mid/nums[i];\\n                    c+=sqrt(min);\\n                }\\n                return c>=cars;\\n            };\\n            if(check( ))\\n            {\\n                e=mid;\\n            }\\n            else\\n            s=mid+1;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871667,
                "title": "binary-search-detailed-explanation-java-solution",
                "content": "# Intuition\\nBinary search: \\nthis is the problem of mimimizing the time over sorted time range.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere rank[i] car is taking rank[i] * n * n minutes, where n = number of card it can repair. \\nso here \\nlowest_rank = min{ranks[i] : 0<= i <= rank.length-1}\\nhighest_rank = max{ranks[i] : 0<= i <= rank.length-1}\\n\\ntherfore our \\nstart_range = lowest_rank * (cars * cars)\\nend_range = highest_rank * (cars * cars)\\n\\nnow run binary search on this range;\\nlong mid = start_range + (end_range - start_range)/2\\ncheck total number of cars can be repaired in time \"mid\"\\n```\\nprivate long totalCarsCanRepair(int[] ranks, long mid) {\\n        long totalCar = 0;\\n        for(int i = 0; i < ranks.length; i++){\\n            totalCar += Math.sqrt((double) mid/ranks[i]);\\n        }\\n        return totalCar;\\n    }\\n```\\nif total car repair count is greater than \"cars\" then one of our ans will \"mid\", lets search for lower time and check if we can repair all car by doing end_range = mid -1;\\nother wise shift the start_range to mid + 1 as in mid time total car can repair count is less than the given car count. so let search for higher time than mid.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Max{n*log(max{ranks[i]} * rars * cars)})\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\nNote: \\n\\nHere we can save time of searching max and min to define our monotonic space.  as we look carefully at constraint given in problem, \\nMax(ranks[i] : 0<= i <= ranks.length -1) = 100;\\nAlso Max of total cars in all the test case are = 10^6\\nso max time required for the test case like \\nrank = [100]\\ncars = 10^6\\n\\nso total time required = 100 * (10^6 * 10^6) = 10^14\\n\\nso directly we can define the start_range = 1 and end_range = 10^14\\nSo time complexity will be O(log(max{ranks[i]} * rars * cars)))\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n   public long repairCars(int[] ranks, int cars) {\\n        int max = 0;\\n        int min = 0;\\n        for(int rank : ranks){\\n            max = Math.max(max, rank);\\n            min = Math.min(min, rank);\\n        }\\n        long s =(long) min * cars * cars;\\n        long ans = s;\\n        long e = (long) max * cars * cars;\\n        while (s <= e){\\n            long mid = s + (e-s)/2;\\n            if(totalCarsCanRepair(ranks, mid) >= cars){\\n                ans = mid;\\n                e = mid -1;\\n            } else {\\n                s = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private long totalCarsCanRepair(int[] ranks, long mid) {\\n        long totalCar = 0;\\n        for(int i = 0; i < ranks.length; i++){\\n            totalCar += Math.sqrt((double) mid/ranks[i]);\\n        }\\n        return totalCar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate long totalCarsCanRepair(int[] ranks, long mid) {\\n        long totalCar = 0;\\n        for(int i = 0; i < ranks.length; i++){\\n            totalCar += Math.sqrt((double) mid/ranks[i]);\\n        }\\n        return totalCar;\\n    }\\n```\n```\\nclass Solution {\\n   public long repairCars(int[] ranks, int cars) {\\n        int max = 0;\\n        int min = 0;\\n        for(int rank : ranks){\\n            max = Math.max(max, rank);\\n            min = Math.min(min, rank);\\n        }\\n        long s =(long) min * cars * cars;\\n        long ans = s;\\n        long e = (long) max * cars * cars;\\n        while (s <= e){\\n            long mid = s + (e-s)/2;\\n            if(totalCarsCanRepair(ranks, mid) >= cars){\\n                ans = mid;\\n                e = mid -1;\\n            } else {\\n                s = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private long totalCarsCanRepair(int[] ranks, long mid) {\\n        long totalCar = 0;\\n        for(int i = 0; i < ranks.length; i++){\\n            totalCar += Math.sqrt((double) mid/ranks[i]);\\n        }\\n        return totalCar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857990,
                "title": "easy-solution-using-binary-search-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long l=1,h=1L*100*cars*cars;\\n        \\n        while(l<h){\\n            long long mid=(h+l)/2;\\n            long long cnt=0;\\n            for(auto it : ranks){\\n                cnt+= (long long) sqrt(1.0*mid/it);\\n            }\\n            if(cnt>=cars) h=mid;\\n            else l=mid+1;\\n        }\\n        return l;\\n        \\n    }\\n};\\n```\\n**Please Upvote if found Useful**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long l=1,h=1L*100*cars*cars;\\n        \\n        while(l<h){\\n            long long mid=(h+l)/2;\\n            long long cnt=0;\\n            for(auto it : ranks){\\n                cnt+= (long long) sqrt(1.0*mid/it);\\n            }\\n            if(cnt>=cars) h=mid;\\n            else l=mid+1;\\n        }\\n        return l;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842549,
                "title": "easy-c-classic-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool binary(long long mid,vector<int> ranks, int cars)\\n    {\\n        long long n=0;\\n        for(int i=0;i<ranks.size();i++)\\n         n+=sqrt(mid/ranks[i]);\\n        return n>=cars;\\n    }\\n\\n    long long repairCars(vector<int>& ranks, int cars) {\\n       long long l=1,h=1e14;\\n       long long ans=0;\\n       while(l<=h)\\n       {   \\n           long long mid=(l+h)/2;\\n           if(binary(mid,ranks,cars))\\n           {\\n               ans=mid;\\n               h=mid-1;\\n           }\\n           else\\n           {\\n               l=mid+1;\\n           }\\n       } \\n       return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool binary(long long mid,vector<int> ranks, int cars)\\n    {\\n        long long n=0;\\n        for(int i=0;i<ranks.size();i++)\\n         n+=sqrt(mid/ranks[i]);\\n        return n>=cars;\\n    }\\n\\n    long long repairCars(vector<int>& ranks, int cars) {\\n       long long l=1,h=1e14;\\n       long long ans=0;\\n       while(l<=h)\\n       {   \\n           long long mid=(l+h)/2;\\n           if(binary(mid,ranks,cars))\\n           {\\n               ans=mid;\\n               h=mid-1;\\n           }\\n           else\\n           {\\n               l=mid+1;\\n           }\\n       } \\n       return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839371,
                "title": "java-simple-solution-to-understand-binary-search-easy-breakdown",
                "content": "# Code\\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long ans = (long) 1e14;\\n\\n        long left = 1;\\n        long right = (long) 1e14;\\n        while(left < right){\\n            long midTime = left + (right - left)/2;\\n            long currTotalRepairableCars = canRepare(ranks, midTime);\\n            if(currTotalRepairableCars >= cars){\\n                ans = midTime;\\n                right = midTime; // enough time left to repair.\\n            }else{\\n                left = midTime + 1; // not enough time.\\n            }\\n        }\\n        return ans;\\n    }\\n    public long canRepare(int[] ranks, long time){\\n        long totalRepairableCars = 0;\\n        for(int i = 0; i < ranks.length; i++){\\n            totalRepairableCars += Math.sqrt(time/ranks[i]);\\n        }\\n\\n        \\n        return totalRepairableCars;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: O(n*logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long ans = (long) 1e14;\\n\\n        long left = 1;\\n        long right = (long) 1e14;\\n        while(left < right){\\n            long midTime = left + (right - left)/2;\\n            long currTotalRepairableCars = canRepare(ranks, midTime);\\n            if(currTotalRepairableCars >= cars){\\n                ans = midTime;\\n                right = midTime; // enough time left to repair.\\n            }else{\\n                left = midTime + 1; // not enough time.\\n            }\\n        }\\n        return ans;\\n    }\\n    public long canRepare(int[] ranks, long time){\\n        long totalRepairableCars = 0;\\n        for(int i = 0; i < ranks.length; i++){\\n            totalRepairableCars += Math.sqrt(time/ranks[i]);\\n        }\\n\\n        \\n        return totalRepairableCars;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833752,
                "title": "java-15ms-beats-98-binary-search-and-clean-code",
                "content": "# Approach\\n1. Basic math: if a mechanic with rank r can repair n cars in r * n^2 minutes, how many cars (c) can he repair in T minutes?\\n    - c = Math.sqrt(T / r). c ^ 2 * r = T.\\n    - EG: [7] and 10 cars. 7 * 100 = 700. He can repair 10 cars in 700 minutes. What about 300 minutes? 300 / 7 = 42. Sqrt(42) = 6.5 (so 6 cars)\\n2. Applying this logic, we can find out if mechanics ran repair ALL the cars in given T minutes.\\n3. For a given T number of minutes, find out how many cars can each mechanic repair.\\n    - If the totalRepaired cars >= cars, then they can fix them all!\\n4. Apply a binary search algorithm: if mechanics can repair ALL the cars in T minutes, increase T, else lower T.\\n    - Your boundries are between 1 and 10^14.\\n    - Worst case scenario: 10^6 cars and 1 mechanic with rank 100: 100 * 10^12 = 10^14.\\n\\n# Complexity\\n- Time complexity:$$O(log(10 power (14)) - apx 46$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long low = 0, high = 100000000000000L, pivot;\\n        while (low <= high) {\\n            pivot = low + (high - low) / 2;\\n            if (canRepairAllCars(ranks, cars, pivot)) {\\n                high = pivot -1;\\n            } else {\\n                low = pivot + 1;\\n            }\\n        }\\n        return low;\\n    }\\n\\n    private boolean canRepairAllCars(int[] ranks, int cars, long totalMinutes) {\\n        int repairedCars = 0;\\n        for (int i = 0; i < ranks.length && repairedCars < cars; i++) {\\n            repairedCars += (int) Math.sqrt(totalMinutes / ranks[i]);\\n        }\\n        return repairedCars >= cars;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long low = 0, high = 100000000000000L, pivot;\\n        while (low <= high) {\\n            pivot = low + (high - low) / 2;\\n            if (canRepairAllCars(ranks, cars, pivot)) {\\n                high = pivot -1;\\n            } else {\\n                low = pivot + 1;\\n            }\\n        }\\n        return low;\\n    }\\n\\n    private boolean canRepairAllCars(int[] ranks, int cars, long totalMinutes) {\\n        int repairedCars = 0;\\n        for (int i = 0; i < ranks.length && repairedCars < cars; i++) {\\n            repairedCars += (int) Math.sqrt(totalMinutes / ranks[i]);\\n        }\\n        return repairedCars >= cars;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831095,
                "title": "python-medium",
                "content": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        def good(minutes):\\n\\n            goal = cars\\n\\n            for r in ranks:\\n                goal -= floor(sqrt(minutes / r))\\n\\n                if goal <= 0:\\n                    return True\\n\\n            return False\\n\\n\\n\\n        l, r = 0, 10 ** 18\\n\\n        while l < r:\\n            mid = (l + r) // 2\\n\\n            if good(mid):\\n                r = mid\\n\\n            else:\\n                l = mid + 1\\n\\n        return l\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        def good(minutes):\\n\\n            goal = cars\\n\\n            for r in ranks:\\n                goal -= floor(sqrt(minutes / r))\\n\\n                if goal <= 0:\\n                    return True\\n\\n            return False\\n\\n\\n\\n        l, r = 0, 10 ** 18\\n\\n        while l < r:\\n            mid = (l + r) // 2\\n\\n            if good(mid):\\n                r = mid\\n\\n            else:\\n                l = mid + 1\\n\\n        return l\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827060,
                "title": "c-easy-solution-in-an-understandable-way",
                "content": "**AMAZON OT QUESTION**\\n\\n# Intuition\\n\\n// the idea of solving this question we actually dont know how many cars should be distributed\\n// to a person ...so we go in reverse order and find the no of cars that can be repaired for given time range and check it can be repared in that time\\n\\n\\n// if the sum>=cars means that they can be repaired in that given time and\\n# Approach\\nsolve in reverse order of first finding the no of cars they can be repared in given interval of time and check if it is equal to the given time and by using binary search we can find the minimum time by takinng the middle of time\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)+O(LOGN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1**Bold**)\\n\\n# Code\\n```\\n// the idea of solving this question we actually dont know how many cars should be distributed\\n// to a person ...so we go in reverse order and find the no of cars that can be repaired for given time range and check it can be repared in that time\\n\\n\\n// if the sum>=cars means that they can be repaired in that given time and else they cannot be repared and by using binary search we calculate the minimum time \\n\\n\\n\\nclass Solution {\\npublic:\\n\\nbool isPossible(long long time,vector<int>&ranks,int cars)\\n{\\n  long long sum=0;\\n    for(int i=0;i<ranks.size();i++)\\n    {\\n          long long n=sqrt(time/ranks[i]);\\n          sum+=n;\\n    }\\n    if(sum>=cars) \\n    {return true;\\n    }\\n     return false;\\n}\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        \\n        // this can be solved using binary search\\n        long long ans=0;\\n        long long start=1;\\n        long long end=100*1e6*1e6;\\n        while(start<=end)\\n        {\\n            long long mid=(start+end)/2;\\n            if(isPossible(mid,ranks,cars))\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// the idea of solving this question we actually dont know how many cars should be distributed\\n// to a person ...so we go in reverse order and find the no of cars that can be repaired for given time range and check it can be repared in that time\\n\\n\\n// if the sum>=cars means that they can be repaired in that given time and else they cannot be repared and by using binary search we calculate the minimum time \\n\\n\\n\\nclass Solution {\\npublic:\\n\\nbool isPossible(long long time,vector<int>&ranks,int cars)\\n{\\n  long long sum=0;\\n    for(int i=0;i<ranks.size();i++)\\n    {\\n          long long n=sqrt(time/ranks[i]);\\n          sum+=n;\\n    }\\n    if(sum>=cars) \\n    {return true;\\n    }\\n     return false;\\n}\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        \\n        // this can be solved using binary search\\n        long long ans=0;\\n        long long start=1;\\n        long long end=100*1e6*1e6;\\n        while(start<=end)\\n        {\\n            long long mid=(start+end)/2;\\n            if(isPossible(mid,ranks,cars))\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820418,
                "title": "java-easy-solution-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int[] ranks,long cars,long mid){\\n        long sum = 0;\\n        long a = 0;\\n        for(int i = 0;i < ranks.length;i++)\\n            sum += (long)Math.floor(Math.sqrt(mid/(long)ranks[i]));\\n        return cars <= sum;\\n    }\\n    public long repairCars(int[] ranks, int cars) {\\n        long low = 0;\\n        long high = Long.MAX_VALUE;\\n        long mid = 0;\\n        long ans = 0;\\n        long car = (long)cars;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            if(isPossible(ranks,car,mid)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] ranks,long cars,long mid){\\n        long sum = 0;\\n        long a = 0;\\n        for(int i = 0;i < ranks.length;i++)\\n            sum += (long)Math.floor(Math.sqrt(mid/(long)ranks[i]));\\n        return cars <= sum;\\n    }\\n    public long repairCars(int[] ranks, int cars) {\\n        long low = 0;\\n        long high = Long.MAX_VALUE;\\n        long mid = 0;\\n        long ans = 0;\\n        long car = (long)cars;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            if(isPossible(ranks,car,mid)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742064,
                "title": "binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n    long ans = (long) 1e14;\\n        long l = 1;\\n        long h = (long) 1e14;\\n        while(l < h){\\n            long mid = l + (h - l)/2;\\n            if(canRepare(ranks, mid) >= cars){\\n                ans = mid;\\n                h = mid;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public long canRepare(int[] ranks, long time){\\n        long totalCar = 0;\\n        for(int i = 0; i < ranks.length; i++){\\n            totalCar += (long)Math.sqrt(time/ranks[i]);\\n        }\\n\\n        \\n        return totalCar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n    long ans = (long) 1e14;\\n        long l = 1;\\n        long h = (long) 1e14;\\n        while(l < h){\\n            long mid = l + (h - l)/2;\\n            if(canRepare(ranks, mid) >= cars){\\n                ans = mid;\\n                h = mid;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public long canRepare(int[] ranks, long time){\\n        long totalCar = 0;\\n        for(int i = 0; i < ranks.length; i++){\\n            totalCar += (long)Math.sqrt(time/ranks[i]);\\n        }\\n\\n        \\n        return totalCar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729370,
                "title": "c-binary-search-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\nbool isPossible(vector<int>& ranks,ll mid ,  int cars,int n){\\n    ll cars_req=0;\\n    for( int i=0;i<n;i++){\\n        ll c= floor(sqrt(mid/ranks[i]));\\n        cars_req+=c;\\n    }\\n    return (cars_req>=cars);\\n}\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        sort(ranks.begin(),ranks.end());\\n        ll ans=0;\\n        int n=ranks.size();\\n        ll lo=1,hi=1e14 ;\\n        while(lo<=hi){\\n            ll mid=(lo+hi)>>1;\\n            if(isPossible(ranks,mid, cars, n)){\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n            else lo=mid+1;\\n        }\\n    \\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\nbool isPossible(vector<int>& ranks,ll mid ,  int cars,int n){\\n    ll cars_req=0;\\n    for( int i=0;i<n;i++){\\n        ll c= floor(sqrt(mid/ranks[i]));\\n        cars_req+=c;\\n    }\\n    return (cars_req>=cars);\\n}\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        sort(ranks.begin(),ranks.end());\\n        ll ans=0;\\n        int n=ranks.size();\\n        ll lo=1,hi=1e14 ;\\n        while(lo<=hi){\\n            ll mid=(lo+hi)>>1;\\n            if(isPossible(ranks,mid, cars, n)){\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n            else lo=mid+1;\\n        }\\n    \\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729369,
                "title": "c-binary-search-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\nbool isPossible(vector<int>& ranks,ll mid ,  int cars,int n){\\n    ll cars_req=0;\\n    for( int i=0;i<n;i++){\\n        ll c= floor(sqrt(mid/ranks[i]));\\n        cars_req+=c;\\n    }\\n    return (cars_req>=cars);\\n}\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        sort(ranks.begin(),ranks.end());\\n        ll ans=0;\\n        int n=ranks.size();\\n        ll lo=1,hi=1e14 ;\\n        while(lo<=hi){\\n            ll mid=(lo+hi)>>1;\\n            if(isPossible(ranks,mid, cars, n)){\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n            else lo=mid+1;\\n        }\\n    \\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\nbool isPossible(vector<int>& ranks,ll mid ,  int cars,int n){\\n    ll cars_req=0;\\n    for( int i=0;i<n;i++){\\n        ll c= floor(sqrt(mid/ranks[i]));\\n        cars_req+=c;\\n    }\\n    return (cars_req>=cars);\\n}\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        sort(ranks.begin(),ranks.end());\\n        ll ans=0;\\n        int n=ranks.size();\\n        ll lo=1,hi=1e14 ;\\n        while(lo<=hi){\\n            ll mid=(lo+hi)>>1;\\n            if(isPossible(ranks,mid, cars, n)){\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n            else lo=mid+1;\\n        }\\n    \\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702129,
                "title": "easy-c-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe want to give more number of cars to small rank mechanics because our end goal is to minimize (r)*(n)*(n). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is fairly simple we can choose a time and see if all the cars can be repaired in that time if not then we can increase the time using low = mid+1, else if we can then we search for even less time using hi = mid-1\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        int n = ranks.size();\\n        sort(ranks.begin(),ranks.end());\\n        long long hi = ((long long)ranks[n-1])*((long long)cars)*((long long)cars);\\n        long long low = (ranks[0]);\\n        while(low<=hi){\\n            long long mid = (hi-low)/2+low;\\n            int c = 0;\\n            long long sum = 0;\\n            for(int i = 0;i<n;i++){\\n                int temp = ranks[i];\\n                long long x = 0;\\n                while(c<cars && temp*x*x<=mid){\\n                    x++;\\n                    c++;\\n                    if(temp*(x+1)*(x+1)>mid){\\n                        //c++;\\n                        break;\\n                    }\\n                }\\n                if(temp*x*x>sum){\\n                    sum = temp*x*x;\\n                }\\n                if(c >= cars)\\n                    break;\\n            }\\n            if(c<cars||sum>mid){\\n                low = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        int n = ranks.size();\\n        sort(ranks.begin(),ranks.end());\\n        long long hi = ((long long)ranks[n-1])*((long long)cars)*((long long)cars);\\n        long long low = (ranks[0]);\\n        while(low<=hi){\\n            long long mid = (hi-low)/2+low;\\n            int c = 0;\\n            long long sum = 0;\\n            for(int i = 0;i<n;i++){\\n                int temp = ranks[i];\\n                long long x = 0;\\n                while(c<cars && temp*x*x<=mid){\\n                    x++;\\n                    c++;\\n                    if(temp*(x+1)*(x+1)>mid){\\n                        //c++;\\n                        break;\\n                    }\\n                }\\n                if(temp*x*x>sum){\\n                    sum = temp*x*x;\\n                }\\n                if(c >= cars)\\n                    break;\\n            }\\n            if(c<cars||sum>mid){\\n                low = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692213,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long left = 1;\\n        long long right = 1e14;\\n        while(left <= right){\\n            long long mid = left + (right- left) / 2, count = 0;\\n            for(int i:ranks)count += sqrt(mid/i);\\n            if(count >= cars)right = mid-1;\\n            else left = mid+1;\\n        }\\n        return right+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long left = 1;\\n        long long right = 1e14;\\n        while(left <= right){\\n            long long mid = left + (right- left) / 2, count = 0;\\n            for(int i:ranks)count += sqrt(mid/i);\\n            if(count >= cars)right = mid-1;\\n            else left = mid+1;\\n        }\\n        return right+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691080,
                "title": "golang-binary-search",
                "content": "# Code\\n```\\nfunc repairCars(ranks []int, cars int) int64 {\\n  var res int64\\n  var left, right int64\\n  // Let\\'s binary search the answer. The maximum is 10^6 * 10^6 * 10^2 (max value of rank)\\n  left, right = 1, int64(1e14)\\n  for left <= right {\\n    mid := left + (right - left)/2\\n    if check(ranks, cars, mid) {\\n      res = mid\\n      right = mid - 1\\n    } else {\\n      left = mid + 1\\n    }\\n  }\\n  return res\\n}\\n\\nfunc check(ranks []int, cars int, target int64) bool {\\n  // Each mechanic can take up to target minutes\\n  // Let\\'s see if we can repair all cards with the given time\\n  for i := 0; i < len(ranks) && cars > 0; i++ {\\n    cars -= int(math.Sqrt(float64(target / int64(ranks[i]))))\\n  }\\n  return cars <= 0\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```\\nfunc repairCars(ranks []int, cars int) int64 {\\n  var res int64\\n  var left, right int64\\n  // Let\\'s binary search the answer. The maximum is 10^6 * 10^6 * 10^2 (max value of rank)\\n  left, right = 1, int64(1e14)\\n  for left <= right {\\n    mid := left + (right - left)/2\\n    if check(ranks, cars, mid) {\\n      res = mid\\n      right = mid - 1\\n    } else {\\n      left = mid + 1\\n    }\\n  }\\n  return res\\n}\\n\\nfunc check(ranks []int, cars int, target int64) bool {\\n  // Each mechanic can take up to target minutes\\n  // Let\\'s see if we can repair all cards with the given time\\n  for i := 0; i < len(ranks) && cars > 0; i++ {\\n    cars -= int(math.Sqrt(float64(target / int64(ranks[i]))))\\n  }\\n  return cars <= 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586821,
                "title": "c-solution-binary-search-nlog-1e14-94-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimply binary answer \\ncreate a sample space of possible answers for 100 rank mech and 10^6 cars time 100 x 1e6x2=1e14\\nmini ans->1\\ndo binary search o the sample space if the mid time suffices the given ranks mechanic and cars then try something smalle otherwise larger\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(1e14))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n**PLS UPVOTE IF IT HELPED**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long end=1e14;\\n        long long st=1;\\n        long long time=0;\\n        long long mid=(st+end)>>1;\\n        int n=ranks.size();\\n        while(st<=end){\\n            mid=(st+end)>>1;\\n            int c=0;\\n\\n            for(int i=0;i<n;i++){\\n                long long x=mid/ranks[i];\\n                x=sqrt(x);\\n                c+=x;\\n                if(c>=cars) break;\\n            }\\n            if(c>=cars){\\n                time=mid;\\n                end=mid-1;\\n            }\\n            else st=mid+1;\\n        }\\n        return time;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long end=1e14;\\n        long long st=1;\\n        long long time=0;\\n        long long mid=(st+end)>>1;\\n        int n=ranks.size();\\n        while(st<=end){\\n            mid=(st+end)>>1;\\n            int c=0;\\n\\n            for(int i=0;i<n;i++){\\n                long long x=mid/ranks[i];\\n                x=sqrt(x);\\n                c+=x;\\n                if(c>=cars) break;\\n            }\\n            if(c>=cars){\\n                time=mid;\\n                end=mid-1;\\n            }\\n            else st=mid+1;\\n        }\\n        return time;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584628,
                "title": "understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n     This question is of binary search in answer topic \\n\\n     but the main catch is to find that this quesiton belongs to binary search on answer\\n     subtopic ; \\n     because answer lies in a range , and we have asked minimum value so this approach\\n     should have comein our mind \\n\\n\\n     WHENEVER MINIMUM HAS ASKED , WE HAVE TWO OPTIONS , \\n\\n     1. BINARY SEARCH ON ANSWERS ; \\n\\n     2. BFS APPROACH ; \\n\\n     \\n*/\\n\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        \\n        // lets try this with bianry search on answer ; \\n         \\n        long max = 0 ; \\n        \\n        long min = 100 ; \\n        \\n        for( int i = 0 ; i < ranks.length ; i++)\\n        {\\n            if( ranks[i] < min)\\n                min = (long)ranks[i] ; \\n            \\n            if( ranks[i] > max)\\n                max = (long)ranks[i] ; \\n        }\\n        \\n\\n       System.out.println(max) ;\\n       System.out.println(min) ;\\n        max = min * (long)cars * (long)cars ; \\n\\n\\n      System.out.println(max) ; \\n        // so max is the maximum possible answer \\n        \\n\\n\\n        min = 1 ; \\n\\n\\n\\n        // now do binary serach ; \\n\\n      long answer = Integer.MAX_VALUE ; \\n\\n        while( min <= max)\\n        {\\n            long mid = min + (max-min)/2  ; \\n\\n\\n            boolean temp = isPossible(ranks , (long)cars , mid ) ; \\n            \\n            if( temp == true)\\n            {\\n                answer = mid ; \\n\\n                max = mid-1 ; \\n            }\\n            else\\n            {\\n                min = mid+1  ;\\n            }\\n\\n\\n\\n\\n        }\\n\\n\\n        return answer ;\\n       \\n    }\\n    public boolean isPossible( int ranks[] , long cars , long mid)\\n    {\\n\\n        for( int i = 0 ; i < ranks.length ; i++)\\n        {\\n             if( cars <= 0 )\\n             return true ; \\n\\n            //  int temp = (int)mid /ranks[i] ;  yahaan mid ko int kara uske wajah se\\n            // interger overflow ho jayga aur answr out of bound chala jyaga \\n\\n\\n            long temp = (long)mid /(long)ranks[i] ; \\n\\n             long answer = (long)Math.sqrt(temp) ; \\n\\n \\n              cars = cars - answer ; \\n\\n        }\\n\\n        if( cars <= 0 )\\n        return true ; \\n\\n\\n        return false ; \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n     This question is of binary search in answer topic \\n\\n     but the main catch is to find that this quesiton belongs to binary search on answer\\n     subtopic ; \\n     because answer lies in a range , and we have asked minimum value so this approach\\n     should have comein our mind \\n\\n\\n     WHENEVER MINIMUM HAS ASKED , WE HAVE TWO OPTIONS , \\n\\n     1. BINARY SEARCH ON ANSWERS ; \\n\\n     2. BFS APPROACH ; \\n\\n     \\n*/\\n\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        \\n        // lets try this with bianry search on answer ; \\n         \\n        long max = 0 ; \\n        \\n        long min = 100 ; \\n        \\n        for( int i = 0 ; i < ranks.length ; i++)\\n        {\\n            if( ranks[i] < min)\\n                min = (long)ranks[i] ; \\n            \\n            if( ranks[i] > max)\\n                max = (long)ranks[i] ; \\n        }\\n        \\n\\n       System.out.println(max) ;\\n       System.out.println(min) ;\\n        max = min * (long)cars * (long)cars ; \\n\\n\\n      System.out.println(max) ; \\n        // so max is the maximum possible answer \\n        \\n\\n\\n        min = 1 ; \\n\\n\\n\\n        // now do binary serach ; \\n\\n      long answer = Integer.MAX_VALUE ; \\n\\n        while( min <= max)\\n        {\\n            long mid = min + (max-min)/2  ; \\n\\n\\n            boolean temp = isPossible(ranks , (long)cars , mid ) ; \\n            \\n            if( temp == true)\\n            {\\n                answer = mid ; \\n\\n                max = mid-1 ; \\n            }\\n            else\\n            {\\n                min = mid+1  ;\\n            }\\n\\n\\n\\n\\n        }\\n\\n\\n        return answer ;\\n       \\n    }\\n    public boolean isPossible( int ranks[] , long cars , long mid)\\n    {\\n\\n        for( int i = 0 ; i < ranks.length ; i++)\\n        {\\n             if( cars <= 0 )\\n             return true ; \\n\\n            //  int temp = (int)mid /ranks[i] ;  yahaan mid ko int kara uske wajah se\\n            // interger overflow ho jayga aur answr out of bound chala jyaga \\n\\n\\n            long temp = (long)mid /(long)ranks[i] ; \\n\\n             long answer = (long)Math.sqrt(temp) ; \\n\\n \\n              cars = cars - answer ; \\n\\n        }\\n\\n        if( cars <= 0 )\\n        return true ; \\n\\n\\n        return false ; \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580462,
                "title": "binary-search-solution-o-ranks-o-log-cars-binary-search",
                "content": "This is genuinely one that I couldn\\'t get until looking at some other solutions -- sometimes I am just in awe at how clever the mechanisms people can come up with. In my solution I ended up adapting the binary search method. \\n\\n\\n# Approach\\n1. Looking at the problem, I instinctively turned towards greedy, at a top level this was all about finding a nice apportionment such that the score was as small as possible. I also found this problem evocative of DP, but that seemed a little more complicated considering the somewhat nontrivial rating function of rank * cars ^2. \\n2. So then I used a toy apportionment, and then thought of ways to optimize it. The one I used was (3, 2, 2, 3), but honestly any can work, now it was making a decision of where to move a car. This iterative thinking made me go back to the beginning, lets start with 0 cars apportioned out and start reasoning -- that was my faux \"aha\" moment where I thought a heap could work. \\n3. Why a heap? Well at any step where we apportion a car to a mechanic, we have (ranks) choices to put it, so what if I just memoized the best possible mechanic choice to give it to? I investigated the big-O and realized it was in the realm of O(nlogn) and wrote up a solution that failed all but 4 cases. \\n4. So this is where my solution breaks down, because in the case of very few ranks, but many many cars, it really does matter whether its log(cars) or log(ranks) -- in my case, I was doing hundreds of thousands of iterations on one single rank, where as the binary search method does log(cars) which is like at most 14. \\n5. Now if we have many ranks, and many cars, the binary search solution is still better because we avoid doing so many \"meaningless\" cycles, when we can just sacrifice processing more ranks. \\n6. So at the very least, for me, this problem was a big lesson in really thinking about specific big-O, not just a benchmark, which would have immedately revealed a huge flaw with my original thought. \\n\\n# Complexity\\n- Time complexity:\\nAt worst this is O(10^5) * O(log(10^14)) ~ 10^5 * 14\\n\\n- Space complexity:\\nO(1) because we only have two pointers. \\n\\n# Code\\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        low = 0\\n        high = max(ranks) * cars * cars\\n\\n        def isAnsSmaller(mid):\\n            totalCarsRepaired = 0\\n            for rank in ranks:\\n                carsICanRepair = math.floor((mid / rank) ** (1/2))\\n                totalCarsRepaired += carsICanRepair\\n            return totalCarsRepaired >= cars\\n\\n        while(low < high):\\n            mid = low + (high - low)//2\\n            if (isAnsSmaller(mid)):\\n                high = mid\\n            else:\\n                low = mid + 1\\n        \\n        return low\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        low = 0\\n        high = max(ranks) * cars * cars\\n\\n        def isAnsSmaller(mid):\\n            totalCarsRepaired = 0\\n            for rank in ranks:\\n                carsICanRepair = math.floor((mid / rank) ** (1/2))\\n                totalCarsRepaired += carsICanRepair\\n            return totalCarsRepaired >= cars\\n\\n        while(low < high):\\n            mid = low + (high - low)//2\\n            if (isAnsSmaller(mid)):\\n                high = mid\\n            else:\\n                low = mid + 1\\n        \\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491297,
                "title": "rust-solution",
                "content": "# Code\\n```\\ntype Target = i64;\\ntype UseValue = i64;\\nfn lower_bound(arr: &Vec<Target>, x: &UseValue) -> usize {\\n    let mut low = 0;\\n    let mut high = arr.len();\\n    while low != high {\\n        let mid = (low + high) / 2;\\n        match arr[mid].cmp(x) {\\n            std::cmp::Ordering::Less => {\\n                low = mid + 1;\\n            }\\n            std::cmp::Ordering::Equal | std::cmp::Ordering::Greater => {\\n                high = mid;\\n            }\\n        }\\n    }\\n    low\\n}\\nimpl Solution {\\n  pub fn repair_cars(ranks: Vec<i32>, cars: i32) -> i64 {\\n    let n = ranks.len();\\n    let cars = cars as i64;\\n\\n    if n == 1 {\\n      return ranks[0] as i64 * cars * cars\\n    }\\n\\n    let ranks = ranks.into_iter().map(|v| v as i64).collect::<Vec<i64>>();\\n    let mut memo = vec![0;10usize.pow(6)];\\n    for i in 1..10i64.pow(6) {\\n      memo[i as usize] = i * i;\\n    }\\n\\n    let mut left = 0;\\n    let mut right = 10i64.pow(10);\\n    while left < right {\\n      let mid = (left+right)/ 2;\\n      let mut temp = 0;\\n\\n      for i in 0..n {\\n        let num_square = mid / ranks[i];\\n        let ti = lower_bound(&memo, &num_square);\\n        if memo[ti] == num_square {\\n          temp += ti as i64;\\n        } else {\\n          temp += ti as i64 - 1;\\n        }\\n      } \\n\\n      if temp < cars {\\n        left = mid + 1;\\n      } else {\\n        right = mid;\\n      }\\n    }\\n    right\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\ntype Target = i64;\\ntype UseValue = i64;\\nfn lower_bound(arr: &Vec<Target>, x: &UseValue) -> usize {\\n    let mut low = 0;\\n    let mut high = arr.len();\\n    while low != high {\\n        let mid = (low + high) / 2;\\n        match arr[mid].cmp(x) {\\n            std::cmp::Ordering::Less => {\\n                low = mid + 1;\\n            }\\n            std::cmp::Ordering::Equal | std::cmp::Ordering::Greater => {\\n                high = mid;\\n            }\\n        }\\n    }\\n    low\\n}\\nimpl Solution {\\n  pub fn repair_cars(ranks: Vec<i32>, cars: i32) -> i64 {\\n    let n = ranks.len();\\n    let cars = cars as i64;\\n\\n    if n == 1 {\\n      return ranks[0] as i64 * cars * cars\\n    }\\n\\n    let ranks = ranks.into_iter().map(|v| v as i64).collect::<Vec<i64>>();\\n    let mut memo = vec![0;10usize.pow(6)];\\n    for i in 1..10i64.pow(6) {\\n      memo[i as usize] = i * i;\\n    }\\n\\n    let mut left = 0;\\n    let mut right = 10i64.pow(10);\\n    while left < right {\\n      let mid = (left+right)/ 2;\\n      let mut temp = 0;\\n\\n      for i in 0..n {\\n        let num_square = mid / ranks[i];\\n        let ti = lower_bound(&memo, &num_square);\\n        if memo[ti] == num_square {\\n          temp += ti as i64;\\n        } else {\\n          temp += ti as i64 - 1;\\n        }\\n      } \\n\\n      if temp < cars {\\n        left = mid + 1;\\n      } else {\\n        right = mid;\\n      }\\n    }\\n    right\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3479264,
                "title": "rust-python-o-n-if-you-use-constrains-with-explanation",
                "content": "# Intuition\\n\\nTwo things can hint you that this is a binary search problem:\\n\\n - you calculate whether in a particular time, it is possible to repair all cars: `is_possible` function.\\n - this function is monotonic\\n\\nSo a simple binary search will work here. This is what all solutions are doing here. But it is possible to significantly speed it up, by selecting proper `hi` value (not a standard $10^{20}$). See how `hi` is calculated.\\n\\nAnother even bigger speed up is by noticing that currently `is_possible` runs in $O(n)$, so the full complexity is $(n \\\\log hi)$. But because of the the constrains of ranks is from [1, 100], you do can just precalculate the frequency of each of them and `is_possible` will run in constant time (we can treat 100 as constant as it is not big).\\n\\n\\n# Complexity\\n\\nLet the size of array is $n$, the number of cars is $k$. Because ranks is small (below 100), it is ignored.\\n\\n- Time complexity: $O(n) + O(\\\\log k)$\\n- Space complexity: $O(1)$ if we ignore original inputs (as we only store array of 100 numbers). Otherwise $O(n)$\\n\\n```Rust []\\nimpl Solution {\\n\\n  fn is_possible(data: &[i64; 101], mut k: i64, res: i64) -> bool {\\n    for i in 1 .. 101 {\\n      if data[i] == 0 { continue; }\\n      k -= data[i] * ((res / i as i64) as f64).sqrt() as i64;\\n      if k <= 0 {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  pub fn repair_cars(arr: Vec<i32>, k: i32) -> i64 {\\n    let k = k as i64;\\n    if arr.len() == 1 {\\n      return (arr[0] as i64) * k * k;\\n    }\\n\\n    let mut data: [i64; 101] = [0; 101];\\n    let mut lo = 1;\\n    let mut hi = 1;\\n    for v in arr {\\n      hi = hi.max(v as i64);\\n      data[v as usize] += 1;\\n    }\\n    hi *= k * k;\\n\\n    while lo < hi {\\n      let mi = (lo + hi) / 2;\\n      if Self::is_possible(&data, k, mi) {\\n        hi = mi;\\n      } else {\\n        lo = mi + 1;\\n      }\\n    }\\n\\n    return lo;\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n\\n  def is_possible(self, arr: List[int], k: int, res) -> bool:\\n    for v, cnt in enumerate(arr):\\n      if v > 0:\\n        k -= cnt * int((res / v) ** 0.5)\\n        if k <= 0:\\n          return True\\n    return False\\n\\n\\n  def repairCars(self, arr: List[int], k: int) -> int:\\n    if len(arr) == 1:\\n      return arr[0] * k * k\\n\\n    lo, hi = 1, min(arr) * k * k\\n\\n    data = [0] * 101\\n    for v in arr:\\n      data[v] += 1\\n\\n    while lo < hi:\\n      mi = (lo + hi) // 2\\n      if self.is_possible(data, k, mi):\\n        hi = mi\\n      else:\\n        lo = mi + 1\\n\\n    return lo\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```Rust []\\nimpl Solution {\\n\\n  fn is_possible(data: &[i64; 101], mut k: i64, res: i64) -> bool {\\n    for i in 1 .. 101 {\\n      if data[i] == 0 { continue; }\\n      k -= data[i] * ((res / i as i64) as f64).sqrt() as i64;\\n      if k <= 0 {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  pub fn repair_cars(arr: Vec<i32>, k: i32) -> i64 {\\n    let k = k as i64;\\n    if arr.len() == 1 {\\n      return (arr[0] as i64) * k * k;\\n    }\\n\\n    let mut data: [i64; 101] = [0; 101];\\n    let mut lo = 1;\\n    let mut hi = 1;\\n    for v in arr {\\n      hi = hi.max(v as i64);\\n      data[v as usize] += 1;\\n    }\\n    hi *= k * k;\\n\\n    while lo < hi {\\n      let mi = (lo + hi) / 2;\\n      if Self::is_possible(&data, k, mi) {\\n        hi = mi;\\n      } else {\\n        lo = mi + 1;\\n      }\\n    }\\n\\n    return lo;\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n\\n  def is_possible(self, arr: List[int], k: int, res) -> bool:\\n    for v, cnt in enumerate(arr):\\n      if v > 0:\\n        k -= cnt * int((res / v) ** 0.5)\\n        if k <= 0:\\n          return True\\n    return False\\n\\n\\n  def repairCars(self, arr: List[int], k: int) -> int:\\n    if len(arr) == 1:\\n      return arr[0] * k * k\\n\\n    lo, hi = 1, min(arr) * k * k\\n\\n    data = [0] * 101\\n    for v in arr:\\n      data[v] += 1\\n\\n    while lo < hi:\\n      mi = (lo + hi) // 2\\n      if self.is_possible(data, k, mi):\\n        hi = mi\\n      else:\\n        lo = mi + 1\\n\\n    return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460035,
                "title": "simple-binary-search-implementation",
                "content": "# Intuition\\nBinary Search Implementation \\nTo learn how to implement binary search on these type of questions learn predicate functions\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& ranks,int cars,long long mid)\\n    {\\n        long long count=0;\\n        for(int i=0;i<ranks.size();i++)\\n        {\\n            count+=(sqrt(mid/ranks[i]));\\n        }\\n        return count>=cars;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long lo=0,hi=LONG_MAX,mid,ans=0;\\n        while(lo<=hi)\\n        {\\n            mid=lo+(hi-lo)/2;\\n            if(check(ranks,cars,mid))\\n            {\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n            else\\n                lo=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& ranks,int cars,long long mid)\\n    {\\n        long long count=0;\\n        for(int i=0;i<ranks.size();i++)\\n        {\\n            count+=(sqrt(mid/ranks[i]));\\n        }\\n        return count>=cars;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long lo=0,hi=LONG_MAX,mid,ans=0;\\n        while(lo<=hi)\\n        {\\n            mid=lo+(hi-lo)/2;\\n            if(check(ranks,cars,mid))\\n            {\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n            else\\n                lo=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431739,
                "title": "java-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\nArrays.sort(ranks);\\n        int n=ranks.length;\\n\\n        long low=0;\\n        long hi=Long.MAX_VALUE;\\n         long ans=-1;\\n        while(low<=hi){\\n            long mid=(low+hi)/2;\\n            if(isPossible(mid,ranks,cars)){\\n                hi=mid-1;\\n                ans=mid;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n\\n        return ans;\\n     \\n        \\n    }\\n    public boolean isPossible(long target,int []ranks,int cars){\\n        for(int i=0;i<ranks.length;i++){\\n            cars-=(int)(Math.sqrt(target/ranks[i]));\\n            if(cars<=0){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\nArrays.sort(ranks);\\n        int n=ranks.length;\\n\\n        long low=0;\\n        long hi=Long.MAX_VALUE;\\n         long ans=-1;\\n        while(low<=hi){\\n            long mid=(low+hi)/2;\\n            if(isPossible(mid,ranks,cars)){\\n                hi=mid-1;\\n                ans=mid;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n\\n        return ans;\\n     \\n        \\n    }\\n    public boolean isPossible(long target,int []ranks,int cars){\\n        for(int i=0;i<ranks.length;i++){\\n            cars-=(int)(Math.sqrt(target/ranks[i]));\\n            if(cars<=0){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415290,
                "title": "easy-understandable-binary-search",
                "content": "# Intuition\\n- Binary Search\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Sort the ranks array\\n- Define start and end limits: just take the smallest and largest possible values to avoid any confusion\\n- For every mid, check whether it could be a possible candidate for ans or not\\n- If yes:\\n-       ans=mid, end=mid-1;\\n- Else:\\n-       start=mid+1\\n- isPossible function calculates the maximum car within the given time (mid), a mechanic can repair and subtract it from the total cars.\\n-       int car=sqrt(time/ranks[i])\\n- At the last, if cars>0, not possible else possible\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool isPossible(vector<int> &ranks, int cars, long long mid){\\n        int n=ranks.size();\\n        for(int i=0;i<n;i++){\\n            if(cars>0){\\n                int n=sqrt(mid/ranks[i]);\\n                cars-=n;\\n            }else{\\n                break;\\n            }\\n        }\\n        if(cars>0){\\n            return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        sort(ranks.begin(),ranks.end());\\n        long long start=1,\\n        end=(101)*1LL*(1e6)*(1e6); // r*n*n limit\\n        long long ans=end;\\n\\n        while(start<=end){\\n            long long mid=start+(end-start)/2;\\n            if(isPossible(ranks,cars,mid)){ // mid is time\\n                ans=mid;\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool isPossible(vector<int> &ranks, int cars, long long mid){\\n        int n=ranks.size();\\n        for(int i=0;i<n;i++){\\n            if(cars>0){\\n                int n=sqrt(mid/ranks[i]);\\n                cars-=n;\\n            }else{\\n                break;\\n            }\\n        }\\n        if(cars>0){\\n            return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        sort(ranks.begin(),ranks.end());\\n        long long start=1,\\n        end=(101)*1LL*(1e6)*(1e6); // r*n*n limit\\n        long long ans=end;\\n\\n        while(start<=end){\\n            long long mid=start+(end-start)/2;\\n            if(isPossible(ranks,cars,mid)){ // mid is time\\n                ans=mid;\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411138,
                "title": "binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(long long mid, vector<int>& ranks, int cars){\\n        long long int carCount=0;\\n        for(auto i: ranks){\\n            carCount+=sqrt((double)(mid/i)); \\n        }\\n        return carCount>=cars;\\n    }\\n    \\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int low=0, high=LLONG_MAX;\\n        sort(ranks.begin(), ranks.end());\\n        \\n        while(low<=high){\\n            long long int mid = low+(high-low)/2;\\n            if(check(mid, ranks, cars)){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(long long mid, vector<int>& ranks, int cars){\\n        long long int carCount=0;\\n        for(auto i: ranks){\\n            carCount+=sqrt((double)(mid/i)); \\n        }\\n        return carCount>=cars;\\n    }\\n    \\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int low=0, high=LLONG_MAX;\\n        sort(ranks.begin(), ranks.end());\\n        \\n        while(low<=high){\\n            long long int mid = low+(high-low)/2;\\n            if(check(mid, ranks, cars)){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392220,
                "title": "python-binary-search-300-ms",
                "content": "1. To use binary search on time, first we need to consider the problem: given time `T`, can we repair all the cars?\\nFor any rank `r`, under the constraint `T`, we have\\n<img src=\"https://assets.leetcode.com/users/images/fd3082a3-6b97-4193-ac29-9ebc00097b72_1680923976.2968996.png\" width=\"30%\" height=\"30%\">\\nHence we can repair `sum([int(sqrt(T/r)) for r in ranks])` cars at most.\\n2. Use binary search to find the minimal `T`.\\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        counter = Counter(ranks)\\n        \\n        def run(T):\\n            todo = cars\\n            for r, cnt in counter.items():\\n                todo -= int(sqrt(T/r)) * cnt\\n                if todo <= 0:\\n                    return True\\n            return todo <= 0\\n        \\n        le, ri = 1, int(max(counter)*cars*cars)\\n        while le < ri:\\n            mid = (le+ri) // 2\\n            if run(mid):\\n                ri = mid\\n            else:\\n                le = mid + 1\\n        return le",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. To use binary search on time, first we need to consider the problem: given time `T`, can we repair all the cars?\\nFor any rank `r`, under the constraint `T`, we have\\n<img src=\"https://assets.leetcode.com/users/images/fd3082a3-6b97-4193-ac29-9ebc00097b72_1680923976.2968996.png\" width=\"30%\" height=\"30%\">\\nHence we can repair `sum([int(sqrt(T/r)) for r in ranks])` cars at most.\\n2. Use binary search to find the minimal `T`.\\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        counter = Counter(ranks)\\n        \\n        def run(T):\\n            todo = cars\\n            for r, cnt in counter.items():\\n                todo -= int(sqrt(T/r)) * cnt\\n                if todo <= 0:\\n                    return True\\n            return todo <= 0\\n        \\n        le, ri = 1, int(max(counter)*cars*cars)\\n        while le < ri:\\n            mid = (le+ri) // 2\\n            if run(mid):\\n                ri = mid\\n            else:\\n                le = mid + 1\\n        return le",
                "codeTag": "Java"
            },
            {
                "id": 3386693,
                "title": "easiest-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars)\\n    {\\n        long long int l =1 , h = 1e14,mid, res  ;\\n        \\n        while(l<=h)\\n        {   \\n           long long  int   capacity = 0; \\n            mid = (l+h)/2;\\n            cout<<mid<<\" \";\\n            \\n             \\n           \\n            for(auto x:ranks)\\n            {    \\n                 capacity +=  sqrt(mid/x); \\n\\n            }\\n            if(capacity>=cars)\\n            {   \\n                res  = mid; \\n                h  = mid -1;\\n            }\\n            \\n            else l = mid +1; \\n           \\n        }\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars)\\n    {\\n        long long int l =1 , h = 1e14,mid, res  ;\\n        \\n        while(l<=h)\\n        {   \\n           long long  int   capacity = 0; \\n            mid = (l+h)/2;\\n            cout<<mid<<\" \";\\n            \\n             \\n           \\n            for(auto x:ranks)\\n            {    \\n                 capacity +=  sqrt(mid/x); \\n\\n            }\\n            if(capacity>=cars)\\n            {   \\n                res  = mid; \\n                h  = mid -1;\\n            }\\n            \\n            else l = mid +1; \\n           \\n        }\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3384498,
                "title": "heap-solution",
                "content": "# Intuition\\nUse heap\\n\\n# Approach\\nMove all items into the MinHeap. Iterate all cars, on every step add next car to the heap head. Get max time needed from all the mechanics.\\n\\n# Complexity\\n- Time complexity:\\nO(N * Log(k))\\n\\n- Space complexity:\\nO(K)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} ranks\\n * @param {number} cars\\n * @return {number}\\n */\\nvar repairCars = function(ranks, cars) {\\n    const heap = new MinPriorityQueue()\\n    for(let r of ranks){\\n        heap.enqueue({rank: r, cars: 0}, r);\\n    }\\n    \\n    while(cars > 0) {\\n        const top = heap.dequeue().element;\\n        top.cars++;\\n        heap.enqueue(top, top.rank * Math.pow(top.cars + 1, 2))\\n        cars--;\\n    }\\n    \\n    let res = 0; \\n    while(heap.size() > 0){\\n        const top = heap.dequeue().element;\\n        res = Math.max(Math.pow(top.cars, 2) * top.rank, res);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} ranks\\n * @param {number} cars\\n * @return {number}\\n */\\nvar repairCars = function(ranks, cars) {\\n    const heap = new MinPriorityQueue()\\n    for(let r of ranks){\\n        heap.enqueue({rank: r, cars: 0}, r);\\n    }\\n    \\n    while(cars > 0) {\\n        const top = heap.dequeue().element;\\n        top.cars++;\\n        heap.enqueue(top, top.rank * Math.pow(top.cars + 1, 2))\\n        cars--;\\n    }\\n    \\n    let res = 0; \\n    while(heap.size() > 0){\\n        const top = heap.dequeue().element;\\n        res = Math.max(Math.pow(top.cars, 2) * top.rank, res);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3379468,
                "title": "c-using-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSuff(vector<int>& ranks, int &cars, long long time){\\n\\n        long long carsDone=0;\\n\\n         for(auto r:ranks){\\n             long long c2= time/r;\\n             long long c= floor(sqrt(c2));\\n             carsDone+=c;\\n         }\\n\\n         return carsDone>=cars;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        \\n        long long l=0;\\n        long long r=1e18;\\n\\n        while(l<r){\\n           long long mid=l+(r-l)/2;\\n            if(isSuff(ranks,cars,mid)){\\n                r=mid;\\n\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        // return l or r as both will be equal\\n         return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSuff(vector<int>& ranks, int &cars, long long time){\\n\\n        long long carsDone=0;\\n\\n         for(auto r:ranks){\\n             long long c2= time/r;\\n             long long c= floor(sqrt(c2));\\n             carsDone+=c;\\n         }\\n\\n         return carsDone>=cars;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        \\n        long long l=0;\\n        long long r=1e18;\\n\\n        while(l<r){\\n           long long mid=l+(r-l)/2;\\n            if(isSuff(ranks,cars,mid)){\\n                r=mid;\\n\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        // return l or r as both will be equal\\n         return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372800,
                "title": "simple-c-solution-using-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool good(long long x , int cars ,vector<int>&arr){\\n        long long ct = 0;\\n\\n        for(int i=0 ; i<arr.size() ; i++){\\n            ct += sqrt(x/arr[i]);\\n        }\\n\\n        return ct>=cars;\\n    }\\n    long long repairCars(vector<int>& arr, int cars) {\\n        int n = arr.size();\\n        long long low = 0 , high = 1e18;\\n        long long ans = 0;\\n\\n        while(low<=high){\\n            long long mid = low + (high-low)/2;\\n\\n            if(good(mid , cars ,arr  )){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool good(long long x , int cars ,vector<int>&arr){\\n        long long ct = 0;\\n\\n        for(int i=0 ; i<arr.size() ; i++){\\n            ct += sqrt(x/arr[i]);\\n        }\\n\\n        return ct>=cars;\\n    }\\n    long long repairCars(vector<int>& arr, int cars) {\\n        int n = arr.size();\\n        long long low = 0 , high = 1e18;\\n        long long ans = 0;\\n\\n        while(low<=high){\\n            long long mid = low + (high-low)/2;\\n\\n            if(good(mid , cars ,arr  )){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363814,
                "title": "python-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n\\n        def cal(minutes):\\n            cars = 0\\n            for rank in ranks:\\n                cars += math.floor((minutes / rank) ** 0.5)\\n            return cars\\n\\n        lo = 0\\n        hi = min(ranks) * cars * cars\\n        while lo < hi:\\n            mi = (lo + hi) // 2\\n            if cal(mi) < cars:\\n                lo = mi + 1\\n            else:\\n                hi = mi\\n\\n        return lo\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n\\n        def cal(minutes):\\n            cars = 0\\n            for rank in ranks:\\n                cars += math.floor((minutes / rank) ** 0.5)\\n            return cars\\n\\n        lo = 0\\n        hi = min(ranks) * cars * cars\\n        while lo < hi:\\n            mi = (lo + hi) // 2\\n            if cal(mi) < cars:\\n                lo = mi + 1\\n            else:\\n                hi = mi\\n\\n        return lo\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363192,
                "title": "using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can guess total time by using binary search from least time (i.e. 1) to maximum time(Any value can be taken from the ranks). \\n\\n# Complexity\\n\\n- Time complexity: O((log(ranks[0]) + logcars) * 100)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        count=collections.Counter(ranks)\\n        min_time,max_time=1,ranks[0]*cars*cars\\n        while min_time<=max_time:\\n            time=min_time+((max_time-min_time)>>1)\\n            if sum(isqrt(time//rank) * count[rank] for rank in count)<cars:min_time=time+1\\n            else:max_time=time-1\\n        return min_time\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        count=collections.Counter(ranks)\\n        min_time,max_time=1,ranks[0]*cars*cars\\n        while min_time<=max_time:\\n            time=min_time+((max_time-min_time)>>1)\\n            if sum(isqrt(time//rank) * count[rank] for rank in count)<cars:min_time=time+1\\n            else:max_time=time-1\\n        return min_time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360142,
                "title": "easy-to-understand-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n\\n    bool solve(vector<int>& ranks, int cars,ll key){\\n        ll tcar=0;\\n        for(auto x:ranks){\\n            // x*(n^2)=key\\n            //n^2=key/2\\n            ll nsquare=key/x;\\n            ll n=floor(sqrt(nsquare));\\n            tcar+=n;\\n        }\\n        return (tcar>=cars);\\n    }\\n\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        ll l=0,r=1e14;\\n        while(l<r){\\n            long long mid=l+(r-l)/2;\\n            if(solve(ranks,cars,mid))\\n                r=mid;\\n            else\\n                l=mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n\\n    bool solve(vector<int>& ranks, int cars,ll key){\\n        ll tcar=0;\\n        for(auto x:ranks){\\n            // x*(n^2)=key\\n            //n^2=key/2\\n            ll nsquare=key/x;\\n            ll n=floor(sqrt(nsquare));\\n            tcar+=n;\\n        }\\n        return (tcar>=cars);\\n    }\\n\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        ll l=0,r=1e14;\\n        while(l<r){\\n            long long mid=l+(r-l)/2;\\n            if(solve(ranks,cars,mid))\\n                r=mid;\\n            else\\n                l=mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348465,
                "title": "simple-java-solution-binary-search",
                "content": "```\\nLogic :\\nWhy Binary Search ?\\nHint :Return the minimum time taken to repair all the cars.\\nWhen ever minimum and maximum comes the first thing which comes in our mind is DP..\\nBut also keep in mind when ever we apply we must look the Constraints:\\n\\n1 <= ranks.length <= 10^5\\n1 <= ranks[i] <= 100\\n1 <= cars <= 10^6\\nIn these contraint the length is 10^5 as per my knowlege dp is not possible in this range...\\n\\nPoint to Keep in mind : \\nwhen ever you see question asking maximum of minimum , minimum of maximum ,maximum , minimum have a thougth of Binary Search beacause in many case Binary Search Works very well....\\n\\nNow How to apply binary Search ?\\nThis Problem is basically type : Binary Search on Answer \\nSo , if we apply binary search then we must need the max ans possible and minimun ans possible for range \\nbecause without having range we can\\'t apply it.\\n\\nFor this Problem :\\nMinimum ans possible is : 1 (no minimum time possible for it.\\nMaximun time possible is : Max of rank * cars^2\\nbut in this case max value if rank[i] = 100 , so why to find max of arr and use O(n) time..\\nsimpley put max = 1L*cars *cars *100\\nNow  we have to minimise the time so that in that time frame all cars can be washed ..\\nto count no. of cars see the eq^n :\\n time  = rank * cars *cars \\n cars  = sqrt(time/rank)....\\n \\n Hope you Enjoyed the solution ...\\n\\nSee the Full Code below :-\\n\\n```\\n\\n\\n\\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long start =1;\\n        long end= 1L* cars *cars *100;\\n        long res=0;\\n        while(start<=end){\\n            long mid = start +(end-start)/2;\\n            if(isPossible(mid , ranks , cars)==true){\\n                res = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n    public static boolean isPossible(long time ,int[] ranks ,int cars){\\n        long count =0;\\n        for(int i=0;i<ranks.length;i++){\\n            count +=(int)Math.floor(Math.sqrt(time/ranks[i]));\\n             if(count>=cars)break;\\n        }\\n        return count>=cars;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nLogic :\\nWhy Binary Search ?\\nHint :Return the minimum time taken to repair all the cars.\\nWhen ever minimum and maximum comes the first thing which comes in our mind is DP..\\nBut also keep in mind when ever we apply we must look the Constraints:\\n\\n1 <= ranks.length <= 10^5\\n1 <= ranks[i] <= 100\\n1 <= cars <= 10^6\\nIn these contraint the length is 10^5 as per my knowlege dp is not possible in this range...\\n\\nPoint to Keep in mind : \\nwhen ever you see question asking maximum of minimum , minimum of maximum ,maximum , minimum have a thougth of Binary Search beacause in many case Binary Search Works very well....\\n\\nNow How to apply binary Search ?\\nThis Problem is basically type : Binary Search on Answer \\nSo , if we apply binary search then we must need the max ans possible and minimun ans possible for range \\nbecause without having range we can\\'t apply it.\\n\\nFor this Problem :\\nMinimum ans possible is : 1 (no minimum time possible for it.\\nMaximun time possible is : Max of rank * cars^2\\nbut in this case max value if rank[i] = 100 , so why to find max of arr and use O(n) time..\\nsimpley put max = 1L*cars *cars *100\\nNow  we have to minimise the time so that in that time frame all cars can be washed ..\\nto count no. of cars see the eq^n :\\n time  = rank * cars *cars \\n cars  = sqrt(time/rank)....\\n \\n Hope you Enjoyed the solution ...\\n\\nSee the Full Code below :-\\n\\n```\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long start =1;\\n        long end= 1L* cars *cars *100;\\n        long res=0;\\n        while(start<=end){\\n            long mid = start +(end-start)/2;\\n            if(isPossible(mid , ranks , cars)==true){\\n                res = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n    public static boolean isPossible(long time ,int[] ranks ,int cars){\\n        long count =0;\\n        for(int i=0;i<ranks.length;i++){\\n            count +=(int)Math.floor(Math.sqrt(time/ranks[i]));\\n             if(count>=cars)break;\\n        }\\n        return count>=cars;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347575,
                "title": "binary-search-c",
                "content": "# Complexity\\n- Time complexity:O(nlog(1e14))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    bool check(ll cost, vector<int> &ranks, int cars){\\n        int n = ranks.size();\\n        ll cnt = 0;\\n        for(int i = 0; i<n; i++){\\n            cnt += (sqrtl((cost/ranks[i])));\\n        }\\n\\n        return cnt >= cars;\\n    }\\n\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        ll l = 1, r = 1e14, ans = 0;\\n\\n        while(l <= r){\\n            ll mid = l+(r - l) / 2;\\n\\n            if(check(mid, ranks, cars)){\\n                ans = mid;\\n                r = mid - 1;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    bool check(ll cost, vector<int> &ranks, int cars){\\n        int n = ranks.size();\\n        ll cnt = 0;\\n        for(int i = 0; i<n; i++){\\n            cnt += (sqrtl((cost/ranks[i])));\\n        }\\n\\n        return cnt >= cars;\\n    }\\n\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        ll l = 1, r = 1e14, ans = 0;\\n\\n        while(l <= r){\\n            ll mid = l+(r - l) / 2;\\n\\n            if(check(mid, ranks, cars)){\\n                ans = mid;\\n                r = mid - 1;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345465,
                "title": "python-solution-using-heap-965ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        if len(ranks) == 1: return ranks[0] * cars * cars\\n        count = Counter(ranks)\\n        heap = [(n, 1, n) for n in count]\\n        heapq.heapify(heap)\\n        res = 0\\n        while cars > 0:\\n            node, times, base = heapq.heappop(heap)\\n            cars -= count[base]\\n            times += 1\\n            heapq.heappush(heap, (base * times * times, times, base))\\n            res = base * (times - 1) ** 2\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        if len(ranks) == 1: return ranks[0] * cars * cars\\n        count = Counter(ranks)\\n        heap = [(n, 1, n) for n in count]\\n        heapq.heapify(heap)\\n        res = 0\\n        while cars > 0:\\n            node, times, base = heapq.heappop(heap)\\n            cars -= count[base]\\n            times += 1\\n            heapq.heappush(heap, (base * times * times, times, base))\\n            res = base * (times - 1) ** 2\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343993,
                "title": "binary-search-c-thought-process-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem says find the min time required to repair cars\\n\\nThe main strategy used to solve such problems finding an answer in a search space and preferably use Bin Search to eliminate left and right halfs when needed\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor Binary search we set start as min assuming \\n\\nThe min value of search space will be min value of array ranks \\n\\nEx - [1,2,3,4]\\nwe want to repair 1 car so rank 1 mechanic will repair it in 1 minute\\n\\nAnd the max value of search space will be max time required by the min rank mechanic \\n\\nEx - [1]\\nwe want to repair 10 car so rank 1 mechanic will repair it in 1 * 10^2 mins\\n\\nHaving start and end run a binary search and check if in mid minutes it is possible to repair atleast the given cars\\n\\nmove to left half if possible to find the minimum possible time\\nelse go to right half since it is not possible to repair this much cars in the given mid time maybe in mid+1 to end it can be repaired\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N.logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long how_many_cars(int rank, long long time)\\n    {\\n        return sqrt(time/rank);\\n    }\\n\\n    long long repairCars(vector<int>& ranks, int cars) \\n    {   \\n        int min = *min_element(ranks.begin(), ranks.end());\\n        long long start = min;\\n        long long end = min* (long long)cars  * (long long)cars;\\n        long long ans = 0;\\n\\n        while(start<=end)\\n        {\\n            long long mid = start + (end - start)/2;\\n            long long sum = 0;\\n\\n            for(int i = 0 ; i < ranks.size() ; i++)\\n            {\\n                sum+= how_many_cars(ranks[i], mid);\\n                if(sum >= cars)\\n                    break;\\n            }\\n\\n            if(sum >= cars)\\n            {\\n                ans = mid;\\n                end = mid-1;\\n            }\\n            else\\n                start = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long how_many_cars(int rank, long long time)\\n    {\\n        return sqrt(time/rank);\\n    }\\n\\n    long long repairCars(vector<int>& ranks, int cars) \\n    {   \\n        int min = *min_element(ranks.begin(), ranks.end());\\n        long long start = min;\\n        long long end = min* (long long)cars  * (long long)cars;\\n        long long ans = 0;\\n\\n        while(start<=end)\\n        {\\n            long long mid = start + (end - start)/2;\\n            long long sum = 0;\\n\\n            for(int i = 0 ; i < ranks.size() ; i++)\\n            {\\n                sum+= how_many_cars(ranks[i], mid);\\n                if(sum >= cars)\\n                    break;\\n            }\\n\\n            if(sum >= cars)\\n            {\\n                ans = mid;\\n                end = mid-1;\\n            }\\n            else\\n                start = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343112,
                "title": "binary-search-very-simple-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool isPossible(vector<int>& ranks, int cars, long long time)\\n    {\\n        long long totalCars=0;\\n        for(auto r: ranks)\\n        {\\n            totalCars+=(long long)sqrt((long long)time/r);\\n        }\\n        return totalCars>=cars;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) \\n    {\\n        int mx=*max_element(ranks.begin(),ranks.end());\\n        long long l=1, r=(long long)mx*cars*cars;\\n        while(l<=r)\\n        {\\n            long long mid=(l+r)/2;\\n            if(isPossible(ranks,cars,mid)) r=mid-1;\\n            else l=mid+1;\\n        }\\n        return l;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isPossible(vector<int>& ranks, int cars, long long time)\\n    {\\n        long long totalCars=0;\\n        for(auto r: ranks)\\n        {\\n            totalCars+=(long long)sqrt((long long)time/r);\\n        }\\n        return totalCars>=cars;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) \\n    {\\n        int mx=*max_element(ranks.begin(),ranks.end());\\n        long long l=1, r=(long long)mx*cars*cars;\\n        while(l<=r)\\n        {\\n            long long mid=(l+r)/2;\\n            if(isPossible(ranks,cars,mid)) r=mid-1;\\n            else l=mid+1;\\n        }\\n        return l;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338843,
                "title": "binarysearch-intuition",
                "content": "# Intuition\\n\\n```\\n\\n// There can be two approaches to think,\\n// 1st way we can think to distribute cars to\\n// mechanics in different  ways i.e \\n// to try out all configuration and return\\n// the minimum time to repair.  \\n//\\n// Another way would be to just focus on what we need to find .\\n// so here we need to find the time to repair all cars . \\n// so what can be the best time to repair all cars \\n// 1 minute right ?.\\n// if if it is possible to repair all car within 1 minute , \\n// then yes this is our answer .\\n// else we will try 2 min then 3 min and so one .....\\n// but now the question is how can we check \\n// if it is possible to repair all cars within t minute   or not ?\\n\\n// Lets see how ...\\n// lets say t is the time we required .\\n//now we have time , we need to know how many cars each mechanic can repair within time t \\n//  lets say c no of cars , so as per equation each mechanic can repair c cars within r*c^2 time\\n// then r*C^2 <= t   ==>   C <= squareroot(t/r)   ==>   max car repaired = squareroot(t/r) .\\n\\n// In this way for  time t , we can find the cars repaired by each each mechanic \\n// if the total cars repaired is >= the cars given in the questions , then yes this is the answer.\\n\\n// so what is the time complexity ? \\n// actually we are doing linear search on time \\n// so maxi time be T and no of mechanic lets say M so TC : O(T*M)\\n\\n// but this will obviously will give TLE . we need to optimise our solution .\\n// so here we are applying linear search , lets think if we can apply binary search or not.\\n// if after splitting the search space , if we can ignore left or right half then that means \\n// we can apply binary search . so Here we can apply binary seach .\\n\\n// so Our TC will become : O(log(T)*M) . Yes this will pass !\\n\\n\\n \\n\\ntypedef long long int ll ;\\n\\nclass Solution {\\npublic:\\n\\nbool isPossibleToRepair(ll t , vector<int>&ranks , int n) {\\n\\n    ll m = ranks.size() ;\\n    ll totalRepairedCars = 0 ;\\n\\n    for(int i = 0 ;i<m ;i++) {\\n          \\n          ll r = ranks[i] ;\\n          totalRepairedCars += sqrt(t/r) ;\\n    }\\n    return totalRepairedCars >= n ;\\n}\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        \\n        ll s = 1 , e = 1e14 ;\\n        ll ans = 0 ;\\n\\n        while(s<=e) {\\n\\n            ll mid = s + (e-s)/2 ;\\n\\n            if(isPossibleToRepair(mid , ranks , cars)) {\\n                ans = mid ;\\n                e = mid-1 ;\\n            }\\n            else \\n                s = mid+1 ;\\n        }\\n        return ans ;\\n      \\n\\n        \\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n// There can be two approaches to think,\\n// 1st way we can think to distribute cars to\\n// mechanics in different  ways i.e \\n// to try out all configuration and return\\n// the minimum time to repair.  \\n//\\n// Another way would be to just focus on what we need to find .\\n// so here we need to find the time to repair all cars . \\n// so what can be the best time to repair all cars \\n// 1 minute right ?.\\n// if if it is possible to repair all car within 1 minute , \\n// then yes this is our answer .\\n// else we will try 2 min then 3 min and so one .....\\n// but now the question is how can we check \\n// if it is possible to repair all cars within t minute   or not ?\\n\\n// Lets see how ...\\n// lets say t is the time we required .\\n//now we have time , we need to know how many cars each mechanic can repair within time t \\n//  lets say c no of cars , so as per equation each mechanic can repair c cars within r*c^2 time\\n// then r*C^2 <= t   ==>   C <= squareroot(t/r)   ==>   max car repaired = squareroot(t/r) .\\n\\n// In this way for  time t , we can find the cars repaired by each each mechanic \\n// if the total cars repaired is >= the cars given in the questions , then yes this is the answer.\\n\\n// so what is the time complexity ? \\n// actually we are doing linear search on time \\n// so maxi time be T and no of mechanic lets say M so TC : O(T*M)\\n\\n// but this will obviously will give TLE . we need to optimise our solution .\\n// so here we are applying linear search , lets think if we can apply binary search or not.\\n// if after splitting the search space , if we can ignore left or right half then that means \\n// we can apply binary search . so Here we can apply binary seach .\\n\\n// so Our TC will become : O(log(T)*M) . Yes this will pass !\\n\\n\\n \\n\\ntypedef long long int ll ;\\n\\nclass Solution {\\npublic:\\n\\nbool isPossibleToRepair(ll t , vector<int>&ranks , int n) {\\n\\n    ll m = ranks.size() ;\\n    ll totalRepairedCars = 0 ;\\n\\n    for(int i = 0 ;i<m ;i++) {\\n          \\n          ll r = ranks[i] ;\\n          totalRepairedCars += sqrt(t/r) ;\\n    }\\n    return totalRepairedCars >= n ;\\n}\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        \\n        ll s = 1 , e = 1e14 ;\\n        ll ans = 0 ;\\n\\n        while(s<=e) {\\n\\n            ll mid = s + (e-s)/2 ;\\n\\n            if(isPossibleToRepair(mid , ranks , cars)) {\\n                ans = mid ;\\n                e = mid-1 ;\\n            }\\n            else \\n                s = mid+1 ;\\n        }\\n        return ans ;\\n      \\n\\n        \\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337812,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars)\\n    {\\n        long long low=0,high=1e14,ans;\\n        int n=ranks.size();\\n        while(low<=high)\\n        {\\n            long long mid=low+(high-low)/2,count=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                count+=sqrt(mid/ranks[i]);\\n            }\\n            if(count>=cars)\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf you like the solution plz upvote.\\n=",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars)\\n    {\\n        long long low=0,high=1e14,ans;\\n        int n=ranks.size();\\n        while(low<=high)\\n        {\\n            long long mid=low+(high-low)/2,count=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                count+=sqrt(mid/ranks[i]);\\n            }\\n            if(count>=cars)\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334415,
                "title": "as-always-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    bool canRepair(vector<int>&ranks, int cars, long long k){\\n        for(auto r : ranks){\\n            if(r > k) break;\\n            long long x = k/r;\\n            x = sqrt(x);\\n\\n            if(x >= cars){\\n                cars = 0;\\n                break;\\n            }\\n\\n            cars -= x;\\n        }\\n\\n        return (cars==0);\\n    }\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        //1.dp - O(ranks*cars)\\n\\n        //2.as always binary search - O(log(LLONG_MAX)) \\n        sort(begin(ranks),end(ranks));\\n        int n = ranks.size();\\n        long long low = 1, high = 1ll*ranks[n-1]*cars*cars;\\n        long long res = 1e18;\\n\\n        while(low<=high){\\n            long long mid = low + (high-low)/2;\\n            if(canRepair(ranks,cars,mid)){\\n                res = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid+1;\\n        }\\n\\n        return res;\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool canRepair(vector<int>&ranks, int cars, long long k){\\n        for(auto r : ranks){\\n            if(r > k) break;\\n            long long x = k/r;\\n            x = sqrt(x);\\n\\n            if(x >= cars){\\n                cars = 0;\\n                break;\\n            }\\n\\n            cars -= x;\\n        }\\n\\n        return (cars==0);\\n    }\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        //1.dp - O(ranks*cars)\\n\\n        //2.as always binary search - O(log(LLONG_MAX)) \\n        sort(begin(ranks),end(ranks));\\n        int n = ranks.size();\\n        long long low = 1, high = 1ll*ranks[n-1]*cars*cars;\\n        long long res = 1e18;\\n\\n        while(low<=high){\\n            long long mid = low + (high-low)/2;\\n            if(canRepair(ranks,cars,mid)){\\n                res = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid+1;\\n        }\\n\\n        return res;\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332427,
                "title": "a-few-solutions",
                "content": "Use binary search to make a logarithmic amount of guesses `k` for the minimum `time` we can fix target `T` cars, ie. perform a linear scan of `A` for validation per `k`<sup>th</sup> guess to divide-and-conquer the search space `i..j` inclusive in near-linear O(NlogN) time.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun repairCars(A: IntArray, T: Int): Long {\\n        var ok = { time: Long -> T <= A.map{ Math.sqrt(time.toDouble() / it).toLong() }.sum() }\\n        var (i, j) = Pair(1L, A.max()!!.toLong() * T.toLong() * T.toLong())\\n        while (i < j) {\\n            var k = (i + j) / 2\\n            if (ok(k))\\n                j = k\\n            else\\n                i = k + 1\\n        }\\n        return i\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet repairCars = (A, T) => {\\n    let ok = time => T <= _.sum(A.map(rank => Math.floor(Math.sqrt(time / rank))));\\n    let [i, j] = [1, Math.max(...A) * T * T];\\n    while (i < j) {\\n        let k = Math.floor((i + j) / 2);\\n        if (ok(k))\\n            j = k;\\n        else\\n            i = k + 1;\\n    }\\n    return i;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def repairCars(self, A: List[int], T: int) -> int:\\n        ok = lambda time: T <= sum([floor(sqrt(time / rank)) for rank in A])\\n        i, j = 1, int(max(A) * T * T)\\n        while i < j:\\n            k = (i + j) // 2\\n            if ok(k):\\n                j = k\\n            else:\\n                i = k + 1\\n        return i\\n```\\n\\n*Rust*\\n```\\nimpl Solution {\\n    pub fn repair_cars(A: Vec<i32>, T: i32) -> i64 {\\n        let T = T as i64;\\n        let ok = (|time| T <= A.iter().map(|rank| (time as f64 / *rank as f64).sqrt() as i64).sum());\\n        let (mut i, mut j) = (1i64, *A.iter().max().unwrap() as i64 * T * T);\\n        while i < j {\\n            let k = (i + j) / 2i64;\\n            if ok(k) {\\n                j = k;\\n            } else {\\n                i = k + 1;\\n            }\\n        }\\n        i\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    LL repairCars(VI& A, int T) {\\n        auto ok = [&](auto time) { return T <= accumulate(A.begin(), A.end(), 0LL, [=](auto t, auto rank) { return t + sqrt(time / rank); }); };\\n        auto [i, j] = make_pair(1LL, *max_element(A.begin(), A.end()) * LL(T) * LL(T));\\n        while (i < j) {\\n            auto k = (i + j) / 2;\\n            if (ok(k))\\n                j = k;\\n            else\\n                i = k + 1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun repairCars(A: IntArray, T: Int): Long {\\n        var ok = { time: Long -> T <= A.map{ Math.sqrt(time.toDouble() / it).toLong() }.sum() }\\n        var (i, j) = Pair(1L, A.max()!!.toLong() * T.toLong() * T.toLong())\\n        while (i < j) {\\n            var k = (i + j) / 2\\n            if (ok(k))\\n                j = k\\n            else\\n                i = k + 1\\n        }\\n        return i\\n    }\\n}\\n```\n```\\nlet repairCars = (A, T) => {\\n    let ok = time => T <= _.sum(A.map(rank => Math.floor(Math.sqrt(time / rank))));\\n    let [i, j] = [1, Math.max(...A) * T * T];\\n    while (i < j) {\\n        let k = Math.floor((i + j) / 2);\\n        if (ok(k))\\n            j = k;\\n        else\\n            i = k + 1;\\n    }\\n    return i;\\n};\\n```\n```\\nclass Solution:\\n    def repairCars(self, A: List[int], T: int) -> int:\\n        ok = lambda time: T <= sum([floor(sqrt(time / rank)) for rank in A])\\n        i, j = 1, int(max(A) * T * T)\\n        while i < j:\\n            k = (i + j) // 2\\n            if ok(k):\\n                j = k\\n            else:\\n                i = k + 1\\n        return i\\n```\n```\\nimpl Solution {\\n    pub fn repair_cars(A: Vec<i32>, T: i32) -> i64 {\\n        let T = T as i64;\\n        let ok = (|time| T <= A.iter().map(|rank| (time as f64 / *rank as f64).sqrt() as i64).sum());\\n        let (mut i, mut j) = (1i64, *A.iter().max().unwrap() as i64 * T * T);\\n        while i < j {\\n            let k = (i + j) / 2i64;\\n            if ok(k) {\\n                j = k;\\n            } else {\\n                i = k + 1;\\n            }\\n        }\\n        i\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    LL repairCars(VI& A, int T) {\\n        auto ok = [&](auto time) { return T <= accumulate(A.begin(), A.end(), 0LL, [=](auto t, auto rank) { return t + sqrt(time / rank); }); };\\n        auto [i, j] = make_pair(1LL, *max_element(A.begin(), A.end()) * LL(T) * LL(T));\\n        while (i < j) {\\n            auto k = (i + j) / 2;\\n            if (ok(k))\\n                j = k;\\n            else\\n                i = k + 1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331980,
                "title": "c-binary-search",
                "content": "# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n       long long mid;\\n       long long low = 1; \\n       long long high = 1e14; \\n       while(low<high){\\n           mid = low + (high-low)/2;\\n           if(checkValid(ranks,cars,mid)){\\n               high = mid;\\n           }else low = mid+1; \\n       }\\n\\n       return low;\\n    }\\n\\n    bool checkValid(vector<int>& ranks,int cars,long long mid){\\n        long long car = 0;\\n        for(auto& val:ranks){\\n            long long temp = mid/val;\\n            car+=sqrt(temp);\\n        }\\n        return car>=cars;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n       long long mid;\\n       long long low = 1; \\n       long long high = 1e14; \\n       while(low<high){\\n           mid = low + (high-low)/2;\\n           if(checkValid(ranks,cars,mid)){\\n               high = mid;\\n           }else low = mid+1; \\n       }\\n\\n       return low;\\n    }\\n\\n    bool checkValid(vector<int>& ranks,int cars,long long mid){\\n        long long car = 0;\\n        for(auto& val:ranks){\\n            long long temp = mid/val;\\n            car+=sqrt(temp);\\n        }\\n        return car>=cars;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331503,
                "title": "antarnab-coding-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long i = 0;\\n        long j = Long.MAX_VALUE;\\n        long ans = Long.MAX_VALUE;\\n        while(i <= j){\\n            long mid = (i+j) >> 1;\\n            if(check(ranks , cars , mid)) {\\n                ans = Math.min(ans , mid);\\n                j = mid - 1;\\n            }else{\\n                i = mid + 1;\\n            }\\n        }\\n        return ans == Long.MAX_VALUE ? 0 : ans;\\n    }\\n    private boolean check(int[] ranks , long totalCars , long time){\\n        long cur = 0;\\n        for(int i = 0 ; i < ranks.length ; i++){\\n            cur += Math.floor(Math.pow(time/(long)ranks[i] , 0.5));\\n        }\\n        return cur >= totalCars;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long i = 0;\\n        long j = Long.MAX_VALUE;\\n        long ans = Long.MAX_VALUE;\\n        while(i <= j){\\n            long mid = (i+j) >> 1;\\n            if(check(ranks , cars , mid)) {\\n                ans = Math.min(ans , mid);\\n                j = mid - 1;\\n            }else{\\n                i = mid + 1;\\n            }\\n        }\\n        return ans == Long.MAX_VALUE ? 0 : ans;\\n    }\\n    private boolean check(int[] ranks , long totalCars , long time){\\n        long cur = 0;\\n        for(int i = 0 ; i < ranks.length ; i++){\\n            cur += Math.floor(Math.pow(time/(long)ranks[i] , 0.5));\\n        }\\n        return cur >= totalCars;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330764,
                "title": "c-binary-search-on-answer-beginner-friendly",
                "content": "\\n# Complexity\\n- Time complexity: O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//Binary search on answer\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int high=100000000000000;\\n        long long int low=1;\\n        long long int ans=100000000000000;\\n        int n=ranks.size();\\n        while(high>=low){\\n            long int mid=low+(high-low)/2;\\n            long long int count=0;\\n            for(int i=0; i<n; i++){\\n                count+=sqrt(mid/ranks[i]);\\n            }\\n            if(count>=cars){\\n                ans=mid;\\n                high=mid-1;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Binary search on answer\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int high=100000000000000;\\n        long long int low=1;\\n        long long int ans=100000000000000;\\n        int n=ranks.size();\\n        while(high>=low){\\n            long int mid=low+(high-low)/2;\\n            long long int count=0;\\n            for(int i=0; i<n; i++){\\n                count+=sqrt(mid/ranks[i]);\\n            }\\n            if(count>=cars){\\n                ans=mid;\\n                high=mid-1;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328492,
                "title": "c-binary-search-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to find max min so we use binary search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& ranks, long long mid,int cars)\\n    {\\n        long long car=0;\\n        for(auto i:ranks)\\n        {\\n            //cout<<sqrt(mid/i);\\n            car+=sqrt(mid/i);\\n            if(car>=cars) return 1;\\n        }\\n        return 0;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long s=0;\\n        long long e=10e17;\\n        sort(ranks.rbegin(),ranks.rend());\\n        while(s<e)\\n        {\\n            long long mid=(s+e)/2;\\n            //cout<<mid<<endl;\\n            if(check(ranks,mid,cars))\\n            {\\n                e=mid;\\n            }\\n            else\\n                s=mid+1;\\n        }\\n        return e;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& ranks, long long mid,int cars)\\n    {\\n        long long car=0;\\n        for(auto i:ranks)\\n        {\\n            //cout<<sqrt(mid/i);\\n            car+=sqrt(mid/i);\\n            if(car>=cars) return 1;\\n        }\\n        return 0;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long s=0;\\n        long long e=10e17;\\n        sort(ranks.rbegin(),ranks.rend());\\n        while(s<e)\\n        {\\n            long long mid=(s+e)/2;\\n            //cout<<mid<<endl;\\n            if(check(ranks,mid,cars))\\n            {\\n                e=mid;\\n            }\\n            else\\n                s=mid+1;\\n        }\\n        return e;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3327968,
                "title": "ez-c-binary-search-solution-using-the-regular-template",
                "content": "Our search space will be from 1 to a very large number (Here I\\'ve taken LONG_MAX)\\nAs for the condition we are just checking whether \\'mid\\' will be appropriate to repair all cars at once.\\n```\\nclass Solution {\\npublic:\\n    long long calc(vector<int>&ranks,int cars,long long mid){\\n        long long sum=0LL;\\n        for(int i=0;i<ranks.size();i++){\\n            sum+=floor(sqrt(1.0*mid/ranks[i]));\\n        }\\n        return sum>=cars;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long a=1,b=LONG_MAX;\\n        while(a<b){\\n            long long mid=a-(a-b)/2;\\n            if(calc(ranks,cars,mid))\\n                b=mid;\\n            else\\n                a=mid+1;\\n        }\\n        return a;\\n    }\\n};\\n/*\\nr * n^2 = mid\\nn = (mid/r)^0.5\\n\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long calc(vector<int>&ranks,int cars,long long mid){\\n        long long sum=0LL;\\n        for(int i=0;i<ranks.size();i++){\\n            sum+=floor(sqrt(1.0*mid/ranks[i]));\\n        }\\n        return sum>=cars;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long a=1,b=LONG_MAX;\\n        while(a<b){\\n            long long mid=a-(a-b)/2;\\n            if(calc(ranks,cars,mid))\\n                b=mid;\\n            else\\n                a=mid+1;\\n        }\\n        return a;\\n    }\\n};\\n/*\\nr * n^2 = mid\\nn = (mid/r)^0.5\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326927,
                "title": "c-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long ans = LLONG_MAX;\\n        long long l = 0;\\n        long long r = (long long) cars * (long long) cars * 100;\\n        while(l <= r){\\n            long long m = (r - l) / 2 + l;\\n            long long c = cars;\\n            for(int i = 0; i < ranks.size() && c > 0; i++){\\n                long long rep = sqrt(m / (long long)ranks[i]);\\n                c -= rep;\\n            }\\n            if(c <= 0){\\n                ans = m;\\n                r = m - 1;\\n            }\\n            else l = m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long ans = LLONG_MAX;\\n        long long l = 0;\\n        long long r = (long long) cars * (long long) cars * 100;\\n        while(l <= r){\\n            long long m = (r - l) / 2 + l;\\n            long long c = cars;\\n            for(int i = 0; i < ranks.size() && c > 0; i++){\\n                long long rep = sqrt(m / (long long)ranks[i]);\\n                c -= rep;\\n            }\\n            if(c <= 0){\\n                ans = m;\\n                r = m - 1;\\n            }\\n            else l = m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326560,
                "title": "java-binary-search-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(Nlog(Long.MAX_VALUE))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long lo = 0, hi = Long.MAX_VALUE;\\n        while (lo < hi) {\\n            long mid = lo + (hi - lo) / 2;\\n            if (check(ranks, mid, cars)) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    public boolean check(int[] ranks, long mid, int cars) {\\n        int count = 0;\\n        for (int rank : ranks) {\\n            count += Math.sqrt(mid / rank);\\n        }\\n        return count >= cars;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long lo = 0, hi = Long.MAX_VALUE;\\n        while (lo < hi) {\\n            long mid = lo + (hi - lo) / 2;\\n            if (check(ranks, mid, cars)) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    public boolean check(int[] ranks, long mid, int cars) {\\n        int count = 0;\\n        for (int rank : ranks) {\\n            count += Math.sqrt(mid / rank);\\n        }\\n        return count >= cars;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326482,
                "title": "c-solution-using-binary-search",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N * log(maximum_rank * cars * cars))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isFeasable(long long time, vector<int> &ranks, long long cars){\\n        int n = ranks.size();\\n        for(int i=0;i<n;i++){\\n            long long cars_repaired = sqrt(time/ranks[i]);\\n            cars -= min(cars, cars_repaired);\\n        }\\n        return (cars == 0);\\n    }\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long lo = 1, hi = 1, ans = 1e10;\\n        for(int i=0;i<ranks.size();i++) hi = max(hi, ranks[i] * 1LL * cars * cars);\\n        while(lo <= hi){\\n            long long mid = lo + (hi - lo)/2;\\n            if(isFeasable(mid,ranks,cars)) {\\n                ans = mid;\\n                hi = mid-1;\\n            }else lo = mid+1;\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isFeasable(long long time, vector<int> &ranks, long long cars){\\n        int n = ranks.size();\\n        for(int i=0;i<n;i++){\\n            long long cars_repaired = sqrt(time/ranks[i]);\\n            cars -= min(cars, cars_repaired);\\n        }\\n        return (cars == 0);\\n    }\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long lo = 1, hi = 1, ans = 1e10;\\n        for(int i=0;i<ranks.size();i++) hi = max(hi, ranks[i] * 1LL * cars * cars);\\n        while(lo <= hi){\\n            long long mid = lo + (hi - lo)/2;\\n            if(isFeasable(mid,ranks,cars)) {\\n                ans = mid;\\n                hi = mid-1;\\n            }else lo = mid+1;\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325300,
                "title": "best-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// class Solution {\\n//     public long repairCars(int[] ranks, int cars) {\\n//         Arrays.sort(ranks);\\n//         int s = 1;\\n//         int e = cars;\\n//         int time = 0;\\n//         int min = Integer.MAX_VALUE;\\n//         while(s<=e){\\n//         int mid = (s+e)/2;\\n//         int remCars = cars - mid;\\n//         time = ranks[0]*(int)Math.pow(mid ,2);\\n//         // System.out.println(time);\\n//         for(int i = 1;i <ranks.length ; i++){\\n//             int cars_rep = time/ranks[i];\\n//             cars_rep = (int)Math.sqrt(cars_rep);  \\n//             remCars = remCars - cars_rep;\\n//         }\\n\\n//         if(remCars <= 0){\\n//             if(time<min){\\n//                 min = time;\\n//             }\\n//             e = mid-1;\\n//         }\\n//         else{\\n//             s = mid+1;\\n//         }\\n        \\n        \\n//         }\\n//         return min;\\n//     }\\n// }\\n\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        Arrays.sort(ranks);\\n        long s = 0;\\n        long e = ranks[ranks.length-1] * (long)Math.pow(cars ,2);\\n        long min = e;\\n        while(s<=e){\\n        long remCars = cars;\\n        long mid = (s+e)/2;\\n        for(int i = 0;i <ranks.length ; i++){\\n            long cars_rep = (long)mid/(long)ranks[i];\\n            cars_rep = (long)Math.sqrt(cars_rep);  \\n            remCars = remCars - cars_rep;\\n            if(remCars<=0){\\n                break;\\n            }\\n        }\\n        if(remCars <= 0){\\n            if(mid<min){\\n                min = mid;\\n            }\\n            e = mid-1;\\n        }\\n        else{\\n            s = mid+1;\\n        }\\n        \\n        \\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// class Solution {\\n//     public long repairCars(int[] ranks, int cars) {\\n//         Arrays.sort(ranks);\\n//         int s = 1;\\n//         int e = cars;\\n//         int time = 0;\\n//         int min = Integer.MAX_VALUE;\\n//         while(s<=e){\\n//         int mid = (s+e)/2;\\n//         int remCars = cars - mid;\\n//         time = ranks[0]*(int)Math.pow(mid ,2);\\n//         // System.out.println(time);\\n//         for(int i = 1;i <ranks.length ; i++){\\n//             int cars_rep = time/ranks[i];\\n//             cars_rep = (int)Math.sqrt(cars_rep);  \\n//             remCars = remCars - cars_rep;\\n//         }\\n\\n//         if(remCars <= 0){\\n//             if(time<min){\\n//                 min = time;\\n//             }\\n//             e = mid-1;\\n//         }\\n//         else{\\n//             s = mid+1;\\n//         }\\n        \\n        \\n//         }\\n//         return min;\\n//     }\\n// }\\n\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        Arrays.sort(ranks);\\n        long s = 0;\\n        long e = ranks[ranks.length-1] * (long)Math.pow(cars ,2);\\n        long min = e;\\n        while(s<=e){\\n        long remCars = cars;\\n        long mid = (s+e)/2;\\n        for(int i = 0;i <ranks.length ; i++){\\n            long cars_rep = (long)mid/(long)ranks[i];\\n            cars_rep = (long)Math.sqrt(cars_rep);  \\n            remCars = remCars - cars_rep;\\n            if(remCars<=0){\\n                break;\\n            }\\n        }\\n        if(remCars <= 0){\\n            if(mid<min){\\n                min = mid;\\n            }\\n            e = mid-1;\\n        }\\n        else{\\n            s = mid+1;\\n        }\\n        \\n        \\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324866,
                "title": "easy-to-get-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n    very similar to Koko Eating Bananas.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    binary search to find the min time the people can fix all the cars\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    (O)n logn\\n\\n    n comes from looping though the ranks\\n    log n times checked ( binary search part )\\n\\n    in total logn * n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def repairCars(self, ranks, cars):\\n        \"\"\"\\n        :type ranks: List[int]\\n        :type cars: int\\n        :rtype: int\\n        \"\"\"\\n\\n\\n\\n        # classic Koko Eating Bananas style question\\n\\n\\n\\n        def can_repair_all_cars_in_x_mins(mins):\\n\\n            total_cars_rep = 0\\n\\n            for rank in ranks:\\n                \\n                # max amount of cars this person can repair in the given time limit\\n                max_i_can_do = int(math.sqrt(mins/rank))\\n                \\n                total_cars_rep+= max_i_can_do\\n\\n\\n            return total_cars_rep>=cars\\n\\n\\n\\n        l = 0\\n\\n        # worst case is the worst person doing all the cars\\n        r = cars**2*max(ranks)\\n\\n        # binary search to find the min time\\n        while l < r:\\n\\n            time_lim = l+((r-l)//2)\\n\\n            # try to do it in less\\n            if can_repair_all_cars_in_x_mins(time_lim):\\n                r = time_lim\\n\\n            # need more time\\n            else:\\n                l = time_lim+1\\n\\n        return r\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def repairCars(self, ranks, cars):\\n        \"\"\"\\n        :type ranks: List[int]\\n        :type cars: int\\n        :rtype: int\\n        \"\"\"\\n\\n\\n\\n        # classic Koko Eating Bananas style question\\n\\n\\n\\n        def can_repair_all_cars_in_x_mins(mins):\\n\\n            total_cars_rep = 0\\n\\n            for rank in ranks:\\n                \\n                # max amount of cars this person can repair in the given time limit\\n                max_i_can_do = int(math.sqrt(mins/rank))\\n                \\n                total_cars_rep+= max_i_can_do\\n\\n\\n            return total_cars_rep>=cars\\n\\n\\n\\n        l = 0\\n\\n        # worst case is the worst person doing all the cars\\n        r = cars**2*max(ranks)\\n\\n        # binary search to find the min time\\n        while l < r:\\n\\n            time_lim = l+((r-l)//2)\\n\\n            # try to do it in less\\n            if can_repair_all_cars_in_x_mins(time_lim):\\n                r = time_lim\\n\\n            # need more time\\n            else:\\n                l = time_lim+1\\n\\n        return r\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324414,
                "title": "not-difficuilt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool aspire(vector<int>& ranks, int& cars, long long min_given){\\n        long long cars1 = 0;\\n        for(auto i : ranks){\\n            long long c2 = min_given/i;\\n            long long c = floor(sqrt(c2));\\n\\n            cars1+= c;\\n        }\\n        return (cars1 >= cars); \\n    }\\n    \\n    long long repairCars(vector<int>& ranks, int cars) {\\n    long long ans = 0, l=1, r=1e14;\\n        while(l < r){\\n            long long mid = (l+r)/2;\\n            if(aspire(ranks, cars, mid)){\\n                r = mid;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool aspire(vector<int>& ranks, int& cars, long long min_given){\\n        long long cars1 = 0;\\n        for(auto i : ranks){\\n            long long c2 = min_given/i;\\n            long long c = floor(sqrt(c2));\\n\\n            cars1+= c;\\n        }\\n        return (cars1 >= cars); \\n    }\\n    \\n    long long repairCars(vector<int>& ranks, int cars) {\\n    long long ans = 0, l=1, r=1e14;\\n        while(l < r){\\n            long long mid = (l+r)/2;\\n            if(aspire(ranks, cars, mid)){\\n                r = mid;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324278,
                "title": "simple-binary-search-solution",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll check(vector<int>& a,ll t,ll k){\\n        for(ll i=0;i<a.size();i++){\\n            ll x=sqrt(t/a[i]);\\n            k-=x;\\n            if(k<1)\\n                return 1;\\n        }\\n        return 0;\\n    }\\n    \\n    ll repairCars(vector<int>& a, int k) {\\n        ll l=0,ans=LONG_MAX,r=LONG_MAX>>1;\\n        while(l<=r){\\n            ll m=l+((r-l)>>1);\\n            if(check(a,m,k)){\\n                ans=m;\\n                r=m-1;\\n            }\\n            else\\n                l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll check(vector<int>& a,ll t,ll k){\\n        for(ll i=0;i<a.size();i++){\\n            ll x=sqrt(t/a[i]);\\n            k-=x;\\n            if(k<1)\\n                return 1;\\n        }\\n        return 0;\\n    }\\n    \\n    ll repairCars(vector<int>& a, int k) {\\n        ll l=0,ans=LONG_MAX,r=LONG_MAX>>1;\\n        while(l<=r){\\n            ll m=l+((r-l)>>1);\\n            if(check(a,m,k)){\\n                ans=m;\\n                r=m-1;\\n            }\\n            else\\n                l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323875,
                "title": "c-binary-search",
                "content": "# Approach\\nBinary search on the values of time under which the cars could be repaired.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& ranks, int cars, long long mid){\\n        long long total = 0;\\n        for(auto&i:ranks){\\n            total += sqrt(mid/i);\\n        }\\n        return total >= cars*1LL;\\n    }\\n    \\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long left = 1, right = 1e16, ans = LLONG_MAX;\\n        while(left <= right){\\n            long long mid = (left + right)/2;\\n            if(check(ranks, cars, mid)) right = mid - 1, ans = min(ans, mid);\\n            else left = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& ranks, int cars, long long mid){\\n        long long total = 0;\\n        for(auto&i:ranks){\\n            total += sqrt(mid/i);\\n        }\\n        return total >= cars*1LL;\\n    }\\n    \\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long left = 1, right = 1e16, ans = LLONG_MAX;\\n        while(left <= right){\\n            long long mid = (left + right)/2;\\n            if(check(ranks, cars, mid)) right = mid - 1, ans = min(ans, mid);\\n            else left = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323159,
                "title": "eassy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n    long left = 1, right = 1L * ranks[0] * cars * cars;\\n        while (left < right) {\\n            long mid = (left + right) / 2, cur = 0;\\n            for (int a : ranks)\\n                cur += (long)(Math.sqrt(1.0 * mid / a));\\n            if (cur < cars)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n    long left = 1, right = 1L * ranks[0] * cars * cars;\\n        while (left < right) {\\n            long mid = (left + right) / 2, cur = 0;\\n            for (int a : ranks)\\n                cur += (long)(Math.sqrt(1.0 * mid / a));\\n            if (cur < cars)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322975,
                "title": "java-binary-search-solution",
                "content": "# Intuition\\nUse binary search on the result\\n\\n# Approach\\nCalculate high = 1L*ranks[0]*cars*cars;\\nAssume we have mid minutes,\\nNow if the ith mechanic can repaire sqrt(mid / ranks[i])cars, then\\nwe calculate all the current cars(s) we can repair,\\nIf s < cars, not enough time, left = mid + 1\\nIf s >= cars, enough time, right = mid.\\n\\nFinally return the binary search result.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        \\n        long low = 1;\\n        long high = 1L*ranks[0]*cars*cars;\\n        while(low<high){\\n            long mid = low+(high-low)/2l;\\n            if(helper(ranks,mid,cars)){\\n                high = mid;\\n            }else\\n                low = mid+1;\\n        }\\n        return low;\\n\\n\\n    }\\n    boolean helper(int ranks[],long time , int cars){\\n         long s=0;\\n        for(int i=0;i<ranks.length;i++){\\n           s += (long)(Math.sqrt(time/ranks[i]));\\n        }\\n       return s>=cars;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        \\n        long low = 1;\\n        long high = 1L*ranks[0]*cars*cars;\\n        while(low<high){\\n            long mid = low+(high-low)/2l;\\n            if(helper(ranks,mid,cars)){\\n                high = mid;\\n            }else\\n                low = mid+1;\\n        }\\n        return low;\\n\\n\\n    }\\n    boolean helper(int ranks[],long time , int cars){\\n         long s=0;\\n        for(int i=0;i<ranks.length;i++){\\n           s += (long)(Math.sqrt(time/ranks[i]));\\n        }\\n       return s>=cars;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321191,
                "title": "binary-search-idea-decoded-completely-with-clean-commented-code",
                "content": "# Idea - BIN SEARCH\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. looking and figuring out bin search is the toughest thing here\\n2. we can see that ans lies in range of 1 to some A[i]*n *n\\n3. Actually to be more precise 1 to MinRank Guy * n *n \\n4. But as in Bin Search we cut the serch space into halfs (LOGN)\\n5. So why to spend a O(N) in finding min most. Just assign the 1st guy rank\\n6. INITIALIZATION OVER\\n7. Now we saw the formula tottime = Rank* n *n\\n8. So now we have a GUESSED Tottime and We know ranks of all\\n9. So just with that guessed tottime, calc the n (that is no of cars that i can repair)\\n10. Summation of it gives tot cars that we can repair with tot time as MID\\n11. Now GAME Starts\\n12. Increment Tottime if u need more Cars to be repaired\\n13. Orelse just try to reduce and see (to get min most time)\\n\\n# Code\\n##### Time: $$O(N* Log(A[0] *M *M))$$ here N is tot workers, M=tot cars\\n##### Space: $$O(1)$$\\n\\n```\\n//Binary Search based\\n\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long s = 1;\\n        long long e = (long long)ranks[0]*cars*cars; // all done by 0th / any random guy\\n        long long potAns = -1;\\n\\n        while(s<=e){\\n            long long mid = s + (e-s)/2;\\n            //mid is tot time taken and the ans\\n            //tot = A[i]*n*n, now find n (no of cars i th guy does)\\n            //n = SQRT (tot / A[i])\\n\\n            long long currCars = 0;\\n            for(int r : ranks){\\n                currCars += sqrt(mid / (1.0*r));\\n            }\\n            //now we know totcars that can be repaired in total time = mid\\n            \\n            if(currCars < cars){\\n                //increment total time to repair more cars (inc currCars)\\n                s = mid +1;\\n            }\\n            else{\\n                //we are able to repair cars nos of cars or even more\\n                potAns = mid;\\n                e = mid -1;\\n                //try to find a possible lesser time  there or not\\n            }\\n        }\\n        return potAns; //min time to repair all N Cars\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//Binary Search based\\n\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long s = 1;\\n        long long e = (long long)ranks[0]*cars*cars; // all done by 0th / any random guy\\n        long long potAns = -1;\\n\\n        while(s<=e){\\n            long long mid = s + (e-s)/2;\\n            //mid is tot time taken and the ans\\n            //tot = A[i]*n*n, now find n (no of cars i th guy does)\\n            //n = SQRT (tot / A[i])\\n\\n            long long currCars = 0;\\n            for(int r : ranks){\\n                currCars += sqrt(mid / (1.0*r));\\n            }\\n            //now we know totcars that can be repaired in total time = mid\\n            \\n            if(currCars < cars){\\n                //increment total time to repair more cars (inc currCars)\\n                s = mid +1;\\n            }\\n            else{\\n                //we are able to repair cars nos of cars or even more\\n                potAns = mid;\\n                e = mid -1;\\n                //try to find a possible lesser time  there or not\\n            }\\n        }\\n        return potAns; //min time to repair all N Cars\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321118,
                "title": "using-binary-search-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long low = 0, high = 1e14;\\n        while( low<high )\\n        {\\n            long long mid = (low+high)/2;\\n            long long count = 0;\\n            for(int i=0; i<ranks.size(); i++)\\n            {\\n                count += sqrt(mid / ranks[i]);\\n            }\\n            if(count >= cars)\\n            {\\n                high = mid;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long low = 0, high = 1e14;\\n        while( low<high )\\n        {\\n            long long mid = (low+high)/2;\\n            long long count = 0;\\n            for(int i=0; i<ranks.size(); i++)\\n            {\\n                count += sqrt(mid / ranks[i]);\\n            }\\n            if(count >= cars)\\n            {\\n                high = mid;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320789,
                "title": "simple-binary-search-python",
                "content": "**Time: O(n log(cars * min(ranks)))\\nSpace: O(1)**\\n```\\ndef repairCars(self, ranks: List[int], cars: int) -> int:\\n    L = 0; R = min(ranks)*(cars**2)\\n    while L < R:\\n        T = (L+R)//2\\n\\n        if sum(map(lambda r: floor(sqrt(T/r)), ranks)) < cars:\\n            L = T+1\\n        else:\\n            R = T\\n    \\n    return L\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\ndef repairCars(self, ranks: List[int], cars: int) -> int:\\n    L = 0; R = min(ranks)*(cars**2)\\n    while L < R:\\n        T = (L+R)//2\\n\\n        if sum(map(lambda r: floor(sqrt(T/r)), ranks)) < cars:\\n            L = T+1\\n        else:\\n            R = T\\n    \\n    return L\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3320486,
                "title": "c-binary-search",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\nBinary Search\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```\\nO(log(n))\\n```\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nO(1)\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool time_is_suff(vector<int>& ranks, int& cars,long long time){\\n        long long carsdone=0;\\n        for(auto r:ranks){\\n            long long a=(time/r);\\n            long long b=floor(sqrt(a));\\n            carsdone+=b;\\n        }\\n        return (carsdone>=cars);\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long l=0,r=1e14;\\n        while(l<r){\\n            long long mid=(l+r)/2;\\n            if(time_is_suff(ranks,cars,mid)){\\n                r=mid;\\n            }\\n            else{\\n                l=(mid+1);\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nBinary Search\\n```\n```\\nO(log(n))\\n```\n```\\nO(1)\\n```\n```\\nclass Solution {\\npublic:\\n    bool time_is_suff(vector<int>& ranks, int& cars,long long time){\\n        long long carsdone=0;\\n        for(auto r:ranks){\\n            long long a=(time/r);\\n            long long b=floor(sqrt(a));\\n            carsdone+=b;\\n        }\\n        return (carsdone>=cars);\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long l=0,r=1e14;\\n        while(l<r){\\n            long long mid=(l+r)/2;\\n            if(time_is_suff(ranks,cars,mid)){\\n                r=mid;\\n            }\\n            else{\\n                l=(mid+1);\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320407,
                "title": "c-concept-binary-search-on-answer-easy-to-understand",
                "content": "# Intuition\\nBinary search on answer. Why ? beacuse the question states to minimize the maximum time to repair n cars.\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    bool isValid(ll time, vector<int>& ranks, int cars) {\\n        for(int i=0;i<ranks.size();i++) {\\n            int n = sqrt(time/ranks[i]);\\n            cars-=n;\\n            if(cars <= 0) return true;\\n        }\\n        return false;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        ll maxTime = 0, n = ranks.size(), res = 0, N = (ll)cars*(ll)cars;\\n        for(int i=0;i<n;i++) {\\n            ll rank = (ll)ranks[i]*N;\\n            maxTime = max(maxTime, rank);\\n        }\\n            \\n        ll start = 1, end = maxTime;\\n        while(start <= end) {\\n            ll mid = start + (end - start)/2;\\n            if(isValid(mid, ranks, cars)) {\\n                res = mid;\\n                end = mid - 1;\\n            } else start = mid + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    bool isValid(ll time, vector<int>& ranks, int cars) {\\n        for(int i=0;i<ranks.size();i++) {\\n            int n = sqrt(time/ranks[i]);\\n            cars-=n;\\n            if(cars <= 0) return true;\\n        }\\n        return false;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        ll maxTime = 0, n = ranks.size(), res = 0, N = (ll)cars*(ll)cars;\\n        for(int i=0;i<n;i++) {\\n            ll rank = (ll)ranks[i]*N;\\n            maxTime = max(maxTime, rank);\\n        }\\n            \\n        ll start = 1, end = maxTime;\\n        while(start <= end) {\\n            ll mid = start + (end - start)/2;\\n            if(isValid(mid, ranks, cars)) {\\n                res = mid;\\n                end = mid - 1;\\n            } else start = mid + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320362,
                "title": "c-binary-search-easy-solution",
                "content": "# Please UpVote if it helps you\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&nums,int cars,long long mid){\\n        long long t = 0;\\n        for(int i=0;i<nums.size();++i){\\n            long long x = (sqrt((double)mid/nums[i]));\\n            t += x;\\n        }\\n        return (t>=cars);\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long lo = 1,hi = 1e15;\\n        while(lo<hi){\\n            long long mid = (lo+hi)/2;\\n            if(check(ranks,cars,mid)){\\n                hi = mid;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n        if(check(ranks,cars,lo))return lo;\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&nums,int cars,long long mid){\\n        long long t = 0;\\n        for(int i=0;i<nums.size();++i){\\n            long long x = (sqrt((double)mid/nums[i]));\\n            t += x;\\n        }\\n        return (t>=cars);\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long lo = 1,hi = 1e15;\\n        while(lo<hi){\\n            long long mid = (lo+hi)/2;\\n            if(check(ranks,cars,mid)){\\n                hi = mid;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n        if(check(ranks,cars,lo))return lo;\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320325,
                "title": "c-binary-search-soln",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n*log(m))$$\\n\\nHere n is the size of the ranks array and m is the maximum time possible to repair the cars. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    bool isPossible(ll mid, vector<int>&ranks, int cars){\\n        ll count = 0;\\n        for(int i=0;i<ranks.size();i++){\\n            ll val = mid/(ll)ranks[i];\\n            count+=sqrt(val);\\n        }\\n        \\n        if(count >= cars)\\n            return true;\\n        return false;\\n    }\\n    \\n    long long repairCars(vector<int>& ranks, int cars) {\\n        int n = ranks.size();\\n        sort(ranks.begin(), ranks.end());\\n        ll low = 0, high = (ll)((ll)ranks[n-1]*(ll)cars*(ll)cars);\\n        \\n        ll res = high;\\n        \\n        while(low<=high){\\n            ll mid = low + (high-low)/2;\\n            if(isPossible(mid, ranks, cars)){\\n                res = min(res, mid);\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    bool isPossible(ll mid, vector<int>&ranks, int cars){\\n        ll count = 0;\\n        for(int i=0;i<ranks.size();i++){\\n            ll val = mid/(ll)ranks[i];\\n            count+=sqrt(val);\\n        }\\n        \\n        if(count >= cars)\\n            return true;\\n        return false;\\n    }\\n    \\n    long long repairCars(vector<int>& ranks, int cars) {\\n        int n = ranks.size();\\n        sort(ranks.begin(), ranks.end());\\n        ll low = 0, high = (ll)((ll)ranks[n-1]*(ll)cars*(ll)cars);\\n        \\n        ll res = high;\\n        \\n        while(low<=high){\\n            ll mid = low + (high-low)/2;\\n            if(isPossible(mid, ranks, cars)){\\n                res = min(res, mid);\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320205,
                "title": "python-binary-search",
                "content": "You can refer to LC\\'s tutorial of Binary Search for more information.\\nTemplate I/II/III really helps a lot.\\n\\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        def helper(time):\\n            ans = 0                     # how manys cars can be repaired within given time\\n            for rank in ranks:\\n                ans += math.floor(math.sqrt(time / rank))\\n                if ans >= cars:\\n                    return True\\n            return False\\n        \\n        l, r = min(ranks), max(ranks) * cars * cars\\n        while l < r:\\n            m = (l + r) // 2\\n            if helper(m): r = m\\n            else: l = m + 1\\n        return l\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        def helper(time):\\n            ans = 0                     # how manys cars can be repaired within given time\\n            for rank in ranks:\\n                ans += math.floor(math.sqrt(time / rank))\\n                if ans >= cars:\\n                    return True\\n            return False\\n        \\n        l, r = min(ranks), max(ranks) * cars * cars\\n        while l < r:\\n            m = (l + r) // 2\\n            if helper(m): r = m\\n            else: l = m + 1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320164,
                "title": "binary-search-fully-explained-each-line-of-code",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(ranks[0]*cars*cars))$$  where n = ranks.size()\\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n    //low contains minimum possible minutes whereas high contains maximum possible minutes\\n    long long low = 1, high = 1L*ranks[0]*cars*cars;\\n    long long mid;\\n\\n    while(low < high)\\n    {\\n        mid = low + (high-low)/2;  \\n        //now, check whether we can repair all cars in \\'mid\\' minutes or not\\n        long long canRepairCars = 0;\\n        for(auto Ri : ranks)\\n        {\\n//if a mechanic with rank Ri can repair \\'n\\' cars in r*n*n minutes\\n//let the total minutes be mid\\n//then, ->   mid = Ri*n*n\\n//      ->   n*n = mid/Ri\\n//      ->   n = sqrt(mid/Ri)\\n//      ->   n = (int)sqrt(mid/Ri)    since, n(no. of cars) should always be an integer\\n           canRepairCars += (int)sqrt(mid/Ri);\\n        }\\n//if you can repair all cars in \\'mid\\' minutes, check in lower range if it is possible\\n    if(canRepairCars >= cars) \\n      high = mid;\\n//otherwise, check in higher range\\n    else\\n      low = mid+1; \\n    }\\n    return low;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n    //low contains minimum possible minutes whereas high contains maximum possible minutes\\n    long long low = 1, high = 1L*ranks[0]*cars*cars;\\n    long long mid;\\n\\n    while(low < high)\\n    {\\n        mid = low + (high-low)/2;  \\n        //now, check whether we can repair all cars in \\'mid\\' minutes or not\\n        long long canRepairCars = 0;\\n        for(auto Ri : ranks)\\n        {\\n//if a mechanic with rank Ri can repair \\'n\\' cars in r*n*n minutes\\n//let the total minutes be mid\\n//then, ->   mid = Ri*n*n\\n//      ->   n*n = mid/Ri\\n//      ->   n = sqrt(mid/Ri)\\n//      ->   n = (int)sqrt(mid/Ri)    since, n(no. of cars) should always be an integer\\n           canRepairCars += (int)sqrt(mid/Ri);\\n        }\\n//if you can repair all cars in \\'mid\\' minutes, check in lower range if it is possible\\n    if(canRepairCars >= cars) \\n      high = mid;\\n//otherwise, check in higher range\\n    else\\n      low = mid+1; \\n    }\\n    return low;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319733,
                "title": "binary-search-linear-check-with-explanation",
                "content": "# Inituition\\nFor a predefined fixed time $$minutes$$, we can check if all the cars can be repaired in $$O(n)$$ where $$n$$ is the size of ranks. Therefore, we can use binary search to find the minimum time.\\n\\n# Explanation\\nFor each $$rank$$ in $$ranks$$, we want to know **at most** how many cars $$n$$ can be repaired in given $$minutes$$:\\n\\n$$rank * n^2 <= minutes$$\\n$$n^2 <= minutes / rank$$\\n$$n <= sqrt(minutes / rank)$$\\n\\nTherfore, at most $$floor(sqrt(minutes / rank))$$ cars can be repaired.\\n\\n# Complexity\\n- Time complexity: $$O(nlog(LLONG\\\\_MAX))$$ where $$n$$ is the size of ranks\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long l = 0, r = LLONG_MAX;\\n\\n        while (l < r) {\\n            long long m = l + (r - l) / 2;\\n            if (check(m, ranks, cars))\\n                r = m;\\n            else\\n                l = m + 1;\\n        }\\n\\n        return l;\\n    }\\nprivate:\\n    bool check(long long minutes, vector<int>& ranks, long long cars) {\\n        for (int rank : ranks) {\\n            long long n = sqrt(static_cast<double>(minutes) / static_cast<double>(rank));\\n            cars -= n;\\n            if (cars <= 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long l = 0, r = LLONG_MAX;\\n\\n        while (l < r) {\\n            long long m = l + (r - l) / 2;\\n            if (check(m, ranks, cars))\\n                r = m;\\n            else\\n                l = m + 1;\\n        }\\n\\n        return l;\\n    }\\nprivate:\\n    bool check(long long minutes, vector<int>& ranks, long long cars) {\\n        for (int rank : ranks) {\\n            long long n = sqrt(static_cast<double>(minutes) / static_cast<double>(rank));\\n            cars -= n;\\n            if (cars <= 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319296,
                "title": "binary-search-o-1-space-100-beat-solution-c",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long ans=1e18;\\n        long long l=1,r=1e14;\\n        while(l<=r){\\n            long long mid=(l+r)/2;\\n            long long d=cars,curr=mid;\\n            bool ok=0;\\n            for(int i=0; i<ranks.size(); i++){\\n                long long x = curr/ranks[i];\\n                x=sqrt(x);\\n                if(x>d){\\n                    ok=1;\\n                    break;\\n                }\\n                else{\\n                    d-=x;\\n                }\\n            }\\n            if(ok||d<=0){\\n                ans=min(ans,mid);\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long ans=1e18;\\n        long long l=1,r=1e14;\\n        while(l<=r){\\n            long long mid=(l+r)/2;\\n            long long d=cars,curr=mid;\\n            bool ok=0;\\n            for(int i=0; i<ranks.size(); i++){\\n                long long x = curr/ranks[i];\\n                x=sqrt(x);\\n                if(x>d){\\n                    ok=1;\\n                    break;\\n                }\\n                else{\\n                    d-=x;\\n                }\\n            }\\n            if(ok||d<=0){\\n                ans=min(ans,mid);\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319201,
                "title": "easy-to-uderstand-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>&ranks,long long int mid,int cars){\\n        int cnt=0;\\n        int n=ranks.size();\\n        for(int i=0;i<n;i++){\\n            if(sqrt(mid/ranks[i])>=cars){return true;}\\n            else{\\n                cars-=(long long)sqrt(mid/ranks[i]);\\n                if(cars<=0){break;}\\n            }\\n        }\\n        if(cars<=0){return true;}\\n        return false;\\n    \\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int lo=0,hi=1e18+3;long long int ans=1e18;\\n        sort(ranks.begin(),ranks.end());\\n        while(lo<=hi){\\n            long long int mid=lo+(hi-lo)/2;\\n            if(helper(ranks,mid,cars)){ans=mid;hi=mid-1;}\\n            else{lo=mid+1;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>&ranks,long long int mid,int cars){\\n        int cnt=0;\\n        int n=ranks.size();\\n        for(int i=0;i<n;i++){\\n            if(sqrt(mid/ranks[i])>=cars){return true;}\\n            else{\\n                cars-=(long long)sqrt(mid/ranks[i]);\\n                if(cars<=0){break;}\\n            }\\n        }\\n        if(cars<=0){return true;}\\n        return false;\\n    \\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int lo=0,hi=1e18+3;long long int ans=1e18;\\n        sort(ranks.begin(),ranks.end());\\n        while(lo<=hi){\\n            long long int mid=lo+(hi-lo)/2;\\n            if(helper(ranks,mid,cars)){ans=mid;hi=mid-1;}\\n            else{lo=mid+1;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319193,
                "title": "binary-search-solution-100-ac-c-simple-and-easy-to-understand-solution",
                "content": "# Intuition\\nBinary search spotted!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif given for a pre defined time can you tell will you be able to complete the task if yes then just do a quick binary search on answer from 1 to 1e14/1e15\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlog(1e14));\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int ans = 0;\\n        long long int s = 0;\\n        long long int e = 1e14;\\n        while(s < e)\\n        {\\n            long long  car = cars;\\n            long long int mid = s + (e-s)/2;\\n            for(int i =0; i < ranks.size(); i++) car -= (int)(sqrt(mid/ranks[i]));\\n            if(car > 0) s = mid + 1;\\n            else e = mid;\\n        }\\n        return s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int ans = 0;\\n        long long int s = 0;\\n        long long int e = 1e14;\\n        while(s < e)\\n        {\\n            long long  car = cars;\\n            long long int mid = s + (e-s)/2;\\n            for(int i =0; i < ranks.size(); i++) car -= (int)(sqrt(mid/ranks[i]));\\n            if(car > 0) s = mid + 1;\\n            else e = mid;\\n        }\\n        return s;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318720,
                "title": "easy-c-binary-search-tc-o-n-log-n",
                "content": "\\n\\n# Complexity\\n- Time complexity: O (N log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(long long mid, vector<int> & ranks, int c){\\n            long long count=0;\\n            for(auto x : ranks){\\n                int temp = sqrt(mid/x);\\n                count+=temp;\\n                if(count>=c) return true;\\n            }\\n            return false;\\n    }\\n\\n    long long repairCars(vector<int>& ranks, int c) {\\n        long long start=1,end=0,ans=0;\\n        for(auto x: ranks) {\\n            if(end<x) end=x;\\n        }\\n        end=end*c*c;\\n        while(start<=end){\\n            long long mid = start +(end-start)/2;\\n            if(isvalid(mid, ranks, c)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else start=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(long long mid, vector<int> & ranks, int c){\\n            long long count=0;\\n            for(auto x : ranks){\\n                int temp = sqrt(mid/x);\\n                count+=temp;\\n                if(count>=c) return true;\\n            }\\n            return false;\\n    }\\n\\n    long long repairCars(vector<int>& ranks, int c) {\\n        long long start=1,end=0,ans=0;\\n        for(auto x: ranks) {\\n            if(end<x) end=x;\\n        }\\n        end=end*c*c;\\n        while(start<=end){\\n            long long mid = start +(end-start)/2;\\n            if(isvalid(mid, ranks, c)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else start=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318678,
                "title": "easy-c-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long int number_of_cars_reaairs_in_mid_time(vector<int>&v,long long int mid){\\n          long long int cnt=0;\\n          for(int i=0;i<v.size();i++){\\n              cnt+=sqrt((mid/v[i]));\\n          }\\n          return cnt;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int ans=0;\\n        long long int mx=*max(ranks.begin(),ranks.end());\\n        // long long int temp=(long long)cars*(long long)cars;\\n        long long int low=1,high=1e18;\\n\\n        while(low<=high){\\n            long long int mid=(low+high)/2;\\n             long long int n=number_of_cars_reaairs_in_mid_time(ranks,mid);\\n            if(n>=cars){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int number_of_cars_reaairs_in_mid_time(vector<int>&v,long long int mid){\\n          long long int cnt=0;\\n          for(int i=0;i<v.size();i++){\\n              cnt+=sqrt((mid/v[i]));\\n          }\\n          return cnt;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int ans=0;\\n        long long int mx=*max(ranks.begin(),ranks.end());\\n        // long long int temp=(long long)cars*(long long)cars;\\n        long long int low=1,high=1e18;\\n\\n        while(low<=high){\\n            long long int mid=(low+high)/2;\\n             long long int n=number_of_cars_reaairs_in_mid_time(ranks,mid);\\n            if(n>=cars){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318560,
                "title": "c-golang-binary-search",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    bool check(vector<int>& ranks, long long cars, long long mid) {\\n        for(int rank: ranks) {\\n            cars -= floor(sqrt(mid * 1.0 / rank));\\n        }\\n        return cars <= 0;\\n    }\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long low = 1, high = 1e14;\\n        long long ans = high;\\n        while(low <= high) {\\n            long long mid = low + (high - low) / 2;\\n            if(check(ranks, cars, mid)) {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc check(ranks []int, cars, mid int64) bool {\\n    for _, rank := range ranks {\\n        cars -= int64(math.Floor(math.Sqrt(float64(mid) / float64(rank))))\\n    }\\n    return cars <= 0\\n}\\n\\nfunc repairCars(ranks []int, cars int) int64 {\\n    var low, high int64 = 1, 1e14\\n    var ans int64 = high\\n    for low <= high {\\n        var mid int64 = low + (high - low) / 2\\n        if check(ranks, int64(cars), mid) {\\n            if mid < ans {ans = mid}\\n            high = mid - 1\\n        } else {\\n            low = mid + 1\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Binary Search"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    bool check(vector<int>& ranks, long long cars, long long mid) {\\n        for(int rank: ranks) {\\n            cars -= floor(sqrt(mid * 1.0 / rank));\\n        }\\n        return cars <= 0;\\n    }\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long low = 1, high = 1e14;\\n        long long ans = high;\\n        while(low <= high) {\\n            long long mid = low + (high - low) / 2;\\n            if(check(ranks, cars, mid)) {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc check(ranks []int, cars, mid int64) bool {\\n    for _, rank := range ranks {\\n        cars -= int64(math.Floor(math.Sqrt(float64(mid) / float64(rank))))\\n    }\\n    return cars <= 0\\n}\\n\\nfunc repairCars(ranks []int, cars int) int64 {\\n    var low, high int64 = 1, 1e14\\n    var ans int64 = high\\n    for low <= high {\\n        var mid int64 = low + (high - low) / 2\\n        if check(ranks, int64(cars), mid) {\\n            if mid < ans {ans = mid}\\n            high = mid - 1\\n        } else {\\n            low = mid + 1\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318425,
                "title": "rank-groups-assign-a-car-to-the-rank-group-with-minimal-cost",
                "content": "# Intuition\\nHave a ```rank group``` with mechanics in the same group and assign each car to the minimal cost in the rank group.\\n\\n# Complexity\\n- Time complexity: O(score * unique ranks) - Bit costly :(\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    class RankGroup(val rank: Int, var count: Int = 0) {\\n        private val assignment = mutableListOf<Int>()\\n        private var lastAssignment = -1\\n        private var time = 0L\\n        \\n        fun initalizeGroupAssignments() {\\n            repeat(count) {\\n                assignment.add(0)\\n            }\\n            lastAssignment = -1\\n            time = 0L\\n        }\\n        \\n        private fun getNextAssignmentIndex(): Int {\\n            if(lastAssignment + 1 >= count) {\\n                return 0\\n            }\\n            return lastAssignment + 1\\n        }\\n        \\n        fun getDurationIfAssigned(): Long {\\n            var carsAlready = assignment[getNextAssignmentIndex()]\\n            return rank.toLong() * (carsAlready+1).toLong() * (carsAlready+1).toLong()\\n        }\\n        \\n        fun assignCar() {\\n            val carsAlready = assignment[getNextAssignmentIndex()]\\n            assignment[getNextAssignmentIndex()]++\\n            lastAssignment = getNextAssignmentIndex()\\n        }\\n\\n        fun getTime(): Long {\\n            time = 0L\\n            for(assign in assignment) {\\n                val current = rank.toLong() * assign.toLong() * assign.toLong()\\n                if(current > time) {\\n                    time = current\\n                }\\n            }\\n            return time\\n        }\\n\\n        override fun toString(): String {\\n            return \"[rank = $rank, count = $count, [[assignments=${assignment.joinToString(\", \")}]] time = $time ls = $lastAssignment]\"\\n        }\\n    }\\n    \\n    fun repairCars(ranks: IntArray, cars: Int): Long {\\n        ranks.sort()\\n        val rankGroups = mutableListOf<RankGroup>()\\n        for(rank in ranks) {\\n            if(rankGroups.isEmpty()) {\\n                rankGroups.add(RankGroup(rank, 1))\\n            } else {\\n                if(rank == rankGroups.last()!!.rank) {\\n                    rankGroups.last().count++\\n                } else {\\n                    rankGroups.add(RankGroup(rank, 1))\\n                }\\n            }\\n        }\\n        rankGroups.forEach {\\n            it.initalizeGroupAssignments()\\n        }\\n        var rem = 0\\n        while(rem < cars) {\\n            var assigned = false\\n            var minCost = Long.MAX_VALUE\\n            var minCostIndex= -1\\n            for(i in 0 until rankGroups.size) {\\n                val cost = rankGroups[i].getDurationIfAssigned()\\n                if(cost < minCost) {\\n                    minCost = cost\\n                    minCostIndex = i\\n                }\\n            }\\n            if(minCostIndex != -1) {\\n                rankGroups[minCostIndex].assignCar()\\n                assigned = true\\n            }\\n            if(!assigned) {\\n                throw RuntimeException(\"car is not assigned in a rank group iteration\")\\n            }\\n            rem++\\n        }\\n        return rankGroups.map { it.getTime() }.max() ?: 0L\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```rank group```\n```\\nclass Solution {\\n    class RankGroup(val rank: Int, var count: Int = 0) {\\n        private val assignment = mutableListOf<Int>()\\n        private var lastAssignment = -1\\n        private var time = 0L\\n        \\n        fun initalizeGroupAssignments() {\\n            repeat(count) {\\n                assignment.add(0)\\n            }\\n            lastAssignment = -1\\n            time = 0L\\n        }\\n        \\n        private fun getNextAssignmentIndex(): Int {\\n            if(lastAssignment + 1 >= count) {\\n                return 0\\n            }\\n            return lastAssignment + 1\\n        }\\n        \\n        fun getDurationIfAssigned(): Long {\\n            var carsAlready = assignment[getNextAssignmentIndex()]\\n            return rank.toLong() * (carsAlready+1).toLong() * (carsAlready+1).toLong()\\n        }\\n        \\n        fun assignCar() {\\n            val carsAlready = assignment[getNextAssignmentIndex()]\\n            assignment[getNextAssignmentIndex()]++\\n            lastAssignment = getNextAssignmentIndex()\\n        }\\n\\n        fun getTime(): Long {\\n            time = 0L\\n            for(assign in assignment) {\\n                val current = rank.toLong() * assign.toLong() * assign.toLong()\\n                if(current > time) {\\n                    time = current\\n                }\\n            }\\n            return time\\n        }\\n\\n        override fun toString(): String {\\n            return \"[rank = $rank, count = $count, [[assignments=${assignment.joinToString(\", \")}]] time = $time ls = $lastAssignment]\"\\n        }\\n    }\\n    \\n    fun repairCars(ranks: IntArray, cars: Int): Long {\\n        ranks.sort()\\n        val rankGroups = mutableListOf<RankGroup>()\\n        for(rank in ranks) {\\n            if(rankGroups.isEmpty()) {\\n                rankGroups.add(RankGroup(rank, 1))\\n            } else {\\n                if(rank == rankGroups.last()!!.rank) {\\n                    rankGroups.last().count++\\n                } else {\\n                    rankGroups.add(RankGroup(rank, 1))\\n                }\\n            }\\n        }\\n        rankGroups.forEach {\\n            it.initalizeGroupAssignments()\\n        }\\n        var rem = 0\\n        while(rem < cars) {\\n            var assigned = false\\n            var minCost = Long.MAX_VALUE\\n            var minCostIndex= -1\\n            for(i in 0 until rankGroups.size) {\\n                val cost = rankGroups[i].getDurationIfAssigned()\\n                if(cost < minCost) {\\n                    minCost = cost\\n                    minCostIndex = i\\n                }\\n            }\\n            if(minCostIndex != -1) {\\n                rankGroups[minCostIndex].assignCar()\\n                assigned = true\\n            }\\n            if(!assigned) {\\n                throw RuntimeException(\"car is not assigned in a rank group iteration\")\\n            }\\n            rem++\\n        }\\n        return rankGroups.map { it.getTime() }.max() ?: 0L\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318110,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool solve(vector<int>& ranks, int cars,long long time)\\n{\\n    int n=ranks.size();\\n    long long curr=0;\\n\\n    for(int i=0;i<n;i++)\\n    {\\n        curr+=floor(sqrt((time/ranks[i])));\\n    }\\n\\n    return curr>=cars;\\n}\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long low=0,high=1e14;\\n        long long ans;\\n        while(low<=high)\\n        {\\n            long long mid=(low+high)/2;\\n            if(solve(ranks,cars,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool solve(vector<int>& ranks, int cars,long long time)\\n{\\n    int n=ranks.size();\\n    long long curr=0;\\n\\n    for(int i=0;i<n;i++)\\n    {\\n        curr+=floor(sqrt((time/ranks[i])));\\n    }\\n\\n    return curr>=cars;\\n}\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long low=0,high=1e14;\\n        long long ans;\\n        while(low<=high)\\n        {\\n            long long mid=(low+high)/2;\\n            if(solve(ranks,cars,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317735,
                "title": "binary-search-standard-practice-python",
                "content": "```\\n\"\"\"\\nTreatment: Binary Search\\n\\nProcedure:\\n    - 1. define a boolean fn to produce order or motononicity: can_finish(t) return True if cars can be repaired in time t.\\n    - 2. find min t such that can_finish(t) == True\\n    \\nObs: \"A mechanic with a rank r can repair n cars in r * n ** 2 minutes\" indicates that the smaller the r value, the higher the mechanic\\'s efficiency. As such, we can sort the list \"ranks\" increasingly, to accecerate the boolen fn \"can_finish\".\\n\\nThen the rest is standard binary search paradigm.\\nSearch Code-Yao in Youtube for more practices of such kind of problems.\\n\"\"\"\\n\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        \\n        # step-0. prep\\n        ranks.sort()\\n        \\n        # step-1. boolean fn\\n        def can_finish(t):\\n            res = 0\\n            for r in ranks:\\n                res += int(math.sqrt(t // r))\\n                if res >= cars:\\n                    return True\\n            return False\\n        \\n        # 3. binary search: search range, thrinkage, and proper return\\n        low, high = 1, ranks[-1] * cars ** 2 # search range\\n        while low < high:\\n            mid = low + (high - low) // 2 # thrinkage\\n            if can_finish(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n        return high # as can_finish(high) is always True, we return high\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nTreatment: Binary Search\\n\\nProcedure:\\n    - 1. define a boolean fn to produce order or motononicity: can_finish(t) return True if cars can be repaired in time t.\\n    - 2. find min t such that can_finish(t) == True\\n    \\nObs: \"A mechanic with a rank r can repair n cars in r * n ** 2 minutes\" indicates that the smaller the r value, the higher the mechanic\\'s efficiency. As such, we can sort the list \"ranks\" increasingly, to accecerate the boolen fn \"can_finish\".\\n\\nThen the rest is standard binary search paradigm.\\nSearch Code-Yao in Youtube for more practices of such kind of problems.\\n\"\"\"\\n\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        \\n        # step-0. prep\\n        ranks.sort()\\n        \\n        # step-1. boolean fn\\n        def can_finish(t):\\n            res = 0\\n            for r in ranks:\\n                res += int(math.sqrt(t // r))\\n                if res >= cars:\\n                    return True\\n            return False\\n        \\n        # 3. binary search: search range, thrinkage, and proper return\\n        low, high = 1, ranks[-1] * cars ** 2 # search range\\n        while low < high:\\n            mid = low + (high - low) // 2 # thrinkage\\n            if can_finish(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n        return high # as can_finish(high) is always True, we return high\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317643,
                "title": "c-solution-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long low = 1, high = 1e14;\\n        int size = ranks.size();\\n        while(low < high){\\n            long long mid = low + (high - low) / 2, count = 0;\\n            for(int i = 0; i < size; ++i)\\n                count += sqrt(mid / ranks[i]);\\n            if(count >= cars) high = mid;\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long low = 1, high = 1e14;\\n        int size = ranks.size();\\n        while(low < high){\\n            long long mid = low + (high - low) / 2, count = 0;\\n            for(int i = 0; i < size; ++i)\\n                count += sqrt(mid / ranks[i]);\\n            if(count >= cars) high = mid;\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317507,
                "title": "python-binary-search",
                "content": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        lo, hi = 1, 10 ** 16\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            cnt = sum(int((mid / r) ** 0.5) for r in ranks)\\n            if cnt >= cars:\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        return lo\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        lo, hi = 1, 10 ** 16\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            cnt = sum(int((mid / r) ** 0.5) for r in ranks)\\n            if cnt >= cars:\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317376,
                "title": "easy-solution-in-c-binarysearch-on-answer",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool feasible(vector<int>& ranks, long minTime, int cars){\\n        long n=ranks.size(),count=0;\\n        for(int i=0;i<n;i++){\\n            count+=sqrt(minTime/ranks[i]);\\n        }\\n        return count>=cars;\\n    }\\n    \\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long ll=1,ul=1e14,mid=0,ans=0;\\n        while(ll<=ul){\\n            mid=(ll+ul)>>1;\\n            if(feasible(ranks,mid,cars)){\\n                ul=mid-1;\\n                ans=mid;\\n            }\\n            else\\n                ll=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool feasible(vector<int>& ranks, long minTime, int cars){\\n        long n=ranks.size(),count=0;\\n        for(int i=0;i<n;i++){\\n            count+=sqrt(minTime/ranks[i]);\\n        }\\n        return count>=cars;\\n    }\\n    \\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long ll=1,ul=1e14,mid=0,ans=0;\\n        while(ll<=ul){\\n            mid=(ll+ul)>>1;\\n            if(feasible(ranks,mid,cars)){\\n                ul=mid-1;\\n                ans=mid;\\n            }\\n            else\\n                ll=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317236,
                "title": "ranged-binary-search-problemwith-solution-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long left = 0, right = (long) (1e14);\\n        long mid;\\n        while (left <= right) {\\n            mid = (left + right) / 2;\\n            if (check(ranks, mid) >= cars) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    private static int check(int[] ranks, long mid) {\\n        int cars = 0;\\n        for (int i = 0; i < ranks.length; i++) {\\n            cars += Math.sqrt(mid / ranks[i]);\\n        }\\n        return cars;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long left = 0, right = (long) (1e14);\\n        long mid;\\n        while (left <= right) {\\n            mid = (left + right) / 2;\\n            if (check(ranks, mid) >= cars) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    private static int check(int[] ranks, long mid) {\\n        int cars = 0;\\n        for (int i = 0; i < ranks.length; i++) {\\n            cars += Math.sqrt(mid / ranks[i]);\\n        }\\n        return cars;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316610,
                "title": "java-easy-binary-search-solution",
                "content": "```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long i = 0;\\n        long j = Long.MAX_VALUE;\\n        long ans = Long.MAX_VALUE;\\n        while(i <= j){\\n            long mid = (i+j) >> 1;\\n            if(check(ranks , cars , mid)) {\\n                ans = Math.min(ans , mid);\\n                j = mid - 1;\\n            }else{\\n                i = mid + 1;\\n            }\\n        }\\n        return ans == Long.MAX_VALUE ? 0 : ans;\\n    }\\n    private boolean check(int[] ranks , long totalCars , long time){\\n        long cur = 0;\\n        for(int i = 0 ; i < ranks.length ; i++){\\n            cur += Math.floor(Math.pow(time/(long)ranks[i] , 0.5));\\n        }\\n        return cur >= totalCars;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n        long i = 0;\\n        long j = Long.MAX_VALUE;\\n        long ans = Long.MAX_VALUE;\\n        while(i <= j){\\n            long mid = (i+j) >> 1;\\n            if(check(ranks , cars , mid)) {\\n                ans = Math.min(ans , mid);\\n                j = mid - 1;\\n            }else{\\n                i = mid + 1;\\n            }\\n        }\\n        return ans == Long.MAX_VALUE ? 0 : ans;\\n    }\\n    private boolean check(int[] ranks , long totalCars , long time){\\n        long cur = 0;\\n        for(int i = 0 ; i < ranks.length ; i++){\\n            cur += Math.floor(Math.pow(time/(long)ranks[i] , 0.5));\\n        }\\n        return cur >= totalCars;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316591,
                "title": "100-beats-binary-search-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n*log(min(ranks)*cars*cars))\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        int n=ranks.size();\\n        long long mini=INT_MAX;\\n        for(int i=0;i<ranks.size();i++)\\n        mini=min(mini,1LL*ranks[i]);\\n        long long minTime=1,maxTime=(long long)cars*(long long)cars*mini;\\n        while(minTime<=maxTime)\\n        {\\n            long long mid=minTime+(maxTime-minTime)/2;\\n            if(possible(mid,ranks,cars))\\n            maxTime=mid-1;\\n            else\\n            minTime=mid+1;\\n        }\\n        return minTime;\\n        \\n    }\\n    bool possible(long long time,vector<int>& ranks,int cars)\\n    {\\n        int i=0;\\n        while(i<ranks.size()&&cars>0)\\n        {\\n            int n=sqrt(time/ranks[i]);\\n            cars-=n;\\n            i++;\\n        }\\n        if(cars>0)\\n        return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        int n=ranks.size();\\n        long long mini=INT_MAX;\\n        for(int i=0;i<ranks.size();i++)\\n        mini=min(mini,1LL*ranks[i]);\\n        long long minTime=1,maxTime=(long long)cars*(long long)cars*mini;\\n        while(minTime<=maxTime)\\n        {\\n            long long mid=minTime+(maxTime-minTime)/2;\\n            if(possible(mid,ranks,cars))\\n            maxTime=mid-1;\\n            else\\n            minTime=mid+1;\\n        }\\n        return minTime;\\n        \\n    }\\n    bool possible(long long time,vector<int>& ranks,int cars)\\n    {\\n        int i=0;\\n        while(i<ranks.size()&&cars>0)\\n        {\\n            int n=sqrt(time/ranks[i]);\\n            cars-=n;\\n            i++;\\n        }\\n        if(cars>0)\\n        return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316458,
                "title": "c-binary-search-on-answer",
                "content": "# Code\\n```\\n    bool isvalid(vector<int> &ranks, int n, long long int mid)\\n{\\n    long long int count = 0;\\n    for (int i = 0; i < ranks.size(); i++)\\n    {\\n\\n        count += (sqrt(mid / ranks[i]));\\n    }\\n    return count >= n;\\n}\\n\\nlong long repairCars(vector<int> &ranks, int n)\\n{\\n    long long int lb = 1;\\n    long long int ub = 1000000000000000;\\n    long long int ans = -1;\\n\\n    while (lb <= ub)\\n    {\\n        long long mid = lb + (ub - lb) / 2;\\n        if (isvalid(ranks, n, mid) == true)\\n        {\\n            ans = mid;\\n            ub = mid - 1;\\n        }\\n        else\\n        {\\n            lb = mid + 1;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    bool isvalid(vector<int> &ranks, int n, long long int mid)\\n{\\n    long long int count = 0;\\n    for (int i = 0; i < ranks.size(); i++)\\n    {\\n\\n        count += (sqrt(mid / ranks[i]));\\n    }\\n    return count >= n;\\n}\\n\\nlong long repairCars(vector<int> &ranks, int n)\\n{\\n    long long int lb = 1;\\n    long long int ub = 1000000000000000;\\n    long long int ans = -1;\\n\\n    while (lb <= ub)\\n    {\\n        long long mid = lb + (ub - lb) / 2;\\n        if (isvalid(ranks, n, mid) == true)\\n        {\\n            ans = mid;\\n            ub = mid - 1;\\n        }\\n        else\\n        {\\n            lb = mid + 1;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3316445,
                "title": "python3-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe minimum time is Binary Searchable.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        low, high = 0, 1e18\\n        res = float(\\'inf\\')\\n\\n        while low <= high:\\n            s = 0\\n            mid = (low + high) // 2\\n\\n            for rank in ranks:\\n                a = mid // rank\\n                s += (int)(math.sqrt(a))\\n            \\n\\n            if s >= cars:\\n                high = mid - 1\\n                res = min(res, mid)\\n            else:\\n                low = mid + 1\\n\\n        return (int)(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        low, high = 0, 1e18\\n        res = float(\\'inf\\')\\n\\n        while low <= high:\\n            s = 0\\n            mid = (low + high) // 2\\n\\n            for rank in ranks:\\n                a = mid // rank\\n                s += (int)(math.sqrt(a))\\n            \\n\\n            if s >= cars:\\n                high = mid - 1\\n                res = min(res, mid)\\n            else:\\n                low = mid + 1\\n\\n        return (int)(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316291,
                "title": "most-easy-solution-c-binary-search",
                "content": "//These are the basic question based on binary search:\\n//Mean this type of question generally ask on topic binary search:\\n//Give Time -> 10^5:  Here we use Binary Search:\\n//If question based on Dynamic programming this is category time is generallly around 1 \\u2264 N \\u2264 1000 :\\n# Code\\n```\\nclass Solution {\\npublic:\\n   long long find(vector<int> &ranks,long long time){\\n       long long sum = 0;\\n       for(auto &x : ranks){\\n           sum+=(long long)int(sqrt(1.0*time/x));\\n       }\\n       return sum;\\n   }\\n\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long  low = 0;\\n        long long maxx = *max_element(ranks.begin(),ranks.end());\\n        long long  high = (long long )maxx * (long long )cars * (long long )cars;\\n        while(low<high){\\n           long long  mid = low+(high-low)/2;\\n           if(find(ranks,mid)<cars){\\n              low=mid+1;\\n           }\\n           else{\\n               high = mid;\\n           }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   long long find(vector<int> &ranks,long long time){\\n       long long sum = 0;\\n       for(auto &x : ranks){\\n           sum+=(long long)int(sqrt(1.0*time/x));\\n       }\\n       return sum;\\n   }\\n\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long  low = 0;\\n        long long maxx = *max_element(ranks.begin(),ranks.end());\\n        long long  high = (long long )maxx * (long long )cars * (long long )cars;\\n        while(low<high){\\n           long long  mid = low+(high-low)/2;\\n           if(find(ranks,mid)<cars){\\n              low=mid+1;\\n           }\\n           else{\\n               high = mid;\\n           }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316277,
                "title": "c-binary-search",
                "content": "# Approach\\nSimply apply binary search on time required and check if number of cars repaired are greater than equal to required no. of repairs or not.\\n\\n# Complexity\\n- Time complexity: O(logn)\\n- Space complexity: O(1)\\n- \\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long ans;\\n        long long lb = 0;\\n        long long ub = ranks[0];\\n        \\n        for(auto x : ranks)\\n        ub = max((long long)x,ub);\\n        \\n        ub *= ((long long)cars * (long long)cars);\\n        \\n        ans = ub;\\n        \\n        while(lb <= ub)\\n        {\\n            long long mid = (lb + ub)/2;\\n            long long dc = 0;\\n            \\n            for(auto x : ranks)\\n            dc += (int)sqrt(mid/x);\\n            \\n            //cout<<mid<<\" \"<<dc<<\" \"<<cars<<\"\\\\n\";\\n            if(dc >= cars)\\n            {\\n                ans = min(mid,ans);\\n                ub = mid - 1;\\n            }\\n            \\n            else\\n                lb = mid + 1;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long ans;\\n        long long lb = 0;\\n        long long ub = ranks[0];\\n        \\n        for(auto x : ranks)\\n        ub = max((long long)x,ub);\\n        \\n        ub *= ((long long)cars * (long long)cars);\\n        \\n        ans = ub;\\n        \\n        while(lb <= ub)\\n        {\\n            long long mid = (lb + ub)/2;\\n            long long dc = 0;\\n            \\n            for(auto x : ranks)\\n            dc += (int)sqrt(mid/x);\\n            \\n            //cout<<mid<<\" \"<<dc<<\" \"<<cars<<\"\\\\n\";\\n            if(dc >= cars)\\n            {\\n                ans = min(mid,ans);\\n                ub = mid - 1;\\n            }\\n            \\n            else\\n                lb = mid + 1;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3316136,
                "title": "c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search: we can ever repair all the cars if we assign them to the first mechanic; we can never repair the cars in 0 time. We can easily check if we can repair all the cars in the given time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * log(ranks[0] * cars))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    private bool CanDo(int[] ranks, int cars, long result) {\\n        foreach (int rank in ranks) \\n            if ((cars -= (int) Math.Sqrt(result / rank)) <= 0)\\n                return true; \\n        \\n        return false;\\n    }\\n\\n    public long RepairCars(int[] ranks, int cars) {\\n        if (cars <= 0)\\n            return 0;\\n\\n        long ever = ((long) ranks[0]) * cars * cars;\\n        long never = 0;\\n\\n        while (ever - never > 1) {\\n            long middle = (ever + never) / 2;\\n \\n            if (CanDo(ranks, cars, middle))\\n                ever = middle;\\n            else\\n                never = middle;     \\n        }\\n        \\n        return ever;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private bool CanDo(int[] ranks, int cars, long result) {\\n        foreach (int rank in ranks) \\n            if ((cars -= (int) Math.Sqrt(result / rank)) <= 0)\\n                return true; \\n        \\n        return false;\\n    }\\n\\n    public long RepairCars(int[] ranks, int cars) {\\n        if (cars <= 0)\\n            return 0;\\n\\n        long ever = ((long) ranks[0]) * cars * cars;\\n        long never = 0;\\n\\n        while (ever - never > 1) {\\n            long middle = (ever + never) / 2;\\n \\n            if (CanDo(ranks, cars, middle))\\n                ever = middle;\\n            else\\n                never = middle;     \\n        }\\n        \\n        return ever;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316131,
                "title": "faster-than-100-00-easy-java-o-nlogn-solution-using-binary-search",
                "content": "//Binary Search on answers concept\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n       \\n        long start = 1;\\n        long end = (long) Math.pow(10,14); //max limit of time taken to repair by each rank = max(rank) * max(cars allotted)^2 = 10^2 * (10^6) ^2 = 10^14\\n        long ans = 0;\\n\\t\\t\\n\\t\\t int n = ranks.length; //writing this beforehand to make i<n loop run faster\\n        \\n        while(start <= end){\\n            \\n        long mid = start + (end - start) / 2;  //mid is time in minutes\\n        long sum = 0; \\n            \\n            \\n     for(int i = 0; i < n; i++){\\n           sum = sum + (long)Math.sqrt(mid/ranks[i]); // time taken (mid) = rank (ranks[i]) * n^2 (cars allotted)^2...so then n = squareroot(time taken/rank)) = squareroot(mid/rank[i))\\n       }\\n        \\n         if (sum >= cars){   \\n             ans = mid; //potential answer so keep storing it as we go ahead\\n             end = mid - 1;\\n            \\n         }  \\n        \\n        else{ //sum < cars\\n            start = mid + 1;\\n        }\\n              \\n        }\\n        \\n        return ans;\\n    }\\n    \\n}\\n\\nOther Approaches using O(NlogN) : https://github.com/vishalsingh2972/DSA-Practise-Tracker/blob/main/Searching%20Algorithms/Searching%20Practise/lcM2594.java",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public long repairCars(int[] ranks, int cars) {\\n       \\n        long start = 1;\\n        long end = (long) Math.pow(10,14); //max limit of time taken to repair by each rank = max(rank) * max(cars allotted)^2 = 10^2 * (10^6) ^2 = 10^14\\n        long ans = 0;\\n\\t\\t\\n\\t\\t int n = ranks.length; //writing this beforehand to make i<n loop run faster\\n        \\n        while(start <= end){\\n            \\n        long mid = start + (end - start) / 2;  //mid is time in minutes\\n        long sum = 0; \\n            \\n            \\n     for(int i = 0; i < n; i++){\\n           sum = sum + (long)Math.sqrt(mid/ranks[i]); // time taken (mid) = rank (ranks[i]) * n^2 (cars allotted)^2...so then n = squareroot(time taken/rank)) = squareroot(mid/rank[i))\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 3315783,
                "title": "binary-search-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long start=1;\\n        long long end=1e15;\\n        long long ans;\\n        while(start<=end){\\n            long long mid=start+(end-start)/2;\\n            long long sum=0;\\n            for(auto it:ranks){\\n                sum+=(long long)(sqrt((long long)mid/(long long)it));\\n            }\\n            if(sum>=cars){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long start=1;\\n        long long end=1e15;\\n        long long ans;\\n        while(start<=end){\\n            long long mid=start+(end-start)/2;\\n            long long sum=0;\\n            for(auto it:ranks){\\n                sum+=(long long)(sqrt((long long)mid/(long long)it));\\n            }\\n            if(sum>=cars){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315734,
                "title": "c-binary-search",
                "content": "```C []\\nstatic int max_int(const int * const nums, const int numsLen){\\n\\tint max = nums[0];\\n\\tfor (int i = 1; i < numsLen; i += 1){\\n\\t\\tif (nums[i] > max){\\n\\t\\t\\tmax = nums[i];\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n\\nstatic bool canRepairAllWithinTime(\\n\\tconst int * const ranks,\\n\\tconst int ranksLen,\\n\\tconst int car,\\n\\tconst int64_t time\\n){\\n\\tint restCar = car;\\n\\tfor (int i = 0; i < ranksLen; i += 1){\\n\\t\\trestCar -= (int)sqrt( (double)time / (double)ranks[i] );\\n\\t\\tif (restCar <= 0){\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n\\nint64_t repairCars(\\n\\tconst int * const ranks,\\n\\tconst int ranksLen,\\n\\tconst int car\\n){\\n\\tconst int carPerMechanic = car / ranksLen + ( (car % ranksLen > 0)? 1 : 0 );\\n\\tint64_t first = 0, nextOfLast =\\n\\t\\t(int64_t)max_int(ranks, ranksLen) *\\n\\t\\t(int64_t)carPerMechanic * (int64_t)carPerMechanic;\\n\\twhile (first < nextOfLast){\\n\\t\\tconst int64_t mid = first + (nextOfLast - first) / 2;\\n\\t\\tif ( canRepairAllWithinTime(ranks, ranksLen, car, mid) ){\\n\\t\\t\\tnextOfLast = mid;\\n\\t\\t}else {\\n\\t\\t\\tfirst = mid + 1;\\n\\t\\t}\\n\\t}\\n\\treturn nextOfLast;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\nstatic int max_int(const int * const nums, const int numsLen){\\n\\tint max = nums[0];\\n\\tfor (int i = 1; i < numsLen; i += 1){\\n\\t\\tif (nums[i] > max){\\n\\t\\t\\tmax = nums[i];\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n\\nstatic bool canRepairAllWithinTime(\\n\\tconst int * const ranks,\\n\\tconst int ranksLen,\\n\\tconst int car,\\n\\tconst int64_t time\\n){\\n\\tint restCar = car;\\n\\tfor (int i = 0; i < ranksLen; i += 1){\\n\\t\\trestCar -= (int)sqrt( (double)time / (double)ranks[i] );\\n\\t\\tif (restCar <= 0){\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n\\nint64_t repairCars(\\n\\tconst int * const ranks,\\n\\tconst int ranksLen,\\n\\tconst int car\\n){\\n\\tconst int carPerMechanic = car / ranksLen + ( (car % ranksLen > 0)? 1 : 0 );\\n\\tint64_t first = 0, nextOfLast =\\n\\t\\t(int64_t)max_int(ranks, ranksLen) *\\n\\t\\t(int64_t)carPerMechanic * (int64_t)carPerMechanic;\\n\\twhile (first < nextOfLast){\\n\\t\\tconst int64_t mid = first + (nextOfLast - first) / 2;\\n\\t\\tif ( canRepairAllWithinTime(ranks, ranksLen, car, mid) ){\\n\\t\\t\\tnextOfLast = mid;\\n\\t\\t}else {\\n\\t\\t\\tfirst = mid + 1;\\n\\t\\t}\\n\\t}\\n\\treturn nextOfLast;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3315671,
                "title": "easy-c-solution-using-binary-search-beats-100-in-time",
                "content": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int low = 1 ; \\n        long long int high = LLONG_MAX ;\\n        long long int ans = high ; \\n        \\n        // using binary search\\n        while (low <= high){\\n            \\n            long long mid = low + (high-low)/2 ;  //  the time taken\\n            \\n            long long int temp_car = 0 ;\\n            \\n            \\n            \\n            for (int i = 0 ; i < ranks.size() ; i++){\\n                \\n                temp_car +=  sqrt(mid/ranks[i]) ;   // number of cars repaired in mid seconds \\n                \\n                if (temp_car >= cars){break;}\\n            }\\n            // cout << high << \" \" << low << \" \" << mid << endl;\\n            if (temp_car >= cars){\\n                ans =mid;\\n                high = mid-1; \\n            }\\n            else {\\n                low = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int low = 1 ; \\n        long long int high = LLONG_MAX ;\\n        long long int ans = high ; \\n        \\n        // using binary search\\n        while (low <= high){\\n            \\n            long long mid = low + (high-low)/2 ;  //  the time taken\\n            \\n            long long int temp_car = 0 ;\\n            \\n            \\n            \\n            for (int i = 0 ; i < ranks.size() ; i++){\\n                \\n                temp_car +=  sqrt(mid/ranks[i]) ;   // number of cars repaired in mid seconds \\n                \\n                if (temp_car >= cars){break;}\\n            }\\n            // cout << high << \" \" << low << \" \" << mid << endl;\\n            if (temp_car >= cars){\\n                ans =mid;\\n                high = mid-1; \\n            }\\n            else {\\n                low = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3315601,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        // int i=1;\\n        long long y=ceil((double)cars/ranks.size());\\n        long long x=*(min_element(ranks.begin(),ranks.end()));\\n         long long z=*(max_element(ranks.begin(),ranks.end()));\\n        \\n        long long  i=x*y*y;\\n       \\n        long long n=z*y*y;\\n         cout<<n;\\n        while(i<=n){\\n            long long  mid=i+(n-i)/2;\\n            int c=find(ranks,mid);\\n            if(c>=cars)n=mid-1;\\n            else i=mid+1;\\n        }\\n        return i;\\n\\n    }\\n    int find(vector<int>nums,long long  time){\\n        int c=0;\\n        for(auto x:nums){\\n            c+=sqrt(time/x);\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        // int i=1;\\n        long long y=ceil((double)cars/ranks.size());\\n        long long x=*(min_element(ranks.begin(),ranks.end()));\\n         long long z=*(max_element(ranks.begin(),ranks.end()));\\n        \\n        long long  i=x*y*y;\\n       \\n        long long n=z*y*y;\\n         cout<<n;\\n        while(i<=n){\\n            long long  mid=i+(n-i)/2;\\n            int c=find(ranks,mid);\\n            if(c>=cars)n=mid-1;\\n            else i=mid+1;\\n        }\\n        return i;\\n\\n    }\\n    int find(vector<int>nums,long long  time){\\n        int c=0;\\n        for(auto x:nums){\\n            c+=sqrt(time/x);\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3315572,
                "title": "simple-solution-using-binary-search",
                "content": "# Intuition\\nCheck each time required to repair minimum n cars between 1 to min(rank)*cars^2 and return the minimum time between them.\\n\\n# Approach\\nUse Binary Search Algorithm..\\nwhere l = 1 and r = min(rank)*cars^2\\nm = l - (l - r)/2 [To avoid overflow]\\nand check total cars which will be repaired in this time as \\'r\\' rank will repair \\'sqrt(m/r)\\' cars in \\'m\\' times.\\nif total cars repaired < given cars update l = m + 1\\nelse update r = m\\nreturn r\\n\\n# Complexity\\n- Time complexity: O(n logn)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long r = INT_MAX;\\n        int n = ranks.size();\\n        for(int i = 0; i < n; i++)\\n            r = max(r, (long long)ranks[i] * cars*cars);\\n        \\n        long long l = 1,m = 0;\\n        while(l < r){\\n            long long sum = 0;\\n            m = l - (l - r)/2;\\n            for(int i = 0; i < n; i++){\\n                sum += sqrt(m/ranks[i]);\\n            }\\n            if(sum < cars)\\n                l = m+1;\\n            else\\n                r = m;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long r = INT_MAX;\\n        int n = ranks.size();\\n        for(int i = 0; i < n; i++)\\n            r = max(r, (long long)ranks[i] * cars*cars);\\n        \\n        long long l = 1,m = 0;\\n        while(l < r){\\n            long long sum = 0;\\n            m = l - (l - r)/2;\\n            for(int i = 0; i < n; i++){\\n                sum += sqrt(m/ranks[i]);\\n            }\\n            if(sum < cars)\\n                l = m+1;\\n            else\\n                r = m;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315561,
                "title": "simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(vector<int>&ranks,long long int &mintime, int &cars){\\n        long long int ans=0;\\n        for(auto r:ranks){\\n            long long int q=(mintime/r);\\n            long long int q1=floor(sqrt(q));\\n            ans+=q1;\\n        }\\n        return ans>=cars;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int s=1;\\n        long long int e=1e14;\\n        long long int ans=0;\\n        while(s<e){\\n            long long int mid=s+(e-s)/2;\\n            if(f(ranks,mid,cars)){\\n                ans=mid;\\n                e=mid;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<int>&ranks,long long int &mintime, int &cars){\\n        long long int ans=0;\\n        for(auto r:ranks){\\n            long long int q=(mintime/r);\\n            long long int q1=floor(sqrt(q));\\n            ans+=q1;\\n        }\\n        return ans>=cars;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int s=1;\\n        long long int e=1e14;\\n        long long int ans=0;\\n        while(s<e){\\n            long long int mid=s+(e-s)/2;\\n            if(f(ranks,mid,cars)){\\n                ans=mid;\\n                e=mid;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315507,
                "title": "simple-binary-search-on-answer-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& ranks, int cars,long long mid )\\n    {\\n        long long sum=0;\\n        for(int i=0;i<ranks.size();i++)\\n        {\\n           long long calc=sqrt(mid/ranks[i]);\\n            sum+=calc;\\n        }\\n        return sum>=cars;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) \\n    {\\n        using ll=long long;\\n        ll low=1;\\n        ll ans=0, high=1e14;\\n        while(low<=high)\\n        {\\n            ll mid=low+(high-low)/2;\\n            if(check(ranks,cars,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& ranks, int cars,long long mid )\\n    {\\n        long long sum=0;\\n        for(int i=0;i<ranks.size();i++)\\n        {\\n           long long calc=sqrt(mid/ranks[i]);\\n            sum+=calc;\\n        }\\n        return sum>=cars;\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) \\n    {\\n        using ll=long long;\\n        ll low=1;\\n        ll ans=0, high=1e14;\\n        while(low<=high)\\n        {\\n            ll mid=low+(high-low)/2;\\n            if(check(ranks,cars,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315342,
                "title": "intuitive-solution-with-binary-search",
                "content": "# Intuition\\nIt is easy to check for given time, can we take take desired number of cars. \\n\\ncars repaired by one =sqrt(mintime/ranks[i])\\nsummation of all these value will tell us how many cars we can repair in desired time.\\n\\n# Approach\\nFind the value of rank. If it do all the the work alone, then it will be upper bound of our time. Now apply binary search, if we are able to do work in given time store this time value in ans and update end to mid-1. If not able to do then shift start=mid+1.\\n\\n# Complexity\\n- Time complexity:O(nlog(10^14))\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    bool check(vector<int>& ranks, int cars,long long int mid){\\n   long long int count=0;\\n    for(int i=0;i<ranks.size();i++){\\n        count+=sqrt(mid/ranks[i]);\\n    }\\n    if(count>=cars)\\n    return true;\\n    return false;\\n    }\\n\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        int n=ranks.size();\\n        long long int ans;\\n         sort(ranks.begin(),ranks.end());\\n      long long int s=0;\\n    long long int e=ranks[0]*1.0*cars*cars;\\n    \\n      while(s<=e){\\n     long long int mid=(s+e)/2;\\n      if(check(ranks,cars,mid)){\\n          ans=mid;\\n          e=mid-1;\\n      }\\n      else{\\n          s=mid+1;\\n      }\\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    bool check(vector<int>& ranks, int cars,long long int mid){\\n   long long int count=0;\\n    for(int i=0;i<ranks.size();i++){\\n        count+=sqrt(mid/ranks[i]);\\n    }\\n    if(count>=cars)\\n    return true;\\n    return false;\\n    }\\n\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        int n=ranks.size();\\n        long long int ans;\\n         sort(ranks.begin(),ranks.end());\\n      long long int s=0;\\n    long long int e=ranks[0]*1.0*cars*cars;\\n    \\n      while(s<=e){\\n     long long int mid=(s+e)/2;\\n      if(check(ranks,cars,mid)){\\n          ans=mid;\\n          e=mid-1;\\n      }\\n      else{\\n          s=mid+1;\\n      }\\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315250,
                "title": "priority-queue",
                "content": "# Approach\\nUse priority queue with priority value equals to the time it will take for mechanic to complete its work if this mechanic will get to repair additional car.\\nRepeat number of cars step of the following algorithm - get element with lowest priority (time) - this mechanic will take this next car. Calculate time for this mechanic if it will take one more car and put element for such case back into queue.\\nMaintain the maximum time spend in a variable.\\n\\nn - number of cars\\nm - number of mechanics\\n\\n# Complexity\\n- Time complexity: $$O(n*logm)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long RepairCars(int[] ranks, int cars)\\n    {\\n        var pq = new PriorityQueue<(int, int), long>();\\n        for (int i = 0; i < ranks.Length; i++)\\n        {\\n            pq.Enqueue((ranks[i], 1), ranks[i]);\\n        }\\n\\n        long max = 0;\\n        while (cars > 0)\\n        {\\n            var tuple = pq.Dequeue();\\n            var time = (long)tuple.Item1 * tuple.Item2 * tuple.Item2;\\n            tuple.Item2 += 1;\\n            max = Math.Max(max, time);\\n            pq.Enqueue((tuple.Item1, tuple.Item2), (long)tuple.Item1 * tuple.Item2 * tuple.Item2);\\n            cars--;\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long RepairCars(int[] ranks, int cars)\\n    {\\n        var pq = new PriorityQueue<(int, int), long>();\\n        for (int i = 0; i < ranks.Length; i++)\\n        {\\n            pq.Enqueue((ranks[i], 1), ranks[i]);\\n        }\\n\\n        long max = 0;\\n        while (cars > 0)\\n        {\\n            var tuple = pq.Dequeue();\\n            var time = (long)tuple.Item1 * tuple.Item2 * tuple.Item2;\\n            tuple.Item2 += 1;\\n            max = Math.Max(max, time);\\n            pq.Enqueue((tuple.Item1, tuple.Item2), (long)tuple.Item1 * tuple.Item2 * tuple.Item2);\\n            cars--;\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315173,
                "title": "easy-binary-search-solution-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGive every mechanic X minutes and see how many cars can they repair, total cars repairable should be greater than cars. If X minutes work then X+1 also will which inspires for Binary Search solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(Nlog(max(ranks)*cars*cars))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        lo,hi = 1,max(ranks)*cars*cars\\n        ans = hi\\n        \\n        def check(time, ranks, cars):\\n            req=0\\n            for r in ranks :\\n                req+=int((time/r)**0.5)\\n            return req>=cars\\n        \\n        while lo <= hi :\\n            mid = (lo+hi)//2\\n            if check(mid, ranks, cars):\\n                ans = min(ans, mid)\\n                hi = mid-1\\n            else :\\n                lo = mid+1\\n\\n        return ans\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        lo,hi = 1,max(ranks)*cars*cars\\n        ans = hi\\n        \\n        def check(time, ranks, cars):\\n            req=0\\n            for r in ranks :\\n                req+=int((time/r)**0.5)\\n            return req>=cars\\n        \\n        while lo <= hi :\\n            mid = (lo+hi)//2\\n            if check(mid, ranks, cars):\\n                ans = min(ans, mid)\\n                hi = mid-1\\n            else :\\n                lo = mid+1\\n\\n        return ans\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315164,
                "title": "easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) \\n    {\\n        //Arrays.sort(ranks);\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        for(int x : ranks)\\n        {\\n        min = Math.min(min,x);\\n        max = Math.max(max,x);\\n        }\\n        long l = 0;\\n        long e = Long.MAX_VALUE;\\n        System.out.println(l+\" sdf \"+e);\\n        long mid = -1;\\n        long ans = 0;\\n        while(l<=e)\\n        {\\n            mid = (l+e)/2;\\n            System.out.println(l+\" sd \"+e);\\n            if(ispos(ranks,cars,mid))\\n            {\\n                e = mid -1 ;\\n                ans = mid;\\n            }\\n            else\\n            l = mid +1;\\n            System.out.println(l+\" \"+e+\" \"+mid);\\n        }\\n        return ans;\\n    }\\n\\n    public boolean ispos(int a[],int c,long m)\\n    {\\n        int cw = 0;\\n        for(int x : a)\\n        {\\n           cw += Math.sqrt(m/x);\\n\\n        }\\n        if(cw>=c)\\n        return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long repairCars(int[] ranks, int cars) \\n    {\\n        //Arrays.sort(ranks);\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        for(int x : ranks)\\n        {\\n        min = Math.min(min,x);\\n        max = Math.max(max,x);\\n        }\\n        long l = 0;\\n        long e = Long.MAX_VALUE;\\n        System.out.println(l+\" sdf \"+e);\\n        long mid = -1;\\n        long ans = 0;\\n        while(l<=e)\\n        {\\n            mid = (l+e)/2;\\n            System.out.println(l+\" sd \"+e);\\n            if(ispos(ranks,cars,mid))\\n            {\\n                e = mid -1 ;\\n                ans = mid;\\n            }\\n            else\\n            l = mid +1;\\n            System.out.println(l+\" \"+e+\" \"+mid);\\n        }\\n        return ans;\\n    }\\n\\n    public boolean ispos(int a[],int c,long m)\\n    {\\n        int cw = 0;\\n        for(int x : a)\\n        {\\n           cw += Math.sqrt(m/x);\\n\\n        }\\n        if(cw>=c)\\n        return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314875,
                "title": "c-binary-search-on-answers",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool helper(long long min_ans,int cars,vector<int>& ranks){\\n        long long cnt=0;\\n        int n=ranks.size();\\n        for(int i=0;i<n;i++){\\n            cnt+=(sqrt(min_ans/ranks[i]));\\n        }\\n        return (cnt>=cars);\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long ans=-1;\\n        int n=ranks.size();\\n        sort(ranks.begin(),ranks.end());\\n        long long s=0;\\n        long long e=(1LL)*ranks[n-1]*cars*cars;\\n\\n        while(s<=e){\\n            long long mid=s+(e-s)/2;\\n            if(helper(mid,cars,ranks)){\\n                e=mid-1;\\n                ans=mid;\\n            }\\n            else s=mid+1;\\n        }\\n\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(long long min_ans,int cars,vector<int>& ranks){\\n        long long cnt=0;\\n        int n=ranks.size();\\n        for(int i=0;i<n;i++){\\n            cnt+=(sqrt(min_ans/ranks[i]));\\n        }\\n        return (cnt>=cars);\\n    }\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long ans=-1;\\n        int n=ranks.size();\\n        sort(ranks.begin(),ranks.end());\\n        long long s=0;\\n        long long e=(1LL)*ranks[n-1]*cars*cars;\\n\\n        while(s<=e){\\n            long long mid=s+(e-s)/2;\\n            if(helper(mid,cars,ranks)){\\n                e=mid-1;\\n                ans=mid;\\n            }\\n            else s=mid+1;\\n        }\\n\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314742,
                "title": "binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe\\'ll select a value for time to see if all cars can be repaired within the selected time. If yes, we will check if we can do so in lesser amount of time. If no, we will increase the value of time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDecide on the best and worst case scenario. Our best case scenario would be every mechanic having a rank of 1. Our worst case scenario would be every mechanic having a rank of 100. \\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    long long int feasible(vector<int> &ranks, int cars, long long time)\\n    {\\n        long long c = 0;\\n        for (int i = 0; i < ranks.size(); ++i)\\n            c += floor(sqrt(1.0 * time / ranks[i]));\\n        return c;\\n    }\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) \\n    {\\n        int n = ranks.size(), x = (cars/n > 0) ? cars/n : 1;\\n        long long beg = 1 * pow(x, 2), end = 100 * pow(x, 2);\\n        while (beg < end)\\n        {\\n            long long mid = beg + (end - beg) / 2, c;\\n            c = feasible(ranks, cars, mid);\\n            if (c >= cars)\\n                end = mid;\\n            else\\n                beg = mid + 1;\\n        }\\n        return beg;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\n    long long int feasible(vector<int> &ranks, int cars, long long time)\\n    {\\n        long long c = 0;\\n        for (int i = 0; i < ranks.size(); ++i)\\n            c += floor(sqrt(1.0 * time / ranks[i]));\\n        return c;\\n    }\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) \\n    {\\n        int n = ranks.size(), x = (cars/n > 0) ? cars/n : 1;\\n        long long beg = 1 * pow(x, 2), end = 100 * pow(x, 2);\\n        while (beg < end)\\n        {\\n            long long mid = beg + (end - beg) / 2, c;\\n            c = feasible(ranks, cars, mid);\\n            if (c >= cars)\\n                end = mid;\\n            else\\n                beg = mid + 1;\\n        }\\n        return beg;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314705,
                "title": "python-binary-search",
                "content": "\\n# Code\\n```python\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        upper = max(ranks) * cars * cars\\n        lower = 1\\n\\n        # Get the number of cars that can be repaired within time t\\n        def getRepairs(ranks, t):\\n            res = 0\\n            for rank in ranks:\\n                res += int(sqrt(t / rank))\\n            return res\\n\\n        while lower < upper:\\n            mid = lower + (upper - lower) // 2\\n            repairs = getRepairs(ranks, mid)\\n            if repairs < cars:\\n                lower = mid + 1\\n            else:\\n                upper = mid\\n        return lower\\n\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        upper = max(ranks) * cars * cars\\n        lower = 1\\n\\n        # Get the number of cars that can be repaired within time t\\n        def getRepairs(ranks, t):\\n            res = 0\\n            for rank in ranks:\\n                res += int(sqrt(t / rank))\\n            return res\\n\\n        while lower < upper:\\n            mid = lower + (upper - lower) // 2\\n            repairs = getRepairs(ranks, mid)\\n            if repairs < cars:\\n                lower = mid + 1\\n            else:\\n                upper = mid\\n        return lower\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314699,
                "title": "java-binary-search-on-time-and-cars",
                "content": "```\\nclass Solution {\\n\\n    public long repairCars(int[] ranks, int cars) {\\n        long ans = 0;\\n        long low = 0;\\n        long high = Long.MAX_VALUE;\\n        while(low<=high) {\\n            // Binary Search to find minimum time taken to repair all the cars.\\n            long mid = low+(high-low)/2;\\n            boolean res = check(ranks, cars, mid);\\n            if(res==true){\\n                ans = mid;\\n                high = mid-1;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    boolean check(int[] ranks, int cars, long time) {\\n        \\n        int cnt = 0;\\n        for(int rank: ranks) {\\n            // Binary Search to find , how many cars mechanic can atmost repair in time seconds\\n            int low = 0 ;\\n            int high = cars;\\n            int c = 0;\\n            while(low<=high){\\n                int m = low+(high-low)/2;\\n                long t = (long)rank*m*m;\\n                if(t<=time){\\n                    c = m; // mechanic can repair atleast m cars\\n                    low = m+1;\\n                }else{\\n                    high = m-1;\\n                }\\n            }\\n            \\n            cnt+= c;\\n            if(cnt>=cars)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long repairCars(int[] ranks, int cars) {\\n        long ans = 0;\\n        long low = 0;\\n        long high = Long.MAX_VALUE;\\n        while(low<=high) {\\n            // Binary Search to find minimum time taken to repair all the cars.\\n            long mid = low+(high-low)/2;\\n            boolean res = check(ranks, cars, mid);\\n            if(res==true){\\n                ans = mid;\\n                high = mid-1;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    boolean check(int[] ranks, int cars, long time) {\\n        \\n        int cnt = 0;\\n        for(int rank: ranks) {\\n            // Binary Search to find , how many cars mechanic can atmost repair in time seconds\\n            int low = 0 ;\\n            int high = cars;\\n            int c = 0;\\n            while(low<=high){\\n                int m = low+(high-low)/2;\\n                long t = (long)rank*m*m;\\n                if(t<=time){\\n                    c = m; // mechanic can repair atleast m cars\\n                    low = m+1;\\n                }else{\\n                    high = m-1;\\n                }\\n            }\\n            \\n            cnt+= c;\\n            if(cnt>=cars)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1838285,
                "content": [
                    {
                        "username": "vi88i",
                        "content": "one of the best binary search problem, didn't even know I had to use binary search."
                    },
                    {
                        "username": "xsank",
                        "content": "agree with you"
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!"
                    },
                    {
                        "username": "itsyashkumar23",
                        "content": "Test your code for this before submitting :\\n\\n[9,13,15,9,5,2,15,12,9,9,9,18,9,22,28,15,4,21,17,23,10,25,10,12,24,30,13,13,24,29,18,5,28,16,1,15,15,30,31,21,15,21,18,10,23,27,27,2,6,4,12,26,17,24,6,31,29,31,29,12,24,27,7,15,14,22,18,23,27,6,6,18,19,15,9,1,3,31,24,16,14,27,6,19,9,2,16,8,9,24,9,1,14,12,3,18,18,21,28,11,15,15,23,26,4,23,12,18,20,19,9,23,3,7,21,21,27,25,29,11,19,1,16,29,25,16,20,21,17,17,20,18,8,15,27,17,21,20,23,14,31,9,29,21,10,3,13,24,3,12,19,14,9,20,25,18,30,8,2,14,3,14,7,23,4,12,26,14,6,3,28,20,8,30,10,19,8,14,3,19,6,12,4,25,28,20,7,19,7,30,17,31,19,19,1,31,26,2,22,13,5,25,31,10,17,24,12,26,23,7,13,22,22,11,29,22,12,7,27,10,26,3,8,4,29,13,4,1,1,24,23,1,13,4,23,26,2,16,25,23,3,25,15,21,1,25,5,25,21,31,14,31,30,21,7,12,2,31,23,20,19,14,28,23,10,18,30,25,3,2,25,14,27,16,18,27,3,25,20,19,29,1,10,18,13,28,14,2,12,5,10,17,4,20,3,14,26,31,30,19,17,6,15,22,28,18,3,11,24,19,7,16,25,28,26,6,7,25,3,28,6,18,9,29,31,9,29,1,23,14,22,17,21,15,14,30,23,12,31,26,25,31,29,28,10,29,2,8,21,24,11,18,24,26,7,12,16,21,13,2,22,9,19,5,7,19,2,22,4,8,19,26,5,13,4,19,27,3,31,22,2,25,30,29,5,7,18,18,18,22,9,5,22,23,25,23,14,5,9,9,31,2,21,12,7,26,6,7,16,19,29,16,25,16,6,19,22,12,21,5,16,20,28,4,27,10,29,27,23,20,17,3,21,15,29,10,19,13,19,15,15,16,20,28,16,17,29,21,12,2,15,22,11,28,4,26,29,4,6,11,5,1,27,19,10,15,19,14,5,27,19,22,14,24,27,11,30,25,12,19,25,23,7,9,20,27,26,25,4,16,19,2,16,13,11,11,13,25,7,23,1,29,18,11,15,16,14,1,21,2,22,31,21,8,19,17,2,3,22,11,8,12,24,16,21,18,7,27,9,12,14,4,14,20,13,16,5,9,1,13,8,2,27,1,17,23,3,30,27,6,17,14,4,3,28,4,13,28,7,29,24,21,27,4,19,16,31,18,15,27,12,25,20,23,21,17,1,6,6,10,10,25,20,14,4,12,7,17,18,24,1,18,11,30,21,21,13,1,24,7,14,11,13,31,13,20,11,11,8,29,22,21,18,21,11,16,30,23,3,5,18,15,19,18,17,6,22,17,10,15,25,10,4,6,29,7,14,26,29,23,5,6,2,1,9,18,17,11,30,27,1,21,17,14,9,16,5,20,3,7,16,14,18,17,21,10,21,30,18,12,28,16,8,6,28,25,8,23,25,27,11,28,7,13,24,31,3,27,11,18,3,8,25,10,8,18,8,16,28,27,27,14,25,31,10,6,11,5,17,27,27,9,2,30,18,2,16,6,21,6,10,24,17,20,1,7,20,16,10,17,15,16,22,24,4,5,1,12,27,3,14,10,10,24,27,6,5,29,10,11,30,15,3,23,17,19,4,1,8,20,25,11,1,31,26,19,11,25,8,14,26,24,27,23,14,22,17,11,17,15,9,3,9,10,30,1,12,30,11,29,18,19,13,17,19,17,20,2,14,11,7,17,10,14,15,18,31,22,25,31,13,4,26,22,20,27,13,17,19,24,20,1,15,1,19,21,30,18,5,23,29,10,24,26,12,30,22,12,2,26,16,7,25,17,12,22,27,4,26,5,17,25,20,12,15,14,6,12,1,16,27,12,15,23,29,17,5,6,23,25,28,14,21,14,30,23,10,22,5,6,21,20,24,17,25,18,5,12,15,30,28,14,28,9,31,15,17,26,6,19,20,24,28,19,4,22,2,17,13,15,3,26,29,6,7,24,16,27,7]\\n292126"
                    },
                    {
                        "username": "xsank",
                        "content": "timeout prone..."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am so stupid. I wrote the whole code of this problem, but forget to check in function that repaired car > car, that\\'s why it gives me TLE and I am thinking the question was wrong."
                    },
                    {
                        "username": "Prog_Jacob",
                        "content": "I guess this question has an out of the box solution with discrete calculus that run on O(1) Time and Space."
                    },
                    {
                        "username": "cyjackx",
                        "content": "Doubtful; you need to interact with each rank at least once, so it has to be O(n) at a minimum."
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "please share the approach"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can you share your thoughts."
                    },
                    {
                        "username": "sameer89",
                        "content": "This is a hard question."
                    },
                    {
                        "username": "Ankitmeena992828",
                        "content": "TLE for this  test case [31,31,5,19,19,10,31,18,19,3,16,20,4,16,2,25,10,16,23,18,21,23,28,6,7,29,11,11,19,20,24,19,26,12,29,29,1,14,17,26,24,7,11,28,22,14,31,12,3,19,16,26,11]\\n736185"
                    },
                    {
                        "username": "gursewak22",
                        "content": "i am stupid didn\\'t read Note Assumed what question is asking to do so spent many hours came up with  logic written code and now"
                    }
                ]
            },
            {
                "id": 1847129,
                "content": [
                    {
                        "username": "vi88i",
                        "content": "one of the best binary search problem, didn't even know I had to use binary search."
                    },
                    {
                        "username": "xsank",
                        "content": "agree with you"
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!"
                    },
                    {
                        "username": "itsyashkumar23",
                        "content": "Test your code for this before submitting :\\n\\n[9,13,15,9,5,2,15,12,9,9,9,18,9,22,28,15,4,21,17,23,10,25,10,12,24,30,13,13,24,29,18,5,28,16,1,15,15,30,31,21,15,21,18,10,23,27,27,2,6,4,12,26,17,24,6,31,29,31,29,12,24,27,7,15,14,22,18,23,27,6,6,18,19,15,9,1,3,31,24,16,14,27,6,19,9,2,16,8,9,24,9,1,14,12,3,18,18,21,28,11,15,15,23,26,4,23,12,18,20,19,9,23,3,7,21,21,27,25,29,11,19,1,16,29,25,16,20,21,17,17,20,18,8,15,27,17,21,20,23,14,31,9,29,21,10,3,13,24,3,12,19,14,9,20,25,18,30,8,2,14,3,14,7,23,4,12,26,14,6,3,28,20,8,30,10,19,8,14,3,19,6,12,4,25,28,20,7,19,7,30,17,31,19,19,1,31,26,2,22,13,5,25,31,10,17,24,12,26,23,7,13,22,22,11,29,22,12,7,27,10,26,3,8,4,29,13,4,1,1,24,23,1,13,4,23,26,2,16,25,23,3,25,15,21,1,25,5,25,21,31,14,31,30,21,7,12,2,31,23,20,19,14,28,23,10,18,30,25,3,2,25,14,27,16,18,27,3,25,20,19,29,1,10,18,13,28,14,2,12,5,10,17,4,20,3,14,26,31,30,19,17,6,15,22,28,18,3,11,24,19,7,16,25,28,26,6,7,25,3,28,6,18,9,29,31,9,29,1,23,14,22,17,21,15,14,30,23,12,31,26,25,31,29,28,10,29,2,8,21,24,11,18,24,26,7,12,16,21,13,2,22,9,19,5,7,19,2,22,4,8,19,26,5,13,4,19,27,3,31,22,2,25,30,29,5,7,18,18,18,22,9,5,22,23,25,23,14,5,9,9,31,2,21,12,7,26,6,7,16,19,29,16,25,16,6,19,22,12,21,5,16,20,28,4,27,10,29,27,23,20,17,3,21,15,29,10,19,13,19,15,15,16,20,28,16,17,29,21,12,2,15,22,11,28,4,26,29,4,6,11,5,1,27,19,10,15,19,14,5,27,19,22,14,24,27,11,30,25,12,19,25,23,7,9,20,27,26,25,4,16,19,2,16,13,11,11,13,25,7,23,1,29,18,11,15,16,14,1,21,2,22,31,21,8,19,17,2,3,22,11,8,12,24,16,21,18,7,27,9,12,14,4,14,20,13,16,5,9,1,13,8,2,27,1,17,23,3,30,27,6,17,14,4,3,28,4,13,28,7,29,24,21,27,4,19,16,31,18,15,27,12,25,20,23,21,17,1,6,6,10,10,25,20,14,4,12,7,17,18,24,1,18,11,30,21,21,13,1,24,7,14,11,13,31,13,20,11,11,8,29,22,21,18,21,11,16,30,23,3,5,18,15,19,18,17,6,22,17,10,15,25,10,4,6,29,7,14,26,29,23,5,6,2,1,9,18,17,11,30,27,1,21,17,14,9,16,5,20,3,7,16,14,18,17,21,10,21,30,18,12,28,16,8,6,28,25,8,23,25,27,11,28,7,13,24,31,3,27,11,18,3,8,25,10,8,18,8,16,28,27,27,14,25,31,10,6,11,5,17,27,27,9,2,30,18,2,16,6,21,6,10,24,17,20,1,7,20,16,10,17,15,16,22,24,4,5,1,12,27,3,14,10,10,24,27,6,5,29,10,11,30,15,3,23,17,19,4,1,8,20,25,11,1,31,26,19,11,25,8,14,26,24,27,23,14,22,17,11,17,15,9,3,9,10,30,1,12,30,11,29,18,19,13,17,19,17,20,2,14,11,7,17,10,14,15,18,31,22,25,31,13,4,26,22,20,27,13,17,19,24,20,1,15,1,19,21,30,18,5,23,29,10,24,26,12,30,22,12,2,26,16,7,25,17,12,22,27,4,26,5,17,25,20,12,15,14,6,12,1,16,27,12,15,23,29,17,5,6,23,25,28,14,21,14,30,23,10,22,5,6,21,20,24,17,25,18,5,12,15,30,28,14,28,9,31,15,17,26,6,19,20,24,28,19,4,22,2,17,13,15,3,26,29,6,7,24,16,27,7]\\n292126"
                    },
                    {
                        "username": "xsank",
                        "content": "timeout prone..."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am so stupid. I wrote the whole code of this problem, but forget to check in function that repaired car > car, that\\'s why it gives me TLE and I am thinking the question was wrong."
                    },
                    {
                        "username": "Prog_Jacob",
                        "content": "I guess this question has an out of the box solution with discrete calculus that run on O(1) Time and Space."
                    },
                    {
                        "username": "cyjackx",
                        "content": "Doubtful; you need to interact with each rank at least once, so it has to be O(n) at a minimum."
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "please share the approach"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can you share your thoughts."
                    },
                    {
                        "username": "sameer89",
                        "content": "This is a hard question."
                    },
                    {
                        "username": "Ankitmeena992828",
                        "content": "TLE for this  test case [31,31,5,19,19,10,31,18,19,3,16,20,4,16,2,25,10,16,23,18,21,23,28,6,7,29,11,11,19,20,24,19,26,12,29,29,1,14,17,26,24,7,11,28,22,14,31,12,3,19,16,26,11]\\n736185"
                    },
                    {
                        "username": "gursewak22",
                        "content": "i am stupid didn\\'t read Note Assumed what question is asking to do so spent many hours came up with  logic written code and now"
                    }
                ]
            },
            {
                "id": 1836514,
                "content": [
                    {
                        "username": "vi88i",
                        "content": "one of the best binary search problem, didn't even know I had to use binary search."
                    },
                    {
                        "username": "xsank",
                        "content": "agree with you"
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!"
                    },
                    {
                        "username": "itsyashkumar23",
                        "content": "Test your code for this before submitting :\\n\\n[9,13,15,9,5,2,15,12,9,9,9,18,9,22,28,15,4,21,17,23,10,25,10,12,24,30,13,13,24,29,18,5,28,16,1,15,15,30,31,21,15,21,18,10,23,27,27,2,6,4,12,26,17,24,6,31,29,31,29,12,24,27,7,15,14,22,18,23,27,6,6,18,19,15,9,1,3,31,24,16,14,27,6,19,9,2,16,8,9,24,9,1,14,12,3,18,18,21,28,11,15,15,23,26,4,23,12,18,20,19,9,23,3,7,21,21,27,25,29,11,19,1,16,29,25,16,20,21,17,17,20,18,8,15,27,17,21,20,23,14,31,9,29,21,10,3,13,24,3,12,19,14,9,20,25,18,30,8,2,14,3,14,7,23,4,12,26,14,6,3,28,20,8,30,10,19,8,14,3,19,6,12,4,25,28,20,7,19,7,30,17,31,19,19,1,31,26,2,22,13,5,25,31,10,17,24,12,26,23,7,13,22,22,11,29,22,12,7,27,10,26,3,8,4,29,13,4,1,1,24,23,1,13,4,23,26,2,16,25,23,3,25,15,21,1,25,5,25,21,31,14,31,30,21,7,12,2,31,23,20,19,14,28,23,10,18,30,25,3,2,25,14,27,16,18,27,3,25,20,19,29,1,10,18,13,28,14,2,12,5,10,17,4,20,3,14,26,31,30,19,17,6,15,22,28,18,3,11,24,19,7,16,25,28,26,6,7,25,3,28,6,18,9,29,31,9,29,1,23,14,22,17,21,15,14,30,23,12,31,26,25,31,29,28,10,29,2,8,21,24,11,18,24,26,7,12,16,21,13,2,22,9,19,5,7,19,2,22,4,8,19,26,5,13,4,19,27,3,31,22,2,25,30,29,5,7,18,18,18,22,9,5,22,23,25,23,14,5,9,9,31,2,21,12,7,26,6,7,16,19,29,16,25,16,6,19,22,12,21,5,16,20,28,4,27,10,29,27,23,20,17,3,21,15,29,10,19,13,19,15,15,16,20,28,16,17,29,21,12,2,15,22,11,28,4,26,29,4,6,11,5,1,27,19,10,15,19,14,5,27,19,22,14,24,27,11,30,25,12,19,25,23,7,9,20,27,26,25,4,16,19,2,16,13,11,11,13,25,7,23,1,29,18,11,15,16,14,1,21,2,22,31,21,8,19,17,2,3,22,11,8,12,24,16,21,18,7,27,9,12,14,4,14,20,13,16,5,9,1,13,8,2,27,1,17,23,3,30,27,6,17,14,4,3,28,4,13,28,7,29,24,21,27,4,19,16,31,18,15,27,12,25,20,23,21,17,1,6,6,10,10,25,20,14,4,12,7,17,18,24,1,18,11,30,21,21,13,1,24,7,14,11,13,31,13,20,11,11,8,29,22,21,18,21,11,16,30,23,3,5,18,15,19,18,17,6,22,17,10,15,25,10,4,6,29,7,14,26,29,23,5,6,2,1,9,18,17,11,30,27,1,21,17,14,9,16,5,20,3,7,16,14,18,17,21,10,21,30,18,12,28,16,8,6,28,25,8,23,25,27,11,28,7,13,24,31,3,27,11,18,3,8,25,10,8,18,8,16,28,27,27,14,25,31,10,6,11,5,17,27,27,9,2,30,18,2,16,6,21,6,10,24,17,20,1,7,20,16,10,17,15,16,22,24,4,5,1,12,27,3,14,10,10,24,27,6,5,29,10,11,30,15,3,23,17,19,4,1,8,20,25,11,1,31,26,19,11,25,8,14,26,24,27,23,14,22,17,11,17,15,9,3,9,10,30,1,12,30,11,29,18,19,13,17,19,17,20,2,14,11,7,17,10,14,15,18,31,22,25,31,13,4,26,22,20,27,13,17,19,24,20,1,15,1,19,21,30,18,5,23,29,10,24,26,12,30,22,12,2,26,16,7,25,17,12,22,27,4,26,5,17,25,20,12,15,14,6,12,1,16,27,12,15,23,29,17,5,6,23,25,28,14,21,14,30,23,10,22,5,6,21,20,24,17,25,18,5,12,15,30,28,14,28,9,31,15,17,26,6,19,20,24,28,19,4,22,2,17,13,15,3,26,29,6,7,24,16,27,7]\\n292126"
                    },
                    {
                        "username": "xsank",
                        "content": "timeout prone..."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am so stupid. I wrote the whole code of this problem, but forget to check in function that repaired car > car, that\\'s why it gives me TLE and I am thinking the question was wrong."
                    },
                    {
                        "username": "Prog_Jacob",
                        "content": "I guess this question has an out of the box solution with discrete calculus that run on O(1) Time and Space."
                    },
                    {
                        "username": "cyjackx",
                        "content": "Doubtful; you need to interact with each rank at least once, so it has to be O(n) at a minimum."
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "please share the approach"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can you share your thoughts."
                    },
                    {
                        "username": "sameer89",
                        "content": "This is a hard question."
                    },
                    {
                        "username": "Ankitmeena992828",
                        "content": "TLE for this  test case [31,31,5,19,19,10,31,18,19,3,16,20,4,16,2,25,10,16,23,18,21,23,28,6,7,29,11,11,19,20,24,19,26,12,29,29,1,14,17,26,24,7,11,28,22,14,31,12,3,19,16,26,11]\\n736185"
                    },
                    {
                        "username": "gursewak22",
                        "content": "i am stupid didn\\'t read Note Assumed what question is asking to do so spent many hours came up with  logic written code and now"
                    }
                ]
            },
            {
                "id": 1836219,
                "content": [
                    {
                        "username": "vi88i",
                        "content": "one of the best binary search problem, didn't even know I had to use binary search."
                    },
                    {
                        "username": "xsank",
                        "content": "agree with you"
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!"
                    },
                    {
                        "username": "itsyashkumar23",
                        "content": "Test your code for this before submitting :\\n\\n[9,13,15,9,5,2,15,12,9,9,9,18,9,22,28,15,4,21,17,23,10,25,10,12,24,30,13,13,24,29,18,5,28,16,1,15,15,30,31,21,15,21,18,10,23,27,27,2,6,4,12,26,17,24,6,31,29,31,29,12,24,27,7,15,14,22,18,23,27,6,6,18,19,15,9,1,3,31,24,16,14,27,6,19,9,2,16,8,9,24,9,1,14,12,3,18,18,21,28,11,15,15,23,26,4,23,12,18,20,19,9,23,3,7,21,21,27,25,29,11,19,1,16,29,25,16,20,21,17,17,20,18,8,15,27,17,21,20,23,14,31,9,29,21,10,3,13,24,3,12,19,14,9,20,25,18,30,8,2,14,3,14,7,23,4,12,26,14,6,3,28,20,8,30,10,19,8,14,3,19,6,12,4,25,28,20,7,19,7,30,17,31,19,19,1,31,26,2,22,13,5,25,31,10,17,24,12,26,23,7,13,22,22,11,29,22,12,7,27,10,26,3,8,4,29,13,4,1,1,24,23,1,13,4,23,26,2,16,25,23,3,25,15,21,1,25,5,25,21,31,14,31,30,21,7,12,2,31,23,20,19,14,28,23,10,18,30,25,3,2,25,14,27,16,18,27,3,25,20,19,29,1,10,18,13,28,14,2,12,5,10,17,4,20,3,14,26,31,30,19,17,6,15,22,28,18,3,11,24,19,7,16,25,28,26,6,7,25,3,28,6,18,9,29,31,9,29,1,23,14,22,17,21,15,14,30,23,12,31,26,25,31,29,28,10,29,2,8,21,24,11,18,24,26,7,12,16,21,13,2,22,9,19,5,7,19,2,22,4,8,19,26,5,13,4,19,27,3,31,22,2,25,30,29,5,7,18,18,18,22,9,5,22,23,25,23,14,5,9,9,31,2,21,12,7,26,6,7,16,19,29,16,25,16,6,19,22,12,21,5,16,20,28,4,27,10,29,27,23,20,17,3,21,15,29,10,19,13,19,15,15,16,20,28,16,17,29,21,12,2,15,22,11,28,4,26,29,4,6,11,5,1,27,19,10,15,19,14,5,27,19,22,14,24,27,11,30,25,12,19,25,23,7,9,20,27,26,25,4,16,19,2,16,13,11,11,13,25,7,23,1,29,18,11,15,16,14,1,21,2,22,31,21,8,19,17,2,3,22,11,8,12,24,16,21,18,7,27,9,12,14,4,14,20,13,16,5,9,1,13,8,2,27,1,17,23,3,30,27,6,17,14,4,3,28,4,13,28,7,29,24,21,27,4,19,16,31,18,15,27,12,25,20,23,21,17,1,6,6,10,10,25,20,14,4,12,7,17,18,24,1,18,11,30,21,21,13,1,24,7,14,11,13,31,13,20,11,11,8,29,22,21,18,21,11,16,30,23,3,5,18,15,19,18,17,6,22,17,10,15,25,10,4,6,29,7,14,26,29,23,5,6,2,1,9,18,17,11,30,27,1,21,17,14,9,16,5,20,3,7,16,14,18,17,21,10,21,30,18,12,28,16,8,6,28,25,8,23,25,27,11,28,7,13,24,31,3,27,11,18,3,8,25,10,8,18,8,16,28,27,27,14,25,31,10,6,11,5,17,27,27,9,2,30,18,2,16,6,21,6,10,24,17,20,1,7,20,16,10,17,15,16,22,24,4,5,1,12,27,3,14,10,10,24,27,6,5,29,10,11,30,15,3,23,17,19,4,1,8,20,25,11,1,31,26,19,11,25,8,14,26,24,27,23,14,22,17,11,17,15,9,3,9,10,30,1,12,30,11,29,18,19,13,17,19,17,20,2,14,11,7,17,10,14,15,18,31,22,25,31,13,4,26,22,20,27,13,17,19,24,20,1,15,1,19,21,30,18,5,23,29,10,24,26,12,30,22,12,2,26,16,7,25,17,12,22,27,4,26,5,17,25,20,12,15,14,6,12,1,16,27,12,15,23,29,17,5,6,23,25,28,14,21,14,30,23,10,22,5,6,21,20,24,17,25,18,5,12,15,30,28,14,28,9,31,15,17,26,6,19,20,24,28,19,4,22,2,17,13,15,3,26,29,6,7,24,16,27,7]\\n292126"
                    },
                    {
                        "username": "xsank",
                        "content": "timeout prone..."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am so stupid. I wrote the whole code of this problem, but forget to check in function that repaired car > car, that\\'s why it gives me TLE and I am thinking the question was wrong."
                    },
                    {
                        "username": "Prog_Jacob",
                        "content": "I guess this question has an out of the box solution with discrete calculus that run on O(1) Time and Space."
                    },
                    {
                        "username": "cyjackx",
                        "content": "Doubtful; you need to interact with each rank at least once, so it has to be O(n) at a minimum."
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "please share the approach"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can you share your thoughts."
                    },
                    {
                        "username": "sameer89",
                        "content": "This is a hard question."
                    },
                    {
                        "username": "Ankitmeena992828",
                        "content": "TLE for this  test case [31,31,5,19,19,10,31,18,19,3,16,20,4,16,2,25,10,16,23,18,21,23,28,6,7,29,11,11,19,20,24,19,26,12,29,29,1,14,17,26,24,7,11,28,22,14,31,12,3,19,16,26,11]\\n736185"
                    },
                    {
                        "username": "gursewak22",
                        "content": "i am stupid didn\\'t read Note Assumed what question is asking to do so spent many hours came up with  logic written code and now"
                    }
                ]
            },
            {
                "id": 1836208,
                "content": [
                    {
                        "username": "vi88i",
                        "content": "one of the best binary search problem, didn't even know I had to use binary search."
                    },
                    {
                        "username": "xsank",
                        "content": "agree with you"
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!"
                    },
                    {
                        "username": "itsyashkumar23",
                        "content": "Test your code for this before submitting :\\n\\n[9,13,15,9,5,2,15,12,9,9,9,18,9,22,28,15,4,21,17,23,10,25,10,12,24,30,13,13,24,29,18,5,28,16,1,15,15,30,31,21,15,21,18,10,23,27,27,2,6,4,12,26,17,24,6,31,29,31,29,12,24,27,7,15,14,22,18,23,27,6,6,18,19,15,9,1,3,31,24,16,14,27,6,19,9,2,16,8,9,24,9,1,14,12,3,18,18,21,28,11,15,15,23,26,4,23,12,18,20,19,9,23,3,7,21,21,27,25,29,11,19,1,16,29,25,16,20,21,17,17,20,18,8,15,27,17,21,20,23,14,31,9,29,21,10,3,13,24,3,12,19,14,9,20,25,18,30,8,2,14,3,14,7,23,4,12,26,14,6,3,28,20,8,30,10,19,8,14,3,19,6,12,4,25,28,20,7,19,7,30,17,31,19,19,1,31,26,2,22,13,5,25,31,10,17,24,12,26,23,7,13,22,22,11,29,22,12,7,27,10,26,3,8,4,29,13,4,1,1,24,23,1,13,4,23,26,2,16,25,23,3,25,15,21,1,25,5,25,21,31,14,31,30,21,7,12,2,31,23,20,19,14,28,23,10,18,30,25,3,2,25,14,27,16,18,27,3,25,20,19,29,1,10,18,13,28,14,2,12,5,10,17,4,20,3,14,26,31,30,19,17,6,15,22,28,18,3,11,24,19,7,16,25,28,26,6,7,25,3,28,6,18,9,29,31,9,29,1,23,14,22,17,21,15,14,30,23,12,31,26,25,31,29,28,10,29,2,8,21,24,11,18,24,26,7,12,16,21,13,2,22,9,19,5,7,19,2,22,4,8,19,26,5,13,4,19,27,3,31,22,2,25,30,29,5,7,18,18,18,22,9,5,22,23,25,23,14,5,9,9,31,2,21,12,7,26,6,7,16,19,29,16,25,16,6,19,22,12,21,5,16,20,28,4,27,10,29,27,23,20,17,3,21,15,29,10,19,13,19,15,15,16,20,28,16,17,29,21,12,2,15,22,11,28,4,26,29,4,6,11,5,1,27,19,10,15,19,14,5,27,19,22,14,24,27,11,30,25,12,19,25,23,7,9,20,27,26,25,4,16,19,2,16,13,11,11,13,25,7,23,1,29,18,11,15,16,14,1,21,2,22,31,21,8,19,17,2,3,22,11,8,12,24,16,21,18,7,27,9,12,14,4,14,20,13,16,5,9,1,13,8,2,27,1,17,23,3,30,27,6,17,14,4,3,28,4,13,28,7,29,24,21,27,4,19,16,31,18,15,27,12,25,20,23,21,17,1,6,6,10,10,25,20,14,4,12,7,17,18,24,1,18,11,30,21,21,13,1,24,7,14,11,13,31,13,20,11,11,8,29,22,21,18,21,11,16,30,23,3,5,18,15,19,18,17,6,22,17,10,15,25,10,4,6,29,7,14,26,29,23,5,6,2,1,9,18,17,11,30,27,1,21,17,14,9,16,5,20,3,7,16,14,18,17,21,10,21,30,18,12,28,16,8,6,28,25,8,23,25,27,11,28,7,13,24,31,3,27,11,18,3,8,25,10,8,18,8,16,28,27,27,14,25,31,10,6,11,5,17,27,27,9,2,30,18,2,16,6,21,6,10,24,17,20,1,7,20,16,10,17,15,16,22,24,4,5,1,12,27,3,14,10,10,24,27,6,5,29,10,11,30,15,3,23,17,19,4,1,8,20,25,11,1,31,26,19,11,25,8,14,26,24,27,23,14,22,17,11,17,15,9,3,9,10,30,1,12,30,11,29,18,19,13,17,19,17,20,2,14,11,7,17,10,14,15,18,31,22,25,31,13,4,26,22,20,27,13,17,19,24,20,1,15,1,19,21,30,18,5,23,29,10,24,26,12,30,22,12,2,26,16,7,25,17,12,22,27,4,26,5,17,25,20,12,15,14,6,12,1,16,27,12,15,23,29,17,5,6,23,25,28,14,21,14,30,23,10,22,5,6,21,20,24,17,25,18,5,12,15,30,28,14,28,9,31,15,17,26,6,19,20,24,28,19,4,22,2,17,13,15,3,26,29,6,7,24,16,27,7]\\n292126"
                    },
                    {
                        "username": "xsank",
                        "content": "timeout prone..."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am so stupid. I wrote the whole code of this problem, but forget to check in function that repaired car > car, that\\'s why it gives me TLE and I am thinking the question was wrong."
                    },
                    {
                        "username": "Prog_Jacob",
                        "content": "I guess this question has an out of the box solution with discrete calculus that run on O(1) Time and Space."
                    },
                    {
                        "username": "cyjackx",
                        "content": "Doubtful; you need to interact with each rank at least once, so it has to be O(n) at a minimum."
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "please share the approach"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can you share your thoughts."
                    },
                    {
                        "username": "sameer89",
                        "content": "This is a hard question."
                    },
                    {
                        "username": "Ankitmeena992828",
                        "content": "TLE for this  test case [31,31,5,19,19,10,31,18,19,3,16,20,4,16,2,25,10,16,23,18,21,23,28,6,7,29,11,11,19,20,24,19,26,12,29,29,1,14,17,26,24,7,11,28,22,14,31,12,3,19,16,26,11]\\n736185"
                    },
                    {
                        "username": "gursewak22",
                        "content": "i am stupid didn\\'t read Note Assumed what question is asking to do so spent many hours came up with  logic written code and now"
                    }
                ]
            },
            {
                "id": 2056063,
                "content": [
                    {
                        "username": "vi88i",
                        "content": "one of the best binary search problem, didn't even know I had to use binary search."
                    },
                    {
                        "username": "xsank",
                        "content": "agree with you"
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!"
                    },
                    {
                        "username": "itsyashkumar23",
                        "content": "Test your code for this before submitting :\\n\\n[9,13,15,9,5,2,15,12,9,9,9,18,9,22,28,15,4,21,17,23,10,25,10,12,24,30,13,13,24,29,18,5,28,16,1,15,15,30,31,21,15,21,18,10,23,27,27,2,6,4,12,26,17,24,6,31,29,31,29,12,24,27,7,15,14,22,18,23,27,6,6,18,19,15,9,1,3,31,24,16,14,27,6,19,9,2,16,8,9,24,9,1,14,12,3,18,18,21,28,11,15,15,23,26,4,23,12,18,20,19,9,23,3,7,21,21,27,25,29,11,19,1,16,29,25,16,20,21,17,17,20,18,8,15,27,17,21,20,23,14,31,9,29,21,10,3,13,24,3,12,19,14,9,20,25,18,30,8,2,14,3,14,7,23,4,12,26,14,6,3,28,20,8,30,10,19,8,14,3,19,6,12,4,25,28,20,7,19,7,30,17,31,19,19,1,31,26,2,22,13,5,25,31,10,17,24,12,26,23,7,13,22,22,11,29,22,12,7,27,10,26,3,8,4,29,13,4,1,1,24,23,1,13,4,23,26,2,16,25,23,3,25,15,21,1,25,5,25,21,31,14,31,30,21,7,12,2,31,23,20,19,14,28,23,10,18,30,25,3,2,25,14,27,16,18,27,3,25,20,19,29,1,10,18,13,28,14,2,12,5,10,17,4,20,3,14,26,31,30,19,17,6,15,22,28,18,3,11,24,19,7,16,25,28,26,6,7,25,3,28,6,18,9,29,31,9,29,1,23,14,22,17,21,15,14,30,23,12,31,26,25,31,29,28,10,29,2,8,21,24,11,18,24,26,7,12,16,21,13,2,22,9,19,5,7,19,2,22,4,8,19,26,5,13,4,19,27,3,31,22,2,25,30,29,5,7,18,18,18,22,9,5,22,23,25,23,14,5,9,9,31,2,21,12,7,26,6,7,16,19,29,16,25,16,6,19,22,12,21,5,16,20,28,4,27,10,29,27,23,20,17,3,21,15,29,10,19,13,19,15,15,16,20,28,16,17,29,21,12,2,15,22,11,28,4,26,29,4,6,11,5,1,27,19,10,15,19,14,5,27,19,22,14,24,27,11,30,25,12,19,25,23,7,9,20,27,26,25,4,16,19,2,16,13,11,11,13,25,7,23,1,29,18,11,15,16,14,1,21,2,22,31,21,8,19,17,2,3,22,11,8,12,24,16,21,18,7,27,9,12,14,4,14,20,13,16,5,9,1,13,8,2,27,1,17,23,3,30,27,6,17,14,4,3,28,4,13,28,7,29,24,21,27,4,19,16,31,18,15,27,12,25,20,23,21,17,1,6,6,10,10,25,20,14,4,12,7,17,18,24,1,18,11,30,21,21,13,1,24,7,14,11,13,31,13,20,11,11,8,29,22,21,18,21,11,16,30,23,3,5,18,15,19,18,17,6,22,17,10,15,25,10,4,6,29,7,14,26,29,23,5,6,2,1,9,18,17,11,30,27,1,21,17,14,9,16,5,20,3,7,16,14,18,17,21,10,21,30,18,12,28,16,8,6,28,25,8,23,25,27,11,28,7,13,24,31,3,27,11,18,3,8,25,10,8,18,8,16,28,27,27,14,25,31,10,6,11,5,17,27,27,9,2,30,18,2,16,6,21,6,10,24,17,20,1,7,20,16,10,17,15,16,22,24,4,5,1,12,27,3,14,10,10,24,27,6,5,29,10,11,30,15,3,23,17,19,4,1,8,20,25,11,1,31,26,19,11,25,8,14,26,24,27,23,14,22,17,11,17,15,9,3,9,10,30,1,12,30,11,29,18,19,13,17,19,17,20,2,14,11,7,17,10,14,15,18,31,22,25,31,13,4,26,22,20,27,13,17,19,24,20,1,15,1,19,21,30,18,5,23,29,10,24,26,12,30,22,12,2,26,16,7,25,17,12,22,27,4,26,5,17,25,20,12,15,14,6,12,1,16,27,12,15,23,29,17,5,6,23,25,28,14,21,14,30,23,10,22,5,6,21,20,24,17,25,18,5,12,15,30,28,14,28,9,31,15,17,26,6,19,20,24,28,19,4,22,2,17,13,15,3,26,29,6,7,24,16,27,7]\\n292126"
                    },
                    {
                        "username": "xsank",
                        "content": "timeout prone..."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am so stupid. I wrote the whole code of this problem, but forget to check in function that repaired car > car, that\\'s why it gives me TLE and I am thinking the question was wrong."
                    },
                    {
                        "username": "Prog_Jacob",
                        "content": "I guess this question has an out of the box solution with discrete calculus that run on O(1) Time and Space."
                    },
                    {
                        "username": "cyjackx",
                        "content": "Doubtful; you need to interact with each rank at least once, so it has to be O(n) at a minimum."
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "please share the approach"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can you share your thoughts."
                    },
                    {
                        "username": "sameer89",
                        "content": "This is a hard question."
                    },
                    {
                        "username": "Ankitmeena992828",
                        "content": "TLE for this  test case [31,31,5,19,19,10,31,18,19,3,16,20,4,16,2,25,10,16,23,18,21,23,28,6,7,29,11,11,19,20,24,19,26,12,29,29,1,14,17,26,24,7,11,28,22,14,31,12,3,19,16,26,11]\\n736185"
                    },
                    {
                        "username": "gursewak22",
                        "content": "i am stupid didn\\'t read Note Assumed what question is asking to do so spent many hours came up with  logic written code and now"
                    }
                ]
            },
            {
                "id": 2048930,
                "content": [
                    {
                        "username": "vi88i",
                        "content": "one of the best binary search problem, didn't even know I had to use binary search."
                    },
                    {
                        "username": "xsank",
                        "content": "agree with you"
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!"
                    },
                    {
                        "username": "itsyashkumar23",
                        "content": "Test your code for this before submitting :\\n\\n[9,13,15,9,5,2,15,12,9,9,9,18,9,22,28,15,4,21,17,23,10,25,10,12,24,30,13,13,24,29,18,5,28,16,1,15,15,30,31,21,15,21,18,10,23,27,27,2,6,4,12,26,17,24,6,31,29,31,29,12,24,27,7,15,14,22,18,23,27,6,6,18,19,15,9,1,3,31,24,16,14,27,6,19,9,2,16,8,9,24,9,1,14,12,3,18,18,21,28,11,15,15,23,26,4,23,12,18,20,19,9,23,3,7,21,21,27,25,29,11,19,1,16,29,25,16,20,21,17,17,20,18,8,15,27,17,21,20,23,14,31,9,29,21,10,3,13,24,3,12,19,14,9,20,25,18,30,8,2,14,3,14,7,23,4,12,26,14,6,3,28,20,8,30,10,19,8,14,3,19,6,12,4,25,28,20,7,19,7,30,17,31,19,19,1,31,26,2,22,13,5,25,31,10,17,24,12,26,23,7,13,22,22,11,29,22,12,7,27,10,26,3,8,4,29,13,4,1,1,24,23,1,13,4,23,26,2,16,25,23,3,25,15,21,1,25,5,25,21,31,14,31,30,21,7,12,2,31,23,20,19,14,28,23,10,18,30,25,3,2,25,14,27,16,18,27,3,25,20,19,29,1,10,18,13,28,14,2,12,5,10,17,4,20,3,14,26,31,30,19,17,6,15,22,28,18,3,11,24,19,7,16,25,28,26,6,7,25,3,28,6,18,9,29,31,9,29,1,23,14,22,17,21,15,14,30,23,12,31,26,25,31,29,28,10,29,2,8,21,24,11,18,24,26,7,12,16,21,13,2,22,9,19,5,7,19,2,22,4,8,19,26,5,13,4,19,27,3,31,22,2,25,30,29,5,7,18,18,18,22,9,5,22,23,25,23,14,5,9,9,31,2,21,12,7,26,6,7,16,19,29,16,25,16,6,19,22,12,21,5,16,20,28,4,27,10,29,27,23,20,17,3,21,15,29,10,19,13,19,15,15,16,20,28,16,17,29,21,12,2,15,22,11,28,4,26,29,4,6,11,5,1,27,19,10,15,19,14,5,27,19,22,14,24,27,11,30,25,12,19,25,23,7,9,20,27,26,25,4,16,19,2,16,13,11,11,13,25,7,23,1,29,18,11,15,16,14,1,21,2,22,31,21,8,19,17,2,3,22,11,8,12,24,16,21,18,7,27,9,12,14,4,14,20,13,16,5,9,1,13,8,2,27,1,17,23,3,30,27,6,17,14,4,3,28,4,13,28,7,29,24,21,27,4,19,16,31,18,15,27,12,25,20,23,21,17,1,6,6,10,10,25,20,14,4,12,7,17,18,24,1,18,11,30,21,21,13,1,24,7,14,11,13,31,13,20,11,11,8,29,22,21,18,21,11,16,30,23,3,5,18,15,19,18,17,6,22,17,10,15,25,10,4,6,29,7,14,26,29,23,5,6,2,1,9,18,17,11,30,27,1,21,17,14,9,16,5,20,3,7,16,14,18,17,21,10,21,30,18,12,28,16,8,6,28,25,8,23,25,27,11,28,7,13,24,31,3,27,11,18,3,8,25,10,8,18,8,16,28,27,27,14,25,31,10,6,11,5,17,27,27,9,2,30,18,2,16,6,21,6,10,24,17,20,1,7,20,16,10,17,15,16,22,24,4,5,1,12,27,3,14,10,10,24,27,6,5,29,10,11,30,15,3,23,17,19,4,1,8,20,25,11,1,31,26,19,11,25,8,14,26,24,27,23,14,22,17,11,17,15,9,3,9,10,30,1,12,30,11,29,18,19,13,17,19,17,20,2,14,11,7,17,10,14,15,18,31,22,25,31,13,4,26,22,20,27,13,17,19,24,20,1,15,1,19,21,30,18,5,23,29,10,24,26,12,30,22,12,2,26,16,7,25,17,12,22,27,4,26,5,17,25,20,12,15,14,6,12,1,16,27,12,15,23,29,17,5,6,23,25,28,14,21,14,30,23,10,22,5,6,21,20,24,17,25,18,5,12,15,30,28,14,28,9,31,15,17,26,6,19,20,24,28,19,4,22,2,17,13,15,3,26,29,6,7,24,16,27,7]\\n292126"
                    },
                    {
                        "username": "xsank",
                        "content": "timeout prone..."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am so stupid. I wrote the whole code of this problem, but forget to check in function that repaired car > car, that\\'s why it gives me TLE and I am thinking the question was wrong."
                    },
                    {
                        "username": "Prog_Jacob",
                        "content": "I guess this question has an out of the box solution with discrete calculus that run on O(1) Time and Space."
                    },
                    {
                        "username": "cyjackx",
                        "content": "Doubtful; you need to interact with each rank at least once, so it has to be O(n) at a minimum."
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "please share the approach"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can you share your thoughts."
                    },
                    {
                        "username": "sameer89",
                        "content": "This is a hard question."
                    },
                    {
                        "username": "Ankitmeena992828",
                        "content": "TLE for this  test case [31,31,5,19,19,10,31,18,19,3,16,20,4,16,2,25,10,16,23,18,21,23,28,6,7,29,11,11,19,20,24,19,26,12,29,29,1,14,17,26,24,7,11,28,22,14,31,12,3,19,16,26,11]\\n736185"
                    },
                    {
                        "username": "gursewak22",
                        "content": "i am stupid didn\\'t read Note Assumed what question is asking to do so spent many hours came up with  logic written code and now"
                    }
                ]
            },
            {
                "id": 1840389,
                "content": [
                    {
                        "username": "vi88i",
                        "content": "one of the best binary search problem, didn't even know I had to use binary search."
                    },
                    {
                        "username": "xsank",
                        "content": "agree with you"
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!"
                    },
                    {
                        "username": "itsyashkumar23",
                        "content": "Test your code for this before submitting :\\n\\n[9,13,15,9,5,2,15,12,9,9,9,18,9,22,28,15,4,21,17,23,10,25,10,12,24,30,13,13,24,29,18,5,28,16,1,15,15,30,31,21,15,21,18,10,23,27,27,2,6,4,12,26,17,24,6,31,29,31,29,12,24,27,7,15,14,22,18,23,27,6,6,18,19,15,9,1,3,31,24,16,14,27,6,19,9,2,16,8,9,24,9,1,14,12,3,18,18,21,28,11,15,15,23,26,4,23,12,18,20,19,9,23,3,7,21,21,27,25,29,11,19,1,16,29,25,16,20,21,17,17,20,18,8,15,27,17,21,20,23,14,31,9,29,21,10,3,13,24,3,12,19,14,9,20,25,18,30,8,2,14,3,14,7,23,4,12,26,14,6,3,28,20,8,30,10,19,8,14,3,19,6,12,4,25,28,20,7,19,7,30,17,31,19,19,1,31,26,2,22,13,5,25,31,10,17,24,12,26,23,7,13,22,22,11,29,22,12,7,27,10,26,3,8,4,29,13,4,1,1,24,23,1,13,4,23,26,2,16,25,23,3,25,15,21,1,25,5,25,21,31,14,31,30,21,7,12,2,31,23,20,19,14,28,23,10,18,30,25,3,2,25,14,27,16,18,27,3,25,20,19,29,1,10,18,13,28,14,2,12,5,10,17,4,20,3,14,26,31,30,19,17,6,15,22,28,18,3,11,24,19,7,16,25,28,26,6,7,25,3,28,6,18,9,29,31,9,29,1,23,14,22,17,21,15,14,30,23,12,31,26,25,31,29,28,10,29,2,8,21,24,11,18,24,26,7,12,16,21,13,2,22,9,19,5,7,19,2,22,4,8,19,26,5,13,4,19,27,3,31,22,2,25,30,29,5,7,18,18,18,22,9,5,22,23,25,23,14,5,9,9,31,2,21,12,7,26,6,7,16,19,29,16,25,16,6,19,22,12,21,5,16,20,28,4,27,10,29,27,23,20,17,3,21,15,29,10,19,13,19,15,15,16,20,28,16,17,29,21,12,2,15,22,11,28,4,26,29,4,6,11,5,1,27,19,10,15,19,14,5,27,19,22,14,24,27,11,30,25,12,19,25,23,7,9,20,27,26,25,4,16,19,2,16,13,11,11,13,25,7,23,1,29,18,11,15,16,14,1,21,2,22,31,21,8,19,17,2,3,22,11,8,12,24,16,21,18,7,27,9,12,14,4,14,20,13,16,5,9,1,13,8,2,27,1,17,23,3,30,27,6,17,14,4,3,28,4,13,28,7,29,24,21,27,4,19,16,31,18,15,27,12,25,20,23,21,17,1,6,6,10,10,25,20,14,4,12,7,17,18,24,1,18,11,30,21,21,13,1,24,7,14,11,13,31,13,20,11,11,8,29,22,21,18,21,11,16,30,23,3,5,18,15,19,18,17,6,22,17,10,15,25,10,4,6,29,7,14,26,29,23,5,6,2,1,9,18,17,11,30,27,1,21,17,14,9,16,5,20,3,7,16,14,18,17,21,10,21,30,18,12,28,16,8,6,28,25,8,23,25,27,11,28,7,13,24,31,3,27,11,18,3,8,25,10,8,18,8,16,28,27,27,14,25,31,10,6,11,5,17,27,27,9,2,30,18,2,16,6,21,6,10,24,17,20,1,7,20,16,10,17,15,16,22,24,4,5,1,12,27,3,14,10,10,24,27,6,5,29,10,11,30,15,3,23,17,19,4,1,8,20,25,11,1,31,26,19,11,25,8,14,26,24,27,23,14,22,17,11,17,15,9,3,9,10,30,1,12,30,11,29,18,19,13,17,19,17,20,2,14,11,7,17,10,14,15,18,31,22,25,31,13,4,26,22,20,27,13,17,19,24,20,1,15,1,19,21,30,18,5,23,29,10,24,26,12,30,22,12,2,26,16,7,25,17,12,22,27,4,26,5,17,25,20,12,15,14,6,12,1,16,27,12,15,23,29,17,5,6,23,25,28,14,21,14,30,23,10,22,5,6,21,20,24,17,25,18,5,12,15,30,28,14,28,9,31,15,17,26,6,19,20,24,28,19,4,22,2,17,13,15,3,26,29,6,7,24,16,27,7]\\n292126"
                    },
                    {
                        "username": "xsank",
                        "content": "timeout prone..."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am so stupid. I wrote the whole code of this problem, but forget to check in function that repaired car > car, that\\'s why it gives me TLE and I am thinking the question was wrong."
                    },
                    {
                        "username": "Prog_Jacob",
                        "content": "I guess this question has an out of the box solution with discrete calculus that run on O(1) Time and Space."
                    },
                    {
                        "username": "cyjackx",
                        "content": "Doubtful; you need to interact with each rank at least once, so it has to be O(n) at a minimum."
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "please share the approach"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Can you share your thoughts."
                    },
                    {
                        "username": "sameer89",
                        "content": "This is a hard question."
                    },
                    {
                        "username": "Ankitmeena992828",
                        "content": "TLE for this  test case [31,31,5,19,19,10,31,18,19,3,16,20,4,16,2,25,10,16,23,18,21,23,28,6,7,29,11,11,19,20,24,19,26,12,29,29,1,14,17,26,24,7,11,28,22,14,31,12,3,19,16,26,11]\\n736185"
                    },
                    {
                        "username": "gursewak22",
                        "content": "i am stupid didn\\'t read Note Assumed what question is asking to do so spent many hours came up with  logic written code and now"
                    }
                ]
            }
        ]
    }
]