[
    {
        "title": "Find All K-Distant Indices in an Array",
        "question_content": "You are given a 0-indexed integer array nums and two integers key and k. A k-distant index is an index i of nums for which there exists at least one index j such that |i - j| <= k and nums[j] == key.\nReturn a list of all k-distant indices sorted in increasing order.\n&nbsp;\nExample 1:\n\nInput: nums = [3,4,9,1,3,9,5], key = 9, k = 1\nOutput: [1,2,3,4,5,6]\nExplanation: Here, nums[2] == key and nums[5] == key.\n- For index 0, |0 - 2| > k and |0 - 5| > k, so there is no j where |0 - j| <= k and nums[j] == key. Thus, 0 is not a k-distant index.\n- For index 1, |1 - 2| <= k and nums[2] == key, so 1 is a k-distant index.\n- For index 2, |2 - 2| <= k and nums[2] == key, so 2 is a k-distant index.\n- For index 3, |3 - 2| <= k and nums[2] == key, so 3 is a k-distant index.\n- For index 4, |4 - 5| <= k and nums[5] == key, so 4 is a k-distant index.\n- For index 5, |5 - 5| <= k and nums[5] == key, so 5 is a k-distant index.\n- For index 6, |6 - 5| <= k and nums[5] == key, so 6 is a k-distant index.\nThus, we return [1,2,3,4,5,6] which is sorted in increasing order. \n\nExample 2:\n\nInput: nums = [2,2,2,2,2], key = 2, k = 2\nOutput: [0,1,2,3,4]\nExplanation: For all indices i in nums, there exists some index j such that |i - j| <= k and nums[j] == key, so every index is a k-distant index. \nHence, we return [0,1,2,3,4].\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 1000\n\t1 <= nums[i] <= 1000\n\tkey is an integer from the array nums.\n\t1 <= k <= nums.length",
        "solutions": [
            {
                "id": 1844332,
                "title": "one-pass",
                "content": "We can use two pointers to swipe the array once (`i`) and collect all k-distant indices (`j`).\\n\\n**C++**\\n```cpp\\nvector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n    vector<int> res;\\n    for (int i = 0, j = 0; i < nums.size(); ++i)\\n        if (nums[i] == key)\\n            for (j = max(j, i - k); j <= i + k && j < nums.size(); ++j)\\n                res.push_back(j);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n    vector<int> res;\\n    for (int i = 0, j = 0; i < nums.size(); ++i)\\n        if (nums[i] == key)\\n            for (j = max(j, i - k); j <= i + k && j < nums.size(); ++j)\\n                res.push_back(j);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1845912,
                "title": "o-n-solution-detailed-pictures-easy-to-understand-explaination-c",
                "content": "# Breaking down and understanding the problem\\nThe problem says to return indexes such that |i - j| <= k and nums[j] = key. What does it mean ?\\n\\nSee once we find the key at a particular index. We need to print those indexes which satisfy the condtion \\n|i - j| <= k. Right ? . Now that we understand it, let\\'s look at a visual\\n\\n\\n![image](https://assets.leetcode.com/users/images/48d5ea71-9b81-4e67-b4a9-dd6c8e6f26e9_1647172473.148794.png)\\n\\nFrom here we see that whenever the key is found. We can only move **AT MOST** k indexes to the left and **AT MOST** k indexes to the right. If we move any further along in any direction the |i - j| <= k condition breaks.\\n\\n\\n**So which basically means that the actual problem is whenever we find the key. we have to move k indexes to the left and k indexes to the right and that gives the answer.**\\n\\nNow comes a few scenarios to keep in mind.\\n\\n1. What if we find key on extreme left. We can\\'t move to left of index 0, it gives us out of bounds.\\n     \\n     ![image](https://assets.leetcode.com/users/images/6b485aa7-eb11-4aa9-b9bb-43bec2a3db8e_1647173394.7046137.png)\\n\\n    In order to avoid this we can move to **max(0, i-k)** positions. So that we never fall below 0.\\n\\n2. What if we find key on extreme right. We can\\'t move beyond array limit.\\n\\n     ![image](https://assets.leetcode.com/users/images/09b4f2e3-9783-4257-9d13-c860e06f0204_1647173786.0431998.png)\\n\\n    In order to avoid this we can move to **min(n-1, i+k)** positions. So that we don\\'t go beyond limit of array.\\n\\n3. Avoiding overlapping in intervals\\n\\n![image](https://assets.leetcode.com/users/images/0358be07-6a88-49ad-b584-08459d4dfec5_1647174378.3456926.png)\\n\\nHere what we can do is, we check the last entry of index that we stored. We compare it with the start of the new interval. We take the max of last index entry + 1 & current start.  In above example last entry for first 3 will be 4 **(See the end of red line)**. Starting index for 3 will be 2 **(See the start of orange line)**. So comparing \\nmax(lastEntry of index + 1, startIndex) = max(5, 2) = 5. So we avoid overlapping interval and start from 5.\\n\\n\\n```\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) \\n    {\\n        int n = nums.size();\\n        vector<int> ans;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            if(nums[i] == key) // if we find the key\\n            {\\n                int start = max(0, i-k);   // initialize the start\\n                int end = min(n-1, i+k);   // intialize the end\\n                \\n                if(ans.size()!=0) // check if any index is stored earlier\\n                    start = max(ans[ans.size() - 1] + 1, start); // avoid overlapping intervals\\n                \\n                for(int j = start; j<=end; j++) // simply push every index from start till end\\n                    ans.push_back(j);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n  \\nAs we are able to avoid overlapping intervals. The time complexity is O(n).\\n\\nUpvote if it was able to help you. Cheers !!\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) \\n    {\\n        int n = nums.size();\\n        vector<int> ans;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            if(nums[i] == key) // if we find the key\\n            {\\n                int start = max(0, i-k);   // initialize the start\\n                int end = min(n-1, i+k);   // intialize the end\\n                \\n                if(ans.size()!=0) // check if any index is stored earlier\\n                    start = max(ans[ans.size() - 1] + 1, start); // avoid overlapping intervals\\n                \\n                for(int j = start; j<=end; j++) // simply push every index from start till end\\n                    ans.push_back(j);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844247,
                "title": "brute-force-o-1-extra-space-without-sorting",
                "content": "- Keep on finding the corresponding index **j** w.r.t **i** , having **abs(j-i)<=k** and **nums[j]==target**.\\n- In this way index i will automatically be in **sorted order** as we are pushing it on the way.\\n- We will use a `break statement` the moment we will get a `j` satisfying all the constraint w.r.t `i`.\\n- We don\\'t need any `extra data structure `or any `sorting algorithm` because we will automatically get a sorted answer.\\n# C++   \\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<size(nums);i++){\\n            for(int j=0;j<size(nums);j++){\\n                //if found atleast one index , break and save\\n                if(abs(i-j)<=k and nums[j]==key){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n**Time** - O(N^2)\\n**Space** - O(1) -> apart from the space of the answer that is a vector that we must return\\n**Pls tell any better approach , if you have**\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "- Keep on finding the corresponding index **j** w.r.t **i** , having **abs(j-i)<=k** and **nums[j]==target**.\\n- In this way index i will automatically be in **sorted order** as we are pushing it on the way.\\n- We will use a `break statement` the moment we will get a `j` satisfying all the constraint w.r.t `i`.\\n- We don\\'t need any `extra data structure `or any `sorting algorithm` because we will automatically get a sorted answer.\\n# C++   \\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<size(nums);i++){\\n            for(int j=0;j<size(nums);j++){\\n                //if found atleast one index , break and save\\n                if(abs(i-j)<=k and nums[j]==key){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n**Time** - O(N^2)\\n**Space** - O(1) -> apart from the space of the answer that is a vector that we must return\\n**Pls tell any better approach , if you have**\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1844454,
                "title": "java-o-n-time-space-easy-4-ms-no-sorting",
                "content": "Problem : We have to find all the indices which are at <= k distance from the keys in an array. \\n\\nIdea : If we find all the indices of the keys in a given array in increasing order, then we can iterate k elements on the right and left sides of that key index to add them to answer in increasing order. For the next key index we can start iterating from the maximum(last key index + k , current key index - k) so that we will not process the already iterated array index. \\n\\nOnce we process all the indices with keys, we have a answer list in increasing order and we return it without the need of sorting.\\n\\n```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> idx = new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = 0 ; i < nums.length; i++){\\n            if(nums[i] == key){\\n                idx.add(i);\\n            }\\n        }\\n        int last = 0;\\n        for(int ind : idx){\\n            int i = Math.max(last,ind-k);\\n            for(; i <= ind+k && i < nums.length; i++){\\n                ans.add(i);\\n            }\\n            last = i;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> idx = new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = 0 ; i < nums.length; i++){\\n            if(nums[i] == key){\\n                idx.add(i);\\n            }\\n        }\\n        int last = 0;\\n        for(int ind : idx){\\n            int i = Math.max(last,ind-k);\\n            for(; i <= ind+k && i < nums.length; i++){\\n                ans.add(i);\\n            }\\n            last = i;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171271,
                "title": "python-easy-to-understand-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        ind_j = []\\n        for ind, elem in enumerate(nums):\\n            if elem == key:\\n                ind_j.append(ind)\\n        res = []\\n        for i in range(len(nums)):\\n            for j in ind_j:\\n                if abs(i - j) <= k:\\n                    res.append(i)\\n                    break\\n        return sorted(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        ind_j = []\\n        for ind, elem in enumerate(nums):\\n            if elem == key:\\n                ind_j.append(ind)\\n        res = []\\n        for i in range(len(nums)):\\n            for j in ind_j:\\n                if abs(i - j) <= k:\\n                    res.append(i)\\n                    break\\n        return sorted(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845499,
                "title": "c-two-pointers-o-n-time-o-1-space",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Two Pointers\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& A, int key, int k) {\\n        int N = A.size();\\n        vector<int> ans, idx;\\n        for (int i = 0; i < N; ++i){\\n            if (A[i] == key) idx.push_back(i); // `idx` is a list of indices whose corresponding value is `key`.\\n        }\\n        for (int i = 0, j = 0; i < N && j < idx.size(); ++i) {\\n            if (i < idx[j] - k) continue; // If `i` is not yet in range of the next `key` element at `idx[j]`, skip.\\n            while (j < idx.size() && i > idx[j] + k) ++j; // While `i > idx[j] + k`, keep incrementing `j` to bring `idx[j]` in range of `i`.\\n            if (j < idx.size() && i <= idx[j] + k && i >= idx[j] - k) ans.push_back(i); // add `i` to the answer if `idx[j] - k <= i <= idx[j] + k`.\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. Two Pointers\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& A, int key, int k) {\\n        int N = A.size(), j = 0;\\n        vector<int> ans;\\n        for (int i = 0, j = 0; i < N; ++i) {\\n            while (j < N && (A[j] != key || j < i - k)) ++j; // Find the first index `j` that `A[j] == key` and `j >= i - k`.\\n            if (j == N) break;\\n            if (i <= j + k && i >= j - k) ans.push_back(i); // add `i` to answer if `j - k <= i <= j + k`.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& A, int key, int k) {\\n        int N = A.size();\\n        vector<int> ans, idx;\\n        for (int i = 0; i < N; ++i){\\n            if (A[i] == key) idx.push_back(i); // `idx` is a list of indices whose corresponding value is `key`.\\n        }\\n        for (int i = 0, j = 0; i < N && j < idx.size(); ++i) {\\n            if (i < idx[j] - k) continue; // If `i` is not yet in range of the next `key` element at `idx[j]`, skip.\\n            while (j < idx.size() && i > idx[j] + k) ++j; // While `i > idx[j] + k`, keep incrementing `j` to bring `idx[j]` in range of `i`.\\n            if (j < idx.size() && i <= idx[j] + k && i >= idx[j] - k) ans.push_back(i); // add `i` to the answer if `idx[j] - k <= i <= idx[j] + k`.\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& A, int key, int k) {\\n        int N = A.size(), j = 0;\\n        vector<int> ans;\\n        for (int i = 0, j = 0; i < N; ++i) {\\n            while (j < N && (A[j] != key || j < i - k)) ++j; // Find the first index `j` that `A[j] == key` and `j >= i - k`.\\n            if (j == N) break;\\n            if (i <= j + k && i >= j - k) ans.push_back(i); // add `i` to answer if `j - k <= i <= j + k`.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845354,
                "title": "c-o-n-using-queue",
                "content": "**Time Complexity:- O(n)\\nSpace Complexity:- O(number of keys)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n        \\n        queue<int> q;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == key) q.push(i);\\n        }\\n        \\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n            if(q.empty()) break;\\n            int idx = q.front();\\n            \\n            if(abs(idx - i) <= k) {\\n                ans.push_back(i);\\n            }\\n            else {\\n                if(i > idx) {\\n\\t\\t\\t\\t\\t// if not able to cover current index then surely can\\'t cover indices after it\\n                    q.pop();\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// lets again try for current index\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n        \\n        queue<int> q;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == key) q.push(i);\\n        }\\n        \\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n            if(q.empty()) break;\\n            int idx = q.front();\\n            \\n            if(abs(idx - i) <= k) {\\n                ans.push_back(i);\\n            }\\n            else {\\n                if(i > idx) {\\n\\t\\t\\t\\t\\t// if not able to cover current index then surely can\\'t cover indices after it\\n                    q.pop();\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// lets again try for current index\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844098,
                "title": "o-n-simple-python-code-explained",
                "content": "The idea here is :\\n- Store all the indices of elements in a queue whose value is equal to key\\n- for every index in nums, there are 2 options:\\n    - check with the near index backside whose value = key and difference<=k\\n    - check with the near index in front whose value = k and difference<=k\\n\\nCode:\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        lis=deque([])\\n        prev_popped=-1\\n        for i in range(len(nums)):\\n            if(nums[i]==key):\\n                lis.append(i)\\n        ans=[]\\n        for i in range(len(nums)):\\n            if(len(lis)>0 and lis[0]<i):\\n                prev_popped = lis.popleft()\\n            if(prev_popped!=-1 and (i-prev_popped) <=k):\\n                ans.append(i)\\n            elif(len(lis)>0 and (lis[0]-i)<=k):\\n                ans.append(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        lis=deque([])\\n        prev_popped=-1\\n        for i in range(len(nums)):\\n            if(nums[i]==key):\\n                lis.append(i)\\n        ans=[]\\n        for i in range(len(nums)):\\n            if(len(lis)>0 and lis[0]<i):\\n                prev_popped = lis.popleft()\\n            if(prev_popped!=-1 and (i-prev_popped) <=k):\\n                ans.append(i)\\n            elif(len(lis)>0 and (lis[0]-i)<=k):\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501802,
                "title": "easy-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n        int len = nums.length - 1;\\n        List<Integer> ans = new ArrayList<>();\\n\\n        int[] arr = new int[len+1];\\n        int dist1 = 0, dist2 = 0;\\n\\n        for (int i = 0; i <= len; i++) {\\n            if (nums[i] == key) dist1 = k + 1;\\n            if (dist1 > 0){\\n                arr[i]++;\\n                dist1--;\\n            }\\n\\n            if (nums[len-i] == key) dist2 = k+1;\\n            if (dist2 > 0){\\n                arr[len-i]++;\\n                dist2--;\\n            }\\n        }\\n\\n        for (int i = 0; i < arr.length; i++)\\n            if (arr[i] > 0)\\n                ans.add(i);\\n\\t\\t\\t\\t\\n\\t\\treturn ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1845916,
                "title": "java-most-efficient-solution-easy-understanding",
                "content": "public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        List <Integer> id = new ArrayList <> ();\\n        for(int i=0; i<nums.length; ++i){\\n            if(nums[i] == key){\\n                id.add(i);\\n            }\\n        }\\n        \\n        \\n        List <Integer> res = new ArrayList <> ();\\n        \\n        for(int i=0; i<nums.length; ++i){\\n            for(int j=0; j<id.size(); ++j){\\n            \\n                if(Math.abs(i - id.get(j)) <= k){\\n                    \\n                    res.add(i);\\n                    break;\\n                    \\n                }\\n               \\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        List <Integer> id = new ArrayList <> ();\\n        for(int i=0; i<nums.length; ++i){\\n            if(nums[i] == key){\\n                id.add(i);\\n            }\\n        }\\n        \\n        \\n        List <Integer> res = new ArrayList <> ();\\n        \\n        for(int i=0; i<nums.length; ++i){\\n            for(int j=0; j<id.size(); ++j){\\n            \\n                if(Math.abs(i - id.get(j)) <= k){\\n                    \\n                    res.add(i);\\n                    break;\\n                    \\n                }\\n               \\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1844532,
                "title": "easy-understanding-python-binary-search",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        \"\"\"\\n        find all that == key into a list, idx\\n        \\n        traverse in nums, using i: (using binary search)\\n            if abs(i - idx) <= k: res.append(i)\\n        \"\"\"\\n        keys = [i for (i, e) in enumerate(nums) if e == key]    \\n        res = set(keys)\\n        \\n        for i in range(len(nums)):\\n            idx = bisect.bisect_left(keys, i)\\n            \\n            # to keys[idx] and keys[idx - 1] are all <= k\\n            if 0 <= idx < len(keys) and abs(i - keys[idx]) <= k:\\n                res.add(i)\\n            if 0 < idx <= len(keys) and abs(i - keys[idx - 1]) <= k:\\n                res.add(i)\\n                \\n        \\n        return sorted(list(res))\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        \"\"\"\\n        find all that == key into a list, idx\\n        \\n        traverse in nums, using i: (using binary search)\\n            if abs(i - idx) <= k: res.append(i)\\n        \"\"\"\\n        keys = [i for (i, e) in enumerate(nums) if e == key]    \\n        res = set(keys)\\n        \\n        for i in range(len(nums)):\\n            idx = bisect.bisect_left(keys, i)\\n            \\n            # to keys[idx] and keys[idx - 1] are all <= k\\n            if 0 <= idx < len(keys) and abs(i - keys[idx]) <= k:\\n                res.add(i)\\n            if 0 < idx <= len(keys) and abs(i - keys[idx - 1]) <= k:\\n                res.add(i)\\n                \\n        \\n        return sorted(list(res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844183,
                "title": "c-easy-set-to-vector",
                "content": "- Create a Set of integers and store the indices.\\n- Set automatically arranges the elements in it in increasing order.\\n```cpp\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int N = nums.size();\\n        set<int> S;\\n        \\n        for(int i = 0; i < N; i++) {\\n            if(nums[i] != key) continue;\\n            \\n            for(int j = 0; j < N; j++) {\\n                if(abs(i - j) <= k && nums[i] == key) {\\n                    S.insert(j);\\n                }\\n            }\\n        }\\n\\t\\t// No need to create a new vector\\n        return vector<int> (S.begin(), S.end());\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```cpp\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int N = nums.size();\\n        set<int> S;\\n        \\n        for(int i = 0; i < N; i++) {\\n            if(nums[i] != key) continue;\\n            \\n            for(int j = 0; j < N; j++) {\\n                if(abs(i - j) <= k && nums[i] == key) {\\n                    S.insert(j);\\n                }\\n            }\\n        }\\n\\t\\t// No need to create a new vector\\n        return vector<int> (S.begin(), S.end());\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2468580,
                "title": "yet-another-fast-o-n-python-solution",
                "content": "**The logic**:\\n1. Initialize the left unseen border in `left = 0`.\\n2. We iterate along the array `nums`. \\n3. When we meet a value equal to `key` we add the surrounding indexes `(i - k, i + k)`. We keep in value of the most right added value in `last` not to add it anymore. Thus, every element could be seen by the algorithm maximum of two times.\\n\\n*Please upvote if you like for motivation and karma :)*\\n\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        \\n        ans = []\\n        \\n        left = 0\\n        \\n        for i, v in enumerate(nums):\\n            # meet new key - include nums in the border [i-k:i+k]\\n            if v == key:\\n                for j in range(max(left, i - k), min(len(nums), i + k + 1)):\\n                    ans.append(j)\\n                left = min(len(nums), i + k + 1)\\n                # if all right part is included?\\n                if left == len(nums):\\n                    break\\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        \\n        ans = []\\n        \\n        left = 0\\n        \\n        for i, v in enumerate(nums):\\n            # meet new key - include nums in the border [i-k:i+k]\\n            if v == key:\\n                for j in range(max(left, i - k), min(len(nums), i + k + 1)):\\n                    ans.append(j)\\n                left = min(len(nums), i + k + 1)\\n                # if all right part is included?\\n                if left == len(nums):\\n                    break\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849214,
                "title": "linear-sweep-of-trimmed-window-to-each-key-location",
                "content": "# Algorithm\\n* Scan array for values of `key`. For each found at location `i`:\\n   * Output locations from `i - k` to `i + k`.\\n\\nDuring the scan, the highest output location is tracked and used to trim the above window of output locations if they overlap what has been output already.\\n# C++ Code\\n\\n```C++\\n    static vector<int> findKDistantIndices(const vector<int>& nums, const int key, const int k)\\n    {\\n        int next_unmarked = 0, end = nums.size();\\n        \\n        vector<int> res;\\n        for(int i = 0; i < end; ++i)\\n        {\\n            if(nums[i] == key){\\n                int j = max(next_unmarked, i - k);\\n                for(; j < min(end, i + k + 1); ++j)\\n                {\\n                    res.push_back(j);\\n                }\\n                next_unmarked = j;\\n            }\\n        } \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\n    static vector<int> findKDistantIndices(const vector<int>& nums, const int key, const int k)\\n    {\\n        int next_unmarked = 0, end = nums.size();\\n        \\n        vector<int> res;\\n        for(int i = 0; i < end; ++i)\\n        {\\n            if(nums[i] == key){\\n                int j = max(next_unmarked, i - k);\\n                for(; j < min(end, i + k + 1); ++j)\\n                {\\n                    res.push_back(j);\\n                }\\n                next_unmarked = j;\\n            }\\n        } \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844619,
                "title": "o-n-two-pass-solution-in-python",
                "content": "for each index `i`, we check for two possible key indexes - `keys[left]` and `keys[left + 1]`. If either of them is less than or equal to k, then add to `res`.\\n\\nIn order to handle the edges, I added negative and positive infinity to both sides.\\n\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        keys = [-math.inf] + [idx for idx, num in enumerate(nums) if num == key] + [math.inf]\\n        N = len(nums)\\n        res = []\\n        left = 0\\n        \\n        for i in range(N):\\n            if i - keys[left] <= k or keys[left + 1] - i <= k:\\n                res.append(i)\\n            if keys[left + 1] == i:\\n                left += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        keys = [-math.inf] + [idx for idx, num in enumerate(nums) if num == key] + [math.inf]\\n        N = len(nums)\\n        res = []\\n        left = 0\\n        \\n        for i in range(N):\\n            if i - keys[left] <= k or keys[left + 1] - i <= k:\\n                res.append(i)\\n            if keys[left + 1] == i:\\n                left += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844437,
                "title": "easy-to-understand-elegant-python-code",
                "content": "Linear Scan , add to a set and sort it in very end\\n\\n```\\ndef findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n\\tres = set()\\n\\tfor i, num in enumerate(nums):\\n\\t\\tfor j, _ in enumerate(nums):\\n\\t\\t\\tif abs(i - j) <= k and num == key:\\n\\t\\t\\t\\tres.add(j)\\n\\treturn sorted(list(res))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n\\tres = set()\\n\\tfor i, num in enumerate(nums):\\n\\t\\tfor j, _ in enumerate(nums):\\n\\t\\t\\tif abs(i - j) <= k and num == key:\\n\\t\\t\\t\\tres.add(j)\\n\\treturn sorted(list(res))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1844330,
                "title": "2200-c-o-n-solution",
                "content": "* Approach:\\n* \\tCreate 2 vectors 1 for storing ans, another for storing nums[i] == key.\\n* \\tUsing loop storing all indices which value is equal to key.\\n* \\tUsing another loop find indices following given condition\\n* \\t\\t-> |i-j| <= k and nums[j] == keys then storing i in ans vector.\\n* \\t\\t-> i>j and |i-j| > k then move next index that vaue is equal to key.\\n* \\t\\tTime Complexity = O(N)\\n* \\t\\tSpace Complexity = O(2N)\\n* \\t\\t**\\n\\t\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) \\n    {\\n        vector<int> ans, equal;\\n        \\n\\t\\t//traversing through nums and put nums[i]==key into the vector\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==key)\\n                equal.push_back(i);\\n        }\\n        \\n        if(!equal.size()) return ans;\\n\\t\\t//j for traversing through vector of indices which value is equal to key\\n        int j=0;\\n        \\n\\t\\t//\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(i > equal[j] && abs(i-equal[j]) > k && j<equal.size()-1)\\n            {\\n                j++;\\n            }\\n            \\n            if(abs(i-equal[j]) <= k)\\n                ans.push_back(i);   \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) \\n    {\\n        vector<int> ans, equal;\\n        \\n\\t\\t//traversing through nums and put nums[i]==key into the vector\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==key)\\n                equal.push_back(i);\\n        }\\n        \\n        if(!equal.size()) return ans;\\n\\t\\t//j for traversing through vector of indices which value is equal to key\\n        int j=0;\\n        \\n\\t\\t//\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(i > equal[j] && abs(i-equal[j]) > k && j<equal.size()-1)\\n            {\\n                j++;\\n            }\\n            \\n            if(abs(i-equal[j]) <= k)\\n                ans.push_back(i);   \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844238,
                "title": "java-clean-code-linear",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        //flagging those who should be in result\\n        boolean flag[] = new boolean[1001];\\n        \\n\\t\\t//O(N * K)\\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            //if we found the key\\n            if (nums[i] == key) {\\n                \\n                //flag range  of (i - k, i + k)\\n                int j = i - k > 0 ? i - k : 0;\\n                for (; j <= i + k  && j < nums.length; j++) {\\n                    flag[j] =true;\\n                }\\n            }\\n        }\\n        \\n        //pack up\\n        //add flagged nums in list\\n        List<Integer> list = new ArrayList<Integer>();\\n        for (int i = 0; i < 1001; i++) {\\n            if (flag[i]) {\\n                list.add(i);\\n        \\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\\n\\nTC : O(N * K)\\nSC : O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        //flagging those who should be in result\\n        boolean flag[] = new boolean[1001];\\n        \\n\\t\\t//O(N * K)\\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            //if we found the key\\n            if (nums[i] == key) {\\n                \\n                //flag range  of (i - k, i + k)\\n                int j = i - k > 0 ? i - k : 0;\\n                for (; j <= i + k  && j < nums.length; j++) {\\n                    flag[j] =true;\\n                }\\n            }\\n        }\\n        \\n        //pack up\\n        //add flagged nums in list\\n        List<Integer> list = new ArrayList<Integer>();\\n        for (int i = 0; i < 1001; i++) {\\n            if (flag[i]) {\\n                list.add(i);\\n        \\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844170,
                "title": "java-code-hashset",
                "content": "\\n```\\n    //contest ANS ::::: 1\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                int from = 0, till = 0;//just initialising you could do anything with it;\\n                from = Math.max((i - k), 0);\\n                till = Math.min((i + k), nums.length - 1);\\n                for (int j = from; j <= till; j++) set.add(j);\\n            }\\n        }\\n        for (int i : set) list.add(i);\\n        Collections.sort(list);\\n\\n        return list;\\n    }\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    //contest ANS ::::: 1\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                int from = 0, till = 0;//just initialising you could do anything with it;\\n                from = Math.max((i - k), 0);\\n                till = Math.min((i + k), nums.length - 1);\\n                for (int j = from; j <= till; j++) set.add(j);\\n            }\\n        }\\n        for (int i : set) list.add(i);\\n        Collections.sort(list);\\n\\n        return list;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844159,
                "title": "javascript-easy-to-understand-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    \\n    let ind = [];\\n    let ans = [];\\n    \\n    nums.forEach((val, i) => {\\n       if (val == key) {\\n           ind.push(i);\\n       } \\n    });\\n    \\n    let temp = new Set();\\n    for (let i = 0; i < ind.length; i++) {\\n        let mn = Math.max(ind[i]-k, 0);\\n        let mx = Math.min(Math.abs(ind[i]+k), nums.length-1);\\n    \\n        for (let j = mn; j <= mx; j++) {\\n            temp.add(j);\\n        } \\n    }\\n    \\n    return [...temp];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    \\n    let ind = [];\\n    let ans = [];\\n    \\n    nums.forEach((val, i) => {\\n       if (val == key) {\\n           ind.push(i);\\n       } \\n    });\\n    \\n    let temp = new Set();\\n    for (let i = 0; i < ind.length; i++) {\\n        let mn = Math.max(ind[i]-k, 0);\\n        let mx = Math.min(Math.abs(ind[i]+k), nums.length-1);\\n    \\n        for (let j = mn; j <= mx; j++) {\\n            temp.add(j);\\n        } \\n    }\\n    \\n    return [...temp];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844133,
                "title": "easy-o-n-solution-using-vector",
                "content": "\\n\\n     int n=nums.size();\\n        vector<int>vt1(n,1001);\\n        int prev=10001;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==key){\\n               prev=i;\\n            }\\n            vt1[i]=min(abs(i-prev),vt1[i]);\\n        }\\n        prev=10001;\\n         for(int i=n-1; i>=0; i--){\\n             \\n            if(nums[i]==key){\\n                \\n               prev=i;\\n        \\n            }\\n             \\n            vt1[i]=min(abs(i-prev),vt1[i]);\\n        }\\n        vector<int>vt2;\\n        for(int i=0; i<nums.size(); i++){\\n            \\n           if(vt1[i]<=k){\\n               \\n              vt2.push_back(i);\\n               \\n            }\\n        }\\n        \\n        return vt2;int n=nums.size();\\n        vector<int>vt1(n,1001);\\n        int prev=10001;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==key){\\n               prev=i;\\n            }\\n            vt1[i]=min(abs(i-prev),vt1[i]);\\n        }\\n        prev=10001;\\n         for(int i=n-1; i>=0; i--){\\n             \\n            if(nums[i]==key){\\n                \\n               prev=i;\\n        \\n            }\\n             \\n            vt1[i]=min(abs(i-prev),vt1[i]);\\n        }\\n        vector<int>vt2;\\n        for(int i=0; i<nums.size(); i++){\\n            \\n           if(vt1[i]<=k){\\n               \\n              vt2.push_back(i);\\n               \\n            }\\n        }\\n        \\n        return vt2;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\n     int n=nums.size();\\n        vector<int>vt1(n,1001);\\n        int prev=10001;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==key){\\n               prev=i;\\n            }\\n            vt1[i]=min(abs(i-prev),vt1[i]);\\n        }\\n        prev=10001;\\n         for(int i=n-1; i>=0; i--){\\n             \\n            if(nums[i]==key){\\n                \\n               prev=i;\\n        \\n            }\\n             \\n            vt1[i]=min(abs(i-prev),vt1[i]);\\n        }\\n        vector<int>vt2;\\n        for(int i=0; i<nums.size(); i++){\\n            \\n           if(vt1[i]<=k){\\n               \\n              vt2.push_back(i);\\n               \\n            }\\n        }\\n        \\n        return vt2;int n=nums.size();\\n        vector<int>vt1(n,1001);\\n        int prev=10001;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==key){\\n               prev=i;\\n            }\\n            vt1[i]=min(abs(i-prev),vt1[i]);\\n        }\\n        prev=10001;\\n         for(int i=n-1; i>=0; i--){\\n             \\n            if(nums[i]==key){\\n                \\n               prev=i;\\n        \\n            }\\n             \\n            vt1[i]=min(abs(i-prev),vt1[i]);\\n        }\\n        vector<int>vt2;\\n        for(int i=0; i<nums.size(); i++){\\n            \\n           if(vt1[i]<=k){\\n               \\n              vt2.push_back(i);\\n               \\n            }\\n        }\\n        \\n        return vt2;",
                "codeTag": "Unknown"
            },
            {
                "id": 1844096,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        List<Integer> result=new ArrayList<>();\\n              \\n        List<Integer> keyIndex=new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==key)\\n           {   \\n               keyIndex.add(i);                                  // Get All keys index present in nums\\n           }\\n        }\\n              \\n        for(int i=0;i<nums.length;i++){\\n           for(int j:keyIndex){\\n               if(Math.abs(i-j)<=k){      \\n                    result.add(i);\\n                    break;\\n               }      \\n           }    \\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        List<Integer> result=new ArrayList<>();\\n              \\n        List<Integer> keyIndex=new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==key)\\n           {   \\n               keyIndex.add(i);                                  // Get All keys index present in nums\\n           }\\n        }\\n              \\n        for(int i=0;i<nums.length;i++){\\n           for(int j:keyIndex){\\n               if(Math.abs(i-j)<=k){      \\n                    result.add(i);\\n                    break;\\n               }      \\n           }    \\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954362,
                "title": "simple-cpp",
                "content": "vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n           vector<int> ans;\\n    for(int i=0;i<nums.size();i++){\\n        for(int j=0;j<nums.size();j++){\\n            //if found atleast one index , break and save\\n            if(abs(i-j)<=k and nums[j]==key){\\n                ans.push_back(i);\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n           vector<int> ans;\\n    for(int i=0;i<nums.size();i++){\\n        for(int j=0;j<nums.size();j++){\\n            //if found atleast one index , break and save\\n            if(abs(i-j)<=k and nums[j]==key){\\n                ans.push_back(i);\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1876576,
                "title": "java-o-n-beats-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> result = new ArrayList();\\n        int lastIncluded=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==key){\\n            int from=Math.max(i-k , lastIncluded+1);\\n            int to=Math.min(i+k , nums.length-1);\\n             for(int j=from;j<=to;j++){\\n                     result.add(j);\\n             }\\n            \\n            lastIncluded=to;\\n            }\\n        }\\n      return result;  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> result = new ArrayList();\\n        int lastIncluded=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==key){\\n            int from=Math.max(i-k , lastIncluded+1);\\n            int to=Math.min(i+k , nums.length-1);\\n             for(int j=from;j<=to;j++){\\n                     result.add(j);\\n             }\\n            \\n            lastIncluded=to;\\n            }\\n        }\\n      return result;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850967,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> list=new ArrayList<>();\\n        int n=nums.length;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(Math.abs(i-j)<=k && nums[j]==key){\\n                    list.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> list=new ArrayList<>();\\n        int n=nums.length;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(Math.abs(i-j)<=k && nums[j]==key){\\n                    list.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849656,
                "title": "simple-javascript-solution-time-o-n-2-space-o-n",
                "content": "```javascript\\nfunction findKDistantIndices (nums, key, k) {\\n  const result = new Set() \\n    \\n  for (let i = 0; i < nums.length; i++) {\\n    for (let j = 0; j < nums.length; j++) {\\n      if (nums[j] === key && Math.abs(i - j) <= k) {\\n          result.add(i)\\n      }\\n    }\\n  }\\n  return Array.from(result)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```javascript\\nfunction findKDistantIndices (nums, key, k) {\\n  const result = new Set() \\n    \\n  for (let i = 0; i < nums.length; i++) {\\n    for (let j = 0; j < nums.length; j++) {\\n      if (nums[j] === key && Math.abs(i - j) <= k) {\\n          result.add(i)\\n      }\\n    }\\n  }\\n  return Array.from(result)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1847962,
                "title": "python-solution-with-explanation",
                "content": "Here in this code I have implemented its brute force concept for better understanding .\\nHere in this we first store all indexes where value is equal to key in list l , then we iterate over the entire nums list for every index value and at the same time iterate over every value in list l to check for every possible scenarios , so that we don\\'t miss any hidden cases . For better understanding remove \"#\"\\nin the code and run it once .\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        l=[]\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                l.append(i)\\n        \\n        if len(l)==0:\\n            return []\\n        \\n        lst=[]\\n        for i in range(len(nums)):\\n            for j in l:\\n                if abs(i-j)<=k:\\n                    #print(nums[i:j+1],nums[j:i+1],i,j)\\n                    if i<j and key in nums[i:j+1]:\\n                        lst.append(i)\\n                        break\\n                    if i>=j and key in nums[j:i+1]:\\n                        lst.append(i)\\n                        break\\n        return lst\\n```\\nIf u understood the code then plz....UPVOTE....Thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        l=[]\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                l.append(i)\\n        \\n        if len(l)==0:\\n            return []\\n        \\n        lst=[]\\n        for i in range(len(nums)):\\n            for j in l:\\n                if abs(i-j)<=k:\\n                    #print(nums[i:j+1],nums[j:i+1],i,j)\\n                    if i<j and key in nums[i:j+1]:\\n                        lst.append(i)\\n                        break\\n                    if i>=j and key in nums[j:i+1]:\\n                        lst.append(i)\\n                        break\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845733,
                "title": "c-brute-force-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++) {\\n            for(int j = 0; j < nums.size(); j++) {\\n                if(abs(i - j) <= k && nums[j] == key) {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++) {\\n            for(int j = 0; j < nums.size(); j++) {\\n                if(abs(i - j) <= k && nums[j] == key) {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845615,
                "title": "c-easy-using-set-beginners-friendly",
                "content": "// Please Upvote if it helps\\u2B06\\uFE0F\\n\\n**Approach**\\n* Created a Set \\n* Iterate over the array\\n* If founded key , then check the condiiotn abs(i-j) for all other indices\\n* Store all indices in a vector\\n* Sort the vector before returning it\\n\\n**TC : O(N square)**\\n**SC: O(N)**\\n\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k)\\n    {\\n        set<int> st;        // for storing the k distant indices (in set there is no duplicacy)\\n        \\n        // iterating over the given array\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // if element is our key \\n            if(nums[i] == key)\\n            {\\n                // just check for the all other indices that they satisfies the condition or not\\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(abs(i-j) <= k)\\n                    {\\n                        st.insert(j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // created a vector for storing the ans\\n        vector<int> ans;\\n        for(int i : st)\\n        {\\n            ans.push_back(i);\\n        }\\n        \\n        // sort the vector in increasing order before returning it\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n**TC : O(N square)**\\n**SC: O(1)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) \\n    {\\n        vector<int> ans;\\n        \\n        // make one pointer to point some index\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // make another pointer that will find the index that will satisfy the given conditions\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                // if both the conditions are satisfied\\n                //if found atleast one index , break and save\\n                if(abs(i-j)<=k && nums[j]==key)\\n                {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```\\n\\n// Please Upvote if it helps\\u2B06\\uFE0F",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k)\\n    {\\n        set<int> st;        // for storing the k distant indices (in set there is no duplicacy)\\n        \\n        // iterating over the given array\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // if element is our key \\n            if(nums[i] == key)\\n            {\\n                // just check for the all other indices that they satisfies the condition or not\\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    if(abs(i-j) <= k)\\n                    {\\n                        st.insert(j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // created a vector for storing the ans\\n        vector<int> ans;\\n        for(int i : st)\\n        {\\n            ans.push_back(i);\\n        }\\n        \\n        // sort the vector in increasing order before returning it\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) \\n    {\\n        vector<int> ans;\\n        \\n        // make one pointer to point some index\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // make another pointer that will find the index that will satisfy the given conditions\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                // if both the conditions are satisfied\\n                //if found atleast one index , break and save\\n                if(abs(i-j)<=k && nums[j]==key)\\n                {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845200,
                "title": "java-detail-explanation-merge-intervals-variation-o-n-time-o-n-space-3ms-solution",
                "content": "We can think of this solution as variation of [Merge Interval](https://leetcode.com/problems/merge-intervals/) question where instead of just merging intervals, we also need to list all values between intervals.\\n\\nNow, the question is how to get intervals. As given in the question, we need to list out all indexes that satisfy  `|i - j| <= k`. Which means that all indexes are accessible that are `k` distance away on left and right side of `nums[key]`.\\n\\n**Approach**\\nPass 1: **Intervals**:\\tWe don\\'t need to create intervals but we can simply store count of where each intervals start and end. Just go throgh array and for each `nums[i] == key` \\n* increase count `Math.max(0, i-k)` in the start array to mark as start of intervals\\n* decrese count at `Math.min(nums.length-1, i+k)` in the end array marking as end of interval.\\n \\nPass 2:  Go through each start and end intervlas arrays. If your current index is in atleast one of the interval, add in the result. \\n\\n**Example**\\nnums =` [6,3,4,9,3,9,5]`, key = 9, k = 2\\n\\nWe have nums[i] == key for i=3 and i=5. So, we will increase the count for i-2 and decrese the count at i+2;\\nFor i=3  :     start = `[0, 1, 0, 0, 0, 0, 0]`;  end = `[0, 0, 0, 0, 0, -1, 0]`\\nAfter i=5;  start = `[0, 1, 0, 1, 0, 0, 0]`; end = `[0, 0, 0, 0, 0, -1, -1]`\\n\\nWhen you are at i=0, your count = 0, don\\'t add in the result.\\nFor i=1 and i=2, count = 1, add in result.\\nFor i=3 and i=4, count = 2, add in result.  //It\\'s overlap of intervals\\nFor i=5, count = 1, add in result\\nfor i=6, count = 1, add in result. Since the intervals are inclusive, always remove from `end` at the end.\\n\\nfinal output: `[1, 2, 3, 4, 5, 6]`\\n\\n**Solution**:\\n\\n```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n       List<Integer> result = new ArrayList<>();      \\n\\t   int[] start = new int[nums.length];\\n        int[] end = new int[nums.length];\\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] != key)\\n                continue;\\n            int min = Math.max(0, i-k);  //Prevent negative index\\n            int max = Math.min(nums.length-1, i+k);  //Prevent overflow \\n            start[min]++;\\n            end[max]--;\\n        }       \\n\\t\\t// Variable to keep track of index inside at least one interval. \\n\\t\\t// If positive, we are in, if 0, we are out.\\n        int reachable = 0;  \\n        for(int i=0; i<nums.length; i++) {\\n            reachable += start[i];\\n            if(reachable > 0)\\n                result.add(i);\\n            reachable += end[i];\\n        }\\n        \\n        return result;\\n    }\\n```\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(N)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n       List<Integer> result = new ArrayList<>();      \\n\\t   int[] start = new int[nums.length];\\n        int[] end = new int[nums.length];\\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] != key)\\n                continue;\\n            int min = Math.max(0, i-k);  //Prevent negative index\\n            int max = Math.min(nums.length-1, i+k);  //Prevent overflow \\n            start[min]++;\\n            end[max]--;\\n        }       \\n\\t\\t// Variable to keep track of index inside at least one interval. \\n\\t\\t// If positive, we are in, if 0, we are out.\\n        int reachable = 0;  \\n        for(int i=0; i<nums.length; i++) {\\n            reachable += start[i];\\n            if(reachable > 0)\\n                result.add(i);\\n            reachable += end[i];\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844196,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        set<int> s;\\n        vector<int> v;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            if(nums[i] == key)\\n            for(int j = 0 ; j < nums.size() ; j++){\\n                if(abs(i-j) <= k){\\n                    s.insert(j);\\n                }\\n            }\\n        }\\n        for(auto x : s){\\n            v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        set<int> s;\\n        vector<int> v;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            if(nums[i] == key)\\n            for(int j = 0 ; j < nums.size() ; j++){\\n                if(abs(i-j) <= k){\\n                    s.insert(j);\\n                }\\n            }\\n        }\\n        for(auto x : s){\\n            v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844127,
                "title": "c-use-set-to-store-distinct-elements",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n        \\n        set<int> temp;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==key){\\n                for(int j=0; j<n; j++){\\n                    if(abs(i-j)<=k)\\n                        temp.insert(j);\\n                }\\n            }   \\n        }\\n        \\n        vector<int> ans;\\n        for(auto &it: temp)\\n            ans.push_back(it);\\n        \\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if u like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n        \\n        set<int> temp;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==key){\\n                for(int j=0; j<n; j++){\\n                    if(abs(i-j)<=k)\\n                        temp.insert(j);\\n                }\\n            }   \\n        }\\n        \\n        vector<int> ans;\\n        for(auto &it: temp)\\n            ans.push_back(it);\\n        \\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690014,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> al = new ArrayList();\\n        for(int i = 0; i < nums.length; i++) {\\n            int index = -1;\\n            for(int j = 0; j < nums.length; j++) {\\n                if(nums[j] == key && Math.abs(i - j) <= k) {\\n                    index = i;\\n                }\\n            }\\n            if(index != -1) {\\n                al.add(index);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> al = new ArrayList();\\n        for(int i = 0; i < nums.length; i++) {\\n            int index = -1;\\n            for(int j = 0; j < nums.length; j++) {\\n                if(nums[j] == key && Math.abs(i - j) <= k) {\\n                    index = i;\\n                }\\n            }\\n            if(index != -1) {\\n                al.add(index);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359787,
                "title": "find-all-k-distant-indices-in-an-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> indices_of_key;\\n        vector<int> ans;\\n        int i, j;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n                indices_of_key.push_back(i);\\n            }\\n        }\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            for(j=0 ; j<indices_of_key.size() ; j++)\\n            {\\n                if(abs(i-indices_of_key[j])<=k)\\n                {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> indices_of_key;\\n        vector<int> ans;\\n        int i, j;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==key)\\n            {\\n                indices_of_key.push_back(i);\\n            }\\n        }\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            for(j=0 ; j<indices_of_key.size() ; j++)\\n            {\\n                if(abs(i-indices_of_key[j])<=k)\\n                {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167337,
                "title": "easy-solution-without-redundant-iterations",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    const keyIndicies = nums.reduce((acc, num, i) => num === key ? [...acc, i] : acc, []);\\n    const res = [];\\n\\n    let lastIndex = 0;\\n    for (const index of keyIndicies) {\\n        const startIndex = Math.max(lastIndex, index - k);\\n        lastIndex = Math.min(index + k, nums.length - 1) + 1;\\n\\n        for (let i = startIndex; i < lastIndex; i++) {\\n            res.push(i);\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    const keyIndicies = nums.reduce((acc, num, i) => num === key ? [...acc, i] : acc, []);\\n    const res = [];\\n\\n    let lastIndex = 0;\\n    for (const index of keyIndicies) {\\n        const startIndex = Math.max(lastIndex, index - k);\\n        lastIndex = Math.min(index + k, nums.length - 1) + 1;\\n\\n        for (let i = startIndex; i < lastIndex; i++) {\\n            res.push(i);\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3062399,
                "title": "easy-c-solution-brute-force",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            int a = -1;\\n            for(int j=0;j<nums.size();j++){\\n                if(abs(i-j)<=k && nums[j]==key)\\n                 a=i;\\n            }\\n            if(a!=-1) \\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            int a = -1;\\n            for(int j=0;j<nums.size();j++){\\n                if(abs(i-j)<=k && nums[j]==key)\\n                 a=i;\\n            }\\n            if(a!=-1) \\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846856,
                "title": "easiest-solution-c-plus-plus-easy-to-understand-simplest-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            int a = -1;\\n            for(int j=0;j<nums.size();j++){\\n                if(abs(i-j)<=k && nums[j]==key) a=i;\\n            }\\n            if(a!=-1) ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            int a = -1;\\n            for(int j=0;j<nums.size();j++){\\n                if(abs(i-j)<=k && nums[j]==key) a=i;\\n            }\\n            if(a!=-1) ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838117,
                "title": "java-using-linkedhashset",
                "content": "1. I use LinkedHashSet to keep the order of indices (which is required by the description of the problem) and keep the indices unique.\\n2. I look for a number in the array equal to key. When I find it I add indices from i - k to i + k.\\n3. end = Math.min(i + k, nums.length - 1) - means that if i + k is more than nums.length - 1, then end is equal to nums.length - 1, else end = i + k;\\n4. j = Math.max(i - k, 0) - here the logic is the same: if i - k is less than 0, then j = 0, else j = i - k;\\n5. And in the end I convert set to ArrayList.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        Set<Integer> set = new LinkedHashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                int end = Math.min(i + k, nums.length - 1);\\n                for (int j = Math.max(i - k, 0); j <= end; j++) {\\n                    set.add(j);\\n                }\\n            }\\n        }\\n        return new ArrayList<>(set);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        Set<Integer> set = new LinkedHashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                int end = Math.min(i + k, nums.length - 1);\\n                for (int j = Math.max(i - k, 0); j <= end; j++) {\\n                    set.add(j);\\n                }\\n            }\\n        }\\n        return new ArrayList<>(set);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541334,
                "title": "golang-o-n",
                "content": "```go\\nfunc findKDistantIndices(nums []int, key int, k int) []int {\\n    var res []int\\n    resMap := make(map[int]struct{})\\n\\n    for i, v := range nums {\\n        if v == key {         \\n            for j := i - k; j <= i + k; j++ {\\n                if j < 0 || j >= len(nums) {\\n                    continue\\n                }\\n\\n                if _, ok := resMap[j]; !ok {\\n                    resMap[j] = struct{}{}\\n                    res = append(res, j)   \\n                }\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc findKDistantIndices(nums []int, key int, k int) []int {\\n    var res []int\\n    resMap := make(map[int]struct{})\\n\\n    for i, v := range nums {\\n        if v == key {         \\n            for j := i - k; j <= i + k; j++ {\\n                if j < 0 || j >= len(nums) {\\n                    continue\\n                }\\n\\n                if _, ok := resMap[j]; !ok {\\n                    resMap[j] = struct{}{}\\n                    res = append(res, j)   \\n                }\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2363675,
                "title": "python-simple-solution-tc-o-n",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        s = [0]*len(nums)\\n        \\n        x = -inf\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                x = i\\n            if i-x<=k:\\n                s[i] = 1\\n                \\n        x = inf\\n        for i in range(len(nums)-1,-1,-1):\\n            if nums[i] == key:\\n                x = i\\n            if x-i<=k:\\n                s[i] = 1\\n        \\n        return [i for i in range(len(s)) if s[i]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        s = [0]*len(nums)\\n        \\n        x = -inf\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                x = i\\n            if i-x<=k:\\n                s[i] = 1\\n                \\n        x = inf\\n        for i in range(len(nums)-1,-1,-1):\\n            if nums[i] == key:\\n                x = i\\n            if x-i<=k:\\n                s[i] = 1\\n        \\n        return [i for i in range(len(s)) if s[i]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353287,
                "title": "java-simple-solution-time-complexity-o-n",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] arr1, int key, int k) {\\n        List<Integer> l1= new ArrayList<Integer>();\\n        List<Integer> index =new ArrayList<Integer>();\\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            if(arr1[i]==key)\\n            {\\n                index.add(i);\\n            }\\n        }\\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            for(int j=0;j<index.size();j++)\\n            {\\n                int val=index.get(j);\\n                int res=Math.abs(i-val);    \\n                if(res<=k)\\n                {\\n                    l1.add(i);\\n                    break;\\n                }\\n            }            \\n        }\\n        return l1;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> findKDistantIndices(int[] arr1, int key, int k) {\\n        List<Integer> l1= new ArrayList<Integer>();\\n        List<Integer> index =new ArrayList<Integer>();\\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            if(arr1[i]==key)\\n            {\\n                index.add(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2328738,
                "title": "simple-brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        \\n        vector<int>v;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            for(int j= 0; j<nums.size(); j++)\\n            {\\n                if(abs(i-j) <= k && nums[j] == key)\\n                {\\n                    v.push_back(i);\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        \\n        vector<int>v;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            for(int j= 0; j<nums.size(); j++)\\n            {\\n                if(abs(i-j) <= k && nums[j] == key)\\n                {\\n                    v.push_back(i);\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2253007,
                "title": "python-easy-solution-without-using-external-function-fast-and-single-pass",
                "content": "Time :0(n) | Space : 0(n)\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        \\n        res_idx = set()\\n        n = len(nums)\\n        for idx in range(n):\\n            if key==nums[idx]:\\n                sp = idx - k if idx - k > 0 else 0\\n                ep = idx + k if idx + k < n else n-1\\n                for val in range(sp,ep+1):\\n                    res_idx.add(val)\\n                \\n        return list(res_idx)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Time :0(n) | Space : 0(n)\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        \\n        res_idx = set()\\n        n = len(nums)\\n        for idx in range(n):\\n            if key==nums[idx]:\\n                sp = idx - k if idx - k > 0 else 0\\n                ep = idx + k if idx + k < n else n-1\\n                for val in range(sp,ep+1):\\n                    res_idx.add(val)\\n                \\n        return list(res_idx)",
                "codeTag": "Java"
            },
            {
                "id": 1946245,
                "title": "simple-c-two-pointers-o-n-with-explanation",
                "content": "1. Start with **both l and h = 0**.\\n2. Keep incrementing h till **key is found**.\\n3. Once key is found, keep **incrementing l** till it covers all indices **within k distance on both sides of h**.\\n4. Once **|h - l| becomes larger than k**, increment **h** and keep **l** the same.\\n5. Repeat\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int l = 0, h = 0, n = nums.size();\\n        vector<int> res;\\n        while(h < n){\\n            if(nums[h] == key){ // If element is found\\n                if(abs(h - l) <= k && l < n){ // Check if it\\'s in k distance and l is in bound of array\\n                    res.push_back(l);\\n                    l++; \\n                }\\n                else{                                           \\n                    l>h ? h++ : l++;  // If l has exceded h, increment h (find key again if it exists, no need to reset l because \\n\\t\\t\\t\\t\\t                  //all indices that were in k distance of previous key have been added)\\n                }\\n            }\\n            else{ \\n                h++; // keep incrementing h till key is found\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int l = 0, h = 0, n = nums.size();\\n        vector<int> res;\\n        while(h < n){\\n            if(nums[h] == key){ // If element is found\\n                if(abs(h - l) <= k && l < n){ // Check if it\\'s in k distance and l is in bound of array\\n                    res.push_back(l);\\n                    l++; \\n                }\\n                else{                                           \\n                    l>h ? h++ : l++;  // If l has exceded h, increment h (find key again if it exists, no need to reset l because \\n\\t\\t\\t\\t\\t                  //all indices that were in k distance of previous key have been added)\\n                }\\n            }\\n            else{ \\n                h++; // keep incrementing h till key is found\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935772,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    static ArrayList<Integer> res;\\n    static int[] index;\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        res = new ArrayList<Integer>();\\n        index = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==key&&fun(i,k,nums.length-1))\\n                break;\\n        }\\n        int i=0;\\n        for(int x:index)\\n        {\\n            if(x>0)\\n            res.add(i);\\n            i++;\\n        }\\n        return res;\\n    }\\n    \\n    static boolean fun(int i,int k,int length)\\n    {\\n        int start = Math.max(0,i-k);\\n        int end = Math.min(length,i+k);\\n        for(int j=start;j<=end;j++)\\n            index[j]++;\\n    \\n        if(end==length)\\n            return true;\\n        return false;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/31f89a49-269a-4258-8545-501abea00c05_1649669250.2263286.png)\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    static ArrayList<Integer> res;\\n    static int[] index;\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        res = new ArrayList<Integer>();\\n        index = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==key&&fun(i,k,nums.length-1))\\n                break;\\n        }\\n        int i=0;\\n        for(int x:index)\\n        {\\n            if(x>0)\\n            res.add(i);\\n            i++;\\n        }\\n        return res;\\n    }\\n    \\n    static boolean fun(int i,int k,int length)\\n    {\\n        int start = Math.max(0,i-k);\\n        int end = Math.min(length,i+k);\\n        for(int j=start;j<=end;j++)\\n            index[j]++;\\n    \\n        if(end==length)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935075,
                "title": "one-pass-o-n-time-o-1-extra-space",
                "content": "Once you use find a key and add all elgible indexes, you need not process the indices already added. You can store the prev key index, and whenever you find a key at index i, you can start adding indixes from Math.max(prevKeyIndex+k+1, i-k).\\nThis way you process each index only once.\\n\\n```\\n public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        List<Integer> res = new ArrayList();\\n        int prevKeyIndex = -1;\\n        for (int i = 0; i < nums.length;i++) {\\n            if (nums[i] == key) {\\n                int start = i-k;\\n                int end = i+k;\\n                if (prevKeyIndex != -1) {\\n                    start = Math.max(prevKeyIndex+k+1, start);\\n                }\\n                for (int j=start; j <=end;j++) {\\n                    if (j >= 0 && j < nums.length)\\n                        res.add(j);\\n                }\\n                prevKeyIndex = i;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        \\n        List<Integer> res = new ArrayList();\\n        int prevKeyIndex = -1;\\n        for (int i = 0; i < nums.length;i++) {\\n            if (nums[i] == key) {\\n                int start = i-k;\\n                int end = i+k;\\n                if (prevKeyIndex != -1) {\\n                    start = Math.max(prevKeyIndex+k+1, start);\\n                }\\n                for (int j=start; j <=end;j++) {\\n                    if (j >= 0 && j < nums.length)\\n                        res.add(j);\\n                }\\n                prevKeyIndex = i;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1895259,
                "title": "find-all-k-distance-indices-in-an-array",
                "content": "\\'\\'\\'**we use ans variable for cheacking there is no dublicates indices push in vector \\nits a brute force its  take more than 100ms but work on all test cases .**\\nvector <int v;\\n        int ans=-1;\\n        int i=0,j=nums.size()-1;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=nums.size()-1;j>=0;j--){\\n                if(abs(i-j)<=k && nums[j]==key){\\n                    if(i!=ans){\\n                    v.push_back(i);\\n                        ans=i;\\n                    }\\n                    else\\n                        continue;\\n                }\\n            }\\n        }\\n     return v;\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "\\'\\'\\'**we use ans variable for cheacking there is no dublicates indices push in vector \\nits a brute force its  take more than 100ms but work on all test cases .**\\nvector <int v;\\n        int ans=-1;\\n        int i=0,j=nums.size()-1;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=nums.size()-1;j>=0;j--){\\n                if(abs(i-j)<=k && nums[j]==key){\\n                    if(i!=ans){\\n                    v.push_back(i);\\n                        ans=i;\\n                    }\\n                    else\\n                        continue;\\n                }\\n            }\\n        }\\n     return v;\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1886150,
                "title": "python-3-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        res = []\\n        high = -1\\n        n = len(nums)\\n\\n        for i, num in enumerate(nums):\\n            if num == key:\\n                for j in range(max(high + 1, i - k), min(n, i + k + 1)):\\n                    res.append(j)\\n                high = i + k\\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        res = []\\n        high = -1\\n        n = len(nums)\\n\\n        for i, num in enumerate(nums):\\n            if num == key:\\n                for j in range(max(high + 1, i - k), min(n, i + k + 1)):\\n                    res.append(j)\\n                high = i + k\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1876262,
                "title": "c-two-pointers-easy-to-understand-single-pass-o-n-time",
                "content": "```cpp\\nvector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n\\tvector<int> ans;\\n\\n\\t// Let i = index tracker and j = (last k-index added to `ans`) + 1\\n\\tfor(int i = 0, j = 0; i < nums.size(); ++i)\\n\\t\\tif(nums[i] == key) {\\n\\t\\t\\tj = max(j, i - k); // find the next k-index to add\\n\\t\\t\\twhile(j < nums.size() && j <= i + k) // add k-index\\'s till i + k\\n\\t\\t\\t\\tans.push_back(j++);\\n\\t\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n\\tvector<int> ans;\\n\\n\\t// Let i = index tracker and j = (last k-index added to `ans`) + 1\\n\\tfor(int i = 0, j = 0; i < nums.size(); ++i)\\n\\t\\tif(nums[i] == key) {\\n\\t\\t\\tj = max(j, i - k); // find the next k-index to add\\n\\t\\t\\twhile(j < nums.size() && j <= i + k) // add k-index\\'s till i + k\\n\\t\\t\\t\\tans.push_back(j++);\\n\\t\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1853807,
                "title": "java-2ms-without-sorting",
                "content": "```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> indices = new ArrayList<>();\\n        int i=0;\\n        for(int j=0; j<nums.length; j++) {\\n            if(nums[j] == key) {\\n                if(indices.size() == 0) {\\n                    i=0;\\n                } else {\\n                    i=indices.get(indices.size()-1)+1;\\n                }\\n                i=Math.max(j-k,i);\\n                int end = Math.min(j+k,nums.length-1);\\n                    \\n                for(; i<=end; i++) {\\n                    indices.add(i);                        \\n                }\\n            }\\n        }\\n        return indices;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> indices = new ArrayList<>();\\n        int i=0;\\n        for(int j=0; j<nums.length; j++) {\\n            if(nums[j] == key) {\\n                if(indices.size() == 0) {\\n                    i=0;\\n                } else {\\n                    i=indices.get(indices.size()-1)+1;\\n                }\\n                i=Math.max(j-k,i);\\n                int end = Math.min(j+k,nums.length-1);\\n                    \\n                for(; i<=end; i++) {\\n                    indices.add(i);                        \\n                }\\n            }\\n        }\\n        return indices;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1850392,
                "title": "python-o-n-solution-find-index-range-around-key",
                "content": "Similar to the concept of absolute value, find the index within the distance of *k* from the index of given key:\\n\\n![image](https://assets.leetcode.com/users/images/6d556ea7-9891-4472-b334-e2bd7d0f0435_1647397141.1234796.png)\\nSuppose the red line is a list. The *k*-distance index of key1 is within the range of (j-k, j+k+1). \\n\\n```\\nkc = [i for i in range(len(nums)) if nums[i] == key]\\nans = []\\nfor j in kc:\\n\\tans += list(range(max(j-k, 0), min(j+k+1, len(nums))))\\n\\nreturn list(set(ans))\\n```",
                "solutionTags": [],
                "code": "```\\nkc = [i for i in range(len(nums)) if nums[i] == key]\\nans = []\\nfor j in kc:\\n\\tans += list(range(max(j-k, 0), min(j+k+1, len(nums))))\\n\\nreturn list(set(ans))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1846739,
                "title": "python3-scan",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/66f7e5045d1b91897d8dbb425b6af153e6802c59) for solutions of weekly 284. \\n\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        ans = []\\n        ii = 0\\n        for i, x in enumerate(nums): \\n            if x == key: \\n                lo, hi = max(ii, i-k), min(i+k+1, len(nums))\\n                ans.extend(list(range(lo, hi)))\\n                ii = hi\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        ans = []\\n        ii = 0\\n        for i, x in enumerate(nums): \\n            if x == key: \\n                lo, hi = max(ii, i-k), min(i+k+1, len(nums))\\n                ans.extend(list(range(lo, hi)))\\n                ii = hi\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846065,
                "title": "java-two-loops-o-n",
                "content": "- iterate over the array \\n- when the key is found at nums[i], loop j from i-k to i+k to add to answer (remember j=i+k as jMax)\\n- when you find the next key, don\\'t loop from i-k, but from jMax i.e. max(i-k, jMax), to avoid adding same indices again\\n```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\tList<Integer> ans= new ArrayList<>();\\n\\tfor(int n= nums.length, i=0, j, jMax= 0; i<n && jMax<n; i++)\\n\\t\\tif(nums[i]==key)\\n\\t\\t\\tfor(j= Math.max(jMax, i-k), jMax= Math.min(n, i+k+1); j<jMax; j++)\\n\\t\\t\\t\\tans.add(j);\\n\\treturn ans;\\n}",
                "solutionTags": [],
                "code": "- iterate over the array \\n- when the key is found at nums[i], loop j from i-k to i+k to add to answer (remember j=i+k as jMax)\\n- when you find the next key, don\\'t loop from i-k, but from jMax i.e. max(i-k, jMax), to avoid adding same indices again\\n```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\tList<Integer> ans= new ArrayList<>();\\n\\tfor(int n= nums.length, i=0, j, jMax= 0; i<n && jMax<n; i++)\\n\\t\\tif(nums[i]==key)\\n\\t\\t\\tfor(j= Math.max(jMax, i-k), jMax= Math.min(n, i+k+1); j<jMax; j++)\\n\\t\\t\\t\\tans.add(j);\\n\\treturn ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1845257,
                "title": "find-all-k-distance-indices-in-an-array-80-faster-solution",
                "content": "class Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n     \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t    l = []\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                l.append(i)\\n  \\n        ans = set()\\n        if len(nums) == len(l):\\n            for i in range(len(nums)):\\n                ans.add(i)\\n\\t\\t\\t\\t\\n        else:       \\n            if max(l)+k+1 <= len(nums):\\n                t = max(l)+k+1\\n            else:\\n                t = len(nums)\\n\\t\\t\\t\\t\\n            for i in l:\\n                for  j in range(t):\\n                    if(abs(j-i)<=k):\\n                        ans.add(i)\\n                        ans.add(j)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "class Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n     \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t    l = []\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                l.append(i)\\n  \\n        ans = set()\\n        if len(nums) == len(l):\\n            for i in range(len(nums)):\\n                ans.add(i)\\n\\t\\t\\t\\t\\n        else:       \\n            if max(l)+k+1 <= len(nums):\\n                t = max(l)+k+1\\n            else:\\n                t = len(nums)\\n\\t\\t\\t\\t\\n            for i in l:\\n                for  j in range(t):\\n                    if(abs(j-i)<=k):\\n                        ans.add(i)\\n                        ans.add(j)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1845210,
                "title": "find-all-k-distance-easy-understandable",
                "content": "vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=max(0,i-k);\\n            for(j; j<n&&j<=i+k;j++)\\n            {\\n                if(nums[j]==key)\\n                {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=max(0,i-k);\\n            for(j; j<n&&j<=i+k;j++)\\n            {\\n                if(nums[j]==key)\\n                {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1844914,
                "title": "simple-python-time-o-n-space-o-number-of-keys-without-sorting",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n       \\n\\t    l = len(nums)\\n        index = [i for i in range(l) if nums[i] == key]\\n        res =[]\\n        pointer = 0\\n        x = len(index)\\n        \\n        for i in range(l):\\n            \\n            if i == k+index[pointer] and  pointer+1 < x:\\n                \\n                if abs(i-index[pointer]) <= k:\\n                    res.append(i)\\n                \\n                pointer += 1\\n            \\n            elif i == index[pointer]:\\n                res.append(i)\\n            \\n            elif abs(i-index[pointer]) <= k:\\n                res.append(i)\\n\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n       \\n\\t    l = len(nums)\\n        index = [i for i in range(l) if nums[i] == key]\\n        res =[]\\n        pointer = 0\\n        x = len(index)\\n        \\n        for i in range(l):\\n            \\n            if i == k+index[pointer] and  pointer+1 < x:\\n                \\n                if abs(i-index[pointer]) <= k:\\n                    res.append(i)\\n                \\n                pointer += 1\\n            \\n            elif i == index[pointer]:\\n                res.append(i)\\n            \\n            elif abs(i-index[pointer]) <= k:\\n                res.append(i)\\n\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844788,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int>ans;\\n        unordered_set<int>res;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int mn=INT_MAX;\\n            for(int j=0;j<n;j++){\\n                if(abs(i-j)<=k && nums[i]==key){\\n                    res.insert(j);\\n                }\\n            }\\n        }\\n        for(int x:res)ans.push_back(x);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int>ans;\\n        unordered_set<int>res;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int mn=INT_MAX;\\n            for(int j=0;j<n;j++){\\n                if(abs(i-j)<=k && nums[i]==key){\\n                    res.insert(j);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1844665,
                "title": "brute-force-using-extra-space",
                "content": "class Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n=nums.size();\\n        vector<int> ans;\\n        vector<int> index;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==key){\\n                index.push_back(i);\\n            }\\n        }\\n        if(index.size()==0){\\n            return ans;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<index.size();j++){\\n                if(abs(index[j]-i)<=k){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n=nums.size();\\n        vector<int> ans;\\n        vector<int> index;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==key){\\n                index.push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1844621,
                "title": "javascript-simple-solution-o-n",
                "content": "```\\nvar findKDistantIndices = function(nums, key, k) {\\n    const res = [];\\n    let j = 0;\\n    let i = 0;\\n    while(i < nums.length) {\\n        if(Math.abs(i-j) <= k && nums[j] === key ) {\\n            res.push(i);\\n            i++;\\n        }\\n        if(j - i > k) {\\n            i++;\\n        }\\n        if(nums[j] !== key || i - j > k){\\n            j++;\\n        }\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findKDistantIndices = function(nums, key, k) {\\n    const res = [];\\n    let j = 0;\\n    let i = 0;\\n    while(i < nums.length) {\\n        if(Math.abs(i-j) <= k && nums[j] === key ) {\\n            res.push(i);\\n            i++;\\n        }\\n        if(j - i > k) {\\n            i++;\\n        }\\n        if(nums[j] !== key || i - j > k){\\n            j++;\\n        }\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844620,
                "title": "java-solution-without-sorting",
                "content": "```\\n List<Integer> al = new ArrayList<>();\\n        List<Integer> idx = new ArrayList<>();\\n        \\n        for(int i = 0; i<nums.length ; i++){\\n            if(nums[i] == key){\\n                idx.add(i);\\n            }\\n        }\\n        \\n        for(int i = 0; i<nums.length ; i++){\\n            for(int j = 0; j<idx.size() ; j++){\\n                if(Math.abs(i - idx.get(j)) <= k){\\n                    if(!al.contains(i)) al.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return al;\\n```",
                "solutionTags": [],
                "code": "```\\n List<Integer> al = new ArrayList<>();\\n        List<Integer> idx = new ArrayList<>();\\n        \\n        for(int i = 0; i<nums.length ; i++){\\n            if(nums[i] == key){\\n                idx.add(i);\\n            }\\n        }\\n        \\n        for(int i = 0; i<nums.length ; i++){\\n            for(int j = 0; j<idx.size() ; j++){\\n                if(Math.abs(i - idx.get(j)) <= k){\\n                    if(!al.contains(i)) al.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return al;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844457,
                "title": "c-2200-find-all-k-distant-indices-in-an-array",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans; \\n        for (int i = 0, ii = 0; i < nums.size(); ++i) \\n            if (nums[i] == key) \\n                for (ii = max(ii, i-k); ii <= i+k && ii < nums.size(); ++ii) \\n                    ans.push_back(ii); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans; \\n        for (int i = 0, ii = 0; i < nums.size(); ++i) \\n            if (nums[i] == key) \\n                for (ii = max(ii, i-k); ii <= i+k && ii < nums.size(); ++ii) \\n                    ans.push_back(ii); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844451,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution(object):\\n    def findKDistantIndices(self, nums, key, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type key: int\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        res=[]\\n        for i in range(len(nums)):\\n            if nums[i]==key:\\n                \\n                for j in range(len(nums)):\\n                    if abs(i-j)<=k and j not in res:\\n                        res.append(j)\\n                if len(res)==len(nums):\\n                    return res\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findKDistantIndices(self, nums, key, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type key: int\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        res=[]\\n        for i in range(len(nums)):\\n            if nums[i]==key:\\n                \\n                for j in range(len(nums)):\\n                    if abs(i-j)<=k and j not in res:\\n                        res.append(j)\\n                if len(res)==len(nums):\\n                    return res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844400,
                "title": "python-5-lines",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        ans = set()\\n        for i, num in enumerate(nums):\\n            if num == key:\\n                ans.update(range(max(0, i-k), min(i+k+1, len(nums))))\\n        return sorted(list(res))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        ans = set()\\n        for i, num in enumerate(nums):\\n            if num == key:\\n                ans.update(range(max(0, i-k), min(i+k+1, len(nums))))\\n        return sorted(list(res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844373,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        int startIndex = 0;\\n        List<Integer> kDistantIndices = new ArrayList<>();\\n        for(int idx = 0; idx < nums.length; idx += 1) {\\n            if(nums[idx] == key) {\\n                for(int rangeIdx = Math.max(idx - k, startIndex); rangeIdx <= Math.min(nums.length - 1, idx + k); rangeIdx += 1) {\\n                    kDistantIndices.add(rangeIdx);\\n                }\\n                startIndex = idx + k + 1;\\n            }\\n        }\\n        return kDistantIndices;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        int startIndex = 0;\\n        List<Integer> kDistantIndices = new ArrayList<>();\\n        for(int idx = 0; idx < nums.length; idx += 1) {\\n            if(nums[idx] == key) {\\n                for(int rangeIdx = Math.max(idx - k, startIndex); rangeIdx <= Math.min(nums.length - 1, idx + k); rangeIdx += 1) {\\n                    kDistantIndices.add(rangeIdx);\\n                }\\n                startIndex = idx + k + 1;\\n            }\\n        }\\n        return kDistantIndices;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844346,
                "title": "python-simple-brute-force",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        n = len(nums)\\n        res = set()\\n        for i in range(n):\\n            if nums[i] == key:\\n                for j in range(i-k,i+k+1):\\n                    if j >=0 and j <= n-1:\\n                        res.add(j)\\n        return res    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        n = len(nums)\\n        res = set()\\n        for i in range(n):\\n            if nums[i] == key:\\n                for j in range(i-k,i+k+1):\\n                    if j >=0 and j <= n-1:\\n                        res.add(j)\\n        return res    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844310,
                "title": "c-brute-force-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> key_index;\\n        vector<int> ans;\\n        for(int j = 0; j < nums.size(); j++){\\n            if (nums[j] == key)\\n                key_index.push_back(j);\\n        }\\n\\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j : key_index){\\n                if (abs(i - j) <= k){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> key_index;\\n        vector<int> ans;\\n        for(int j = 0; j < nums.size(); j++){\\n            if (nums[j] == key)\\n                key_index.push_back(j);\\n        }\\n\\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j : key_index){\\n                if (abs(i - j) <= k){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844232,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n=nums.size();\\n        bool f=false;\\n        vector <int> ans;\\n        for(int i=0;i<n;i++){\\n \\n            for(int l=0;l<k+1;l++)\\n            {\\n                if((i+l)<n && nums[i+l]==key){\\n                    f=true;\\n                    break;\\n                }\\n                if((i-l)>=0 && nums[i-l]==key )\\n                {\\n                    f=true;\\n                    break;\\n                }\\n            } \\n            if(f==true)\\n                ans.push_back(i);\\n            \\n            f=false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n=nums.size();\\n        bool f=false;\\n        vector <int> ans;\\n        for(int i=0;i<n;i++){\\n \\n            for(int l=0;l<k+1;l++)\\n            {\\n                if((i+l)<n && nums[i+l]==key){\\n                    f=true;\\n                    break;\\n                }\\n                if((i-l)>=0 && nums[i-l]==key )\\n                {\\n                    f=true;\\n                    break;\\n                }\\n            } \\n            if(f==true)\\n                ans.push_back(i);\\n            \\n            f=false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844167,
                "title": "c-easiest-solution-ever-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        \\n        vector<int> index,res;\\n        int n=nums.size();\\n        \\n\\t\\t//storing index of all [j] in vector\\n        for(int i=0;i<n;i++)\\n            if(key==nums[i])\\n                index.push_back(i);\\n      \\n\\t  //comparing each possible solution\\n        for(int i=0;i<n;i++){\\n            bool flag=false;\\n            \\n            for(auto j:index){\\n                if(abs(i-j) <= k){ //if condition true\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            if(flag)\\n                res.push_back(i);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        \\n        vector<int> index,res;\\n        int n=nums.size();\\n        \\n\\t\\t//storing index of all [j] in vector\\n        for(int i=0;i<n;i++)\\n            if(key==nums[i])\\n                index.push_back(i);\\n      \\n\\t  //comparing each possible solution\\n        for(int i=0;i<n;i++){\\n            bool flag=false;\\n            \\n            for(auto j:index){\\n                if(abs(i-j) <= k){ //if condition true\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            if(flag)\\n                res.push_back(i);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844155,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n    List<Integer> ans=new ArrayList<Integer>();\\n    List<Integer> list=new ArrayList<Integer>();\\n    int n = nums.length;\\n        for(int i = 0 ; i < n ;i++){\\n            if(nums[i] == key)\\n            list.add(i);  \\n        }\\n            for(int i = 0 ; i < n ; i++){\\n                for(Integer j : list){\\n                    if(Math.abs(i-j) <= k){\\n                        ans.add(i);\\n                        break;\\n                }\\n            }\\n        }\\n     return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n    List<Integer> ans=new ArrayList<Integer>();\\n    List<Integer> list=new ArrayList<Integer>();\\n    int n = nums.length;\\n        for(int i = 0 ; i < n ;i++){\\n            if(nums[i] == key)\\n            list.add(i);  \\n        }\\n            for(int i = 0 ; i < n ; i++){\\n                for(Integer j : list){\\n                    if(Math.abs(i-j) <= k){\\n                        ans.add(i);\\n                        break;\\n                }\\n            }\\n        }\\n     return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844137,
                "title": "clean-python-brute-force-solution",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        n, ans = len(nums), []\\n        keys_index = [i for i in range(n) if nums[i] == key] # Holds the indices of all elements equal to key.\\n        m = len(keys_index)\\n        for i in range(n):\\n            for j in range(m):\\n                if abs(i - keys_index[j]) <= k: # If the conditions are met then add ith index to the answer array.\\n                    ans.append(i)\\n                    break\\n        return sorted(ans) # Return sorted ans according to problem\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        n, ans = len(nums), []\\n        keys_index = [i for i in range(n) if nums[i] == key] # Holds the indices of all elements equal to key.\\n        m = len(keys_index)\\n        for i in range(n):\\n            for j in range(m):\\n                if abs(i - keys_index[j]) <= k: # If the conditions are met then add ith index to the answer array.\\n                    ans.append(i)\\n                    break\\n        return sorted(ans) # Return sorted ans according to problem\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844125,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> inx;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==key)  inx.push_back(i);\\n        }\\n        int n = nums.size();\\n        vector<int> res;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<inx.size(); j++){\\n                if(abs(i-inx[j]) <= k){\\n                    res.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> inx;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==key)  inx.push_back(i);\\n        }\\n        int n = nums.size();\\n        vector<int> res;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<inx.size(); j++){\\n                if(abs(i-inx[j]) <= k){\\n                    res.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074276,
                "title": "simple-and-fast-solution-o-n",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        ans, n, left = [], len(nums), 0\\n        for i, num in enumerate(nums):\\n            if num == key:\\n                right = min(i+k+1, n)\\n                ans.extend(range(max(i-k, left), right))\\n                left = right\\n        return ans      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        ans, n, left = [], len(nums), 0\\n        for i, num in enumerate(nums):\\n            if num == key:\\n                right = min(i+k+1, n)\\n                ans.extend(range(max(i-k, left), right))\\n                left = right\\n        return ans      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067871,
                "title": "simple-short-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        \\n        vector<int> ans{};\\n\\n        int high{-1}, n = nums.size();\\n\\n        for(int i = 0; i < n; i++){\\n\\n            if(nums[i] == key){\\n\\n                for(int j = max(high + 1, i - k); j <= i + k && j < n; j++){\\n                    ans.push_back(j);\\n                }\\n\\n                high = i + k;\\n                if(high >= n) break;\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        \\n        vector<int> ans{};\\n\\n        int high{-1}, n = nums.size();\\n\\n        for(int i = 0; i < n; i++){\\n\\n            if(nums[i] == key){\\n\\n                for(int j = max(high + 1, i - k); j <= i + k && j < n; j++){\\n                    ans.push_back(j);\\n                }\\n\\n                high = i + k;\\n                if(high >= n) break;\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058097,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> result;\\n        int idx = 0;\\n        while (idx < nums.size())\\n        {\\n            if (nums[idx] == key)\\n            {\\n                int l = std::max<int>(0, idx - k);\\n                if (result.size() > 0)\\n                {\\n                    l = std::max<int>(l, result[result.size() - 1] + 1);\\n                }\\n                int r = std::min<int>(nums.size() - 1, idx + k);\\n                for (int i = l; i <= r; i++)\\n                {\\n                    result.push_back(i);\\n                }\\n            }\\n            idx++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> result;\\n        int idx = 0;\\n        while (idx < nums.size())\\n        {\\n            if (nums[idx] == key)\\n            {\\n                int l = std::max<int>(0, idx - k);\\n                if (result.size() > 0)\\n                {\\n                    l = std::max<int>(l, result[result.size() - 1] + 1);\\n                }\\n                int r = std::min<int>(nums.size() - 1, idx + k);\\n                for (int i = l; i <= r; i++)\\n                {\\n                    result.push_back(i);\\n                }\\n            }\\n            idx++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010541,
                "title": "easy-fast-solution-beats-96-84",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(Math.abs(i-j) <= k && nums[j] == key){\\n                    list.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(Math.abs(i-j) <= k && nums[j] == key){\\n                    list.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987437,
                "title": "easy-cpp-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Reach the ith element having the nums[i] == key, then insert i-k to i+k indexes into the set.\\n- Here, we have used set as there are chances of indexes begin repeated.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        set<int> st;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == key){\\n                for(int j=i-k >= 0 ? i-k : 0; j<=i+k && j < nums.size(); j++)\\n                    st.insert(j);\\n            }\\n        }\\n\\n        return vector<int>(st.begin(), st.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        set<int> st;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == key){\\n                for(int j=i-k >= 0 ? i-k : 0; j<=i+k && j < nums.size(); j++)\\n                    st.insert(j);\\n            }\\n        }\\n\\n        return vector<int>(st.begin(), st.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983218,
                "title": "priority-queue-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        priority_queue<int, vector<int> , greater<int> > pq;\\n        for(int i =0;i<nums.size();i++){\\n            if(nums[i] == key){\\n                pq.push(i);\\n                \\n            }\\n        }\\n        \\n        for(int i =0 ;i<nums.size();i++){\\n            int diff = i - pq.top();\\n            if(abs(diff) <= k){\\n                ans.push_back(i);\\n            }\\n            else{\\n                if(diff > 0 && diff > k){\\n                    pq.pop();\\n                    if(abs(i - pq.top()) <=k ) ans.push_back(i);\\n                }\\n            }\\n            \\n        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        priority_queue<int, vector<int> , greater<int> > pq;\\n        for(int i =0;i<nums.size();i++){\\n            if(nums[i] == key){\\n                pq.push(i);\\n                \\n            }\\n        }\\n        \\n        for(int i =0 ;i<nums.size();i++){\\n            int diff = i - pq.top();\\n            if(abs(diff) <= k){\\n                ans.push_back(i);\\n            }\\n            else{\\n                if(diff > 0 && diff > k){\\n                    pq.pop();\\n                    if(abs(i - pq.top()) <=k ) ans.push_back(i);\\n                }\\n            }\\n            \\n        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970928,
                "title": "typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction findKDistantIndices(\\n  nums: number[], \\n  key: number, \\n  k: number\\n): number[] {\\n  const list = [];\\n\\n  for (let i = 0, j = 0; i < nums.length; i++) {\\n    if (nums[i] == key) {\\n      for (j = Math.max(j, i - k); j <= i + k && j < nums.length; j++) {\\n        list.push(j);\\n      }\\n    }\\n  }\\n\\n  return list;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findKDistantIndices(\\n  nums: number[], \\n  key: number, \\n  k: number\\n): number[] {\\n  const list = [];\\n\\n  for (let i = 0, j = 0; i < nums.length; i++) {\\n    if (nums[i] == key) {\\n      for (j = Math.max(j, i - k); j <= i + k && j < nums.length; j++) {\\n        list.push(j);\\n      }\\n    }\\n  }\\n\\n  return list;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962371,
                "title": "c-simplified",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) maybe\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=0; j<nums.size(); j++){\\n                if(abs(i-j)<=k && nums[j]==key){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=0; j<nums.size(); j++){\\n                if(abs(i-j)<=k && nums[j]==key){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959909,
                "title": "find-all-k-distant-indices-in-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        System.out.println(nums.length);\\n        ArrayList<Integer> ans = new ArrayList<Integer>();\\n        int j=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            while(j<nums.length&&(nums[j]!=key||i-j>k))\\n            {\\n                ++j;\\n            }\\n            if(j==nums.length)\\n            break;\\n            if(Math.abs(i-j)<=k)\\n            ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        System.out.println(nums.length);\\n        ArrayList<Integer> ans = new ArrayList<Integer>();\\n        int j=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            while(j<nums.length&&(nums[j]!=key||i-j>k))\\n            {\\n                ++j;\\n            }\\n            if(j==nums.length)\\n            break;\\n            if(Math.abs(i-j)<=k)\\n            ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959189,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        ArrayList<Integer>list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(Math.abs(i-j)<=k && nums[j]==key){\\n                    if(list.contains(i)){\\n\\n                    }\\n                    else{\\n                        list.add(i);\\n                        break;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        ArrayList<Integer>list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(Math.abs(i-j)<=k && nums[j]==key){\\n                    if(list.contains(i)){\\n\\n                    }\\n                    else{\\n                        list.add(i);\\n                        break;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955587,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        indices = []\\n\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                indices.append(i)\\n        \\n        res = set()\\n\\n        for i in indices:\\n            for j in range(len(nums)):\\n                if abs(i-j) <= k:\\n                    res.add(j)\\n        \\n        res = list(res)\\n        res.sort()\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        indices = []\\n\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                indices.append(i)\\n        \\n        res = set()\\n\\n        for i in indices:\\n            for j in range(len(nums)):\\n                if abs(i-j) <= k:\\n                    res.add(j)\\n        \\n        res = list(res)\\n        res.sort()\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947054,
                "title": "simple-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        unordered_set<int>s;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==key) s.insert(i);\\n        }\\n        vector<int>res;\\n        for(int i=0;i<nums.size();i++){\\n            for(auto it:s){\\n                if(abs(i-it)<=k){\\n                    res.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        unordered_set<int>s;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==key) s.insert(i);\\n        }\\n        vector<int>res;\\n        for(int i=0;i<nums.size();i++){\\n            for(auto it:s){\\n                if(abs(i-it)<=k){\\n                    res.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947049,
                "title": "using-set-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        unordered_set<int>s;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==key) s.insert(i);\\n        }\\n        vector<int>res;\\n        for(int i=0;i<nums.size();i++){\\n            for(auto it:s){\\n                if(abs(i-it)<=k){\\n                    res.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        unordered_set<int>s;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==key) s.insert(i);\\n        }\\n        vector<int>res;\\n        for(int i=0;i<nums.size();i++){\\n            for(auto it:s){\\n                if(abs(i-it)<=k){\\n                    res.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919173,
                "title": "simple-easy-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        int n = nums.length;\\n        ArrayList<Integer> idxsofkeys = new ArrayList<>();\\n        for(int i=0 ;i <n;i++){\\n            if(nums[i]==key) idxsofkeys.add(i);\\n        }\\n        int m = idxsofkeys.size();\\n        ArrayList<Integer> res = new ArrayList<>();boolean condtnmet;\\n        for(int i=0;i<n;i++){\\n            condtnmet = false;\\n            for(int j=0;j<m&&!condtnmet;j++){\\n                if(Math.abs(i-idxsofkeys.get(j))<=k){\\n                    res.add(i);condtnmet=true;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        int n = nums.length;\\n        ArrayList<Integer> idxsofkeys = new ArrayList<>();\\n        for(int i=0 ;i <n;i++){\\n            if(nums[i]==key) idxsofkeys.add(i);\\n        }\\n        int m = idxsofkeys.size();\\n        ArrayList<Integer> res = new ArrayList<>();boolean condtnmet;\\n        for(int i=0;i<n;i++){\\n            condtnmet = false;\\n            for(int j=0;j<m&&!condtnmet;j++){\\n                if(Math.abs(i-idxsofkeys.get(j))<=k){\\n                    res.add(i);condtnmet=true;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908221,
                "title": "easy-approach-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& a, int key, int k) {\\n        int n=a.size();\\n        // v is used to store indices of keys\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==key)v.push_back(i);\\n        }\\n        // if key is not present\\n        if(v.size()==0)return v;\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            int tmp=INT_MAX;\\n            for(auto j:v){\\n                // get the minimum distance from all key\\n                tmp=min(tmp,abs(i-j));\\n            }\\n            if(tmp!=INT_MAX && tmp<=k)ans.push_back(i);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& a, int key, int k) {\\n        int n=a.size();\\n        // v is used to store indices of keys\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==key)v.push_back(i);\\n        }\\n        // if key is not present\\n        if(v.size()==0)return v;\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            int tmp=INT_MAX;\\n            for(auto j:v){\\n                // get the minimum distance from all key\\n                tmp=min(tmp,abs(i-j));\\n            }\\n            if(tmp!=INT_MAX && tmp<=k)ans.push_back(i);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902422,
                "title": "simple-java-solution-time-o-n-space-o-n-for-the-o-p-array",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) \\n    {\\n        List<Integer> result = new ArrayList<>();\\n\\n        if (nums == null || nums.length == 0)\\n            return result;\\n\\n        int n = nums.length;\\n        int nextStartIndex = 0;\\n        int currentStartIndex = 0;\\n        int currentEndIndex = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (nums[i] == key)\\n            {\\n                currentStartIndex = i - k < 0 ? 0 : i - k;\\n                currentEndIndex = i + k >= n ? n - 1 : i + k;\\n                currentStartIndex = currentStartIndex < nextStartIndex ? nextStartIndex : currentStartIndex;\\n\\n                for(int j = currentStartIndex; j <= currentEndIndex; j++)\\n                {\\n                    result.add(j);\\n                }\\n\\n                nextStartIndex = currentEndIndex + 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) \\n    {\\n        List<Integer> result = new ArrayList<>();\\n\\n        if (nums == null || nums.length == 0)\\n            return result;\\n\\n        int n = nums.length;\\n        int nextStartIndex = 0;\\n        int currentStartIndex = 0;\\n        int currentEndIndex = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (nums[i] == key)\\n            {\\n                currentStartIndex = i - k < 0 ? 0 : i - k;\\n                currentEndIndex = i + k >= n ? n - 1 : i + k;\\n                currentStartIndex = currentStartIndex < nextStartIndex ? nextStartIndex : currentStartIndex;\\n\\n                for(int j = currentStartIndex; j <= currentEndIndex; j++)\\n                {\\n                    result.add(j);\\n                }\\n\\n                nextStartIndex = currentEndIndex + 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880184,
                "title": "python-single-pass-with-set-no-sort-5-line",
                "content": "- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n```\\nclass Solution(object):\\n    def findKDistantIndices(self, nums, key, k):\\n        ans, n = set(), len(nums)\\n        for i in range(n):\\n            if nums[i]==key:\\n                ans.update( range(max(0,i-k),min(n,i+k+1)) )\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def findKDistantIndices(self, nums, key, k):\\n        ans, n = set(), len(nums)\\n        for i in range(n):\\n            if nums[i]==key:\\n                ans.update( range(max(0,i-k),min(n,i+k+1)) )\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862551,
                "title": "brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer>al=new ArrayList<>();\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n            if(Math.abs(i-j)<=k && nums[j]==key){\\n                al.add(i);\\n                break;\\n            }\\n        }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer>al=new ArrayList<>();\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n            if(Math.abs(i-j)<=k && nums[j]==key){\\n                al.add(i);\\n                break;\\n            }\\n        }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851790,
                "title": "java-easy-solution",
                "content": "class Solution {\\n   public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n    \\t\\n    \\tList<Integer> ind=new ArrayList<>();\\n    \\tList<Integer> ans=new ArrayList<>();\\n    \\t\\n    \\tfor(int i=0;i<nums.length;i++) {\\n    \\t\\tif(nums[i]==key)\\n    \\t\\t\\tind.add(i);\\n    \\t}\\n    \\t\\n    \\tfor(int i=0;i<nums.length;i++) {\\n    \\t\\t\\n    \\t\\tboolean p=false;\\n    \\t\\tfor(int j:ind) {\\n    \\t\\t\\tif(Math.abs(i-j)<=k) {\\n    \\t\\t\\t\\tp=true;\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\t\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif(p) ans.add(i);\\n    \\t}\\n    \\treturn ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n   public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n    \\t\\n    \\tList<Integer> ind=new ArrayList<>();\\n    \\tList<Integer> ans=new ArrayList<>();\\n    \\t\\n    \\tfor(int i=0;i<nums.length;i++) {\\n    \\t\\tif(nums[i]==key)\\n    \\t\\t\\tind.add(i);\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3824822,
                "title": "beat-100-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    const indices = [];\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === key) {\\n            indices.push(i);\\n        }\\n    }\\n\\n    const results = [];\\n\\n    // iterate nums\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let indice of indices) {\\n            if (Math.abs(i - indice) <= k) {\\n                results.push(i);\\n                break;\\n            }\\n        }\\n    }\\n\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    const indices = [];\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === key) {\\n            indices.push(i);\\n        }\\n    }\\n\\n    const results = [];\\n\\n    // iterate nums\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let indice of indices) {\\n            if (Math.abs(i - indice) <= k) {\\n                results.push(i);\\n                break;\\n            }\\n        }\\n    }\\n\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3803254,
                "title": "one-pass-go-golang-solution",
                "content": "```\\nfunc findKDistantIndices(nums []int, key, k int) []int {\\n        res := make([]int, 0)\\n\\n        for i := 0; i < len(nums); i++ {\\n                if num := nums[i]; num == key {\\n                        startIdx := i - k\\n                        endIdx := i + k\\n\\n                        if startIdx < 0 {                                                       startIdx = 0\\n                        }\\n\\n                        if len(res) > 0 && res[len(res)-1] >= startIdx {\\n                                startIdx = res[len(res)-1] + 1\\n                        }\\n\\n                        if endIdx > len(nums)-1 {\\n                                endIdx = len(nums) - 1\\n                        }\\n\\n                        for j := startIdx; j <= endIdx; j++ {\\n                                res = append(res, j)\\n                        }\\n                }\\n        }\\n\\n        return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findKDistantIndices(nums []int, key, k int) []int {\\n        res := make([]int, 0)\\n\\n        for i := 0; i < len(nums); i++ {\\n                if num := nums[i]; num == key {\\n                        startIdx := i - k\\n                        endIdx := i + k\\n\\n                        if startIdx < 0 {                                                       startIdx = 0\\n                        }\\n\\n                        if len(res) > 0 && res[len(res)-1] >= startIdx {\\n                                startIdx = res[len(res)-1] + 1\\n                        }\\n\\n                        if endIdx > len(nums)-1 {\\n                                endIdx = len(nums) - 1\\n                        }\\n\\n                        for j := startIdx; j <= endIdx; j++ {\\n                                res = append(res, j)\\n                        }\\n                }\\n        }\\n\\n        return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797325,
                "title": "short-and-simple-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    let see=[];\\n    for(var i=0;i<nums.length;i++){\\n        if(nums[i]==key){see.push(i)}\\n    }\\n    let ans=[];\\n    for(var i=0;i<nums.length;i++){\\n        for(var j=0;j<see.length;j++){\\n            dif=see[j]-i;\\n            if(dif<0) dif=0-dif;\\n            if(dif<=k){ans.push(i); break;}\\n        }\\n    } return ans;\\n}; \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    let see=[];\\n    for(var i=0;i<nums.length;i++){\\n        if(nums[i]==key){see.push(i)}\\n    }\\n    let ans=[];\\n    for(var i=0;i<nums.length;i++){\\n        for(var j=0;j<see.length;j++){\\n            dif=see[j]-i;\\n            if(dif<0) dif=0-dif;\\n            if(dif<=k){ans.push(i); break;}\\n        }\\n    } return ans;\\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3754311,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        Set<Integer> output = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                for (int j = 0; j < nums.length; j++) {\\n                    if (Math.abs(i - j) <= k) {\\n                        output.add(j);\\n                    }\\n                }\\n            }\\n        }\\n        return output.stream().sorted().collect(Collectors.toList());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        Set<Integer> output = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                for (int j = 0; j < nums.length; j++) {\\n                    if (Math.abs(i - j) <= k) {\\n                        output.add(j);\\n                    }\\n                }\\n            }\\n        }\\n        return output.stream().sorted().collect(Collectors.toList());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741402,
                "title": "python-easy-to-understand-beats-99-63",
                "content": "# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: list[int], key: int, k: int) -> list[int]:\\n        # Create list of k_distant indices.\\n        k_distant = []\\n        \\n        # Set last checked index.\\n        last_checked = 0\\n\\n        for i, num in enumerate(nums):\\n            # All indices around the key element would be appropriate for k_distant.\\n            if num == key:\\n                # Go through indices around key element.\\n                # Also adjust left border according to the last_checked and\\n                # make sure, that right border are in the list.\\n                for j in range(max(last_checked, i-k), min(i+k+1, len(nums))):\\n                    k_distant.append(j)\\n\\n                # Update last_checked.\\n                last_checked = i+k+1\\n                \\n                # last_checked >= len(nums) means that all elements were already checked.\\n                if last_checked >= len(nums):\\n                    break\\n\\n        return k_distant\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: list[int], key: int, k: int) -> list[int]:\\n        # Create list of k_distant indices.\\n        k_distant = []\\n        \\n        # Set last checked index.\\n        last_checked = 0\\n\\n        for i, num in enumerate(nums):\\n            # All indices around the key element would be appropriate for k_distant.\\n            if num == key:\\n                # Go through indices around key element.\\n                # Also adjust left border according to the last_checked and\\n                # make sure, that right border are in the list.\\n                for j in range(max(last_checked, i-k), min(i+k+1, len(nums))):\\n                    k_distant.append(j)\\n\\n                # Update last_checked.\\n                last_checked = i+k+1\\n                \\n                # last_checked >= len(nums) means that all elements were already checked.\\n                if last_checked >= len(nums):\\n                    break\\n\\n        return k_distant\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740612,
                "title": "beats-96-63-time-complexity-of-2ms-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// class Solution {\\n//     public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n//         ArrayList<Integer> list = new ArrayList<>();\\n//         List<Integer> pos=position(key,nums);\\n//         for(int i=0;i<nums.length;i++){\\n//             for(int j=0;j<pos.size();j++){\\n//                 int diff= (int)Math.abs(i-pos.get(j));\\n//                 if(diff<=k){\\n//                     list.add(i);\\n//                     break;\\n//                 }\\n//             }\\n//         }\\n//         return list;\\n//     }\\n//     public List<Integer> position(int key,int nums[]){\\n//         ArrayList<Integer> pos = new ArrayList<>();\\n//         for(int i=0;i<nums.length;i++){\\n//             if(nums[i]==key){\\n//                 pos.add(i);\\n//             }\\n//         }\\n//         return pos;\\n//     }\\n// }\\nclass Solution {\\n     public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n         ArrayList<Integer> list = new ArrayList<>();\\n         int pos=position(0,key,nums);\\n         for(int i=0; i<nums.length;i++)\\n         {\\n             if(i>=pos-k && i<=pos+k){\\n                 list.add(i);\\n                 if(nums[i]==key){\\n                     pos=i;\\n                 }\\n             }\\n             else{\\n                 pos=position(i,key,nums);\\n                 if(pos==-1){\\n                     break;\\n                 }\\n                 else if(i>=pos-k && i<=pos+k){\\n                    list.add(i);\\n                 }\\n             }\\n         }\\n         return list;\\n     }\\n     public static int position(int p,int key,int nums[]){\\n         for(int i=p;i<nums.length;i++){\\n             if(nums[i]==key){\\n                return i;\\n             }\\n         }\\n         return -1;\\n    }\\n }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// class Solution {\\n//     public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n//         ArrayList<Integer> list = new ArrayList<>();\\n//         List<Integer> pos=position(key,nums);\\n//         for(int i=0;i<nums.length;i++){\\n//             for(int j=0;j<pos.size();j++){\\n//                 int diff= (int)Math.abs(i-pos.get(j));\\n//                 if(diff<=k){\\n//                     list.add(i);\\n//                     break;\\n//                 }\\n//             }\\n//         }\\n//         return list;\\n//     }\\n//     public List<Integer> position(int key,int nums[]){\\n//         ArrayList<Integer> pos = new ArrayList<>();\\n//         for(int i=0;i<nums.length;i++){\\n//             if(nums[i]==key){\\n//                 pos.add(i);\\n//             }\\n//         }\\n//         return pos;\\n//     }\\n// }\\nclass Solution {\\n     public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n         ArrayList<Integer> list = new ArrayList<>();\\n         int pos=position(0,key,nums);\\n         for(int i=0; i<nums.length;i++)\\n         {\\n             if(i>=pos-k && i<=pos+k){\\n                 list.add(i);\\n                 if(nums[i]==key){\\n                     pos=i;\\n                 }\\n             }\\n             else{\\n                 pos=position(i,key,nums);\\n                 if(pos==-1){\\n                     break;\\n                 }\\n                 else if(i>=pos-k && i<=pos+k){\\n                    list.add(i);\\n                 }\\n             }\\n         }\\n         return list;\\n     }\\n     public static int position(int p,int key,int nums[]){\\n         for(int i=p;i<nums.length;i++){\\n             if(nums[i]==key){\\n                return i;\\n             }\\n         }\\n         return -1;\\n    }\\n }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724129,
                "title": "java-simple-explained",
                "content": "**Idea:** Collect the k distant elements\\' indices from any nums[i] = key. To avoid overlap, keep a common pointer (j) to resume from where you left for previous key\\n>**T/S:** O(n\\xB2)/O(n), where n = size(nums)\\n```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\tvar j = 0;\\n\\tvar n = nums.length;\\n\\tvar indices = new ArrayList<Integer>();\\n\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tif (nums[i] == key)\\n\\t\\t\\tfor (j = Math.max(j, i - k); j <= Math.min(i + k, n - 1); j++)\\n\\t\\t\\t\\tindices.add(j);\\n\\n\\treturn indices;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\tvar j = 0;\\n\\tvar n = nums.length;\\n\\tvar indices = new ArrayList<Integer>();\\n\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tif (nums[i] == key)\\n\\t\\t\\tfor (j = Math.max(j, i - k); j <= Math.min(i + k, n - 1); j++)\\n\\t\\t\\t\\tindices.add(j);\\n\\n\\treturn indices;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3723977,
                "title": "easiest-sol-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n       List<Integer> li = new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=0;j<nums.length;j++){\\n               if(nums[j]==key && Math.abs(i-j)<=k){\\n                   li.add(i);\\n                   break;\\n               }\\n           }\\n       }\\n       return li; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n       List<Integer> li = new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=0;j<nums.length;j++){\\n               if(nums[j]==key && Math.abs(i-j)<=k){\\n                   li.add(i);\\n                   break;\\n               }\\n           }\\n       }\\n       return li; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696067,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    let arr = [];\\n    let result = [];\\n    for (let i = 0; i < nums.length; i++){\\n        if (nums[i] === key) arr.push(i);  \\n    }\\n    for (i = 0; i < nums.length; i++){\\n        let flag = false;\\n        for (let j = 0; j < arr.length; j++){\\n            if (Math.abs(i - arr[j]) <= k && !flag){\\n                result.push(i);\\n                flag = true;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    let arr = [];\\n    let result = [];\\n    for (let i = 0; i < nums.length; i++){\\n        if (nums[i] === key) arr.push(i);  \\n    }\\n    for (i = 0; i < nums.length; i++){\\n        let flag = false;\\n        for (let j = 0; j < arr.length; j++){\\n            if (Math.abs(i - arr[j]) <= k && !flag){\\n                result.push(i);\\n                flag = true;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3678643,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        //unordered_set<int> s;\\n\\n        for (int i=0 ; i<nums.size() ; i++){\\n            // if (i>k)\\n            //     s.erase(nums[i-k-1]);\\n            \\n            // if (s.count(key)>0 || nums[i]==key)\\n            //     ans.push_back(i);\\n            \\n            // s.insert(nums[i]);\\n            if (nums[i] == key){\\n                ans.push_back(i);\\n                continue;\\n            }\\n            auto start = nums.begin() + max(i-k , 0);\\n            auto end = nums.begin() + min(i+k+1 , n);\\n            int occurrences = count(start , end , key);\\n            if (occurrences>0)\\n                ans.push_back(i);\\n        }\\n\\n        sort(ans.begin() , ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        //unordered_set<int> s;\\n\\n        for (int i=0 ; i<nums.size() ; i++){\\n            // if (i>k)\\n            //     s.erase(nums[i-k-1]);\\n            \\n            // if (s.count(key)>0 || nums[i]==key)\\n            //     ans.push_back(i);\\n            \\n            // s.insert(nums[i]);\\n            if (nums[i] == key){\\n                ans.push_back(i);\\n                continue;\\n            }\\n            auto start = nums.begin() + max(i-k , 0);\\n            auto end = nums.begin() + min(i+k+1 , n);\\n            int occurrences = count(start , end , key);\\n            if (occurrences>0)\\n                ans.push_back(i);\\n        }\\n\\n        sort(ans.begin() , ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671952,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n        vector<int> ans;   \\n        for(int i = 0; i<n; i++)\\n        {\\n            if(nums[i] == key) \\n            {\\n                int start = max(0, i-k);   \\n                int end = min(n-1, i+k);  \\n                \\n                if(ans.size()!=0) // check if any index is stored earlier\\n                    start = max(ans[ans.size() - 1] + 1, start); // avoid overlapping intervals\\n                \\n                for(int j = start; j<=end; j++) // simply push every index from start till end\\n                    ans.push_back(j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n        vector<int> ans;   \\n        for(int i = 0; i<n; i++)\\n        {\\n            if(nums[i] == key) \\n            {\\n                int start = max(0, i-k);   \\n                int end = min(n-1, i+k);  \\n                \\n                if(ans.size()!=0) // check if any index is stored earlier\\n                    start = max(ans[ans.size() - 1] + 1, start); // avoid overlapping intervals\\n                \\n                for(int j = start; j<=end; j++) // simply push every index from start till end\\n                    ans.push_back(j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655242,
                "title": "python-very-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        keyLis=[]\\n        res=[]\\n        for i in range(len(nums)):\\n            if nums[i]==key:\\n                keyLis.append(i)\\n        for i in range(len(nums)):\\n            for j in keyLis:\\n                if abs(i-j)<=k:\\n                    res.append(i)\\n                    break\\n        return res\\n```\\n\\n***Please Upvote***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        keyLis=[]\\n        res=[]\\n        for i in range(len(nums)):\\n            if nums[i]==key:\\n                keyLis.append(i)\\n        for i in range(len(nums)):\\n            for j in keyLis:\\n                if abs(i-j)<=k:\\n                    res.append(i)\\n                    break\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648630,
                "title": "java-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically we use at our advantage the fact that \"k\" defines how many indices are \"close\" to a key occurrence, namely all indices inside num[j] +/- k are what is considered as a k-distant index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to find the occurrences of num[x] = key, and around them find the k-distant indices. The formula is simple: all indices between num[x] - k < num[x] < num[x] + k, where num[x] == key, should be part of the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n). \\n\\nWe iterate over the array to get the occurrences of key, and then we iterate over the occurrences and their k-distant indices. We use an optimization which saves us from visiting repeated indices. At worst case we visit the whole array 2 times, which is O(n).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), as we create a new array for the result.\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        var coincidences = new ArrayList<Integer>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) coincidences.add(i);\\n        }\\n\\n        int lastIdx = -1;\\n\\n        var result = new ArrayList<Integer>();\\n        for (Integer coincidence: coincidences) {\\n            for (int j = Math.max(0, Math.max(lastIdx, coincidence-k)); j <= Math.min(coincidence + k, nums.length-1); j++) {\\n                result.add(j);\\n                lastIdx = j+1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        var coincidences = new ArrayList<Integer>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) coincidences.add(i);\\n        }\\n\\n        int lastIdx = -1;\\n\\n        var result = new ArrayList<Integer>();\\n        for (Integer coincidence: coincidences) {\\n            for (int j = Math.max(0, Math.max(lastIdx, coincidence-k)); j <= Math.min(coincidence + k, nums.length-1); j++) {\\n                result.add(j);\\n                lastIdx = j+1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619623,
                "title": "java-noob-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i =0; i<nums.length; i++){\\n            if(nums[i]==key){\\n                for(int j =list.size(); j<nums.length; j++){\\n                    if(Math.abs(i-j)<=k){\\n                        if(!list.contains(j))\\n                         list.add(j);\\n                    }\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i =0; i<nums.length; i++){\\n            if(nums[i]==key){\\n                for(int j =list.size(); j<nums.length; j++){\\n                    if(Math.abs(i-j)<=k){\\n                        if(!list.contains(j))\\n                         list.add(j);\\n                    }\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602808,
                "title": "easy-to-understand-explaination",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: look for all indices whose value == key\\nStep 2: While traversing find the key to processing element and check the condition. \\n\\n# Complexity\\n- Time complexity: O(nlog) as we are checking for each and every element in the treeset\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(n) as TreeSet used hold all the indices whose value matched with key. In worst case all element in array is equal to key.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\n        TreeSet<Integer> keyIdx = new TreeSet<>();\\n        // Let find all the index where key == nums[index];\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == key)\\n                keyIdx.add(i); // log(n) to add an element\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n        // Lets traverse for each element to find it distance from nearest key index\\n        for(int i = 0; i < nums.length; i++){\\n            \\n            // check the left side of the index\\n            Integer lowerIdx = keyIdx.floor(i); //log(n) to search the nearest element\\n\\n            if(lowerIdx != null){\\n                if(i-lowerIdx <= k){\\n                    ans.add(i);\\n                    continue; // now check the next element.\\n                }\\n            } \\n\\n// if left side index key not found or is greater than K then check on it right side\\n            Integer higherIdx = keyIdx.ceiling(i); //log(n) to search the nearest element\\n            if(higherIdx != null){\\n                if(higherIdx-i <= k){\\n                    ans.add(i);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\n        TreeSet<Integer> keyIdx = new TreeSet<>();\\n        // Let find all the index where key == nums[index];\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == key)\\n                keyIdx.add(i); // log(n) to add an element\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n        // Lets traverse for each element to find it distance from nearest key index\\n        for(int i = 0; i < nums.length; i++){\\n            \\n            // check the left side of the index\\n            Integer lowerIdx = keyIdx.floor(i); //log(n) to search the nearest element\\n\\n            if(lowerIdx != null){\\n                if(i-lowerIdx <= k){\\n                    ans.add(i);\\n                    continue; // now check the next element.\\n                }\\n            } \\n\\n// if left side index key not found or is greater than K then check on it right side\\n            Integer higherIdx = keyIdx.ceiling(i); //log(n) to search the nearest element\\n            if(higherIdx != null){\\n                if(higherIdx-i <= k){\\n                    ans.add(i);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578123,
                "title": "easy-logic-and-13ms-solutions-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int len = nums.size();\\n        vector<int>vals;\\n        vector<int>ans;\\n        for(int i =0 ; i<len; i++){  // stores all the index of the keys.\\n            if(nums[i]==key){\\n                vals.push_back(i);\\n            }\\n        }\\n\\n        //for travelling and checking each index with the keys index if (i - vals[i]) < = k\\n        //  if ture -> push the i index in array and break\\n\\n        for(int i=0; i<len; i++){\\n            if(nums[i]==key){  /*this if checks , if the value at ith is same as key \\n                                then simply push the index in ans array*/\\n                ans.push_back(i);\\n                continue;\\n            } \\n            else{\\n                for(int j=0 ; j<vals.size(); j++){\\n                    if(abs(i-vals[j])<=k){\\n                        cout<<abs(i-vals[j])<<endl;\\n                        ans.push_back(i);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans; //noted we are traversing i from 0 to n so ans is already sorted!!\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int len = nums.size();\\n        vector<int>vals;\\n        vector<int>ans;\\n        for(int i =0 ; i<len; i++){  // stores all the index of the keys.\\n            if(nums[i]==key){\\n                vals.push_back(i);\\n            }\\n        }\\n\\n        //for travelling and checking each index with the keys index if (i - vals[i]) < = k\\n        //  if ture -> push the i index in array and break\\n\\n        for(int i=0; i<len; i++){\\n            if(nums[i]==key){  /*this if checks , if the value at ith is same as key \\n                                then simply push the index in ans array*/\\n                ans.push_back(i);\\n                continue;\\n            } \\n            else{\\n                for(int j=0 ; j<vals.size(); j++){\\n                    if(abs(i-vals[j])<=k){\\n                        cout<<abs(i-vals[j])<<endl;\\n                        ans.push_back(i);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans; //noted we are traversing i from 0 to n so ans is already sorted!!\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3575807,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j] == key){\\n                    if(abs(i-j)<=k) {\\n                        ans.push_back(i);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j] == key){\\n                    if(abs(i-j)<=k) {\\n                        ans.push_back(i);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572879,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n            List<Integer> res = new ArrayList<>() , holder = new ArrayList<>();\\n        for (int i=0;i<nums.length;i++){\\n            if (nums[i] == key)\\n                holder.add(i);\\n        }\\n        for (int i=0;i<nums.length;i++){\\n            for (int n : holder){\\n                if (Math.abs(i-n) <=k){\\n                    res.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n            List<Integer> res = new ArrayList<>() , holder = new ArrayList<>();\\n        for (int i=0;i<nums.length;i++){\\n            if (nums[i] == key)\\n                holder.add(i);\\n        }\\n        for (int i=0;i<nums.length;i++){\\n            for (int n : holder){\\n                if (Math.abs(i-n) <=k){\\n                    res.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518043,
                "title": "this-is-not-effective-solution-in-cpp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n       vector<int> ans;\\n       unordered_map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] == key){\\n                for(int j = 0; j < nums.size(); j++){\\n                    if(mp[j] == 0 && abs(i - j) <= k){\\n                        ans.push_back(j);\\n                        mp[j]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n       vector<int> ans;\\n       unordered_map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] == key){\\n                for(int j = 0; j < nums.size(); j++){\\n                    if(mp[j] == 0 && abs(i - j) <= k){\\n                        ans.push_back(j);\\n                        mp[j]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498162,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    let res = []; // [2, 5]\\\\\\n    let curRes = [];\\n    for (let i = 0; i < nums.length; i++){\\n        if (nums[i] === key){\\n            res.push(i);\\n        }\\n    }\\n    for (i = 0; i < nums.length; i++){\\n        let isAdded = false;\\n        for (let j = 0; j < res.length; j++){\\n            if (Math.abs(i - res[j]) <= k && !isAdded){\\n                curRes.push(i);\\n                isAdded = true;\\n            }\\n        }\\n    }\\n    return curRes;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    let res = []; // [2, 5]\\\\\\n    let curRes = [];\\n    for (let i = 0; i < nums.length; i++){\\n        if (nums[i] === key){\\n            res.push(i);\\n        }\\n    }\\n    for (i = 0; i < nums.length; i++){\\n        let isAdded = false;\\n        for (let j = 0; j < res.length; j++){\\n            if (Math.abs(i - res[j]) <= k && !isAdded){\\n                curRes.push(i);\\n                isAdded = true;\\n            }\\n        }\\n    }\\n    return curRes;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3481917,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        Set<Integer> keyset = new HashSet<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            if (nums[i] == key) {\\n                keyset.add(i);\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            for (int ke : keyset) {\\n\\n                if (Math.abs(ke - i) <= k) {\\n                    ans.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        Set<Integer> keyset = new HashSet<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            if (nums[i] == key) {\\n                keyset.add(i);\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            for (int ke : keyset) {\\n\\n                if (Math.abs(ke - i) <= k) {\\n                    ans.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480840,
                "title": "java-solution-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> ans = new ArrayList<>();\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==key){\\n                int rang1 = i-k;\\n                int rang2 = i+k;\\n                if(rang1<0){\\n                    rang1=0;\\n                }\\n                if(rang2>nums.length-1){\\n                    rang2 = nums.length-1;\\n                }\\n                for(int j=rang1;j<=rang2;j++){\\n                    set.add(j);\\n                }\\n            }\\n        }\\n        for(int ke:set){\\n            ans.add(ke);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> ans = new ArrayList<>();\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==key){\\n                int rang1 = i-k;\\n                int rang2 = i+k;\\n                if(rang1<0){\\n                    rang1=0;\\n                }\\n                if(rang2>nums.length-1){\\n                    rang2 = nums.length-1;\\n                }\\n                for(int j=rang1;j<=rang2;j++){\\n                    set.add(j);\\n                }\\n            }\\n        }\\n        for(int ke:set){\\n            ans.add(ke);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466328,
                "title": "find-all-k-distant-indices-js-easy-to-understand-70-ms",
                "content": "![image.png](https://assets.leetcode.com/users/images/e3f31571-69e3-4270-ba5d-ba668476a473_1682776087.9805954.png)\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    result = []                                 // store result\\n    arr_keys = []                               // store all nums keys indexes\\n    \\n    for (let i = 0; i < nums.length; i++) {     // get all keys indexes in nums\\n        if (nums[i] == key) arr_keys.push(i)\\n    }    \\n\\n    for (x of arr_keys) {                       // fill with \\'0\\' all nums[keys] on left && right for k value\\n        fix(x)\\n    }    \\n\\n    for (let i = 0; i < nums.length; i++) {     // all indexes with \\'0\\' in nums add to result array\\n        if (nums[i] == 0) result.push(i)\\n    }\\n\\n    return result                               // return result as answer\\n\\n    function fix(x) {                           // fill nums with \\'0\\' on left && right from nums[x] with k size\\n        left = Math.max(0, x - k)\\n        right = Math.min(nums.length - 1, x + k)\\n        \\n        for (let i = left; i <= right; i++) {\\n            nums[i] = 0\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    result = []                                 // store result\\n    arr_keys = []                               // store all nums keys indexes\\n    \\n    for (let i = 0; i < nums.length; i++) {     // get all keys indexes in nums\\n        if (nums[i] == key) arr_keys.push(i)\\n    }    \\n\\n    for (x of arr_keys) {                       // fill with \\'0\\' all nums[keys] on left && right for k value\\n        fix(x)\\n    }    \\n\\n    for (let i = 0; i < nums.length; i++) {     // all indexes with \\'0\\' in nums add to result array\\n        if (nums[i] == 0) result.push(i)\\n    }\\n\\n    return result                               // return result as answer\\n\\n    function fix(x) {                           // fill nums with \\'0\\' on left && right from nums[x] with k size\\n        left = Math.max(0, x - k)\\n        right = Math.min(nums.length - 1, x + k)\\n        \\n        for (let i = left; i <= right; i++) {\\n            nums[i] = 0\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464974,
                "title": "find-all-k-distant-indices-in-an-array-using-c-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n     \\n        vector<int>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            int a =-1;\\n            for(int j=0; j<n; j++) // for matching the key\\n            {\\n              if(abs(i-j)<=k && nums[j]==key) //conditions \\n              {\\n                  a =i;\\n              }\\n            }\\n            if(a!=-1)\\n            {\\n                ans.push_back(a);\\n            } \\n        }\\n        return ans;  \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int n = nums.size();\\n     \\n        vector<int>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            int a =-1;\\n            for(int j=0; j<n; j++) // for matching the key\\n            {\\n              if(abs(i-j)<=k && nums[j]==key) //conditions \\n              {\\n                  a =i;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 3458389,
                "title": "solution-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an empty array called: output\\n2. Create a for loop that goes throught every index in nums\\n3. Create an other for loop that goes throught every index in nums.\\n4. Check conditions: \\n    - Absolute (i-j) <= k  (  i is index in first for loop, j is index in secend for loop)\\n    - nums[j] == key\\n5. If conditions are true: append index i in to output array (then break out of the second for loop \\n6. Return output\\n# Complexity\\n- Time complexity:\\n    On2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- On\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func findKDistantIndices(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\\n        var output : [Int] = []\\n        for i in 0...nums.count-1 {\\n            for j in 0...nums.count-1 {\\n                if abs(i-j) <= k && nums[j] == key {\\n                    output.append(i)\\n                    break\\n                }\\n            }\\n        }\\n        return output\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findKDistantIndices(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\\n        var output : [Int] = []\\n        for i in 0...nums.count-1 {\\n            for j in 0...nums.count-1 {\\n                if abs(i-j) <= k && nums[j] == key {\\n                    output.append(i)\\n                    break\\n                }\\n            }\\n        }\\n        return output\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446477,
                "title": "java-simple-solution-bruteforce-treeset",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        Set<Integer> kDistantIndicies = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                for (int j = 0; j < nums.length; j++) {\\n                    if (Math.abs(i - j) <= k) {\\n                        kDistantIndicies.add(j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(kDistantIndicies);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        Set<Integer> kDistantIndicies = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                for (int j = 0; j < nums.length; j++) {\\n                    if (Math.abs(i - j) <= k) {\\n                        kDistantIndicies.add(j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(kDistantIndicies);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441524,
                "title": "100-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    const result = []\\n    let keys = []\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === key) keys.push(i)\\n    }\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (isKDistantIndex(i)) result.push(i)\\n    }\\n\\n\\n    return result\\n\\n    function isKDistantIndex(index) {\\n        for (const el of keys) {\\n            if (Math.abs(index - el) <= k) return true\\n        }\\n\\n        return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    const result = []\\n    let keys = []\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === key) keys.push(i)\\n    }\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (isKDistantIndex(i)) result.push(i)\\n    }\\n\\n\\n    return result\\n\\n    function isKDistantIndex(index) {\\n        for (const el of keys) {\\n            if (Math.abs(index - el) <= k) return true\\n        }\\n\\n        return false\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3432752,
                "title": "83-submission",
                "content": "# Intuition\\nfor finding key we either use traverse whole array but it will give not optimize as key will be smaller or equal than array size so storing key and checking min key index to current index will optimize\\n\\n# Approach\\nfirst store key as will check only directly those index which have key ,then check one by one element as soon we found index-key index is less than k store it into ans array otherwise check for next key index till either index-key index is less than k or not found\\n\\n# Complexity\\n- Time complexity:\\no(n*no.of key)\\n\\n- Space complexity:\\no(no of key + no of valid index)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int>a;\\n        for(int i=0;i<nums.size();i++) if(nums[i]==key) a.push_back(i);\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<a.size();j++){\\n                if(abs(a[j]-i)<=k){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int>a;\\n        for(int i=0;i<nums.size();i++) if(nums[i]==key) a.push_back(i);\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<a.size();j++){\\n                if(abs(a[j]-i)<=k){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428316,
                "title": "java-treeset-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo store indexes of keys in TreeSet. \\nThen in cycle getting closest key indexes from TreeSet and compare. \\n\\n# Approach\\nTreeSet\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(m))\\nwhere n - elements in array\\nwhere m - freequency of key in array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == key){\\n                set.add(i);\\n            }\\n        }\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i = 0; i < nums.length; i++){\\n\\n            Integer higerIndex = set.ceiling(i);\\n            Integer lowerIndex = set.floor(i);\\n            higerIndex = higerIndex == null ? Integer.MAX_VALUE : higerIndex;\\n            lowerIndex = lowerIndex == null ? Integer.MAX_VALUE : lowerIndex;\\n            \\n            if(Math.abs(higerIndex - i) <= k || Math.abs(lowerIndex - i) <= k){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == key){\\n                set.add(i);\\n            }\\n        }\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i = 0; i < nums.length; i++){\\n\\n            Integer higerIndex = set.ceiling(i);\\n            Integer lowerIndex = set.floor(i);\\n            higerIndex = higerIndex == null ? Integer.MAX_VALUE : higerIndex;\\n            lowerIndex = lowerIndex == null ? Integer.MAX_VALUE : lowerIndex;\\n            \\n            if(Math.abs(higerIndex - i) <= k || Math.abs(lowerIndex - i) <= k){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418662,
                "title": "find-all-k-distant-indices-in-an-array-easiest-with-c-in-0ms-runtime",
                "content": "![image.png](https://assets.leetcode.com/users/images/716c88ed-0345-48ec-b791-fe02b37d4843_1681542492.5761387.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int>index;\\n        vector<int>ans;\\n        for(int i=0; i<nums.size(); i++)\\n            if(nums[i] == key)\\n                index.push_back(i);\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            for(auto j:index){\\n                if(abs(i - j) <= k){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int>index;\\n        vector<int>ans;\\n        for(int i=0; i<nums.size(); i++)\\n            if(nums[i] == key)\\n                index.push_back(i);\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            for(auto j:index){\\n                if(abs(i - j) <= k){\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402046,
                "title": "rust-4ms-fast-enough",
                "content": "```\\nimpl Solution {\\n    pub fn find_k_distant_indices(nums: Vec<i32>, key: i32, k: i32) -> Vec<i32> {\\n        let indexes: Vec<_> = nums\\n            .iter()\\n            .enumerate()\\n            .filter(|&(_, x)| x == &key)\\n            .map(|(i, _)| i as i32)\\n            .collect();\\n\\n        let mut res = vec![];\\n\\n        for i in 0..nums.len() as i32 {\\n            if indexes.contains(&i) {\\n                res.push(i);\\n                continue;\\n            }\\n            for j in &indexes {\\n                if (i - j).abs() <= k {\\n                    res.push(i)\\n                }\\n            }\\n        }\\n        res.dedup();\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_k_distant_indices(nums: Vec<i32>, key: i32, k: i32) -> Vec<i32> {\\n        let indexes: Vec<_> = nums\\n            .iter()\\n            .enumerate()\\n            .filter(|&(_, x)| x == &key)\\n            .map(|(i, _)| i as i32)\\n            .collect();\\n\\n        let mut res = vec![];\\n\\n        for i in 0..nums.len() as i32 {\\n            if indexes.contains(&i) {\\n                res.push(i);\\n                continue;\\n            }\\n            for j in &indexes {\\n                if (i - j).abs() <= k {\\n                    res.push(i)\\n                }\\n            }\\n        }\\n        res.dedup();\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3364029,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        int n = nums.length;\\n        List<Integer> keyIndices = new ArrayList<>();\\n        List<Integer> result = new ArrayList<>();\\n\\n        for (int i = 0; i<n; i++)\\n        {\\n            if (nums[i] == key)\\n                keyIndices.add(i);\\n        }\\n        if (keyIndices.isEmpty())\\n            return result;\\n        \\n        int index = 0;\\n        for (int i = 0; i<n; i++)\\n        {\\n            while (index < keyIndices.size())\\n            {\\n                if (Math.abs(i-keyIndices.get(index)) <=k)\\n                {\\n                    result.add(i);\\n                    break;\\n                }\\n                else if (i > keyIndices.get(index))\\n                    index++;\\n                else\\n                    break;\\n            }\\n            \\n            if (index >= keyIndices.size())\\n                return result;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        int n = nums.length;\\n        List<Integer> keyIndices = new ArrayList<>();\\n        List<Integer> result = new ArrayList<>();\\n\\n        for (int i = 0; i<n; i++)\\n        {\\n            if (nums[i] == key)\\n                keyIndices.add(i);\\n        }\\n        if (keyIndices.isEmpty())\\n            return result;\\n        \\n        int index = 0;\\n        for (int i = 0; i<n; i++)\\n        {\\n            while (index < keyIndices.size())\\n            {\\n                if (Math.abs(i-keyIndices.get(index)) <=k)\\n                {\\n                    result.add(i);\\n                    break;\\n                }\\n                else if (i > keyIndices.get(index))\\n                    index++;\\n                else\\n                    break;\\n            }\\n            \\n            if (index >= keyIndices.size())\\n                return result;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355084,
                "title": "swift-solution-with-explanations",
                "content": "# Approach\\n1. Create an empty array called ans\\n2. Create a for loop that goes through every index in nums\\n3. Create another for loop that goes through every index in nums\\n4. If the current number in nums is equal to the key and the absolute difference between the current index of the first for loop and the current index of the second for loop is less than or equal to k\\n5. Append the current index of the first for loop to ans\\n6. Break out of the second for loop\\n7. Return ans\\n\\n- Note that this code is not the most efficient way to solve the problem, but it gets the job done.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\n    func findKDistantIndices(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] \\n    {\\n        var ans = [Int]()\\n        \\n        for i in 0..<nums.count\\n        {\\n            for j in 0..<nums.count\\n            {\\n                if nums[j] == key && abs(i - j) <= k\\n                {\\n                    ans.append(i)\\n                    break\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution \\n{\\n    func findKDistantIndices(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] \\n    {\\n        var ans = [Int]()\\n        \\n        for i in 0..<nums.count\\n        {\\n            for j in 0..<nums.count\\n            {\\n                if nums[j] == key && abs(i - j) <= k\\n                {\\n                    ans.append(i)\\n                    break\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354640,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = 0; j < nums.length; j++){\\n                if(nums[j] == key && Math.abs(i - j) <=k){\\n                    ans.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = 0; j < nums.length; j++){\\n                if(nums[j] == key && Math.abs(i - j) <=k){\\n                    ans.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336890,
                "title": "php-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $key\\n     * @param Integer $k\\n     * @return Integer[]\\n     */\\n    function findKDistantIndices($nums, $key, $k) {\\n        $res = [];\\n\\n        for($i = 0; $i < count($nums); $i++){\\n            for($j = 0; $j < count($nums); $j++){\\n                    if(abs($i - $j) <= $k && $nums[$j] == $key){\\n                        array_push($res, $i);\\n                        break;\\n                    }\\n            }\\n        }\\n        sort($res);\\n        return $res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $key\\n     * @param Integer $k\\n     * @return Integer[]\\n     */\\n    function findKDistantIndices($nums, $key, $k) {\\n        $res = [];\\n\\n        for($i = 0; $i < count($nums); $i++){\\n            for($j = 0; $j < count($nums); $j++){\\n                    if(abs($i - $j) <= $k && $nums[$j] == $key){\\n                        array_push($res, $i);\\n                        break;\\n                    }\\n            }\\n        }\\n        sort($res);\\n        return $res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305931,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        indicies = []\\n\\n        for i in range(len(nums)):\\n            if key in nums[max(0, i-k):min(len(nums), i+k+1)]:\\n                indicies.append(i)\\n        \\n        return indicies\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        indicies = []\\n\\n        for i in range(len(nums)):\\n            if key in nums[max(0, i-k):min(len(nums), i+k+1)]:\\n                indicies.append(i)\\n        \\n        return indicies\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290769,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\n        int len = nums.length;\\n        List<Integer> l = new ArrayList<>();\\n\\n        for (int i = 0; i < len; i++) {\\n            for (int j = 0; j < len; j++) {\\n                if(Math.abs(i-j) <= k && nums[j] == key){\\n                    l.add(i);\\n                }\\n            }\\n        }\\n\\n        return l.stream().collect(Collectors.toSet()).stream().sorted().toList();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\n        int len = nums.length;\\n        List<Integer> l = new ArrayList<>();\\n\\n        for (int i = 0; i < len; i++) {\\n            for (int j = 0; j < len; j++) {\\n                if(Math.abs(i-j) <= k && nums[j] == key){\\n                    l.add(i);\\n                }\\n            }\\n        }\\n\\n        return l.stream().collect(Collectors.toSet()).stream().sorted().toList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285375,
                "title": "python-very-nice-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        idxkeys = [idx for idx, i in enumerate(nums) if i == key]\\n        ll = []\\n        for idx, i in enumerate(nums):\\n            for ky in idxkeys:\\n                if abs(idx - ky) <= k:\\n                    ll.append(idx)\\n                    break\\n        return ll\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        idxkeys = [idx for idx, i in enumerate(nums) if i == key]\\n        ll = []\\n        for idx, i in enumerate(nums):\\n            for ky in idxkeys:\\n                if abs(idx - ky) <= k:\\n                    ll.append(idx)\\n                    break\\n        return ll\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269249,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        arr = []\\n        ans = []\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                arr.append(i)\\n        for i in range(len(nums)):\\n            for j in arr:\\n                if abs(i-j) <= k:\\n                    ans.append(i)\\n                    break\\n        return ans\\n\\n\\n```\\nDo upvote if you like the Solution :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        arr = []\\n        ans = []\\n        for i in range(len(nums)):\\n            if nums[i] == key:\\n                arr.append(i)\\n        for i in range(len(nums)):\\n            for j in arr:\\n                if abs(i-j) <= k:\\n                    ans.append(i)\\n                    break\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265171,
                "title": "java-javascript-solution-jw",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nJava:\\n```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n    List<Integer> idx = new ArrayList<>();\\n    List<Integer> ans = new ArrayList<>();\\n    for(int i = 0 ; i < nums.length; i++){\\n        if(nums[i] == key){\\n            idx.add(i);\\n        }\\n    }\\n    int last = 0;\\n    for(int ind : idx){\\n        int i = Math.max(last,ind-k);\\n        for(; i <= ind+k && i < nums.length; i++){\\n            ans.add(i);\\n        }\\n        last = i;\\n    }\\n    return ans;\\n}\\n```\\nJavascript:\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    let idx = [];\\n    let ans = [];\\n    for (let i = 0 ; i < nums.length; i++) {\\n        if(nums[i] === key){\\n            idx.push(i);\\n        }\\n    }\\n    let last = 0;\\n    for (let ind of idx) {\\n        let i = Math.max(last, ind - k);\\n        for(; i <= ind + k && i < nums.length; i++){\\n            ans.push(i);\\n        }\\n        last = i;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\npublic List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n    List<Integer> idx = new ArrayList<>();\\n    List<Integer> ans = new ArrayList<>();\\n    for(int i = 0 ; i < nums.length; i++){\\n        if(nums[i] == key){\\n            idx.add(i);\\n        }\\n    }\\n    int last = 0;\\n    for(int ind : idx){\\n        int i = Math.max(last,ind-k);\\n        for(; i <= ind+k && i < nums.length; i++){\\n            ans.add(i);\\n        }\\n        last = i;\\n    }\\n    return ans;\\n}\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} key\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar findKDistantIndices = function(nums, key, k) {\\n    let idx = [];\\n    let ans = [];\\n    for (let i = 0 ; i < nums.length; i++) {\\n        if(nums[i] === key){\\n            idx.push(i);\\n        }\\n    }\\n    let last = 0;\\n    for (let ind of idx) {\\n        let i = Math.max(last, ind - k);\\n        for(; i <= ind + k && i < nums.length; i++){\\n            ans.push(i);\\n        }\\n        last = i;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3240226,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        indexes = []\\n        res = []\\n        for i,j in enumerate(nums):\\n            if j == key:\\n                indexes.append(i)\\n        for t in range(len(nums)):\\n            for yy in indexes:\\n                if abs(yy-t) <= k:\\n                    res.append(t)\\n                    break\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        indexes = []\\n        res = []\\n        for i,j in enumerate(nums):\\n            if j == key:\\n                indexes.append(i)\\n        for t in range(len(nums)):\\n            for yy in indexes:\\n                if abs(yy-t) <= k:\\n                    res.append(t)\\n                    break\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236106,
                "title": "sliding-window-approach-neat-explanation-clean-c-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the indices of elements that are k distances away from the given key in a given array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a sliding window approach to find the indices. We can keep a window of size nk+1 (where nk is 2k+1), and slide this window through the array. For each position i, we check if the element i-k-1 is the key, then decrement the count of keys. If the element i+k is the key, then we increment the count of keys. If the count of keys is greater than zero, we add the index i to our result.\\n\\n# Complexity\\n- Time complexity: $$O(n log n)$$ for sorting the result vector after finding the indices.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for the result vector and the count of keys.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int nk = 2*k + 1;\\n        int n = nums.size();\\n        vector<int> res;\\n        int keys = 0;\\n        for(int i = 0; i < k + 1 && i < n; i++) {\\n            if(nums[i] == key) {\\n                keys++;\\n            }\\n        }\\n        if(keys > 0) {\\n            res.push_back(0);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            if((i - k - 1 >= 0) && nums[i-k-1] == key) {\\n                keys--;\\n            }\\n            if((i + k < n) && nums[i+k] == key) {\\n                keys++;\\n            }\\n            if(keys > 0) {\\n                res.push_back(i);\\n            }\\n        }\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        int nk = 2*k + 1;\\n        int n = nums.length;\\n        List<Integer> res = new ArrayList<>();\\n        int keys = 0;\\n        for(int i = 0; i < k + 1 && i < n; i++) {\\n            if(nums[i] == key) {\\n                keys++;\\n            }\\n        }\\n        if(keys > 0) {\\n            res.add(0);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            if((i - k - 1 >= 0) && nums[i-k-1] == key) {\\n                keys--;\\n            }\\n            if((i + k < n) && nums[i+k] == key) {\\n                keys++;\\n            }\\n            if(keys > 0) {\\n                res.add(i);\\n            }\\n        }\\n        Collections.sort(res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        int nk = 2*k + 1;\\n        int n = nums.size();\\n        vector<int> res;\\n        int keys = 0;\\n        for(int i = 0; i < k + 1 && i < n; i++) {\\n            if(nums[i] == key) {\\n                keys++;\\n            }\\n        }\\n        if(keys > 0) {\\n            res.push_back(0);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            if((i - k - 1 >= 0) && nums[i-k-1] == key) {\\n                keys--;\\n            }\\n            if((i + k < n) && nums[i+k] == key) {\\n                keys++;\\n            }\\n            if(keys > 0) {\\n                res.push_back(i);\\n            }\\n        }\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        int nk = 2*k + 1;\\n        int n = nums.length;\\n        List<Integer> res = new ArrayList<>();\\n        int keys = 0;\\n        for(int i = 0; i < k + 1 && i < n; i++) {\\n            if(nums[i] == key) {\\n                keys++;\\n            }\\n        }\\n        if(keys > 0) {\\n            res.add(0);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            if((i - k - 1 >= 0) && nums[i-k-1] == key) {\\n                keys--;\\n            }\\n            if((i + k < n) && nums[i+k] == key) {\\n                keys++;\\n            }\\n            if(keys > 0) {\\n                res.add(i);\\n            }\\n        }\\n        Collections.sort(res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233981,
                "title": "c-hashset-solution-o-n-2-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Iterate through the array to identify all the index where nums[index] == key - store the info in HashSet.\\n2. Iterate through the array to check if the condition of |j - i| <= k.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2) - this solution provides clear view on solving the problem, but it unfortunately expensive one of O(n^2).  An optimized solution of O(n) is available - posted by others for other languages.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> FindKDistantIndices(int[] nums, int key, int k) {\\n\\n        var set = new HashSet<int>();\\n        var result = new List<int>();\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] == key) set.Add(i);\\n        }\\n\\n        for (int j = 0; j < nums.Length; j++)\\n        {\\n            foreach (var index in set)\\n            {\\n                if (Math.Abs(j - index) <= k)  \\n                { result.Add(j); break; } \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> FindKDistantIndices(int[] nums, int key, int k) {\\n\\n        var set = new HashSet<int>();\\n        var result = new List<int>();\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] == key) set.Add(i);\\n        }\\n\\n        for (int j = 0; j < nums.Length; j++)\\n        {\\n            foreach (var index in set)\\n            {\\n                if (Math.Abs(j - index) <= k)  \\n                { result.Add(j); break; } \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215175,
                "title": "find-all-k-distant-indices-in-an-array",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        l = []\\n        for i in range(len(nums)):\\n            if nums[i]==key:\\n                l.append(i)\\n        # print(l)\\n        p = []\\n        # count = 0\\n        for i in range(len(nums)):\\n            for j in l:\\n                if abs(i-j)<=k:\\n                    p.append(i)\\n                    break\\n                    \\n                    # count+=1\\n        # print(count)\\n        p.sort()\\n        return (p)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        l = []\\n        for i in range(len(nums)):\\n            if nums[i]==key:\\n                l.append(i)\\n        # print(l)\\n        p = []\\n        # count = 0\\n        for i in range(len(nums)):\\n            for j in l:\\n                if abs(i-j)<=k:\\n                    p.append(i)\\n                    break\\n                    \\n                    # count+=1\\n        # print(count)\\n        p.sort()\\n        return (p)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214537,
                "title": "simple-solution-to-understand-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\n       Set<Integer> set = new HashSet<>();\\n\\n       for (int i = 0; i < nums.length; i++) {\\n           for (int j = 0; j < nums.length; j++) {\\n               if (nums[j] == key && Math.abs(i - j) <= k)\\n                set.add(i);\\n           }\\n       } \\n        List<Integer> list = new ArrayList<Integer>(set);\\n        \\n        Collections.sort(list);\\n\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n\\n       Set<Integer> set = new HashSet<>();\\n\\n       for (int i = 0; i < nums.length; i++) {\\n           for (int j = 0; j < nums.length; j++) {\\n               if (nums[j] == key && Math.abs(i - j) <= k)\\n                set.add(i);\\n           }\\n       } \\n        List<Integer> list = new ArrayList<Integer>(set);\\n        \\n        Collections.sort(list);\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214136,
                "title": "scala-oneliner",
                "content": "```\\nobject Solution {\\n  def findKDistantIndices(nums: Array[Int], key: Int, k: Int): List[Int] =\\n    nums.iterator.zipWithIndex.filter(_._1 == key).map(_._2).to(Set)\\n      .flatMap{i:Int => (0.max(i-k) to (i+k).min(nums.size-1))}.toList.sorted\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def findKDistantIndices(nums: Array[Int], key: Int, k: Int): List[Int] =\\n    nums.iterator.zipWithIndex.filter(_._1 == key).map(_._2).to(Set)\\n      .flatMap{i:Int => (0.max(i-k) to (i+k).min(nums.size-1))}.toList.sorted\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3203643,
                "title": "python-clean-and-simple-o-n-solution",
                "content": "```\\nclass Solution:\\n    def findKDistantIndices(self, A: list[int], key: int, k: int) -> list[int]:\\n        it = (idx for idx, a in enumerate(A) if a == key)  # creating generator from indices of \"key\"\\n\\n        i, n = 0, len(A)\\n        output = []\\n\\n        while i < n and (idx := next(it, n)) < n:\\n            i, j = max(i, idx - k), min(idx + k, n - 1)\\n\\n            output.extend(range(i, j + 1))  # + 1 to include index j in output\\n\\n            i = j + 1\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, A: list[int], key: int, k: int) -> list[int]:\\n        it = (idx for idx, a in enumerate(A) if a == key)  # creating generator from indices of \"key\"\\n\\n        i, n = 0, len(A)\\n        output = []\\n\\n        while i < n and (idx := next(it, n)) < n:\\n            i, j = max(i, idx - k), min(idx + k, n - 1)\\n\\n            output.extend(range(i, j + 1))  # + 1 to include index j in output\\n\\n            i = j + 1\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192161,
                "title": "easy-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(abs(i-j)<=k and nums[j]==key)\\n                {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(abs(i-j)<=k and nums[j]==key)\\n                {\\n                    ans.push_back(i);\\n                    break;\\n                }\\n            }\\n\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158281,
                "title": "java-o-n-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> list1 = new ArrayList<>();\\n        List<Integer> list2 = new ArrayList<>();\\n\\n        for(int i = 0;i<nums.length ; i++){\\n            if(nums[i] == key)\\n                list1.add(i);\\n        }\\n        int last = 0;\\n        for(int i = 0;i<list1.size();i++){\\n            int j = Math.max(list1.get(i) - k,last);\\n            for(;j<=list1.get(i)+k;j++){\\n                if(j < nums.length)\\n                    list2.add(j);\\n            }\\n            last = j;\\n        }\\n        return list2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> list1 = new ArrayList<>();\\n        List<Integer> list2 = new ArrayList<>();\\n\\n        for(int i = 0;i<nums.length ; i++){\\n            if(nums[i] == key)\\n                list1.add(i);\\n        }\\n        int last = 0;\\n        for(int i = 0;i<list1.size();i++){\\n            int j = Math.max(list1.get(i) - k,last);\\n            for(;j<=list1.get(i)+k;j++){\\n                if(j < nums.length)\\n                    list2.add(j);\\n            }\\n            last = j;\\n        }\\n        return list2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148789,
                "title": "pyhton-o-n-time-space-easy-fast-no-sorting",
                "content": "![image.png](https://assets.leetcode.com/users/images/091831b2-4009-4f1e-8aa3-0ed5d91f737d_1675653039.5216413.png)\\n\\n# Intuition\\nAdd all the indexes around the key to the result.\\n\\n# Approach\\nFor every num that equal to key, we prepare the index range that meets the requirements, and also use min and max function to avoid index out of range and interval overlap.\\n\\nCheers!\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findKDistantIndices(self, nums, key, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type key: int\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        result = []\\n        prev = 0\\n        for i, num in enumerate(nums):\\n            if num == key:\\n                result += range(max(prev, i-k), min(i+k, len(nums)-1)+1)\\n                prev = min(i+k, len(nums)-1)+1\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findKDistantIndices(self, nums, key, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type key: int\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        result = []\\n        prev = 0\\n        for i, num in enumerate(nums):\\n            if num == key:\\n                result += range(max(prev, i-k), min(i+k, len(nums)-1)+1)\\n                prev = min(i+k, len(nums)-1)+1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146919,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n       vector<int>v;\\n       for(int i=0; i<nums.size();i++){\\n           for(int j=0; j<nums.size(); j++){\\n               if(abs(i-j)<=k && nums[j]==key){\\n                  v.push_back(i);\\n                  break;\\n               }   \\n           }\\n       }\\n       return v; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n       vector<int>v;\\n       for(int i=0; i<nums.size();i++){\\n           for(int j=0; j<nums.size(); j++){\\n               if(abs(i-j)<=k && nums[j]==key){\\n                  v.push_back(i);\\n                  break;\\n               }   \\n           }\\n       }\\n       return v; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108577,
                "title": "easy-c-brute-force-god-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvoid check(vector<int>& ans,vector<int>& nums,int i,int k){\\n    for(int j=0;j<nums.size();j++){\\n        if(abs(j-i)<=k){\\n            ans.push_back(j);\\n        }\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==key){\\n                check(ans,nums,i,k);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvoid check(vector<int>& ans,vector<int>& nums,int i,int k){\\n    for(int j=0;j<nums.size();j++){\\n        if(abs(j-i)<=k){\\n            ans.push_back(j);\\n        }\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==key){\\n                check(ans,nums,i,k);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101670,
                "title": "python3-simple-runtime-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/e73f61a5-ff5b-4464-a6f0-f686a6e13bea_1674736602.7959375.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums, key, k):\\n        res, l = [], len(nums)\\n        if l == 1 or len(set(nums)) == 1 and key in nums:\\n            return [i for i in range(l)]\\n        else:\\n            for idx, ele in enumerate(nums):\\n                if key == ele:\\n                    start = idx - k if idx - k > 0 else 0\\n                    end = idx + k + 1 if idx + k < l else l\\n                    for i in range(start, end):\\n                        res.append(i)\\n        return set(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums, key, k):\\n        res, l = [], len(nums)\\n        if l == 1 or len(set(nums)) == 1 and key in nums:\\n            return [i for i in range(l)]\\n        else:\\n            for idx, ele in enumerate(nums):\\n                if key == ele:\\n                    start = idx - k if idx - k > 0 else 0\\n                    end = idx + k + 1 if idx + k < l else l\\n                    for i in range(start, end):\\n                        res.append(i)\\n        return set(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085405,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& a, int key, int k) {\\n      int n=a.size();\\n      int p=0;\\n      map<int,int>mp;\\n      vector<int>v;\\n      vector<int>e;\\n      \\n        for(int j=0;j<n;j++)\\n      {\\n          \\n          { for(int i=0;i<n;i++)\\n          {  if(a[j]==key && abs(i-j)<=k)\\n              \\n              v.push_back(i);\\n          }\\n              \\n          }\\n         \\n      }\\n      for(int h=0;h<v.size();h++)\\n      { mp[v[h]]++;}\\n      for(auto h:mp)\\n      {\\n          e.push_back(h.first);\\n      }\\n      return e;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findKDistantIndices(vector<int>& a, int key, int k) {\\n      int n=a.size();\\n      int p=0;\\n      map<int,int>mp;\\n      vector<int>v;\\n      vector<int>e;\\n      \\n        for(int j=0;j<n;j++)\\n      {\\n          \\n          { for(int i=0;i<n;i++)\\n          {  if(a[j]==key && abs(i-j)<=k)\\n              \\n              v.push_back(i);\\n          }\\n              \\n          }\\n         \\n      }\\n      for(int h=0;h<v.size();h++)\\n      { mp[v[h]]++;}\\n      for(auto h:mp)\\n      {\\n          e.push_back(h.first);\\n      }\\n      return e;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060360,
                "title": "python3-beats-98-72-constant-space-key-ranges-approach",
                "content": "# Intuition\\nFind all the `key` positions. Each key covers a `2k`-range of indices that needs to be added. Only problem that may arise is if the range either spills out of the array length, or if it overlaps with another range. To account for this, we can keep track of the most recently added index.\\n\\n# Approach\\nFind the keys and generate the ranges they produce. At the start we\\'ve `covered` 0 indices. For each range, adjust the range by keeping left greater than or equal to what has already been covered.\\n\\n# Complexity\\n- $$n=len(nums)$$\\n\\n- Time complexity:  $$O(n)$$ as in any case we are only seeing each number in `nums` once because `covered` adjusts our pointer past seen numbers.\\n\\n- Space complexity:  $$O(1)$$ extra space as we iterate over a generator.\\n\\n# Code\\n```Python\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        res: List[int] = []\\n\\n        keyRanges = ((pos - k, pos + k) for pos, num in enumerate(nums) if num == key)\\n        covered = 0\\n        for keyLeft, keyRight in keyRanges:\\n            keyLeft, keyRight = max(keyLeft, covered), min(keyRight + 1, len(nums))\\n            for i in range(keyLeft, keyRight):\\n                res.append(i)\\n                covered = keyRight\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        res: List[int] = []\\n\\n        keyRanges = ((pos - k, pos + k) for pos, num in enumerate(nums) if num == key)\\n        covered = 0\\n        for keyLeft, keyRight in keyRanges:\\n            keyLeft, keyRight = max(keyLeft, covered), min(keyRight + 1, len(nums))\\n            for i in range(keyLeft, keyRight):\\n                res.append(i)\\n                covered = keyRight\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057385,
                "title": "c-fast-o-n-solution-135ms-100",
                "content": "# Code\\n```\\npublic class Solution {\\n    public IList<int> FindKDistantIndices(int[] nums, int key, int k) \\n    {\\n        var r = new List<int>(nums.Length);\\n\\n        var i = Array.IndexOf(nums, key);\\n\\n        if(i < 0) return r;\\n\\n        r.Add(Math.Max(0, i-k)); // Initial index. The rest distant indexes for \\'i\\' will be filled in the loop.\\n\\n        for(var len1 = nums.Length-1; i <= len1; i++)\\n        {\\n            if(nums[i] != key) continue;\\n\\n            var (from, to) = (Math.Max(r[^1] + 1, i-k), Math.Min(i+k, len1));\\n\\n            while(from <= to) r.Add(from++);\\n        }\\n\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> FindKDistantIndices(int[] nums, int key, int k) \\n    {\\n        var r = new List<int>(nums.Length);\\n\\n        var i = Array.IndexOf(nums, key);\\n\\n        if(i < 0) return r;\\n\\n        r.Add(Math.Max(0, i-k)); // Initial index. The rest distant indexes for \\'i\\' will be filled in the loop.\\n\\n        for(var len1 = nums.Length-1; i <= len1; i++)\\n        {\\n            if(nums[i] != key) continue;\\n\\n            var (from, to) = (Math.Max(r[^1] + 1, i-k), Math.Min(i+k, len1));\\n\\n            while(from <= to) r.Add(from++);\\n        }\\n\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047606,
                "title": "easy-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        li=[]\\n        for i in range(len(nums)):\\n            if nums[i]==key:\\n                li.append(i)\\n        s=0\\n        li1=[]\\n        for i in range(len(nums)):\\n            for j in li:\\n                if abs(i-j)<=k:\\n                    li1.append(s)\\n                    break\\n            s+=1\\n        return li1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        li=[]\\n        for i in range(len(nums)):\\n            if nums[i]==key:\\n                li.append(i)\\n        s=0\\n        li1=[]\\n        for i in range(len(nums)):\\n            for j in li:\\n                if abs(i-j)<=k:\\n                    li1.append(s)\\n                    break\\n            s+=1\\n        return li1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043926,
                "title": "simple-java-solution-with-explanation-one-pass",
                "content": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0, j = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                for (j = Math.max(i - k, j); j <= Math.min(nums.length - 1, i + k); j++) {\\n                    result.add(j);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0, j = 0; i < nums.length; i++) {\\n            if (nums[i] == key) {\\n                for (j = Math.max(i - k, j); j <= Math.min(nums.length - 1, i + k); j++) {\\n                    result.add(j);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038809,
                "title": "java-search-iterator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRequires the position of all the indexes at which we have key.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGet all the positions at which we have key. Now iterator over all nums and with iteator over the foundIndexes check for i<=it.next();. If found add it to list.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> response = new ArrayList<>();\\n        List<Integer> foundIndexes = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] == key)\\n                foundIndexes.add(i);\\n        for (int i = 0; i < nums.length; i++) {\\n            Iterator<Integer> it = foundIndexes.iterator();\\n            while (it.hasNext()) {\\n                if (Math.abs(i - it.next()) <= k) {\\n                    response.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return response;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\\n        List<Integer> response = new ArrayList<>();\\n        List<Integer> foundIndexes = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] == key)\\n                foundIndexes.add(i);\\n        for (int i = 0; i < nums.length; i++) {\\n            Iterator<Integer> it = foundIndexes.iterator();\\n            while (it.hasNext()) {\\n                if (Math.abs(i - it.next()) <= k) {\\n                    response.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return response;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037906,
                "title": "python3-using-set",
                "content": "# Intuition\\nEssentially, the question is just asking to find value \\'key\\' in the array and then record the indices \\'k\\' spaces around it. If done in linear fashion, it will naturally yield a sorted result.\\n\\n# Approach\\n1. Initialize result set as I do not want duplicate indices added\\n2. For every number in array, check if value is equal to \\'key\\'\\n    1. if value is equal, then add all indices from (i - k) to (i + k) inclusively to the set\\n    2. if such values run out of the array, then make sure to check for the correct limit\\n3. Finally, return set as a list\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        res = set()\\n        for i, val in enumerate(nums):\\n            if val == key:\\n                low = i - k if i - k >= 0 else 0\\n                high = i + k + 1 if i + k + 1 < len(nums) else len(nums)\\n                res.update(range(low, high))\\n        return list(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\\n        res = set()\\n        for i, val in enumerate(nums):\\n            if val == key:\\n                low = i - k if i - k >= 0 else 0\\n                high = i + k + 1 if i + k + 1 < len(nums) else len(nums)\\n                res.update(range(low, high))\\n        return list(res)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": []
    },
    {
        "title": "The Users That Are Eligible for Discount",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Count Number of Rectangles Containing Each Point",
        "question_content": "<p>You are given a 2D integer array <code>rectangles</code> where <code>rectangles[i] = [l<sub>i</sub>, h<sub>i</sub>]</code> indicates that <code>i<sup>th</sup></code> rectangle has a length of <code>l<sub>i</sub></code> and a height of <code>h<sub>i</sub></code>. You are also given a 2D integer array <code>points</code> where <code>points[j] = [x<sub>j</sub>, y<sub>j</sub>]</code> is a point with coordinates <code>(x<sub>j</sub>, y<sub>j</sub>)</code>.</p>\n\n<p>The <code>i<sup>th</sup></code> rectangle has its <strong>bottom-left corner</strong> point at the coordinates <code>(0, 0)</code> and its <strong>top-right corner</strong> point at <code>(l<sub>i</sub>, h<sub>i</sub>)</code>.</p>\n\n<p>Return<em> an integer array </em><code>count</code><em> of length </em><code>points.length</code><em> where </em><code>count[j]</code><em> is the number of rectangles that <strong>contain</strong> the </em><code>j<sup>th</sup></code><em> point.</em></p>\n\n<p>The <code>i<sup>th</sup></code> rectangle <strong>contains</strong> the <code>j<sup>th</sup></code> point if <code>0 &lt;= x<sub>j</sub> &lt;= l<sub>i</sub></code> and <code>0 &lt;= y<sub>j</sub> &lt;= h<sub>i</sub></code>. Note that points that lie on the <strong>edges</strong> of a rectangle are also considered to be contained by that rectangle.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/example1.png\" style=\"width: 300px; height: 509px;\" />\n<pre>\n<strong>Input:</strong> rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]\n<strong>Output:</strong> [2,1]\n<strong>Explanation:</strong> \nThe first rectangle contains no points.\nThe second rectangle contains only the point (2, 1).\nThe third rectangle contains the points (2, 1) and (1, 4).\nThe number of rectangles that contain the point (2, 1) is 2.\nThe number of rectangles that contain the point (1, 4) is 1.\nTherefore, we return [2, 1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/example2.png\" style=\"width: 300px; height: 312px;\" />\n<pre>\n<strong>Input:</strong> rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]\n<strong>Output:</strong> [1,3]\n<strong>Explanation:\n</strong>The first rectangle contains only the point (1, 1).\nThe second rectangle contains only the point (1, 1).\nThe third rectangle contains the points (1, 3) and (1, 1).\nThe number of rectangles that contain the point (1, 3) is 1.\nThe number of rectangles that contain the point (1, 1) is 3.\nTherefore, we return [1, 3].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rectangles.length, points.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>rectangles[i].length == points[j].length == 2</code></li>\n\t<li><code>1 &lt;= l<sub>i</sub>, x<sub>j</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= h<sub>i</sub>, y<sub>j</sub> &lt;= 100</code></li>\n\t<li>All the <code>rectangles</code> are <strong>unique</strong>.</li>\n\t<li>All the <code>points</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1976969,
                "title": "java-c-python-detailed-explanation-fully-commented-binary-search-l-among-points-of-h",
                "content": "See the contraints carefully.\\n```\\n1 <= rectangles.length, points.length <= 5 * 10^4\\n1 <= li, xj <= 10^9\\n1 <= hi, yj <= 100\\n```\\n\\nThis tells us that we cannot go through all the rectangles for all the points, coz that will be 5 * 10^4 * 5* 10^4 which would be > 10^8 operations, so would give TLE.\\n\\nThis gives **intution** of doing something like binary search.\\nBut how do we do that?\\n\\nWe see that heights are only from 0 to 100. So can traverse in them. But lengths can be till 10^9 so have to do binary search in that.\\n\\nSo, we create an unordered_map which maps each height to lengths of rectangles having that height.\\n\\nThen we sort all those length vectors (since we have to apply binary search)\\n\\nWe make a helper function for binary search which gives the idx of the first position with value greater than or equal to given x.\\n\\nNow just binary search for all the heights from 0 to 100 and get how many lengths are greater than the x cordinate of the point. The sum of all of these is our answer.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// helper fxn for binary search\\n    int binsear(vector<int>& arr, int x){\\n        int l=0, r=arr.size()-1;\\n        \\n        int anstillnow=arr.size(); \\n\\t\\t// if we find no m such that arr[m]>=x, means that our x is greater than all values of length, in such case we return idx n (i.e. size of arr)\\n\\t\\t// reason being, we substract our idx by size of arr to get number of rectangles greater than that in main fxn, so return arr.size would give us 0 (which we want)\\n\\t\\t\\n        while(l<=r){\\n            int m= l + (r-l)/2;\\n            \\n            \\n            if(arr[m]>=x){\\n                anstillnow=m;\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n            \\n        }\\n        \\n        return anstillnow;\\n    }\\n    \\n    \\n    vector<int> countRectangles(vector<vector<int>>& rect, vector<vector<int>>& points) {\\n        \\n        unordered_map<int, vector<int>> htl;\\n        // maps heights to all the lengths of rectangles with that height\\n        \\n        for(int i=0; i<rect.size(); i++){       \\n            htl[rect[i][1]].push_back(rect[i][0]);\\n        }\\n        \\n\\t\\t// have to sort the containers to apply binary search\\n        for(int i=0; i<=100; i++){\\n            sort(htl[i].begin(), htl[i].end());\\n        }\\n        \\n\\t\\t\\n        vector<int> ans;\\n\\t\\t\\n        for(vector<int> p: points){\\n            int x=p[0], y=p[1];\\n            int ct=0;\\n            for(int j= y; j<=100; j++){\\n                if(htl.find(j)!=htl.end()){\\n                    ct+= htl[j].size()- binsear(htl[j], x);\\n\\t\\t\\t\\t\\t// binary search return the idx in array from which the values are >= x\\n\\t\\t\\t\\t\\t// the values at this and right of this are the lengths possible\\n\\t\\t\\t\\t\\t// so substract by size of array to get the number\\n                }\\n            }\\n            \\n            ans.push_back(ct);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Java:**\\n```\\nclass Solution {\\n    \\n\\t// helper fxn for binary search\\n    int binsear(ArrayList<Integer> arr, int x){\\n        int l=0, r=arr.size()-1;\\n        \\n        int anstillnow=arr.size(); \\n\\t\\t// if we find no m such that arr[m]>=x, means that our x is greater than all values of length, in such case we return idx n (i.e. size of arr)\\n\\t\\t// reason being, we substract our idx by size of arr to get number of rectangles greater than that in main fxn, so return arr.size would give us 0 (which we want)\\n\\t\\t\\n        while(l<=r){\\n            int m= l + (r-l)/2;\\n            \\n            \\n            if(arr.get(m)>=x){\\n                anstillnow=m;\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n            \\n        }\\n        \\n        return anstillnow;\\n    }\\n    \\n    public int[] countRectangles(int[][] rect, int[][] points) {\\n        HashMap<Integer, ArrayList<Integer>> htl= new HashMap<>();\\n        // maps heights to all the lengths of rectangles with that height\\n        \\n        for(int i=0; i<rect.length; i++){       \\n            if(htl.containsKey(rect[i][1])) htl.get(rect[i][1]).add(rect[i][0]);\\n            else \\n            {\\n                htl.put(rect[i][1],new ArrayList<>());\\n                htl.get(rect[i][1]).add(rect[i][0]);\\n            }\\n        }\\n        \\n\\t\\t// have to sort the container to apply binary search\\n        for(int a:htl.keySet()){\\n            Collections.sort(htl.get(a));        \\n        }\\n\\t\\t\\n        int[] ans = new int[points.length];\\n\\t\\t\\n        for(int i=0;i<points.length;i++){\\n            int x=points[i][0], y=points[i][1];\\n            int ct=0;\\n            for(int j= y; j<=100; j++){\\n                if(htl.containsKey(j)){\\n                    ct+= htl.get(j).size()- binsear(htl.get(j), x);\\n\\t\\t\\t\\t\\t// binary search return the idx in array from which the values are >= x\\n\\t\\t\\t\\t\\t// the values at this and right of this are the lengths possible\\n\\t\\t\\t\\t\\t// so substract by size of array to get the number\\n                }\\n            }\\n            \\n            ans[i]=ct;\\n            \\n        }\\n        \\n        return ans;        \\n    }\\n}\\n```\\n\\n**Python:**\\n```\\n# helper fxn for binary search\\ndef binsear(arr, x):\\n    l=0\\n    r=len(arr)-1\\n\\n    anstillnow=len(arr)\\n    # if we find no m such that arr[m]>=x, means that our x is greater than all values of length, in such case we return idx n (i.e. size of arr)\\n    # reason being, we substract our idx by size of arr to get number of rectangles greater than that in main fxn, so return arr.size would give us 0 (which we want)\\n\\n    while(l<=r):\\n        m= l + (r-l)//2\\n\\n\\n        if(arr[m]>=x):\\n            anstillnow=m\\n            r=m-1;\\n\\n        else:\\n            l=m+1\\n\\n    return anstillnow\\n\\n    \\nclass Solution:\\n\\n    def countRectangles(self, rect: List[List[int]], points: List[List[int]]) -> List[int]:\\n        \\n        # create a dictionary of int -> list of int\\n        htl=defaultdict(list)\\n        \\n        # maps heights to all the lengths of rectangles with that height\\n        for l, h in rect:       \\n            htl[h].append(l)\\n        \\n\\t\\t# have to sort the containers to apply binary search\\n        for k,v in htl.items():\\n            v.sort()\\n        \\n\\t\\t\\n        ans=[];\\n\\t\\t\\n        for p in points:\\n            x=p[0]\\n            y=p[1]\\n            \\n            ct=0\\n            \\n            for j in range(y, 101):\\n                if j in htl:\\n                    ct+= len(htl[j]) - binsear(htl[j], x)\\n                    \\n\\t\\t\\t\\t\\t# binary search return the idx in array from which the values are >= x\\n\\t\\t\\t\\t\\t# the values at this and right of this are the lengths possible\\n\\t\\t\\t\\t\\t# so substract by size of array to get the number\\n            \\n            ans.append(ct)\\n        \\n        return ans\\n```\\n\\n\\n**Time Complexity Analysis:**\\nTime: O( m * 100 * log(n) ) : where m is the number of points, and 100 comes from the range of heights (1 to 100) and log(n) for binary search in range n (range for lengths) \\nSpace: O(n) : space used by unordered map (all the list mappings combinedly would store all the lengths which is n)\\n\\n**Please upvote if you liked it.**",
                "solutionTags": [],
                "code": "```\\n1 <= rectangles.length, points.length <= 5 * 10^4\\n1 <= li, xj <= 10^9\\n1 <= hi, yj <= 100\\n```\n```\\nclass Solution {\\npublic:\\n    \\n\\t// helper fxn for binary search\\n    int binsear(vector<int>& arr, int x){\\n        int l=0, r=arr.size()-1;\\n        \\n        int anstillnow=arr.size(); \\n\\t\\t// if we find no m such that arr[m]>=x, means that our x is greater than all values of length, in such case we return idx n (i.e. size of arr)\\n\\t\\t// reason being, we substract our idx by size of arr to get number of rectangles greater than that in main fxn, so return arr.size would give us 0 (which we want)\\n\\t\\t\\n        while(l<=r){\\n            int m= l + (r-l)/2;\\n            \\n            \\n            if(arr[m]>=x){\\n                anstillnow=m;\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n            \\n        }\\n        \\n        return anstillnow;\\n    }\\n    \\n    \\n    vector<int> countRectangles(vector<vector<int>>& rect, vector<vector<int>>& points) {\\n        \\n        unordered_map<int, vector<int>> htl;\\n        // maps heights to all the lengths of rectangles with that height\\n        \\n        for(int i=0; i<rect.size(); i++){       \\n            htl[rect[i][1]].push_back(rect[i][0]);\\n        }\\n        \\n\\t\\t// have to sort the containers to apply binary search\\n        for(int i=0; i<=100; i++){\\n            sort(htl[i].begin(), htl[i].end());\\n        }\\n        \\n\\t\\t\\n        vector<int> ans;\\n\\t\\t\\n        for(vector<int> p: points){\\n            int x=p[0], y=p[1];\\n            int ct=0;\\n            for(int j= y; j<=100; j++){\\n                if(htl.find(j)!=htl.end()){\\n                    ct+= htl[j].size()- binsear(htl[j], x);\\n\\t\\t\\t\\t\\t// binary search return the idx in array from which the values are >= x\\n\\t\\t\\t\\t\\t// the values at this and right of this are the lengths possible\\n\\t\\t\\t\\t\\t// so substract by size of array to get the number\\n                }\\n            }\\n            \\n            ans.push_back(ct);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\n\\t// helper fxn for binary search\\n    int binsear(ArrayList<Integer> arr, int x){\\n        int l=0, r=arr.size()-1;\\n        \\n        int anstillnow=arr.size(); \\n\\t\\t// if we find no m such that arr[m]>=x, means that our x is greater than all values of length, in such case we return idx n (i.e. size of arr)\\n\\t\\t// reason being, we substract our idx by size of arr to get number of rectangles greater than that in main fxn, so return arr.size would give us 0 (which we want)\\n\\t\\t\\n        while(l<=r){\\n            int m= l + (r-l)/2;\\n            \\n            \\n            if(arr.get(m)>=x){\\n                anstillnow=m;\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n            \\n        }\\n        \\n        return anstillnow;\\n    }\\n    \\n    public int[] countRectangles(int[][] rect, int[][] points) {\\n        HashMap<Integer, ArrayList<Integer>> htl= new HashMap<>();\\n        // maps heights to all the lengths of rectangles with that height\\n        \\n        for(int i=0; i<rect.length; i++){       \\n            if(htl.containsKey(rect[i][1])) htl.get(rect[i][1]).add(rect[i][0]);\\n            else \\n            {\\n                htl.put(rect[i][1],new ArrayList<>());\\n                htl.get(rect[i][1]).add(rect[i][0]);\\n            }\\n        }\\n        \\n\\t\\t// have to sort the container to apply binary search\\n        for(int a:htl.keySet()){\\n            Collections.sort(htl.get(a));        \\n        }\\n\\t\\t\\n        int[] ans = new int[points.length];\\n\\t\\t\\n        for(int i=0;i<points.length;i++){\\n            int x=points[i][0], y=points[i][1];\\n            int ct=0;\\n            for(int j= y; j<=100; j++){\\n                if(htl.containsKey(j)){\\n                    ct+= htl.get(j).size()- binsear(htl.get(j), x);\\n\\t\\t\\t\\t\\t// binary search return the idx in array from which the values are >= x\\n\\t\\t\\t\\t\\t// the values at this and right of this are the lengths possible\\n\\t\\t\\t\\t\\t// so substract by size of array to get the number\\n                }\\n            }\\n            \\n            ans[i]=ct;\\n            \\n        }\\n        \\n        return ans;        \\n    }\\n}\\n```\n```\\n# helper fxn for binary search\\ndef binsear(arr, x):\\n    l=0\\n    r=len(arr)-1\\n\\n    anstillnow=len(arr)\\n    # if we find no m such that arr[m]>=x, means that our x is greater than all values of length, in such case we return idx n (i.e. size of arr)\\n    # reason being, we substract our idx by size of arr to get number of rectangles greater than that in main fxn, so return arr.size would give us 0 (which we want)\\n\\n    while(l<=r):\\n        m= l + (r-l)//2\\n\\n\\n        if(arr[m]>=x):\\n            anstillnow=m\\n            r=m-1;\\n\\n        else:\\n            l=m+1\\n\\n    return anstillnow\\n\\n    \\nclass Solution:\\n\\n    def countRectangles(self, rect: List[List[int]], points: List[List[int]]) -> List[int]:\\n        \\n        # create a dictionary of int -> list of int\\n        htl=defaultdict(list)\\n        \\n        # maps heights to all the lengths of rectangles with that height\\n        for l, h in rect:       \\n            htl[h].append(l)\\n        \\n\\t\\t# have to sort the containers to apply binary search\\n        for k,v in htl.items():\\n            v.sort()\\n        \\n\\t\\t\\n        ans=[];\\n\\t\\t\\n        for p in points:\\n            x=p[0]\\n            y=p[1]\\n            \\n            ct=0\\n            \\n            for j in range(y, 101):\\n                if j in htl:\\n                    ct+= len(htl[j]) - binsear(htl[j], x)\\n                    \\n\\t\\t\\t\\t\\t# binary search return the idx in array from which the values are >= x\\n\\t\\t\\t\\t\\t# the values at this and right of this are the lengths possible\\n\\t\\t\\t\\t\\t# so substract by size of array to get the number\\n            \\n            ans.append(ct)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976853,
                "title": "c-bs",
                "content": "`O(100 * nlogn)`\\n```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<vector<int>> umap(101);\\n        for (auto &r: rectangles) {\\n            umap[r[1]].push_back(r[0]);\\n        }\\n        \\n        for (int i = 0; i < 101; i++) {\\n            sort(begin(umap[i]), end(umap[i]));\\n        }\\n        \\n        vector<int> res;\\n        for (auto &p: points) {\\n            int sum = 0;\\n            for (int i = p[1]; i < 101; i++) {\\n                auto lb = lower_bound(begin(umap[i]), end(umap[i]), p[0]);\\n                sum += end(umap[i]) - lb;\\n            }\\n            res.push_back(sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<vector<int>> umap(101);\\n        for (auto &r: rectangles) {\\n            umap[r[1]].push_back(r[0]);\\n        }\\n        \\n        for (int i = 0; i < 101; i++) {\\n            sort(begin(umap[i]), end(umap[i]));\\n        }\\n        \\n        vector<int> res;\\n        for (auto &p: points) {\\n            int sum = 0;\\n            for (int i = p[1]; i < 101; i++) {\\n                auto lb = lower_bound(begin(umap[i]), end(umap[i]), p[0]);\\n                sum += end(umap[i]) - lb;\\n            }\\n            res.push_back(sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984225,
                "title": "bit",
                "content": "Since `y` is constrained to `100`, we do not have to use BIT - but where is the fun in that?\\n\\nThe solution below would work efficiently for larger`y`. \\n\\nWe first sort rectangles and points by `x`, decreasing. Then, going from the rightmost point, we gradually add heights of wider (or same width) rectangles to BIT. \\n\\nThis way, we can efficiently get the count of all \"taler\" rectangles from BIT. Again, all rectangles in BIT are wider (or same width) than the current point.\\n\\n**C++**\\n```cpp\\nconstexpr int static n = 101;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val = 1)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nvector<int> countRectangles(vector<vector<int>>& rects, vector<vector<int>>& points) {\\n    vector<int> idx(points.size()), res(points.size());\\n    iota(begin(idx), end(idx), 0);\\n    sort(begin(idx), end(idx), [&](int a, int b){ return points[a][0] > points[b][0];});\\n    sort(begin(rects), end(rects), [](const auto &r1, const auto &r2){ return r1[0] > r2[0];});\\n    for (int i = 0, j = 0; i < idx.size(); ++i) {\\n        while (j < rects.size() && rects[j][0] >= points[idx[i]][0])\\n            add(rects[j++][1] + 1);\\n        res[idx[i]] = j - prefix_sum(points[idx[i]][1]);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nconstexpr int static n = 101;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val = 1)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nvector<int> countRectangles(vector<vector<int>>& rects, vector<vector<int>>& points) {\\n    vector<int> idx(points.size()), res(points.size());\\n    iota(begin(idx), end(idx), 0);\\n    sort(begin(idx), end(idx), [&](int a, int b){ return points[a][0] > points[b][0];});\\n    sort(begin(rects), end(rects), [](const auto &r1, const auto &r2){ return r1[0] > r2[0];});\\n    for (int i = 0, j = 0; i < idx.size(); ++i) {\\n        while (j < rects.size() && rects[j][0] >= points[idx[i]][0])\\n            add(rects[j++][1] + 1);\\n        res[idx[i]] = j - prefix_sum(points[idx[i]][1]);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976880,
                "title": "python-binary-search-on-the-width",
                "content": "Intuition: notice the hint that all rectangles are unique and width is greater than height, so sort the rectangles by width, it is possible to binary search on the width to find the number of rectangles that conver the point\\n\\nEdit:\\nNotice that the **upper bound** of width is greater than height, that yields the binary search on width and linear scan on height.\\n\\n```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        from bisect import bisect\\n\\n        rectangles = sorted(rectangles, key=lambda x:x[0])\\n\\n        rectangle_map = defaultdict(list)\\n\\n        for l, h in rectangles:\\n            rectangle_map[h].append(l)\\n\\n        def contains(x, y):\\n            count = 0\\n\\n            for height, widths in rectangle_map.items():\\n                if height >= y:\\n                    count += len(widths) - bisect(widths, x - 1)\\n\\n            return count\\n\\n        res = []\\n\\n        for point in points:\\n            x, y = point\\n            res.append(contains(x, y))\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        from bisect import bisect\\n\\n        rectangles = sorted(rectangles, key=lambda x:x[0])\\n\\n        rectangle_map = defaultdict(list)\\n\\n        for l, h in rectangles:\\n            rectangle_map[h].append(l)\\n\\n        def contains(x, y):\\n            count = 0\\n\\n            for height, widths in rectangle_map.items():\\n                if height >= y:\\n                    count += len(widths) - bisect(widths, x - 1)\\n\\n            return count\\n\\n        res = []\\n\\n        for point in points:\\n            x, y = point\\n            res.append(contains(x, y))\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976972,
                "title": "python3-easy-to-understand-count-by-h",
                "content": "since the range of h is 1 <= h <= 100, we could \\n1. store all \"l\" of rectangles to corresponding \"h\" and sort \\n2. count the number of rectangles whose \"h\" is larger than or equal to target point\\n3. since \"h\" is guranteed to be valid, rectangles with larger \"l\" than target point will be considered valid\\n```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        res = []\\n        n = len(rectangles)\\n        dic = collections.defaultdict(list)\\n        for l, h in rectangles:\\n            dic[h].append(l)\\n        for h in dic:\\n            dic[h].sort()\\n        # print(dic)\\n        for x, y in points:\\n            count = 0\\n            for h in range(y, 101):\\n                j = bisect_left(dic[h], x)\\n                # print(h, j)\\n                count += len(dic[h]) - j\\n            res.append(count)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        res = []\\n        n = len(rectangles)\\n        dic = collections.defaultdict(list)\\n        for l, h in rectangles:\\n            dic[h].append(l)\\n        for h in dic:\\n            dic[h].sort()\\n        # print(dic)\\n        for x, y in points:\\n            count = 0\\n            for h in range(y, 101):\\n                j = bisect_left(dic[h], x)\\n                # print(h, j)\\n                count += len(dic[h]) - j\\n            res.append(count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979130,
                "title": "easy-to-understand-c-solution",
                "content": "here given the range of y value is 1-100 and range of x is 1-10^9,so we stored the values of x coordinates for a particular y value in our map;\\nthen using the inbuilt lower bound functions we count the number of points that satisfy the given condition.....feel free  to comment your queries,thanks\\n```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& r, vector<vector<int>>& points) {\\n        map<int,vector<int>> mappa;\\n        sort(r.begin(),r.end());\\n        vector<int> ans;\\n        for(auto it:r){\\n            mappa[it[1]].push_back(it[0]);//pushing the x coordinate to the respective mapping of y coordinate\\n        }\\n        \\n\\n        for(auto i:points){\\n\\t\\t   //in order to contain the given point.....the y coordinate and x coordinate of rectangle must be\\n\\t\\t\\t//greater  than or equal to that of the point.\\n            auto it = mappa.lower_bound(i[1]);//finding the y coordinates of rectangle that are greater than or\\n\\t\\t\\t//equal to y coordinate of the given point.\\n            int k = 0;\\n            while(it!=mappa.end()){\\n                auto it1 = lower_bound((*it).second.begin(),(*it).second.end(),i[0]);\\n\\t\\t\\t\\t//in the vector finding the lower bound of given x coordinate of the point.\\n\\t\\t\\t\\t\\n                k+=(*it).second.end()-it1;\\n                it++;\\n            }\\n            ans.push_back(k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& r, vector<vector<int>>& points) {\\n        map<int,vector<int>> mappa;\\n        sort(r.begin(),r.end());\\n        vector<int> ans;\\n        for(auto it:r){\\n            mappa[it[1]].push_back(it[0]);//pushing the x coordinate to the respective mapping of y coordinate\\n        }\\n        \\n\\n        for(auto i:points){\\n\\t\\t   //in order to contain the given point.....the y coordinate and x coordinate of rectangle must be\\n\\t\\t\\t//greater  than or equal to that of the point.\\n            auto it = mappa.lower_bound(i[1]);//finding the y coordinates of rectangle that are greater than or\\n\\t\\t\\t//equal to y coordinate of the given point.\\n            int k = 0;\\n            while(it!=mappa.end()){\\n                auto it1 = lower_bound((*it).second.begin(),(*it).second.end(),i[0]);\\n\\t\\t\\t\\t//in the vector finding the lower bound of given x coordinate of the point.\\n\\t\\t\\t\\t\\n                k+=(*it).second.end()-it1;\\n                it++;\\n            }\\n            ans.push_back(k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976843,
                "title": "java-solutin-using-treemap-and-binarysearch",
                "content": "\\nPrepare a TreeMap with key as `y` and values as list of corresponding `x` for all the rectangle.\\nNow we can get the range of `y` co-ordinagtes in `log(n)` time using TreeMap function `subMap` and \\nfor each `y` in this submap, we can get the list of `x` coordinate and run binary search (after sorting it one time) on it to find the valid `x` co-ordinate of rectangles in `log(n)` time.\\n    \\nThe key observaion here is the range of `y`. It can only go from 1 to 100.\\nIf instead of `y`, you use `x` of rectangle as the key in the TreeMap, the code will TimeOut since `x` can vary on much wider range hence you will be running binary search too many times.\\n\\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int max = Integer.MIN_VALUE;\\n        \\n        TreeMap<Integer, List<Integer>> rects = new TreeMap<>();\\n        for(int[] rect : rectangles) {\\n            if (!rects.containsKey(rect[1])) {\\n                rects.put(rect[1], new ArrayList<Integer>());\\n            }\\n            \\n            rects.get(rect[1]).add(rect[0]);\\n            max = Math.max(max, rect[1]);\\n        }\\n        \\n        for(int k : rects.keySet()) {\\n            Collections.sort(rects.get(k));\\n        }\\n        \\n        int[] ans = new int[points.length];\\n        for(int i = 0; i < points.length; i++) {\\n            if (points[i][1] > max) {\\n                continue;\\n            }\\n\\n            int count = 0;\\n            \\n            for(int key : rects.subMap(points[i][1], max + 1).keySet()) {\\n                List<Integer> y = rects.get(key);\\n                \\n                count += binarySearch(y, points[i][0]);\\n            }\\n            \\n            ans[i] = count;\\n        }\\n\\n        return ans;\\n    }\\n    \\n    private int binarySearch(List<Integer> vals, int val) {\\n        int lo = 0;\\n        int hi = vals.size() - 1;\\n        int id = -1;\\n        \\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if (vals.get(mid) < val) {\\n                lo = mid + 1;\\n            } else {\\n                id = mid;\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        if (id < 0) {\\n            return 0;\\n        }\\n        \\n        return vals.size() - id;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int max = Integer.MIN_VALUE;\\n        \\n        TreeMap<Integer, List<Integer>> rects = new TreeMap<>();\\n        for(int[] rect : rectangles) {\\n            if (!rects.containsKey(rect[1])) {\\n                rects.put(rect[1], new ArrayList<Integer>());\\n            }\\n            \\n            rects.get(rect[1]).add(rect[0]);\\n            max = Math.max(max, rect[1]);\\n        }\\n        \\n        for(int k : rects.keySet()) {\\n            Collections.sort(rects.get(k));\\n        }\\n        \\n        int[] ans = new int[points.length];\\n        for(int i = 0; i < points.length; i++) {\\n            if (points[i][1] > max) {\\n                continue;\\n            }\\n\\n            int count = 0;\\n            \\n            for(int key : rects.subMap(points[i][1], max + 1).keySet()) {\\n                List<Integer> y = rects.get(key);\\n                \\n                count += binarySearch(y, points[i][0]);\\n            }\\n            \\n            ans[i] = count;\\n        }\\n\\n        return ans;\\n    }\\n    \\n    private int binarySearch(List<Integer> vals, int val) {\\n        int lo = 0;\\n        int hi = vals.size() - 1;\\n        int id = -1;\\n        \\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if (vals.get(mid) < val) {\\n                lo = mid + 1;\\n            } else {\\n                id = mid;\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        if (id < 0) {\\n            return 0;\\n        }\\n        \\n        return vals.size() - id;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976824,
                "title": "c-solution-binary-search-for-100-buckets",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<vector<int> > harr(101);\\n        for(auto &r : rectangles) {\\n            harr[r[1]].push_back(r[0]);\\n        }\\n        for(auto &v : harr) sort(v.begin(), v.end());\\n        vector<int> ans(points.size());\\n        int i = 0;\\n        for(auto &p : points) {\\n            int y = p[1], x = p[0];\\n            int sum = 0;\\n            for(int k = y; k <= 100; k++) {\\n                sum += harr[k].end() - lower_bound(harr[k].begin(), harr[k].end(), x);\\n            }\\n            ans[i++] = sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<vector<int> > harr(101);\\n        for(auto &r : rectangles) {\\n            harr[r[1]].push_back(r[0]);\\n        }\\n        for(auto &v : harr) sort(v.begin(), v.end());\\n        vector<int> ans(points.size());\\n        int i = 0;\\n        for(auto &p : points) {\\n            int y = p[1], x = p[0];\\n            int sum = 0;\\n            for(int k = y; k <= 100; k++) {\\n                sum += harr[k].end() - lower_bound(harr[k].begin(), harr[k].end(), x);\\n            }\\n            ans[i++] = sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979055,
                "title": "c-solution-with-explanation",
                "content": "**Sorry this is a long post. I try to avoid it but some explanation need details. Some people can undertand quickly and some people like me needs more explanation**\\n\\nIn this problem, we have to count the number of rectangles that have the points inside it. Just a basic math that a point will be inside the rectangle if the bottom left X is smaller than equals to point X and bottom left Y is smaller than equals to point Y. Similarly, top right X should be greater than equals to point X and top right Y should be greater than equals to top right Y.\\n\\n```\\nBottom Left X <= Point X <= Top Right X\\nBottom Left Y <= Point Y <= Top Right Y\\n\\nFor eg: if the bottom left X is 2 and bottom left Y is 3 & top right X is 6 and top right Y is 10\\nThen point X can range from [2, 6] and point Y can range from [3, 10] both inclusive\\n```\\n\\nOne straightforward solution is to apply brute force for each point and check if that is inside the rectangle or not.\\n\\nAfter brute force, we can think of sorting the points but how should we sort them?\\n\\n1 - Can we sort the rectangles based on x coordinates? Yes, we can sort them by x coordinates and now we only have to look for the rectangles whose x coordinate is greater than point x.\\n\\n```\\nIf we have rectangles with coordinates or [length, height] as follows\\n[(1,1), (2,2), (3,3), (5,5), (7, 7]) and \\nif point coordinates are (4, 4), all we have to look for is x coordinates of rectangles whose \\nvalues is 4 or greater than it.\\n```\\n\\nWhy? because point x needs to be smaller than rectangle coordinate x. \\nNow we can easily perform a binary search and get the number of coordinates that are greater than point x\\n\\nWhat\\'s the problem here? It is possible that y coordinate of rectangle will be smaller than point y coordinate.\\n\\n```\\nLet\\'s take a look at the above example one more time with the same rectangle coordinates\\n[(1,1), (2,2), (3,3), (5,5), (7, 7])\\nif point coordinates are (4, 4), we did the binary search and we got 2 count because (5,5) and (7,7) \\nhas x coordinates greater than point x cordinate. \\n\\nNow what if the points are follows\\n[(1,1), (2,2), (3,3), **(5,2)**, (7, 7])\\n\\nif point coordinates are (4, 4), we again do the binary search and get 2 count. \\nBut does (5, 2) should be counted? No, because its range of y ends at 2. In order to count it,\\nits y values should be atleast 4 or greater than 4\\n\\nSo we cannot sort by x coordinates\\n```\\n\\n2 - Can we sort by y coordinates? Yes we can but we will face the same problem as we faced by sorting x coordinates\\n\\n**Do we have any solution so far? Yes, we do and that is brute force which will give us Time Limit Exceeded. We do have some kind of logic in our mind regarding binary search which won\\'t work but it is good to keep in mind**\\n\\nIf we look at the constraints, x can go upto pow(10, 9) and y can only go upto 100. Can we take advanage of it?\\n\\nIf we do a mapping of all the x coordinates and list of y coordinates, then we can do binary search. \\n```\\nIf we have rectangle coordinates like\\n[1, 1], [1, 2], [1, 3], [1, 10], [2, 1], [2, 5], [4, 4], [4, 15], [5, 17] and we have to look for point [3, 10]\\nIf we do a mapping like  x -> y, it will look like this\\n\\n1->1,2,3,10\\n2->15\\n4->4,15\\n5->17\\n\\nNow we can start looking into the map where the value is greater than point x coordinate\\n(which is 3 in this case). In the above example, we will start with 4 as it is greater than 3. \\nNow we can easily do binary search on the y coordinates and get the first index whose value is greater. \\nThen we will go to 5 and again to the binary search. \\n\\nWhy we ignored looking for 1 and 2? Because those x coordinate are already smaller \\nthan the point x coordinate(3 in this case)\\n```\\n\\nNow does it work? Yes it will but what can be the problem here? As x varies from 1 to pow(10, 9), it can cause TLE. How?\\nAs we are traversing the keys of the map(we are storing x coordinate as keys), we have to look at the x and do a binary search on y coordinate. \\n```\\nWhat if all the rectangle coordinates are like this\\n[1, 1], [1, 2], [1, 3], [1, 4],[500, 1],[1000, 2],[100000, 10], [1000000, 2], [1000000000, 1]\\n\\nand all the points are like this\\n[1, 1], [1, 2], [1, 3], [1, 4]\\n\\nThen we have to start traversing the map from 1 upto pow(10, 9)\\n```\\n\\nCan we take advantage of y coordinate as its limit constraint is smaller than x(only 100)? Yes, we can\\nHow? Can we do a mapping of y->x\\n\\nYes, if we do that, all we have to do is traverse the numbers upto 100(which was upto pow(10, 9) if we would have done mapping x->y) and do a binary search on x coordinates\\n\\n**Steps**\\n*  Map all the rectangle coordinates from y to x\\n*  Traverse all the points\\n*  Look for the y coordinates whose value is greater than or equals to point y coordinate\\n*  Do the binary search on the x coordinate for each y coordinate\\n*  Return the result\\n\\n```\\nclass Solution {\\npublic:\\n    int binarySearch(int x, vector<int>& arr){\\n        int low = 0;\\n        int high = arr.size() - 1;\\n        \\n        while(low <= high){\\n            \\n            int mid = low + (high - low)/2;\\n            if(arr[mid] >= x){\\n                high = mid - 1;\\n            }else{\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return low;\\n    }\\n    \\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        \\n        unordered_map<int, vector<int>> heightMapping;\\n        sort(rectangles.begin(), rectangles.end());\\n        \\n\\t\\t//Step 1 starts\\n        for(int i = 0; i < rectangles.size(); i++){\\n            int x = rectangles[i][0];\\n            int y = rectangles[i][1];\\n            \\n            if(heightMapping.find(y) == heightMapping.end()){\\n                heightMapping[y] = {};\\n            }\\n            \\n            heightMapping[y].push_back(x);\\n        }\\n        //Step 1 ends\\n        vector<int> result;\\n\\t\\t\\n\\t\\t//Step 2 starts\\n        for(int i = 0; i < points.size(); i++){\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            int count = 0;\\n                \\n\\t\\t\\t//Step 3 starts\\n            for(int h = y; h <= 100; h++){\\n                if(heightMapping.find(h) != heightMapping.end()){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t    // Step 4 starts\\n                    int index = binarySearch(x, heightMapping[h]);\\n                    count+=(heightMapping[h].size() - index);\\n\\t\\t\\t\\t\\t// Step 4 ends\\n                }\\n            }\\n            //Step 3 ends\\n\\t\\t\\t\\n            result.push_back(count);\\n        }\\n        //Step 2 ends\\n\\t\\t\\n\\t\\t// Step 5\\n        return result;\\n    }\\n};\\n```\\n\\nTime Complexity -\\n\\n* Let\\'s say rectangle size is n and in step 1 we are traversing, so its O(n)\\n* In step2, we are traversing points and let\\'s say size of points is m, so its O(m)\\n* In step3, we are traversing upto 100 which is constant\\n* In step4, we are doing a binary search on x coordinates, whose size can be n, so it\\'s O(log(n))\\n\\nOverall it\\'s O(n) + (O(m) * 100 * O(log((n))\\n\\nPS - I know that there are lot of things that can be hard to understand in my explanation. I am trying to write a post that even a newbie can understand. Feel free to suggest me if I can make the post simple or reach out to me on interviewpreparation42@gmail.com if you have any question. I will be happy to answer it\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nBottom Left X <= Point X <= Top Right X\\nBottom Left Y <= Point Y <= Top Right Y\\n\\nFor eg: if the bottom left X is 2 and bottom left Y is 3 & top right X is 6 and top right Y is 10\\nThen point X can range from [2, 6] and point Y can range from [3, 10] both inclusive\\n```\n```\\nIf we have rectangles with coordinates or [length, height] as follows\\n[(1,1), (2,2), (3,3), (5,5), (7, 7]) and \\nif point coordinates are (4, 4), all we have to look for is x coordinates of rectangles whose \\nvalues is 4 or greater than it.\\n```\n```\\nLet\\'s take a look at the above example one more time with the same rectangle coordinates\\n[(1,1), (2,2), (3,3), (5,5), (7, 7])\\nif point coordinates are (4, 4), we did the binary search and we got 2 count because (5,5) and (7,7) \\nhas x coordinates greater than point x cordinate. \\n\\nNow what if the points are follows\\n[(1,1), (2,2), (3,3), **(5,2)**, (7, 7])\\n\\nif point coordinates are (4, 4), we again do the binary search and get 2 count. \\nBut does (5, 2) should be counted? No, because its range of y ends at 2. In order to count it,\\nits y values should be atleast 4 or greater than 4\\n\\nSo we cannot sort by x coordinates\\n```\n```\\nIf we have rectangle coordinates like\\n[1, 1], [1, 2], [1, 3], [1, 10], [2, 1], [2, 5], [4, 4], [4, 15], [5, 17] and we have to look for point [3, 10]\\nIf we do a mapping like  x -> y, it will look like this\\n\\n1->1,2,3,10\\n2->15\\n4->4,15\\n5->17\\n\\nNow we can start looking into the map where the value is greater than point x coordinate\\n(which is 3 in this case). In the above example, we will start with 4 as it is greater than 3. \\nNow we can easily do binary search on the y coordinates and get the first index whose value is greater. \\nThen we will go to 5 and again to the binary search. \\n\\nWhy we ignored looking for 1 and 2? Because those x coordinate are already smaller \\nthan the point x coordinate(3 in this case)\\n```\n```\\nWhat if all the rectangle coordinates are like this\\n[1, 1], [1, 2], [1, 3], [1, 4],[500, 1],[1000, 2],[100000, 10], [1000000, 2], [1000000000, 1]\\n\\nand all the points are like this\\n[1, 1], [1, 2], [1, 3], [1, 4]\\n\\nThen we have to start traversing the map from 1 upto pow(10, 9)\\n```\n```\\nclass Solution {\\npublic:\\n    int binarySearch(int x, vector<int>& arr){\\n        int low = 0;\\n        int high = arr.size() - 1;\\n        \\n        while(low <= high){\\n            \\n            int mid = low + (high - low)/2;\\n            if(arr[mid] >= x){\\n                high = mid - 1;\\n            }else{\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return low;\\n    }\\n    \\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        \\n        unordered_map<int, vector<int>> heightMapping;\\n        sort(rectangles.begin(), rectangles.end());\\n        \\n\\t\\t//Step 1 starts\\n        for(int i = 0; i < rectangles.size(); i++){\\n            int x = rectangles[i][0];\\n            int y = rectangles[i][1];\\n            \\n            if(heightMapping.find(y) == heightMapping.end()){\\n                heightMapping[y] = {};\\n            }\\n            \\n            heightMapping[y].push_back(x);\\n        }\\n        //Step 1 ends\\n        vector<int> result;\\n\\t\\t\\n\\t\\t//Step 2 starts\\n        for(int i = 0; i < points.size(); i++){\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            int count = 0;\\n                \\n\\t\\t\\t//Step 3 starts\\n            for(int h = y; h <= 100; h++){\\n                if(heightMapping.find(h) != heightMapping.end()){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t    // Step 4 starts\\n                    int index = binarySearch(x, heightMapping[h]);\\n                    count+=(heightMapping[h].size() - index);\\n\\t\\t\\t\\t\\t// Step 4 ends\\n                }\\n            }\\n            //Step 3 ends\\n\\t\\t\\t\\n            result.push_back(count);\\n        }\\n        //Step 2 ends\\n\\t\\t\\n\\t\\t// Step 5\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977017,
                "title": "binary-search-on-the-width",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        \\n        int n(size(rectangles)), maxi(0);\\n        for (auto& rectangle : rectangles)   maxi = max(maxi, rectangle[1]);\\n        \\n        vector<int> w[maxi+1];\\n        for (auto& rectangle : rectangles)  w[rectangle[1]].push_back(rectangle[0]);\\n    \\n        for(int i=0; i<=maxi; i++)  sort(begin(w[i]), end(w[i]));\\n        \\n        vector<int> ans;\\n        for(auto& point : points) {\\n            int res = 0;\\n            for (int y=point[1]; y<=maxi; y++) {\\n                auto cnt = end(w[y]) - lower_bound(begin(w[y]), end(w[y]), point[0]);\\n                res += cnt;\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        \\n        int n(size(rectangles)), maxi(0);\\n        for (auto& rectangle : rectangles)   maxi = max(maxi, rectangle[1]);\\n        \\n        vector<int> w[maxi+1];\\n        for (auto& rectangle : rectangles)  w[rectangle[1]].push_back(rectangle[0]);\\n    \\n        for(int i=0; i<=maxi; i++)  sort(begin(w[i]), end(w[i]));\\n        \\n        vector<int> ans;\\n        for(auto& point : points) {\\n            int res = 0;\\n            for (int y=point[1]; y<=maxi; y++) {\\n                auto cnt = end(w[y]) - lower_bound(begin(w[y]), end(w[y]), point[0]);\\n                res += cnt;\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976881,
                "title": "treemap-and-binarysearch",
                "content": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        TreeMap<Integer, ArrayList<Integer>> tmap = new TreeMap<>();\\n        Arrays.sort(rectangles, (a,b)-> (a[0]==b[0])?(a[1]-b[1]):(a[0]-b[0]));\\n        for(int [] rect: rectangles){\\n            tmap.putIfAbsent(rect[1], new ArrayList<>());\\n            tmap.get(rect[1]).add(rect[0]);\\n        }\\n        int[] result = new int[points.length];\\n        int index = 0;\\n        for(int [] point: points){\\n            int count = 0; \\n            for(ArrayList<Integer> al: tmap.subMap(point[1],true, Integer.MAX_VALUE, true).values()){\\n                \\n                int idx = Collections.binarySearch(al,point[0]);\\n         \\n                if(idx>=0)//found element\\n                {\\n                 count+= (al.size() - (idx));   \\n                }else{\\n                    count = (count + al.size()+(idx+1));\\n                }\\n            }\\n            result[index++] = count;\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        TreeMap<Integer, ArrayList<Integer>> tmap = new TreeMap<>();\\n        Arrays.sort(rectangles, (a,b)-> (a[0]==b[0])?(a[1]-b[1]):(a[0]-b[0]));\\n        for(int [] rect: rectangles){\\n            tmap.putIfAbsent(rect[1], new ArrayList<>());\\n            tmap.get(rect[1]).add(rect[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1978078,
                "title": "java-solution-binary-search-with-explanation",
                "content": "Since we are given the constraint that `1 <= h, y <= 100`, meaning that we can group the rectangles based on height and sort each group by length.\\n\\nThen for each point, we do binary search for x coordiante on all the groups that has `height >= y`.\\n\\nThe binary search will look for the first possible rectangle length that can contain the point\\'s x coordinate, and all the lengths after it in the list can absolutely contain the point.\\n\\nTime Complexity: O(NlogN)\\n\\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int[] res = new int[points.length];\\n        List<List<Integer>> group = new ArrayList<>(101);\\n        for(int i = 0; i < 101; i++){\\n            group.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] rec : rectangles){\\n            int l = rec[0];\\n            int h = rec[1];\\n            group.get(h).add(l);\\n        }\\n        \\n        for(int i = 0; i < 101; i++){\\n            Collections.sort(group.get(i));   \\n        }\\n        \\n        for(int i = 0; i < points.length; i++){\\n            int count = 0;\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            for(int j = y; j < 101; j++){\\n                List<Integer> cur = group.get(j);\\n                int index = binarySearch(cur, x);\\n                count += cur.size() - index;\\n            }\\n            res[i] = count;\\n        }\\n\\n        return res;\\n    }\\n    \\n    private int binarySearch(List<Integer> list, int x){\\n        int left = 0;\\n        int right = list.size();\\n        while(left < right){\\n            int mid = left + (right - left) / 2;\\n            if(list.get(mid) >= x){\\n                right = mid;\\n            } else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int[] res = new int[points.length];\\n        List<List<Integer>> group = new ArrayList<>(101);\\n        for(int i = 0; i < 101; i++){\\n            group.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] rec : rectangles){\\n            int l = rec[0];\\n            int h = rec[1];\\n            group.get(h).add(l);\\n        }\\n        \\n        for(int i = 0; i < 101; i++){\\n            Collections.sort(group.get(i));   \\n        }\\n        \\n        for(int i = 0; i < points.length; i++){\\n            int count = 0;\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            for(int j = y; j < 101; j++){\\n                List<Integer> cur = group.get(j);\\n                int index = binarySearch(cur, x);\\n                count += cur.size() - index;\\n            }\\n            res[i] = count;\\n        }\\n\\n        return res;\\n    }\\n    \\n    private int binarySearch(List<Integer> list, int x){\\n        int left = 0;\\n        int right = list.size();\\n        while(left < right){\\n            int mid = left + (right - left) / 2;\\n            if(list.get(mid) >= x){\\n                right = mid;\\n            } else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977006,
                "title": "python-o-nlogn-using-sortedlist",
                "content": "Sort rectanges descendingly by x.\\nSort points descnedingly by x.\\n\\nThen, we\\'ll loop through the points and rectangles, from the most outward to the most inward. We know that any time we \\'discover\\' a new rectangle, we add it to our sorted set (LogN). \\n\\nFor each point, binary search on the Y axis of the rectangles we\\'ve \\'discovered\\' to find out how many are in the Y range. \\n\\nSmarter and more flexible than the dummy bucket solution, which people got away with because leetcode went easy on them and bounded the Y by 100. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countRectangles(self, rects: List[List[int]], points: List[List[int]]) -> List[int]:\\n        points = [(p[0], p[1], i) for i, p in enumerate(points)]\\n        \\n        rects.sort(reverse=True) # sort rectangles DESCENDING by x\\n        points.sort(reverse=True) # sort points DESCENDING by x\\n\\n        rectPointer = 0\\n        sortedByY = SortedList(key=lambda p: -p[1])\\n        ans = [0] * len(points)\\n        \\n        for px, py, i in points:\\n            while rectPointer < len(rects) and px <= rects[rectPointer][0]:\\n                r = rects[rectPointer]\\n                sortedByY.add((r[0], r[1]))\\n                rectPointer += 1\\n            \\n            numGreaterThanY = sortedByY.bisect_right((px, py))\\n            ans[i] = numGreaterThanY\\n\\n        return ans\\n        \\n   ```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countRectangles(self, rects: List[List[int]], points: List[List[int]]) -> List[int]:\\n        points = [(p[0], p[1], i) for i, p in enumerate(points)]\\n        \\n        rects.sort(reverse=True) # sort rectangles DESCENDING by x\\n        points.sort(reverse=True) # sort points DESCENDING by x\\n\\n        rectPointer = 0\\n        sortedByY = SortedList(key=lambda p: -p[1])\\n        ans = [0] * len(points)\\n        \\n        for px, py, i in points:\\n            while rectPointer < len(rects) and px <= rects[rectPointer][0]:\\n                r = rects[rectPointer]\\n                sortedByY.add((r[0], r[1]))\\n                rectPointer += 1\\n            \\n            numGreaterThanY = sortedByY.bisect_right((px, py))\\n            ans[i] = numGreaterThanY\\n\\n        return ans\\n        \\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 1978346,
                "title": "python-binary-search-simplest-solution-with-detailed-explanation",
                "content": "## Logic:\\n\\t1. The idea is to group all the rectangles on the basis of their height in the increasing order of their length.\\n\\t2. Then for each point, find the minimum height first that would accommodate the y-coordinate of the point, then find the minimum length of rectangle that would accommodate the x-coordinate of point. \\n\\t3. If a potential rectangle is found which can accommodate the point, then the current rectangle and all the longer rectangle in the current height group would accommodate the point.\\n\\t4. For each point, repeat Step3 for all the higher rectangles than the minimum height rectangle.\\n\\n```\\nclass Solution:\\n    def binarySearch(self, arr, target):\\n        left, right = 0, len(arr)\\n        ans = None\\n        while left < right:\\n            mid = left + ((right-left)//2)\\n            if arr[mid] >= target:\\n                # Potential answer found! Now try to minimize it iff possible.\\n                ans = mid\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return ans\\n        \\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        # Sort rectangles based on the lengths\\n        rectangles.sort()  \\n        # Group rectangles by their height in increasing order of their length\\n        lengths = {}\\n        for x,y in rectangles:\\n            if y in lengths:\\n                lengths[y].append(x)\\n            else:\\n                lengths[y] = [x]\\n        \\n        heights = sorted(list(lengths.keys()))\\n        \\n        count = [0] * len(points)\\n        \\n        for idx, point in enumerate(points):\\n            x, y = point\\n            # Get the  min height rectangle that would accommodate the y coordinate of current point.\\n            minHeightRectIdx = self.binarySearch(heights, y)\\n            if minHeightRectIdx is not None:\\n                for h in heights[minHeightRectIdx:]:\\n                    # Get the Min length rectangle that would accommodate the x coordinate of current point for all h height rectangles.\\n                    minLenRectIdx = self.binarySearch(lengths[h], x)\\n                    if minLenRectIdx is not None:\\n                        count[idx] += len(lengths[h]) - minLenRectIdx\\n        \\n        return count\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def binarySearch(self, arr, target):\\n        left, right = 0, len(arr)\\n        ans = None\\n        while left < right:\\n            mid = left + ((right-left)//2)\\n            if arr[mid] >= target:\\n                # Potential answer found! Now try to minimize it iff possible.\\n                ans = mid\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return ans\\n        \\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        # Sort rectangles based on the lengths\\n        rectangles.sort()  \\n        # Group rectangles by their height in increasing order of their length\\n        lengths = {}\\n        for x,y in rectangles:\\n            if y in lengths:\\n                lengths[y].append(x)\\n            else:\\n                lengths[y] = [x]\\n        \\n        heights = sorted(list(lengths.keys()))\\n        \\n        count = [0] * len(points)\\n        \\n        for idx, point in enumerate(points):\\n            x, y = point\\n            # Get the  min height rectangle that would accommodate the y coordinate of current point.\\n            minHeightRectIdx = self.binarySearch(heights, y)\\n            if minHeightRectIdx is not None:\\n                for h in heights[minHeightRectIdx:]:\\n                    # Get the Min length rectangle that would accommodate the x coordinate of current point for all h height rectangles.\\n                    minLenRectIdx = self.binarySearch(lengths[h], x)\\n                    if minLenRectIdx is not None:\\n                        count[idx] += len(lengths[h]) - minLenRectIdx\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978008,
                "title": "python-binary-search-detailed-explanation",
                "content": "### Idea\\n\\n- `Point (px, py)` should be counted when `px <= length and py <= height`\\n- We can start with a simpler question -> If the point is not 2D, and it\\'s just a 1D integer, how can we solve this?\\n\\n### Simpler question (1D)\\n- Question: \\n\\t- Given a list of point `xi` and a list of rectangle\\'s length `li`. For each point, how many rectangles contain it?\\n- Brute Force: \\n\\t- We can travese each point and compare with each rectangle.\\n```Python\\nres = []\\nfor xi in points:\\n\\tcount = 0 \\n\\tfor li in rectangles: \\n\\t\\tif li >= xi:\\n\\t\\t\\tcount +=1\\n\\tres.append(count)\\n\\n# Time Complexity: O(P * R)  #assume P points and R rectangles \\n```\\n- Better approach: \\n\\t- We know the Brute Force is not efficient enough because it check all rectangles for each points again and again. \\n\\t- Instead, we can do some preprocessing in advance to make the rectangle\\'s states easier to be reused before starting traversing points. \\n\\t- The common *preprocessing* are like building map, creating prefix sum, sorting, etc. Here, a simple sorting helps because then we can use a binary search to find the first index which\\'s rectangle is larger than the point.\\n\\n```Python\\nrectangles.sort()   \\nres = []\\nfor xi in points:\\n\\tidx = bisect.bisect_left(rectangles, xi)  #index of first rectangle which is >= xi \\n\\tres.append(len(rectangles) - idx)\\n\\t\\n# Time Complexity: O(RlogR + PlogR)  #Sorting: RlogR  /  Binary search in rectangle for P times: PlogR \\n```\\n\\n### Back to the original question (2D)\\n- Similar to the 1D question, if either the height or weight is static, we can use the same approach `sorting + binary search` to solve. \\n- After checking the constraint, we noticed one important fact - the height is limited !\\n```\\n1 <= li, xj <= 10^9\\n1 <= hi, yj <= 100\\n```\\n- Then the story becomes easy. It\\'s almost the same as the 1D question. We just need to find the possible heights first, then do the binary search for each possible heights, and sum them up. \\n\\n```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        maxH = 101 \\n        hToL = [[] for _ in range(maxH)]\\n        \\n\\t\\t# Create the 100 list (0 is not used) \\n        for l, h in rectangles:\\n            hToL[h].append(l)\\n\\t\\t\\t\\n        # Sort the 100 list\\n        for h in range(1, maxH):\\n            hToL[h].sort()\\n        \\n\\t\\tres = []\\n        for px, py in points:\\n            count = 0\\n            # Only search the height (y) which equals to or greater than given py \\n            for h in range(py, maxH):\\n                if len(hToL[h]) == 0:\\n                    continue\\n                # Find the first index of length (x) which equals to or greater than given px in the sorted array\\n                idx = bisect.bisect_left(hToL[h], px) \\n                count += len(hToL[h]) - idx\\n            res.append(count)\\n        return res\\n\\n# Time Complexity: O(100*RlogR + P*100*logR) = O(RlogR + PlogR)  //if we consider 100 is a constant\\n# Space Complexity: O(R)\\n```\\n\\nPracticing leetcode problem is tough and lonely (at least for me).\\nI hope this solution helps you a bit :) \\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```Python\\nres = []\\nfor xi in points:\\n\\tcount = 0 \\n\\tfor li in rectangles: \\n\\t\\tif li >= xi:\\n\\t\\t\\tcount +=1\\n\\tres.append(count)\\n\\n# Time Complexity: O(P * R)  #assume P points and R rectangles \\n```\n```Python\\nrectangles.sort()   \\nres = []\\nfor xi in points:\\n\\tidx = bisect.bisect_left(rectangles, xi)  #index of first rectangle which is >= xi \\n\\tres.append(len(rectangles) - idx)\\n\\t\\n# Time Complexity: O(RlogR + PlogR)  #Sorting: RlogR  /  Binary search in rectangle for P times: PlogR \\n```\n```\\n1 <= li, xj <= 10^9\\n1 <= hi, yj <= 100\\n```\n```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        maxH = 101 \\n        hToL = [[] for _ in range(maxH)]\\n        \\n\\t\\t# Create the 100 list (0 is not used) \\n        for l, h in rectangles:\\n            hToL[h].append(l)\\n\\t\\t\\t\\n        # Sort the 100 list\\n        for h in range(1, maxH):\\n            hToL[h].sort()\\n        \\n\\t\\tres = []\\n        for px, py in points:\\n            count = 0\\n            # Only search the height (y) which equals to or greater than given py \\n            for h in range(py, maxH):\\n                if len(hToL[h]) == 0:\\n                    continue\\n                # Find the first index of length (x) which equals to or greater than given px in the sorted array\\n                idx = bisect.bisect_left(hToL[h], px) \\n                count += len(hToL[h]) - idx\\n            res.append(count)\\n        return res\\n\\n# Time Complexity: O(100*RlogR + P*100*logR) = O(RlogR + PlogR)  //if we consider 100 is a constant\\n# Space Complexity: O(R)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976822,
                "title": "java-binary-search-x-grouped-by-y",
                "content": "Pay attention to condition: `1 <= y <= 100`, so we should group by `y` and then binary search `x`.\\n\\nWe can save lots of time, if we group by `y` instead of `x`.\\n\\nTime: O(NlogN)\\nSpace: O(N)\\n\\n```\\nclass Solution {\\n  public int[] countRectangles(int[][] rectangles, int[][] points) {\\n    // group by y, as 1 <= y <= 100\\n    int limit = 101;\\n    List<List<Integer>> group = new ArrayList<>(limit);\\n    for (int i = 0; i < limit; i++) {\\n      group.add(new ArrayList<>());\\n    }\\n\\n    for (int[] rectangle : rectangles) {\\n      group.get(rectangle[1]).add(rectangle[0]);\\n    }\\n\\n    // sort each group\\n    for (int i = 0; i < limit; i++) {\\n      group.get(i).sort(Comparator.naturalOrder());\\n    }\\n\\n    int m = points.length;\\n    int[] result = new int[m];\\n\\n    for (int i = 0; i < m; i++) {\\n      int count = 0;\\n      for (int j = points[i][1]; j < limit; j++) {\\n        List<Integer> part = group.get(j);\\n        int index = Collections.binarySearch(part, points[i][0]);\\n        if (index < 0) {\\n          index = -index - 1;\\n        }\\n\\n        count += part.size() - index;\\n      }\\n      result[i] = count;\\n    }\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  public int[] countRectangles(int[][] rectangles, int[][] points) {\\n    // group by y, as 1 <= y <= 100\\n    int limit = 101;\\n    List<List<Integer>> group = new ArrayList<>(limit);\\n    for (int i = 0; i < limit; i++) {\\n      group.add(new ArrayList<>());\\n    }\\n\\n    for (int[] rectangle : rectangles) {\\n      group.get(rectangle[1]).add(rectangle[0]);\\n    }\\n\\n    // sort each group\\n    for (int i = 0; i < limit; i++) {\\n      group.get(i).sort(Comparator.naturalOrder());\\n    }\\n\\n    int m = points.length;\\n    int[] result = new int[m];\\n\\n    for (int i = 0; i < m; i++) {\\n      int count = 0;\\n      for (int j = points[i][1]; j < limit; j++) {\\n        List<Integer> part = group.get(j);\\n        int index = Collections.binarySearch(part, points[i][0]);\\n        if (index < 0) {\\n          index = -index - 1;\\n        }\\n\\n        count += part.size() - index;\\n      }\\n      result[i] = count;\\n    }\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979001,
                "title": "java-understanding-solution-from-uwi-weekly-champion",
                "content": "### Most Important\\nThis is the solution from [@uwil](https://leetcode.com/uwi/).  \\nI cannot figure out the solution in the contest by the way :(\\n\\n### General Ideas\\n+ Sort points and rectangles together using the rule **which sorts `x` in descending order**. **If `x` is the same, rectangles go first, then points.** ( Implementation would be explained next section)\\n+ **Sweep line on y direction**. Iterate the sorted array. \\n\\t+ If we meet a rectangle, we add the `y` in range of [0, height of rectangel] by 1, which is stored in `int[] ct`\\n\\t+ If we meet a point, check out the `int[] ct` we maintained before. The final result is stored in `int[] ret`\\n+ Return `int[] ret`\\n\\n### Details\\n+ Combine the rectangles and points together\\n\\t+ Since we need to know the index of points after sorted, we can make an element `int[] element  = new int[3]{x, y, id}` for points. But for rectangles, we just do `int[] element = new int[]{x, y}`. **So we can get the type from length of `element`.** The code is as follows:\\n\\t```\\n\\t\\tint n = rectangles.length;\\n        int m = points.length;\\n        int[][] elements = new int[n + m][];\\n        \\n        // init.\\n        for(int i = 0; i < n; i++){\\n            elements[i] = rectangles[i];\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            elements[n + i] = new int[]{points[i][0], points[i][1], i};\\n        }\\n\\t```\\n\\n+ Descending order in `x` makes life easier 50% in which if we have the sorted array `int[][] elements` we will know : \\n\\t<img src=\"https://render.githubusercontent.com/render/math?math=elements[i][0] >= elements[j][0]\"> when <img src=\"https://render.githubusercontent.com/render/math?math=i < j\">. \\n\\tSo we don\\'t need to worry about  `x` dimension, just need to focus on `y`.\\n\\t\\n+ Why rectangle first, the point when same x? It is due to **points on the edges of rectangles also belong to being in the rectangles**.\\n\\t```\\n\\t\\t// sort\\n        Arrays.sort(elements, (a, b) -> (a[0] != b[0] ? b[0] - a[0] : a.length - b.length));\\n\\t```\\n+ Sweep Line:\\n\\t + We only care about the y direction. \\n\\t + When we meet a rectangle, for its range, i.e., [0, `y` of rectangle], we just add the `cnt` of values in the range.  We use `int[] cnt` to keep track of `cnt` at each position. For example, we have ranges [0, 5], [0, 8], [0, 13], after iteration, the following picture shows the result of `int[] cnt`. The darker areas have larger values.\\n![image](https://assets.leetcode.com/users/images/ce862b8e-1054-422d-bd12-4bd8c9a1df23_1650816975.4492297.png)\\n\\nThis  way is useful for **other general cases(Other problems which ranges are not necessarily from 0).**\\n![image](https://assets.leetcode.com/users/images/8c624d55-3ccd-4137-9dfb-28fe201a818e_1650816872.986852.png)\\n\\nWhen we meet a point during the iteration of the sorted `int[][] elements`, justs need to check out we already have. More specifically, we can directly know the number of rectangles cover this point.\\n\\n```\\n// sweep line : count values on y direction [1, 100]\\n        int[] ct = new int[101];\\n        int[] ret = new int[m];\\n        \\n        for(int[] element : elements){\\n            // check current is rectangle or point\\n            // case 1: if rectangle, range count 0 to yi ++\\n            if(element.length == 2){\\n                for(int y = 0; y <= element[1]; y++){\\n                    ct[y]++;\\n                }\\n            // case 2: if point, checkout by current count \\n            }else{\\n                ret[element[2]] = ct[element[1]];\\n            }\\n        }\\n```\\n\\n\\n\\n\\n### Code\\n```\\n// Solution  from @uwi\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        // idea: sort rectangles and points in descending order by x value and type\\n        //       sweep line on y\\n        \\n        int n = rectangles.length;\\n        int m = points.length;\\n        int[][] elements = new int[n + m][];\\n        \\n        // init.\\n        for(int i = 0; i < n; i++){\\n            elements[i] = rectangles[i];\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            elements[n + i] = new int[]{points[i][0], points[i][1], i};\\n        }\\n        \\n        // sort\\n        Arrays.sort(elements, (a, b) -> (a[0] != b[0] ? b[0] - a[0] : a.length - b.length));\\n        \\n        // sweep line : count values on y direction [1, 100]\\n        int[] ct = new int[101];\\n        int[] ret = new int[m];\\n        \\n        for(int[] element : elements){\\n            // check current is rectangle or point\\n            // case 1: if rectangle, range count 0 to yi ++\\n            if(element.length == 2){\\n                for(int y = 0; y <= element[1]; y++){\\n                    ct[y]++;\\n                }\\n            // case 2: if point, checkout by current count \\n            }else{\\n                ret[element[2]] = ct[element[1]];\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tint n = rectangles.length;\\n        int m = points.length;\\n        int[][] elements = new int[n + m][];\\n        \\n        // init.\\n        for(int i = 0; i < n; i++){\\n            elements[i] = rectangles[i];\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            elements[n + i] = new int[]{points[i][0], points[i][1], i};\\n        }\\n\\t```\n```\\n\\t\\t// sort\\n        Arrays.sort(elements, (a, b) -> (a[0] != b[0] ? b[0] - a[0] : a.length - b.length));\\n\\t```\n```\\n// sweep line : count values on y direction [1, 100]\\n        int[] ct = new int[101];\\n        int[] ret = new int[m];\\n        \\n        for(int[] element : elements){\\n            // check current is rectangle or point\\n            // case 1: if rectangle, range count 0 to yi ++\\n            if(element.length == 2){\\n                for(int y = 0; y <= element[1]; y++){\\n                    ct[y]++;\\n                }\\n            // case 2: if point, checkout by current count \\n            }else{\\n                ret[element[2]] = ct[element[1]];\\n            }\\n        }\\n```\n```\\n// Solution  from @uwi\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        // idea: sort rectangles and points in descending order by x value and type\\n        //       sweep line on y\\n        \\n        int n = rectangles.length;\\n        int m = points.length;\\n        int[][] elements = new int[n + m][];\\n        \\n        // init.\\n        for(int i = 0; i < n; i++){\\n            elements[i] = rectangles[i];\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            elements[n + i] = new int[]{points[i][0], points[i][1], i};\\n        }\\n        \\n        // sort\\n        Arrays.sort(elements, (a, b) -> (a[0] != b[0] ? b[0] - a[0] : a.length - b.length));\\n        \\n        // sweep line : count values on y direction [1, 100]\\n        int[] ct = new int[101];\\n        int[] ret = new int[m];\\n        \\n        for(int[] element : elements){\\n            // check current is rectangle or point\\n            // case 1: if rectangle, range count 0 to yi ++\\n            if(element.length == 2){\\n                for(int y = 0; y <= element[1]; y++){\\n                    ct[y]++;\\n                }\\n            // case 2: if point, checkout by current count \\n            }else{\\n                ret[element[2]] = ct[element[1]];\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977370,
                "title": "c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>&nums,int target)\\n    {\\n        int l=0;\\n        int r=nums.size()-1;\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(nums[mid]>=target)\\n            {\\n                ans=nums.size()-mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> countRectangles(vector<vector<int>>& rect, vector<vector<int>>& point) \\n    {\\n        vector<int>dp[101];\\n        for(auto &it:rect)\\n        {\\n            dp[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<101;i++)\\n        {\\n            sort(dp[i].begin(),dp[i].end());\\n        }\\n        vector<int>ans;\\n        for(auto &it:point)\\n        {\\n            int sum=0;\\n            int length=it[0];\\n            int height=it[1];\\n            for(int i=height;i<101;i++)\\n            {\\n                sum+=find(dp[i],it[0]);\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>&nums,int target)\\n    {\\n        int l=0;\\n        int r=nums.size()-1;\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(nums[mid]>=target)\\n            {\\n                ans=nums.size()-mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> countRectangles(vector<vector<int>>& rect, vector<vector<int>>& point) \\n    {\\n        vector<int>dp[101];\\n        for(auto &it:rect)\\n        {\\n            dp[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<101;i++)\\n        {\\n            sort(dp[i].begin(),dp[i].end());\\n        }\\n        vector<int>ans;\\n        for(auto &it:point)\\n        {\\n            int sum=0;\\n            int length=it[0];\\n            int height=it[1];\\n            for(int i=height;i<101;i++)\\n            {\\n                sum+=find(dp[i],it[0]);\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976827,
                "title": "5-lines-easy-solution-with-explanation-and-analysis",
                "content": "Notice the constraints of y-axis: `1 <= hi, yj <= 100`.\\nWe can sort rectangles by x-axis and separate them by y-axis.\\nWhen we search for the answer of a point (x, y) we can search only in all lists with `height >= y`, and with the fact that lengths (x\\'s) are already sorted, we can use binary search to find the number of rectangles with height y that contain the given point.\\n\\n**Python:**\\n\\n```\\ndef countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        rectangles.sort()\\n        length = defaultdict(list)\\n        for l, h in rectangles:\\n            length[h].append(l)\\n        return [sum(len(length[h]) - bisect.bisect_left(length[h], x) for h in range(y, 101)) for x, y in points]\\n```\\n\\n**Complexity: O(nlogn)**",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\ndef countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        rectangles.sort()\\n        length = defaultdict(list)\\n        for l, h in rectangles:\\n            length[h].append(l)\\n        return [sum(len(length[h]) - bisect.bisect_left(length[h], x) for h in range(y, 101)) for x, y in points]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1980349,
                "title": "python3-binary-search",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/c2730559a4a05cfc912d81e5d7a3d4d607079401) for solutions of weekly 290.\\n\\n```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        mp = defaultdict(list)\\n        for l, h in rectangles: mp[h].append(l)\\n        for v in mp.values(): v.sort()\\n        ans = []\\n        for x, y in points: \\n            cnt = 0 \\n            for yy in range(y, 101): \\n                if yy in mp: cnt += len(mp[yy]) - bisect_left(mp[yy], x)\\n            ans.append(cnt)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        mp = defaultdict(list)\\n        for l, h in rectangles: mp[h].append(l)\\n        for v in mp.values(): v.sort()\\n        ans = []\\n        for x, y in points: \\n            cnt = 0 \\n            for yy in range(y, 101): \\n                if yy in mp: cnt += len(mp[yy]) - bisect_left(mp[yy], x)\\n            ans.append(cnt)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976954,
                "title": "c-binary-search",
                "content": "Iterating over the y axis that is greater than the given value and checking the number of possible solutions using binary search\\n```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n    \\n        sort(rectangles.begin(),rectangles.end());\\n        unordered_map<int,vector<int>> mp;\\n        for(auto& r:rectangles)\\n        {\\n            mp[r[1]].push_back(r[0]);\\n        }\\n        vector<int> v;\\n        vector<int> res;\\n        for(auto& p:points)\\n        {\\n            int a=p[0],b=p[1];\\n            int cnt=0;\\n            for(int i=b;i<=100;i++)\\n            {\\n                v=mp[i];\\n                int t=lower_bound(v.begin(),v.end(),a)-v.begin();\\n                cnt+=(v.size()-t);\\n            }\\n            res.push_back(cnt);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n    \\n        sort(rectangles.begin(),rectangles.end());\\n        unordered_map<int,vector<int>> mp;\\n        for(auto& r:rectangles)\\n        {\\n            mp[r[1]].push_back(r[0]);\\n        }\\n        vector<int> v;\\n        vector<int> res;\\n        for(auto& p:points)\\n        {\\n            int a=p[0],b=p[1];\\n            int cnt=0;\\n            for(int i=b;i<=100;i++)\\n            {\\n                v=mp[i];\\n                int t=lower_bound(v.begin(),v.end(),a)-v.begin();\\n                cnt+=(v.size()-t);\\n            }\\n            res.push_back(cnt);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976924,
                "title": "trivial-segment-tree",
                "content": "Process by x-coordinates descending, then query number of points inserted which has y-coordinates greater or equal to current one, done by discretizing y-coordinates then insert into seg tree\\n```\\n#include <algorithm>\\n#include <cassert>\\n#include <vector>\\n\\n\\n#ifdef _MSC_VER\\n#include <intrin.h>\\n#endif\\n\\nnamespace atcoder {\\n\\nnamespace internal {\\n\\nint ceil_pow2(int n) {\\n    int x = 0;\\n    while ((1U << x) < (unsigned int)(n)) x++;\\n    return x;\\n}\\n\\nint bsf(unsigned int n) {\\n#ifdef _MSC_VER\\n    unsigned long index;\\n    _BitScanForward(&index, n);\\n    return index;\\n#else\\n    return __builtin_ctz(n);\\n#endif\\n}\\n\\n}  // namespace internal\\n\\n}  // namespace atcoder\\n\\n\\nnamespace atcoder {\\n\\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\\n  public:\\n    segtree() : segtree(0) {}\\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\\n        log = internal::ceil_pow2(_n);\\n        size = 1 << log;\\n        d = std::vector<S>(2 * size, e());\\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\\n        for (int i = size - 1; i >= 1; i--) {\\n            update(i);\\n        }\\n    }\\n\\n    void set(int p, S x) {\\n        assert(0 <= p && p < _n);\\n        p += size;\\n        d[p] = x;\\n        for (int i = 1; i <= log; i++) update(p >> i);\\n    }\\n\\n    S get(int p) {\\n        assert(0 <= p && p < _n);\\n        return d[p + size];\\n    }\\n\\n    S prod(int l, int r) {\\n        assert(0 <= l && l <= r && r <= _n);\\n        S sml = e(), smr = e();\\n        l += size;\\n        r += size;\\n\\n        while (l < r) {\\n            if (l & 1) sml = op(sml, d[l++]);\\n            if (r & 1) smr = op(d[--r], smr);\\n            l >>= 1;\\n            r >>= 1;\\n        }\\n        return op(sml, smr);\\n    }\\n\\n    S all_prod() { return d[1]; }\\n\\n    template <bool (*f)(S)> int max_right(int l) {\\n        return max_right(l, [](S x) { return f(x); });\\n    }\\n    template <class F> int max_right(int l, F f) {\\n        assert(0 <= l && l <= _n);\\n        assert(f(e()));\\n        if (l == _n) return _n;\\n        l += size;\\n        S sm = e();\\n        do {\\n            while (l % 2 == 0) l >>= 1;\\n            if (!f(op(sm, d[l]))) {\\n                while (l < size) {\\n                    l = (2 * l);\\n                    if (f(op(sm, d[l]))) {\\n                        sm = op(sm, d[l]);\\n                        l++;\\n                    }\\n                }\\n                return l - size;\\n            }\\n            sm = op(sm, d[l]);\\n            l++;\\n        } while ((l & -l) != l);\\n        return _n;\\n    }\\n\\n    template <bool (*f)(S)> int min_left(int r) {\\n        return min_left(r, [](S x) { return f(x); });\\n    }\\n    template <class F> int min_left(int r, F f) {\\n        assert(0 <= r && r <= _n);\\n        assert(f(e()));\\n        if (r == 0) return 0;\\n        r += size;\\n        S sm = e();\\n        do {\\n            r--;\\n            while (r > 1 && (r % 2)) r >>= 1;\\n            if (!f(op(d[r], sm))) {\\n                while (r < size) {\\n                    r = (2 * r + 1);\\n                    if (f(op(d[r], sm))) {\\n                        sm = op(d[r], sm);\\n                        r--;\\n                    }\\n                }\\n                return r + 1 - size;\\n            }\\n            sm = op(d[r], sm);\\n        } while ((r & -r) != r);\\n        return 0;\\n    }\\n\\n  private:\\n    int _n, size, log;\\n    std::vector<S> d;\\n\\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\\n};\\n\\n}  // namespace atcoder\\n// source: https://github.com/atcoder/ac-library\\n\\n// shame leetcode not using gcc\\n// what a shame \\uD83D\\uDE1E\\nstatic int op(int a, int b) { return a + b; }\\nstatic int e() { return 0; }\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& r, vector<vector<int>>& p) {\\n        vector<int> vals;\\n        for (auto i : r) vals.push_back(i[1]);\\n        for (auto i : p) vals.push_back(i[1]);\\n        sort(vals.begin(), vals.end());\\n        auto get = [&](int i) { return lower_bound(vals.begin(), vals.end(), i) - vals.begin(); };\\n        for (auto &i : r) i[1] = get(i[1]);\\n        for (auto &i : p) i[1] = get(i[1]);\\n        \\n        vector<array<int, 3>> v;\\n        int big = 1e9;\\n        for (auto i : r) {\\n            v.push_back({i[0], big, i[1]});\\n        }\\n        for (int i = 0; i < p.size(); ++i) {\\n            v.push_back({p[i][0], j++, p[i][1]});\\n        }\\n        sort(v.rbegin(), v.rend());\\n        vector<int> res(p.size());\\n        int sz = vals.size()+10;\\n        atcoder::segtree<int, op, e> t(sz);\\n        for (auto [x, i, y] : v) {\\n            if (i == big) {\\n                t.set(y, t.get(y)+1);\\n            } else {\\n                res[i] = t.prod(y, sz);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n#include <algorithm>\\n#include <cassert>\\n#include <vector>\\n\\n\\n#ifdef _MSC_VER\\n#include <intrin.h>\\n#endif\\n\\nnamespace atcoder {\\n\\nnamespace internal {\\n\\nint ceil_pow2(int n) {\\n    int x = 0;\\n    while ((1U << x) < (unsigned int)(n)) x++;\\n    return x;\\n}\\n\\nint bsf(unsigned int n) {\\n#ifdef _MSC_VER\\n    unsigned long index;\\n    _BitScanForward(&index, n);\\n    return index;\\n#else\\n    return __builtin_ctz(n);\\n#endif\\n}\\n\\n}  // namespace internal\\n\\n}  // namespace atcoder\\n\\n\\nnamespace atcoder {\\n\\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\\n  public:\\n    segtree() : segtree(0) {}\\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\\n        log = internal::ceil_pow2(_n);\\n        size = 1 << log;\\n        d = std::vector<S>(2 * size, e());\\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\\n        for (int i = size - 1; i >= 1; i--) {\\n            update(i);\\n        }\\n    }\\n\\n    void set(int p, S x) {\\n        assert(0 <= p && p < _n);\\n        p += size;\\n        d[p] = x;\\n        for (int i = 1; i <= log; i++) update(p >> i);\\n    }\\n\\n    S get(int p) {\\n        assert(0 <= p && p < _n);\\n        return d[p + size];\\n    }\\n\\n    S prod(int l, int r) {\\n        assert(0 <= l && l <= r && r <= _n);\\n        S sml = e(), smr = e();\\n        l += size;\\n        r += size;\\n\\n        while (l < r) {\\n            if (l & 1) sml = op(sml, d[l++]);\\n            if (r & 1) smr = op(d[--r], smr);\\n            l >>= 1;\\n            r >>= 1;\\n        }\\n        return op(sml, smr);\\n    }\\n\\n    S all_prod() { return d[1]; }\\n\\n    template <bool (*f)(S)> int max_right(int l) {\\n        return max_right(l, [](S x) { return f(x); });\\n    }\\n    template <class F> int max_right(int l, F f) {\\n        assert(0 <= l && l <= _n);\\n        assert(f(e()));\\n        if (l == _n) return _n;\\n        l += size;\\n        S sm = e();\\n        do {\\n            while (l % 2 == 0) l >>= 1;\\n            if (!f(op(sm, d[l]))) {\\n                while (l < size) {\\n                    l = (2 * l);\\n                    if (f(op(sm, d[l]))) {\\n                        sm = op(sm, d[l]);\\n                        l++;\\n                    }\\n                }\\n                return l - size;\\n            }\\n            sm = op(sm, d[l]);\\n            l++;\\n        } while ((l & -l) != l);\\n        return _n;\\n    }\\n\\n    template <bool (*f)(S)> int min_left(int r) {\\n        return min_left(r, [](S x) { return f(x); });\\n    }\\n    template <class F> int min_left(int r, F f) {\\n        assert(0 <= r && r <= _n);\\n        assert(f(e()));\\n        if (r == 0) return 0;\\n        r += size;\\n        S sm = e();\\n        do {\\n            r--;\\n            while (r > 1 && (r % 2)) r >>= 1;\\n            if (!f(op(d[r], sm))) {\\n                while (r < size) {\\n                    r = (2 * r + 1);\\n                    if (f(op(d[r], sm))) {\\n                        sm = op(d[r], sm);\\n                        r--;\\n                    }\\n                }\\n                return r + 1 - size;\\n            }\\n            sm = op(d[r], sm);\\n        } while ((r & -r) != r);\\n        return 0;\\n    }\\n\\n  private:\\n    int _n, size, log;\\n    std::vector<S> d;\\n\\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\\n};\\n\\n}  // namespace atcoder\\n// source: https://github.com/atcoder/ac-library\\n\\n// shame leetcode not using gcc\\n// what a shame \\uD83D\\uDE1E\\nstatic int op(int a, int b) { return a + b; }\\nstatic int e() { return 0; }\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& r, vector<vector<int>>& p) {\\n        vector<int> vals;\\n        for (auto i : r) vals.push_back(i[1]);\\n        for (auto i : p) vals.push_back(i[1]);\\n        sort(vals.begin(), vals.end());\\n        auto get = [&](int i) { return lower_bound(vals.begin(), vals.end(), i) - vals.begin(); };\\n        for (auto &i : r) i[1] = get(i[1]);\\n        for (auto &i : p) i[1] = get(i[1]);\\n        \\n        vector<array<int, 3>> v;\\n        int big = 1e9;\\n        for (auto i : r) {\\n            v.push_back({i[0], big, i[1]});\\n        }\\n        for (int i = 0; i < p.size(); ++i) {\\n            v.push_back({p[i][0], j++, p[i][1]});\\n        }\\n        sort(v.rbegin(), v.rend());\\n        vector<int> res(p.size());\\n        int sz = vals.size()+10;\\n        atcoder::segtree<int, op, e> t(sz);\\n        for (auto [x, i, y] : v) {\\n            if (i == big) {\\n                t.set(y, t.get(y)+1);\\n            } else {\\n                res[i] = t.prod(y, sz);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2483126,
                "title": "easy-binary-search-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<vector<int>>dp(101);\\n        \\n        for(int i=0;i<rectangles.size();i++){\\n            dp[rectangles[i][1]].push_back(rectangles[i][0]);\\n        }\\n        \\n        for(auto &ele:dp){\\n            sort(ele.begin(),ele.end());\\n        }\\n        vector<int>ans;\\n        \\n        \\n        for(int i=0;i<points.size();i++){\\n            int ct=0;\\n            for(int j=points[i][1];j<101;j++){\\n                int t=lower_bound(dp[j].begin(),dp[j].end(),points[i][0])-dp[j].begin();\\n                \\n                ct+=dp[j].size()-t;\\n            }\\n            ans.push_back(ct);\\n        }\\n                                   \\n         return ans;                                                         \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<vector<int>>dp(101);\\n        \\n        for(int i=0;i<rectangles.size();i++){\\n            dp[rectangles[i][1]].push_back(rectangles[i][0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2382022,
                "title": "2-approaches-binary-search-fenwick-tree",
                "content": "### **Approach 1: (naive)**\\n\\nReiterate through the rectangles array for every point, and count the no.of rectangles engulfing that point.\\n\\n**Time Complexity:** O(rectanglesLength * pointsLength)\\n**Space Complexity:** O(1)\\n\\n**Verdict:** Time Limit Exceeded (~10^9 comparisons)\\n\\n### **Approach 2: (binary search/BST)**\\n\\nSince the difference in height is very less for the question (100), so, we can use this fact. We will have an array of size 100, each cell will store the x-coordinates for every rectangles from height [1 ... height_of_that_rectangle]. \\nNow, sort the list in every cell.\\nNext, for every points, move to that specific height cell in the array, and return the no.of x-coordinaates, which are >= to the present x-point coordinate. This can be efficiently done using Binary Search.\\n\\n*Note: This approach is explained well in other blogs also. I can understand, that I am unable to explain this approach nicely. Kindly refer to those blogs for this approach. My main motive for this one is to highlight the Fenwick Tree solution.*\\n\\n**Java Code: (Binaary Search)**\\n\\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        \\n        int pointsLength = points.length, result[] = new int[pointsLength];\\n        \\n        List<Integer>[] arr = new List[101];\\n        for(int i=1; i<=100; ++i)\\n            arr[i] = new ArrayList<Integer>();\\n        \\n        for(int[] a:rectangles) \\n            for(int i=1; i<=a[1]; ++i)\\n                arr[i].add(a[0]);\\n            \\n        for(int i=1; i<=100; ++i)\\n            Collections.sort(arr[i]);\\n        \\n        for(int i=0; i<pointsLength; ++i) \\n            result[i] = arr[points[i][1]].size() - upperBoundX(arr[points[i][1]], points[i][0]);\\n        \\n        return result;\\n    }\\n    \\n    private int upperBoundX(List<Integer> list, int val) {\\n        int left=0, right=list.size()-1, mid=0;\\n        \\n        if(list.isEmpty())\\n            return right+1;\\n        \\n        if(val <= list.get(0)) \\n            return 0;\\n        \\n        if(val > list.get(right))\\n            return right+1;\\n        \\n        while(left <= right) {\\n            mid = (left+right)/2;\\n            \\n            if(val <= list.get(mid)) \\n                right = mid-1;\\n            else \\n                left = mid+1;\\n        }\\n        \\n        return left;\\n    }\\n}\\n```\\n\\n**Time Complexity:** O(rectanglesLength * 100) + O(rectanglesLength * log(rectanglesLength)) + O(rectanglesLength * log(rectanglesLength))\\n**Space Complexity:** O(1)\\n\\n**Verdict:** 1000ms (~10^6 comparisons)\\n\\nCan be improved further using TreeMap (BST) instead of normal 100 size array.\\n\\n### **Approach 3: (BIT/Fenwick Tree)**\\n\\nIf the difference in the height is in the order of 10^5, we will have no way other that using Binary Indexed Trees. \\n\\n1. Sort both the rectangles and points in decsending order of x\\n2. Create a Fenwick Tree for [minHeight ... maxHeight]\\n3. Traverse both the rectangles and points array at the same time. Increase the count in Fenwick Tree ([y_recatngle ... y_recatngle]) for every rectangle, such that x_rectangle >= x_point. Now, when x_rectangle < x_point, find the count of recatngles in the height range [y_point, maxHeight] and then service the next point\\n4. Stoe this count for every point and return this array\\n\\n**Java Code: (Fenwick)**\\n\\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        \\n        int rectanglesLength = rectangles.length, pointsLength = points.length, i=0, j=0, result[] = new int[pointsLength], minHeight = Integer.MAX_VALUE, maxHeight = 0;\\n        \\n        for(int ii=0; ii<pointsLength; ++ii)\\n            points[ii] = new int[]{points[ii][0], points[ii][1], ii};\\n        \\n        // Sort the rectangles and points based on the decreasing order of x\\n        \\n        Arrays.sort(rectangles, (a, b) -> b[0] - a[0]);\\n        Arrays.sort(points, (a, b) -> b[0] - a[0]);\\n        \\n        for(i=0; i<rectanglesLength; ++i) {\\n            minHeight = Math.min(rectangles[i][1], minHeight);\\n            maxHeight = Math.max(rectangles[i][1], maxHeight);\\n        }\\n        \\n        for(i=0; i<pointsLength; ++i) {\\n            minHeight = Math.min(points[i][1], minHeight);\\n            maxHeight = Math.max(points[i][1], maxHeight);\\n        }\\n        \\n        FenwickTree root = createTree(minHeight, maxHeight); \\n        \\n        for(i=0, j=0; i<rectanglesLength && j<pointsLength; ) {\\n            \\n            int[] rectanglesArr = rectangles[i], pointsArr = points[j];\\n            \\n            if(rectanglesArr[0] >= pointsArr[0]) {\\n                insertVal(root, rectanglesArr[1]);\\n                ++i;\\n                continue;\\n            }\\n            \\n            result[points[j][2]] = rectanglesCount(root, pointsArr[1], maxHeight);\\n            ++j;\\n        }\\n        \\n        while(j<pointsLength) {\\n            result[points[j][2]] = rectanglesCount(root, points[j][1], maxHeight);\\n            ++j;\\n        }\\n            \\n        \\n        return result;\\n    }\\n    \\n    // Create a Fenwick Tree from the heights in the range [min_height ... max_height]\\n    \\n    class FenwickTree {\\n        int from, to, mid, count;\\n        FenwickTree leftChild, rightChild;\\n        \\n        FenwickTree(int from, int to, int mid) {\\n            this.from = from;\\n            this.to = to;\\n            this.mid = mid;\\n            count = 0;\\n            leftChild = rightChild = null;\\n        }\\n    }\\n    \\n    private FenwickTree createTree(int from, int to) {\\n        \\n        int mid = (from + to)/2;\\n        FenwickTree ptr = new FenwickTree(from, to, mid);\\n        \\n        if(from == to) \\n            return ptr;\\n        \\n        ptr.leftChild = createTree(from, mid);\\n        ptr.rightChild = createTree(mid+1, to);  \\n        \\n        return ptr;\\n    }\\n    \\n    private void insertVal(FenwickTree ptr, int height) {\\n        \\n        if(ptr.from == ptr.to && ptr.mid == height) {\\n            ++ptr.count;\\n            return;\\n        }\\n        \\n        if(height <= ptr.mid)\\n            insertVal(ptr.leftChild, height);\\n        else \\n            insertVal(ptr.rightChild, height);\\n            \\n        ++ptr.count;\\n    }\\n    \\n    private int rectanglesCount(FenwickTree ptr, int from, int to) {\\n        \\n        if(from == ptr.from && to == ptr.to) \\n            return ptr.count;\\n        \\n        if(to <= ptr.mid) \\n            return rectanglesCount(ptr.leftChild, from, to);\\n        \\n        if(from > ptr.mid) \\n            return rectanglesCount(ptr.rightChild, from, to);\\n        \\n        return rectanglesCount(ptr.leftChild, from, ptr.mid) + rectanglesCount(ptr.rightChild, ptr.mid+1, to);\\n        \\n    }\\n}\\n```\\n\\nThis code is very lengthy, but can be reduced if segment tree is used. Complexity will remain the same.\\n\\n**Time Complexity:** O(rectanglesLength * log(diff)) + O(pointsLength * log(diff)), where diff = maxHeight - minHeight\\n**Space Complexity:** O(2 * diff -1), where diff = maxHeight - minHeight\\n\\n**Verdict:** [72ms (faster than 95%)](https://leetcode.com/submissions/detail/765350195/)\\n\\nPlease upvote the answer!",
                "solutionTags": [
                    "Binary Search",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        \\n        int pointsLength = points.length, result[] = new int[pointsLength];\\n        \\n        List<Integer>[] arr = new List[101];\\n        for(int i=1; i<=100; ++i)\\n            arr[i] = new ArrayList<Integer>();\\n        \\n        for(int[] a:rectangles) \\n            for(int i=1; i<=a[1]; ++i)\\n                arr[i].add(a[0]);\\n            \\n        for(int i=1; i<=100; ++i)\\n            Collections.sort(arr[i]);\\n        \\n        for(int i=0; i<pointsLength; ++i) \\n            result[i] = arr[points[i][1]].size() - upperBoundX(arr[points[i][1]], points[i][0]);\\n        \\n        return result;\\n    }\\n    \\n    private int upperBoundX(List<Integer> list, int val) {\\n        int left=0, right=list.size()-1, mid=0;\\n        \\n        if(list.isEmpty())\\n            return right+1;\\n        \\n        if(val <= list.get(0)) \\n            return 0;\\n        \\n        if(val > list.get(right))\\n            return right+1;\\n        \\n        while(left <= right) {\\n            mid = (left+right)/2;\\n            \\n            if(val <= list.get(mid)) \\n                right = mid-1;\\n            else \\n                left = mid+1;\\n        }\\n        \\n        return left;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        \\n        int rectanglesLength = rectangles.length, pointsLength = points.length, i=0, j=0, result[] = new int[pointsLength], minHeight = Integer.MAX_VALUE, maxHeight = 0;\\n        \\n        for(int ii=0; ii<pointsLength; ++ii)\\n            points[ii] = new int[]{points[ii][0], points[ii][1], ii};\\n        \\n        // Sort the rectangles and points based on the decreasing order of x\\n        \\n        Arrays.sort(rectangles, (a, b) -> b[0] - a[0]);\\n        Arrays.sort(points, (a, b) -> b[0] - a[0]);\\n        \\n        for(i=0; i<rectanglesLength; ++i) {\\n            minHeight = Math.min(rectangles[i][1], minHeight);\\n            maxHeight = Math.max(rectangles[i][1], maxHeight);\\n        }\\n        \\n        for(i=0; i<pointsLength; ++i) {\\n            minHeight = Math.min(points[i][1], minHeight);\\n            maxHeight = Math.max(points[i][1], maxHeight);\\n        }\\n        \\n        FenwickTree root = createTree(minHeight, maxHeight); \\n        \\n        for(i=0, j=0; i<rectanglesLength && j<pointsLength; ) {\\n            \\n            int[] rectanglesArr = rectangles[i], pointsArr = points[j];\\n            \\n            if(rectanglesArr[0] >= pointsArr[0]) {\\n                insertVal(root, rectanglesArr[1]);\\n                ++i;\\n                continue;\\n            }\\n            \\n            result[points[j][2]] = rectanglesCount(root, pointsArr[1], maxHeight);\\n            ++j;\\n        }\\n        \\n        while(j<pointsLength) {\\n            result[points[j][2]] = rectanglesCount(root, points[j][1], maxHeight);\\n            ++j;\\n        }\\n            \\n        \\n        return result;\\n    }\\n    \\n    // Create a Fenwick Tree from the heights in the range [min_height ... max_height]\\n    \\n    class FenwickTree {\\n        int from, to, mid, count;\\n        FenwickTree leftChild, rightChild;\\n        \\n        FenwickTree(int from, int to, int mid) {\\n            this.from = from;\\n            this.to = to;\\n            this.mid = mid;\\n            count = 0;\\n            leftChild = rightChild = null;\\n        }\\n    }\\n    \\n    private FenwickTree createTree(int from, int to) {\\n        \\n        int mid = (from + to)/2;\\n        FenwickTree ptr = new FenwickTree(from, to, mid);\\n        \\n        if(from == to) \\n            return ptr;\\n        \\n        ptr.leftChild = createTree(from, mid);\\n        ptr.rightChild = createTree(mid+1, to);  \\n        \\n        return ptr;\\n    }\\n    \\n    private void insertVal(FenwickTree ptr, int height) {\\n        \\n        if(ptr.from == ptr.to && ptr.mid == height) {\\n            ++ptr.count;\\n            return;\\n        }\\n        \\n        if(height <= ptr.mid)\\n            insertVal(ptr.leftChild, height);\\n        else \\n            insertVal(ptr.rightChild, height);\\n            \\n        ++ptr.count;\\n    }\\n    \\n    private int rectanglesCount(FenwickTree ptr, int from, int to) {\\n        \\n        if(from == ptr.from && to == ptr.to) \\n            return ptr.count;\\n        \\n        if(to <= ptr.mid) \\n            return rectanglesCount(ptr.leftChild, from, to);\\n        \\n        if(from > ptr.mid) \\n            return rectanglesCount(ptr.rightChild, from, to);\\n        \\n        return rectanglesCount(ptr.leftChild, from, ptr.mid) + rectanglesCount(ptr.rightChild, ptr.mid+1, to);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986710,
                "title": "tricky-solution-using-bs",
                "content": "\\'\\'\\'\\nunordered_map<int, vector<int>>m;\\n        int mnh = 101, mxh = 0;\\n        for(vector<int> v: rectangles) {\\n            mnh = min(mnh, v[1]); \\n            mxh = max(mxh, v[1]);\\n            m[v[1]].push_back(v[0]);\\n        }\\n        for(auto it: m) {\\n            sort(m[it.first].begin(), m[it.first].end());\\n        }\\n        vector<int> ans;\\n        for(vector<int> p: points) {\\n            int x = p[0];\\n            int y = p[1];\\n            int a = 0;\\n            for(int i = y; i<=mxh; i++) {\\n                if(m.find(i) != m.end()) {\\n                    // vector<int> v = m[i];\\n                    int n = m[i].size();\\n                    a += n - (lower_bound(m[i].begin(), m[i].end(), x) - m[i].begin());\\n                }\\n            }\\n            ans.push_back(a);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "\\'\\'\\'\\nunordered_map<int, vector<int>>m;\\n        int mnh = 101, mxh = 0;\\n        for(vector<int> v: rectangles) {\\n            mnh = min(mnh, v[1]); \\n            mxh = max(mxh, v[1]);\\n            m[v[1]].push_back(v[0]);\\n        }\\n        for(auto it: m) {\\n            sort(m[it.first].begin(), m[it.first].end());\\n        }\\n        vector<int> ans;\\n        for(vector<int> p: points) {\\n            int x = p[0];\\n            int y = p[1];\\n            int a = 0;\\n            for(int i = y; i<=mxh; i++) {\\n                if(m.find(i) != m.end()) {\\n                    // vector<int> v = m[i];\\n                    int n = m[i].size();\\n                    a += n - (lower_bound(m[i].begin(), m[i].end(), x) - m[i].begin());\\n                }\\n            }\\n            ans.push_back(a);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 1981885,
                "title": "c-time-complexity-101-n-in-worst-case",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n      \\n        vector<int> ans;\\n        \\n        vector<vector<int> > v(101);\\n        for(int i=0; i<rectangles.size(); i++){\\n            v[rectangles[i][1]].push_back(rectangles[i][0]);\\n        }\\n        for(int i=0; i<101; i++){\\n            sort(v[i].begin(),v[i].end());\\n        }\\n     \\n        for(auto &aka:points){\\n            int cnt=0;\\n            for(int i=aka[1]; i < 101; i++){\\n                \\n                    int id=lower_bound(v[i].begin(), v[i].end(), aka[0])-v[i].begin();\\n                    cnt+=v[i].size()-id;\\n                             \\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n      \\n        vector<int> ans;\\n        \\n        vector<vector<int> > v(101);\\n        for(int i=0; i<rectangles.size(); i++){\\n            v[rectangles[i][1]].push_back(rectangles[i][0]);\\n        }\\n        for(int i=0; i<101; i++){\\n            sort(v[i].begin(),v[i].end());\\n        }\\n     \\n        for(auto &aka:points){\\n            int cnt=0;\\n            for(int i=aka[1]; i < 101; i++){\\n                \\n                    int id=lower_bound(v[i].begin(), v[i].end(), aka[0])-v[i].begin();\\n                    cnt+=v[i].size()-id;\\n                             \\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978023,
                "title": "c-bs-simple-explained",
                "content": "in the constraints height of ractangle can be max 100\\nso ,\\ncreate a 2D vector/array \\nand strore the X cordinate of the ractangle to the Yth row of created vector\\ne.g. \\nwe have cordinates (1,**2**),(2,**3**),(3,**2**),(2,**2**)\\nso our vector will be\\nv[0]=empty\\nv[1]=empty\\nv[2]={1,3,2}\\nv[3]={2}\\n\\nthen sort every row of the array\\nthen traverse to the point array and from the row greater then Py (points y cordinate)\\nsearch the greater X coordinate in the new vector that we created \\n \\n e.g.\\n p[i]={3,2}\\n so from the 2nd row of our vector to 100th row search for the elements >= 3\\n \\n```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& r, vector<vector<int>>& p) {\\n        vector<vector<int>> v(101);  // vector to store the x cordinates on the Yth row\\n\\t\\tfor(int i=0;i<r.size();i++)       v[r[i][1]].push_back(r[i][0]);\\n        \\n        for(int i=0;i<101;i++)      sort(v[i].begin(),v[i].end());\\n        \\n        vector<int> ans;\\n        for(int i=0;i<p.size();i++){\\n            int c=0;\\n            for(int j=p[i][1];j<101;j++){\\n                int x=lower_bound(v[j].begin(),v[j].end(),p[i][0])-v[j].begin();;\\n                c+=(v[j].size()-x);\\n            }\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTC O(nlogn) at max\\nSC O(101*n) at max",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& r, vector<vector<int>>& p) {\\n        vector<vector<int>> v(101);  // vector to store the x cordinates on the Yth row\\n\\t\\tfor(int i=0;i<r.size();i++)       v[r[i][1]].push_back(r[i][0]);\\n        \\n        for(int i=0;i<101;i++)      sort(v[i].begin(),v[i].end());\\n        \\n        vector<int> ans;\\n        for(int i=0;i<p.size();i++){\\n            int c=0;\\n            for(int j=p[i][1];j<101;j++){\\n                int x=lower_bound(v[j].begin(),v[j].end(),p[i][0])-v[j].begin();;\\n                c+=(v[j].size()-x);\\n            }\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977726,
                "title": "python-fenwick-tree-can-solve-y-up-to-10-5-and-more",
                "content": "Previous solution is given by the contraint that y is very small,  however,  when y is up to 10^5 or more,  it will be too slow. \\nMy fenwick tree solution works when y is up to 10^5,  if you want to solve y up to 10^9,  you can set up a dictionary and convert all matrix points and query points to indexes [0, q+n-1] \\n\\nTime complexity:  O(nlogn + qlgy   )\\nSpace complexity:  O(y)\\n\\n\\n```\\nclass fenwick(object):\\n    def __init__(self, n):\\n        self.n = n\\n        self.cul = [0]*n\\n        self.maxd = len(bin(n))-3\\n\\n    def update(self,index,diff):\\n        i = index\\n        while i<self.n:\\n            self.cul[i] += diff\\n            i += (i+1)&(-i-1)\\n\\n\\n    def getaccu(self,index):\\n        output = 0\\n        i = index\\n        while i>=0:\\n            output += self.cul[i]\\n            i -= (i+1)&(-i-1)\\n        return output\\n    \\n\\nclass Solution(object):\\n    def countRectangles(self, rectangles, points):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :type points: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = [0]*len(points)\\n        heap = []\\n        fen = fenwick(101)\\n        for [x,y] in rectangles:\\n            heapq.heappush(heap,(x,y))\\n            fen.update(y,1)\\n\\n        query = []        \\n        for i,p in enumerate(points):\\n            query.append([p[0],i])\\n        query.sort()\\n        \\n        count = len(heap)\\n        for [x,i] in query:\\n            while heap and heap[0][0] < x:\\n                ele = heapq.heappop(heap)\\n                fen.update(ele[1],-1)\\n                count -= 1\\n            ans[i] = count - fen.getaccu(points[i][1]-1) \\n        return ans\\n\\n                \\n                \\n        \\n            \\n            \\n\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass fenwick(object):\\n    def __init__(self, n):\\n        self.n = n\\n        self.cul = [0]*n\\n        self.maxd = len(bin(n))-3\\n\\n    def update(self,index,diff):\\n        i = index\\n        while i<self.n:\\n            self.cul[i] += diff\\n            i += (i+1)&(-i-1)\\n\\n\\n    def getaccu(self,index):\\n        output = 0\\n        i = index\\n        while i>=0:\\n            output += self.cul[i]\\n            i -= (i+1)&(-i-1)\\n        return output\\n    \\n\\nclass Solution(object):\\n    def countRectangles(self, rectangles, points):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :type points: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = [0]*len(points)\\n        heap = []\\n        fen = fenwick(101)\\n        for [x,y] in rectangles:\\n            heapq.heappush(heap,(x,y))\\n            fen.update(y,1)\\n\\n        query = []        \\n        for i,p in enumerate(points):\\n            query.append([p[0],i])\\n        query.sort()\\n        \\n        count = len(heap)\\n        for [x,i] in query:\\n            while heap and heap[0][0] < x:\\n                ele = heapq.heappop(heap)\\n                fen.update(ele[1],-1)\\n                count -= 1\\n            ans[i] = count - fen.getaccu(points[i][1]-1) \\n        return ans\\n\\n                \\n                \\n        \\n            \\n            \\n\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977569,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int n = rectangles.length, Q = points.length;\\n        int[][] es = new int[n + Q][];\\n        for (int i = 0; i < n; i++) {\\n            es[i] = rectangles[i];\\n        }\\n        for (int i = 0; i < Q; i++) {\\n            es[n + i] = new int[]{points[i][0], points[i][1], i};\\n        }\\n        Arrays.sort(es, (x, y) -> {\\n            if (x[0] != y[0]) {\\n                return -(x[0] - y[0]);\\n            }\\n            return x.length - y.length;\\n        });\\n        int[] ct = new int[101];\\n        int[] ans = new int[Q];\\n        for (int[] e : es) {\\n            if (e.length == 2) {\\n                for (int i = 0; i <= e[1]; i++) {\\n                    ct[i]++;\\n                }\\n            } else {\\n                ans[e[2]] = ct[e[1]];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int n = rectangles.length, Q = points.length;\\n        int[][] es = new int[n + Q][];\\n        for (int i = 0; i < n; i++) {\\n            es[i] = rectangles[i];\\n        }\\n        for (int i = 0; i < Q; i++) {\\n            es[n + i] = new int[]{points[i][0], points[i][1], i};\\n        }\\n        Arrays.sort(es, (x, y) -> {\\n            if (x[0] != y[0]) {\\n                return -(x[0] - y[0]);\\n            }\\n            return x.length - y.length;\\n        });\\n        int[] ct = new int[101];\\n        int[] ans = new int[Q];\\n        for (int[] e : es) {\\n            if (e.length == 2) {\\n                for (int i = 0; i <= e[1]; i++) {\\n                    ct[i]++;\\n                }\\n            } else {\\n                ans[e[2]] = ct[e[1]];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976848,
                "title": "c-2250-count-number-of-rectangles-containing-each-point",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        unordered_map<int, vector<int>> mp; \\n        for (auto& r : rectangles) mp[r[1]].push_back(r[0]); \\n        for (auto& [k, v] : mp) sort(v.begin(), v.end()); \\n        vector<int> ans; \\n        for (auto& p : points) {\\n            int cnt = 0; \\n            for (int yy = p[1]; yy <= 100; ++yy) \\n                if (mp[yy].size()) \\n                    cnt += mp[yy].end() - lower_bound(mp[yy].begin(), mp[yy].end(), p[0]);\\n            ans.push_back(cnt); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        unordered_map<int, vector<int>> mp; \\n        for (auto& r : rectangles) mp[r[1]].push_back(r[0]); \\n        for (auto& [k, v] : mp) sort(v.begin(), v.end()); \\n        vector<int> ans; \\n        for (auto& p : points) {\\n            int cnt = 0; \\n            for (int yy = p[1]; yy <= 100; ++yy) \\n                if (mp[yy].size()) \\n                    cnt += mp[yy].end() - lower_bound(mp[yy].begin(), mp[yy].end(), p[0]);\\n            ans.push_back(cnt); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976839,
                "title": "prefix-sum-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int findIndex(vector<vector<int>> &rec, int x){\\n \\xA0 \\xA0 \\xA0 \\xA0//finding lowerbound -> it will find the first index from where all x coordintate >= given x\\n        \\n        int l = 0;\\n        int h = rec.size();\\n        \\n        while (l < h) {\\n            \\n            int mid =  l + (h - l) / 2;\\n            if (x <= rec[mid][0]) {\\n                h = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return l;\\n        \\n    }\\n    \\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        \\n        //sorting rectangles so that we can find lower bound\\n        sort(rectangles.begin(), rectangles.end());\\n        \\n        int n = rectangles.size();\\n        \\n        //creating a prefix array -\\n        vector<vector<int>> prefix(n+1, vector<int> (101, 0));\\n        \\n        \\n        //prefix array is storing till i element how many different heights are there\\n        for(int i=1; i<=n; i++){\\n            int h = rectangles[i-1][1];\\n            \\n            for(int j=1; j <= 100; j++){\\n                prefix[i][j] += prefix[i-1][j] + (h == j);\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(auto &v: points){\\n            //finding index for x coordinate\\n            int x = findIndex(rectangles, v[0]);\\n            \\n            int y = v[1]; //we need all the elements whose height is greater than y\\n            \\n            int cnt = 0;\\n            for(int i=y; i<101; i++){ //we interate from y till 100 and see how many element have height greater than y\\n                cnt += prefix[n][i] -  prefix[x][i];\\n            }\\n            \\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findIndex(vector<vector<int>> &rec, int x){\\n \\xA0 \\xA0 \\xA0 \\xA0//finding lowerbound -> it will find the first index from where all x coordintate >= given x\\n        \\n        int l = 0;\\n        int h = rec.size();\\n        \\n        while (l < h) {\\n            \\n            int mid =  l + (h - l) / 2;\\n            if (x <= rec[mid][0]) {\\n                h = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return l;\\n        \\n    }\\n    \\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        \\n        //sorting rectangles so that we can find lower bound\\n        sort(rectangles.begin(), rectangles.end());\\n        \\n        int n = rectangles.size();\\n        \\n        //creating a prefix array -\\n        vector<vector<int>> prefix(n+1, vector<int> (101, 0));\\n        \\n        \\n        //prefix array is storing till i element how many different heights are there\\n        for(int i=1; i<=n; i++){\\n            int h = rectangles[i-1][1];\\n            \\n            for(int j=1; j <= 100; j++){\\n                prefix[i][j] += prefix[i-1][j] + (h == j);\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(auto &v: points){\\n            //finding index for x coordinate\\n            int x = findIndex(rectangles, v[0]);\\n            \\n            int y = v[1]; //we need all the elements whose height is greater than y\\n            \\n            int cnt = 0;\\n            for(int i=y; i<101; i++){ //we interate from y till 100 and see how many element have height greater than y\\n                cnt += prefix[n][i] -  prefix[x][i];\\n            }\\n            \\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460561,
                "title": "java-binary-search-clean-code",
                "content": "here 0 <= y <= 100 , we can use this condition to solve our problem, for each rectangle we will store all x corresponding to each y in map like Map<Y, [X1,X2,X3.....]>. For each point in point array , we will iteate from 100 to current point y coordinate and for each y check how many x validate the condition.\\n```\\nclass Solution {\\n    public int binarySearch(List<Integer> l , int x){\\n        int low = 0 , high = l.size() - 1;\\n        int retval = 0;\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(l.get(mid) >= x){\\n                retval = l.size() - mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return retval;\\n    }\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Arrays.sort(rectangles,(a,b) -> a[0] - b[0]);\\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        int n = points.length;\\n        int[] ans = new int[n];\\n        for(int[] r : rectangles){\\n            int x = r[0], y = r[1];\\n            List<Integer> l = map.getOrDefault(y,new ArrayList<>());\\n            l.add(x);\\n            if(!map.containsKey(y)){\\n                map.put(y,l);    \\n            }\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            int x = points[i][0], y = points[i][1];\\n            int cnt = 0;\\n            for(int j = 100 ; j >= y ; j--){\\n                if(map.containsKey(j)){\\n                    cnt += binarySearch(map.get(j),x);\\n                }\\n            }\\n            ans[i] = cnt;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int binarySearch(List<Integer> l , int x){\\n        int low = 0 , high = l.size() - 1;\\n        int retval = 0;\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(l.get(mid) >= x){\\n                retval = l.size() - mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return retval;\\n    }\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Arrays.sort(rectangles,(a,b) -> a[0] - b[0]);\\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        int n = points.length;\\n        int[] ans = new int[n];\\n        for(int[] r : rectangles){\\n            int x = r[0], y = r[1];\\n            List<Integer> l = map.getOrDefault(y,new ArrayList<>());\\n            l.add(x);\\n            if(!map.containsKey(y)){\\n                map.put(y,l);    \\n            }\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            int x = points[i][0], y = points[i][1];\\n            int cnt = 0;\\n            for(int j = 100 ; j >= y ; j--){\\n                if(map.containsKey(j)){\\n                    cnt += binarySearch(map.get(j),x);\\n                }\\n            }\\n            ans[i] = cnt;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332504,
                "title": "python-bs-o-n-log-n",
                "content": "- Time complexity: O(n log n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n\\n        def bs(arr, a):\\n            left = 0\\n            right = len(arr) - 1\\n\\n            while left <= right:\\n                mid = (left + right) // 2\\n\\n                if arr[mid] == a:\\n                    return mid\\n                elif arr[mid] < a:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n            return left\\n\\n        dict_rectangles = defaultdict(list)\\n        result = []\\n\\n        for x, y in rectangles:\\n            dict_rectangles[y].append(x)\\n\\n        for value in dict_rectangles.values():\\n            value.sort()\\n\\n        max_heigh = max(dict_rectangles.keys())\\n\\n        for a, b in points:\\n            counts = 0\\n            for i in range(b, max_heigh + 1):\\n                if dict_rectangles[i]:\\n                    counts += len(dict_rectangles[i]) - bs(dict_rectangles[i], a)\\n            result.append(counts)\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n\\n        def bs(arr, a):\\n            left = 0\\n            right = len(arr) - 1\\n\\n            while left <= right:\\n                mid = (left + right) // 2\\n\\n                if arr[mid] == a:\\n                    return mid\\n                elif arr[mid] < a:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n            return left\\n\\n        dict_rectangles = defaultdict(list)\\n        result = []\\n\\n        for x, y in rectangles:\\n            dict_rectangles[y].append(x)\\n\\n        for value in dict_rectangles.values():\\n            value.sort()\\n\\n        max_heigh = max(dict_rectangles.keys())\\n\\n        for a, b in points:\\n            counts = 0\\n            for i in range(b, max_heigh + 1):\\n                if dict_rectangles[i]:\\n                    counts += len(dict_rectangles[i]) - bs(dict_rectangles[i], a)\\n            result.append(counts)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614238,
                "title": "golang-using-binary-index-tree",
                "content": "```\\nconst N = 101\\nfunc countRectangles(rectangles [][]int, points [][]int) []int {\\n    bitArr := make([]int, N+1)\\n    res := make([]int, len(points))\\n    \\n    // Add index, since we are sorting\\n    for i := 0; i < len(points); i++ {\\n        points[i] = append(points[i], i)\\n    }\\n    \\n    // Sort by decreasing width\\n    sort.Slice(rectangles, func (i, j int) bool {\\n        return rectangles[i][0] > rectangles[j][0]\\n    })\\n    \\n    // Sort by decreasing width\\n    sort.Slice(points, func (i, j int) bool {\\n        return points[i][0] > points[j][0]\\n    })\\n    \\n    i, j := 0, 0\\n    for i < len(points) {\\n        // Add all rectangles which have more width then point[i]\\n        for j < len(rectangles) && rectangles[j][0] >= points[i][0] {\\n            add(bitArr, rectangles[j][1]) // Add heights to bitArr\\n            j++\\n        }\\n        \\n        // Get all prefixSum of heights less than points[i][1] and subtract from current rectangles count\\n        count := j - prefixSum(bitArr, points[i][1]-1)\\n        res[points[i][2]] = count\\n        i++\\n    }\\n    \\n    return res\\n}\\n\\nfunc add(bitArr []int, h int) {\\n    for i := h+1; i <= N; i += lsb(i) {\\n        bitArr[i]++\\n    }\\n}\\n\\nfunc prefixSum(bitArr []int, h int) int {\\n    sum := 0\\n    for i := h+1; i > 0; i -= lsb(i) {\\n        sum += bitArr[i]\\n    }\\n    return sum\\n}\\n\\nfunc lsb(n int) int {\\n    return n & (-n)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```\\nconst N = 101\\nfunc countRectangles(rectangles [][]int, points [][]int) []int {\\n    bitArr := make([]int, N+1)\\n    res := make([]int, len(points))\\n    \\n    // Add index, since we are sorting\\n    for i := 0; i < len(points); i++ {\\n        points[i] = append(points[i], i)\\n    }\\n    \\n    // Sort by decreasing width\\n    sort.Slice(rectangles, func (i, j int) bool {\\n        return rectangles[i][0] > rectangles[j][0]\\n    })\\n    \\n    // Sort by decreasing width\\n    sort.Slice(points, func (i, j int) bool {\\n        return points[i][0] > points[j][0]\\n    })\\n    \\n    i, j := 0, 0\\n    for i < len(points) {\\n        // Add all rectangles which have more width then point[i]\\n        for j < len(rectangles) && rectangles[j][0] >= points[i][0] {\\n            add(bitArr, rectangles[j][1]) // Add heights to bitArr\\n            j++\\n        }\\n        \\n        // Get all prefixSum of heights less than points[i][1] and subtract from current rectangles count\\n        count := j - prefixSum(bitArr, points[i][1]-1)\\n        res[points[i][2]] = count\\n        i++\\n    }\\n    \\n    return res\\n}\\n\\nfunc add(bitArr []int, h int) {\\n    for i := h+1; i <= N; i += lsb(i) {\\n        bitArr[i]++\\n    }\\n}\\n\\nfunc prefixSum(bitArr []int, h int) int {\\n    sum := 0\\n    for i := h+1; i > 0; i -= lsb(i) {\\n        sum += bitArr[i]\\n    }\\n    return sum\\n}\\n\\nfunc lsb(n int) int {\\n    return n & (-n)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2523767,
                "title": "easy-binary-search-c-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<int> ans;\\n        vector<vector<int>> dp(101);\\n        for(int i = 0 ; i < rectangles.size(); i++)\\n        {\\n            dp[rectangles[i][1]].push_back(rectangles[i][0]);\\n        }\\n        for(int i = 0 ; i < 101; i++)\\n        {\\n            sort(dp[i].begin(), dp[i].end());\\n        }\\n        for(int i = 0 ; i < points.size(); i++)\\n        {\\n            int count = 0;\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            for(int j = y; j < 101; j++)\\n            {\\n                int temp = lower_bound(dp[j].begin(), dp[j].end(), x) - dp[j].begin();\\n                count += dp[j].size() - temp;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<int> ans;\\n        vector<vector<int>> dp(101);\\n        for(int i = 0 ; i < rectangles.size(); i++)\\n        {\\n            dp[rectangles[i][1]].push_back(rectangles[i][0]);\\n        }\\n        for(int i = 0 ; i < 101; i++)\\n        {\\n            sort(dp[i].begin(), dp[i].end());\\n        }\\n        for(int i = 0 ; i < points.size(); i++)\\n        {\\n            int count = 0;\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            for(int j = y; j < 101; j++)\\n            {\\n                int temp = lower_bound(dp[j].begin(), dp[j].end(), x) - dp[j].begin();\\n                count += dp[j].size() - temp;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224553,
                "title": "c-easy-to-understand-sorting-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        \\n        int i, count, ind, x, y, n = rectangles.size();\\n        \\n        vector<int> ans;\\n        vector<vector<int>> heights(101);\\n        \\n        for(auto rect : rectangles)\\n            heights[rect[1]].push_back(rect[0]);\\n        \\n        for(i=0;i<101;i++)\\n            sort(heights[i].begin(), heights[i].end());\\n        \\n        for(auto point : points)\\n        {\\n            count = 0;\\n            x = point[0];\\n            y = point[1];\\n            for(i=y;i<101;i++)\\n            {\\n                ind = lower_bound(heights[i].begin(), heights[i].end(), x) - heights[i].begin();\\n                count += (heights[i].size() - ind);\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        \\n        int i, count, ind, x, y, n = rectangles.size();\\n        \\n        vector<int> ans;\\n        vector<vector<int>> heights(101);\\n        \\n        for(auto rect : rectangles)\\n            heights[rect[1]].push_back(rect[0]);\\n        \\n        for(i=0;i<101;i++)\\n            sort(heights[i].begin(), heights[i].end());\\n        \\n        for(auto point : points)\\n        {\\n            count = 0;\\n            x = point[0];\\n            y = point[1];\\n            for(i=y;i<101;i++)\\n            {\\n                ind = lower_bound(heights[i].begin(), heights[i].end(), x) - heights[i].begin();\\n                count += (heights[i].size() - ind);\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157119,
                "title": "c-complexity-analysis-split-rectangle-by-heights-then-binary-search",
                "content": "The first thing we must be aware of is the constraints given by the question. The constraints are stated as follows:\\n1 <= number of points <= 5 * 10^4, let this number of P\\n1 <= number of rectangle <= 5 * 10^4, let this number be R\\n1 <= height of rectangle <= 100, let this number be H\\n1 <= width of rectangle <= 10^9 , let this number be W\\n\\nI know it is bizarre to have non-uniformed constraints like this, and you will probably not encounter such a situation (or very rarely) during an actual interview, but this is the tricky part of the question.\\n\\nTo explain how the constraints affect the time complexity, we first have to understand how our algorithm works. Our goal is to count how many rectangles cover a certain point, so naturally, we need to find all rectangle that has both height and width greater or equal to the point\\'s x and y coordinate respectively.\\n\\nThe brute force solution is in fact to check each point against each rectangle, which gives us a time complexity of O(P * R) (roughly 2.5 * 10^9), which is not ideal. One thing to note from the above condition is that we only care about rectangles that are \"greater than\" the point, allowing us to optimize the algorithm with binary search.\\n\\nOne common strategy when dealing with any coordinates questions is to split a 2D graph into two 1D graphs (i.e. separate width and height). Combine with the above observation, we can split the rectangles into buckets labeled by their height (thus we have 100 buckets at most), then perform a binary search on each height bucket (that has a greater or equal height than our point) and see how many rectangles satisfy our condition. This gives us a time complexity of O(R + HlogW + P * HlogW) ~= O(R + P * HlogW) (roughly 5 * 10^5), which is an improvement compared to the brute force approach under the given condition.\\n\\nOne thing to note is that we cannot further optimize by performing two binary searches on height and width since width and height are mutually exclusive properties of the rectangle.\\n```\\nclass Solution {\\nprivate:\\n    int bSearchUpper(int tar, vector<int> &arr) {\\n        int l = 0, r = arr.size();\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (arr[m] >= tar) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return l;\\n    }\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<vector<int>> heightLookup(101, vector<int>()); // O(R) space\\n        \\n\\t\\t// O(R) time\\n        for (vector<int> &eachR : rectangles) {\\n            heightLookup[eachR[1]].push_back(eachR[0]);\\n        }\\n\\n\\t\\t// O(HlogW) time, where H and W are bounded by R\\n        for (vector<int> &eachH : heightLookup) {\\n            sort(eachH.begin(), eachH.end(), greater<int>());\\n        }\\n        \\n\\t\\t// O(P * HlogW) time, where H and W are bounded by R\\n        vector<int> res;\\n        for (vector<int> &eachP : points) {\\n            int cnt = 0;\\n            for (int i = 100; i >= eachP[1]; i--) {\\n                if (heightLookup[i].empty()) continue;\\n                cnt += bSearchUpper(eachP[0], heightLookup[i]);\\n            }\\n            res.push_back(cnt);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int bSearchUpper(int tar, vector<int> &arr) {\\n        int l = 0, r = arr.size();\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (arr[m] >= tar) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return l;\\n    }\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<vector<int>> heightLookup(101, vector<int>()); // O(R) space\\n        \\n\\t\\t// O(R) time\\n        for (vector<int> &eachR : rectangles) {\\n            heightLookup[eachR[1]].push_back(eachR[0]);\\n        }\\n\\n\\t\\t// O(HlogW) time, where H and W are bounded by R\\n        for (vector<int> &eachH : heightLookup) {\\n            sort(eachH.begin(), eachH.end(), greater<int>());\\n        }\\n        \\n\\t\\t// O(P * HlogW) time, where H and W are bounded by R\\n        vector<int> res;\\n        for (vector<int> &eachP : points) {\\n            int cnt = 0;\\n            for (int i = 100; i >= eachP[1]; i--) {\\n                if (heightLookup[i].empty()) continue;\\n                cnt += bSearchUpper(eachP[0], heightLookup[i]);\\n            }\\n            res.push_back(cnt);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043476,
                "title": "python3-bisect-left-hashmap-solution-for-reference",
                "content": "I think finding a generic algorithm to fit into the two parameter ( >=x and >= y ) search without looping is a hard problem. Based on hints, i guess this one requires the problem is reduced by considering the height limited to 100 to one dimension bineary search and another dimension by looping.\\n\\n```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        heights = defaultdict(list)\\n        \\n        # sort so that the x values in heights dict are sorted.\\n        rectangles.sort(key=lambda a: a[0])\\n  \\n        # organize information by heights.\\n        for x,y in rectangles:\\n            heights[y].append(x)\\n        \\n        o = [] \\n\\n        ## loop through all points and their Y values as their start into search. \\n        for x,y in points:\\n            ans = 0\\n            for dy in range(y, 101):\\n                if heights[dy]:\\n                    ans += len(heights[dy]) - bisect_left(heights[dy], x)\\n\\n            o.append(ans)\\n        return o\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "I think finding a generic algorithm to fit into the two parameter ( >=x and >= y ) search without looping is a hard problem. Based on hints, i guess this one requires the problem is reduced by considering the height limited to 100 to one dimension bineary search and another dimension by looping.\\n\\n```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        heights = defaultdict(list)\\n        \\n        # sort so that the x values in heights dict are sorted.\\n        rectangles.sort(key=lambda a: a[0])\\n  \\n        # organize information by heights.\\n        for x,y in rectangles:\\n            heights[y].append(x)\\n        \\n        o = [] \\n\\n        ## loop through all points and their Y values as their start into search. \\n        for x,y in points:\\n            ans = 0\\n            for dy in range(y, 101):\\n                if heights[dy]:\\n                    ans += len(heights[dy]) - bisect_left(heights[dy], x)\\n\\n            o.append(ans)\\n        return o\\n",
                "codeTag": "Java"
            },
            {
                "id": 2032094,
                "title": "c-easy-explanation-binary-search",
                "content": "**Steps:**\\n* For each `y` coordinate of the rectangle, store `x` coordinates in sorted order, using a map.\\n* For each point,\\n\\t1. Find all the `y` coordinates greater than or equal to the `y` coordinate of this point. This can be done using lower bound.\\n\\t1. Now, for each of these `y` coordinates, do a binary search on the corresponding `x` coordinates to find out how many of them are greater than the `x` coordinate of this point. \\n\\n\\n**Why can\\'t we store `y` coordinates in sorted order for each `x` coordinate?**\\nBecause we are iterating on the first variable (linear) and applying a binary search on the second variable (logarithmic) and as per the question, constraints on `x` are tighter, so it is better we apply binary search on `x` and not `y`.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        map<int, vector<int>>mp;\\n        sort(rectangles.begin(), rectangles.end());\\n        \\n        for(auto r:rectangles){\\n            mp[r[1]].push_back(r[0]);\\n        }\\n        vector<int>ans;\\n        for(auto p:points){\\n            int x=p[0];\\n            int y=p[1];\\n            \\n            auto it1=mp.lower_bound(y);\\n            int temp=0;\\n            while(it1 != mp.end()){\\n                auto it2=lower_bound(it1->second.begin(), it1->second.end(), x);\\n                temp+=(it1->second.end()-it2);\\n                it1++;\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        map<int, vector<int>>mp;\\n        sort(rectangles.begin(), rectangles.end());\\n        \\n        for(auto r:rectangles){\\n            mp[r[1]].push_back(r[0]);\\n        }\\n        vector<int>ans;\\n        for(auto p:points){\\n            int x=p[0];\\n            int y=p[1];\\n            \\n            auto it1=mp.lower_bound(y);\\n            int temp=0;\\n            while(it1 != mp.end()){\\n                auto it2=lower_bound(it1->second.begin(), it1->second.end(), x);\\n                temp+=(it1->second.end()-it2);\\n                it1++;\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002235,
                "title": "java-create-list-of-x-for-each-y-coordinate-and-binary-search-elegant-and-concise-solution",
                "content": "**46/47 Cases Passed**\\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Arrays.sort(rectangles, (a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\\n        \\n        int[] ans = new int[points.length];\\n        for(int i=0; i<points.length; i++){\\n            if(points[i][0] > rectangles[rectangles.length-1][0]) continue;\\n            // Find the smallest rectangle index with the x coordinate >= current point x coordinate\\n            int xIndex = findXIndex(rectangles, points[i][0]);\\n\\n            int count = 0;\\n            for(int j=xIndex; j<rectangles.length; j++){\\n                if(rectangles[j][1] >= points[i][1]) count++;\\n            }\\n            \\n            ans[i] = count;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int findXIndex(int[][] rectangles, int key){\\n        int l = 0;\\n        int h = rectangles.length-1;\\n        \\n        while(l < h){\\n            int m = l + (h-l)/2;\\n            if(rectangles[m][0] < key){\\n                l = m+1;\\n            }else h = m;\\n        }\\n        \\n        return l;\\n    }\\n}\\n```\\n\\n**Optimization by creating HashMap and store all the x for each y in the Map**\\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Arrays.sort(rectangles, (a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\\n      \\n        HashMap<Integer, List<Integer>>  yMap = new HashMap<>();\\n        for(int i=0; i<rectangles.length; i++){\\n            yMap.computeIfAbsent(rectangles[i][1], k -> new ArrayList<>()).add(rectangles[i][0]);\\n        }\\n        \\n        int[] ans = new int[points.length];\\n        for(int i=0; i<points.length; i++){\\n        if(points[i][0] > rectangles[rectangles.length-1][0]) continue;\\n            \\n            int count = 0;\\n            for(int j=points[i][1]; j<=100; j++){\\n                if(!yMap.containsKey(j)) continue;\\n                \\n                int xIndex = findXIndex(yMap.get(j), points[i][0]);\\n                if(xIndex == -1) continue;\\n                count += yMap.get(j).size() - xIndex;\\n            }\\n            \\n            ans[i] = count;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int findXIndex(List<Integer> li, int key){\\n        if(li.get(li.size()-1) < key) return -1;\\n\\n        int l = 0;\\n        int h = li.size() - 1;\\n\\n        while(l < h){\\n            int m = l + (h-l)/2;\\n            if(li.get(m) < key){\\n                l = m+1;\\n            }else h = m;\\n        }\\n        \\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Arrays.sort(rectangles, (a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\\n        \\n        int[] ans = new int[points.length];\\n        for(int i=0; i<points.length; i++){\\n            if(points[i][0] > rectangles[rectangles.length-1][0]) continue;\\n            // Find the smallest rectangle index with the x coordinate >= current point x coordinate\\n            int xIndex = findXIndex(rectangles, points[i][0]);\\n\\n            int count = 0;\\n            for(int j=xIndex; j<rectangles.length; j++){\\n                if(rectangles[j][1] >= points[i][1]) count++;\\n            }\\n            \\n            ans[i] = count;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int findXIndex(int[][] rectangles, int key){\\n        int l = 0;\\n        int h = rectangles.length-1;\\n        \\n        while(l < h){\\n            int m = l + (h-l)/2;\\n            if(rectangles[m][0] < key){\\n                l = m+1;\\n            }else h = m;\\n        }\\n        \\n        return l;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Arrays.sort(rectangles, (a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\\n      \\n        HashMap<Integer, List<Integer>>  yMap = new HashMap<>();\\n        for(int i=0; i<rectangles.length; i++){\\n            yMap.computeIfAbsent(rectangles[i][1], k -> new ArrayList<>()).add(rectangles[i][0]);\\n        }\\n        \\n        int[] ans = new int[points.length];\\n        for(int i=0; i<points.length; i++){\\n        if(points[i][0] > rectangles[rectangles.length-1][0]) continue;\\n            \\n            int count = 0;\\n            for(int j=points[i][1]; j<=100; j++){\\n                if(!yMap.containsKey(j)) continue;\\n                \\n                int xIndex = findXIndex(yMap.get(j), points[i][0]);\\n                if(xIndex == -1) continue;\\n                count += yMap.get(j).size() - xIndex;\\n            }\\n            \\n            ans[i] = count;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int findXIndex(List<Integer> li, int key){\\n        if(li.get(li.size()-1) < key) return -1;\\n\\n        int l = 0;\\n        int h = li.size() - 1;\\n\\n        while(l < h){\\n            int m = l + (h-l)/2;\\n            if(li.get(m) < key){\\n                l = m+1;\\n            }else h = m;\\n        }\\n        \\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990959,
                "title": "generalise-merge-sort-tree-implementation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //Generalize Merge Sort Tree Implementation\\n    vector<pair<int, int> > vv[1000000];\\n    void build(vector<pair<int,int> > &v, int st, int en, int ind){\\n        if(st==en){\\n            vector<pair<int,int> > pp;\\n            pp.push_back(make_pair(v[st].second, v[st].first));\\n            vv[ind] = pp;\\n            return;\\n        }\\n        int mid = (st+en)/2;\\n        build(v, st, mid, 2*ind);\\n        build(v, mid+1, en, 2*ind+1);\\n        vv[ind].resize(en-st+1);\\n        merge(vv[2*ind].begin(), vv[2*ind].end(), vv[2*ind+1].begin(), vv[2*ind+1].end(), vv[ind].begin());\\n    }\\n    \\n    int f(int st, int en, int l1, int r1, int ind, int val){\\n        if(st>r1||en<l1){\\n            return 0;\\n        }\\n        if(st>=l1&&en<=r1){\\n            int in = lower_bound(vv[ind].begin(), vv[ind].end(), make_pair(val, 0)) - vv[ind].begin();\\n            return vv[ind].size()-in;\\n        }\\n        int mid = (st+en)/2;\\n        return f(st, mid, l1, r1, 2*ind, val) + f(mid+1, en, l1, r1, 2*ind+1, val);\\n    }\\n    vector<int> countRectangles(vector<vector<int>>& r, vector<vector<int>>& p) {\\n        set<int> ss;\\n        for(int i=0;i<r.size();++i){\\n            ss.insert(r[i][0]);\\n            ss.insert(r[i][1]);\\n        }\\n        for(int i=0;i<p.size();++i){\\n            ss.insert(p[i][0]);\\n            ss.insert(p[i][1]);\\n        }\\n        map<int,int> mp;\\n        int j=1;\\n        for(auto x: ss){\\n            mp[x]=j++;\\n        }\\n        vector<pair<int,int> > v;\\n        for(int i=0;i<r.size();++i){\\n            int l1 = mp[r[i][0]];\\n            int l2 = mp[r[i][1]];\\n            v.push_back(make_pair(l1,l2));\\n        }\\n        sort(v.begin(),v.end());\\n        build(v, 0, v.size()-1, 1);\\n        vector<int> res;\\n        for(int i=0;i<p.size();++i){\\n            int l1 = mp[p[i][0]];\\n            int l2 = mp[p[i][1]];\\n            int ind = lower_bound(v.begin(),v.end(), make_pair(l1, 0)) - v.begin();\\n            if(ind == v.size()) {\\n                res.push_back(0);\\n                continue;\\n            }\\n            res.push_back(f(0, v.size()-1, ind, v.size()-1, 1, l2));\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Merge Sort",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //Generalize Merge Sort Tree Implementation\\n    vector<pair<int, int> > vv[1000000];\\n    void build(vector<pair<int,int> > &v, int st, int en, int ind){\\n        if(st==en){\\n            vector<pair<int,int> > pp;\\n            pp.push_back(make_pair(v[st].second, v[st].first));\\n            vv[ind] = pp;\\n            return;\\n        }\\n        int mid = (st+en)/2;\\n        build(v, st, mid, 2*ind);\\n        build(v, mid+1, en, 2*ind+1);\\n        vv[ind].resize(en-st+1);\\n        merge(vv[2*ind].begin(), vv[2*ind].end(), vv[2*ind+1].begin(), vv[2*ind+1].end(), vv[ind].begin());\\n    }\\n    \\n    int f(int st, int en, int l1, int r1, int ind, int val){\\n        if(st>r1||en<l1){\\n            return 0;\\n        }\\n        if(st>=l1&&en<=r1){\\n            int in = lower_bound(vv[ind].begin(), vv[ind].end(), make_pair(val, 0)) - vv[ind].begin();\\n            return vv[ind].size()-in;\\n        }\\n        int mid = (st+en)/2;\\n        return f(st, mid, l1, r1, 2*ind, val) + f(mid+1, en, l1, r1, 2*ind+1, val);\\n    }\\n    vector<int> countRectangles(vector<vector<int>>& r, vector<vector<int>>& p) {\\n        set<int> ss;\\n        for(int i=0;i<r.size();++i){\\n            ss.insert(r[i][0]);\\n            ss.insert(r[i][1]);\\n        }\\n        for(int i=0;i<p.size();++i){\\n            ss.insert(p[i][0]);\\n            ss.insert(p[i][1]);\\n        }\\n        map<int,int> mp;\\n        int j=1;\\n        for(auto x: ss){\\n            mp[x]=j++;\\n        }\\n        vector<pair<int,int> > v;\\n        for(int i=0;i<r.size();++i){\\n            int l1 = mp[r[i][0]];\\n            int l2 = mp[r[i][1]];\\n            v.push_back(make_pair(l1,l2));\\n        }\\n        sort(v.begin(),v.end());\\n        build(v, 0, v.size()-1, 1);\\n        vector<int> res;\\n        for(int i=0;i<p.size();++i){\\n            int l1 = mp[p[i][0]];\\n            int l2 = mp[p[i][1]];\\n            int ind = lower_bound(v.begin(),v.end(), make_pair(l1, 0)) - v.begin();\\n            if(ind == v.size()) {\\n                res.push_back(0);\\n                continue;\\n            }\\n            res.push_back(f(0, v.size()-1, ind, v.size()-1, 1, l2));\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983013,
                "title": "c-binary-search-simple-easy-to-understand",
                "content": "```\\nvector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) \\n    {\\n        vector<vector<int>> umap(101);\\n        for(int i=0;i<rectangles.size();i++)\\n        {\\n            umap[rectangles[i][1]].push_back(rectangles[i][0]);\\n        }\\n    \\n        for (int i = 0; i < 101; i++) \\n        {\\n            sort(begin(umap[i]),end(umap[i]));\\n        }\\n        \\n        vector<int> ans;\\n        for (auto &p: points) \\n        {\\n            int cnt = 0;\\n            for (int i = p[1]; i < 101; i++)\\n            {\\n                auto lb = lower_bound(begin(umap[i]), end(umap[i]), p[0]);\\n                cnt += end(umap[i]) - lb;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nvector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) \\n    {\\n        vector<vector<int>> umap(101);\\n        for(int i=0;i<rectangles.size();i++)\\n        {\\n            umap[rectangles[i][1]].push_back(rectangles[i][0]);\\n        }\\n    \\n        for (int i = 0; i < 101; i++) \\n        {\\n            sort(begin(umap[i]),end(umap[i]));\\n        }\\n        \\n        vector<int> ans;\\n        for (auto &p: points) \\n        {\\n            int cnt = 0;\\n            for (int i = p[1]; i < 101; i++)\\n            {\\n                auto lb = lower_bound(begin(umap[i]), end(umap[i]), p[0]);\\n                cnt += end(umap[i]) - lb;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1982475,
                "title": "short-solution-9-lines-with-explanation-c-linq",
                "content": "There is a constrain `1 <= hi, yj <= 100`. This means we can create an array of 100 hights. Each array item contains a list of rectangles with hight more or equal to the item index.\\n\\nThe list with index 1 (`hights[1]`) contains all rectangles sorted by their length. Every next hight contains a list of rectangles filtered from the previous list (so, it\\'s sorted as well).\\n\\nThe number of rectangles that contain a point `[x, y]` equals the **count** of rectangles in `hights[y]` **minus** the **count** of rectangles with length less than `x`. Since all rectangles are sorted by length the second parameter equals to the **index** of the first rectangle with `length >= x`.\\n```\\npublic int[] CountRectangles(int[][] rectangles, int[][] points) {\\n\\tvar hights = new List<int[]>[101];\\n\\thights[1] = rectangles.OrderBy(rect => rect[0]).ToList(); // Rectangles are sorted by length\\n\\tfor (int i = 2; i <= 100; i++)\\n\\t\\thights[i] = hights[i - 1].Where(rect => rect[1] >= i).ToList(); // Every next list is filtered from the previos list\\n\\n\\tvar result = new int[points.Length];\\n\\tfor (int i = 0; i < points.Length; i++) {\\n\\t\\tvar index = hights[points[i][1]].FindIndex(rect => rect[0] >= points[i][0]);\\n\\t\\tresult[i] = index == -1 ? 0 : hights[points[i][1]].Count - index; // index == -1 when the point is out of all rectangles\\n\\t}\\n\\n\\treturn result;\\n}\\n```\\n\\uD83D\\uDC4D\\uD83C\\uDFFB Upvote if it helped you or you learnt something new.",
                "solutionTags": [],
                "code": "```\\npublic int[] CountRectangles(int[][] rectangles, int[][] points) {\\n\\tvar hights = new List<int[]>[101];\\n\\thights[1] = rectangles.OrderBy(rect => rect[0]).ToList(); // Rectangles are sorted by length\\n\\tfor (int i = 2; i <= 100; i++)\\n\\t\\thights[i] = hights[i - 1].Where(rect => rect[1] >= i).ToList(); // Every next list is filtered from the previos list\\n\\n\\tvar result = new int[points.Length];\\n\\tfor (int i = 0; i < points.Length; i++) {\\n\\t\\tvar index = hights[points[i][1]].FindIndex(rect => rect[0] >= points[i][0]);\\n\\t\\tresult[i] = index == -1 ? 0 : hights[points[i][1]].Count - index; // index == -1 when the point is out of all rectangles\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1981340,
                "title": "complete-explaination-using-bst-set-c",
                "content": "### Observation:\\n- The heights of the rectangles and the y-coordinates of the points are only at most 100, so for each point, we can iterate over the possible heights of the rectangles that contain a given point.\\n- For a given point and height, can we efficiently count how many rectangles with that height contain our point?\\nSo, for this we have used here **set (BST implemtation).**\\n\\nTime complexity: **O(100*mlogn)**, here n is number of rectangles and m is number of point query.\\nTo be more precise: **O(n+100+mlogn*100)**\\n\\n### Solution Code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        int n = rectangles.size(), m = points.size();\\n        vector<int> vec[101];\\n        \\n\\t\\t//below loop takes O(n)\\n        for (auto rectangle: rectangles) {\\n            int length = rectangle[0], height = rectangle[1];\\n            vec[height].push_back(length);\\n        }\\n        \\n\\t\\t//below loop takes O(100)\\n        for (int i=0; i<101; i++)\\n            sort(vec[i].begin(), vec[i].end());\\n        \\n        vector<int> ans;\\n\\t\\t\\n\\t\\t//below code inside the for loop takes: O(m*100*logn)\\n        for (auto point: points) {\\n            int x = point[0], y = point[1];\\n            int k = 0;\\n            for (int i=y; i<101; i++)\\n                k += (vec[i].end() - lower_bound(vec[i].begin(), vec[i].end(), x)); //to be clear, this line takes O(logn) time complexity\\n            \\n            ans.push_back(k);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        int n = rectangles.size(), m = points.size();\\n        vector<int> vec[101];\\n        \\n\\t\\t//below loop takes O(n)\\n        for (auto rectangle: rectangles) {\\n            int length = rectangle[0], height = rectangle[1];\\n            vec[height].push_back(length);\\n        }\\n        \\n\\t\\t//below loop takes O(100)\\n        for (int i=0; i<101; i++)\\n            sort(vec[i].begin(), vec[i].end());\\n        \\n        vector<int> ans;\\n\\t\\t\\n\\t\\t//below code inside the for loop takes: O(m*100*logn)\\n        for (auto point: points) {\\n            int x = point[0], y = point[1];\\n            int k = 0;\\n            for (int i=y; i<101; i++)\\n                k += (vec[i].end() - lower_bound(vec[i].begin(), vec[i].end(), x)); //to be clear, this line takes O(logn) time complexity\\n            \\n            ans.push_back(k);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980362,
                "title": "java-easy-to-understand-solution-w-binary-search",
                "content": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int[] ans = new int[points.length];\\n        Map<Integer, List<Integer>> rectangleMap = new HashMap<>();\\n        \\n        for (int[] rectangle : rectangles) {\\n            if (!rectangleMap.containsKey(rectangle[1])) {\\n                rectangleMap.put(rectangle[1], new ArrayList<>());\\n            }\\n            rectangleMap.get(rectangle[1]).add(rectangle[0]);\\n        }\\n        \\n        for (int n : rectangleMap.keySet()) {\\n            Collections.sort(rectangleMap.get(n));\\n        }\\n        \\n        for (int k = 0; k < points.length; k++) {\\n            int count = 0;\\n            for (int n : rectangleMap.keySet()) {\\n                if (n < points[k][1]) {\\n                    continue;\\n                }\\n                List<Integer> x = rectangleMap.get(n);\\n                int i = 0, j = x.size() - 1;\\n                while (i < j) {\\n                    int mid = i + (j - i) / 2;\\n                    if (x.get(mid) <  points[k][0]) {\\n                        i = mid + 1;\\n                    } else {\\n                        j = mid;\\n                    }\\n                }\\n                if (x.get(i) < points[k][0]) {\\n                    i++;\\n                }\\n                count += x.size() - i;\\n            }\\n            ans[k] = count;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int[] ans = new int[points.length];\\n        Map<Integer, List<Integer>> rectangleMap = new HashMap<>();\\n        \\n        for (int[] rectangle : rectangles) {\\n            if (!rectangleMap.containsKey(rectangle[1])) {\\n                rectangleMap.put(rectangle[1], new ArrayList<>());\\n            }\\n            rectangleMap.get(rectangle[1]).add(rectangle[0]);\\n        }\\n        \\n        for (int n : rectangleMap.keySet()) {\\n            Collections.sort(rectangleMap.get(n));\\n        }\\n        \\n        for (int k = 0; k < points.length; k++) {\\n            int count = 0;\\n            for (int n : rectangleMap.keySet()) {\\n                if (n < points[k][1]) {\\n                    continue;\\n                }\\n                List<Integer> x = rectangleMap.get(n);\\n                int i = 0, j = x.size() - 1;\\n                while (i < j) {\\n                    int mid = i + (j - i) / 2;\\n                    if (x.get(mid) <  points[k][0]) {\\n                        i = mid + 1;\\n                    } else {\\n                        j = mid;\\n                    }\\n                }\\n                if (x.get(i) < points[k][0]) {\\n                    i++;\\n                }\\n                count += x.size() - i;\\n            }\\n            ans[k] = count;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980089,
                "title": "rust-solution",
                "content": "```rust\\npub fn _count_rectangles(rectangles: Vec<Vec<i32>>, points: Vec<Vec<i32>>) -> Vec<i32> {\\n    let mut group: Vec<Vec<i32>> = vec![Vec::new(); 101];\\n    rectangles\\n        .iter()\\n        .for_each(|x| group[x[1] as usize].push(x[0]));\\n    group.iter_mut().for_each(|x| x.sort_unstable());\\n\\n    points\\n        .iter()\\n        .map(|i| {\\n            group\\n                .iter()\\n                .skip(i[1] as usize)\\n                .map(|l| match l.binary_search(&i[0]) {\\n                    Ok(index) => (l.len() - index) as i32,\\n                    Err(index) => (l.len() - index) as i32,\\n                })\\n                .sum::<i32>()\\n        })\\n        .collect()\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```rust\\npub fn _count_rectangles(rectangles: Vec<Vec<i32>>, points: Vec<Vec<i32>>) -> Vec<i32> {\\n    let mut group: Vec<Vec<i32>> = vec![Vec::new(); 101];\\n    rectangles\\n        .iter()\\n        .for_each(|x| group[x[1] as usize].push(x[0]));\\n    group.iter_mut().for_each(|x| x.sort_unstable());\\n\\n    points\\n        .iter()\\n        .map(|i| {\\n            group\\n                .iter()\\n                .skip(i[1] as usize)\\n                .map(|l| match l.binary_search(&i[0]) {\\n                    Ok(index) => (l.len() - index) as i32,\\n                    Err(index) => (l.len() - index) as i32,\\n                })\\n                .sum::<i32>()\\n        })\\n        .collect()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1979622,
                "title": "javascript-detailed-explanation-binary-search-on-the-width",
                "content": "I **wasn\\'t able** to solve the problem during the contest because I **missed a very important constrain**: \\n\\n`1 <= hi, yj <= 100`\\n\\nThis constraint would change how you think about this problem. \\n\\n\\nBecause we can have **buckets of width** by **height** ( not sure if it is the correct way to call it ) \\nPlease be noted that **all rectangles start at (0, 0)**, so we only need to care about length and height of the rectangle\\n\\n```\\nretangle with ( l, h ) will be store at bucket[h] = [ ..., l ]\\n```\\n\\nExample 1: \\n\\t[[1,2],[2,3],[2,5]]\\n\\nRectangle [1, 2]  would be store on bucket[2] = [1]\\nRectangle [2, 3]  would be store on bucket[3] = [2]\\nRectangle [2, 5]  would be store on bucket[5] = [2]\\n\\n```\\nWe don\\'t need to check all the rectangle by width as if the smaller rectangle contain the point then the bigger  will surely contain the point\\n```\\n\\nFrom this point, we can think of how to count number of rectangle contain each point by width. We need to find the index of width which is **greater than or equal** with x on the point => **Binary search** on width can help\\n\\n\\n\\n```\\nconst binarySearch = (arr, target) => {\\n    let l = 0, r = arr.length - 1\\n    \\n    while (l <= r) {\\n        const mid = l + Math.floor((r - l) / 2)\\n        \\n        if (arr[mid] === target) {\\n            return mid\\n        } else if (arr[mid] < target) {\\n            l = mid + 1\\n        } else {\\n            r = mid - 1\\n        }\\n    }\\n    \\n    return l\\n}\\n\\n/**\\n * @param {number[][]} rectangles\\n * @param {number[][]} points\\n * @return {number[]}\\n */\\nconst countRectangles = (rectangles, points) => {\\n    let bucket = new Array(101).fill().map(_ => new Array())\\n    \\n    for (let [l, h] of rectangles) {\\n        bucket[h].push(l)\\n    }\\n    \\n    for (let i = 1; i < 101; i++) {\\n        bucket[i] = bucket[i].sort((l1, l2) => l1 - l2)\\n    }\\n    \\n    let numberOfRectangles = []\\n    \\n    for (let [x, y] of points) {\\n        let cur = 0\\n        for (let i = y; i <= 100; i++) {\\n            if (!bucket[i].length) continue\\n            const foundIndex = binarySearch(bucket[i], x)\\n            cur += bucket[i].length - foundIndex\\n        }\\n        numberOfRectangles.push(cur)\\n    }\\n\\n    \\n    return numberOfRectangles\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nretangle with ( l, h ) will be store at bucket[h] = [ ..., l ]\\n```\n```\\nWe don\\'t need to check all the rectangle by width as if the smaller rectangle contain the point then the bigger  will surely contain the point\\n```\n```\\nconst binarySearch = (arr, target) => {\\n    let l = 0, r = arr.length - 1\\n    \\n    while (l <= r) {\\n        const mid = l + Math.floor((r - l) / 2)\\n        \\n        if (arr[mid] === target) {\\n            return mid\\n        } else if (arr[mid] < target) {\\n            l = mid + 1\\n        } else {\\n            r = mid - 1\\n        }\\n    }\\n    \\n    return l\\n}\\n\\n/**\\n * @param {number[][]} rectangles\\n * @param {number[][]} points\\n * @return {number[]}\\n */\\nconst countRectangles = (rectangles, points) => {\\n    let bucket = new Array(101).fill().map(_ => new Array())\\n    \\n    for (let [l, h] of rectangles) {\\n        bucket[h].push(l)\\n    }\\n    \\n    for (let i = 1; i < 101; i++) {\\n        bucket[i] = bucket[i].sort((l1, l2) => l1 - l2)\\n    }\\n    \\n    let numberOfRectangles = []\\n    \\n    for (let [x, y] of points) {\\n        let cur = 0\\n        for (let i = y; i <= 100; i++) {\\n            if (!bucket[i].length) continue\\n            const foundIndex = binarySearch(bucket[i], x)\\n            cur += bucket[i].length - foundIndex\\n        }\\n        numberOfRectangles.push(cur)\\n    }\\n\\n    \\n    return numberOfRectangles\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977910,
                "title": "very-easy-cakewalk-binary-search",
                "content": "First of all i could not even read the problem in contest because i got too invested in problem B. That i couldn\\'t solve in contest either. This one is easier than B actually.\\n\\n\\nFirst we see that height only varies from 1 to 100. So, we make a 2D vector (1 to 100) and store all lengths associated with that particular height.\\nThen sort all that for applying binary serach.\\n\\nThen we iterate for all given points given. Again y is from 1 to 100. So, we iterate from that particular y to 100.\\n\\nIn the meantime for every height between y to 100, we apply lower_bound( A function of binary search) to know \\nhow many x\\'s are there in that height that can provide us answer.\\n\\nTime complexity is (10^4 * 10^2 * (log(size of that height vector) ~ 100)) - That is good enough.\\n```\\n#define ll long long\\n#define pi (3.141592653589)\\n#define mod 1000000007\\n#define float double\\n#define pb push_back\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) c.begin(), c.end()\\n#define min3(a, b, c) min(c, min(a, b))\\n#define min4(a, b, c, d) min(d, min(c, min(a, b)))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        \\n        \\n        vector<vector<ll>> hehe(101);\\n            \\n        rep(i, rectangles.size()){\\n            \\n            hehe[rectangles[i][1]].pb(rectangles[i][0]);\\n        }\\n        \\n         rep(i, 101){\\n            \\n           sort(all(hehe[i]));\\n        }\\n        \\n        vector<int> ans;\\n        \\n        rep(i, points.size()){\\n                ll x=0;\\n            for(int j=points[i][1]; j<=100;j++){\\n                \\n                auto it= lower_bound(all(hehe[j]), points[i][0]   );\\n                    \\n                if(it== hehe[j].end()) continue;\\n                else{\\n                    x+=(hehe[j].size() - (it- hehe[j].begin()));\\n                }\\n            }\\n            ans.pb(x);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        \\n        \\n        vector<vector<ll>> hehe(101);\\n            \\n        rep(i, rectangles.size()){\\n            \\n            hehe[rectangles[i][1]].pb(rectangles[i][0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1977809,
                "title": "golang-binary-search-beats-100",
                "content": "```\\nfunc countRectangles(rectangles [][]int, points [][]int) []int {\\n    // height <= 100\\n    // length <= 10^9\\n    // store height in key and lenght in array\\n    heightsMap := make(map[int][]int)\\n    for _, rectangle := range rectangles {\\n        heightsMap[rectangle[1]] = append(heightsMap[rectangle[1]], rectangle[0])\\n    }\\n    \\n    // int array will have unique value\\n    for _, value := range heightsMap {\\n        sort.Ints(value)\\n    }\\n    \\n    p := len(points)\\n    ans := make([]int, p)\\n    for idx, point := range points {\\n        cnt := 0\\n        for i := point[1]; i <= 100; i++ {\\n            cnt += upperbound(heightsMap[i], point[0])\\n        }\\n        ans[idx] = cnt\\n    }\\n    return ans\\n}\\n\\n// binary search\\nfunc upperbound(arr []int, target int) int {\\n    n := len(arr)\\n    if n == 0 {\\n        return 0\\n    }\\n    left := 0 \\n    right := n-1\\n    ans := -1\\n    for left <= right {\\n        mid := left + (right-left)/2\\n        if arr[mid] == target {\\n            ans = mid\\n            break\\n        } else if arr[mid] > target {\\n            ans = mid\\n            right = mid-1\\n        } else {\\n            left = mid+1\\n        }\\n    }\\n    if ans == -1 {\\n        return 0\\n    }\\n    return len(arr)-ans\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nfunc countRectangles(rectangles [][]int, points [][]int) []int {\\n    // height <= 100\\n    // length <= 10^9\\n    // store height in key and lenght in array\\n    heightsMap := make(map[int][]int)\\n    for _, rectangle := range rectangles {\\n        heightsMap[rectangle[1]] = append(heightsMap[rectangle[1]], rectangle[0])\\n    }\\n    \\n    // int array will have unique value\\n    for _, value := range heightsMap {\\n        sort.Ints(value)\\n    }\\n    \\n    p := len(points)\\n    ans := make([]int, p)\\n    for idx, point := range points {\\n        cnt := 0\\n        for i := point[1]; i <= 100; i++ {\\n            cnt += upperbound(heightsMap[i], point[0])\\n        }\\n        ans[idx] = cnt\\n    }\\n    return ans\\n}\\n\\n// binary search\\nfunc upperbound(arr []int, target int) int {\\n    n := len(arr)\\n    if n == 0 {\\n        return 0\\n    }\\n    left := 0 \\n    right := n-1\\n    ans := -1\\n    for left <= right {\\n        mid := left + (right-left)/2\\n        if arr[mid] == target {\\n            ans = mid\\n            break\\n        } else if arr[mid] > target {\\n            ans = mid\\n            right = mid-1\\n        } else {\\n            left = mid+1\\n        }\\n    }\\n    if ans == -1 {\\n        return 0\\n    }\\n    return len(arr)-ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977744,
                "title": "detailed-and-clear-c-solution-binary-search-frequency-counting",
                "content": "This problem is basically:\\nGiven a point (x,y), find the number of points `p` in `rectangles` such that `p.x >= x` and `p.y >= y`\\nWe can first sort the points in `rectangles` by one dimension, and then query the other dimension.\\nThe rough idea is as follows:\\n1. sort the points in `rectangles` by x\\n2. for each point `(x,y)` in `points`, use binary search to find all points `p` in  `rectangles` such that `p.x >= x`\\n3. from these points, use some data structure `ContainerType` to find all points `p` such that `p.y >= y`\\n\\nThe pseudocode is therefore\\n``` cpp\\nstruct ContainerType\\n{\\n    ContainerType();\\n    // add one number\\n    void add(int i);\\n    // add numbers from another container\\n    void merge(ContainerType const& other);\\n    // query how many elements in the container are >= i\\n    int query(int i);\\n};\\n// sort and group elements by x\\nmap<int, ContainerType> mp;\\nfor(auto& v : rectangles)\\n    mp[v[0]].add(v[1]);\\n\\t\\n// iterate backwards and accumulate elements\\n// mp[i] will go from all y\\'s with x = i\\n// to all y\\'s with x >= i\\nfor(auto it = prev(mp.end()); it != mp.end(); )\\n{\\n    if(it != prev(mp.end()))\\n        it->second.merge(next(it)->second);\\n    if(it == mp.begin())\\n        it = mp.end();\\n    else\\n        --it;\\n}\\n\\nfor(int i=0; i<m; ++i)\\n{\\n    int x = points[i][0],\\n        y = points[i][1];\\n    auto it = mp.lower_bound(x);\\n    if(it != mp.end())\\n        ret[i] = it->second.query(y);\\n}\\n```\\n\\nThe two main operations that need to be supported by `ContainerType` are\\ninsertion and query\\nWith very large number range, the ideal candidates are segment tree (or fenwick tree) and order-statistic tree\\nBut here all y coordinates only range from 0 to 100, so we just use a frequency array to implement `ContainerType`\\n\\n``` cpp\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        int n = rectangles.size(),\\n        \\tm = points.size();\\n        vector<int> ret(m);\\n\\n        struct ContainerType\\n        {\\n            int cnts[101];\\n            ContainerType() { memset(cnts,0,sizeof(cnts)); }\\n            void add(int i) { ++ cnts[i]; }\\n            void merge(ContainerType const& other) \\n            {\\n                for(int i=0; i<=100; ++i)\\n                    cnts[i] += other.cnts[i];\\n            }\\n            int query(int i)\\n            {\\n                int ret = 0;\\n                for(int j=i; j<=100; ++j)\\n                    ret += cnts[j];\\n                return ret;\\n            }\\n        };\\n\\n        map<int, ContainerType> mp;\\n        for(auto& v : rectangles)\\n            mp[v[0]].add(v[1]);\\n        \\n    \\tauto sit = prev(mp.end());\\n        for(auto it = sit; it != mp.end(); )\\n        {\\n        \\tif(it != sit)\\n                it->second.merge(next(it)->second);\\n        \\tif(it == mp.begin())\\n    \\t\\t\\tit = mp.end();\\n    \\t\\telse\\n    \\t\\t\\t--it;\\n        }\\n\\n        for(int i=0; i<m; ++i)\\n        {\\n        \\tint x = points[i][0],\\n        \\t\\ty = points[i][1];\\n        \\tauto it = mp.lower_bound(x);\\n        \\tif(it != mp.end())\\n                ret[i] = it->second.query(y);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "``` cpp\\nstruct ContainerType\\n{\\n    ContainerType();\\n    // add one number\\n    void add(int i);\\n    // add numbers from another container\\n    void merge(ContainerType const& other);\\n    // query how many elements in the container are >= i\\n    int query(int i);\\n};\\n// sort and group elements by x\\nmap<int, ContainerType> mp;\\nfor(auto& v : rectangles)\\n    mp[v[0]].add(v[1]);\\n\\t\\n// iterate backwards and accumulate elements\\n// mp[i] will go from all y\\'s with x = i\\n// to all y\\'s with x >= i\\nfor(auto it = prev(mp.end()); it != mp.end(); )\\n{\\n    if(it != prev(mp.end()))\\n        it->second.merge(next(it)->second);\\n    if(it == mp.begin())\\n        it = mp.end();\\n    else\\n        --it;\\n}\\n\\nfor(int i=0; i<m; ++i)\\n{\\n    int x = points[i][0],\\n        y = points[i][1];\\n    auto it = mp.lower_bound(x);\\n    if(it != mp.end())\\n        ret[i] = it->second.query(y);\\n}\\n```\n``` cpp\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        int n = rectangles.size(),\\n        \\tm = points.size();\\n        vector<int> ret(m);\\n\\n        struct ContainerType\\n        {\\n            int cnts[101];\\n            ContainerType() { memset(cnts,0,sizeof(cnts)); }\\n            void add(int i) { ++ cnts[i]; }\\n            void merge(ContainerType const& other) \\n            {\\n                for(int i=0; i<=100; ++i)\\n                    cnts[i] += other.cnts[i];\\n            }\\n            int query(int i)\\n            {\\n                int ret = 0;\\n                for(int j=i; j<=100; ++j)\\n                    ret += cnts[j];\\n                return ret;\\n            }\\n        };\\n\\n        map<int, ContainerType> mp;\\n        for(auto& v : rectangles)\\n            mp[v[0]].add(v[1]);\\n        \\n    \\tauto sit = prev(mp.end());\\n        for(auto it = sit; it != mp.end(); )\\n        {\\n        \\tif(it != sit)\\n                it->second.merge(next(it)->second);\\n        \\tif(it == mp.begin())\\n    \\t\\t\\tit = mp.end();\\n    \\t\\telse\\n    \\t\\t\\t--it;\\n        }\\n\\n        for(int i=0; i<m; ++i)\\n        {\\n        \\tint x = points[i][0],\\n        \\t\\ty = points[i][1];\\n        \\tauto it = mp.lower_bound(x);\\n        \\tif(it != mp.end())\\n                ret[i] = it->second.query(y);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977634,
                "title": "javascript-binary-search-buckets",
                "content": "```\\n/**\\n * @param {number[][]} rectangles\\n * @param {number[][]} points\\n * @return {number[]}\\n */\\nvar countRectangles = function(rectangles, points) {\\n    \\n    let result = []\\n    let dp = new Array(101) // h >= 1 and h <= 100\\n    for(let h = 0; h<=100; h++) {\\n        dp[h] = []\\n    }\\n    //pre calculate\\n    for(let rect of rectangles) {\\n        let l = rect[0]\\n        let h = rect[1]\\n        dp[h].push(l) //stores lengths with height h\\n    }\\n    //console.log(dp)\\n    //sort all lengths\\n    for(let h = 0;  h<=100; h++) {\\n        dp[h].sort(function(a,b) {\\n            return a - b\\n        })\\n    }\\n    \\n    //find floor value of len <= target\\n    let find = function(arr, target) {\\n        let start = 0, end = arr.length-1, ans = 0\\n        while(start <= end ){\\n            let mid = parseInt((start+end)/2)\\n            if(target <= arr[mid]) {\\n                ans = (arr.length - mid)\\n                end = mid - 1\\n            } else {\\n                start = mid + 1\\n            }\\n        }\\n        return ans\\n    }\\n    \\n    for(let point of points) {\\n        let x = point[0]\\n        let y = point[1]\\n        let ans = 0\\n        //search all heights greater than equal to y\\n        for(let h = y; h <= 100; h++) {\\n            ans = ans + find(dp[h],x) // if height is there and lengths are present, then return lengths >= x\\n        }\\n        result.push(ans)\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} rectangles\\n * @param {number[][]} points\\n * @return {number[]}\\n */\\nvar countRectangles = function(rectangles, points) {\\n    \\n    let result = []\\n    let dp = new Array(101) // h >= 1 and h <= 100\\n    for(let h = 0; h<=100; h++) {\\n        dp[h] = []\\n    }\\n    //pre calculate\\n    for(let rect of rectangles) {\\n        let l = rect[0]\\n        let h = rect[1]\\n        dp[h].push(l) //stores lengths with height h\\n    }\\n    //console.log(dp)\\n    //sort all lengths\\n    for(let h = 0;  h<=100; h++) {\\n        dp[h].sort(function(a,b) {\\n            return a - b\\n        })\\n    }\\n    \\n    //find floor value of len <= target\\n    let find = function(arr, target) {\\n        let start = 0, end = arr.length-1, ans = 0\\n        while(start <= end ){\\n            let mid = parseInt((start+end)/2)\\n            if(target <= arr[mid]) {\\n                ans = (arr.length - mid)\\n                end = mid - 1\\n            } else {\\n                start = mid + 1\\n            }\\n        }\\n        return ans\\n    }\\n    \\n    for(let point of points) {\\n        let x = point[0]\\n        let y = point[1]\\n        let ans = 0\\n        //search all heights greater than equal to y\\n        for(let h = y; h <= 100; h++) {\\n            ans = ans + find(dp[h],x) // if height is there and lengths are present, then return lengths >= x\\n        }\\n        result.push(ans)\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977363,
                "title": "java-o-n-log-n-solution-binary-search-with-detail-explanation",
                "content": "As the constrain `1 <= hi <= 100` of the problem, we can store rectangles by a map from height to sorted widths.\\n```\\nheight = 1 -> sorted widths of rectangles that have height = 1\\nheight = 2 -> sorted widths of rectangles that have height = 2\\n...\\nheight = 100 -> sorted widths of rectangles that have height = 100\\n```\\n\\nFor each point `(x, y)`, a rectangle `r` is counted if and only if `x <= r[0] && y <= r[1]`. Therefore, we just need to consider rectangles that have `height >= y`. We will handle each height from `y` to `100` independently. \\n```\\nheight = h -> sorted widths of of rectangles that have height = h (y <= h <= 100)\\n```\\nWe will count number of elements in `sortedWidths` that greater than or equal `x`, i.e.  find minimum index in `sortedWidths` that satisfies `x <= sortedWidths[index]` by using binary search. Number of counted rectangles will be `(sortedWidths.size() - 1) - index + 1`.\\n\\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n\\t\\t// map from height to widths\\n        List<List<Integer>> list = new ArrayList<>(101);\\n        for (int i = 0; i <= 100; ++i) {\\n            list.add(new ArrayList<>());\\n        }\\n        for (int[] r : rectangles) {\\n            list.get(r[1]).add(r[0]);\\n        }\\n        for (List<Integer> s : list) {\\n            Collections.sort(s);\\n        }\\n        int n = points.length;\\n        int[] result = new int[n];\\n        for (int i = 0; i < points.length; ++i) {\\n            for (int j = points[i][1]; j <= 100; ++j) {\\n                result[i] += countElementsGreaterThanOrEqual(points[i][0], list.get(j));\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int countElementsGreaterThanOrEqual(int w, List<Integer> sortedWidths) {\\n        if (sortedWidths.isEmpty()) {\\n            return 0;\\n        }\\n        int left = 0;\\n        int right = sortedWidths.size() - 1;\\n        if (w <= sortedWidths.get(left)) {\\n            return sortedWidths.size();\\n        }\\n        if (w >= sortedWidths.get(right)) {\\n            return w == sortedWidths.get(right) ? 1 : 0;\\n        }\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (sortedWidths.get(mid) == w) {\\n                return sortedWidths.size() - 1 - mid + 1;\\n            } else if (sortedWidths.get(mid) > w) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return sortedWidths.size() - 1 - left + 1;\\n    }\\n    \\n}\\n```\\n\\nTime complexity: O(n* log(n)) (n = max(rectangles.length, points.length))\\nSpace complexity: O(n)\\n\\nPlease upvote if it is helpful to you. If there is any question/suggestion, please comment, I will reply as soon as possible. Thank you.\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Tree"
                ],
                "code": "```\\nheight = 1 -> sorted widths of rectangles that have height = 1\\nheight = 2 -> sorted widths of rectangles that have height = 2\\n...\\nheight = 100 -> sorted widths of rectangles that have height = 100\\n```\n```\\nheight = h -> sorted widths of of rectangles that have height = h (y <= h <= 100)\\n```\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n\\t\\t// map from height to widths\\n        List<List<Integer>> list = new ArrayList<>(101);\\n        for (int i = 0; i <= 100; ++i) {\\n            list.add(new ArrayList<>());\\n        }\\n        for (int[] r : rectangles) {\\n            list.get(r[1]).add(r[0]);\\n        }\\n        for (List<Integer> s : list) {\\n            Collections.sort(s);\\n        }\\n        int n = points.length;\\n        int[] result = new int[n];\\n        for (int i = 0; i < points.length; ++i) {\\n            for (int j = points[i][1]; j <= 100; ++j) {\\n                result[i] += countElementsGreaterThanOrEqual(points[i][0], list.get(j));\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int countElementsGreaterThanOrEqual(int w, List<Integer> sortedWidths) {\\n        if (sortedWidths.isEmpty()) {\\n            return 0;\\n        }\\n        int left = 0;\\n        int right = sortedWidths.size() - 1;\\n        if (w <= sortedWidths.get(left)) {\\n            return sortedWidths.size();\\n        }\\n        if (w >= sortedWidths.get(right)) {\\n            return w == sortedWidths.get(right) ? 1 : 0;\\n        }\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (sortedWidths.get(mid) == w) {\\n                return sortedWidths.size() - 1 - mid + 1;\\n            } else if (sortedWidths.get(mid) > w) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return sortedWidths.size() - 1 - left + 1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977264,
                "title": "c-ordered-set",
                "content": "\\nif 1 <= hi, yj <= 1e9\\nthan this solution works fine\\n\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& r, vector<vector<int>>& p) {\\n        \\n        \\n          vector<pair<vector<int> , int>> tmp;\\n        \\n          for(int i = 0  ;i < p.size() ; i ++ ){\\n              \\n              tmp.push_back({p[i] , i}) ;\\n          }\\n        \\n          sort(tmp.begin() , tmp.end() , [&]( pair<vector<int>  , int> &a ,pair<vector<int> , int> &b ){\\n              \\n               return a.first[0] == b.first[0]  ? a.first[1] < b.first[1] : a.first[0] < b.first[0] ;\\n          }) ;\\n               \\n          sort(r.begin() , r.end() , [&]( vector<int> &a  , vector<int> &b  ){\\n              \\n               return a[0] == b[0]  ? a[1] < b[1] : a[0] < b[0] ;\\n          }) ;\\n         \\n          ordered_set  y ;\\n          for(int i = 0 ; i < r.size() ; i ++)\\n                y.insert(r[i][1] ) ;\\n        \\n          vector<int> ans(p.size() , 0) ;\\n        \\n          int j = 0  ;\\n          for(int i = 0 ; i < tmp.size();  i ++ ){         \\n              \\n               while(j < r.size() && r[j][0] < tmp[i].first[0]){\\n                   \\n                   \\n                    y.erase(--y.lower_bound(r[j][1])) ;\\n                    j ++ ;\\n                    \\n               }\\n               if(j != r.size()){\\n\\n                     int x = y.order_of_key(tmp[i].first[1]) ;\\n                     ans[tmp[i].second] = max( 0 , (int)y.size() - x  )  ; \\n               }\\n          }\\n                   \\n        \\n          return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Indexed Tree"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& r, vector<vector<int>>& p) {\\n        \\n        \\n          vector<pair<vector<int> , int>> tmp;\\n        \\n          for(int i = 0  ;i < p.size() ; i ++ ){\\n              \\n              tmp.push_back({p[i] , i}) ;\\n          }\\n        \\n          sort(tmp.begin() , tmp.end() , [&]( pair<vector<int>  , int> &a ,pair<vector<int> , int> &b ){\\n              \\n               return a.first[0] == b.first[0]  ? a.first[1] < b.first[1] : a.first[0] < b.first[0] ;\\n          }) ;\\n               \\n          sort(r.begin() , r.end() , [&]( vector<int> &a  , vector<int> &b  ){\\n              \\n               return a[0] == b[0]  ? a[1] < b[1] : a[0] < b[0] ;\\n          }) ;\\n         \\n          ordered_set  y ;\\n          for(int i = 0 ; i < r.size() ; i ++)\\n                y.insert(r[i][1] ) ;\\n        \\n          vector<int> ans(p.size() , 0) ;\\n        \\n          int j = 0  ;\\n          for(int i = 0 ; i < tmp.size();  i ++ ){         \\n              \\n               while(j < r.size() && r[j][0] < tmp[i].first[0]){\\n                   \\n                   \\n                    y.erase(--y.lower_bound(r[j][1])) ;\\n                    j ++ ;\\n                    \\n               }\\n               if(j != r.size()){\\n\\n                     int x = y.order_of_key(tmp[i].first[1]) ;\\n                     ans[tmp[i].second] = max( 0 , (int)y.size() - x  )  ; \\n               }\\n          }\\n                   \\n        \\n          return ans ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1977198,
                "title": "java-binary-search-on-list",
                "content": "Not a big fan of this solution as it depends on the max size of `y` in the limits section. But I am putting this here in case anyone wants to know.\\n\\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Arrays.sort(rectangles, (a,b)->{\\n            return a[0] - b[0];\\n        });\\n        \\n        List<List<Integer>> yList = new ArrayList<>();\\n        for(int y=0;y<=100;y++)\\n            yList.add(new ArrayList<>());\\n        \\n        for(int i=0;i<rectangles.length;i++){\\n            int[] rect = rectangles[i];\\n            int x = rect[0];\\n            int y = rect[1];\\n            \\n            List<Integer> xList = yList.get(y);\\n            xList.add(x);\\n        }\\n        \\n        int[] ans = new int[points.length];\\n        \\n        for(int i=0;i<points.length;i++){\\n            int[] p = points[i];\\n            \\n            for(int y=p[1]; y<=100; y++){\\n                List<Integer> xList = yList.get(y);\\n                if(xList.isEmpty())\\n                    continue;\\n                int index = Collections.binarySearch(xList, p[0]);\\n                \\n                ans[i] += xList.size() - (index >= 0 ? index : -index-1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Arrays.sort(rectangles, (a,b)->{\\n            return a[0] - b[0];\\n        });\\n        \\n        List<List<Integer>> yList = new ArrayList<>();\\n        for(int y=0;y<=100;y++)\\n            yList.add(new ArrayList<>());\\n        \\n        for(int i=0;i<rectangles.length;i++){\\n            int[] rect = rectangles[i];\\n            int x = rect[0];\\n            int y = rect[1];\\n            \\n            List<Integer> xList = yList.get(y);\\n            xList.add(x);\\n        }\\n        \\n        int[] ans = new int[points.length];\\n        \\n        for(int i=0;i<points.length;i++){\\n            int[] p = points[i];\\n            \\n            for(int y=p[1]; y<=100; y++){\\n                List<Integer> xList = yList.get(y);\\n                if(xList.isEmpty())\\n                    continue;\\n                int index = Collections.binarySearch(xList, p[0]);\\n                \\n                ans[i] += xList.size() - (index >= 0 ? index : -index-1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977049,
                "title": "c-binary-search-o-nlogn",
                "content": "```\\npublic class Solution {\\n    public int[] CountRectangles(int[][] rectangles, int[][] points) {\\n        List<List<int>> yList = new List<List<int>>();\\n        for(int i = 0; i < 101; i++)\\n        {\\n            yList.Add(new List<int>());\\n        }\\n        \\n        for(int i = 0; i < rectangles.Length; i++)\\n        {\\n            yList[rectangles[i][1]].Add(rectangles[i][0]);\\n        }\\n        \\n        for(int i = 0; i < 101; i++)\\n        {\\n            yList[i] = yList[i].OrderBy(x=>x).ToList();\\n        }\\n        \\n        int[] res = new int[points.Length];\\n        \\n        for(int i = 0; i < points.Length; i++)\\n        {\\n            int y = points[i][1];\\n            \\n            for(int j = y; j<yList.Count; j++)\\n            {\\n                res[i]+= yList[j].Count-helper(yList[j], points[i][0]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int helper(List<int> nums, int t)\\n    {\\n        int l = 0;\\n        int r = nums.Count-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(nums[mid]==t)\\n            {\\n                while(mid>0&&nums[mid]==nums[mid-1])\\n                    mid--;\\n                return mid;\\n            }\\n            \\n            if(nums[mid]<t)\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n}",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int[] CountRectangles(int[][] rectangles, int[][] points) {\\n        List<List<int>> yList = new List<List<int>>();\\n        for(int i = 0; i < 101; i++)\\n        {\\n            yList.Add(new List<int>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1976857,
                "title": "divide-into-buckets-of-height",
                "content": "```\\nfrom collections import defaultdict\\nimport bisect\\n\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        n = len(rectangles)\\n        heights = defaultdict(list)\\n        for l, h in rectangles:\\n            bisect.insort(heights[h], l)\\n        count = []\\n        for x, y in points:\\n            ctr = 0\\n            for h in range(y, 101):\\n                ctr += len(heights[h]) - bisect.bisect_left(heights[h], x)\\n            count.append(ctr)\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nimport bisect\\n\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        n = len(rectangles)\\n        heights = defaultdict(list)\\n        for l, h in rectangles:\\n            bisect.insort(heights[h], l)\\n        count = []\\n        for x, y in points:\\n            ctr = 0\\n            for h in range(y, 101):\\n                ctr += len(heights[h]) - bisect.bisect_left(heights[h], x)\\n            count.append(ctr)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973602,
                "title": "very-easy-solution-approach",
                "content": "best easy approach  please optimsie it 46 testcase gives tle \\n```\\nclass Solution {\\n    public int c(int [][] r,int []point){\\n        int a=point[0];\\n        int b=point[1];\\n        \\n        int count=0;\\n        for(int i=0;i<r.length;i++){\\n            if((r[i][0]>=a )&&(r[i][1]>=b)) count++;\\n        }\\n        return count;\\n\\n    }\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int l=points.length;\\n        int ans[]=new int[l];\\n\\n\\n        for(int i=0;i<points.length;i++){\\n            int count=c(rectangles,points[i]);\\n            ans[i]=count;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int c(int [][] r,int []point){\\n        int a=point[0];\\n        int b=point[1];\\n        \\n        int count=0;\\n        for(int i=0;i<r.length;i++){\\n            if((r[i][0]>=a )&&(r[i][1]>=b)) count++;\\n        }\\n        return count;\\n\\n    }\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int l=points.length;\\n        int ans[]=new int[l];\\n\\n\\n        for(int i=0;i<points.length;i++){\\n            int count=c(rectangles,points[i]);\\n            ans[i]=count;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892620,
                "title": "binary-search-on-height-buckets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the upper bound on the *y* axis is low, we can split rectangles between height buckets and then do binary search on *x* coordinates within each one\\n\\n# Complexity\\n- Time complexity: $$O(M*max_y*log(N))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(max_y + N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn count_rectangles(mut rectangles: Vec<Vec<i32>>, points: Vec<Vec<i32>>) -> Vec<i32> {\\n        rectangles.sort_unstable();\\n\\n        let max_y = rectangles.iter().map(|r| r[1]).max().unwrap().max(points.iter().map(|p| p[1]).max().unwrap()) as usize;\\n        let rectangles = rectangles.into_iter().fold(vec![vec![]; max_y + 1], |mut acc, r| {\\n            acc[r[1] as usize].push(r[0]);\\n            acc\\n        });\\n\\n        points.into_iter().map(|p| {\\n            rectangles[p[1] as usize..].iter().map(|r| r.len() - r.partition_point(|&x| x < p[0])).sum::<usize>() as i32\\n        }).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_rectangles(mut rectangles: Vec<Vec<i32>>, points: Vec<Vec<i32>>) -> Vec<i32> {\\n        rectangles.sort_unstable();\\n\\n        let max_y = rectangles.iter().map(|r| r[1]).max().unwrap().max(points.iter().map(|p| p[1]).max().unwrap()) as usize;\\n        let rectangles = rectangles.into_iter().fold(vec![vec![]; max_y + 1], |mut acc, r| {\\n            acc[r[1] as usize].push(r[0]);\\n            acc\\n        });\\n\\n        points.into_iter().map(|p| {\\n            rectangles[p[1] as usize..].iter().map(|r| r.len() - r.partition_point(|&x| x < p[0])).sum::<usize>() as i32\\n        }).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3866156,
                "title": "c-python-binary-indexed-tree-solution-with-explanation",
                "content": "sort rectangles and points reversely.\\nand traverse point, use binary indexed tree to count how many squares whose height >= curent point\\'s y.\\nand add square whose length > x or length == x and height >= y into binary indexed tree, we can use prefix sum to count the square.\\n\\ntc is O(nlogn + plogp + p log(100)), sc is O(100)\\n\\n\\n### python\\n```python\\nclass BIT:\\n    def __init__(self, size):\\n        self.bit = [0] * (size + 1)\\n    \\n    def add(self, idx, val):\\n        idx += 1\\n        while idx < len(self.bit):\\n            self.bit[idx] += val\\n            idx += idx & -idx\\n        \\n    def query(self, idx):\\n        idx += 1\\n        s = 0\\n        while idx > 0:\\n            s += self.bit[idx]\\n            idx -= idx & -idx\\n        return s\\n\\n\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        rectangles.sort(key=lambda x: (x[0], x[1]), reverse=True)\\n        size_p = len(points)\\n        p = sorted(range(size_p), key=lambda x: (points[x][0], points[x][1]), reverse=True)\\n        bit = BIT(100)\\n        i = 0\\n        ans = [0] * size_p\\n        for j in p:\\n            x, y = points[j][0], points[j][1]\\n            while i < len(rectangles) and (rectangles[i][0] > x or (rectangles[i][0] == x and rectangles[i][1] >= y)):\\n                bit.add(rectangles[i][1] - 1, 1)\\n                i += 1\\n            ans[j] = i - bit.query(y - 2)\\n        return ans\\n```\\n\\n### c++\\n```cpp\\nclass BIT {\\npublic:\\n    vector<int> bit;\\n    BIT (int size): bit(size + 1) {}\\n    void add(int idx, int val) {\\n        idx += 1;\\n        while (idx < this -> bit.size()) {\\n            this -> bit[idx] += val;\\n            idx += idx & -idx;\\n        }\\n    }\\n    int query(int idx) {\\n        int s = 0;\\n        idx += 1;\\n        while (idx > 0) {\\n            s += this -> bit[idx];\\n            idx -= idx & -idx;\\n        }\\n        return s;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        sort(rectangles.begin(), rectangles.end(), [] (auto& x, auto& y) {return x[0] == y[0] ? x[1] > y[1] : x[0] > y[0];});\\n        int size_p = points.size();\\n        vector<int> p (size_p);\\n        for (int i = 0; i < size_p; i+=1) p[i] = i;\\n        sort(p.begin(), p.end(), [&points] (auto& x, auto& y) {return points[x][0] == points[y][0] ? points[x][1] > points[y][1]: points[x][0] > points[y][0];});\\n        int i = 0;\\n        vector<int> ans (size_p);\\n        BIT bit (100);\\n        for (auto& j: p) {\\n            int & x = points[j][0], & y = points[j][1];\\n            while (i < rectangles.size() && (rectangles[i][0] > x || (rectangles[i][0] == x && rectangles[i][1] >= y))) {\\n                bit.add(rectangles[i][1] - 1, 1);\\n                i += 1;\\n            }\\n            ans[j] = i - bit.query(y - 2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Binary Indexed Tree"
                ],
                "code": "```python\\nclass BIT:\\n    def __init__(self, size):\\n        self.bit = [0] * (size + 1)\\n    \\n    def add(self, idx, val):\\n        idx += 1\\n        while idx < len(self.bit):\\n            self.bit[idx] += val\\n            idx += idx & -idx\\n        \\n    def query(self, idx):\\n        idx += 1\\n        s = 0\\n        while idx > 0:\\n            s += self.bit[idx]\\n            idx -= idx & -idx\\n        return s\\n\\n\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        rectangles.sort(key=lambda x: (x[0], x[1]), reverse=True)\\n        size_p = len(points)\\n        p = sorted(range(size_p), key=lambda x: (points[x][0], points[x][1]), reverse=True)\\n        bit = BIT(100)\\n        i = 0\\n        ans = [0] * size_p\\n        for j in p:\\n            x, y = points[j][0], points[j][1]\\n            while i < len(rectangles) and (rectangles[i][0] > x or (rectangles[i][0] == x and rectangles[i][1] >= y)):\\n                bit.add(rectangles[i][1] - 1, 1)\\n                i += 1\\n            ans[j] = i - bit.query(y - 2)\\n        return ans\\n```\n```cpp\\nclass BIT {\\npublic:\\n    vector<int> bit;\\n    BIT (int size): bit(size + 1) {}\\n    void add(int idx, int val) {\\n        idx += 1;\\n        while (idx < this -> bit.size()) {\\n            this -> bit[idx] += val;\\n            idx += idx & -idx;\\n        }\\n    }\\n    int query(int idx) {\\n        int s = 0;\\n        idx += 1;\\n        while (idx > 0) {\\n            s += this -> bit[idx];\\n            idx -= idx & -idx;\\n        }\\n        return s;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        sort(rectangles.begin(), rectangles.end(), [] (auto& x, auto& y) {return x[0] == y[0] ? x[1] > y[1] : x[0] > y[0];});\\n        int size_p = points.size();\\n        vector<int> p (size_p);\\n        for (int i = 0; i < size_p; i+=1) p[i] = i;\\n        sort(p.begin(), p.end(), [&points] (auto& x, auto& y) {return points[x][0] == points[y][0] ? points[x][1] > points[y][1]: points[x][0] > points[y][0];});\\n        int i = 0;\\n        vector<int> ans (size_p);\\n        BIT bit (100);\\n        for (auto& j: p) {\\n            int & x = points[j][0], & y = points[j][1];\\n            while (i < rectangles.size() && (rectangles[i][0] > x || (rectangles[i][0] == x && rectangles[i][1] >= y))) {\\n                bit.add(rectangles[i][1] - 1, 1);\\n                i += 1;\\n            }\\n            ans[j] = i - bit.query(y - 2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772366,
                "title": "c-82mb-total-memory-usage-100th-percentile-efficiency-tle-attempts",
                "content": "# \\uD83D\\uDCAF An algorithm at the 100th space efficiency percentile\\nWith less than 200 solution posts at that time and being quite difficult for a Medium (I got several TLEs), I feel like it is time to write a detailed analysis on this algorithm! My algorithm consistently used `82.0 \\xB1 0.1 MB` of storage, placing it above the 99th percentile for memory efficiency!\\n\\n**Please upvote if you liked that!**\\n## 1\\uFE0F\\u20E3 Naive Approach\\n\\nA naive approach involving checking all the rectangles `rect : rectangles` to ensure it satisfies the equation\\n\\n    rect[0] >= points[p][0] && rect[1] >= points[p][1]\\n\\t\\nwill take linear `O(|rectangles|)` per point, and no extra space outside of sorting and the two pointers.\\n\\n## 2\\uFE0F\\u20E3 Sorting and Enumeration\\n\\nThus, a sorting approach should be made. We sort in _descending_ order, so that the loop will terminate early. In our case, we will sort with the x-coordinate as the major coordinate, so the algorithm terminates early once `rect[0]` can no longer fit the point. We will also sort by the y-coordinate so the sequence of rectangles are sorted by their length, and then in the case of a tie, by their height, both in descending order.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        sort(rectangles.begin(), rectangles.end(), [](vector<int>& a, vector<int>& b) {return a[0] > b[0];});\\n        vector<int> count(points.size(), 0);\\n        for (int p = 0; p < points.size(); p++) {\\n            cout << points[p][0] << \" \" << points[p][1] << \"\\\\n\";\\n            for (int r = 0; r < rectangles.size(); r++) {\\n                if (points[p][0] > rectangles[r][0]) {\\n                    r = rectangles.size();\\n                }\\n                else if (points[p][1] > rectangles[r][1]) {\\n                }\\n                else {\\n                    count[p]++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nThis algorithm will abort once `rect[0] < points[p][0]`, so there is a constant best case. However, it will still be linear in the worst or average case. \\n\\nThe reason why I included the case where `rect[1] < points[p][1]` is to allow the inner loop to jump to the next index where the x-coordinate of `rect` changes. Moreover, we can set up for a *binary search* approach for rectangles of a given x-coordinate. Here, we must perform a series of two stable sorts (or its equivalent), so that the results are ordered by their x-coordinate, and then by their y-coordinate.\\n\\n## 3\\uFE0F\\u20E3 Two-level sorting\\n\\nWe sort `rectangles` by their x-coordinate at the primary level, and by the y-coordinate at the secondary level. We also need to check the index of the rectangle after sorting, let that be `r`. The algorithm will now be:\\n\\n1. Check `rect[0] >= points[p][0]`. If this is false, then all further rectangles will fail this loop guard.\\n    * We are now examining all the rectangles with some given height `rect[0]`.\\n\\t* Check if `rect[1] >= points[p][1]`.\\n\\t\\t* If so, increment the count and `r`.\\n\\t\\t* Otherwise, do not increment count, and jump `r` to the first rectangle with a greater x-value.\\n2. Repeat for each `p`.\\n\\nNow, the best case for each x-value of the rectangle is constant, since all rectangles with smaller y-value for a given x-value will be skipped. Jumping `r` will also take constant time, but will require an auxiliary datastructure.\\n\\nThe time complexity still remains at `O(|rectangle|)` time in the worst case. It now works better for cases where the heights of the rectangles vary considerably or are narrower than the majority of the points.\\n\\n### \\uD83D\\uDCC1 Auxiliary datastructure\\n\\nWe devise an auxiliary datastructure to accommodate sorting and constant-time jumping of rectangle indices.\\n\\n```\\n    vector<int> xintervals(vector<vector<int>>& coordinates) {\\n        vector<int> xintervals;\\n\\t\\t// Order by x-coordinate DESC\\n        sort(coordinates.begin(),\\n\\t\\t     coordinates.end(), \\n\\t\\t\\t [](vector<int>& a, vector<int>& b) {return a[0] > b[0];});\\n\\t\\t// Build auxiliary datastructure\\n        int last = INT_MIN;\\n        for (int k = 0; k < coordinates.size(); k++) {\\n            if (coordinates[k][0] != last) {\\n                xintervals.push_back(k);\\n                last = coordinates[k][0];\\n            }\\n        }\\n        xintervals.push_back(coordinates.size());\\n        return xintervals;\\n    }\\n```\\n\\nLet `rx` be the `(k + 1)`th widest x-dimension of the rectangles. Then, `xintervals[k]` returns the index of the first rectangle with length `rx`. If there are `K` different rectangle lengths, then `xintervals[k] = |rectangles|`. \\n\\n    \\u2200r\\u2208[xintervals[k],xintervals[k + 1]) rectangle[r][0] == rectangles[r][xintervals[k]] == rx\\n\\nThis auxiliary step is only called once. It takes time linear in `|coordinates|`, in which `coordinates` will be the rectangles in this problem. It also takes linear `O(|coordinates| + 1)` space in the worst case when the lengths are all distinct, and `O(2)` space in the best case when the rectangles differ only by height.\\n\\n### \\uD83D\\uDDC3\\uFE0F Secondary-level sorting\\n\\nWe use the auxiliary datastructure to perform secondary-level sorting by the rectangle\\'s y-values. The rectangles sharing a particular x-value forms a subarray.\\n\\n```\\n        for (int x = 0; x < rectangle_xintervals.size() - 1; x++) {\\n            sort(rectangles.begin() + rectangle_xintervals[x], \\n                 rectangles.begin() + rectangle_xintervals[x + 1], \\n                 [](vector<int>& a, vector<int>& b) {return a[1] > b[1];});\\n        }\\n```\\n\\n### \\u23E9 Performing jumps\\n\\nAfter performing a two-level sort and building the auxiliary datastructure, we are ready to perform jumps when necessary. Our code will now be:\\n\\nIn the case that `(rectangles[r][1] < points[p][1])`, we increment `k` and perform the jump. Note `rectangle_xintervals[0] == 0`.\\n\\n```\\n        for (int p = 0; p < points.size(); p++) {\\n            int k = 0;\\n            for (int r = 0; r < rectangles.size(); r++) {\\n                if (points[p][0] > rectangles[r][0]) {\\n                    r = rectangles.size();\\n                }\\n                else if (points[p][1] > rectangles[r][1]) {\\n\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t\\tr = rectangle_xintervals[k];\\n                }\\n                else {\\n                    count[p]++;\\n                }\\n            }\\n        }\\n```\\n\\n## \\uD83D\\uDD0D Binary search on rectangles with a common length [TLE]\\n\\nWe are now ready to perform a binary search, since our previous approachs still take linear time. We can now reduce the time complexity for a set of rectangles sharing a common height to logarithmic.\\n\\nWe will use one variety of the binary search. Given a descending list of unique values, the binary search returns the index of the greatest value strictly less than the target. \\n\\nWe will also mind the offset since binary search is compatible for sorted subarrays, so we can perform an in-place binary sort.\\n\\n```\\n    int binarysubsearchL(vector<vector<int>>& coordinates, int ini, int fin, int target) {\\n        int inix = ini;\\n        int med;\\n\\t\\t// Halts when ini equals fin\\n        while (ini < fin) {\\n            med = (ini + fin) / 2;\\n            if (target > coordinates[med][0]) {\\n                fin = med; // Target is before the median\\n            }\\n            else if (target < coordinates[med][0]) {\\n                ini = med + 1; // Target is after the median\\n            }\\n            else {\\n                return med - inix + 1; // Match found\\n            }\\n        }\\n        return fin - inix; // Always equal to ini\\n    }\\n```\\n\\n### \\u231B Final code\\n\\nOur final algorithm consists of three steps:\\n1.  Perform primary sort on x-coordinate, and derive the auxiliary datastructure\\n2.  Perform secondary sort on y-coordinate, using the auxiliary datastructure.\\n3.  For each `p`:\\n\\t* Traverse the rectangles by height rank `k`, as long as the height is not strictly less than this point\\'s x-value.\\n\\t* Perform binary search on the subarray of rectangles sharing the same height `rectangles[xintervals[k]][0]`\\n\\t* Each binary search call returns the number of rectangles of that height and also having y-coordinate at least that of the current point.\\n\\n```\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<int> count(points.size(), 0);\\n\\t\\t\\n\\t\\t// Primary sorting and auxiliary datastructure\\n        vector<int> rectangle_xintervals = xintervals(rectangles);\\n        \\n\\t\\t// Seconday sorting\\n        for (int k = 0; k < rectangle_xintervals.size() - 1; k++) {\\n            sort(rectangles.begin() + rectangle_xintervals[k], \\n                 rectangles.begin() + rectangle_xintervals[k + 1], \\n                 [](vector<int>& a, vector<int>& b) {return a[1] > b[1];});\\n        }\\n\\n        for (int p = 0; p < points.size(); p++) {\\n            for (int k = 0; k < rectangle_xintervals.size() - 1; k++) {\\n                if (rectangles[rectangle_xintervals[k]][0] < points[p][0]) {\\n                    k = rectangle_xintervals.size();\\n                    continue; // break\\n                }\\n\\t\\t\\t\\t// Perform binary search on rectangles with width of rank k\\n                int score = binarysubsearchL(rectangles, \\n                                             rectangle_xintervals[k], \\n                                             rectangle_xintervals[k + 1], \\n                                             points[p][1]);\\n                count[p] += score;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\nUnfortunately, the algorithm will not improve by much if the number of distinct x-values is great, as in this problem. Doing it by x-coordinate will register as a _time limit exceeded_ failure. However, the question is structured specifically with the number of distinct y-values being no more than 100.\\n\\nOur algorithm\\'s average case complexity improves to `O(S*log|rectangles/S|)`, which is especially noticeable for low `S`.\\n\\n## \\uD83D\\uDCAF Binary search on rectangles with a common height [Accepted]\\n\\nWe can interchange the roles of the length (x-coordinate) and the height (y-coordinate). The rectangles will be grouped into no more than 100 contiguous subarrays, and all rectangles within any one subarray has the same height, and are then sorted by their lengths.\\n\\nOur algorithm\\'s complexity reduces to logarithmic time with `S <= 100`\\n\\n    O(100*log(|rectangles/100|))\\n\\tO(log|rectangles|)\\n\\t\\nand space \\n\\n    O(101)\\n\\nusing only the `p`, `k` pointers, the three binary search pointers, and the return value from binary search.\\n\\n### \\u2705 Final code\\n\\nI have also improved the code so Step 1 and 2 are done together, with Step 2 using the partial result of Step 1. This provides a time reduction from `800 ms` to `760 ms`.\\n\\nFeel free to run!\\n\\n```\\nclass Solution {\\nprivate:\\n    vector<int> jumplist1(vector<vector<int>>& coordinates) {\\n        vector<int> jumplist;\\n        if (!coordinates.size()) {\\n            return jumplist;\\n        }\\n        \\n        sort(coordinates.begin(), \\n             coordinates.end(), \\n             [](vector<int>& a, vector<int>& b) {return a[1] > b[1];});\\n        \\n        int last = coordinates[0][1];\\n        jumplist.push_back(0);\\n        for (int r = 1; r < coordinates.size(); r++) {\\n            if (coordinates[r][1] < last) {\\n                sort(coordinates.begin() + jumplist[jumplist.size() - 1], \\n                     coordinates.begin() + r, \\n                     [](vector<int>& a, vector<int>& b) {return a[0] > b[0];});\\n                jumplist.push_back(r);\\n                last = coordinates[r][1];\\n            }\\n        }\\n        sort(coordinates.begin() + jumplist[jumplist.size() - 1], \\n             coordinates.end(), \\n             [](vector<int>& a, vector<int>& b) {return a[0] > b[0];});\\n        jumplist.push_back(coordinates.size());\\n        return jumplist;\\n    }\\n    \\n    int binarysubsearchL(vector<vector<int>>& coordinates, int ini, int fin, int target) {\\n        int inix = ini;\\n        int med;\\n        while (ini < fin) {\\n            med = (ini + fin) / 2;\\n            if (target > coordinates[med][0]) {\\n                fin = med;\\n            }\\n            else if (target <= coordinates[med][0]) {\\n                ini = med + 1;\\n            }\\n        }\\n        return fin - inix;\\n    }\\n    \\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<int> count(points.size(), 0);\\n        \\n        vector<int> y_jumplist = jumplist1(rectangles);\\n\\n        for (int p = 0; p < points.size(); p++) {\\n            for (int k = 0; \\n                 k < y_jumplist.size() - 1 && rectangles[y_jumplist[k]][1] >= points[p][1]; \\n                 k++) {\\n                int score = binarysubsearchL(rectangles, \\n                                             y_jumplist[k], \\n                                             y_jumplist[k + 1], \\n                                             points[p][0]);\\n                count[p] += score;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        sort(rectangles.begin(), rectangles.end(), [](vector<int>& a, vector<int>& b) {return a[0] > b[0];});\\n        vector<int> count(points.size(), 0);\\n        for (int p = 0; p < points.size(); p++) {\\n            cout << points[p][0] << \" \" << points[p][1] << \"\\\\n\";\\n            for (int r = 0; r < rectangles.size(); r++) {\\n                if (points[p][0] > rectangles[r][0]) {\\n                    r = rectangles.size();\\n                }\\n                else if (points[p][1] > rectangles[r][1]) {\\n                }\\n                else {\\n                    count[p]++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\n    vector<int> xintervals(vector<vector<int>>& coordinates) {\\n        vector<int> xintervals;\\n\\t\\t// Order by x-coordinate DESC\\n        sort(coordinates.begin(),\\n\\t\\t     coordinates.end(), \\n\\t\\t\\t [](vector<int>& a, vector<int>& b) {return a[0] > b[0];});\\n\\t\\t// Build auxiliary datastructure\\n        int last = INT_MIN;\\n        for (int k = 0; k < coordinates.size(); k++) {\\n            if (coordinates[k][0] != last) {\\n                xintervals.push_back(k);\\n                last = coordinates[k][0];\\n            }\\n        }\\n        xintervals.push_back(coordinates.size());\\n        return xintervals;\\n    }\\n```\n```\\n        for (int x = 0; x < rectangle_xintervals.size() - 1; x++) {\\n            sort(rectangles.begin() + rectangle_xintervals[x], \\n                 rectangles.begin() + rectangle_xintervals[x + 1], \\n                 [](vector<int>& a, vector<int>& b) {return a[1] > b[1];});\\n        }\\n```\n```\\n        for (int p = 0; p < points.size(); p++) {\\n            int k = 0;\\n            for (int r = 0; r < rectangles.size(); r++) {\\n                if (points[p][0] > rectangles[r][0]) {\\n                    r = rectangles.size();\\n                }\\n                else if (points[p][1] > rectangles[r][1]) {\\n\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t\\tr = rectangle_xintervals[k];\\n                }\\n                else {\\n                    count[p]++;\\n                }\\n            }\\n        }\\n```\n```\\n    int binarysubsearchL(vector<vector<int>>& coordinates, int ini, int fin, int target) {\\n        int inix = ini;\\n        int med;\\n\\t\\t// Halts when ini equals fin\\n        while (ini < fin) {\\n            med = (ini + fin) / 2;\\n            if (target > coordinates[med][0]) {\\n                fin = med; // Target is before the median\\n            }\\n            else if (target < coordinates[med][0]) {\\n                ini = med + 1; // Target is after the median\\n            }\\n            else {\\n                return med - inix + 1; // Match found\\n            }\\n        }\\n        return fin - inix; // Always equal to ini\\n    }\\n```\n```\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<int> count(points.size(), 0);\\n\\t\\t\\n\\t\\t// Primary sorting and auxiliary datastructure\\n        vector<int> rectangle_xintervals = xintervals(rectangles);\\n        \\n\\t\\t// Seconday sorting\\n        for (int k = 0; k < rectangle_xintervals.size() - 1; k++) {\\n            sort(rectangles.begin() + rectangle_xintervals[k], \\n                 rectangles.begin() + rectangle_xintervals[k + 1], \\n                 [](vector<int>& a, vector<int>& b) {return a[1] > b[1];});\\n        }\\n\\n        for (int p = 0; p < points.size(); p++) {\\n            for (int k = 0; k < rectangle_xintervals.size() - 1; k++) {\\n                if (rectangles[rectangle_xintervals[k]][0] < points[p][0]) {\\n                    k = rectangle_xintervals.size();\\n                    continue; // break\\n                }\\n\\t\\t\\t\\t// Perform binary search on rectangles with width of rank k\\n                int score = binarysubsearchL(rectangles, \\n                                             rectangle_xintervals[k], \\n                                             rectangle_xintervals[k + 1], \\n                                             points[p][1]);\\n                count[p] += score;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    vector<int> jumplist1(vector<vector<int>>& coordinates) {\\n        vector<int> jumplist;\\n        if (!coordinates.size()) {\\n            return jumplist;\\n        }\\n        \\n        sort(coordinates.begin(), \\n             coordinates.end(), \\n             [](vector<int>& a, vector<int>& b) {return a[1] > b[1];});\\n        \\n        int last = coordinates[0][1];\\n        jumplist.push_back(0);\\n        for (int r = 1; r < coordinates.size(); r++) {\\n            if (coordinates[r][1] < last) {\\n                sort(coordinates.begin() + jumplist[jumplist.size() - 1], \\n                     coordinates.begin() + r, \\n                     [](vector<int>& a, vector<int>& b) {return a[0] > b[0];});\\n                jumplist.push_back(r);\\n                last = coordinates[r][1];\\n            }\\n        }\\n        sort(coordinates.begin() + jumplist[jumplist.size() - 1], \\n             coordinates.end(), \\n             [](vector<int>& a, vector<int>& b) {return a[0] > b[0];});\\n        jumplist.push_back(coordinates.size());\\n        return jumplist;\\n    }\\n    \\n    int binarysubsearchL(vector<vector<int>>& coordinates, int ini, int fin, int target) {\\n        int inix = ini;\\n        int med;\\n        while (ini < fin) {\\n            med = (ini + fin) / 2;\\n            if (target > coordinates[med][0]) {\\n                fin = med;\\n            }\\n            else if (target <= coordinates[med][0]) {\\n                ini = med + 1;\\n            }\\n        }\\n        return fin - inix;\\n    }\\n    \\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<int> count(points.size(), 0);\\n        \\n        vector<int> y_jumplist = jumplist1(rectangles);\\n\\n        for (int p = 0; p < points.size(); p++) {\\n            for (int k = 0; \\n                 k < y_jumplist.size() - 1 && rectangles[y_jumplist[k]][1] >= points[p][1]; \\n                 k++) {\\n                int score = binarysubsearchL(rectangles, \\n                                             y_jumplist[k], \\n                                             y_jumplist[k + 1], \\n                                             points[p][0]);\\n                count[p] += score;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3764998,
                "title": "binary-search-naive-solution-please-help-improve",
                "content": "\\n\\n# Approach\\n1. put rectangles\\'s length to a HashMap using its height as the key and a List as the value. as height can only be up to 100.\\n2. sort List to be prepared for binary search\\n3. iterate each point. while iterate each height, start from this\\'s point\\'s height, so that it won\\'t count those rectangle who has smaller height but longer length.\\n4. when doing binary search, find its would-inserted index and count how many elements are larger than the would-inserted index, and return this number as the result. so that the function is telling how many rectangle has larger length than the point.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn + m), where n = number of rectangles and m = number of points\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int[] rec: rectangles) {\\n            List<Integer> list = map.getOrDefault(rec[1], new ArrayList<>());\\n            list.add(rec[0]);\\n            map.put(rec[1], list);\\n        }\\n        for(Map.Entry<Integer, List<Integer>> entry: map.entrySet()) {\\n            Collections.sort(entry.getValue());\\n        }\\n        int[] result = new int[points.length];\\n        for(int i=0; i<points.length; i++) {\\n            int[] point = points[i];\\n            int length = point[0];\\n            int height = point[1];\\n            int count = 0;\\n            for(int j=height; j<=100; j++) {\\n                List<Integer> lengthList = map.getOrDefault(j, new ArrayList<>());\\n                int numberOfLess = numElementGreaterThanTarget(lengthList, length);\\n                count += numberOfLess;\\n            }\\n            result[i] = count;\\n        }\\n        return result;\\n    }\\n\\n    public int numElementGreaterThanTarget(List<Integer> list, int target) {\\n        if(list.size() == 0) {\\n            return 0;\\n        }\\n        if(target > list.get(list.size()-1)) {\\n            return 0;\\n        }\\n        int left=0, right=list.size();\\n        while(left < right) {\\n            int mid = (left+right) / 2;\\n            if (target == list.get(mid)) {\\n                return list.size() - mid;\\n            } else if(target < list.get(mid)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return list.size() - left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int[] rec: rectangles) {\\n            List<Integer> list = map.getOrDefault(rec[1], new ArrayList<>());\\n            list.add(rec[0]);\\n            map.put(rec[1], list);\\n        }\\n        for(Map.Entry<Integer, List<Integer>> entry: map.entrySet()) {\\n            Collections.sort(entry.getValue());\\n        }\\n        int[] result = new int[points.length];\\n        for(int i=0; i<points.length; i++) {\\n            int[] point = points[i];\\n            int length = point[0];\\n            int height = point[1];\\n            int count = 0;\\n            for(int j=height; j<=100; j++) {\\n                List<Integer> lengthList = map.getOrDefault(j, new ArrayList<>());\\n                int numberOfLess = numElementGreaterThanTarget(lengthList, length);\\n                count += numberOfLess;\\n            }\\n            result[i] = count;\\n        }\\n        return result;\\n    }\\n\\n    public int numElementGreaterThanTarget(List<Integer> list, int target) {\\n        if(list.size() == 0) {\\n            return 0;\\n        }\\n        if(target > list.get(list.size()-1)) {\\n            return 0;\\n        }\\n        int left=0, right=list.size();\\n        while(left < right) {\\n            int mid = (left+right) / 2;\\n            if (target == list.get(mid)) {\\n                return list.size() - mid;\\n            } else if(target < list.get(mid)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return list.size() - left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720165,
                "title": "c-solution-using-height-at-max-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis code counts the number of rectangles for each given point based on certain criteria. It uses a 2D vector called store to store the x-coordinates for each vertical height. It then iterates through each point, checks the valid x-coordinates using binary search, and counts the number of rectangles for each point. The results are stored in a vector called fans and returned as the final result. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is O(N * log(M)), where N is the total number of rectangles and points combined, and M is the maximum number of rectangles for a single vertical height.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(N).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        //making a vector for storing the vertical heights and their x coordinates\\n        vector<vector<int>> store(101);\\n\\n        for(auto itr: rectangles)\\n        {\\n            store[itr[1]].push_back(itr[0]);\\n        }\\n        for(int i=0;i<101;i++)\\n        {\\n            // if(store[i].size())\\n            sort(store[i].begin(),store[i].end());\\n        }\\n        vector<int> fans;\\n        //sorted each vertical length and its corrosponding x coordinates \\n        for(auto itr:points)\\n        {\\n            int x=itr[0];\\n            int ans=0;\\n            for(int y = itr[1];y<101;y++)\\n            {\\n                //now we have to check at each y the valid x using binary search\\n                int ind = lower_bound(store[y].begin(),store[y].end(),x) - store[y].begin();\\n                ans+= store[y].size()-ind;\\n            }\\n            fans.push_back(ans);\\n        }\\n        return fans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        //making a vector for storing the vertical heights and their x coordinates\\n        vector<vector<int>> store(101);\\n\\n        for(auto itr: rectangles)\\n        {\\n            store[itr[1]].push_back(itr[0]);\\n        }\\n        for(int i=0;i<101;i++)\\n        {\\n            // if(store[i].size())\\n            sort(store[i].begin(),store[i].end());\\n        }\\n        vector<int> fans;\\n        //sorted each vertical length and its corrosponding x coordinates \\n        for(auto itr:points)\\n        {\\n            int x=itr[0];\\n            int ans=0;\\n            for(int y = itr[1];y<101;y++)\\n            {\\n                //now we have to check at each y the valid x using binary search\\n                int ind = lower_bound(store[y].begin(),store[y].end(),x) - store[y].begin();\\n                ans+= store[y].size()-ind;\\n            }\\n            fans.push_back(ans);\\n        }\\n        return fans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632133,
                "title": "c-lower-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        const int N = points.size();\\n        vector<int> ret(N);\\n        \\n        map<int, vector<int>> data;\\n        \\n        for(const auto &rect : rectangles) {\\n            data[rect[1]].push_back(rect[0]);\\n        }\\n        \\n        for(auto &entry : data) {\\n            sort(entry.second.begin(), entry.second.end());\\n        }\\n        \\n        for(int i = 0; i < N; ++i) {\\n            const int l = points[i][0];\\n            const int h = points[i][1];\\n            int cnt = 0;\\n            for(auto h_it = data.lower_bound(h); h_it != data.end(); ++h_it) {\\n                const auto &lengths = h_it->second;\\n                auto l_it = lower_bound(lengths.cbegin(), lengths.cend(), l);\\n                cnt += distance(l_it, lengths.cend());\\n            }\\n            ret[i] = cnt;\\n        }\\n        return ret;\\n    }\\n};\\n``\\xB4",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        const int N = points.size();\\n        vector<int> ret(N);\\n        \\n        map<int, vector<int>> data;\\n        \\n        for(const auto &rect : rectangles) {\\n            data[rect[1]].push_back(rect[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3625532,
                "title": "c-hash-map-easy-solution",
                "content": "# Approach\\nSince the heights are till 100 so we can mantain a map of vector with key as height and the value as vector of lengths with that particular height, now we can iterate on the points array to find how many rectangles satisfy the condition.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rect, vector<vector<int>>& pts) {\\n        int n = rect.size();\\n        map<int,vector<int>> m;\\n        vector<vector<int>> vec(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            vec[i] = {rect[i][0],rect[i][1]};\\n        }\\n        sort(vec.begin(),vec.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            m[vec[i][1]].push_back(vec[i][0]);\\n        }\\n        vector<int> ans(pts.size());\\n        for(int i=0;i<pts.size();i++)\\n        {\\n            int x = pts[i][0];\\n            int y = pts[i][1];\\n            for(auto &j:m)\\n            {\\n                if(j.first<y)\\n                continue;\\n                int siz = j.second.size();\\n                int it = lower_bound(j.second.begin(),j.second.end(),x)-j.second.begin();\\n                ans[i]+= siz-it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rect, vector<vector<int>>& pts) {\\n        int n = rect.size();\\n        map<int,vector<int>> m;\\n        vector<vector<int>> vec(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            vec[i] = {rect[i][0],rect[i][1]};\\n        }\\n        sort(vec.begin(),vec.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            m[vec[i][1]].push_back(vec[i][0]);\\n        }\\n        vector<int> ans(pts.size());\\n        for(int i=0;i<pts.size();i++)\\n        {\\n            int x = pts[i][0];\\n            int y = pts[i][1];\\n            for(auto &j:m)\\n            {\\n                if(j.first<y)\\n                continue;\\n                int siz = j.second.size();\\n                int it = lower_bound(j.second.begin(),j.second.end(),x)-j.second.begin();\\n                ans[i]+= siz-it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550869,
                "title": "simple-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom bisect import bisect_left\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        count=[]\\n        rectangles.sort()\\n\\n        h=defaultdict(list)\\n\\n        #y height pe jitne bhi rectangles hai unki list\\n        for l,hi in rectangles:\\n            h[hi].append(l)\\n\\n        for x,y in points:\\n            ans=0\\n\\n            for i in range(y,101):\\n                if i in h:\\n                    ans=ans + len(h[i]) - bisect_left(h[i], x)\\n            \\n            count.append(ans)\\n        \\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import bisect_left\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        count=[]\\n        rectangles.sort()\\n\\n        h=defaultdict(list)\\n\\n        #y height pe jitne bhi rectangles hai unki list\\n        for l,hi in rectangles:\\n            h[hi].append(l)\\n\\n        for x,y in points:\\n            ans=0\\n\\n            for i in range(y,101):\\n                if i in h:\\n                    ans=ans + len(h[i]) - bisect_left(h[i], x)\\n            \\n            count.append(ans)\\n        \\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494622,
                "title": "my-solutions",
                "content": "\\n**Solution I**\\n```\\nclass Solution {\\n public:\\n  vector<int> countRectangles(const vector<vector<int>> &rectangles,\\n                              const vector<vector<int>> &points) {\\n    map<int, vector<int>> rect_y_to_xs;\\n    for (const vector<int> &rectangle : rectangles) {\\n      rect_y_to_xs[rectangle.back()].emplace_back(rectangle.front());\\n    }\\n    \\n    for (auto &[_, xs] : rect_y_to_xs) {\\n      sort(xs.begin(), xs.end());\\n    }\\n    \\n    vector<int> ret(points.size());\\n    for (size_t i = 0; i < points.size(); ++i) {\\n      const int x = points[i].front();\\n      const int y = points[i].back();\\n      int &item = ret[i];\\n      auto lb_y = rect_y_to_xs.lower_bound(y);\\n      for (auto itr = lb_y; itr != rect_y_to_xs.end(); ++itr) {\\n        const vector<int> &xs = itr->second;\\n        auto lb_x = lower_bound(xs.begin(), xs.end(), x);\\n        item += static_cast<int>(xs.end() - lb_x);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**Solution II, based on `Solution I`, using more space complexity to gain the less time complexity**\\n```\\nclass Solution {\\n public:\\n  vector<int> countRectangles(const vector<vector<int>> &rectangles,\\n                              const vector<vector<int>> &points) {\\n    unordered_map<int, vector<int>> rect_y_to_xs;\\n    int min_rect_y = numeric_limits<int>::max();\\n    int max_rect_y = numeric_limits<int>::min();\\n    for (const vector<int> &rectangle : rectangles) {\\n      rect_y_to_xs[rectangle.back()].emplace_back(rectangle.front());\\n      min_rect_y = min(min_rect_y, rectangle.back());\\n      max_rect_y = max(max_rect_y, rectangle.back());\\n    }\\n    const int rect_y_range = max_rect_y - min_rect_y + 1;\\n    vector<int> rects[rect_y_range];\\n    for (auto &[y, xs] : rect_y_to_xs) {\\n      sort(xs.begin(), xs.end());\\n      rects[y - min_rect_y] = move(xs);\\n    }\\n    \\n    vector<int> ret(points.size());\\n    for (size_t i = 0; i < points.size(); ++i) {\\n      const int x = points[i].front();\\n      const int y = points[i].back();\\n      int &item = ret[i];\\n      for (int rect_y = max(min_rect_y, y); rect_y < max_rect_y + 1; ++rect_y) {\\n        const vector<int> &xs = rects[rect_y - min_rect_y];\\n        if (xs.empty()) {\\n          continue;\\n        }\\n        auto lb_x = lower_bound(xs.begin(), xs.end(), x);\\n        item += static_cast<int>(xs.end() - lb_x);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  vector<int> countRectangles(const vector<vector<int>> &rectangles,\\n                              const vector<vector<int>> &points) {\\n    map<int, vector<int>> rect_y_to_xs;\\n    for (const vector<int> &rectangle : rectangles) {\\n      rect_y_to_xs[rectangle.back()].emplace_back(rectangle.front());\\n    }\\n    \\n    for (auto &[_, xs] : rect_y_to_xs) {\\n      sort(xs.begin(), xs.end());\\n    }\\n    \\n    vector<int> ret(points.size());\\n    for (size_t i = 0; i < points.size(); ++i) {\\n      const int x = points[i].front();\\n      const int y = points[i].back();\\n      int &item = ret[i];\\n      auto lb_y = rect_y_to_xs.lower_bound(y);\\n      for (auto itr = lb_y; itr != rect_y_to_xs.end(); ++itr) {\\n        const vector<int> &xs = itr->second;\\n        auto lb_x = lower_bound(xs.begin(), xs.end(), x);\\n        item += static_cast<int>(xs.end() - lb_x);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\nclass Solution {\\n public:\\n  vector<int> countRectangles(const vector<vector<int>> &rectangles,\\n                              const vector<vector<int>> &points) {\\n    unordered_map<int, vector<int>> rect_y_to_xs;\\n    int min_rect_y = numeric_limits<int>::max();\\n    int max_rect_y = numeric_limits<int>::min();\\n    for (const vector<int> &rectangle : rectangles) {\\n      rect_y_to_xs[rectangle.back()].emplace_back(rectangle.front());\\n      min_rect_y = min(min_rect_y, rectangle.back());\\n      max_rect_y = max(max_rect_y, rectangle.back());\\n    }\\n    const int rect_y_range = max_rect_y - min_rect_y + 1;\\n    vector<int> rects[rect_y_range];\\n    for (auto &[y, xs] : rect_y_to_xs) {\\n      sort(xs.begin(), xs.end());\\n      rects[y - min_rect_y] = move(xs);\\n    }\\n    \\n    vector<int> ret(points.size());\\n    for (size_t i = 0; i < points.size(); ++i) {\\n      const int x = points[i].front();\\n      const int y = points[i].back();\\n      int &item = ret[i];\\n      for (int rect_y = max(min_rect_y, y); rect_y < max_rect_y + 1; ++rect_y) {\\n        const vector<int> &xs = rects[rect_y - min_rect_y];\\n        if (xs.empty()) {\\n          continue;\\n        }\\n        auto lb_x = lower_bound(xs.begin(), xs.end(), x);\\n        item += static_cast<int>(xs.end() - lb_x);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435974,
                "title": "python-binary-search-intuitive-solution-w-detailed-explanation",
                "content": "# Intuition\\nBecause all the rectangles are confined to Quadrant 1, we know that if any given rectangle contains a point (x, y), then all larger rectangles must \\nalso contain that point.\\n\\nHere, \"larger\" is defined as a rectangle that has both a greater than or equal height and length. It is not enough for just one of those to satisfy the >= condition.\\n\\nSince the lengths have a larger range of possible values than heights, Binary Search will be used on the lengths.  \\n\\n# Approach\\nFor each point (x, y), find the rectangles with a greater than or equal height (i.e. >= y) and then for each one of those rectangles, determine which ones also have a greater than or equal length (i.e. >= x).\\n\\n# Complexity\\nTime complexity:\\nO(n log n)\\n\\nSpace complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countRectangles(rectangles: list[list[int]], points: list[list[int]]) -> list[int]:\\n        # Standard Binary Search\\n        def binary_search(arr, target):\\n            left, right = 0, len(arr) - 1\\n            while left <= right:\\n                mid = (left + right) // 2\\n                if arr[mid] == target:\\n                    return mid\\n                elif arr[mid] > target:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            return left\\n\\n        # Create our dictionary, where we map heights to lengths. So all the lengths for a given height\\n        # will be put together\\n        height_to_lengths = defaultdict(list)\\n        for length, height in rectangles:\\n            height_to_lengths[height].append(length)\\n\\n        # Find the max height, this will be used an upper bound\\n        max_height = max(height_to_lengths.keys())\\n        ans = []\\n\\n        # Since Binary Search will be done on the lengths, they will need to be sorted\\n        for lengths in height_to_lengths.values():\\n            lengths.sort()\\n\\n        # Iterate through all the points, and for each point see how many rectangles that point is in (in other words, how\\n        # many rectangles contain that point).\\n        for x, y in points:\\n            count = 0\\n            for height in range(y, max_height + 1):\\n                if height in height_to_lengths.keys():\\n                    # Binary Search gives us the index of the immediate rectangle that is greater than or equal to x. To\\n                    # find all the rectangles that have a length greater than x, we simply subtract the index Binary Search\\n                    # gives us from the length of the array.\\n                    count += len(height_to_lengths[height]) - binary_search(height_to_lengths[height], x)\\n            ans.append(count)\\n        return ans\\n```\\n\\nHope this helps.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countRectangles(rectangles: list[list[int]], points: list[list[int]]) -> list[int]:\\n        # Standard Binary Search\\n        def binary_search(arr, target):\\n            left, right = 0, len(arr) - 1\\n            while left <= right:\\n                mid = (left + right) // 2\\n                if arr[mid] == target:\\n                    return mid\\n                elif arr[mid] > target:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            return left\\n\\n        # Create our dictionary, where we map heights to lengths. So all the lengths for a given height\\n        # will be put together\\n        height_to_lengths = defaultdict(list)\\n        for length, height in rectangles:\\n            height_to_lengths[height].append(length)\\n\\n        # Find the max height, this will be used an upper bound\\n        max_height = max(height_to_lengths.keys())\\n        ans = []\\n\\n        # Since Binary Search will be done on the lengths, they will need to be sorted\\n        for lengths in height_to_lengths.values():\\n            lengths.sort()\\n\\n        # Iterate through all the points, and for each point see how many rectangles that point is in (in other words, how\\n        # many rectangles contain that point).\\n        for x, y in points:\\n            count = 0\\n            for height in range(y, max_height + 1):\\n                if height in height_to_lengths.keys():\\n                    # Binary Search gives us the index of the immediate rectangle that is greater than or equal to x. To\\n                    # find all the rectangles that have a length greater than x, we simply subtract the index Binary Search\\n                    # gives us from the length of the array.\\n                    count += len(height_to_lengths[height]) - binary_search(height_to_lengths[height], x)\\n            ans.append(count)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410171,
                "title": "c-sorting-travel-from-end",
                "content": "The idea is to calculate the total number of buildings >= x and >= y\\nInitially we think of sorting computing vals and store and retrive them. But that cost a lot of memory.\\nSo, we have to do while we traverse.\\nTravel from the end to begin.\\nIf our point xi > the current building x then we have to get all buildings whose height >= yj\\nheights are of upto 100 only so use an array and aggregate all of them so no need to search on a bigger pile\\n\\n```\\nclass Solution {\\npublic:\\n    // xi, yi -> represts point\\n    // xj, yj -> isInside ?\\n    // so every xi >= xj and yi >= yj qualifies\\n    // if we get the xi - then the task is how many yi >= yj? \\n    // from xi - there are 6 yi - s\\n    // from yi - there are 3 xi - s\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n     \\n        int n = rectangles.size();\\n        vector<int> xi, yi;\\n        sort(rectangles.begin(), rectangles.end());\\n        \\n        for(int i=0; i<n; i++) {\\n            xi.push_back(rectangles[i][0]);\\n            yi.push_back(rectangles[i][1]);\\n        }\\n        auto prevIndex = yi.end();\\n        vector<int> height_till_now(101, 0);\\n        int k = points.size();\\n        vector<int> counts(k,0);\\n        vector<pair<vector<int>,int>> pointPairs;\\n        for(int i=0; i<k; i++) pointPairs.push_back({points[i], i});\\n        sort(pointPairs.begin(), pointPairs.end());\\n        int l=k-1;\\n        for(int i=n-1; i>=0 && l>=0; i--) {\\n            auto xii = xi[i];\\n            \\n            while(l>=0 && xii < pointPairs[l].first[0]) {\\n                counts[pointPairs[l].second] = height_till_now[pointPairs[l].first[1]];\\n                l--;\\n            }\\n            \\n            partial_sort(yi.begin()+i, prevIndex, prevIndex);\\n            for(int j=100; j>=1; j--) {\\n                height_till_now[j] += prevIndex - lower_bound(yi.begin()+i, prevIndex, j);\\n            }\\n            prevIndex = yi.begin()+i;\\n        }\\n        \\n        while(l>=0) {\\n            counts[pointPairs[l].second] = height_till_now[pointPairs[l].first[1]];\\n            l--;\\n        }\\n        \\n        return counts;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // xi, yi -> represts point\\n    // xj, yj -> isInside ?\\n    // so every xi >= xj and yi >= yj qualifies\\n    // if we get the xi - then the task is how many yi >= yj? \\n    // from xi - there are 6 yi - s\\n    // from yi - there are 3 xi - s\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n     \\n        int n = rectangles.size();\\n        vector<int> xi, yi;\\n        sort(rectangles.begin(), rectangles.end());\\n        \\n        for(int i=0; i<n; i++) {\\n            xi.push_back(rectangles[i][0]);\\n            yi.push_back(rectangles[i][1]);\\n        }\\n        auto prevIndex = yi.end();\\n        vector<int> height_till_now(101, 0);\\n        int k = points.size();\\n        vector<int> counts(k,0);\\n        vector<pair<vector<int>,int>> pointPairs;\\n        for(int i=0; i<k; i++) pointPairs.push_back({points[i], i});\\n        sort(pointPairs.begin(), pointPairs.end());\\n        int l=k-1;\\n        for(int i=n-1; i>=0 && l>=0; i--) {\\n            auto xii = xi[i];\\n            \\n            while(l>=0 && xii < pointPairs[l].first[0]) {\\n                counts[pointPairs[l].second] = height_till_now[pointPairs[l].first[1]];\\n                l--;\\n            }\\n            \\n            partial_sort(yi.begin()+i, prevIndex, prevIndex);\\n            for(int j=100; j>=1; j--) {\\n                height_till_now[j] += prevIndex - lower_bound(yi.begin()+i, prevIndex, j);\\n            }\\n            prevIndex = yi.begin()+i;\\n        }\\n        \\n        while(l>=0) {\\n            counts[pointPairs[l].second] = height_till_now[pointPairs[l].first[1]];\\n            l--;\\n        }\\n        \\n        return counts;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398692,
                "title": "easy-to-understand-python-binary-search-on-the-x-and-look-for-the-y-coordinate-than-given-point",
                "content": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        rectangles = sorted(rectangles)\\n        res, xc = [], [rectangles[i][0] for i in range(len(rectangles))]\\n        yc = [[0 for _ in range(101)] for _ in range(len(xc))]\\n        yc[-1][rectangles[-1][1]] = 1\\n        for i in range(len(yc) - 2, -1, -1):\\n            for y in range(1, 101):\\n                yc[i][y] = yc[i + 1][y]\\n            yc[i][rectangles[i][1]]+=1 \\n\\n        for x, y in points:\\n            ix, tot = bisect.bisect_left(xc, x), 0\\n            if ix >= len(xc):\\n                res.append(0)\\n                continue\\n            candx = yc[ix]\\n            for i in range(y, 101):\\n                tot+=candx[i]\\n            res.append(tot)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        rectangles = sorted(rectangles)\\n        res, xc = [], [rectangles[i][0] for i in range(len(rectangles))]\\n        yc = [[0 for _ in range(101)] for _ in range(len(xc))]\\n        yc[-1][rectangles[-1][1]] = 1\\n        for i in range(len(yc) - 2, -1, -1):\\n            for y in range(1, 101):\\n                yc[i][y] = yc[i + 1][y]\\n            yc[i][rectangles[i][1]]+=1 \\n\\n        for x, y in points:\\n            ix, tot = bisect.bisect_left(xc, x), 0\\n            if ix >= len(xc):\\n                res.append(0)\\n                continue\\n            candx = yc[ix]\\n            for i in range(y, 101):\\n                tot+=candx[i]\\n            res.append(tot)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371959,
                "title": "c-using-binarysearch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing BinarySearch\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int countGreaterOrEqualXi(vector<int> &X, int x)\\n    {\\n        if(X.size() == 0) return 0;\\n\\n        int pos = X.size();\\n        int beg = 0, end = X.size() - 1;\\n        while(beg <= end)\\n        {\\n            int mid = (beg + end) / 2;\\n            if(x <= X[mid])\\n            {\\n                pos = mid;\\n                end = mid - 1;\\n            }\\n            else beg = mid + 1;\\n        }\\n\\n        return X.size() - pos;\\n    }\\n\\n    int findRectangle(unordered_map<int, vector<int>> &Map, int x, int y)\\n    {\\n        int ans = 0;\\n        for(int i = y; i <= 100; i++)\\n        {\\n            ans += countGreaterOrEqualXi(Map[i], x);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) \\n    {\\n        vector<int> ans;\\n\\n        //HINT : check contraints -> y/h <= 100\\n        unordered_map<int, vector<int>> Map; //y -> x1, x2 .... xn.\\n        for(auto r : rectangles) Map[r[1]].push_back(r[0]);\\n        \\n        for(auto x : Map) sort(Map[x.first].begin(), Map[x.first].end()); \\n\\n        for(auto point : points)\\n        {\\n            ans.push_back(findRectangle(Map, point[0], point[1]));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int countGreaterOrEqualXi(vector<int> &X, int x)\\n    {\\n        if(X.size() == 0) return 0;\\n\\n        int pos = X.size();\\n        int beg = 0, end = X.size() - 1;\\n        while(beg <= end)\\n        {\\n            int mid = (beg + end) / 2;\\n            if(x <= X[mid])\\n            {\\n                pos = mid;\\n                end = mid - 1;\\n            }\\n            else beg = mid + 1;\\n        }\\n\\n        return X.size() - pos;\\n    }\\n\\n    int findRectangle(unordered_map<int, vector<int>> &Map, int x, int y)\\n    {\\n        int ans = 0;\\n        for(int i = y; i <= 100; i++)\\n        {\\n            ans += countGreaterOrEqualXi(Map[i], x);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) \\n    {\\n        vector<int> ans;\\n\\n        //HINT : check contraints -> y/h <= 100\\n        unordered_map<int, vector<int>> Map; //y -> x1, x2 .... xn.\\n        for(auto r : rectangles) Map[r[1]].push_back(r[0]);\\n        \\n        for(auto x : Map) sort(Map[x.first].begin(), Map[x.first].end()); \\n\\n        for(auto point : points)\\n        {\\n            ans.push_back(findRectangle(Map, point[0], point[1]));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355287,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<vector<int>>yTox(101) ;\\n        for(auto& r : rectangles)\\n            yTox[r[1]].push_back(r[0]) ;\\n        \\n        for(auto& xArr : yTox)\\n            sort(xArr.begin(), xArr.end()) ;\\n        \\n        vector<int>ret ;\\n        for(int i = 0 ; i < points.size(); i++){\\n            int x = points[i][0] ;\\n            int y = points[i][1] ;\\n            int count = 0 ;\\n            for(int j = y; j <= 100; j++){\\n                auto& Xarr = yTox[j] ;\\n                count += Xarr.end() - lower_bound(Xarr.begin(), Xarr.end(), x) ;    \\n            }\\n            ret.push_back(count) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<vector<int>>yTox(101) ;\\n        for(auto& r : rectangles)\\n            yTox[r[1]].push_back(r[0]) ;\\n        \\n        for(auto& xArr : yTox)\\n            sort(xArr.begin(), xArr.end()) ;\\n        \\n        vector<int>ret ;\\n        for(int i = 0 ; i < points.size(); i++){\\n            int x = points[i][0] ;\\n            int y = points[i][1] ;\\n            int count = 0 ;\\n            for(int j = y; j <= 100; j++){\\n                auto& Xarr = yTox[j] ;\\n                count += Xarr.end() - lower_bound(Xarr.begin(), Xarr.end(), x) ;    \\n            }\\n            ret.push_back(count) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270462,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* Since x is 10^9, we need to use binary search to go through all values.\\n* As y can be only 100, we simply group all rectangles per y value, and then we do binary search for all rectangles where the height is y or above.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* First, do teh grouping per rectangle height.\\n* Next, sort each group, because it\\'s necessary in order to use the binary search over the list.\\n* For each point:\\n    * For each group where the hight of the rectanlge is y or above\\n    * Find the number of rectangles that have a length at least x, and increase the result.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(p * log(r) + r * log(r)), where p is a number of points, and r is a number of rectangles. The first part is for the binary search algorithm, and the second for groups sorting.\\n- Space complexity:\\nO(r)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Map<Integer, List<Integer>> perH = new HashMap<>();\\n        for (int[] rectangle : rectangles) {\\n            List<Integer> lengths = perH.getOrDefault(rectangle[1], new ArrayList<>());\\n            lengths.add(rectangle[0]);\\n            perH.put(rectangle[1], lengths);\\n        }\\n        for (int i = 1; i <= 100; i++) {\\n            Collections.sort(perH.getOrDefault(i, new ArrayList<>()));\\n        }\\n        int[] result = new int[points.length];\\n        for (int i = 0; i < points.length; i++) {\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            for (int j = y; j <= 100; j++) {\\n                result[i] += bs(perH.getOrDefault(j, new ArrayList<>()), x);\\n            }\\n        }\\n        return result;\\n    }\\n    private int bs(List<Integer> rectangles, int x) {\\n        if (rectangles.size() == 0) {\\n            return 0;\\n        }\\n        int left = 0;\\n        int right = rectangles.size() - 1;\\n        while (left <= right) {\\n            int middle = left + (right - left) / 2;\\n            if (rectangles.get(middle) < x) {\\n                left = middle + 1;\\n            } else {\\n                right = middle - 1;\\n            }\\n        }\\n        return rectangles.size() - left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Map<Integer, List<Integer>> perH = new HashMap<>();\\n        for (int[] rectangle : rectangles) {\\n            List<Integer> lengths = perH.getOrDefault(rectangle[1], new ArrayList<>());\\n            lengths.add(rectangle[0]);\\n            perH.put(rectangle[1], lengths);\\n        }\\n        for (int i = 1; i <= 100; i++) {\\n            Collections.sort(perH.getOrDefault(i, new ArrayList<>()));\\n        }\\n        int[] result = new int[points.length];\\n        for (int i = 0; i < points.length; i++) {\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            for (int j = y; j <= 100; j++) {\\n                result[i] += bs(perH.getOrDefault(j, new ArrayList<>()), x);\\n            }\\n        }\\n        return result;\\n    }\\n    private int bs(List<Integer> rectangles, int x) {\\n        if (rectangles.size() == 0) {\\n            return 0;\\n        }\\n        int left = 0;\\n        int right = rectangles.size() - 1;\\n        while (left <= right) {\\n            int middle = left + (right - left) / 2;\\n            if (rectangles.get(middle) < x) {\\n                left = middle + 1;\\n            } else {\\n                right = middle - 1;\\n            }\\n        }\\n        return rectangles.size() - left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240553,
                "title": "swift-binary-search-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(p * maxY * logp), where maxY <= 100\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func countRectangles(_ rectangles: [[Int]], _ points: [[Int]]) -> [Int] {\\n        var map = rectangles  // [ height: [length_sorted] ] \\n                .reduce(into: [:]){ $0[$1[1], default: []].append($1[0]) }\\n                .mapValues{$0.sorted()}\\n        let maxY = map.max{$0.key < $1.key }!.key\\n        var res = [Int]()\\n\\n        for p in points  {\\n            let (x, y) = (p[0], p[1])\\n            var count = 0\\n            if y > maxY {res.append(0); continue}\\n            for i in y...maxY {\\n                if let lengths = map[i] {\\n                    count += countRects(x, lengths)\\n                }\\n            }\\n            res.append(count)\\n        }\\n        return res\\n    }\\n\\n    // finding count of satisfying rects for a one Y\\n    func countRects(_ target: Int, _ arr: [Int]) -> Int {\\n        var (l, r) = (0, arr.count)\\n        while l < r {\\n            let m = (l + r)/2\\n            if arr[m] >= target {\\n                r = m\\n            } else {\\n                l = m + 1\\n            }\\n        }\\n        return arr.count - l\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    func countRectangles(_ rectangles: [[Int]], _ points: [[Int]]) -> [Int] {\\n        var map = rectangles  // [ height: [length_sorted] ] \\n                .reduce(into: [:]){ $0[$1[1], default: []].append($1[0]) }\\n                .mapValues{$0.sorted()}\\n        let maxY = map.max{$0.key < $1.key }!.key\\n        var res = [Int]()\\n\\n        for p in points  {\\n            let (x, y) = (p[0], p[1])\\n            var count = 0\\n            if y > maxY {res.append(0); continue}\\n            for i in y...maxY {\\n                if let lengths = map[i] {\\n                    count += countRects(x, lengths)\\n                }\\n            }\\n            res.append(count)\\n        }\\n        return res\\n    }\\n\\n    // finding count of satisfying rects for a one Y\\n    func countRects(_ target: Int, _ arr: [Int]) -> Int {\\n        var (l, r) = (0, arr.count)\\n        while l < r {\\n            let m = (l + r)/2\\n            if arr[m] >= target {\\n                r = m\\n            } else {\\n                l = m + 1\\n            }\\n        }\\n        return arr.count - l\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212219,
                "title": "golang-binary-search",
                "content": "```go\\nfunc countRectangles(rectangles [][]int, points [][]int) []int {\\n  // rectangleX contains the x coordinates of all rectangles for each height.\\n  rectangleX := make([][]int, 101)\\n  for _, rectangle := range rectangles {\\n    l, h := rectangle[0], rectangle[1]\\n    rectangleX[h] = append(rectangleX[h], l)\\n  }\\n  // Sort all the X coordinates\\n  for _, x := range rectangleX {\\n    sort.Ints(x)\\n  }\\n  // fmt.Println(rectangleX)\\n  res := make([]int, len(points))\\n  for idx, point := range points {\\n    x, y := point[0], point[1]\\n    for h := y; h <= 100; h++ {\\n      // All rectangles that are greater than the given height contain the point\\n      // Now we also need to verify if their width >= the point\\'s x coordinate.\\n      if len(rectangleX[h]) > 0 {\\n        res[idx] += getCount(rectangleX[h], x)\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\n// getCount uses binary search to get the count of all elements >= the given value\\nfunc getCount(nums []int, x int) int {\\n  var res int\\n  lo, hi := 0, len(nums)-1\\n  for lo <= hi {\\n    mi := lo + (hi - lo)/2\\n    if nums[mi] < x {\\n      lo = mi + 1\\n    } else {\\n      res = len(nums) - mi\\n      hi = mi - 1\\n    }\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```go\\nfunc countRectangles(rectangles [][]int, points [][]int) []int {\\n  // rectangleX contains the x coordinates of all rectangles for each height.\\n  rectangleX := make([][]int, 101)\\n  for _, rectangle := range rectangles {\\n    l, h := rectangle[0], rectangle[1]\\n    rectangleX[h] = append(rectangleX[h], l)\\n  }\\n  // Sort all the X coordinates\\n  for _, x := range rectangleX {\\n    sort.Ints(x)\\n  }\\n  // fmt.Println(rectangleX)\\n  res := make([]int, len(points))\\n  for idx, point := range points {\\n    x, y := point[0], point[1]\\n    for h := y; h <= 100; h++ {\\n      // All rectangles that are greater than the given height contain the point\\n      // Now we also need to verify if their width >= the point\\'s x coordinate.\\n      if len(rectangleX[h]) > 0 {\\n        res[idx] += getCount(rectangleX[h], x)\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\n// getCount uses binary search to get the count of all elements >= the given value\\nfunc getCount(nums []int, x int) int {\\n  var res int\\n  lo, hi := 0, len(nums)-1\\n  for lo <= hi {\\n    mi := lo + (hi - lo)/2\\n    if nums[mi] < x {\\n      lo = mi + 1\\n    } else {\\n      res = len(nums) - mi\\n      hi = mi - 1\\n    }\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3193033,
                "title": "c-easy-fast-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        int n=points.size();\\n        vector<int> ans(n,0);\\n        vector<vector<int>> height(101);\\n\\n        for(int i=0;i<rectangles.size();i++)\\n        {\\n            height[rectangles[i][1]].push_back(rectangles[i][0]);\\n        }\\n\\n        for(int i=1;i<=100;i++)\\n        {\\n            sort(height[i].begin(),height[i].end());\\n        }\\n\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int temp=0;\\n            for(int j=points[i][1];j<=100;j++)\\n            {\\n                int curr=lower_bound(height[j].begin(),height[j].end(),points[i][0])-height[j].begin();\\n                temp+=height[j].size()-curr;\\n            }\\n            ans[i]=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        int n=points.size();\\n        vector<int> ans(n,0);\\n        vector<vector<int>> height(101);\\n\\n        for(int i=0;i<rectangles.size();i++)\\n        {\\n            height[rectangles[i][1]].push_back(rectangles[i][0]);\\n        }\\n\\n        for(int i=1;i<=100;i++)\\n        {\\n            sort(height[i].begin(),height[i].end());\\n        }\\n\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int temp=0;\\n            for(int j=points[i][1];j<=100;j++)\\n            {\\n                int curr=lower_bound(height[j].begin(),height[j].end(),points[i][0])-height[j].begin();\\n                temp+=height[j].size()-curr;\\n            }\\n            ans[i]=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170530,
                "title": "2d-bit-tree-range-update-point-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nadd 1 to area for each rec..prefix_sum(x, y) is the ans to each query\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse BIT to keep track of prefix sum\\ncompress coords cuz some test cases have sparse matrix\\n\\nalso work for duplicates input also.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Nlogn)   \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) for BIT tree + 2 hashmap for val2index look up\\n# Code\\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        // int right = Math.max(maxIndex(0, points), maxIndex(0, rectangles));\\n        // int top = Math.max(maxIndex(1, points), maxIndex(1, rectangles));\\n        //problem, graph maybe sparse..to compress it..\\n        //test case 35 2666 values used in range [0:999782] lmao\\n        HashMap<Integer, Integer> xvals = discretize(0, rectangles, points);\\n        HashMap<Integer, Integer> yvals = discretize(1, rectangles, points);\\n        //keep track of sum set by rec\\n        Fenwick2D bit = new Fenwick2D(xvals.size(), yvals.size()); //make blank 2d tree\\n        //fill in rec nlogn\\n        for(int[] r: rectangles) {\\n            int X = xvals.get(r[0]), Y = yvals.get(r[1]);\\n            bit.range_update(0, 0, X, Y, 1);\\n        }\\n        //\\n        int[] ans = new int[points.length];\\n        //nlogn\\n        for(int i = 0; i < points.length; i++) {\\n            int[] pt = points[i];\\n            int X = xvals.get(pt[0]), Y = yvals.get(pt[1]);\\n            //System.out.println(X + \", \"+ Y);\\n            //System.out.println(bit.prefix_sum(X, Y));\\n            ans[i] = bit.prefix_sum(X, Y); //logn\\n        }\\n        return ans;\\n    }\\n    private HashMap<Integer, Integer> discretize(int i , int[][] rectangles, int[][] points) {\\n        //1 get all uniq vals\\n        Set<Integer> coords = new HashSet<>();\\n        addAll(i, rectangles, coords);\\n        addAll(i, points, coords);\\n        //make arr to return\\n        int [] vals = new int[coords.size()];\\n        int j = 0;\\n        for(int v: coords) {\\n            vals[j++] = v;\\n        }\\n        //remember to sort them!\\n        Arrays.sort(vals);\\n        HashMap<Integer, Integer> val2Idx = new HashMap<Integer, Integer>();\\n        for(j = 0; j < vals.length; j++) {\\n            val2Idx.put(vals[j], j);\\n        }\\n        return val2Idx;\\n    }\\n    private void addAll(int i, int[][] arr, Set<Integer> set) {\\n        for(int[] a: arr) {\\n            set.add(a[i]);\\n        }\\n    }\\n    private int maxIndex(int i, int[][] arr) {\\n        int m = Integer.MIN_VALUE;\\n        for(int[]a: arr) {\\n            m = Math.max(m, a[i]);\\n        }\\n        return m;\\n    }\\n}\\nclass Fenwick2D {\\n    int[][] tree;\\n    int R, C;\\n    public Fenwick2D(int[][] arr) {\\n        this(arr.length, arr[0].length);\\n        //point update nlogn\\n        for(int i = 0; i < R; i++) {\\n            for(int j = 0; j < C; j++) {\\n                //matrix[i][j] = arr[i][j];\\n                this.update_point(i, j, arr[i][j]);\\n            }\\n        }\\n    }\\n    //\"opposiate of \" https://leetcode.com/problems/range-sum-query-2d-mutable/\\n    //lower,left : upper,right\\n    //2d point update, range query . need to switch to 2D Range update, Point query\\n    //or 2d range update, range query ..which require 4 2D tree[][] lmao\\n    public Fenwick2D(int maxX, int maxY) {\\n        R = maxX; C = maxY;\\n        tree = new int[R + 2][C + 2]; // 1-indexeed, +1 for extra prefix..needed for countFloor\\n    }\\n    public int RSB(int X) {\\n        return (X & -X);\\n    }\\n    //point update\\n    public void update_point(int i, int j, int delta) {\\n        for(int r = i + 1; r < tree.length; r+=RSB(r)) {\\n            for(int c = j + 1; c < tree[0].length; c += RSB(c)) {\\n                tree[r][c] += delta;\\n            }\\n        }\\n    }\\n    //[0,0 : i,j] inclusive\\n    public int prefix_sum(int i, int j) {\\n        \\n        int sum = 0;\\n        for(int r = i + 1; r > 0; r-=RSB(r)) {\\n            for(int c = j + 1; c > 0; c -= RSB(c)) {\\n                sum += tree[r][c];\\n            }\\n        }\\n        return sum;\\n    }\\n    // this become useless but we dont need it in this problem https://leetcode.com/problems/range-sum-query-2d-mutable/\\n    // public int range_sum(int r1, int c1, int r2, int c2) {\\n    //     //if(l < 0 || r > N) return Integer.MIN_VALUE;\\n    //     int A = sum(r2, c2);\\n    //     int B = sum(r1 - 1, c2); //top portion\\n    //     int C = sum(r2, c1 - 1); //left portion\\n    //     int D = sum(r1 - 1, c1 - 1);\\n    //     return A - B - C + D;\\n    // }\\n    //logn..since range_update use point_update, each range update make 4 point updates\\n    public void range_update(int r1, int c1, int r2, int c2, int val) {\\n        update_point(r1, c1, val);\\n        update_point(r2 + 1, c2 + 1, val);\\n\\n        update_point(r1, c2 + 1, -val);\\n        update_point(r2 + 1, c1, -val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        // int right = Math.max(maxIndex(0, points), maxIndex(0, rectangles));\\n        // int top = Math.max(maxIndex(1, points), maxIndex(1, rectangles));\\n        //problem, graph maybe sparse..to compress it..\\n        //test case 35 2666 values used in range [0:999782] lmao\\n        HashMap<Integer, Integer> xvals = discretize(0, rectangles, points);\\n        HashMap<Integer, Integer> yvals = discretize(1, rectangles, points);\\n        //keep track of sum set by rec\\n        Fenwick2D bit = new Fenwick2D(xvals.size(), yvals.size()); //make blank 2d tree\\n        //fill in rec nlogn\\n        for(int[] r: rectangles) {\\n            int X = xvals.get(r[0]), Y = yvals.get(r[1]);\\n            bit.range_update(0, 0, X, Y, 1);\\n        }\\n        //\\n        int[] ans = new int[points.length];\\n        //nlogn\\n        for(int i = 0; i < points.length; i++) {\\n            int[] pt = points[i];\\n            int X = xvals.get(pt[0]), Y = yvals.get(pt[1]);\\n            //System.out.println(X + \", \"+ Y);\\n            //System.out.println(bit.prefix_sum(X, Y));\\n            ans[i] = bit.prefix_sum(X, Y); //logn\\n        }\\n        return ans;\\n    }\\n    private HashMap<Integer, Integer> discretize(int i , int[][] rectangles, int[][] points) {\\n        //1 get all uniq vals\\n        Set<Integer> coords = new HashSet<>();\\n        addAll(i, rectangles, coords);\\n        addAll(i, points, coords);\\n        //make arr to return\\n        int [] vals = new int[coords.size()];\\n        int j = 0;\\n        for(int v: coords) {\\n            vals[j++] = v;\\n        }\\n        //remember to sort them!\\n        Arrays.sort(vals);\\n        HashMap<Integer, Integer> val2Idx = new HashMap<Integer, Integer>();\\n        for(j = 0; j < vals.length; j++) {\\n            val2Idx.put(vals[j], j);\\n        }\\n        return val2Idx;\\n    }\\n    private void addAll(int i, int[][] arr, Set<Integer> set) {\\n        for(int[] a: arr) {\\n            set.add(a[i]);\\n        }\\n    }\\n    private int maxIndex(int i, int[][] arr) {\\n        int m = Integer.MIN_VALUE;\\n        for(int[]a: arr) {\\n            m = Math.max(m, a[i]);\\n        }\\n        return m;\\n    }\\n}\\nclass Fenwick2D {\\n    int[][] tree;\\n    int R, C;\\n    public Fenwick2D(int[][] arr) {\\n        this(arr.length, arr[0].length);\\n        //point update nlogn\\n        for(int i = 0; i < R; i++) {\\n            for(int j = 0; j < C; j++) {\\n                //matrix[i][j] = arr[i][j];\\n                this.update_point(i, j, arr[i][j]);\\n            }\\n        }\\n    }\\n    //\"opposiate of \" https://leetcode.com/problems/range-sum-query-2d-mutable/\\n    //lower,left : upper,right\\n    //2d point update, range query . need to switch to 2D Range update, Point query\\n    //or 2d range update, range query ..which require 4 2D tree[][] lmao\\n    public Fenwick2D(int maxX, int maxY) {\\n        R = maxX; C = maxY;\\n        tree = new int[R + 2][C + 2]; // 1-indexeed, +1 for extra prefix..needed for countFloor\\n    }\\n    public int RSB(int X) {\\n        return (X & -X);\\n    }\\n    //point update\\n    public void update_point(int i, int j, int delta) {\\n        for(int r = i + 1; r < tree.length; r+=RSB(r)) {\\n            for(int c = j + 1; c < tree[0].length; c += RSB(c)) {\\n                tree[r][c] += delta;\\n            }\\n        }\\n    }\\n    //[0,0 : i,j] inclusive\\n    public int prefix_sum(int i, int j) {\\n        \\n        int sum = 0;\\n        for(int r = i + 1; r > 0; r-=RSB(r)) {\\n            for(int c = j + 1; c > 0; c -= RSB(c)) {\\n                sum += tree[r][c];\\n            }\\n        }\\n        return sum;\\n    }\\n    // this become useless but we dont need it in this problem https://leetcode.com/problems/range-sum-query-2d-mutable/\\n    // public int range_sum(int r1, int c1, int r2, int c2) {\\n    //     //if(l < 0 || r > N) return Integer.MIN_VALUE;\\n    //     int A = sum(r2, c2);\\n    //     int B = sum(r1 - 1, c2); //top portion\\n    //     int C = sum(r2, c1 - 1); //left portion\\n    //     int D = sum(r1 - 1, c1 - 1);\\n    //     return A - B - C + D;\\n    // }\\n    //logn..since range_update use point_update, each range update make 4 point updates\\n    public void range_update(int r1, int c1, int r2, int c2, int val) {\\n        update_point(r1, c1, val);\\n        update_point(r2 + 1, c2 + 1, val);\\n\\n        update_point(r1, c2 + 1, -val);\\n        update_point(r2 + 1, c1, -val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121950,
                "title": "python3-sortedlist",
                "content": "he is too lazy to write any explaination\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countRectangles(self, rec: List[List[int]], points: List[List[int]]) -> List[int]:\\n        for a,b in points:\\n            rec.append([a,-b-1])\\n        rec.sort(key=lambda x:(-x[0],-x[1]))\\n        pool = SortedList()\\n        ans=dict()\\n        for a,b in rec:\\n            if(b>=0):\\n                pool.add(b)\\n            else:\\n                b=-(b+1)\\n                ans[(a,b)]=len(pool)-pool.bisect_left(b)\\n        ansl=[]\\n        for a,b in points:\\n            ansl.append(ans[(a,b)])\\n        return ansl\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countRectangles(self, rec: List[List[int]], points: List[List[int]]) -> List[int]:\\n        for a,b in points:\\n            rec.append([a,-b-1])\\n        rec.sort(key=lambda x:(-x[0],-x[1]))\\n        pool = SortedList()\\n        ans=dict()\\n        for a,b in rec:\\n            if(b>=0):\\n                pool.add(b)\\n            else:\\n                b=-(b+1)\\n                ans[(a,b)]=len(pool)-pool.bisect_left(b)\\n        ansl=[]\\n        for a,b in points:\\n            ansl.append(ans[(a,b)])\\n        return ansl\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824111,
                "title": "python-from-brute-force-to-binary-search",
                "content": "# **1. BRUTE FORCE APPROACH - TLE**\\nA Brute force approach is never going to work as the constraints say the length of the lists can be up to 5 * 10^4!\\n\\nBut, from here, we can start thinking of how we can optimize this solution such that it is accepted.\\n\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        # Output array to return\\n        count = []\\n        \\n        # For each point\\n        for point in points:\\n            # Go through each rectangle and check if this point lies in this rectangle or not\\n            rectCount = 0\\n            for rectangle in rectangles:\\n                # If this rectangle contains this point, increment the count for this point\\n                if point[0] <= rectangle[0] and point[1] <= rectangle[1]: rectCount += 1\\n            \\n            # And append the count we get after the above loop in the final output array\\n            count.append(rectCount)\\n            \\n        return count\\n\\t\\t\\n# **2. BINARY SEARCH APPROACH**\\n\\nWe see that the main reason why the Brute Force approach is failing for large inputs is because for every point, we have to traverse the rectangles list from beginning to end. But if you take a look at the constraints carefully, while the lengths can be up to  10^9, the heights can be up to 100 only. And this constraint is given for a reason. Because we have to map the lengths based on the heights.\\n\\nSee, since height can be from 1 to 100, we know that for any point, any rectangle that contains that point should have height >= point[1]. For if we already know that for heights >= point[1], how many rectangles are there and what are their lengths, then all that is left to find is how many rectangles have length >= point[0]. And to optimize that, we can use Binary Search if the rectangles list is alrady sorted based on the lengths. Because in that case, we know that if one rectangle contains a point, all rectangles after it contain it as well. So all that we want is the leftmost rectangle that contains a particular point.\\n\\n\\tTake this example - rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]\\n\\t\\n\\tThe list is already in sorted order. \\n\\t\\n\\tWe will create a map where key is the height and value is a list \\n\\tcontaining the lengths of rectangles with that height.\\n\\t\\n\\tHence, for above list, our map is like - \\n\\t\\n\\tdict = { 2: [1], 3: [2, 3, 6], 5: [2]}\\n\\t\\n\\tIt means, for height = 3, we have 3 rectangles with lengths 2, 3 and 6.\\n\\t\\n\\nNow, for each point, all we want to do is traverse over all the lists of heights where height >= point[1].\\n\\n\\tFirst point is [1,3]. It means, \"y\" value is 3. \\n\\t\\n\\tSo any rectangle with height >= 3 should be a candidate. \\n\\t\\n\\tHence, we traverse from heights 3 to 100 (since 100 is the upper limit)\\n\\t\\n\\tAnd for each height in the map, for its corresponding list, we can use Binary Search.\\n\\t\\nWe Binary search for the leftmost length such that length >= point[0]\\n\\t\\nAnd once we get the leftmost index, we increment count by len(dict[height]) - leftmostIndex\\n\\n```\\ndef countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        # Output array to return\\n        count = []\\n        \\n        # Why did we get TLE in the above approach?\\n        # Because for every point, we have to traverse the array from the beginning to the end\\n        \\n        # First, let us sort the rectangles as per their lengths\\n        rectangles.sort()\\n        \\n        # The problem constrains say that height can be from 1 to 100\\n        # So we can track how many rectangles are there with a certain height\\n        dict = defaultdict(list)\\n        \\n        # For each height, we can keep the length of a rectangle in a corresponding list\\n        # Since we already sorted the rectangles list above by lengths, no need to worry about the order here\\n        for rectangle in rectangles: dict[rectangle[1]].append(rectangle[0])\\n        \\n        # Now, for each point\\n        for point in points:\\n            rectCount = 0\\n            \\n            # We know that point[1] is the \"y\" axis value of that point\\n            # So, any rectangle with height >= y should contain that point, right?\\n            # Given, the rectangle also has length >= point[0]\\n            for height in range(point[1], 101):\\n                \\n                # And now, we can apply Binary search to find the leftmost length of rectangle that contains this point\\n                # Once we find that, we know all lengths after that are also containing this point since list is sorted\\n                if height in dict:\\n                    lengths = dict[height]\\n                    \\n                    start = 0\\n                    end = len(lengths) - 1\\n                    leftmostIndex = -1\\n                    \\n                    while start <= end:\\n                        mid = start + (end - start) // 2\\n                        \\n                        if lengths[mid] >= point[0]:\\n                            leftmostIndex = mid\\n                            end = mid - 1\\n                        else: start = mid + 1\\n                            \\n                    if leftmostIndex != -1:\\n                        rectCount += len(dict[height]) - leftmostIndex\\n                    \\n            count.append(rectCount)\\n        \\n        return count\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        # Output array to return\\n        count = []\\n        \\n        # Why did we get TLE in the above approach?\\n        # Because for every point, we have to traverse the array from the beginning to the end\\n        \\n        # First, let us sort the rectangles as per their lengths\\n        rectangles.sort()\\n        \\n        # The problem constrains say that height can be from 1 to 100\\n        # So we can track how many rectangles are there with a certain height\\n        dict = defaultdict(list)\\n        \\n        # For each height, we can keep the length of a rectangle in a corresponding list\\n        # Since we already sorted the rectangles list above by lengths, no need to worry about the order here\\n        for rectangle in rectangles: dict[rectangle[1]].append(rectangle[0])\\n        \\n        # Now, for each point\\n        for point in points:\\n            rectCount = 0\\n            \\n            # We know that point[1] is the \"y\" axis value of that point\\n            # So, any rectangle with height >= y should contain that point, right?\\n            # Given, the rectangle also has length >= point[0]\\n            for height in range(point[1], 101):\\n                \\n                # And now, we can apply Binary search to find the leftmost length of rectangle that contains this point\\n                # Once we find that, we know all lengths after that are also containing this point since list is sorted\\n                if height in dict:\\n                    lengths = dict[height]\\n                    \\n                    start = 0\\n                    end = len(lengths) - 1\\n                    leftmostIndex = -1\\n                    \\n                    while start <= end:\\n                        mid = start + (end - start) // 2\\n                        \\n                        if lengths[mid] >= point[0]:\\n                            leftmostIndex = mid\\n                            end = mid - 1\\n                        else: start = mid + 1\\n                            \\n                    if leftmostIndex != -1:\\n                        rectCount += len(dict[height]) - leftmostIndex\\n                    \\n            count.append(rectCount)\\n        \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2806150,
                "title": "c-iterative-segment-tree",
                "content": "We build a binary segment tree with the base layer being 128 elements wide (since the height is at most 100). We can construct it iteratively/ bottom-up by sorting the rectangles by the length (the side to later to binary search on), so that smaller lengths always come first.\\n\\nWe query the tree from the height of the query point, up to the max-element, by specifying the left and right bounds for each level, and moving up one level in each move `>>= 1`.\\n\\nThe `right` is exclusive, so if we are on a right-hand-side leaf, we have to do the binary-search-addition operation on the node one left to it. For this we index the tree 1-based so that we can check the least-significant bit with `index & 1`. The left is inclusive, so here we have to calculate its value if it\\'s on the right-hand-side, and then jump the left over to the right side, since we already exhausted the left side.\\n\\nIdea taken from this blog post: https://codeforces.com/blog/entry/18051\\n\\n```\\nclass Solution {\\npublic:\\n    // bottom layer needs 101 entries, so pad to binary 2**7 128\\n    vector<vector<int>> tree;\\n    int bottom = 128;\\n    \\n    void insert(int i, int val) {\\n        while (i > 1) {\\n            tree[i].push_back(val);\\n            i >>= 1;\\n        }\\n    }\\n    \\n    int query(int left, int val) {\\n        int right = bottom + 101;\\n        int ret = 0;\\n        while (left < right) {\\n            if (left & 1) {\\n                ret += distance(lower_bound(tree[left].begin(), tree[left].end(), val),\\n                               tree[left].end());\\n                left++;\\n            }\\n            left >>= 1;\\n            if (right & 1) {\\n                ret += distance(lower_bound(tree[right^1].begin(), tree[right^1].end(), val),\\n                                tree[right^1].end());\\n            }\\n            right >>= 1;\\n        }\\n        return ret;\\n    }\\n    \\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        tree.resize(260);\\n        sort(rectangles.begin(), rectangles.end());\\n        for (auto& rect: rectangles) {\\n            insert(bottom + rect[1], rect[0]);\\n        }\\n        \\n        vector<int> ret;\\n        ret.reserve(points.size());\\n        for (auto& point: points) {\\n            ret.emplace_back(query(bottom + point[1], point[0]));\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // bottom layer needs 101 entries, so pad to binary 2**7 128\\n    vector<vector<int>> tree;\\n    int bottom = 128;\\n    \\n    void insert(int i, int val) {\\n        while (i > 1) {\\n            tree[i].push_back(val);\\n            i >>= 1;\\n        }\\n    }\\n    \\n    int query(int left, int val) {\\n        int right = bottom + 101;\\n        int ret = 0;\\n        while (left < right) {\\n            if (left & 1) {\\n                ret += distance(lower_bound(tree[left].begin(), tree[left].end(), val),\\n                               tree[left].end());\\n                left++;\\n            }\\n            left >>= 1;\\n            if (right & 1) {\\n                ret += distance(lower_bound(tree[right^1].begin(), tree[right^1].end(), val),\\n                                tree[right^1].end());\\n            }\\n            right >>= 1;\\n        }\\n        return ret;\\n    }\\n    \\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        tree.resize(260);\\n        sort(rectangles.begin(), rectangles.end());\\n        for (auto& rect: rectangles) {\\n            insert(bottom + rect[1], rect[0]);\\n        }\\n        \\n        vector<int> ret;\\n        ret.reserve(points.size());\\n        for (auto& point: points) {\\n            ret.emplace_back(query(bottom + point[1], point[0]));\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785840,
                "title": "python-3-3-lines-bisect-left",
                "content": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        \\n        y, res = [[] for _ in range(100)], []\\n        for rect in rectangles: insort(y[rect[1]-1], rect[0])\\n        return [sum([len(y[j]) - bisect_left(y[j], point[0]) for j in range(point[1]-1, 100)]) for point in points]\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        \\n        y, res = [[] for _ in range(100)], []\\n        for rect in rectangles: insort(y[rect[1]-1], rect[0])\\n        return [sum([len(y[j]) - bisect_left(y[j], point[0]) for j in range(point[1]-1, 100)]) for point in points]\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2778498,
                "title": "c-concise",
                "content": "```\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<vector<int>> rects(101); //y, {xi}\\n        for(auto& v:rectangles) rects[v[1]].push_back(v[0]);\\n        for(auto& v:rects) sort(v.begin(), v.end());\\n        vector<int> res;\\n        for(auto& p:points){\\n            int x = p[0], y = p[1], cnt = 0;\\n            for(int i=y;i<101;i++) {\\n                auto& v = rects[i];\\n                cnt  += v.end() - lower_bound(v.begin(), v.end(), x);\\n            }\\n            res.push_back(cnt);\\n        }\\n        return res;                        \\n    }",
                "solutionTags": [],
                "code": "```\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<vector<int>> rects(101); //y, {xi}\\n        for(auto& v:rectangles) rects[v[1]].push_back(v[0]);\\n        for(auto& v:rects) sort(v.begin(), v.end());\\n        vector<int> res;\\n        for(auto& p:points){\\n            int x = p[0], y = p[1], cnt = 0;\\n            for(int i=y;i<101;i++) {\\n                auto& v = rects[i];\\n                cnt  += v.end() - lower_bound(v.begin(), v.end(), x);\\n            }\\n            res.push_back(cnt);\\n        }\\n        return res;                        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2774314,
                "title": "c-easy-binary-search",
                "content": "```\\nclass Solution {\\n    int utilfunc(vector<int> &nums,int x)\\n    {\\n        int l=0;\\n        int h = nums.size()-1;\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            int mid = (l+(h-l)/2);\\n            if(nums[mid]>=x)\\n            {\\n                ans = nums.size()-mid;\\n                h = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& arr, vector<vector<int>>& points) {\\n    \\n        vector<vector<int>> dp(101);\\n        for(auto it : arr)\\n        {\\n            dp[it[1]].push_back(it[0]);\\n        }\\n        \\n        for(int i=0;i<101;i++)\\n        {\\n            sort(dp[i].begin(),dp[i].end());\\n        }\\n        \\n        vector<int> ans;\\n        for(auto it : points)\\n        {\\n            int l = it[0];\\n            int h = it[1];\\n            int sum = 0;\\n            for(int i=h;i<101;i++)\\n            {\\n                sum += utilfunc(dp[i],l);\\n            }\\n            ans.push_back(sum);\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    int utilfunc(vector<int> &nums,int x)\\n    {\\n        int l=0;\\n        int h = nums.size()-1;\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            int mid = (l+(h-l)/2);\\n            if(nums[mid]>=x)\\n            {\\n                ans = nums.size()-mid;\\n                h = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& arr, vector<vector<int>>& points) {\\n    \\n        vector<vector<int>> dp(101);\\n        for(auto it : arr)\\n        {\\n            dp[it[1]].push_back(it[0]);\\n        }\\n        \\n        for(int i=0;i<101;i++)\\n        {\\n            sort(dp[i].begin(),dp[i].end());\\n        }\\n        \\n        vector<int> ans;\\n        for(auto it : points)\\n        {\\n            int l = it[0];\\n            int h = it[1];\\n            int sum = 0;\\n            for(int i=h;i<101;i++)\\n            {\\n                sum += utilfunc(dp[i],l);\\n            }\\n            ans.push_back(sum);\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690900,
                "title": "good-question-c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int bsearch(vector<int> &nums, int k){\\n        int l=0, h=nums.size()-1;\\n        \\n        int res=nums.size();\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            \\n            if(nums[mid]>=k){\\n                h=mid-1;\\n                res=mid;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> countRectangles(vector<vector<int>>& rect, vector<vector<int>>& points) {\\n        \\n        unordered_map<int, vector<int>> htl;\\n        vector<int> ans;\\n        for(int i=0; i<rect.size(); i++){       \\n            htl[rect[i][1]].push_back(rect[i][0]);\\n        }\\n        \\n        for(int i=0; i<=100; i++){\\n            sort(htl[i].begin(), htl[i].end());\\n        }\\n        \\n        for(auto p:points){\\n            int x=p[0], y=p[1];\\n            int sum=0;\\n            for(int a=y; a<=100; a++){\\n                if(htl.find(a)!=htl.end())\\n                    sum+=(htl[a].size()-bsearch(htl[a], x));\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bsearch(vector<int> &nums, int k){\\n        int l=0, h=nums.size()-1;\\n        \\n        int res=nums.size();\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            \\n            if(nums[mid]>=k){\\n                h=mid-1;\\n                res=mid;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> countRectangles(vector<vector<int>>& rect, vector<vector<int>>& points) {\\n        \\n        unordered_map<int, vector<int>> htl;\\n        vector<int> ans;\\n        for(int i=0; i<rect.size(); i++){       \\n            htl[rect[i][1]].push_back(rect[i][0]);\\n        }\\n        \\n        for(int i=0; i<=100; i++){\\n            sort(htl[i].begin(), htl[i].end());\\n        }\\n        \\n        for(auto p:points){\\n            int x=p[0], y=p[1];\\n            int sum=0;\\n            for(int a=y; a<=100; a++){\\n                if(htl.find(a)!=htl.end())\\n                    sum+=(htl[a].size()-bsearch(htl[a], x));\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603775,
                "title": "python-binary-search-solution",
                "content": "```\\ndef countRectangles(self, rects: List[List[int]], points: List[List[int]]) -> List[int]:\\n\\tans, mp = [0]*len(points), defaultdict(list)\\n\\tfor w, h in rects:\\n\\t\\tmp[h].append(w)\\n\\tfor h in mp:\\n\\t\\tmp[h].sort()\\n\\t\\tfor i in range(len(points)):\\n\\t\\t\\tif points[i][1]>h:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tans[i] += len(mp[h]) - bisect.bisect_left(mp[h], points[i][0])\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef countRectangles(self, rects: List[List[int]], points: List[List[int]]) -> List[int]:\\n\\tans, mp = [0]*len(points), defaultdict(list)\\n\\tfor w, h in rects:\\n\\t\\tmp[h].append(w)\\n\\tfor h in mp:\\n\\t\\tmp[h].sort()\\n\\t\\tfor i in range(len(points)):\\n\\t\\t\\tif points[i][1]>h:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tans[i] += len(mp[h]) - bisect.bisect_left(mp[h], points[i][0])\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2594981,
                "title": "python-create-an-index-binary-search-88",
                "content": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        num_points = len(points)\\n        count = [0] * num_points\\n        \\n        # Create an index of the rectangles on y value.\\n        rect_index = [[] for i in range(101)]\\n        \\n        for x, y in rectangles:\\n            rect_index[y].append(x)\\n            \\n        # Sort each list of rectangles to facilitate quick\\n        # lookup on x value.\\n        for rect_list in rect_index:\\n            rect_list.sort()\\n            \\n        for i, [p_x, p_y] in enumerate(points):\\n            for y in range (p_y, 101):\\n                # As all rectangles are distinct, we need\\n                # not worry about multiple x values.\\n                count[i] += len(rect_index[y]) - bisect_left(rect_index[y], p_x)\\n                \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        num_points = len(points)\\n        count = [0] * num_points\\n        \\n        # Create an index of the rectangles on y value.\\n        rect_index = [[] for i in range(101)]\\n        \\n        for x, y in rectangles:\\n            rect_index[y].append(x)\\n            \\n        # Sort each list of rectangles to facilitate quick\\n        # lookup on x value.\\n        for rect_list in rect_index:\\n            rect_list.sort()\\n            \\n        for i, [p_x, p_y] in enumerate(points):\\n            for y in range (p_y, 101):\\n                # As all rectangles are distinct, we need\\n                # not worry about multiple x values.\\n                count[i] += len(rect_index[y]) - bisect_left(rect_index[y], p_x)\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568652,
                "title": "python-ugly-solution",
                "content": "I do not like that task because of the trick with height - we use the fact that it is between 0 and 100.\\n```\\nclass Solution:\\n    \\n    def bs(self, x, ar):\\n        if x > ar[-1]:\\n            return len(ar)\\n        if x <= ar[0]:\\n            return 0\\n        \\n        l, r = 0, len(ar) - 1\\n        \\n        while l <= r:\\n            mid = l + (r - l) // 2\\n            if ar[mid] >= x:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n            \\n        return l\\n\\n        \\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n    \\n        ans = [0] * len(points)\\n        rectangles.sort()\\n        R = [[] for _ in range(101)]\\n        for [l, h] in rectangles:\\n            R[h].append(l)\\n        for idx, [x, i] in enumerate(points):\\n            c = 0\\n            for y in range(i, 101):\\n                if R[y]:\\n                    c += len(R[y]) - self.bs(x, R[y]) \\n            ans[idx] = c\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def bs(self, x, ar):\\n        if x > ar[-1]:\\n            return len(ar)\\n        if x <= ar[0]:\\n            return 0\\n        \\n        l, r = 0, len(ar) - 1\\n        \\n        while l <= r:\\n            mid = l + (r - l) // 2\\n            if ar[mid] >= x:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n            \\n        return l\\n\\n        \\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n    \\n        ans = [0] * len(points)\\n        rectangles.sort()\\n        R = [[] for _ in range(101)]\\n        for [l, h] in rectangles:\\n            R[h].append(l)\\n        for idx, [x, i] in enumerate(points):\\n            c = 0\\n            for y in range(i, 101):\\n                if R[y]:\\n                    c += len(R[y]) - self.bs(x, R[y]) \\n            ans[idx] = c\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563140,
                "title": "c-map-lower-bound",
                "content": "This solution is based on https://leetcode.com/problems/count-number-of-rectangles-containing-each-point/discuss/1976969/Java-C%2B%2B-Python-Detailed-Explanation-fully-commented-Binary-Search-l-among-points-of-h\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        map<int /* heights */, vector<int> /* lengths */> rects;\\n        \\n        for (auto r: rectangles)\\n            rects[r[1]].emplace_back(r[0]);\\n        \\n        /* Sort all x\\'s so lower_bound can be applier */\\n        for (auto &r: rects)\\n            sort(r.second.begin(), r.second.end());\\n\\n        vector<int> answer;\\n        int count;\\n        for (auto p: points) {\\n            count = 0;\\n            \\n            for (auto it = rects.rbegin(); it != rects.rend(); ++it) {\\n                int y = it->first;\\n                auto &x_vec = it->second;\\n                if (p[1] > y) /* No need to go futher left */\\n                    break;\\n\\n                auto ub = lower_bound(x_vec.begin(), x_vec.end(), p[0]);\\n                count += distance(ub, x_vec.end());\\n            }\\n            answer.emplace_back(count);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        map<int /* heights */, vector<int> /* lengths */> rects;\\n        \\n        for (auto r: rectangles)\\n            rects[r[1]].emplace_back(r[0]);\\n        \\n        /* Sort all x\\'s so lower_bound can be applier */\\n        for (auto &r: rects)\\n            sort(r.second.begin(), r.second.end());\\n\\n        vector<int> answer;\\n        int count;\\n        for (auto p: points) {\\n            count = 0;\\n            \\n            for (auto it = rects.rbegin(); it != rects.rend(); ++it) {\\n                int y = it->first;\\n                auto &x_vec = it->second;\\n                if (p[1] > y) /* No need to go futher left */\\n                    break;\\n\\n                auto ub = lower_bound(x_vec.begin(), x_vec.end(), p[0]);\\n                count += distance(ub, x_vec.end());\\n            }\\n            answer.emplace_back(count);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553624,
                "title": "c-sorting-map-cleanest-code-easiest-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        map<int,vector<int>> mp;\\n        for(auto v:rectangles){\\n            mp[v[1]].push_back(v[0]);\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            sort(it->second.begin(),it->second.end());\\n        }\\n        //notice how I am using pointers here\\n       \\n        vector<int> res(points.size(),0);\\n        for(int i=0;i<points.size();i++){\\n            int sum=0;\\n            int x=points[i][0],y=points[i][1];\\n            for(int k=y;k<=100;k++){\\n                vector<int>& v=mp[k];\\n                if(v.empty()){\\n                    continue;\\n                }\\n                sum+=v.size()-(lower_bound(v.begin(),v.end(),x)-v.begin());\\n            }\\n            res[i]=sum;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        map<int,vector<int>> mp;\\n        for(auto v:rectangles){\\n            mp[v[1]].push_back(v[0]);\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            sort(it->second.begin(),it->second.end());\\n        }\\n        //notice how I am using pointers here\\n       \\n        vector<int> res(points.size(),0);\\n        for(int i=0;i<points.size();i++){\\n            int sum=0;\\n            int x=points[i][0],y=points[i][1];\\n            for(int k=y;k<=100;k++){\\n                vector<int>& v=mp[k];\\n                if(v.empty()){\\n                    continue;\\n                }\\n                sum+=v.size()-(lower_bound(v.begin(),v.end(),x)-v.begin());\\n            }\\n            res[i]=sum;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531392,
                "title": "python-simple-binary-search",
                "content": "\\n    def countRectangles(self, rectangles, points):\\n        rectangles.sort(key = lambda x: x[0])\\n        \\n        dict1 = defaultdict(list)\\n        \\n        for l, h in rectangles:\\n            dict1[h].append(l)\\n            \\n        def dfs(x,y):\\n            count = 0\\n            \\n            for h in range(y,101):\\n                count += len(dict1[h]) - bisect.bisect_left(dict1[h],x)\\n                \\n            return count\\n        \\n        return [dfs(x,y) for x,y in points]",
                "solutionTags": [],
                "code": "\\n    def countRectangles(self, rectangles, points):\\n        rectangles.sort(key = lambda x: x[0])\\n        \\n        dict1 = defaultdict(list)\\n        \\n        for l, h in rectangles:\\n            dict1[h].append(l)\\n            \\n        def dfs(x,y):\\n            count = 0\\n            \\n            for h in range(y,101):\\n                count += len(dict1[h]) - bisect.bisect_left(dict1[h],x)\\n                \\n            return count\\n        \\n        return [dfs(x,y) for x,y in points]",
                "codeTag": "Python3"
            },
            {
                "id": 2515143,
                "title": "c-easy-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& re, vector<vector<int>>& points) {\\n        \\n        vector<vector<int>> mad(101);\\n        for(int i=0;i<re.size();i++)\\n        {\\n            mad[re[i][1]].push_back(re[i][0]);\\n        }\\n        for(int i=1;i<=100;i++)\\n        {\\n            sort(mad[i].begin(),mad[i].end());\\n        }\\n        vector<int> ans(points.size());\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int a=0;\\n            for(int j=points[i][1];j<=100;j++)\\n            {\\n                auto it=lower_bound(mad[j].begin(),mad[j].end(),points[i][0]);\\n                a+=(mad[j].size())-(it-mad[j].begin());\\n            }\\n            ans[i]=a;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& re, vector<vector<int>>& points) {\\n        \\n        vector<vector<int>> mad(101);\\n        for(int i=0;i<re.size();i++)\\n        {\\n            mad[re[i][1]].push_back(re[i][0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2389750,
                "title": "python-binary-search-simple-intutive",
                "content": "```class Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        def bin_sch(arr,tar):\\n            low = 0\\n            high = len(arr)-1\\n            ans = len(arr)\\n            while low <= high:\\n                mid = (low+high)//2\\n                if arr[mid] >= tar:\\n                    ans = mid\\n                    high = mid-1\\n                else:\\n                    low = mid+1\\n            return ans\\n        h = defaultdict(list)\\n        for rect in rectangles:\\n            h[rect[1]].append(rect[0])\\n        for i in range(101):\\n            h[i].sort()\\n        ans = []\\n        for q in points:\\n            x = q[0]\\n            y = q[1]\\n            count = 0\\n            for i in range(y,101):\\n                if i in h:\\n                    count += len(h[i])-bin_sch(h[i],x)\\n            ans.append(count)\\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```class Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        def bin_sch(arr,tar):\\n            low = 0\\n            high = len(arr)-1\\n            ans = len(arr)\\n            while low <= high:\\n                mid = (low+high)//2\\n                if arr[mid] >= tar:\\n                    ans = mid\\n                    high = mid-1\\n                else:\\n                    low = mid+1\\n            return ans\\n        h = defaultdict(list)\\n        for rect in rectangles:\\n            h[rect[1]].append(rect[0])\\n        for i in range(101):\\n            h[i].sort()\\n        ans = []\\n        for q in points:\\n            x = q[0]\\n            y = q[1]\\n            count = 0\\n            for i in range(y,101):\\n                if i in h:\\n                    count += len(h[i])-bin_sch(h[i],x)\\n            ans.append(count)\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2376662,
                "title": "java-o-100nlgn",
                "content": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rcs, int[][] pts) {\\n        TreeMap<Integer, Integer>[] cnt = new TreeMap[101];\\n        for(int h = 1; h <= 100; h++) {\\n            cnt[h] = new TreeMap<>();\\n        }\\n        for(int[] rc: rcs) {\\n            int l = rc[0], h = rc[1];\\n            cnt[h].put(l, cnt[h].getOrDefault(l, 0) + 1);\\n        }\\n        \\n        int acc = 0;\\n        for(int h = 1; h <= 100; h++) {\\n            acc = 0;\\n            for(Integer k: cnt[h].descendingKeySet()) {\\n                acc += cnt[h].get(k);\\n                cnt[h].put(k, acc);\\n            }\\n        }\\n        int len = pts.length;\\n        int[] ans = new int[len];\\n        \\n        for(int i = 0; i < len; i++) {\\n            int y = pts[i][1], x = pts[i][0];\\n            int ret = 0;\\n            for(int h = y; h <= 100; h++) {\\n                Integer k = cnt[h].ceilingKey(x);\\n                if(k == null) continue;\\n                ret += cnt[h].get(k);\\n            }\\n            ans[i] = ret;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rcs, int[][] pts) {\\n        TreeMap<Integer, Integer>[] cnt = new TreeMap[101];\\n        for(int h = 1; h <= 100; h++) {\\n            cnt[h] = new TreeMap<>();\\n        }\\n        for(int[] rc: rcs) {\\n            int l = rc[0], h = rc[1];\\n            cnt[h].put(l, cnt[h].getOrDefault(l, 0) + 1);\\n        }\\n        \\n        int acc = 0;\\n        for(int h = 1; h <= 100; h++) {\\n            acc = 0;\\n            for(Integer k: cnt[h].descendingKeySet()) {\\n                acc += cnt[h].get(k);\\n                cnt[h].put(k, acc);\\n            }\\n        }\\n        int len = pts.length;\\n        int[] ans = new int[len];\\n        \\n        for(int i = 0; i < len; i++) {\\n            int y = pts[i][1], x = pts[i][0];\\n            int ret = 0;\\n            for(int h = y; h <= 100; h++) {\\n                Integer k = cnt[h].ceilingKey(x);\\n                if(k == null) continue;\\n                ret += cnt[h].get(k);\\n            }\\n            ans[i] = ret;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351713,
                "title": "java-easy-to-understand-o-nlogn-nh-qlogn",
                "content": "### Solution idea:\\n1. Sort points by X axis and for same X, sort by Y\\n2. For all rectangle, maintain a list of X for all `0` to `Y`\\n3. Now problem becomes simple, for each query point (x,y)\\n\\t* Get the list of X = Rectangles are possible total rectangles covering the given point\\n\\t* Get Lower bound for `x` = Rectangles are not covering the point\\n\\t* Ans = total - lower_bound\\n\\n**Runtime:** O(NlogN + NH + QlogN)\\n\\n```java\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Arrays.sort(rectangles, (a,b)->a[0]-b[0]==0?a[1]-b[1]:a[0]-b[0]);\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int rec[] : rectangles) {\\n            for(int y=0;y<=rec[1];y++) {\\n                map.computeIfAbsent(y, k->new ArrayList<Integer>())\\n                    .add(rec[0]);\\n            }\\n        }\\n        int[] ans = new int[points.length];\\n        for(int qi=0;qi<points.length;qi++) {\\n            ans[qi]=search(map.get(points[qi][1]), points[qi][0]);\\n        }\\n        return ans;\\n    }\\n    \\n    private int search(List<Integer> list, int target) {\\n        if(list==null) return 0;\\n        int lo=0;\\n        int hi=list.size()-1;\\n        int ans = 0;\\n        while(lo<=hi) {\\n            int m = (lo+hi)/2;\\n            if(list.get(m) < target) {\\n                ans = m+1;\\n                lo=m+1;\\n            }\\n            else {\\n                hi=m-1;\\n            }\\n        }\\n        return list.size() - ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Arrays.sort(rectangles, (a,b)->a[0]-b[0]==0?a[1]-b[1]:a[0]-b[0]);\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int rec[] : rectangles) {\\n            for(int y=0;y<=rec[1];y++) {\\n                map.computeIfAbsent(y, k->new ArrayList<Integer>())\\n                    .add(rec[0]);\\n            }\\n        }\\n        int[] ans = new int[points.length];\\n        for(int qi=0;qi<points.length;qi++) {\\n            ans[qi]=search(map.get(points[qi][1]), points[qi][0]);\\n        }\\n        return ans;\\n    }\\n    \\n    private int search(List<Integer> list, int target) {\\n        if(list==null) return 0;\\n        int lo=0;\\n        int hi=list.size()-1;\\n        int ans = 0;\\n        while(lo<=hi) {\\n            int m = (lo+hi)/2;\\n            if(list.get(m) < target) {\\n                ans = m+1;\\n                lo=m+1;\\n            }\\n            else {\\n                hi=m-1;\\n            }\\n        }\\n        return list.size() - ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338150,
                "title": "c-binary-search-bucket-sort",
                "content": "One version works but anothe slightly-modified version got TLE.\\nThe accepted version:\\n```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>> &rectangles, vector<vector<int>> &points) {\\n        sort(rectangles.begin(), rectangles.end());\\n        map<int, vector<int> > mm;\\n        for (auto i : rectangles) {\\n            mm[i[1]].push_back(i[0]);\\n        }\\n        vector<int> res;\\n        for (auto point : points) {\\n            int cnt = 0;\\n            int x = point[0], y = point[1];\\n            auto iter = mm.lower_bound(y);\\n            for (; iter != mm.end(); iter++) {\\n                auto lower = lower_bound(iter->second.begin(), iter->second.end(), x);\\n                cnt += (iter->second.end() - lower);\\n            }\\n            res.push_back(cnt);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nWhile this version got tle:\\n```\\n    vector<int> countRectangles(vector<vector<int>> &rectangles, vector<vector<int>> &points) {\\n        sort(rectangles.begin(), rectangles.end());\\n        map<int, vector<int> > mm;\\n        for (auto i : rectangles) {\\n            mm[i[1]].push_back(i[0]);\\n        }\\n        vector<int> res;\\n        for (auto point : points) {\\n            int cnt = 0;\\n            int x = point[0], y = point[1];\\n            auto iter = mm.lower_bound(y);\\n            for (; iter != mm.end(); iter++) {\\n\\t\\t\\t\\t// the only modification, replace iter->second with tmp, got tle\\n                auto tmp = iter->second;\\n                auto lower = lower_bound(tmp.begin(), tmp.end(), x);\\n                cnt += (tmp.end() - lower);\\n            }\\n\\n            res.push_back(cnt);\\n        }\\n        return res;\\n    }\\n```\\nCan anyone help to figure out the reason?",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>> &rectangles, vector<vector<int>> &points) {\\n        sort(rectangles.begin(), rectangles.end());\\n        map<int, vector<int> > mm;\\n        for (auto i : rectangles) {\\n            mm[i[1]].push_back(i[0]);\\n        }\\n        vector<int> res;\\n        for (auto point : points) {\\n            int cnt = 0;\\n            int x = point[0], y = point[1];\\n            auto iter = mm.lower_bound(y);\\n            for (; iter != mm.end(); iter++) {\\n                auto lower = lower_bound(iter->second.begin(), iter->second.end(), x);\\n                cnt += (iter->second.end() - lower);\\n            }\\n            res.push_back(cnt);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\n    vector<int> countRectangles(vector<vector<int>> &rectangles, vector<vector<int>> &points) {\\n        sort(rectangles.begin(), rectangles.end());\\n        map<int, vector<int> > mm;\\n        for (auto i : rectangles) {\\n            mm[i[1]].push_back(i[0]);\\n        }\\n        vector<int> res;\\n        for (auto point : points) {\\n            int cnt = 0;\\n            int x = point[0], y = point[1];\\n            auto iter = mm.lower_bound(y);\\n            for (; iter != mm.end(); iter++) {\\n\\t\\t\\t\\t// the only modification, replace iter->second with tmp, got tle\\n                auto tmp = iter->second;\\n                auto lower = lower_bound(tmp.begin(), tmp.end(), x);\\n                cnt += (tmp.end() - lower);\\n            }\\n\\n            res.push_back(cnt);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306729,
                "title": "c-bucket-sort-binary-search-with-logic-beats-96",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n        for each point[j] -> (x,y) check all rects\\n        M rectangles, N points -> O(M*N) time O(1) space\\n        \\n        bucket sort: O(maxH * N * log(M) ) time, O(maxH * M) space\\n        given that max height is 10^2, we sort the rectangles into buckets\\n        each bin representing rectangles of height \"h\", sort each bucket by length\\n        use binary search to find number of rects of height \"h\" that contains point i\\n        \\n        repeat for each point of input\\n    */\\n    int findFirstGreaterThan(vector<int> &A, int t) {\\n        int n = A.size();\\n        int hi = n-1;\\n        int lo = 0;\\n        \\n        while (lo < hi-1) {\\n            int mid = lo + (hi-lo)/2;\\n            \\n            if (A[mid] < t) {\\n                lo = mid+1;\\n            }\\n            else {\\n                hi = mid;\\n            }\\n        }\\n        if (lo < n && A[lo] >= t) return lo;\\n        if (A[hi] >= t) return hi;\\n        return -1;\\n    }\\n    \\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        int max_ht = 101;\\n        vector<vector<int>> sortedRects(max_ht, vector<int> ());\\n        vector<int> ret;\\n        \\n        for (auto rect : rectangles) {\\n            int l = rect[0];\\n            int h = rect[1];\\n            sortedRects[h].push_back(l);\\n        }\\n        \\n        for (int i = 0; i < max_ht; ++i) {\\n            sort(sortedRects[i].begin(), sortedRects[i].end());\\n        }\\n        \\n        for (int i = 0; i < points.size(); ++i) {\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            \\n            int cnt = 0;\\n            for (int r = y; r < sortedRects.size(); ++r) {\\n                if (sortedRects[r].empty()) continue;\\n                int idx = findFirstGreaterThan(sortedRects[r], x);\\n                if (idx != -1) cnt += (sortedRects[r].size() - idx);\\n            }\\n            ret.push_back(cnt);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        for each point[j] -> (x,y) check all rects\\n        M rectangles, N points -> O(M*N) time O(1) space\\n        \\n        bucket sort: O(maxH * N * log(M) ) time, O(maxH * M) space\\n        given that max height is 10^2, we sort the rectangles into buckets\\n        each bin representing rectangles of height \"h\", sort each bucket by length\\n        use binary search to find number of rects of height \"h\" that contains point i\\n        \\n        repeat for each point of input\\n    */\\n    int findFirstGreaterThan(vector<int> &A, int t) {\\n        int n = A.size();\\n        int hi = n-1;\\n        int lo = 0;\\n        \\n        while (lo < hi-1) {\\n            int mid = lo + (hi-lo)/2;\\n            \\n            if (A[mid] < t) {\\n                lo = mid+1;\\n            }\\n            else {\\n                hi = mid;\\n            }\\n        }\\n        if (lo < n && A[lo] >= t) return lo;\\n        if (A[hi] >= t) return hi;\\n        return -1;\\n    }\\n    \\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        int max_ht = 101;\\n        vector<vector<int>> sortedRects(max_ht, vector<int> ());\\n        vector<int> ret;\\n        \\n        for (auto rect : rectangles) {\\n            int l = rect[0];\\n            int h = rect[1];\\n            sortedRects[h].push_back(l);\\n        }\\n        \\n        for (int i = 0; i < max_ht; ++i) {\\n            sort(sortedRects[i].begin(), sortedRects[i].end());\\n        }\\n        \\n        for (int i = 0; i < points.size(); ++i) {\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            \\n            int cnt = 0;\\n            for (int r = y; r < sortedRects.size(); ++r) {\\n                if (sortedRects[r].empty()) continue;\\n                int idx = findFirstGreaterThan(sortedRects[r], x);\\n                if (idx != -1) cnt += (sortedRects[r].size() - idx);\\n            }\\n            ret.push_back(cnt);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244642,
                "title": "python3-solution-binary-search",
                "content": "```\\nclass Solution:\\n    def countRectangles(self, R, P):\\n        R.sort()\\n        dp = [[] for _ in range(101)]\\n        for l,h in R:\\n            dp[h].append(l)\\n        res = []\\n        for x,y in P:\\n            count = 0\\n            for h in range(y,101):\\n                count += len(dp[h]) - bisect.bisect_left(dp[h], x)\\n            res.append(count)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def countRectangles(self, R, P):\\n        R.sort()\\n        dp = [[] for _ in range(101)]\\n        for l,h in R:\\n            dp[h].append(l)\\n        res = []\\n        for x,y in P:\\n            count = 0\\n            for h in range(y,101):\\n                count += len(dp[h]) - bisect.bisect_left(dp[h], x)\\n            res.append(count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244569,
                "title": "python-binary-search-o-nlogn",
                "content": "```\\nclass Solution:\\n    def countRectangles(self, rect: List[List[int]], points: List[List[int]]) -> List[int]:\\n        \\n        hashmap = {}\\n        for x, y in rect:\\n            hashmap[y] = hashmap.get(y, []) + [x]\\n            \\n        for k in hashmap.keys():\\n            hashmap[k].sort()\\n        \\n        res = []\\n        for x, y in points:\\n            ans = 0\\n            for coord in range(y, 101):\\n                if coord in hashmap:\\n                    val = hashmap[coord]\\n                    ans += len(val) - bisect_left(val, x)\\n            res.append(ans)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def countRectangles(self, rect: List[List[int]], points: List[List[int]]) -> List[int]:\\n        \\n        hashmap = {}\\n        for x, y in rect:\\n            hashmap[y] = hashmap.get(y, []) + [x]\\n            \\n        for k in hashmap.keys():\\n            hashmap[k].sort()\\n        \\n        res = []\\n        for x, y in points:\\n            ans = 0\\n            for coord in range(y, 101):\\n                if coord in hashmap:\\n                    val = hashmap[coord]\\n                    ans += len(val) - bisect_left(val, x)\\n            res.append(ans)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237142,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rect, int[][] p) \\n    {\\n        int dp[][]=new int[102][];\\n        \\n        //map stores y---->list of x\\n        Map<Integer,ArrayList<Integer>> map=new HashMap<>();\\n        \\n        for(int i=0;i<rect.length;i++)\\n        {\\n            if(!map.containsKey(rect[i][1]))\\n            map.put(rect[i][1],new ArrayList<>());\\n            \\n            map.get(rect[i][1]).add(rect[i][0]);\\n        }\\n        \\n        Set<Integer> set=map.keySet();\\n        for(int e:set)\\n        {\\n            ArrayList<Integer> temp=map.get(e);\\n            Collections.sort(temp);\\n            \\n            dp[e]=new int[temp.size()];\\n            \\n            for(int i=0;i<temp.size();i++)\\n            dp[e][i]=temp.get(i);\\n        }\\n        \\n        int ans[]=new int[p.length];\\n        for(int i=0;i<p.length;i++)\\n        {\\n            ans[i]=find(p[i][0],p[i][1],dp);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int find(int x,int y,int dp[][])\\n    {\\n        int ans=0;\\n        \\n        for(int i=y;i<=100;i++)\\n        {\\n            if(dp[i]!=null)\\n            ans+=count(x,dp,i);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int count(int x,int dp[][],int i)\\n    {\\n        int size=dp[i].length;\\n        int start=0;\\n        int end=size-1;\\n        int f=-1;\\n            \\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(dp[i][mid]>=x)\\n            {\\n                f=mid;\\n                end=mid-1;\\n            }\\n            else\\n            start=mid+1;\\n        }\\n        \\n        return f==-1?0:size-f;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rect, int[][] p) \\n    {\\n        int dp[][]=new int[102][];\\n        \\n        //map stores y---->list of x\\n        Map<Integer,ArrayList<Integer>> map=new HashMap<>();\\n        \\n        for(int i=0;i<rect.length;i++)\\n        {\\n            if(!map.containsKey(rect[i][1]))\\n            map.put(rect[i][1],new ArrayList<>());\\n            \\n            map.get(rect[i][1]).add(rect[i][0]);\\n        }\\n        \\n        Set<Integer> set=map.keySet();\\n        for(int e:set)\\n        {\\n            ArrayList<Integer> temp=map.get(e);\\n            Collections.sort(temp);\\n            \\n            dp[e]=new int[temp.size()];\\n            \\n            for(int i=0;i<temp.size();i++)\\n            dp[e][i]=temp.get(i);\\n        }\\n        \\n        int ans[]=new int[p.length];\\n        for(int i=0;i<p.length;i++)\\n        {\\n            ans[i]=find(p[i][0],p[i][1],dp);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int find(int x,int y,int dp[][])\\n    {\\n        int ans=0;\\n        \\n        for(int i=y;i<=100;i++)\\n        {\\n            if(dp[i]!=null)\\n            ans+=count(x,dp,i);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int count(int x,int dp[][],int i)\\n    {\\n        int size=dp[i].length;\\n        int start=0;\\n        int end=size-1;\\n        int f=-1;\\n            \\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(dp[i][mid]>=x)\\n            {\\n                f=mid;\\n                end=mid-1;\\n            }\\n            else\\n            start=mid+1;\\n        }\\n        \\n        return f==-1?0:size-f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177518,
                "title": "python-o-nlogn-using-100-backets",
                "content": "Precompute a bracket array so that we minimize the lookup cost to O(log N). \\n\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        \\n        brackets = [[] for _ in range(101)] # brackets[i] stores rectangles with h => i, sorted\\n        \\n        for x,y in rectangles:\\n            brackets[y].append([x,y])\\n            \\n        # O(nlogn)\\n        for i in range(len(brackets)-2, 0, -1): # loop 100 times\\n            brackets[i] += brackets[i+1] # O(n)\\n            brackets[i].sort() # O(nlogn)\\n        brackets[len(brackets)-1].sort() \\n                    \\n        ret = []\\n        # O(nlogn)\\n        for [x,y] in points: \\n            rects = brackets[y]\\n            count = bisect.bisect_left(rects, [x,0]) # O(logn)\\n            ret.append(len(rects) - count)\\n        return ret\\n    \\n",
                "solutionTags": [],
                "code": "Precompute a bracket array so that we minimize the lookup cost to O(log N). \\n\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        \\n        brackets = [[] for _ in range(101)] # brackets[i] stores rectangles with h => i, sorted\\n        \\n        for x,y in rectangles:\\n            brackets[y].append([x,y])\\n            \\n        # O(nlogn)\\n        for i in range(len(brackets)-2, 0, -1): # loop 100 times\\n            brackets[i] += brackets[i+1] # O(n)\\n            brackets[i].sort() # O(nlogn)\\n        brackets[len(brackets)-1].sort() \\n                    \\n        ret = []\\n        # O(nlogn)\\n        for [x,y] in points: \\n            rects = brackets[y]\\n            count = bisect.bisect_left(rects, [x,0]) # O(logn)\\n            ret.append(len(rects) - count)\\n        return ret\\n    \\n",
                "codeTag": "Python3"
            },
            {
                "id": 2154089,
                "title": "python-binary-search",
                "content": "```class Solution:\\n    def countRectangles(self, rect: List[List[int]], points: List[List[int]]) -> List[int]:\\n        store = defaultdict(list)\\n        for x, y in rect:\\n            store[y].append(x)\\n        for k in store.keys():\\n            store[k].sort()\\n        ans = []\\n        for x, y in points:\\n            nums = 0\\n            for h in range(y, 101):\\n                if h in store:\\n                    nums += len(store[h]) - bisect.bisect_left(store[h], x)\\n            ans.append(nums)\\n        return ans",
                "solutionTags": [],
                "code": "```class Solution:\\n    def countRectangles(self, rect: List[List[int]], points: List[List[int]]) -> List[int]:\\n        store = defaultdict(list)\\n        for x, y in rect:\\n            store[y].append(x)\\n        for k in store.keys():\\n            store[k].sort()\\n        ans = []\\n        for x, y in points:\\n            nums = 0\\n            for h in range(y, 101):\\n                if h in store:\\n                    nums += len(store[h]) - bisect.bisect_left(store[h], x)\\n            ans.append(nums)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2120923,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\n        public int[] CountRectangles(int[][] rectangles, int[][] points)\\n        {\\n            List<int>[] mat = new List<int>[101];// 1<=height<=100, create matrix with range [0,100]\\n            for (int i = 0; i < mat.Length; i++)\\n                mat[i] = new List<int>();//each row store x croods\\n\\n            foreach (var rect in rectangles)\\n                mat[rect[1]].Add(rect[0]);\\n\\n            foreach (var row in mat)\\n                row.Sort();//must sort all x croods\\n\\n            int[] res = new int[points.Length];\\n            for(int i = 0; i < points.Length; i++)\\n            {\\n                var p = points[i];\\n                int sum = 0;\\n\\t\\t\\t\\t//search all [p[1],100] height rows\\n                for(int j =p[1]; j < mat.Length; j++)\\n                {\\n                    if (mat[j].Count == 0) continue;//no node\\n                    if (mat[j].Last() < p[0]) continue;//no valid\\n                    if (mat[j].First() >= p[0]) sum += mat[j].Count;//all valid\\n                    else\\n                    {\\n                        int left = 0;\\n                        int right = mat[j].Count - 1;\\n\\t\\t\\t\\t\\t\\t//using binary search\\n                        while (left < right)\\n                        {\\n                            int mid = (left + right) / 2;\\n                            if (mat[j][mid] >= p[0]) right = mid;\\n                            else left = mid + 1;\\n                        }\\n                        sum+=mat[j].Count - left;//[left,count-1]\\n                    }\\n                }\\n                res[i] = sum;\\n            }\\n            return res;\\n        }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        public int[] CountRectangles(int[][] rectangles, int[][] points)\\n        {\\n            List<int>[] mat = new List<int>[101];// 1<=height<=100, create matrix with range [0,100]\\n            for (int i = 0; i < mat.Length; i++)\\n                mat[i] = new List<int>();//each row store x croods\\n\\n            foreach (var rect in rectangles)\\n                mat[rect[1]].Add(rect[0]);\\n\\n            foreach (var row in mat)\\n                row.Sort();//must sort all x croods\\n\\n            int[] res = new int[points.Length];\\n            for(int i = 0; i < points.Length; i++)\\n            {\\n                var p = points[i];\\n                int sum = 0;\\n\\t\\t\\t\\t//search all [p[1],100] height rows\\n                for(int j =p[1]; j < mat.Length; j++)\\n                {\\n                    if (mat[j].Count == 0) continue;//no node\\n                    if (mat[j].Last() < p[0]) continue;//no valid\\n                    if (mat[j].First() >= p[0]) sum += mat[j].Count;//all valid\\n                    else\\n                    {\\n                        int left = 0;\\n                        int right = mat[j].Count - 1;\\n\\t\\t\\t\\t\\t\\t//using binary search\\n                        while (left < right)\\n                        {\\n                            int mid = (left + right) / 2;\\n                            if (mat[j][mid] >= p[0]) right = mid;\\n                            else left = mid + 1;\\n                        }\\n                        sum+=mat[j].Count - left;//[left,count-1]\\n                    }\\n                }\\n                res[i] = sum;\\n            }\\n            return res;\\n        }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2106355,
                "title": "easy-explanation-with-diagram-c",
                "content": "![image](https://assets.leetcode.com/users/images/a541d576-4b1e-450e-b22b-e3b5c429b205_1654265206.7315168.jpeg)\\n\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tvector<int> countRectangles(vector<vector<int>>& r, vector<vector<int>>& p) {\\n\\t\\t\\t\\t\\tint n = r.size();\\n\\t\\t\\t\\t\\tsort(r.begin(),r.end());\\n\\t\\t\\t\\t\\tunordered_map<int,vector<int>> m;\\n\\t\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\t\\tm[r[i][1]].push_back(r[i][0]);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvector<int> res;\\n\\t\\t\\t\\t\\tfor(int i=0; i<p.size(); i++){\\n\\t\\t\\t\\t\\t\\tint x = p[i][0];\\n\\t\\t\\t\\t\\t\\tint y = p[i][1];\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\t\\t\\tfor(int h=y; h<=100; h++){\\n\\t\\t\\t\\t\\t\\t\\tif(m.find(h)!=m.end()){\\n\\t\\t\\t\\t\\t\\t\\t\\tint lb = lower_bound(m[h].begin(),m[h].end(),x)-m[h].begin();\\n\\t\\t\\t\\t\\t\\t\\t\\tcnt += m[h].size()-lb;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tres.push_back(cnt);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tvector<int> countRectangles(vector<vector<int>>& r, vector<vector<int>>& p) {\\n\\t\\t\\t\\t\\tint n = r.size();\\n\\t\\t\\t\\t\\tsort(r.begin(),r.end());\\n\\t\\t\\t\\t\\tunordered_map<int,vector<int>> m;\\n\\t\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\t\\tm[r[i][1]].push_back(r[i][0]);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2069912,
                "title": "2solutions-map-binsrch-and-sorting",
                "content": "Solution 1 :  Map + Binary Search\\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Map<Integer, List<Integer>> hm = new HashMap<>(); //height -> List of lengths\\n        for(int[] r : rectangles){\\n             hm.computeIfAbsent(r[1], v->new ArrayList<Integer>()).add(r[0]);\\n        }\\n        for(int k : hm.keySet()){\\n            Collections.sort(hm.get(k));\\n        }\\n       // System.out.println(\"hm:\"+hm);\\n        int[] ans = new int[points.length];\\n        int idx = 0;\\n        for(int[] p : points){\\n            int x = p[0], y = p[1] ;\\n            for(int k=y; k<=100; k++){\\n                if(hm.containsKey(k)){\\n                    int sz = hm.get(k).size();\\n                    ans[idx] += (sz - binsearch(x, 0, sz-1, hm.get(k))); // search in list of lengths\\n                }\\n            }\\n            idx++;\\n        }\\n        return ans;\\n    }\\n    int binsearch(int srch, int lo, int hi, List<Integer> arr){\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(srch < arr.get(mid)) hi = mid-1;\\n            else if(srch > arr.get(mid)) lo = mid+1;\\n            else return mid;\\n        }\\n        return lo;\\n    }\\n}\\n```\\n\\nSolution 2: Sorting\\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int len = rectangles.length, n = points.length;\\n        Arrays.sort(rectangles, (a, b) -> b[0] - a[0]); //length desc\\n        //System.out.println(\"rectangles:\"+Arrays.deepToString(rectangles));\\n        int[][] pp = new int[n][];\\n        for (int i = 0; i < n; ++i) {\\n            pp[i] = new int[]{ points[i][0], points[i][1], i};\\n        }\\n        Arrays.sort(pp, (a, b) -> b[0] - a[0]); //length desc\\n        //System.out.println(\"pp:\"+Arrays.deepToString(pp));\\n        int[] arr = new int[101];\\n        int[] res = new int[n];\\n        int i = 0;\\n\\n        for (int[] p : pp) {\\n            int x = p[0];\\n            int y = p[1];\\n            int index = p[2];\\n            for ( ; i < len && x<=rectangles[i][0]; i++) {\\n                for (int ht = rectangles[i][1]; ht >= 0; --ht) { // Put my(point) entry in all heights uptill 0; since length is within limits\\n                    arr[ht] += 1;\\n                }\\n            }\\n            res[index] = arr[y]; //how many points within ht range\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Map<Integer, List<Integer>> hm = new HashMap<>(); //height -> List of lengths\\n        for(int[] r : rectangles){\\n             hm.computeIfAbsent(r[1], v->new ArrayList<Integer>()).add(r[0]);\\n        }\\n        for(int k : hm.keySet()){\\n            Collections.sort(hm.get(k));\\n        }\\n       // System.out.println(\"hm:\"+hm);\\n        int[] ans = new int[points.length];\\n        int idx = 0;\\n        for(int[] p : points){\\n            int x = p[0], y = p[1] ;\\n            for(int k=y; k<=100; k++){\\n                if(hm.containsKey(k)){\\n                    int sz = hm.get(k).size();\\n                    ans[idx] += (sz - binsearch(x, 0, sz-1, hm.get(k))); // search in list of lengths\\n                }\\n            }\\n            idx++;\\n        }\\n        return ans;\\n    }\\n    int binsearch(int srch, int lo, int hi, List<Integer> arr){\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(srch < arr.get(mid)) hi = mid-1;\\n            else if(srch > arr.get(mid)) lo = mid+1;\\n            else return mid;\\n        }\\n        return lo;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int len = rectangles.length, n = points.length;\\n        Arrays.sort(rectangles, (a, b) -> b[0] - a[0]); //length desc\\n        //System.out.println(\"rectangles:\"+Arrays.deepToString(rectangles));\\n        int[][] pp = new int[n][];\\n        for (int i = 0; i < n; ++i) {\\n            pp[i] = new int[]{ points[i][0], points[i][1], i};\\n        }\\n        Arrays.sort(pp, (a, b) -> b[0] - a[0]); //length desc\\n        //System.out.println(\"pp:\"+Arrays.deepToString(pp));\\n        int[] arr = new int[101];\\n        int[] res = new int[n];\\n        int i = 0;\\n\\n        for (int[] p : pp) {\\n            int x = p[0];\\n            int y = p[1];\\n            int index = p[2];\\n            for ( ; i < len && x<=rectangles[i][0]; i++) {\\n                for (int ht = rectangles[i][1]; ht >= 0; --ht) { // Put my(point) entry in all heights uptill 0; since length is within limits\\n                    arr[ht] += 1;\\n                }\\n            }\\n            res[index] = arr[y]; //how many points within ht range\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059795,
                "title": "java-binary-search-detailed-explanation",
                "content": "### Intuition\\nAssume the height is 1 (ignore the height first)\\n\\nIf we can sort the rectangles by width, then it\\'s easy to get **count of rectangle whose width >= point x** by binary search\\n\\n#### Binary Search\\nfor a points, find the nearest index `i` where `ractangles[i].width >= point.x`\\nthe count of rectangles containing point is `n - i`\\n\\nExample:\\n```\\ngiven sorted rectangles\\' widths: [1,3,5,7]\\n\\nif x = 1, count = 4 - 0 = 4\\nif x = 2, count = 4 - 1 = 3\\nif x = 7, count = 4 - 3 = 1\\nif x = 10, count = 4 - 4 = 0\\n```\\n\\n\\n\\n#### Bucket\\nConsider height.\\nuse bucket to store all heights[1,100]\\nfor a given point(x, y), we need to sum up all buckets with height >= y\\n\\n#### Complexity\\n- Time: `O(nhlogn + m)` = `O(nlogn + m)`\\n- Space: `O(n)`\\n\\nWhere `n` is the size of rectangles, `m` is size of points, `h` is the max height\\n#### Java\\n```java\\npublic int[] countRectangles(int[][] rectangles, int[][] points) {\\n    int n = rectangles.length;\\n    List<Integer>[] bucket = new ArrayList[101];\\n    for (int i = 1; i <= 100; i++) {\\n        bucket[i] = new ArrayList<>();\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        int w = rectangles[i][0], h = rectangles[i][1];\\n        bucket[h].add(w);\\n    }\\n    for (int i = 1; i <= 100; i++) {\\n        Collections.sort(bucket[i]);\\n    }\\n\\n    int m = points.length;\\n    int[] res = new int[m];\\n    for (int i = 0; i < m; i++) {\\n        int x = points[i][0], y = points[i][1];\\n        int count = 0;\\n        for (int h = y; h < bucket.length; h++) {\\n            int index = ceiling(bucket[h], x);\\n            count += bucket[h].size() - index;\\n        }\\n        res[i] = count;\\n    }\\n    return res;\\n}\\n\\nint ceiling(List<Integer> list, int target) {\\n    int left = 0, right = list.size();\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n        if (list.get(mid) < target) left = mid + 1;\\n        else right = mid;\\n    }\\n    return left;\\n}\\n```\\n\\n----\\n### Why Can\\'t Use Presum?\\nSometimes we might use presum to resolve this kind of questions.\\n#### Steps\\n1. Calculate the presum width rectangles for the entire matrix\\n2. Then use height bucket (same as binary search solution)\\n\\n\\n#### Complexity\\nHowever the time complexity will be:\\n- Time: `O(hw + m)`\\n- Space: `O(hw)`\\n\\nWhere `h` is the max height, `w` is the max width, `m` is size of points\\nSince `w` could be `10^9` which cause TLE\\n\\n### Conclusion\\nIt depends on the question. Therefore, ask as many clarifying questions as possible.\\n\\nHope this is helpful to you, thanks :)",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\ngiven sorted rectangles\\' widths: [1,3,5,7]\\n\\nif x = 1, count = 4 - 0 = 4\\nif x = 2, count = 4 - 1 = 3\\nif x = 7, count = 4 - 3 = 1\\nif x = 10, count = 4 - 4 = 0\\n```\n```java\\npublic int[] countRectangles(int[][] rectangles, int[][] points) {\\n    int n = rectangles.length;\\n    List<Integer>[] bucket = new ArrayList[101];\\n    for (int i = 1; i <= 100; i++) {\\n        bucket[i] = new ArrayList<>();\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        int w = rectangles[i][0], h = rectangles[i][1];\\n        bucket[h].add(w);\\n    }\\n    for (int i = 1; i <= 100; i++) {\\n        Collections.sort(bucket[i]);\\n    }\\n\\n    int m = points.length;\\n    int[] res = new int[m];\\n    for (int i = 0; i < m; i++) {\\n        int x = points[i][0], y = points[i][1];\\n        int count = 0;\\n        for (int h = y; h < bucket.length; h++) {\\n            int index = ceiling(bucket[h], x);\\n            count += bucket[h].size() - index;\\n        }\\n        res[i] = count;\\n    }\\n    return res;\\n}\\n\\nint ceiling(List<Integer> list, int target) {\\n    int left = 0, right = list.size();\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n        if (list.get(mid) < target) left = mid + 1;\\n        else right = mid;\\n    }\\n    return left;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2054146,
                "title": "c-binary-search-hashmap-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int getFirstIdxGreaterThanEqualToX(vector<int>&X, int ref) {\\n        int n = X.size();\\n        int l = 0, r = n - 1;\\n        while(l < r) {\\n            int mid = (l + r) / 2;\\n            if(X[mid] >= ref) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return r;\\n    }\\n    \\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        unordered_map<int, set<int>> mp; // {hi --> {x1, x2, ...}} x1 < x2 ....\\n        int mxY = 0;\\n        for(auto rec : rectangles) {\\n            mp[rec[1]].insert(rec[0]);\\n            mxY = max(mxY, rec[1]);\\n        }\\n        int pointCount = points.size();\\n        vector<int> ans(pointCount);\\n        int count = 0;\\n        for(int i = 0; i < pointCount; i++) {\\n            vector<int> point = points[i];\\n            int x = point[0];\\n            int y = point[1];\\n            // cout << \"(\" << x << \",\" << y << \")\" << endl;\\n            for(int h = y; h <= mxY; h++) {\\n                vector<int> X(mp[h].begin(), mp[h].end());\\n                if(X.empty()) {\\n                    continue;\\n                }\\n                int n = X.size();\\n                int firstIdxGreaterThanEqualToX = getFirstIdxGreaterThanEqualToX(X, x);\\n                if(firstIdxGreaterThanEqualToX == n - 1 && X[firstIdxGreaterThanEqualToX] < x) {\\n                    firstIdxGreaterThanEqualToX = n;\\n                }\\n                // cout << \"h = \" << h << endl;\\n                ans[i] += n - firstIdxGreaterThanEqualToX;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getFirstIdxGreaterThanEqualToX(vector<int>&X, int ref) {\\n        int n = X.size();\\n        int l = 0, r = n - 1;\\n        while(l < r) {\\n            int mid = (l + r) / 2;\\n            if(X[mid] >= ref) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return r;\\n    }\\n    \\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        unordered_map<int, set<int>> mp; // {hi --> {x1, x2, ...}} x1 < x2 ....\\n        int mxY = 0;\\n        for(auto rec : rectangles) {\\n            mp[rec[1]].insert(rec[0]);\\n            mxY = max(mxY, rec[1]);\\n        }\\n        int pointCount = points.size();\\n        vector<int> ans(pointCount);\\n        int count = 0;\\n        for(int i = 0; i < pointCount; i++) {\\n            vector<int> point = points[i];\\n            int x = point[0];\\n            int y = point[1];\\n            // cout << \"(\" << x << \",\" << y << \")\" << endl;\\n            for(int h = y; h <= mxY; h++) {\\n                vector<int> X(mp[h].begin(), mp[h].end());\\n                if(X.empty()) {\\n                    continue;\\n                }\\n                int n = X.size();\\n                int firstIdxGreaterThanEqualToX = getFirstIdxGreaterThanEqualToX(X, x);\\n                if(firstIdxGreaterThanEqualToX == n - 1 && X[firstIdxGreaterThanEqualToX] < x) {\\n                    firstIdxGreaterThanEqualToX = n;\\n                }\\n                // cout << \"h = \" << h << endl;\\n                ans[i] += n - firstIdxGreaterThanEqualToX;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2045219,
                "title": "java-solution-70-faster-n-log-n",
                "content": "class Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int[] res = new int[points.length];\\n        List<List<Integer>> group = new ArrayList<>(101);\\n        for(int i = 0; i < 101; i++){\\n            group.add(new ArrayList<>());\\n        }\\n        int max=0;\\n        for(int[] rec : rectangles){\\n            int l = rec[0];\\n            int h = rec[1];\\n            group.get(h).add(l);\\n            max = Math.max(max,h);\\n        }\\n        \\n        for(int i = 0; i <= max; i++){\\n            Collections.sort(group.get(i));   \\n        }\\n        \\n        for(int i = 0; i < points.length; i++){\\n            int count = 0;\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            for(int j = y; j <= max; j++){\\n                List<Integer> cur = group.get(j);\\n                int index = binarySearch(cur, x);\\n                count += cur.size() - index;\\n            }\\n            res[i] = count;\\n        }\\n\\n        return res;\\n    }\\n    \\n    private int binarySearch(List<Integer> list, int x){\\n        int left = 0;\\n        int right = list.size();\\n        while(left < right){\\n            int mid = left + (right - left) / 2;\\n            if(list.get(mid) >= x){\\n                right = mid;\\n            } else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int[] res = new int[points.length];\\n        List<List<Integer>> group = new ArrayList<>(101);\\n        for(int i = 0; i < 101; i++){\\n            group.add(new ArrayList<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2023857,
                "title": "java-soln-using-binary-search",
                "content": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        HashMap<Integer,ArrayList<Integer>> map=new HashMap<>();\\n        for(int i=0;i<rectangles.length;i++)\\n        {\\n            if(map.containsKey(rectangles[i][1]))\\n            {\\n                map.get(rectangles[i][1]).add(rectangles[i][0]);\\n            }\\n            else\\n            {\\n                map.put(rectangles[i][1],new ArrayList<>());\\n                map.get(rectangles[i][1]).add(rectangles[i][0]);\\n            }\\n        }\\n        Iterator<Integer> it=map.keySet().iterator();\\n        while(it.hasNext())\\n        {\\n            int key=it.next();\\n            Collections.sort(map.get(key));\\n        }\\n        \\n        int[] ans=new int[points.length];\\n        \\n        for(int i=0;i<points.length;i++)\\n        {\\n            int x=points[i][0];\\n            int y=points[i][1];\\n            \\n            for(int j=y;j<=100;j++)\\n            {\\n             if(map.containsKey(j))\\n             {\\n                ans[i]=ans[i]+map.get(j).size()-binsearch(map.get(j),x);\\n             }\\n                \\n             }\\n            \\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n    public int binsearch(ArrayList<Integer> vec,int x)\\n    {\\n        int l=0;int r=vec.size()-1;\\n        int ans=vec.size();\\n        \\n        while(l<=r)\\n        {\\n            int m=(r-l)/2+l;\\n            if(vec.get(m)>=x)\\n            {\\n                ans=m;\\n                r=m-1;\\n            }\\n            else\\n            {\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        HashMap<Integer,ArrayList<Integer>> map=new HashMap<>();\\n        for(int i=0;i<rectangles.length;i++)\\n        {\\n            if(map.containsKey(rectangles[i][1]))\\n            {\\n                map.get(rectangles[i][1]).add(rectangles[i][0]);\\n            }\\n            else\\n            {\\n                map.put(rectangles[i][1],new ArrayList<>());\\n                map.get(rectangles[i][1]).add(rectangles[i][0]);\\n            }\\n        }\\n        Iterator<Integer> it=map.keySet().iterator();\\n        while(it.hasNext())\\n        {\\n            int key=it.next();\\n            Collections.sort(map.get(key));\\n        }\\n        \\n        int[] ans=new int[points.length];\\n        \\n        for(int i=0;i<points.length;i++)\\n        {\\n            int x=points[i][0];\\n            int y=points[i][1];\\n            \\n            for(int j=y;j<=100;j++)\\n            {\\n             if(map.containsKey(j))\\n             {\\n                ans[i]=ans[i]+map.get(j).size()-binsearch(map.get(j),x);\\n             }\\n                \\n             }\\n            \\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n    public int binsearch(ArrayList<Integer> vec,int x)\\n    {\\n        int l=0;int r=vec.size()-1;\\n        int ans=vec.size();\\n        \\n        while(l<=r)\\n        {\\n            int m=(r-l)/2+l;\\n            if(vec.get(m)>=x)\\n            {\\n                ans=m;\\n                r=m-1;\\n            }\\n            else\\n            {\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019756,
                "title": "a-few-solutions",
                "content": "Use a map `m` as `1..100` inclusive buckets for each rectangle y-axis value.  Each bucket stores each rectangle x-axis value.  Sort each bucket for logarithmic lookups via binary search for each point `x`,`y` of the input `queries` for each y-axis bucket from y..100 inclusive to accumulate the count `cnt` of rectangles for each query.\\n\\n---\\n\\n*Kotlin*\\n```\\nfun bisect_left(A: MutableList<Int>, x: Int): Int {\\n    var N = A.size\\n    var (i, j) = Pair(0, N)\\n    while (i < j) {\\n        var k = (i + j) / 2\\n        if (A[k] < x)\\n            i = k + 1\\n        else\\n            j = k\\n    }\\n    return i\\n}\\nclass Solution {\\n    fun countRectangles(A: Array<IntArray>, queries: Array<IntArray>): IntArray {\\n        var m = mutableMapOf<Int, MutableList<Int>>()\\n        for ((x, y) in A) {\\n            if (!m.contains(y))\\n                m[y] = mutableListOf<Int>()\\n            m[y]!!.add(x)\\n        }\\n        for ((y, points) in m)\\n            points.sort()\\n        fun f(x: Int, y_: Int): Int {\\n            var cnt = 0\\n            for (y in y_..100) {\\n                var bucket = m[y] ?: mutableListOf<Int>()\\n                var i = bisect_left(bucket, x)\\n                cnt += bucket.size - i\\n            }\\n            return cnt\\n        }\\n        return queries.map{ (x, y) -> f(x, y) }.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countRectangles = (A, queries, m = new Map()) => {\\n    for (let [x, y] of A) {\\n        if (!m.has(y))\\n            m.set(y, []);\\n        m.get(y).push(x);\\n    }\\n    for (let [y, points] of m)\\n        points.sort((a, b) => a - b);\\n    let f = (x, y) => {\\n        let cnt = 0;\\n        while (y <= 100) {\\n            let bucket = m.get(y++) || [];\\n            let i = _.sortedIndex(bucket, x);\\n            cnt += bucket.length - i;\\n        }\\n        return cnt;\\n    };\\n    return queries.map(([x, y]) => f(x, y));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countRectangles(self, A: List[List[int]], queries: List[List[int]]) -> List[int]:\\n        m = defaultdict(list)\\n        for x, y in A:\\n            m[y].append(x)\\n        for points in m.values():\\n            points.sort()\\n        def f(x, y):\\n            cnt = 0\\n            while y <= 100:\\n                bucket = m[y]\\n                i = bisect_left(bucket, x)\\n                cnt += len(bucket) - i\\n                y += 1\\n            return cnt\\n        return [f(x, y) for x, y in queries]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = set<int>;\\n    using Map = unordered_map<int, Set>;\\n    VI countRectangles(VVI& A, VVI& queries, Map m = {}, VI ans = {}) {\\n        for (auto& pair: A) {\\n            auto [x, y] = tie(pair[0], pair[1]);\\n            m[y].insert(x);\\n        }\\n        auto f = [&](auto x, auto y) {\\n            auto cnt = 0;\\n            while (y <= 100) {\\n                auto bucket = m[y++];\\n                auto it = lower_bound(bucket.begin(), bucket.end(), x);\\n                cnt += bucket.size() - distance(bucket.begin(), it);\\n            }\\n            return cnt;\\n        };\\n        transform(queries.begin(), queries.end(), back_inserter(ans), [&](auto& pair) {\\n            auto [x, y] = tie(pair[0], pair[1]);\\n            return f(x, y);\\n        });\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfun bisect_left(A: MutableList<Int>, x: Int): Int {\\n    var N = A.size\\n    var (i, j) = Pair(0, N)\\n    while (i < j) {\\n        var k = (i + j) / 2\\n        if (A[k] < x)\\n            i = k + 1\\n        else\\n            j = k\\n    }\\n    return i\\n}\\nclass Solution {\\n    fun countRectangles(A: Array<IntArray>, queries: Array<IntArray>): IntArray {\\n        var m = mutableMapOf<Int, MutableList<Int>>()\\n        for ((x, y) in A) {\\n            if (!m.contains(y))\\n                m[y] = mutableListOf<Int>()\\n            m[y]!!.add(x)\\n        }\\n        for ((y, points) in m)\\n            points.sort()\\n        fun f(x: Int, y_: Int): Int {\\n            var cnt = 0\\n            for (y in y_..100) {\\n                var bucket = m[y] ?: mutableListOf<Int>()\\n                var i = bisect_left(bucket, x)\\n                cnt += bucket.size - i\\n            }\\n            return cnt\\n        }\\n        return queries.map{ (x, y) -> f(x, y) }.toIntArray()\\n    }\\n}\\n```\n```\\nlet countRectangles = (A, queries, m = new Map()) => {\\n    for (let [x, y] of A) {\\n        if (!m.has(y))\\n            m.set(y, []);\\n        m.get(y).push(x);\\n    }\\n    for (let [y, points] of m)\\n        points.sort((a, b) => a - b);\\n    let f = (x, y) => {\\n        let cnt = 0;\\n        while (y <= 100) {\\n            let bucket = m.get(y++) || [];\\n            let i = _.sortedIndex(bucket, x);\\n            cnt += bucket.length - i;\\n        }\\n        return cnt;\\n    };\\n    return queries.map(([x, y]) => f(x, y));\\n};\\n```\n```\\nclass Solution:\\n    def countRectangles(self, A: List[List[int]], queries: List[List[int]]) -> List[int]:\\n        m = defaultdict(list)\\n        for x, y in A:\\n            m[y].append(x)\\n        for points in m.values():\\n            points.sort()\\n        def f(x, y):\\n            cnt = 0\\n            while y <= 100:\\n                bucket = m[y]\\n                i = bisect_left(bucket, x)\\n                cnt += len(bucket) - i\\n                y += 1\\n            return cnt\\n        return [f(x, y) for x, y in queries]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = set<int>;\\n    using Map = unordered_map<int, Set>;\\n    VI countRectangles(VVI& A, VVI& queries, Map m = {}, VI ans = {}) {\\n        for (auto& pair: A) {\\n            auto [x, y] = tie(pair[0], pair[1]);\\n            m[y].insert(x);\\n        }\\n        auto f = [&](auto x, auto y) {\\n            auto cnt = 0;\\n            while (y <= 100) {\\n                auto bucket = m[y++];\\n                auto it = lower_bound(bucket.begin(), bucket.end(), x);\\n                cnt += bucket.size() - distance(bucket.begin(), it);\\n            }\\n            return cnt;\\n        };\\n        transform(queries.begin(), queries.end(), back_inserter(ans), [&](auto& pair) {\\n            auto [x, y] = tie(pair[0], pair[1]);\\n            return f(x, y);\\n        });\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015199,
                "title": "python-binary-search",
                "content": "```python\\nclass Solution(object):\\n    def countRectangles(self, rectangles, points):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :type points: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        def binary_search(arr, value, left, right):\\n            while left < right:\\n                mi = (left + right) / 2\\n                mv = arr[mi]\\n                \\n                if mv < value:\\n                    left = mi + 1\\n                else:\\n                    right = mi\\n            return left\\n        \\n        res = []\\n        dt = {}\\n        \\n        for ri, rj in rectangles:\\n            if rj not in dt:\\n                dt[rj] = []\\n            dt[rj].append(ri)\\n        \\n        keys = []\\n        for k, arr in dt.items():\\n            i = binary_search(keys, k, 0, len(keys))\\n            keys.insert(i, k)\\n            n_arr = []\\n            for a in arr:\\n                j = binary_search(n_arr, a, 0, len(n_arr))\\n                n_arr.insert(j, a)\\n            dt[k] = n_arr\\n        \\n        for pi, pj in points:\\n            j = binary_search(keys, pj, 0, len(keys))\\n            cnt = 0\\n            for ki in range(j, len(keys)):\\n                k = keys[ki]\\n                i = binary_search(dt[k], pi, 0, len(dt[k]))\\n                cnt += len(dt[k]) - i\\n            res.append(cnt)\\n            \\n        return res \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def countRectangles(self, rectangles, points):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :type points: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        def binary_search(arr, value, left, right):\\n            while left < right:\\n                mi = (left + right) / 2\\n                mv = arr[mi]\\n                \\n                if mv < value:\\n                    left = mi + 1\\n                else:\\n                    right = mi\\n            return left\\n        \\n        res = []\\n        dt = {}\\n        \\n        for ri, rj in rectangles:\\n            if rj not in dt:\\n                dt[rj] = []\\n            dt[rj].append(ri)\\n        \\n        keys = []\\n        for k, arr in dt.items():\\n            i = binary_search(keys, k, 0, len(keys))\\n            keys.insert(i, k)\\n            n_arr = []\\n            for a in arr:\\n                j = binary_search(n_arr, a, 0, len(n_arr))\\n                n_arr.insert(j, a)\\n            dt[k] = n_arr\\n        \\n        for pi, pj in points:\\n            j = binary_search(keys, pj, 0, len(keys))\\n            cnt = 0\\n            for ki in range(j, len(keys)):\\n                k = keys[ki]\\n                i = binary_search(dt[k], pi, 0, len(dt[k]))\\n                cnt += len(dt[k]) - i\\n            res.append(cnt)\\n            \\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011150,
                "title": "brute-force-and-optimized-both-discussed-c-solution",
                "content": "```\\n//brute force\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        //points= x,y\\n        // rectangles = rectangle( length, height )\\n        vector<int> ans;\\n        int count=0;\\n        for(int i=0;i<points.size();i++){\\n            count=0;\\n            int x=points[i][0];\\n            int y=points[i][1];\\n\\n            for(int j=0;j<rectangles.size();j++){\\n                int l=rectangles[j][0];\\n                int h=rectangles[j][1];\\n                \\n                if(  x<=l and  y <=h) \\n                    count++;\\n            }\\n                ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n//optimised version\\n\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& r, vector<vector<int>>& p) {\\n        vector<vector<int>> temp(101);\\n        //put x values for every y of rectangle\\n        // jiske y same ho  ukse x ko ek sath ek array me  daal do\\n        for(int i=0;i<r.size();i++)\\n            temp[r[i][1]].push_back(r[i][0]);\\n        \\n        //ab sort kro har row ko taaki binary seacrh lga paye \\n        // wrna binary search lga nahi payenge \\n        for(int i=0;i<101;i++)\\n            sort(temp[i].begin(), temp[i].end());\\n        \\n        // iss vector me asnwer store krenge;\\n        vector<int> ans;\\n        \\n        // loop lga ke har points ke x ko find kro temp vector me y ke corresponding;\\n        int count;\\n        for(int i=0;i<p.size();i++){\\n             count=0;\\n            for(int j=p[i][1] ;j<101;j++){\\n                \\n                int x= lower_bound(temp[j].begin(), temp[j].end(), p[i][0]) -temp[j].begin();\\n                count=count+(temp[j].size()-x);\\n            }\\n            ans.push_back(count);\\n        }\\n        \\n        return ans;\\n            \\n   \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        //points= x,y\\n        // rectangles = rectangle( length, height )\\n        vector<int> ans;\\n        int count=0;\\n        for(int i=0;i<points.size();i++){\\n            count=0;\\n            int x=points[i][0];\\n            int y=points[i][1];\\n\\n            for(int j=0;j<rectangles.size();j++){\\n                int l=rectangles[j][0];\\n                int h=rectangles[j][1];\\n                \\n                if(  x<=l and  y <=h) \\n                    count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2009106,
                "title": "java-binary-search-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n      \\n        ArrayList<Integer> [] list = new ArrayList[101];\\n        \\n        \\n        for(int i =0;i<101;i++)\\n            list[i] = new ArrayList<>();\\n        \\n        for(int i=0;i<rectangles.length;i++)\\n            list [ rectangles[i][1]] .add(rectangles[i][0]);\\n        \\n        \\n        for(int i=1;i<101;i++)\\n            Collections.sort(list[i]);\\n        \\n        \\n        \\n        int result [] = new int [ points.length ];\\n        for(int i =0;i<points.length ; i++){\\n            int x = points [i][0];\\n            int y = points [i][1];\\n            for(int j = y;j<101;j++){\\n                int temp = Collections.binarySearch(list[j],x);\\n                if(temp<0)\\n                    result[i]+=list[j].size()+temp+1;\\n                else\\n                    result[i]+=list[j].size()-temp;\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n      \\n        ArrayList<Integer> [] list = new ArrayList[101];\\n        \\n        \\n        for(int i =0;i<101;i++)\\n            list[i] = new ArrayList<>();\\n        \\n        for(int i=0;i<rectangles.length;i++)\\n            list [ rectangles[i][1]] .add(rectangles[i][0]);\\n        \\n        \\n        for(int i=1;i<101;i++)\\n            Collections.sort(list[i]);\\n        \\n        \\n        \\n        int result [] = new int [ points.length ];\\n        for(int i =0;i<points.length ; i++){\\n            int x = points [i][0];\\n            int y = points [i][1];\\n            for(int j = y;j<101;j++){\\n                int temp = Collections.binarySearch(list[j],x);\\n                if(temp<0)\\n                    result[i]+=list[j].size()+temp+1;\\n                else\\n                    result[i]+=list[j].size()-temp;\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997847,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        HashMap<Integer,ArrayList<Integer>> map = new HashMap<>();\\n        for(int[] rectangle:rectangles){\\n            map.putIfAbsent(rectangle[1],new ArrayList<>());\\n            map.get(rectangle[1]).add(rectangle[0]);\\n        }\\n        for(int key:map.keySet()){\\n            Collections.sort(map.get(key));\\n        }\\n        int[] ans = new int[points.length];\\n        int i=0;\\n        for(int[] point:points){\\n            int x = point[0];\\n            int y = point[1];\\n            ans[i++] = helper(map,x,y);\\n        }\\n        return ans;\\n    }\\n    public int helper(HashMap<Integer,ArrayList<Integer>> map,int x,int y){\\n        int count = 0;\\n        for(int h=y;h<=100;h++){\\n            ArrayList<Integer> list = map.getOrDefault(h,new ArrayList<>());\\n            int low = 0;\\n            int high = list.size()-1;\\n            int index = -1;\\n            while(low<=high){\\n                int mid= (low+high)/2;\\n                if(list.get(mid)>=x){\\n                    index = mid;\\n                    high = mid-1;\\n                }else if(list.get(mid)<x){\\n                    low = mid+1;\\n                }\\n            }\\n            if(index!=-1)\\n                count+=(list.size()-index);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        HashMap<Integer,ArrayList<Integer>> map = new HashMap<>();\\n        for(int[] rectangle:rectangles){\\n            map.putIfAbsent(rectangle[1],new ArrayList<>());\\n            map.get(rectangle[1]).add(rectangle[0]);\\n        }\\n        for(int key:map.keySet()){\\n            Collections.sort(map.get(key));\\n        }\\n        int[] ans = new int[points.length];\\n        int i=0;\\n        for(int[] point:points){\\n            int x = point[0];\\n            int y = point[1];\\n            ans[i++] = helper(map,x,y);\\n        }\\n        return ans;\\n    }\\n    public int helper(HashMap<Integer,ArrayList<Integer>> map,int x,int y){\\n        int count = 0;\\n        for(int h=y;h<=100;h++){\\n            ArrayList<Integer> list = map.getOrDefault(h,new ArrayList<>());\\n            int low = 0;\\n            int high = list.size()-1;\\n            int index = -1;\\n            while(low<=high){\\n                int mid= (low+high)/2;\\n                if(list.get(mid)>=x){\\n                    index = mid;\\n                    high = mid-1;\\n                }else if(list.get(mid)<x){\\n                    low = mid+1;\\n                }\\n            }\\n            if(index!=-1)\\n                count+=(list.size()-index);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997229,
                "title": "python-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        YX=[]\\n        for i in range(101):\\n            YX.append([])\\n        for rectangle in rectangles:\\n            YX[rectangle[1]].append(rectangle[0])\\n        for i in range(101):\\n            YX[i].sort()\\n        ans=[]\\n        for point in points:\\n            count=0\\n            for y in range(point[1],101):\\n                count+=len(YX[y])-bisect.bisect_left(YX[y],point[0])\\n            ans.append(count)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        YX=[]\\n        for i in range(101):\\n            YX.append([])\\n        for rectangle in rectangles:\\n            YX[rectangle[1]].append(rectangle[0])\\n        for i in range(101):\\n            YX[i].sort()\\n        ans=[]\\n        for point in points:\\n            count=0\\n            for y in range(point[1],101):\\n                count+=len(YX[y])-bisect.bisect_left(YX[y],point[0])\\n            ans.append(count)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992727,
                "title": "binary-search-java",
                "content": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int[] ele: rectangles){\\n            int L = ele[0];\\n            int H = ele[1];\\n            if(map.containsKey(H) == false){\\n                map.put(H, new ArrayList<>());\\n            }\\n            map.get(H).add(L);\\n        }\\n        \\n        for(Integer key: map.keySet()){\\n            List<Integer> list = map.get(key);\\n            Collections.sort(list);\\n        }\\n        \\n        int[] res = new int[points.length];\\n        int index = -1;\\n        for(int[] ele: points){\\n            int tmp = 0;\\n            index += 1;\\n            for(Integer key: map.keySet()){\\n                if(key>=ele[1]){\\n                    List<Integer> list = map.get(key);\\n                    int count = list.size() - binarySearch(list, ele[0]);\\n                    tmp += count;\\n                }\\n            }\\n            \\n            res[index] = tmp;\\n        }\\n        \\n        \\n        return res;\\n    }\\n    \\n    \\n    public int binarySearch(List<Integer> list, int val){\\n        int left = 0;\\n        int right = list.size();\\n        while(left < right){\\n            int mid = (left+right)/2;\\n            if(list.get(mid) >= val){\\n                right = mid;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        \\n        \\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int[] ele: rectangles){\\n            int L = ele[0];\\n            int H = ele[1];\\n            if(map.containsKey(H) == false){\\n                map.put(H, new ArrayList<>());\\n            }\\n            map.get(H).add(L);\\n        }\\n        \\n        for(Integer key: map.keySet()){\\n            List<Integer> list = map.get(key);\\n            Collections.sort(list);\\n        }\\n        \\n        int[] res = new int[points.length];\\n        int index = -1;\\n        for(int[] ele: points){\\n            int tmp = 0;\\n            index += 1;\\n            for(Integer key: map.keySet()){\\n                if(key>=ele[1]){\\n                    List<Integer> list = map.get(key);\\n                    int count = list.size() - binarySearch(list, ele[0]);\\n                    tmp += count;\\n                }\\n            }\\n            \\n            res[index] = tmp;\\n        }\\n        \\n        \\n        return res;\\n    }\\n    \\n    \\n    public int binarySearch(List<Integer> list, int val){\\n        int left = 0;\\n        int right = list.size();\\n        while(left < right){\\n            int mid = (left+right)/2;\\n            if(list.get(mid) >= val){\\n                right = mid;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        \\n        \\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990842,
                "title": "java-binary-search-on-width-clean-code",
                "content": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        List<Integer>[] lengths = new List[101];\\n        for (int i = 0; i <= 100; i++) lengths[i] = new ArrayList<Integer>();\\n        for (int[] rectangle : rectangles) {\\n            lengths[rectangle[1]].add(rectangle[0]);\\n        }\\n        for (int i = 0; i <= 100; i++) Collections.sort(lengths[i]);\\n        \\n        int[] ans = new int[points.length];\\n        for(int k = 0; k < ans.length; k++) {\\n            for(int i = points[k][1]; i <= 100; i++) {\\n                int insertPoint = Collections.binarySearch(lengths[i],points[k][0]);\\n                if (insertPoint >= 0) ans[k] += lengths[i].size() - insertPoint;\\n                else ans[k] += lengths[i].size() + insertPoint + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        List<Integer>[] lengths = new List[101];\\n        for (int i = 0; i <= 100; i++) lengths[i] = new ArrayList<Integer>();\\n        for (int[] rectangle : rectangles) {\\n            lengths[rectangle[1]].add(rectangle[0]);\\n        }\\n        for (int i = 0; i <= 100; i++) Collections.sort(lengths[i]);\\n        \\n        int[] ans = new int[points.length];\\n        for(int k = 0; k < ans.length; k++) {\\n            for(int i = points[k][1]; i <= 100; i++) {\\n                int insertPoint = Collections.binarySearch(lengths[i],points[k][0]);\\n                if (insertPoint >= 0) ans[k] += lengths[i].size() - insertPoint;\\n                else ans[k] += lengths[i].size() + insertPoint + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987385,
                "title": "python-using-dictionary-sorting-and-binarysearch",
                "content": "```\\nclass Solution:\\n    def countRectangles(self, rec: List[List[int]], pnt: List[List[int]]) -> List[int]:\\n        \\n        d = defaultdict(list)\\n        done = defaultdict(list)\\n        for x,y in rec:\\n            d[y].append(x)\\n        \\n        respnt = []\\n        for x,y in pnt:\\n            \\n            res = 0\\n            for j in range(y,101):\\n                if d[j]:\\n                    if not done[j]:\\n                        done[j] = 1\\n                        d[j].sort()\\n                    res += len(d[j]) - bisect_left(d[j],x)\\n                    \\n            respnt.append(res)\\n            \\n        return respnt\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def countRectangles(self, rec: List[List[int]], pnt: List[List[int]]) -> List[int]:\\n        \\n        d = defaultdict(list)\\n        done = defaultdict(list)\\n        for x,y in rec:\\n            d[y].append(x)\\n        \\n        respnt = []\\n        for x,y in pnt:\\n            \\n            res = 0\\n            for j in range(y,101):\\n                if d[j]:\\n                    if not done[j]:\\n                        done[j] = 1\\n                        d[j].sort()\\n                    res += len(d[j]) - bisect_left(d[j],x)\\n                    \\n            respnt.append(res)\\n            \\n        return respnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986500,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        HashMap<Integer,List<Integer>> T = new HashMap(); // for storing y coordinates as keys and list of x coordinates as values\\n        for(int r[]:rectangles){\\n            List<Integer> A = T.getOrDefault(r[1],new ArrayList());\\n            A.add(r[0]);\\n            T.put(r[1],A);\\n        }\\n        for(List<Integer> A:T.values()){ //Sorting inorder to binary search coordinates later on\\n            Collections.sort(A);\\n        }\\n        System.out.println(T);\\n        int k=0,m=points.length;\\n        int ans[] = new int[m];\\n        for(int p[]:points){\\n            int c=0;\\n            for(int i=p[1];i<=100;i++){\\n                List<Integer> A = T.getOrDefault(i,new ArrayList());\\n                if(A.size()>0){\\n                    int x = Collections.binarySearch(A,p[0]);\\n                    if(x<0 && -x-1<A.size()){\\n                        c+=A.size()+x+1;\\n                    }\\n                    else if(x>=0){\\n                        c+=A.size()-x;\\n                    }\\n                }\\n            }\\n            ans[k++]=c;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        HashMap<Integer,List<Integer>> T = new HashMap(); // for storing y coordinates as keys and list of x coordinates as values\\n        for(int r[]:rectangles){\\n            List<Integer> A = T.getOrDefault(r[1],new ArrayList());\\n            A.add(r[0]);\\n            T.put(r[1],A);\\n        }\\n        for(List<Integer> A:T.values()){ //Sorting inorder to binary search coordinates later on\\n            Collections.sort(A);\\n        }\\n        System.out.println(T);\\n        int k=0,m=points.length;\\n        int ans[] = new int[m];\\n        for(int p[]:points){\\n            int c=0;\\n            for(int i=p[1];i<=100;i++){\\n                List<Integer> A = T.getOrDefault(i,new ArrayList());\\n                if(A.size()>0){\\n                    int x = Collections.binarySearch(A,p[0]);\\n                    if(x<0 && -x-1<A.size()){\\n                        c+=A.size()+x+1;\\n                    }\\n                    else if(x>=0){\\n                        c+=A.size()-x;\\n                    }\\n                }\\n            }\\n            ans[k++]=c;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984031,
                "title": "c-easy-code",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        int i,j,n = rectangles.size(),m = points.size();\\n        \\n        vector<vector<int>> vec(101);\\n        vector<int> res;\\n        \\n        for(i=1;i<=100;i++){\\n            for(j=0;j<n;j++){\\n                if(rectangles[j][1]>=i){\\n                    vec[i].push_back(rectangles[j][0]);\\n                }\\n            }\\n        }\\n        \\n        \\n        for(i=1;i<=100;i++){\\n            sort(vec[i].begin(),vec[i].end());\\n        }\\n        \\n        \\n        for(i=0;i<m;i++){\\n            int r = points[i][0];\\n            int k = points[i][1];\\n            int p = lower_bound(vec[k].begin(),vec[k].end(),r) - vec[k].begin();\\n            res.push_back(vec[k].size()-p);\\n        }\\n        \\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        int i,j,n = rectangles.size(),m = points.size();\\n        \\n        vector<vector<int>> vec(101);\\n        vector<int> res;\\n        \\n        for(i=1;i<=100;i++){\\n            for(j=0;j<n;j++){\\n                if(rectangles[j][1]>=i){\\n                    vec[i].push_back(rectangles[j][0]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1983845,
                "title": "bisect-on-bisect-80-speed",
                "content": "![image](https://assets.leetcode.com/users/images/e67ae4e2-37ab-4ff8-b999-b14c3c13f367_1650977753.8137095.png)\\nEach sorted height has sorted lengths. First bisect on heights (because those are fewer). Second bisect on lengths for each valid height.\\n```\\nfrom collections import defaultdict\\nfrom bisect import bisect_left, insort_left\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        height_length = defaultdict(list)\\n        for length, h in rectangles:\\n            insort_left(height_length[h], length)\\n        lst_h = sorted(height_length.keys())\\n        return [sum(len(height_length[h]) - bisect_left(height_length[h], x)\\n                    for h in lst_h[bisect_left(lst_h, y):]) for x, y in points]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom bisect import bisect_left, insort_left\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        height_length = defaultdict(list)\\n        for length, h in rectangles:\\n            insort_left(height_length[h], length)\\n        lst_h = sorted(height_length.keys())\\n        return [sum(len(height_length[h]) - bisect_left(height_length[h], x)\\n                    for h in lst_h[bisect_left(lst_h, y):]) for x, y in points]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983293,
                "title": "python-beat-100-o-nlogn-group-by-y-and-binary-serach",
                "content": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        maxh = 100\\n        points_slot = [[] for _ in range(maxh + 1)]\\n        for i, (x, y) in enumerate(points): points_slot[y].append((x, i))\\n        rectangles.sort()\\n        ans = [0] * len(points)\\n        for curh in range(1, maxh + 1):\\n            if not points_slot[curh]: continue\\n            currec = [w for w, h in rectangles if h >= curh]\\n            if not currec: break\\n            for x, i in points_slot[curh]: ans[i] = len(currec) - bisect_left(currec, x)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        maxh = 100\\n        points_slot = [[] for _ in range(maxh + 1)]\\n        for i, (x, y) in enumerate(points): points_slot[y].append((x, i))\\n        rectangles.sort()\\n        ans = [0] * len(points)\\n        for curh in range(1, maxh + 1):\\n            if not points_slot[curh]: continue\\n            currec = [w for w, h in rectangles if h >= curh]\\n            if not currec: break\\n            for x, i in points_slot[curh]: ans[i] = len(currec) - bisect_left(currec, x)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983207,
                "title": "simple-c-solution",
                "content": "Take a data structure to store `vector<vector<int>> v`  to store the heights then lengths of all the rectangles.  Idea is the max value of height is 101 so store all diff values of height in a vector.  sort it and find index using lowerbound. all the lengths after the lowerbound should also contain the point so increment the count.\\n\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> countRectangles(vector<vector<int>> &rectangles, vector<vector<int>> &points)\\n    {\\n        int n = rectangles.size(), m = points.size();\\n        \\n\\t\\tsort(rectangles.begin(), rectangles.end());\\n        \\n\\t\\tvector<vector<int>> res(101);\\n        for (int i = 0; i < n; i++)\\n        {\\n            res[rectangles[i][1]].push_back(rectangles[i][0]); // <<l1,l2>,<l3,l4,l5>>\\n        }\\n\\t\\t\\n        // sort all length vector\\n        for (int i = 0; i < 101; i++)\\n        {\\n            sort(res[i].begin(), res[i].end());\\n        }\\n\\t\\t\\n        vector<int> ans;\\n        for (auto pt : points)\\n        {\\n            int cnt = 0;\\n            int x = pt[0], y = pt[1];\\n            for (int i = y; i < 101; i++)\\n            {\\n                int index = lower_bound(res[i].begin(), res[i].end(), x) - res[i].begin();\\n                cnt += res[i].size() - index;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> countRectangles(vector<vector<int>> &rectangles, vector<vector<int>> &points)\\n    {\\n        int n = rectangles.size(), m = points.size();\\n        \\n\\t\\tsort(rectangles.begin(), rectangles.end());\\n        \\n\\t\\tvector<vector<int>> res(101);\\n        for (int i = 0; i < n; i++)\\n        {\\n            res[rectangles[i][1]].push_back(rectangles[i][0]); // <<l1,l2>,<l3,l4,l5>>\\n        }\\n\\t\\t\\n        // sort all length vector\\n        for (int i = 0; i < 101; i++)\\n        {\\n            sort(res[i].begin(), res[i].end());\\n        }\\n\\t\\t\\n        vector<int> ans;\\n        for (auto pt : points)\\n        {\\n            int cnt = 0;\\n            int x = pt[0], y = pt[1];\\n            for (int i = y; i < 101; i++)\\n            {\\n                int index = lower_bound(res[i].begin(), res[i].end(), x) - res[i].begin();\\n                cnt += res[i].size() - index;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983023,
                "title": "c-binary-search-map-height-to-length",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rect , vector<vector<int>>& points) {\\n        sort(begin(rect),end(rect)) ;\\n        vector<vector<int>>hArr(101) ;\\n        \\n        //map height with length !! \\n        for(auto&V : rect){\\n            int h = V[1] , l = V[0] ;\\n            hArr[h].push_back(l) ;\\n        }\\n        \\n        vector<int> ans ;\\n        \\n        for(auto &x : points){\\n            int atLeastX = x[0] , atLeastY = x[1] ;\\n            int temp = 0 ;\\n\\t\\t\\t//points height should be less than equal to the rectangle height for it to lie inside\\n            for(int i = atLeastY ; i <= 100 ; ++i ){\\n                vector<int> &arr = hArr[i] ; //important to take as reference otherwise givve TLE !! \\n                auto lb = lower_bound(begin(arr),end(arr),atLeastX) ;\\n                temp += distance(lb,end(arr)) ;\\n            }\\n            ans.push_back(temp) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rect , vector<vector<int>>& points) {\\n        sort(begin(rect),end(rect)) ;\\n        vector<vector<int>>hArr(101) ;\\n        \\n        //map height with length !! \\n        for(auto&V : rect){\\n            int h = V[1] , l = V[0] ;\\n            hArr[h].push_back(l) ;\\n        }\\n        \\n        vector<int> ans ;\\n        \\n        for(auto &x : points){\\n            int atLeastX = x[0] , atLeastY = x[1] ;\\n            int temp = 0 ;\\n\\t\\t\\t//points height should be less than equal to the rectangle height for it to lie inside\\n            for(int i = atLeastY ; i <= 100 ; ++i ){\\n                vector<int> &arr = hArr[i] ; //important to take as reference otherwise givve TLE !! \\n                auto lb = lower_bound(begin(arr),end(arr),atLeastX) ;\\n                temp += distance(lb,end(arr)) ;\\n            }\\n            ans.push_back(temp) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982914,
                "title": "c-nlogn",
                "content": "* All queries are known before hand - can process in sorted order. \\n* Max width of 1e9 implies some sort of logrithmic solution required. In this case I chose sort + iterate. \\n* Max height of 100 implies we can bruteforce. \\n\\nThe algorithm inserts all points into `p`, and  height into `y_axis` - we then sort `p`. Iterate through sorted query `q`, and drop the rectangles that are too small. For the remaining rectangles, only count the ones that can possible include the query point with `rv[i] += y_axis[j]`. \\n\\n```\\n    vector<int> countRectangles(vector<vector<int>> &rectangles, vector<vector<int>> &points)\\n    {\\n        vector<array<int, 3>> q;\\n        for (auto i = 0; i < points.size(); ++i)\\n            q.push_back({points[i][0], points[i][1], i});\\n        sort(begin(q), end(q));\\n\\n        vector<array<int, 2>> p;\\n        vector<int> y_axis(101);\\n        for (auto &r : rectangles)\\n            p.push_back({r[0], r[1]}), ++y_axis[r[1]];\\n        sort(begin(p), end(p));\\n\\n        vector<int> rv(q.size());\\n        int k = 0;\\n        for (auto &[x, y, i] : q)\\n        {\\n            while (k < p.size() && p[k][0] < x)\\n                --y_axis[p[k][1]], ++k;\\n            for (auto j = y; j < 101; ++j)\\n                rv[i] += y_axis[j];\\n        }\\n        return rv;\\n    }\\n",
                "solutionTags": [],
                "code": "* All queries are known before hand - can process in sorted order. \\n* Max width of 1e9 implies some sort of logrithmic solution required. In this case I chose sort + iterate. \\n* Max height of 100 implies we can bruteforce. \\n\\nThe algorithm inserts all points into `p`, and  height into `y_axis` - we then sort `p`. Iterate through sorted query `q`, and drop the rectangles that are too small. For the remaining rectangles, only count the ones that can possible include the query point with `rv[i] += y_axis[j]`. \\n\\n```\\n    vector<int> countRectangles(vector<vector<int>> &rectangles, vector<vector<int>> &points)\\n    {\\n        vector<array<int, 3>> q;\\n        for (auto i = 0; i < points.size(); ++i)\\n            q.push_back({points[i][0], points[i][1], i});\\n        sort(begin(q), end(q));\\n\\n        vector<array<int, 2>> p;\\n        vector<int> y_axis(101);\\n        for (auto &r : rectangles)\\n            p.push_back({r[0], r[1]}), ++y_axis[r[1]];\\n        sort(begin(p), end(p));\\n\\n        vector<int> rv(q.size());\\n        int k = 0;\\n        for (auto &[x, y, i] : q)\\n        {\\n            while (k < p.size() && p[k][0] < x)\\n                --y_axis[p[k][1]], ++k;\\n            for (auto j = y; j < 101; ++j)\\n                rv[i] += y_axis[j];\\n        }\\n        return rv;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1982766,
                "title": "golang-simple-binary-search",
                "content": "```go\\nfunc countRectangles(rectangles [][]int, points [][]int) []int {\\n\\trectWidths := make([][]int, 101)\\n\\tfor _, rect := range rectangles {\\n\\t\\t// width: rect[0], height: rect[1]\\n\\t\\tfor h := 1; h <= rect[1]; h++ {\\n\\t\\t\\trectWidths[h] = append(rectWidths[h], rect[0])\\n\\t\\t}\\n\\t}\\n\\tfor _, v := range rectWidths {\\n\\t\\tsort.Ints(v)\\n\\t}\\n\\tresult := make([]int, len(points))\\n\\tfor i, point := range points {\\n\\t\\t// width: point[0], height: point[1]\\n\\t\\tresult[i] = binarySearch(point[0], rectWidths[point[1]])\\n\\t}\\n\\treturn result\\n}\\n\\n// find GE\\nfunc binarySearch(val int, array []int) int {\\n\\tl, r := 0, len(array)-1\\n\\tfor l <= r {\\n\\t\\tm := (l + r) >> 1\\n\\t\\tif array[m] < val {\\n\\t\\t\\tl = m + 1\\n\\t\\t} else {\\n\\t\\t\\tr = m - 1\\n\\t\\t}\\n\\t}\\n\\t// array[l] first GE\\n\\treturn len(array) - l\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```go\\nfunc countRectangles(rectangles [][]int, points [][]int) []int {\\n\\trectWidths := make([][]int, 101)\\n\\tfor _, rect := range rectangles {\\n\\t\\t// width: rect[0], height: rect[1]\\n\\t\\tfor h := 1; h <= rect[1]; h++ {\\n\\t\\t\\trectWidths[h] = append(rectWidths[h], rect[0])\\n\\t\\t}\\n\\t}\\n\\tfor _, v := range rectWidths {\\n\\t\\tsort.Ints(v)\\n\\t}\\n\\tresult := make([]int, len(points))\\n\\tfor i, point := range points {\\n\\t\\t// width: point[0], height: point[1]\\n\\t\\tresult[i] = binarySearch(point[0], rectWidths[point[1]])\\n\\t}\\n\\treturn result\\n}\\n\\n// find GE\\nfunc binarySearch(val int, array []int) int {\\n\\tl, r := 0, len(array)-1\\n\\tfor l <= r {\\n\\t\\tm := (l + r) >> 1\\n\\t\\tif array[m] < val {\\n\\t\\t\\tl = m + 1\\n\\t\\t} else {\\n\\t\\t\\tr = m - 1\\n\\t\\t}\\n\\t}\\n\\t// array[l] first GE\\n\\treturn len(array) - l\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1981528,
                "title": "python-sortedlist-for-heights-of-rectangles-o-nlogn",
                "content": "Process points in increasing order while maintaining sortedlist for heights of remaining rectangles.\\nWe can discard rectangles whose width is less than x-coordinate of the current point.\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        points = sorted([(x, y, i) for i, (x, y) in enumerate(points)])\\n        rectangles.sort()\\n        sl = SortedList([y for x, y in rectangles])\\n        j = 0\\n        count = [0]*len(points)\\n        for x, y, i in points:\\n            while j < len(rectangles) and rectangles[j][0] < x:\\n                sl.discard(rectangles[j][1])\\n                j += 1\\n            count[i] = len(sl) - sl.bisect_left(y)\\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "Process points in increasing order while maintaining sortedlist for heights of remaining rectangles.\\nWe can discard rectangles whose width is less than x-coordinate of the current point.\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        points = sorted([(x, y, i) for i, (x, y) in enumerate(points)])\\n        rectangles.sort()\\n        sl = SortedList([y for x, y in rectangles])\\n        j = 0\\n        count = [0]*len(points)\\n        for x, y, i in points:\\n            while j < len(rectangles) and rectangles[j][0] < x:\\n                sl.discard(rectangles[j][1])\\n                j += 1\\n            count[i] = len(sl) - sl.bisect_left(y)\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1980128,
                "title": "bitmap-sort-java",
                "content": "[Note] this is a solution from others.\\nFind a nice solution. Still don\\'t understand why removing and adding rightmost bit one by one would work. I know the number of prior valid rectangles are stored in bitMap. But what\\'s the intuition behind the way it stores and retrieve the number?\\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Arrays.sort(rectangles , (a, b) -> b[0] - a[0]);\\n        \\n        int [][] mPoints = new int [points.length][];\\n        int maxWidth = 0;\\n        \\n        for (int i = 0; i < points.length; ++i){\\n            mPoints[i] = new int [] {points[i][0], points[i][1], i};\\n        }\\n        \\n        Arrays.sort(mPoints, (a, b) -> b[0] - a[0]);\\n        \\n        int [] result = new int [points.length];\\n        int idx = 0;\\n        \\n        int [] bit = new int [101];\\n        \\n        for (int i = 0; i < rectangles.length; ++i){\\n            int[] rect = rectangles[i];\\n            \\n            while (idx < points.length && mPoints[idx][0] > rect[0] ){\\n                result[mPoints[idx][2]] = getBit(bit, mPoints[idx][1]);\\n                ++idx;\\n            }\\n            \\n            addToBit(bit, rect[1]);\\n        }\\n        \\n        while (idx < points.length) {\\n            result[mPoints[idx][2]] = getBit(bit, mPoints[idx][1]);\\n            ++idx;\\n        }\\n               \\n        return result;\\n    }\\n    \\n    private void addToBit(int [] bit, int val){\\n        for (int i = val; i > 0; i -= (i & -i))\\n            ++bit[i];\\n    }\\n    \\n    private int getBit(int [] bit, int val){\\n        int result = 0;\\n        \\n        for (int i = val; i < bit.length; i += (i & -i))\\n            result += bit[i];\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        Arrays.sort(rectangles , (a, b) -> b[0] - a[0]);\\n        \\n        int [][] mPoints = new int [points.length][];\\n        int maxWidth = 0;\\n        \\n        for (int i = 0; i < points.length; ++i){\\n            mPoints[i] = new int [] {points[i][0], points[i][1], i};\\n        }\\n        \\n        Arrays.sort(mPoints, (a, b) -> b[0] - a[0]);\\n        \\n        int [] result = new int [points.length];\\n        int idx = 0;\\n        \\n        int [] bit = new int [101];\\n        \\n        for (int i = 0; i < rectangles.length; ++i){\\n            int[] rect = rectangles[i];\\n            \\n            while (idx < points.length && mPoints[idx][0] > rect[0] ){\\n                result[mPoints[idx][2]] = getBit(bit, mPoints[idx][1]);\\n                ++idx;\\n            }\\n            \\n            addToBit(bit, rect[1]);\\n        }\\n        \\n        while (idx < points.length) {\\n            result[mPoints[idx][2]] = getBit(bit, mPoints[idx][1]);\\n            ++idx;\\n        }\\n               \\n        return result;\\n    }\\n    \\n    private void addToBit(int [] bit, int val){\\n        for (int i = val; i > 0; i -= (i & -i))\\n            ++bit[i];\\n    }\\n    \\n    private int getBit(int [] bit, int val){\\n        int result = 0;\\n        \\n        for (int i = val; i < bit.length; i += (i & -i))\\n            result += bit[i];\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980035,
                "title": "c-sort-suffix",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a,vector<int>& b)\\n    {\\n        return a[1]<b[1];\\n    }\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) \\n    {\\n        for(auto &x:rectangles)swap(x[0],x[1]);\\n        for(auto &x:points)swap(x[0],x[1]);\\n        int n=points.size();\\n        map<pair<int,int>,int>record;\\n        for(auto &x:points)record[{x[0],x[1]}]=record.size();\\n        sort(rectangles.begin(),rectangles.end(),cmp);\\n        sort(points.begin(),points.end(),cmp);\\n        vector<vector<pair<int,int>>>st(101);\\n        int idx=0;\\n        for(auto &cur:rectangles)\\n        {\\n            int l=cur[0],h=cur[1];\\n            while(idx<n&&points[idx][1]<=h)\\n            {\\n                st[points[idx][0]].push_back({points[idx][1],0});\\n                idx++;\\n            }\\n            for(int i=0;i<=l;i++)\\n                if(st[i].size()!=0)st[i].back().second++;\\n        }\\n        vector<int>ans(n,0);\\n        for(int i=0;i<=100;i++)\\n            for(int j=st[i].size()-1;j>=0;j--)\\n            {\\n                st[i][j].second+=(j+1<st[i].size()) ? st[i][j+1].second : 0;\\n                ans[record[{i,st[i][j].first}]]=st[i][j].second;\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a,vector<int>& b)\\n    {\\n        return a[1]<b[1];\\n    }\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) \\n    {\\n        for(auto &x:rectangles)swap(x[0],x[1]);\\n        for(auto &x:points)swap(x[0],x[1]);\\n        int n=points.size();\\n        map<pair<int,int>,int>record;\\n        for(auto &x:points)record[{x[0],x[1]}]=record.size();\\n        sort(rectangles.begin(),rectangles.end(),cmp);\\n        sort(points.begin(),points.end(),cmp);\\n        vector<vector<pair<int,int>>>st(101);\\n        int idx=0;\\n        for(auto &cur:rectangles)\\n        {\\n            int l=cur[0],h=cur[1];\\n            while(idx<n&&points[idx][1]<=h)\\n            {\\n                st[points[idx][0]].push_back({points[idx][1],0});\\n                idx++;\\n            }\\n            for(int i=0;i<=l;i++)\\n                if(st[i].size()!=0)st[i].back().second++;\\n        }\\n        vector<int>ans(n,0);\\n        for(int i=0;i<=100;i++)\\n            for(int j=st[i].size()-1;j>=0;j--)\\n            {\\n                st[i][j].second+=(j+1<st[i].size()) ? st[i][j+1].second : 0;\\n                ans[record[{i,st[i][j].first}]]=st[i][j].second;\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979611,
                "title": "lookout-for-height-constraint-c-solution-binary-search-map-of-sorted-list",
                "content": "I didn\\'t notice the constraints and it bit me as I wasted a lot of time doing the wrong implementation. Notice that Length can be huge, but Height can only go up to 100. This means that you must group by Height first, and then do Binary Search on the Length. Doing Binary Search on the Length is what allows your algorithm to be efficient enough to pass the time constraint.\\n\\nMy C# Implementation below:\\n```\\npublic class Solution {\\n    public int[] CountRectangles(int[][] rectangles, int[][] points) {\\n        int[] result = new int[points.Length];\\n        Dictionary<int, SortedList<int, int>> lengthBuckets = new Dictionary<int, SortedList<int, int>>();\\n        foreach (int[] rect in rectangles) {\\n            if (lengthBuckets.ContainsKey(rect[1]))\\n                lengthBuckets[rect[1]].Add(rect[0], rect[0]);\\n            else {\\n                lengthBuckets[rect[1]] = new SortedList<int, int>();\\n                lengthBuckets[rect[1]].Add(rect[0], rect[0]);\\n            }\\n        }\\n        \\n        for (int i = 0; i < points.Length; i++) {\\n            int targetX = points[i][1];\\n\\t\\t\\tint targetY = points[i][0];\\n\\t\\t\\t\\n            foreach (var bucket in lengthBuckets) { // Apply binary search to search each bucket quickly\\n                if (bucket.Key < targetX)\\n                    continue;\\n                int l = 0;\\n                int r = bucket.Value.Count - 1;\\n                int mid = (l + r) / 2;\\n                \\n                if (bucket.Value.Values[r] < points[i][0])\\n                    continue;\\n\\n                while (l < r) {\\n                    if (targetY <= bucket.Value.Values[mid])\\n                        r = mid;\\n                    else if (targetY > bucket.Value.Values[mid])\\n                        l = mid + 1;\\n                    mid = (l + r) / 2;\\n                }\\n                result[i] += bucket.Value.Count - mid;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] CountRectangles(int[][] rectangles, int[][] points) {\\n        int[] result = new int[points.Length];\\n        Dictionary<int, SortedList<int, int>> lengthBuckets = new Dictionary<int, SortedList<int, int>>();\\n        foreach (int[] rect in rectangles) {\\n            if (lengthBuckets.ContainsKey(rect[1]))\\n                lengthBuckets[rect[1]].Add(rect[0], rect[0]);\\n            else {\\n                lengthBuckets[rect[1]] = new SortedList<int, int>();\\n                lengthBuckets[rect[1]].Add(rect[0], rect[0]);\\n            }\\n        }\\n        \\n        for (int i = 0; i < points.Length; i++) {\\n            int targetX = points[i][1];\\n\\t\\t\\tint targetY = points[i][0];\\n\\t\\t\\t\\n            foreach (var bucket in lengthBuckets) { // Apply binary search to search each bucket quickly\\n                if (bucket.Key < targetX)\\n                    continue;\\n                int l = 0;\\n                int r = bucket.Value.Count - 1;\\n                int mid = (l + r) / 2;\\n                \\n                if (bucket.Value.Values[r] < points[i][0])\\n                    continue;\\n\\n                while (l < r) {\\n                    if (targetY <= bucket.Value.Values[mid])\\n                        r = mid;\\n                    else if (targetY > bucket.Value.Values[mid])\\n                        l = mid + 1;\\n                    mid = (l + r) / 2;\\n                }\\n                result[i] += bucket.Value.Count - mid;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979546,
                "title": "python3-binary-search-o-nlogn",
                "content": "Key ideas:\\n1. sort the rectangle array by x so we can perform binary search and have one less dimension to worry about\\n2. sort the query point by x as well but keep their index for the final answer\\n3. data_x stores all width by increasing order(do not change)\\n4. data_y stores all height by increasing order(build incrementally when we check all query points)\\n5. for each query point q_x, q_y,  a single binary search will quickly find out how many xs are larger than or equal to q_x, these are the potential rectangles that can contain the query point. Add all height of the potential rectangles to data_y and use binary search again to find out how many ys are larger than or equal to q_y. \\n\\n```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n      \\n      rectangles.sort(key = lambda x : x[0])\\n      \\n      for i in range(len(points)):\\n        points[i] += [i]\\n\\n      points.sort(key = lambda x : x[0])\\n      \\n      data_x = [x[0] for x in rectangles]\\n      data_y = []\\n      prev_ind = len(rectangles)\\n      \\n      res = [0]*len(points)\\n      \\n      for i in range(len(points)-1, -1, -1):\\n        q_x, q_y, loc = points[i]\\n        ind = bisect.bisect_left(data_x, q_x)\\n        for t in range(ind, prev_ind):\\n          bisect.insort(data_y, rectangles[t][1])\\n        prev_ind = ind\\n        res[loc] = len(data_y) - bisect.bisect_left(data_y, q_y)\\n      \\n      return res\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n      \\n      rectangles.sort(key = lambda x : x[0])\\n      \\n      for i in range(len(points)):\\n        points[i] += [i]\\n\\n      points.sort(key = lambda x : x[0])\\n      \\n      data_x = [x[0] for x in rectangles]\\n      data_y = []\\n      prev_ind = len(rectangles)\\n      \\n      res = [0]*len(points)\\n      \\n      for i in range(len(points)-1, -1, -1):\\n        q_x, q_y, loc = points[i]\\n        ind = bisect.bisect_left(data_x, q_x)\\n        for t in range(ind, prev_ind):\\n          bisect.insort(data_y, rectangles[t][1])\\n        prev_ind = ind\\n        res[loc] = len(data_y) - bisect.bisect_left(data_y, q_y)\\n      \\n      return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979422,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        #index is height. 1 <= hi, yj <= 100. value where be x value array\\n        hArr = [[] for _ in range(100)]\\n        \\n        for a, b in rectangles:\\n            hArr[b-1].append(a)\\n        \\n        # sort\\n        for i in range(100):\\n            hArr[i].sort()\\n      \\n        ans = []\\n        \\n        for x, y in points:\\n            c = 0\\n            for i in range(y-1, 100):\\n                if len(hArr[i])==0:\\n                    continue\\n                index = bisect_left(hArr[i], x)\\n                if index <= len(hArr[i])-1:\\n                    c += len(hArr[i]) -index\\n            ans.append(c)\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        #index is height. 1 <= hi, yj <= 100. value where be x value array\\n        hArr = [[] for _ in range(100)]\\n        \\n        for a, b in rectangles:\\n            hArr[b-1].append(a)\\n        \\n        # sort\\n        for i in range(100):\\n            hArr[i].sort()\\n      \\n        ans = []\\n        \\n        for x, y in points:\\n            c = 0\\n            for i in range(y-1, 100):\\n                if len(hArr[i])==0:\\n                    continue\\n                index = bisect_left(hArr[i], x)\\n                if index <= len(hArr[i])-1:\\n                    c += len(hArr[i]) -index\\n            ans.append(c)\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979331,
                "title": "java-treemap-arraylist-binarysearch-lowerbound",
                "content": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rec, int[][] points) {\\n        TreeMap<Integer, List<Integer>> map = new TreeMap<>();\\n        int maxy = 0;\\n        int maxx = 0;\\n        List<Integer> res = new ArrayList<>();\\n        \\n        for(int[] arr: rec){\\n            List<Integer> l = map.getOrDefault(arr[1], new ArrayList<Integer>());\\n            l.add(arr[0]);\\n            map.put(arr[1], l);\\n            maxy = Math.max(arr[1], maxy);\\n            maxx = Math.max(arr[0], maxx);\\n        }\\n        \\n        for(Map.Entry<Integer, List<Integer>> entry: map.entrySet()){\\n            List<Integer> l = entry.getValue();\\n            Collections.sort(l);\\n        }\\n        \\n        int count = 0;\\n        for(int[] p: points){\\n            int x = p[0];\\n            int y = p[1];\\n            \\n            for(Map.Entry<Integer, List<Integer>> entry: map.entrySet()){\\n                if(y > entry.getKey()){\\n                    continue;\\n                }\\n                else{\\n                    int tmp = 0;\\n                    List<Integer> l = entry.getValue();\\n                    int start = 0;\\n                    int end = l.size()-1;\\n                    int index = 0;\\n                    while(start <= end){\\n                        int mid = start + (end - start)/2;\\n                        if(l.get(mid) > x){\\n                            end = mid-1;\\n                            tmp = l.size() - mid;\\n                        }\\n                        else if(l.get(mid) < x){\\n                            start = mid+1;\\n                        }\\n                        else if(l.get(mid) == x){\\n                            end = mid-1;\\n                            tmp = l.size() - mid;\\n                        }\\n                    }\\n                    count+=tmp;\\n                }\\n            }\\n            res.add(count);\\n            count = 0;\\n        }\\n        int[] arr = new int[res.size()];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i] = res.get(i);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rec, int[][] points) {\\n        TreeMap<Integer, List<Integer>> map = new TreeMap<>();\\n        int maxy = 0;\\n        int maxx = 0;\\n        List<Integer> res = new ArrayList<>();\\n        \\n        for(int[] arr: rec){\\n            List<Integer> l = map.getOrDefault(arr[1], new ArrayList<Integer>());\\n            l.add(arr[0]);\\n            map.put(arr[1], l);\\n            maxy = Math.max(arr[1], maxy);\\n            maxx = Math.max(arr[0], maxx);\\n        }\\n        \\n        for(Map.Entry<Integer, List<Integer>> entry: map.entrySet()){\\n            List<Integer> l = entry.getValue();\\n            Collections.sort(l);\\n        }\\n        \\n        int count = 0;\\n        for(int[] p: points){\\n            int x = p[0];\\n            int y = p[1];\\n            \\n            for(Map.Entry<Integer, List<Integer>> entry: map.entrySet()){\\n                if(y > entry.getKey()){\\n                    continue;\\n                }\\n                else{\\n                    int tmp = 0;\\n                    List<Integer> l = entry.getValue();\\n                    int start = 0;\\n                    int end = l.size()-1;\\n                    int index = 0;\\n                    while(start <= end){\\n                        int mid = start + (end - start)/2;\\n                        if(l.get(mid) > x){\\n                            end = mid-1;\\n                            tmp = l.size() - mid;\\n                        }\\n                        else if(l.get(mid) < x){\\n                            start = mid+1;\\n                        }\\n                        else if(l.get(mid) == x){\\n                            end = mid-1;\\n                            tmp = l.size() - mid;\\n                        }\\n                    }\\n                    count+=tmp;\\n                }\\n            }\\n            res.add(count);\\n            count = 0;\\n        }\\n        int[] arr = new int[res.size()];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i] = res.get(i);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979316,
                "title": "python-follow-the-hints",
                "content": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        heights = defaultdict(list)\\n        for x, y in rectangles: heights[y].append(x)\\n        for h in range(1, 101): heights[h].sort()\\n        result = []\\n\\n        for x, y in points:\\n            count = 0\\n            for height in range(y, 101):\\n                count += len(heights[height]) - bisect_left(heights[height], x)\\n            result.append(count)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        heights = defaultdict(list)\\n        for x, y in rectangles: heights[y].append(x)\\n        for h in range(1, 101): heights[h].sort()\\n        result = []\\n\\n        for x, y in points:\\n            count = 0\\n            for height in range(y, 101):\\n                count += len(heights[height]) - bisect_left(heights[height], x)\\n            result.append(count)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979314,
                "title": "python",
                "content": "\\n```\\ndef countRectangles(self, rect: List[List[int]], points: List[List[int]]) -> List[int]:\\n        \\n        nr,np = len(rect),len(points)\\n        res = [0]*np\\n        \\n        rect = sorted(rect,key = lambda x:x[1])\\n        pinx = [i[0] for i in sorted(enumerate(points), key=lambda x:x[1][1])]\\n        points = sorted(points, key =lambda x:x[1])\\n        \\n        c1,c2 = nr-1,np-1\\n        ns = []\\n        for i in range(100,-1,-1):\\n            while c1>=0 and rect[c1][1]==i:\\n                ns.append(rect[c1][0])\\n                c1-=1\\n            ns.sort()\\n            n = len(ns)\\n            while c2>=0 and points[c2][1]==i:\\n                tmp = bisect_left(ns,points[c2][0])\\n                res[pinx[c2]] = n-tmp\\n                c2-=1\\n        return res\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\ndef countRectangles(self, rect: List[List[int]], points: List[List[int]]) -> List[int]:\\n        \\n        nr,np = len(rect),len(points)\\n        res = [0]*np\\n        \\n        rect = sorted(rect,key = lambda x:x[1])\\n        pinx = [i[0] for i in sorted(enumerate(points), key=lambda x:x[1][1])]\\n        points = sorted(points, key =lambda x:x[1])\\n        \\n        c1,c2 = nr-1,np-1\\n        ns = []\\n        for i in range(100,-1,-1):\\n            while c1>=0 and rect[c1][1]==i:\\n                ns.append(rect[c1][0])\\n                c1-=1\\n            ns.sort()\\n            n = len(ns)\\n            while c2>=0 and points[c2][1]==i:\\n                tmp = bisect_left(ns,points[c2][0])\\n                res[pinx[c2]] = n-tmp\\n                c2-=1\\n        return res\\n        \\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1978990,
                "title": "java-solution",
                "content": "\\n\\n        Map<Integer,List<Integer>> mp=new HashMap<>();\\n        for(int t[]:rectangles)\\n        {\\n            if(mp.containsKey(t[1]))\\n            {\\n                List<Integer> al=mp.get(t[1]);\\n                al.add(t[0]);\\n                mp.put(t[1],al);\\n            }\\n            else\\n            {\\n                List<Integer> al=new ArrayList<>();\\n                al.add(t[0]);\\n                mp.put(t[1],al);\\n            }\\n                \\n        }\\n        for(Integer t:mp.keySet())\\n        {\\n            List<Integer> al=mp.get(t);\\n            Collections.sort(al);\\n            mp.put(t,al);\\n        }\\n        int ans[]=new int[points.length];\\n        int pp=0;\\n        for(int t[]:points)\\n        {\\n            int cn=0;\\n            for(Integer key:mp.keySet())\\n            {\\n                if(key>=t[1])\\n                {\\n                   List<Integer> al=mp.get(key);\\n                   int i=0,j=al.size()-1;\\n                   int x=-1;\\n                   while(i<=j)\\n                   {\\n                       int mid=(i+j)/2;\\n                       if(al.get(mid)>=t[0])\\n                       {\\n                           x=mid;\\n                           j=mid-1;\\n                       }\\n                       else\\n                           i=mid+1;\\n                   }\\n                   if(x!=-1)\\n                     cn+=al.size()-x; \\n                }\\n            }\\n            ans[pp++]=cn;\\n        }\\n        return ans;\\n \\n",
                "solutionTags": [
                    "Java",
                    "Geometry",
                    "Binary Tree"
                ],
                "code": "\\n\\n        Map<Integer,List<Integer>> mp=new HashMap<>();\\n        for(int t[]:rectangles)\\n        {\\n            if(mp.containsKey(t[1]))\\n            {\\n                List<Integer> al=mp.get(t[1]);\\n                al.add(t[0]);\\n                mp.put(t[1],al);\\n            }\\n            else\\n            {\\n                List<Integer> al=new ArrayList<>();\\n                al.add(t[0]);\\n                mp.put(t[1],al);\\n            }\\n                \\n        }\\n        for(Integer t:mp.keySet())\\n        {\\n            List<Integer> al=mp.get(t);\\n            Collections.sort(al);\\n            mp.put(t,al);\\n        }\\n        int ans[]=new int[points.length];\\n        int pp=0;\\n        for(int t[]:points)\\n        {\\n            int cn=0;\\n            for(Integer key:mp.keySet())\\n            {\\n                if(key>=t[1])\\n                {\\n                   List<Integer> al=mp.get(key);\\n                   int i=0,j=al.size()-1;\\n                   int x=-1;\\n                   while(i<=j)\\n                   {\\n                       int mid=(i+j)/2;\\n                       if(al.get(mid)>=t[0])\\n                       {\\n                           x=mid;\\n                           j=mid-1;\\n                       }\\n                       else\\n                           i=mid+1;\\n                   }\\n                   if(x!=-1)\\n                     cn+=al.size()-x; \\n                }\\n            }\\n            ans[pp++]=cn;\\n        }\\n        return ans;\\n \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1978897,
                "title": "cpp-binary-search-with-comments",
                "content": "During contest I got TLE, but again I made the same mistake twice: I didn\\'t check the problem constrains. The most important trick here is that because the length/heights is between [0,100] we can create a vector and put all the lengths into the same height.\\n```\\nvector<int> countRectangles(vector<vector<int>>& rectangles, \\n\\t\\t\\t\\t\\t\\t\\tvector<vector<int>>& points) {\\n\\tvector<vector<int>> hmap(101);\\n\\tfor (auto& r : rectangles) {\\n\\t\\thmap[r[1]].push_back(r[0]); // Put all the length into the same height.\\n\\t}\\n\\tfor (auto& l : hmap) {\\n\\t\\tsort(l.begin(), l.end()); \\n\\t}\\n\\tvector<int> res;\\n\\tfor (auto& p : points) {\\n\\t\\tint x = p[0], y = p[1];\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = y; i < 101; i++) { // We know from where to start - we will not find any rectagle if their height is less than y.\\n\\t\\t\\tauto it = lower_bound(hmap[i].begin(), hmap[i].end(), x); // Find the lenght that is not less than x.\\n\\t\\t\\tcount += distance(it, hmap[i].end());\\n\\t\\t}\\n\\t\\tres.push_back(count);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> countRectangles(vector<vector<int>>& rectangles, \\n\\t\\t\\t\\t\\t\\t\\tvector<vector<int>>& points) {\\n\\tvector<vector<int>> hmap(101);\\n\\tfor (auto& r : rectangles) {\\n\\t\\thmap[r[1]].push_back(r[0]); // Put all the length into the same height.\\n\\t}\\n\\tfor (auto& l : hmap) {\\n\\t\\tsort(l.begin(), l.end()); \\n\\t}\\n\\tvector<int> res;\\n\\tfor (auto& p : points) {\\n\\t\\tint x = p[0], y = p[1];\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = y; i < 101; i++) { // We know from where to start - we will not find any rectagle if their height is less than y.\\n\\t\\t\\tauto it = lower_bound(hmap[i].begin(), hmap[i].end(), x); // Find the lenght that is not less than x.\\n\\t\\t\\tcount += distance(it, hmap[i].end());\\n\\t\\t}\\n\\t\\tres.push_back(count);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1978783,
                "title": "binary-search-on-the-width-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        \\n        \\n        vector<int > ans;\\n        int n = rectangles.size();\\n        sort(rectangles.begin(),rectangles.end());\\n        vector<vector<int>> y(101);\\n        \\n        sort(rectangles.begin() , rectangles.end() , [&](vector<int> &x ,vector<int> &y){\\n            return x[1] < y[1];\\n        });\\n        sort(rectangles.begin() , rectangles.end() , [&](vector<int> &x ,vector<int> &y){\\n            return x[0] < y[0];\\n        });\\n        \\n        for(auto e:rectangles){\\n            y[e[1]].push_back(e[0]);\\n        }\\n        \\n        \\n        \\n        for(auto e: points){\\n            int cnt = 0;\\n            for(int i=e[1]; i<= 100; i++){\\n                if(y[i].size()){\\n                    cnt+= binary_s(y[i] , e[0]); // since x has been put in sorted order in vector y binary search on x range for each ys range will give us the count of rectangles lies in that domain\\n                }\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n        \\n    }\\n    int binary_s(vector<int>& rec , int x ){\\n        int n = rec.size();\\n        int lo = 0 , hi= n-1;\\n        int res = n; \\n        while(lo <= hi){\\n            int mid = (lo + hi)/2;\\n            if(rec[mid] >= x ){\\n                res = mid;\\n                hi =mid -1;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n        \\n        \\n        \\n        return n-res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        \\n        \\n        vector<int > ans;\\n        int n = rectangles.size();\\n        sort(rectangles.begin(),rectangles.end());\\n        vector<vector<int>> y(101);\\n        \\n        sort(rectangles.begin() , rectangles.end() , [&](vector<int> &x ,vector<int> &y){\\n            return x[1] < y[1];\\n        });\\n        sort(rectangles.begin() , rectangles.end() , [&](vector<int> &x ,vector<int> &y){\\n            return x[0] < y[0];\\n        });\\n        \\n        for(auto e:rectangles){\\n            y[e[1]].push_back(e[0]);\\n        }\\n        \\n        \\n        \\n        for(auto e: points){\\n            int cnt = 0;\\n            for(int i=e[1]; i<= 100; i++){\\n                if(y[i].size()){\\n                    cnt+= binary_s(y[i] , e[0]); // since x has been put in sorted order in vector y binary search on x range for each ys range will give us the count of rectangles lies in that domain\\n                }\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n        \\n    }\\n    int binary_s(vector<int>& rec , int x ){\\n        int n = rec.size();\\n        int lo = 0 , hi= n-1;\\n        int res = n; \\n        while(lo <= hi){\\n            int mid = (lo + hi)/2;\\n            if(rec[mid] >= x ){\\n                res = mid;\\n                hi =mid -1;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n        \\n        \\n        \\n        return n-res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978529,
                "title": "c-easy-create-bucket-on-y-and-seach-for-x",
                "content": "`Idea:`\\nWe can create buckets for Y coordinates as there are 100. For each bucket, we can put the X coordinate corresponding to the Y coordinate, and for each point, we can see what all Y points are feasible, and for each such point, we can apply a binary search for possible X coordinates.\\n\\n`Code and Complexity: `\\n```\\n/* \\n    Time: O(P*Y*log(N)), where P=P.size(), Y=distinct y coordinates and N=rectangles.size()\\n    Space: O(N)\\n    Tags: Binary Search, Map \\n    Difficulty: M\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>> &rectangles, vector<vector<int>> &points) {\\n        map<int, vector<int>> mp;\\n        for (vector<int> &rec : rectangles) {\\n            mp[rec[1]].push_back(rec[0]);\\n        }\\n        for (auto &p : mp) {\\n            sort(p.second.begin(), p.second.end());\\n        }\\n        vector<int> res(points.size(), 0);\\n        for (int i = 0; i < points.size(); i++) {\\n            for (auto it = mp.rbegin(); it != mp.rend(); it++) {\\n                if (it->first < points[i][1]) break;\\n                res[i] += it->second.size() - (lower_bound(it->second.begin(), it->second.end(), points[i][0]) - it->second.begin());\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n/* \\n    Time: O(P*Y*log(N)), where P=P.size(), Y=distinct y coordinates and N=rectangles.size()\\n    Space: O(N)\\n    Tags: Binary Search, Map \\n    Difficulty: M\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>> &rectangles, vector<vector<int>> &points) {\\n        map<int, vector<int>> mp;\\n        for (vector<int> &rec : rectangles) {\\n            mp[rec[1]].push_back(rec[0]);\\n        }\\n        for (auto &p : mp) {\\n            sort(p.second.begin(), p.second.end());\\n        }\\n        vector<int> res(points.size(), 0);\\n        for (int i = 0; i < points.size(); i++) {\\n            for (auto it = mp.rbegin(); it != mp.rend(); it++) {\\n                if (it->first < points[i][1]) break;\\n                res[i] += it->second.size() - (lower_bound(it->second.begin(), it->second.end(), points[i][0]) - it->second.begin());\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978459,
                "title": "memory-usage-beats-100-c-easy-solution-lower-bound",
                "content": "First, look at the constraints -\\n ```\\n\\t\\t\\t1 <= rectangles.length, points.length <= 5 * 10^4\\n\\t\\t\\t1 <= li, xj <= 10^9\\n\\t\\t\\t1 <= hi, yj <= 100\\n```\\n**Height** can be atmost 100. Therefore we need to use HashMap, take height as key and respective length as value. \\n\\nWe\\'ll sort the length array (taken as HashMap Value) by iterating the entire HashMap.\\n\\nNow, we know if point coordinates are : (x, y), then rectangle\\'s length and height must be greater than or equal to x & y respectively.\\n\\nWe need to find the **lower bound** for x in length array and subtract it from the **end() iterator**.\\nOr we can use **Binary Search** to find first index in length array that is greater than or equal to x. We\\'ll substract it from the length array size and We\\'ll get the number of valid rectangles for y height. \\n\\nWe\\'ll traverse for heights more than y as well to find all the valid rectangles.\\n```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        unordered_map<int, vector<int>> map;\\n        for(auto &it : rectangles){\\n            map[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0; i<map.size(); i++)\\n            sort(begin(map[i]), end(map[i]));\\n        vector<int> res(points.size(), 0);\\n        for(int i=0; i<points.size(); i++){\\n            int h = points[i][1], l = points[i][0];\\n            for(int j=h; j<=100; j++){\\n                res[i] += (map[j].end() - lower_bound(map[j].begin(), map[j].end(), l));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n\\t\\t\\t1 <= rectangles.length, points.length <= 5 * 10^4\\n\\t\\t\\t1 <= li, xj <= 10^9\\n\\t\\t\\t1 <= hi, yj <= 100\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        unordered_map<int, vector<int>> map;\\n        for(auto &it : rectangles){\\n            map[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0; i<map.size(); i++)\\n            sort(begin(map[i]), end(map[i]));\\n        vector<int> res(points.size(), 0);\\n        for(int i=0; i<points.size(); i++){\\n            int h = points[i][1], l = points[i][0];\\n            for(int j=h; j<=100; j++){\\n                res[i] += (map[j].end() - lower_bound(map[j].begin(), map[j].end(), l));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978447,
                "title": "python-tle-solution-solved-in-contest",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.count = 0\\n        \\n    def check_for_presence(self,point,rectangles):\\n        for rectangle in rectangles:\\n            if point[0]  <= rectangle[0] and point[1] <= rectangle[1] :\\n                    self.count +=1\\n        return self.count\\n        \\n        \\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        res = []\\n        for point in points:\\n            res.append(self.check_for_presence(point,rectangles))\\n            self.count = 0 \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.count = 0\\n        \\n    def check_for_presence(self,point,rectangles):\\n        for rectangle in rectangles:\\n            if point[0]  <= rectangle[0] and point[1] <= rectangle[1] :\\n                    self.count +=1\\n        return self.count\\n        \\n        \\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\\n        res = []\\n        for point in points:\\n            res.append(self.check_for_presence(point,rectangles))\\n            self.count = 0 \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978379,
                "title": "o-n-2-and-nlogn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<int> ans(points.size(), 0);\\n        \\n        for(auto rect: rectangles){\\n            int l = rect[0];\\n            int h = rect[1];\\n            for(int i = 0; i < points.size(); i++){\\n                if(points[i][0] <= l && points[i][1] <= h){\\n                    ans[i] += 1;\\n                }\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```\\n\\nO(nlogn) solution\\n```\\nclass Solution {\\npublic:\\n    int binaryLength(vector<int>& len, int x){\\n        int low = 0;\\n        int high = (len.size()-1);\\n        \\n        int idx = len.size();\\n        while(low <= high){\\n            int mid = (low+(high-low)/2);\\n            if(len[mid] >= x){\\n                idx = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        \\n        return idx;\\n    }\\n    \\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n       unordered_map<int, vector<int>> freq;\\n       for(int i=0; i<rectangles.size(); i++){       \\n            freq[rectangles[i][1]].push_back(rectangles[i][0]);\\n        }\\n        \\n       for(int i=0; i<=100; i++){\\n            sort(freq[i].begin(), freq[i].end());\\n        }\\n        \\n        vector<int> ans; \\n        for(int i = 0; i < points.size(); i++){\\n            int l = points[i][0];\\n            int h = points[i][1];\\n            \\n            int cnt = 0;\\n            for(int j = h; j <= 100; j++){\\n                if(freq.find(j) != freq.end()){\\n                    cnt += (freq[j].size() - binaryLength(freq[j], l));\\n                }\\n                \\n            }\\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<int> ans(points.size(), 0);\\n        \\n        for(auto rect: rectangles){\\n            int l = rect[0];\\n            int h = rect[1];\\n            for(int i = 0; i < points.size(); i++){\\n                if(points[i][0] <= l && points[i][1] <= h){\\n                    ans[i] += 1;\\n                }\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int binaryLength(vector<int>& len, int x){\\n        int low = 0;\\n        int high = (len.size()-1);\\n        \\n        int idx = len.size();\\n        while(low <= high){\\n            int mid = (low+(high-low)/2);\\n            if(len[mid] >= x){\\n                idx = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        \\n        return idx;\\n    }\\n    \\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n       unordered_map<int, vector<int>> freq;\\n       for(int i=0; i<rectangles.size(); i++){       \\n            freq[rectangles[i][1]].push_back(rectangles[i][0]);\\n        }\\n        \\n       for(int i=0; i<=100; i++){\\n            sort(freq[i].begin(), freq[i].end());\\n        }\\n        \\n        vector<int> ans; \\n        for(int i = 0; i < points.size(); i++){\\n            int l = points[i][0];\\n            int h = points[i][1];\\n            \\n            int cnt = 0;\\n            for(int j = h; j <= 100; j++){\\n                if(freq.find(j) != freq.end()){\\n                    cnt += (freq[j].size() - binaryLength(freq[j], l));\\n                }\\n                \\n            }\\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978372,
                "title": "c-binary-search-with-comments-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        int n = points.size();                                      //number of points\\n        vector<int> counts (n, 0);                                  //initialize results\\n        int m = rectangles.size();                                  //number of rectangles\\n        sort(rectangles.begin(), rectangles.end(),                  //sort rectangles based on x value, so when we may the matrix later on at each index it will be sorted and we can do binary search\\n             [](auto& a, auto& b) {\\n                return a[0] < b[0];\\n            });\\n    vector<vector<int>> matrix (100);                               //define a matrix that has 100 row - the maximum number of possible heights\\n    for(int i = 0; i < m; i++) {                                        \\n        matrix[rectangles[i][1] - 1].push_back(rectangles[i][0]);   //fill the matrix - each row contains values only for a given height value\\n    }\\n    \\n    for(int i = 0; i < n; i++) {                                    //iterate over points O(n) will be multipled by the order of inside this loop\\n        for(int j = points[i][1] - 1; j < 100; j++) {               //iterate over matrix O(100) - start from the row that has the same value as the height of the points, the lower rows have lower height can can not contain the point\\n            int low = 0;                                            //initialize for binary search - we want to find the index on each row by binary search so that the values after that will be bigger than the x value of the point\\n            int high = matrix[j].size() - 1;                        //max index in the row\\n            int index = -1;                                         //it is possible that no rectanble will have an x bigger or equal to x of the point so need to control that\\n            while(low <= high) {                                    //start the binary search O(n)\\n                int mid = low + (high - low) / 2;\\n                if(matrix[j][mid] < points[i][0]) {\\n                    low = mid + 1;\\n                }\\n                else {\\n                    index = mid;                                    //the smallest value of index that is bigger or equal to x of the point will be updated here\\n                    high = mid - 1;\\n                }\\n            }\\n            if(index >= 0)  counts[i] += matrix[j].size() - index;  //so we have found the index for each row, increment the counts for the point by the number of rectangles in the row that have bigger x - values before index will be smaller rectangles that x because of smaller length\\n        }\\n    }\\n    return counts;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        int n = points.size();                                      //number of points\\n        vector<int> counts (n, 0);                                  //initialize results\\n        int m = rectangles.size();                                  //number of rectangles\\n        sort(rectangles.begin(), rectangles.end(),                  //sort rectangles based on x value, so when we may the matrix later on at each index it will be sorted and we can do binary search\\n             [](auto& a, auto& b) {\\n                return a[0] < b[0];\\n            });\\n    vector<vector<int>> matrix (100);                               //define a matrix that has 100 row - the maximum number of possible heights\\n    for(int i = 0; i < m; i++) {                                        \\n        matrix[rectangles[i][1] - 1].push_back(rectangles[i][0]);   //fill the matrix - each row contains values only for a given height value\\n    }\\n    \\n    for(int i = 0; i < n; i++) {                                    //iterate over points O(n) will be multipled by the order of inside this loop\\n        for(int j = points[i][1] - 1; j < 100; j++) {               //iterate over matrix O(100) - start from the row that has the same value as the height of the points, the lower rows have lower height can can not contain the point\\n            int low = 0;                                            //initialize for binary search - we want to find the index on each row by binary search so that the values after that will be bigger than the x value of the point\\n            int high = matrix[j].size() - 1;                        //max index in the row\\n            int index = -1;                                         //it is possible that no rectanble will have an x bigger or equal to x of the point so need to control that\\n            while(low <= high) {                                    //start the binary search O(n)\\n                int mid = low + (high - low) / 2;\\n                if(matrix[j][mid] < points[i][0]) {\\n                    low = mid + 1;\\n                }\\n                else {\\n                    index = mid;                                    //the smallest value of index that is bigger or equal to x of the point will be updated here\\n                    high = mid - 1;\\n                }\\n            }\\n            if(index >= 0)  counts[i] += matrix[j].size() - index;  //so we have found the index for each row, increment the counts for the point by the number of rectangles in the row that have bigger x - values before index will be smaller rectangles that x because of smaller length\\n        }\\n    }\\n    return counts;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978326,
                "title": "c-solution-binary-search-on-y-axis",
                "content": "```\\n//store all rectangles on the basis of their y-coordinates and then apply binary search\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<int>ans;\\n        vector<vector<int>>v(101);\\n        for(auto &itr:rectangles)\\n        {\\n            v[itr[1]].push_back(itr[0]);\\n        }\\n        for(int i=1;i<=100;i++)\\n        {\\n            if(!v[i].empty())\\n            {sort(v[i].begin(),v[i].end());}\\n        }\\n        for(auto &itr:points)\\n        {\\n            int curr=0,x=itr[0],y=itr[1];\\n            for(int i=100;i>=y;i--)\\n            {\\n                if(!v[i].empty())\\n                {\\n                    auto val=lower_bound(v[i].begin(),v[i].end(),x);\\n                    if(val==v[i].end())\\n                    {\\n                        continue;\\n                    }\\n                    curr+=v[i].end()-val;\\n                    //cout<<curr<<\"\\\\n\";\\n                }\\n            }\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<int>ans;\\n        vector<vector<int>>v(101);\\n        for(auto &itr:rectangles)\\n        {\\n            v[itr[1]].push_back(itr[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1978280,
                "title": "python-binary-search",
                "content": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: list[list[int]], points: list[list[int]]) -> list[int]:\\n\\n        h = [[] for _ in range(101)]\\n        for x, y in rectangles:\\n            h[y].append(x)\\n\\n        for i in range(len(h)):\\n            h[i].sort()\\n\\n        result = []\\n\\n        for x, y in points:\\n            c = 0\\n            for yy in range(y, 101):\\n                if not h[yy] or h[yy][-1] < x:\\n                    continue\\n                if h[yy][0] >= x:\\n                    c += len(h[yy])\\n                    continue\\n                l, r = 0, len(h[yy])-1\\n                while l < r:\\n                    mid = (l + r) // 2\\n                    if h[yy][mid] >= x:\\n                        r = mid\\n                    else:\\n                        l = mid + 1\\n                c += len(h[yy]) - l\\n\\n            result.append(c)\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def countRectangles(self, rectangles: list[list[int]], points: list[list[int]]) -> list[int]:\\n\\n        h = [[] for _ in range(101)]\\n        for x, y in rectangles:\\n            h[y].append(x)\\n\\n        for i in range(len(h)):\\n            h[i].sort()\\n\\n        result = []\\n\\n        for x, y in points:\\n            c = 0\\n            for yy in range(y, 101):\\n                if not h[yy] or h[yy][-1] < x:\\n                    continue\\n                if h[yy][0] >= x:\\n                    c += len(h[yy])\\n                    continue\\n                l, r = 0, len(h[yy])-1\\n                while l < r:\\n                    mid = (l + r) // 2\\n                    if h[yy][mid] >= x:\\n                        r = mid\\n                    else:\\n                        l = mid + 1\\n                c += len(h[yy]) - l\\n\\n            result.append(c)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978193,
                "title": "python3-a-general-solution-that-doesn-t-need-to-group-rectangles-by-height",
                "content": "```\\nfrom sortedcontainers import SortedList\\nfrom bisect import bisect_left\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def countRectangles(\\n        self, rectangles: List[List[int]], points: List[List[int]]\\n    ) -> List[int]:\\n        \"\"\"A general solution without using the constraint 0 <= height <= 100.\\n\\n        We use sortedlist (similar to TreeMap in Java) to keep all seen y-coords sorted.\\n        1. We need to sort the points first by x-coord in decreasing order.\\n        2. For each visited point, we add the y-coord to the sortedlist so\\n            that we can query later using binary search\\n\\n        Time Complexity: O(nlogn)\\n        Space Complexity: O(n)\\n        \"\"\"\\n\\n        sorted_rec = sorted(rectangles)\\n        n = len(rectangles)\\n        slist = SortedList()\\n\\n        cnt_arr = [0] * len(points)\\n        pt_pairs = sorted(\\n            [(ptx, pty, pti) for pti, (ptx, pty) in enumerate(points)], reverse=True\\n        )\\n\\n        last = n - 1\\n        for ptx, pty, pti in pt_pairs:\\n\\n            # find out how many rectangles with xcoord >= ptx (query 1)\\n            idx = bisect_left(sorted_rec, [ptx, float(\"-inf\")])\\n\\n            # find out how many rectangles from query 1 with ycoord >= pty\\n            # slist is used to keep track the ycoord of the rectanges we\\'ve seen so far\\n            # as we are traversing the points by xcoord in decreasing order,\\n            # idx is always monotonically decreasing\\n            while idx <= last:\\n                slist.add(sorted_rec[last][1])\\n                last -= 1\\n\\n            cnt_arr[pti] = len(slist) - slist.bisect_left(pty)\\n\\n        return cnt_arr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nfrom bisect import bisect_left\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def countRectangles(\\n        self, rectangles: List[List[int]], points: List[List[int]]\\n    ) -> List[int]:\\n        \"\"\"A general solution without using the constraint 0 <= height <= 100.\\n\\n        We use sortedlist (similar to TreeMap in Java) to keep all seen y-coords sorted.\\n        1. We need to sort the points first by x-coord in decreasing order.\\n        2. For each visited point, we add the y-coord to the sortedlist so\\n            that we can query later using binary search\\n\\n        Time Complexity: O(nlogn)\\n        Space Complexity: O(n)\\n        \"\"\"\\n\\n        sorted_rec = sorted(rectangles)\\n        n = len(rectangles)\\n        slist = SortedList()\\n\\n        cnt_arr = [0] * len(points)\\n        pt_pairs = sorted(\\n            [(ptx, pty, pti) for pti, (ptx, pty) in enumerate(points)], reverse=True\\n        )\\n\\n        last = n - 1\\n        for ptx, pty, pti in pt_pairs:\\n\\n            # find out how many rectangles with xcoord >= ptx (query 1)\\n            idx = bisect_left(sorted_rec, [ptx, float(\"-inf\")])\\n\\n            # find out how many rectangles from query 1 with ycoord >= pty\\n            # slist is used to keep track the ycoord of the rectanges we\\'ve seen so far\\n            # as we are traversing the points by xcoord in decreasing order,\\n            # idx is always monotonically decreasing\\n            while idx <= last:\\n                slist.add(sorted_rec[last][1])\\n                last -= 1\\n\\n            cnt_arr[pti] = len(slist) - slist.bisect_left(pty)\\n\\n        return cnt_arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978164,
                "title": "go-binary-search",
                "content": "```\\nfunc countRectangles(a [][]int, points [][]int) []int {\\n    res := make([]int, len(points))\\n    \\n    f := make(map[int][]int)\\n    for i := 0; i < len(a); i++ {\\n        f[a[i][1]] = append(f[a[i][1]], a[i][0])\\n    }\\n    \\n    for _, v := range f {\\n        sort.Ints(v)\\n    }\\n    \\n    \\n    for i := 0; i < len(points); i++ {\\n        var x, y int = points[i][0], points[i][1] \\n        cnt := 0\\n        for h := y; h <= 100; h++ {\\n            if _, ok := f[h]; ok {\\n                var l, r, pos int = 0, len(f[h]) - 1, -1\\n                for l <= r {\\n                    mid := l + (r - l) / 2\\n                    if f[h][mid] >= x {\\n                        pos = mid\\n                        r = mid - 1\\n                    } else {\\n                        l = mid + 1\\n                    }\\n                }\\n                if pos != -1 {\\n                    size := len(f[h])\\n                    cnt += (size - pos)\\n                }\\n            }\\n        }\\n        res[i] = cnt\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc countRectangles(a [][]int, points [][]int) []int {\\n    res := make([]int, len(points))\\n    \\n    f := make(map[int][]int)\\n    for i := 0; i < len(a); i++ {\\n        f[a[i][1]] = append(f[a[i][1]], a[i][0])\\n    }\\n    \\n    for _, v := range f {\\n        sort.Ints(v)\\n    }\\n    \\n    \\n    for i := 0; i < len(points); i++ {\\n        var x, y int = points[i][0], points[i][1] \\n        cnt := 0\\n        for h := y; h <= 100; h++ {\\n            if _, ok := f[h]; ok {\\n                var l, r, pos int = 0, len(f[h]) - 1, -1\\n                for l <= r {\\n                    mid := l + (r - l) / 2\\n                    if f[h][mid] >= x {\\n                        pos = mid\\n                        r = mid - 1\\n                    } else {\\n                        l = mid + 1\\n                    }\\n                }\\n                if pos != -1 {\\n                    size := len(f[h])\\n                    cnt += (size - pos)\\n                }\\n            }\\n        }\\n        res[i] = cnt\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1978134,
                "title": "java-solution-binary-search",
                "content": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        List<ArrayList<Integer>> list=new ArrayList<>();\\n        for(int i=0;i<=100;i++) list.add(new ArrayList<>());\\n        for(int rect[]:rectangles){\\n            list.get(rect[1]).add(rect[0]);\\n        }\\n\\t\\t\\n\\t\\t// store all x-cordinates of the rectangle in list with y as index,because x range from 1 to 10^9 and \\n\\t\\t// y range from only 1 to 100\\n\\t\\t\\n        for(int i=0;i<=100;i++){\\n            if(list.get(i).size()>0){\\n                Collections.sort(list.get(i));\\n\\t\\t\\t\\t//sort all list of x coordinates to apply binary search\\n            }\\n        }\\n\\t\\t// binary search helps to find the max element which is greater or equal to given points\\n        int out[]=new int[points.length];\\n        int ind=0;\\n        for(int i=0;i<points.length;i++){\\n            int x= points[i][0];\\n            int y= points[i][1];\\n            int cnt=0;\\n            for(int j=y;j<=100;j++){\\n                if(list.get(j).size()>0){\\n                    int val = binarySearch(0,list.get(j).size()-1,list.get(j),x);\\n                    cnt+=val>=0?list.get(j).size()-val:0; \\n\\t\\t\\t\\t\\t// when x point is not present in array then add 0 and\\n\\t\\t\\t\\t\\t// when elements is there take difference of size and val because the list is 0 indexed.\\n                }\\n            }\\n            out[ind++]=cnt;\\n        }\\n        return out;\\n    }\\n    public static int binarySearch(int low,int high,List<Integer> innerArr,int key){\\n        int m=-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(innerArr.get(mid)>=key){\\n                m=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        List<ArrayList<Integer>> list=new ArrayList<>();\\n        for(int i=0;i<=100;i++) list.add(new ArrayList<>());\\n        for(int rect[]:rectangles){\\n            list.get(rect[1]).add(rect[0]);\\n        }\\n\\t\\t\\n\\t\\t// store all x-cordinates of the rectangle in list with y as index,because x range from 1 to 10^9 and \\n\\t\\t// y range from only 1 to 100\\n\\t\\t\\n        for(int i=0;i<=100;i++){\\n            if(list.get(i).size()>0){\\n                Collections.sort(list.get(i));\\n\\t\\t\\t\\t//sort all list of x coordinates to apply binary search\\n            }\\n        }\\n\\t\\t// binary search helps to find the max element which is greater or equal to given points\\n        int out[]=new int[points.length];\\n        int ind=0;\\n        for(int i=0;i<points.length;i++){\\n            int x= points[i][0];\\n            int y= points[i][1];\\n            int cnt=0;\\n            for(int j=y;j<=100;j++){\\n                if(list.get(j).size()>0){\\n                    int val = binarySearch(0,list.get(j).size()-1,list.get(j),x);\\n                    cnt+=val>=0?list.get(j).size()-val:0; \\n\\t\\t\\t\\t\\t// when x point is not present in array then add 0 and\\n\\t\\t\\t\\t\\t// when elements is there take difference of size and val because the list is 0 indexed.\\n                }\\n            }\\n            out[ind++]=cnt;\\n        }\\n        return out;\\n    }\\n    public static int binarySearch(int low,int high,List<Integer> innerArr,int key){\\n        int m=-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(innerArr.get(mid)>=key){\\n                m=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977975,
                "title": "javascript-binary-search",
                "content": "**Solution: Binary Search**\\n\\nThe constraints state that the height <= 10^9 and the width <= 100.\\nGiven these constraints, we can do binary search on the x coordinates and loop through the y coordinates in a brute force manner.\\n\\nTo sum it up:\\n1. Group the rectangle coordinates by the y coordinate -> [[x coordinate, x coordinate, ...], [x coordinate, ...], ...]\\n2. Sort each of the buckets (because we need to binary search over them)\\n3. For each point, only loop through the buckets where the y coordinate >= the point\\'s y coordinate.\\n  For each bucket, binary search to find the number of coordinates where the x coordinate is >= the point\\'s x coordinate.\\n\\nTime Complexity: `O(n log(n) * 100)` 627ms\\nSpace Complexity: `O(n) `73.5MB\\n```\\nvar countRectangles = function(rectangles, points) {\\n  let buckets = Array(101).fill(0).map(() => []);\\n  for (let [x, y] of rectangles) {\\n    buckets[y].push(x);\\n  }\\n  for (let i = 0; i < 101; i++) buckets[i].sort((a, b) => a - b);\\n\\n  let res = [];\\n  for (let point of points) {\\n    let sum = 0;\\n    for (let j = point[1]; j < 101; j++) {\\n      // lowest index >= point[0]\\n      let index = lower_bound(buckets[j], point[0]);\\n      sum += buckets[j].length - index;\\n    }\\n    res.push(sum);\\n  }\\n  return res;\\n\\n  function lower_bound(arr, targ) {\\n    let low = 0, high = arr.length;\\n    while (low < high) {\\n      let mid = Math.floor((low + high) / 2);\\n      if (arr[mid] >= targ) high = mid;\\n      else low = mid + 1;\\n    }\\n    return low;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countRectangles = function(rectangles, points) {\\n  let buckets = Array(101).fill(0).map(() => []);\\n  for (let [x, y] of rectangles) {\\n    buckets[y].push(x);\\n  }\\n  for (let i = 0; i < 101; i++) buckets[i].sort((a, b) => a - b);\\n\\n  let res = [];\\n  for (let point of points) {\\n    let sum = 0;\\n    for (let j = point[1]; j < 101; j++) {\\n      // lowest index >= point[0]\\n      let index = lower_bound(buckets[j], point[0]);\\n      sum += buckets[j].length - index;\\n    }\\n    res.push(sum);\\n  }\\n  return res;\\n\\n  function lower_bound(arr, targ) {\\n    let low = 0, high = arr.length;\\n    while (low < high) {\\n      let mid = Math.floor((low + high) / 2);\\n      if (arr[mid] >= targ) high = mid;\\n      else low = mid + 1;\\n    }\\n    return low;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977934,
                "title": "two-pointers-c",
                "content": "First let\\'s solve this problem for one dimension.\\n\\nGiven some line segments starting from origin, you have to tell how many times a point will be included.\\n\\nYou can sort those points and line segments in decending order.\\nUse two pointers. For each point you can keep incrementing the pointer till you find line segments which are greater than or equal to given point.\\n\\nPseudo code will look something like this\\n``` \\nlet n = size of points\\nlet m = size of lines\\nlet ans = 0\\nsort points decending\\nsort lines decending\\nset i = 0 , j = 0;\\nfor int i to n - 1\\n{\\n\\twhile(j < m and lines[j] >= points[i]) j++;\\n\\tif(lines[j] >= points[i]) ans += j + 1;\\n}\\nprint(ans)\\n```\\nSince height of rectangles is very less, you can do this for each height.\\nI have sorted both rectangles and points and simply ignored the points which are not on the current height\\n\\nFull code\\n```\\n#define ll long long\\n#define vi vector<int>\\n#define pii pair<int, int>\\n#define f first\\n#define s second\\n#define pb push_back\\n#define sz(x) (int)x.size()\\n#define all(x) x.begin(), x.end()\\n\\nclass Solution {\\n  public:\\n    vi countRectangles(vector<vi> &rectangles, vector<vi> &points) {\\n        int n = sz(rectangles), m = sz(points);\\n        sort(all(rectangles), greater<>());\\n\\n        vector<pair<vector<int>, int>> p;\\n\\n        for (int i = 0; i < m; ++i) {\\n            p.push_back({points[i], i});\\n        }\\n        sort(all(p), greater<>());\\n\\n        vector<int> ans(m);\\n        for (int cur_height = 1; cur_height <= 100; ++cur_height) {\\n            int good = 0;\\n            int i = 0, j = 0;\\n            while (i < m) {\\n                while (j < n and rectangles[j][0] >= p[i].f[0]) {\\n                    if (rectangles[j][1] >= cur_height)\\n                        good++;\\n                    j++;\\n                }\\n                if (p[i].f[1] == cur_height)\\n                    ans[p[i].s] += good;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "``` \\nlet n = size of points\\nlet m = size of lines\\nlet ans = 0\\nsort points decending\\nsort lines decending\\nset i = 0 , j = 0;\\nfor int i to n - 1\\n{\\n\\twhile(j < m and lines[j] >= points[i]) j++;\\n\\tif(lines[j] >= points[i]) ans += j + 1;\\n}\\nprint(ans)\\n```\n```\\n#define ll long long\\n#define vi vector<int>\\n#define pii pair<int, int>\\n#define f first\\n#define s second\\n#define pb push_back\\n#define sz(x) (int)x.size()\\n#define all(x) x.begin(), x.end()\\n\\nclass Solution {\\n  public:\\n    vi countRectangles(vector<vi> &rectangles, vector<vi> &points) {\\n        int n = sz(rectangles), m = sz(points);\\n        sort(all(rectangles), greater<>());\\n\\n        vector<pair<vector<int>, int>> p;\\n\\n        for (int i = 0; i < m; ++i) {\\n            p.push_back({points[i], i});\\n        }\\n        sort(all(p), greater<>());\\n\\n        vector<int> ans(m);\\n        for (int cur_height = 1; cur_height <= 100; ++cur_height) {\\n            int good = 0;\\n            int i = 0, j = 0;\\n            while (i < m) {\\n                while (j < n and rectangles[j][0] >= p[i].f[0]) {\\n                    if (rectangles[j][1] >= cur_height)\\n                        good++;\\n                    j++;\\n                }\\n                if (p[i].f[1] == cur_height)\\n                    ans[p[i].s] += good;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977909,
                "title": "datastructure-explanation-java-code",
                "content": "**Thought 1:** How to know if a point lies inside a rectangle?\\n```\\n\\t\\tpointX <= rectangleX && pointY <= rectangleY\\n```\\nThis is possible because left-bottom X,Y are 0,0 for each rectangle.\\n\\n**Thought 2:**\\nBased on input constraints:\\n1. Y is limited from 1 to 100\\n2. X is unlimited from 1 to huge number\\n3. All the rectangles and points are unique\\n\\nSo somehow we should utilize this fact.\\n\\n**Creating a new data-structure**\\nSince Y is limited from 1 to 100, lets just create an array of size 100.\\nAnd then collect all the X belonging to given Y as a list.\\n\\nSo input **[[1,2],[4,1],[2,3],[2,5],[2,2],[3,1],[2,1],[4,5],[1,5]]** can be re-written in a new data structure (lets call this **yList**) as\\n```\\n\\tY\\tXs for a given Y     Explaination\\n\\t1\\t[4, 3, 1]\\t\\t\\ti.e. [(4,1), (3,1), (2,1)]\\n\\t2\\t[1, 2]\\t\\t\\t\\ti.e. [(1,2), (2,2)]\\n\\t3\\t[2]\\t\\t\\t\\t\\ti.e. [(2,3)]\\n\\t4\\t[]\\n\\t5\\t[2,4,1]\\t\\t\\t\\ti.e. [(2,5), (4,5), (1,5)]\\n...\\n```\\n\\nNow just sort each x-list.\\nNow my data structure looks like\\n```\\n\\tY\\tXs for a given Y\\n\\t1\\t[1, 3, 4]\\n\\t2\\t[1, 2]\\n\\t3\\t[2]\\n\\t4\\t[]\\n\\t5\\t[1, 2, 4]\\n...\\n```\\n**For each point - find answer**\\nLets say the point in question is (2,3).\\nY is 3. \\nSo each Y from 3 to 100 is in my area of interest. i.e.\\n```\\n\\tY\\tXs for a given Y\\n\\t3\\t[2]\\n\\t4\\t[]\\n\\t5\\t[1, 2, 4]\\n...\\n```\\n\\nNow for each X list (lets call it **xList**), do a binary search to find X (i.e. 2). Lets call found position as **xPos**.\\n```\\n\\tarr: [2]\\n\\tsearchVal: 2\\n\\tbinarySearch([2], 2) => xPos = 0\\n```\\nSo number of rectangles with Y = 3, and X >= 2 are: \\n```\\n\\txList.size() - xPos\\n\\ti.e. 1 - 0 = 1\\n```\\n\\nSimilarly, number of rectangles with Y = 5, and X >= 2 are:\\n```\\n\\tarr: [1, 2, 4]\\n\\tsearchVal: 2\\n\\tbinarySearch([1, 2, 4], 2) => xPos = 1\\n\\t\\n\\tNow rectangles satisfying criteria are\\n\\t\\txList.size() - xPos\\n\\t\\t3 - 1\\n\\t\\t= 2\\n```\\n\\nNow we need to just sum up all the answers for each Y.\\n\\nSpace Complexity: O(n) because we stored each rectangle in a new data structure.\\nTime Complexity: O(n log n)\\n* we sorted each x within a y - O(n log n) in worst case\\n* for each Y, we did a binary search\\n\\t* each y = n\\n\\t* binary search = log n\\n\\t* so complexity = n log n\\n\\nHence total is O(n log n)\\n\\nCode:\\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        List<List<Integer>> yList = new ArrayList(101);\\n        for(int i = 0; i <= 101; i++) { // zeroth is ignored for code brevity\\n            yList.add(new ArrayList());\\n        }\\n        \\n        for(int i = 0; i < rectangles.length; i++) {\\n            yList.get(rectangles[i][1]).add(rectangles[i][0]);\\n        }\\n        \\n        for(int i = 0; i < yList.size(); i++) {\\n            Collections.sort(yList.get(i));\\n        }\\n        \\n        int answer[] = new int[points.length];\\n        for(int i = 0; i < points.length; i++) {\\n            answer[i] = countPresence(points[i][0], points[i][1], yList);\\n        }\\n        return answer;        \\n    }\\n\\n    private int countPresence(int x, int y, List<List<Integer>> list) {\\n        int answer = 0;\\n        \\n        // all elements from list[y] to end have satisfying y\\n        for(int i = y; i < list.size(); i++) {\\n            List<Integer> xlist = list.get(i);\\n            if(xlist.size() == 0) \\n                continue;\\n            int xPos = binarySearchFirstOccurenceOrPossiblePosition(xlist, x);\\n\\n            // all elements from xPos to end are part of solution\\n            answer += xlist.size() - xPos;\\n        }\\n        return answer;\\n    }\\n    \\n    private int binarySearchFirstOccurenceOrPossiblePosition(List<Integer> list, int val) {\\n        int start = 0, end = list.size() - 1;\\n        int minPosFound = -1;\\n        while(start <= end) {\\n            int mid = start + ((end - start) / 2);\\n            if(list.get(mid) == val) {\\n                minPosFound = Integer.min(minPosFound, mid);\\n                end = mid - 1;\\n            } else if(list.get(mid) < val) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return  minPosFound == -1 ? start : minPosFound;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tpointX <= rectangleX && pointY <= rectangleY\\n```\n```\\n\\tY\\tXs for a given Y     Explaination\\n\\t1\\t[4, 3, 1]\\t\\t\\ti.e. [(4,1), (3,1), (2,1)]\\n\\t2\\t[1, 2]\\t\\t\\t\\ti.e. [(1,2), (2,2)]\\n\\t3\\t[2]\\t\\t\\t\\t\\ti.e. [(2,3)]\\n\\t4\\t[]\\n\\t5\\t[2,4,1]\\t\\t\\t\\ti.e. [(2,5), (4,5), (1,5)]\\n...\\n```\n```\\n\\tY\\tXs for a given Y\\n\\t1\\t[1, 3, 4]\\n\\t2\\t[1, 2]\\n\\t3\\t[2]\\n\\t4\\t[]\\n\\t5\\t[1, 2, 4]\\n...\\n```\n```\\n\\tY\\tXs for a given Y\\n\\t3\\t[2]\\n\\t4\\t[]\\n\\t5\\t[1, 2, 4]\\n...\\n```\n```\\n\\tarr: [2]\\n\\tsearchVal: 2\\n\\tbinarySearch([2], 2) => xPos = 0\\n```\n```\\n\\txList.size() - xPos\\n\\ti.e. 1 - 0 = 1\\n```\n```\\n\\tarr: [1, 2, 4]\\n\\tsearchVal: 2\\n\\tbinarySearch([1, 2, 4], 2) => xPos = 1\\n\\t\\n\\tNow rectangles satisfying criteria are\\n\\t\\txList.size() - xPos\\n\\t\\t3 - 1\\n\\t\\t= 2\\n```\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        List<List<Integer>> yList = new ArrayList(101);\\n        for(int i = 0; i <= 101; i++) { // zeroth is ignored for code brevity\\n            yList.add(new ArrayList());\\n        }\\n        \\n        for(int i = 0; i < rectangles.length; i++) {\\n            yList.get(rectangles[i][1]).add(rectangles[i][0]);\\n        }\\n        \\n        for(int i = 0; i < yList.size(); i++) {\\n            Collections.sort(yList.get(i));\\n        }\\n        \\n        int answer[] = new int[points.length];\\n        for(int i = 0; i < points.length; i++) {\\n            answer[i] = countPresence(points[i][0], points[i][1], yList);\\n        }\\n        return answer;        \\n    }\\n\\n    private int countPresence(int x, int y, List<List<Integer>> list) {\\n        int answer = 0;\\n        \\n        // all elements from list[y] to end have satisfying y\\n        for(int i = y; i < list.size(); i++) {\\n            List<Integer> xlist = list.get(i);\\n            if(xlist.size() == 0) \\n                continue;\\n            int xPos = binarySearchFirstOccurenceOrPossiblePosition(xlist, x);\\n\\n            // all elements from xPos to end are part of solution\\n            answer += xlist.size() - xPos;\\n        }\\n        return answer;\\n    }\\n    \\n    private int binarySearchFirstOccurenceOrPossiblePosition(List<Integer> list, int val) {\\n        int start = 0, end = list.size() - 1;\\n        int minPosFound = -1;\\n        while(start <= end) {\\n            int mid = start + ((end - start) / 2);\\n            if(list.get(mid) == val) {\\n                minPosFound = Integer.min(minPosFound, mid);\\n                end = mid - 1;\\n            } else if(list.get(mid) < val) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return  minPosFound == -1 ? start : minPosFound;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977783,
                "title": "java-20-lines-treemap-binary-search-solution",
                "content": "[Collections.binarySearch](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#binarySearch-java.util.List-T-)\\n\\n> Returns:\\nthe index of the search key, if it is contained in the list; otherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the list: the index of the first element greater than the key, or list.size() if all elements in the list are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\\n\\n```java\\npublic int[] countRectangles(int[][] rectangles, int[][] points) {\\n\\tTreeMap<Integer, List<Integer>> m = new TreeMap<>();\\n\\t// Group rectangles by y\\n\\tfor (int[] r: rectangles)\\n\\t\\tm.computeIfAbsent(r[1], k -> new ArrayList<Integer>()).add(r[0]);\\n\\t// Then sort the group by x\\n\\tfor (List<Integer> l : m.values())\\n\\t\\tCollections.sort(l);\\n\\tint[] res = new int[points.length];\\n\\tint pos = 0;\\n\\tfor (int[] p: points) {\\n\\t\\tint sum = 0;\\n\\t\\tfor (List<Integer> lengths : m.tailMap(p[1]).values()) {\\n\\t\\t\\t// Find number of rectangles, that have the point as outside\\n\\t\\t\\tint ins = Collections.binarySearch(lengths, p[0]);\\n\\t\\t\\tsum += ins >= 0 ? lengths.size() - ins : lengths.size() - (-ins - 1);\\n\\t\\t}\\n\\t\\tres[pos++] += sum;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int[] countRectangles(int[][] rectangles, int[][] points) {\\n\\tTreeMap<Integer, List<Integer>> m = new TreeMap<>();\\n\\t// Group rectangles by y\\n\\tfor (int[] r: rectangles)\\n\\t\\tm.computeIfAbsent(r[1], k -> new ArrayList<Integer>()).add(r[0]);\\n\\t// Then sort the group by x\\n\\tfor (List<Integer> l : m.values())\\n\\t\\tCollections.sort(l);\\n\\tint[] res = new int[points.length];\\n\\tint pos = 0;\\n\\tfor (int[] p: points) {\\n\\t\\tint sum = 0;\\n\\t\\tfor (List<Integer> lengths : m.tailMap(p[1]).values()) {\\n\\t\\t\\t// Find number of rectangles, that have the point as outside\\n\\t\\t\\tint ins = Collections.binarySearch(lengths, p[0]);\\n\\t\\t\\tsum += ins >= 0 ? lengths.size() - ins : lengths.size() - (-ins - 1);\\n\\t\\t}\\n\\t\\tres[pos++] += sum;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1971752,
                "content": [
                    {
                        "username": "sahil_gpt11",
                        "content": "MY TLE SOLn\\n\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<int> ans(points.size());\\n       \\n          for(int i=0;i<points.size();i++)\\n        {   int c=0;\\n            int x=points[i][0];\\n             int y=points[i][1];\\n        for(int j=0;j<rectangles.size();j++)\\n        {\\n           if(rectangles[j][0]>=x && rectangles[j][1]>=y)\\n           {\\n               ans[i]++;\\n           }\\n        }\\n       }\\n       return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "sometime answer max point and sometime min point  why???????????"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me"
                    }
                ]
            },
            {
                "id": 1750586,
                "content": [
                    {
                        "username": "sahil_gpt11",
                        "content": "MY TLE SOLn\\n\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<int> ans(points.size());\\n       \\n          for(int i=0;i<points.size();i++)\\n        {   int c=0;\\n            int x=points[i][0];\\n             int y=points[i][1];\\n        for(int j=0;j<rectangles.size();j++)\\n        {\\n           if(rectangles[j][0]>=x && rectangles[j][1]>=y)\\n           {\\n               ans[i]++;\\n           }\\n        }\\n       }\\n       return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "sometime answer max point and sometime min point  why???????????"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me"
                    }
                ]
            },
            {
                "id": 1750584,
                "content": [
                    {
                        "username": "sahil_gpt11",
                        "content": "MY TLE SOLn\\n\\nclass Solution {\\npublic:\\n    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {\\n        vector<int> ans(points.size());\\n       \\n          for(int i=0;i<points.size();i++)\\n        {   int c=0;\\n            int x=points[i][0];\\n             int y=points[i][1];\\n        for(int j=0;j<rectangles.size();j++)\\n        {\\n           if(rectangles[j][0]>=x && rectangles[j][1]>=y)\\n           {\\n               ans[i]++;\\n           }\\n        }\\n       }\\n       return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "sometime answer max point and sometime min point  why???????????"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me"
                    }
                ]
            }
        ]
    }
]