[
    {
        "title": "Text Justification",
        "question_content": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\nNote:\n\n\tA word is defined as a character sequence consisting of non-space characters only.\n\tEach word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n\tThe input array words contains at least one word.\n\n&nbsp;\nExample 1:\n\nInput: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n&nbsp; &nbsp;\"This &nbsp; &nbsp;is &nbsp; &nbsp;an\",\n&nbsp; &nbsp;\"example &nbsp;of text\",\n&nbsp; &nbsp;\"justification. &nbsp;\"\n]\nExample 2:\n\nInput: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n&nbsp; \"What &nbsp; must &nbsp; be\",\n&nbsp; \"acknowledgment &nbsp;\",\n&nbsp; \"shall be &nbsp; &nbsp; &nbsp; &nbsp;\"\n]\nExplanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.\nExample 3:\n\nInput: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n&nbsp; \"Science &nbsp;is &nbsp;what we\",\n  \"understand &nbsp; &nbsp; &nbsp;well\",\n&nbsp; \"enough to explain to\",\n&nbsp; \"a &nbsp;computer. &nbsp;Art is\",\n&nbsp; \"everything &nbsp;else &nbsp;we\",\n&nbsp; \"do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\"\n]\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 300\n\t1 <= words[i].length <= 20\n\twords[i] consists of only English letters and symbols.\n\t1 <= maxWidth <= 100\n\twords[i].length <= maxWidth",
        "solutions": [
            {
                "id": 24902,
                "title": "java-easy-to-understand-broken-into-several-functions",
                "content": "We start with left being the first word.\\n\\nfindRight: Then we greedily try to go as far right as possible until we fill our current line.\\n\\nThen we justify one line at a time.\\n\\njustify: In all cases we pad the right side with spaces until we reach max width for the line;\\n1. If it's one word then it is easy, the result is just that word.\\n2. If it's the last line then the result is all words separated by a single space.\\n3. Otherwise we calculate the size of each space evenly and if there is a remainder we distribute an extra space until it is gone.\\n\\n```\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        int left = 0; List<String> result = new ArrayList<>();\\n        \\n        while (left < words.length) {\\n            int right = findRight(left, words, maxWidth);\\n            result.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        \\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n            \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return padResult(words[left], maxWidth);\\n        \\n        boolean isLastLine = right == words.length - 1;\\n        int numSpaces = right - left;\\n        int totalSpace = maxWidth - wordsLength(left, right, words);\\n        \\n        String space = isLastLine ? \" \" : blank(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (int i = left; i <= right; i++)\\n            result.append(words[i])\\n                .append(space)\\n                .append(remainder-- > 0 ? \" \" : \"\");\\n        \\n        return padResult(result.toString().trim(), maxWidth);\\n    }\\n    \\n    private int wordsLength(int left, int right, String[] words) {\\n        int wordsLength = 0;\\n        for (int i = left; i <= right; i++) wordsLength += words[i].length();\\n        return wordsLength;\\n    }\\n    \\n    private String padResult(String result, int maxWidth) {\\n        return result + blank(maxWidth - result.length());\\n    }\\n    \\n    private String blank(int length) {\\n        return new String(new char[length]).replace('\\\\0', ' ');\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        int left = 0; List<String> result = new ArrayList<>();\\n        \\n        while (left < words.length) {\\n            int right = findRight(left, words, maxWidth);\\n            result.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        \\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n            \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return padResult(words[left], maxWidth);\\n        \\n        boolean isLastLine = right == words.length - 1;\\n        int numSpaces = right - left;\\n        int totalSpace = maxWidth - wordsLength(left, right, words);\\n        \\n        String space = isLastLine ? \" \" : blank(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (int i = left; i <= right; i++)\\n            result.append(words[i])\\n                .append(space)\\n                .append(remainder-- > 0 ? \" \" : \"\");\\n        \\n        return padResult(result.toString().trim(), maxWidth);\\n    }\\n    \\n    private int wordsLength(int left, int right, String[] words) {\\n        int wordsLength = 0;\\n        for (int i = left; i <= right; i++) wordsLength += words[i].length();\\n        return wordsLength;\\n    }\\n    \\n    private String padResult(String result, int maxWidth) {\\n        return result + blank(maxWidth - result.length());\\n    }\\n    \\n    private String blank(int length) {\\n        return new String(new char[length]).replace('\\\\0', ' ');\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24891,
                "title": "concise-python-solution-10-lines",
                "content": "--------------------------------------------\\n\\n    def fullJustify(self, words, maxWidth):\\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n                res.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        return res + [\\' \\'.join(cur).ljust(maxWidth)]\\n\\nHow does it work? Well in the question statement, the sentence \"Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right\" was just a really long and awkward way to say *round robin*. The following line implements the round robin logic: \\n\\n    for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n\\nWhat does this line do? Once you determine that there are only k words that can fit on a given line, you know what the total length of those words is num_of_letters. Then the rest are spaces, and there are (maxWidth - num_of_letters) of spaces. The \"or 1\" part is for dealing with the edge case len(cur) == 1.\\n\\n###### Note: I found that this problem & solution is directly being used in the \"Elements of Programming Interviews in Python\" book. Cool I guess, but the book should include an acknowledgement or link to this source.\\n--------------------------------------------\\n\\nThe following is my older solution for reference, longer and less clear. The idea is the same, but I did not figure out the nice way to distribute the space at the time.\\n\\n    def fullJustify(self, words, maxWidth):\\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                if len(cur) == 1:\\n                    res.append( cur[0] + \\' \\'*(maxWidth - num_of_letters) )\\n                else:\\n                    num_spaces = maxWidth - num_of_letters\\n                    space_between_words, num_extra_spaces = divmod( num_spaces, len(cur)-1)\\n                    for i in range(num_extra_spaces):\\n                        cur[i] += \\' \\'\\n                    res.append( (\\' \\'*space_between_words).join(cur) )\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        res.append( \\' \\'.join(cur) + \\' \\'*(maxWidth - num_of_letters - len(cur) + 1) )\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "--------------------------------------------\\n\\n    def fullJustify(self, words, maxWidth):\\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n                res.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        return res + [\\' \\'.join(cur).ljust(maxWidth)]\\n\\nHow does it work? Well in the question statement, the sentence \"Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right\" was just a really long and awkward way to say *round robin*. The following line implements the round robin logic: \\n\\n    for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n\\nWhat does this line do? Once you determine that there are only k words that can fit on a given line, you know what the total length of those words is num_of_letters. Then the rest are spaces, and there are (maxWidth - num_of_letters) of spaces. The \"or 1\" part is for dealing with the edge case len(cur) == 1.\\n\\n###### Note: I found that this problem & solution is directly being used in the \"Elements of Programming Interviews in Python\" book. Cool I guess, but the book should include an acknowledgement or link to this source.\\n--------------------------------------------\\n\\nThe following is my older solution for reference, longer and less clear. The idea is the same, but I did not figure out the nice way to distribute the space at the time.\\n\\n    def fullJustify(self, words, maxWidth):\\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                if len(cur) == 1:\\n                    res.append( cur[0] + \\' \\'*(maxWidth - num_of_letters) )\\n                else:\\n                    num_spaces = maxWidth - num_of_letters\\n                    space_between_words, num_extra_spaces = divmod( num_spaces, len(cur)-1)\\n                    for i in range(num_extra_spaces):\\n                        cur[i] += \\' \\'\\n                    res.append( (\\' \\'*space_between_words).join(cur) )\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        res.append( \\' \\'.join(cur) + \\' \\'*(maxWidth - num_of_letters - len(cur) + 1) )\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2992661,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        const int n = words.size();\\n        int begin = 0, len = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (len + words[i].size() + (i - begin) > maxWidth) {\\n                res.emplace_back(connect(words, maxWidth, begin, i, len, false));\\n                begin = i;\\n                len = 0;\\n            }\\n            len += words[i].size();\\n        }\\n        res.emplace_back(connect(words, maxWidth, begin, n, len, true));\\n        return res;\\n    }\\nprivate:\\n    string connect(const vector<string>& words, int maxWidth,\\n                   int begin, int end, int len,\\n                   bool is_last) {\\n        string s;\\n        int n = end - begin;\\n        for (int i = 0; i < n; ++i) {\\n            s += words[begin + i];\\n            addSpaces(i, n - 1, maxWidth - len, is_last, &s);\\n        }\\n        if (s.size() < maxWidth) {\\n            s.append(maxWidth - s.size(), \\' \\');\\n        }\\n        return s;\\n    }\\n    void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {\\n        if (i < spaceCnt) {\\n            int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);\\n            s->append(spaces, \\' \\');\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        \\n        cur_wlist  = []\\n        cur_ch_cnt = 0   # for the space consideration\\n     \\n        for w in words: \\n            if cur_ch_cnt + len(cur_wlist) + len(w) > maxWidth:\\n                for i in range(maxWidth - cur_ch_cnt):  # insert space\\n                    cur_wlist[i%(len(cur_wlist) - 1 or 1)] += \\' \\'\\n               \\n                res.append(\\'\\'.join(cur_wlist)) # insert a this row \\n                cur_wlist, cur_ch_cnt = [], 0 # prepare a new row, resetting\\n                \\n            cur_wlist += [w]\\n            cur_ch_cnt += len(w)\\n            \\n        return res + [\\' \\'.join(cur_wlist).ljust(maxWidth)]\\n```\\n\\n```Java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\n        List<String> result = new ArrayList<>();\\n\\n        int word = 0;\\n\\n        while(word<words.length){\\n\\n            int j = word-1;\\n            int characters = 0;\\n\\n\\n            while(j+1<words.length && characters+words[j+1].length() + j+1-word<=maxWidth)\\n            {\\n                j++;\\n                characters+=words[j].length();\\n            }\\n            result.add(line(words , word , j, characters , maxWidth));\\n            word = j+1;\\n        }\\n        return result;\\n    }\\n      public String line(String words[],int start,int end, int Linelen,int max)\\n    {\\n        StringBuilder a = new StringBuilder();\\n        int p=1,q=0;\\n        if(end!=start)\\n        {\\n            p=(max-Linelen)/(end-start);\\n            q=(max-Linelen)%(end-start);\\n        }\\n        \\n        for(int i=start;i<=end;i++)\\n        {\\n            a.append(words[i]);\\n            if(i!=end)\\n            {\\n                if(end==words.length-1) a.append(\" \");\\n                else {\\n                    for(int j=1;j<=p;j++) a.append(\" \");\\n                    if(q-->=1) a.append(\" \");\\n                }\\n            }\\n        }\\n        while(a.length()<max) a.append(\" \");\\n        return a.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        const int n = words.size();\\n        int begin = 0, len = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (len + words[i].size() + (i - begin) > maxWidth) {\\n                res.emplace_back(connect(words, maxWidth, begin, i, len, false));\\n                begin = i;\\n                len = 0;\\n            }\\n            len += words[i].size();\\n        }\\n        res.emplace_back(connect(words, maxWidth, begin, n, len, true));\\n        return res;\\n    }\\nprivate:\\n    string connect(const vector<string>& words, int maxWidth,\\n                   int begin, int end, int len,\\n                   bool is_last) {\\n        string s;\\n        int n = end - begin;\\n        for (int i = 0; i < n; ++i) {\\n            s += words[begin + i];\\n            addSpaces(i, n - 1, maxWidth - len, is_last, &s);\\n        }\\n        if (s.size() < maxWidth) {\\n            s.append(maxWidth - s.size(), \\' \\');\\n        }\\n        return s;\\n    }\\n    void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {\\n        if (i < spaceCnt) {\\n            int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);\\n            s->append(spaces, \\' \\');\\n        }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        \\n        cur_wlist  = []\\n        cur_ch_cnt = 0   # for the space consideration\\n     \\n        for w in words: \\n            if cur_ch_cnt + len(cur_wlist) + len(w) > maxWidth:\\n                for i in range(maxWidth - cur_ch_cnt):  # insert space\\n                    cur_wlist[i%(len(cur_wlist) - 1 or 1)] += \\' \\'\\n               \\n                res.append(\\'\\'.join(cur_wlist)) # insert a this row \\n                cur_wlist, cur_ch_cnt = [], 0 # prepare a new row, resetting\\n                \\n            cur_wlist += [w]\\n            cur_ch_cnt += len(w)\\n            \\n        return res + [\\' \\'.join(cur_wlist).ljust(maxWidth)]\\n```\n```Java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\n        List<String> result = new ArrayList<>();\\n\\n        int word = 0;\\n\\n        while(word<words.length){\\n\\n            int j = word-1;\\n            int characters = 0;\\n\\n\\n            while(j+1<words.length && characters+words[j+1].length() + j+1-word<=maxWidth)\\n            {\\n                j++;\\n                characters+=words[j].length();\\n            }\\n            result.add(line(words , word , j, characters , maxWidth));\\n            word = j+1;\\n        }\\n        return result;\\n    }\\n      public String line(String words[],int start,int end, int Linelen,int max)\\n    {\\n        StringBuilder a = new StringBuilder();\\n        int p=1,q=0;\\n        if(end!=start)\\n        {\\n            p=(max-Linelen)/(end-start);\\n            q=(max-Linelen)%(end-start);\\n        }\\n        \\n        for(int i=start;i<=end;i++)\\n        {\\n            a.append(words[i]);\\n            if(i!=end)\\n            {\\n                if(end==words.length-1) a.append(\" \");\\n                else {\\n                    for(int j=1;j<=p;j++) a.append(\" \");\\n                    if(q-->=1) a.append(\" \");\\n                }\\n            }\\n        }\\n        while(a.length()<max) a.append(\" \");\\n        return a.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24873,
                "title": "share-my-concise-c-solution-less-than-20-lines",
                "content": "    vector<string> fullJustify(vector<string> &words, int L) {\\n        vector<string> res;\\n        for(int i = 0, k, l; i < words.size(); i += k) {\\n            for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n                l += words[i+k].size();\\n            }\\n            string tmp = words[i];\\n            for(int j = 0; j < k - 1; j++) {\\n                if(i + k >= words.size()) tmp += \" \";\\n                else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), ' ');\\n                tmp += words[i+j+1];\\n            }\\n            tmp += string(L - tmp.size(), ' ');\\n            res.push_back(tmp);\\n        }\\n        return res;\\n    }\\n\\nFor each line, I first figure out which words can fit in. According to the code, these words are words[i] through words[i+k-1]. Then spaces are added between the words. The trick here is to use mod operation to manage the spaces that can't be evenly distrubuted: the first (L-l) % (k-1) gaps acquire an additional space.",
                "solutionTags": [],
                "code": "    vector<string> fullJustify(vector<string> &words, int L) {\\n        vector<string> res;\\n        for(int i = 0, k, l; i < words.size(); i += k) {\\n            for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n                l += words[i+k].size();\\n            }\\n            string tmp = words[i];\\n            for(int j = 0; j < k - 1; j++) {\\n                if(i + k >= words.size()) tmp += \" \";\\n                else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), ' ');\\n                tmp += words[i+j+1];\\n            }\\n            tmp += string(L - tmp.size(), ' ');\\n            res.push_back(tmp);\\n        }\\n        return res;\\n    }\\n\\nFor each line, I first figure out which words can fit in. According to the code, these words are words[i] through words[i+k-1]. Then spaces are added between the words. The trick here is to use mod operation to manage the spaces that can't be evenly distrubuted: the first (L-l) % (k-1) gaps acquire an additional space.",
                "codeTag": "Unknown"
            },
            {
                "id": 24876,
                "title": "simple-java-solution",
                "content": "    public class Solution {\\n        public List<String> fullJustify(String[] words, int L) {\\n            List<String> lines = new ArrayList<String>();\\n            \\n            int index = 0;\\n            while (index < words.length) {\\n                int count = words[index].length();\\n                int last = index + 1;\\n                while (last < words.length) {\\n                    if (words[last].length() + count + 1 > L) break;\\n                    count += words[last].length() + 1;\\n                    last++;\\n                }\\n                \\n                StringBuilder builder = new StringBuilder();\\n                int diff = last - index - 1;\\n                // if last line or number of words in the line is 1, left-justified\\n                if (last == words.length || diff == 0) {\\n                    for (int i = index; i < last; i++) {\\n                        builder.append(words[i] + \" \");\\n                    }\\n                    builder.deleteCharAt(builder.length() - 1);\\n                    for (int i = builder.length(); i < L; i++) {\\n                        builder.append(\" \");\\n                    }\\n                } else {\\n                    // middle justified\\n                    int spaces = (L - count) / diff;\\n                    int r = (L - count) % diff;\\n                    for (int i = index; i < last; i++) {\\n                        builder.append(words[i]);\\n                        if (i < last - 1) {\\n                            for (int j = 0; j <= (spaces + ((i - index) < r ? 1 : 0)); j++) {\\n                                builder.append(\" \");\\n                            }\\n                        }\\n                    }\\n                }\\n                lines.add(builder.toString());\\n                index = last;\\n            }\\n            \\n            \\n            return lines;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> fullJustify(String[] words, int L) {\\n            List<String> lines = new ArrayList<String>();\\n            \\n            int index = 0;\\n            while (index < words.length) {\\n                int count = words[index].length();\\n                int last = index + 1;\\n                while (last < words.length) {\\n                    if (words[last].length() + count + 1 > L) break;\\n                    count += words[last].length() + 1;\\n                    last++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 24965,
                "title": "easy-understanding-solution",
                "content": "    vector<string> fullJustify(vector<string> &words, int L) {\\n        vector<string> ans, vs;\\n        string str;\\n        \\n        int len = 0;\\n        for (int i = 0; i < words.size(); ++i) {\\n            if (len + vs.size() + words[i].size() <= L) {\\n                // vs not full, need to get more words in the line\\n                vs.push_back(words[i]);\\n                len += words[i].size();\\n            }\\n            else {\\n                // vs full, get the whole line\\n                if (vs.size() == 1) {\\n                    // just one word, the left justify\\n                    str = vs[0];\\n                    str.append(L - str.size(), ' ');\\n                    ans.push_back(str);\\n                }\\n                else if (vs.size() > 1) {\\n                    // the first \"mod\" words get \"div+1\" spaces\\n                    // the remaining words get \"div\" spaces\\n                    int div = (L - len) / (vs.size() - 1);\\n                    int mod = (L - len) % (vs.size() - 1);\\n                    str = vs[0];\\n                    for (int j = 1; j < vs.size(); ++j) {\\n                        if (j <= mod) str.append(div+1, ' '); // one more space\\n                        else str.append(div, ' ');\\n                        str += vs[j];\\n                    }\\n                    ans.push_back(str);\\n                }\\n                \\n                vs.clear();\\n                vs.push_back(words[i]);\\n                len = words[i].size();\\n            }\\n        }\\n        \\n        // the last line, left justified and no extra space is inserted between words\\n        str = vs[0];\\n        for (int j = 1; j < vs.size(); ++j) str += ' ' + vs[j];\\n        str.append(L-str.size(), ' ');\\n        ans.push_back(str);\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "    vector<string> fullJustify(vector<string> &words, int L) {\\n        vector<string> ans, vs;\\n        string str;\\n        \\n        int len = 0;\\n        for (int i = 0; i < words.size(); ++i) {\\n            if (len + vs.size() + words[i].size() <= L) {\\n                // vs not full, need to get more words in the line\\n                vs.push_back(words[i]);\\n                len += words[i].size();\\n            }\\n            else {\\n                // vs full, get the whole line\\n                if (vs.size() == 1) {\\n                    // just one word, the left justify\\n                    str = vs[0];\\n                    str.append(L - str.size(), ' ');\\n                    ans.push_back(str);\\n                }\\n                else if (vs.size() > 1) {\\n                    // the first \"mod\" words get \"div+1\" spaces\\n                    // the remaining words get \"div\" spaces\\n                    int div = (L - len) / (vs.size() - 1);\\n                    int mod = (L - len) % (vs.size() - 1);\\n                    str = vs[0];\\n                    for (int j = 1; j < vs.size(); ++j) {\\n                        if (j <= mod) str.append(div+1, ' '); // one more space\\n                        else str.append(div, ' ');\\n                        str += vs[j];\\n                    }\\n                    ans.push_back(str);\\n                }\\n                \\n                vs.clear();\\n                vs.push_back(words[i]);\\n                len = words[i].size();\\n            }\\n        }\\n        \\n        // the last line, left justified and no extra space is inserted between words\\n        str = vs[0];\\n        for (int j = 1; j < vs.size(); ++j) str += ' ' + vs[j];\\n        str.append(L-str.size(), ' ');\\n        ans.push_back(str);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1243483,
                "title": "intuitive-code-with-explanation",
                "content": "**This problem can be divided into main 2 parts :-**\\n*  First part is to find enough number of words in each line but length of each line should be less then maxWidth(which is pretty straight forward).\\n\\n*  Second part is to format each line.(which is difficult)\\n\\n**Code is written in C++ but after reading explanation you can translate it in your favourite language.**\\n\\n**1. first part:-**\\nThe below function is doing 1st part, it\\'s calling spaceJustifer function just before inserting output string into result vector(or else we can just insert strings without justification into result vector then we can justify each line at the end). just to make sure we are on same page spaceJustifier is getting a input like this `\"This is an\"`  i.e single space to seperate each word, and spaceJustifier is returning us string like this `\"This    is    an\"` i.e inserting 1 space between `this` and `is` . \\n```\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result; //result vector which will store each line\\n        string output = words[0]; //add first word to output string\\n        for (int i = 1; i<words.size(); i++){\\n            if(output.length() + words[i].length() + 1 <= maxWidth) //+1 for space \\n\\t\\t\\t\\n\\t\\t\\t\\t\\toutput += \" \"+words[i]; //add space before adding word\\n            \\n            else{ \\n\\t\\t\\t   //this else will be executed when current line can\\'t add current words \\n                output = spaceJustifier(output, maxWidth, 0); //formatting space before adding it to result \\n                result.push_back(output);\\n                //now we added output to result vector now we can start a new line \\n                output = words[i]; //add current word to output(start of new line)\\n            }\\n        }\\n        //the above loop will not add last line to result because last line to will always satify (output.length()+words[i].length()+1<=maxWidth) condition\\n        output = spaceJustifier(output, maxWidth, 1); //justifying spaces in last line\\n        result.push_back(output); //adding last line to result array\\n        return result;\\n    }\\n```\\n**2. The below function is doing main part of justification.**\\n   `spaceJustifier(string str, int maxWidth, int isLast)` function accepting 3 parameters :-\\n   1. first is str which will accept string/line ex - `\"This is an\"`\\n   2. Second is maxWidth.\\n   3. Third is a flag which will tell us, is the current string is last line or not.\\n    why we intereseted in last line? because last line must be left-justified instead of fully-justified.\\n\\t\\nbelow are the condition/operations we are checking.\\n\\n1. The first condition is **`str.length() == maxWidth`** for string whose length is already equal to max width so we **return line as it is.**\\n\\n2. Now if **`str.length() < maxWidth`** we will calculate spaces which are already in the string. Ex- `\"This is an\"` has 2 spaces.\\n\\n3. After finding number of spaces we will check if `spacesInString == 0 || isLast == 1 ` i.e if number of spaces is equal to 0 and if the current string is last line or not. if string has 0 spaces it means there is only one word inside string. for one word string has to be left-justified same as last line. that is why both conditions are put together\\n\\n4. Now if 1st and 3st condition are checked and we haven\\'t returned the string it means we have to fully justify the line. \\n\\tto do this we need to calculate number of spaces which need to be inserted to make string equal to `maxWidth` we can do this by ``spaceToBeInserted = maxWidth - str.length()``\\n\\tnow we need to find how much spaces we should insert at `each slot` (slot is index of space in the string) to make the given string equal to `maxWidth`. ex- `\"This is an\"` and `maxWidth` is 16. spaces we need to insert in the string to make it equal to maxWidth is 6 [16-10(length of string)]\\n\\tthe above ex has 2 slots or spaces already, so we need add 6 more spaces equally. we can find how much extra space `each slot` will get by dividing `spaceToBeInserted` by `spaces in strings` i.e `eachSlot = spacesToBeInserted / spacesInString`\\n\\t\\nThe above condition will work till `spacesToBeInserted` is fully divisible by `spacesInString`. \\n\\n5. Let us take another example where  `spacesToBeInserted` is not fully divisible by `spacesInString` :-\\nSuppose string is  `\"so fine That all the\"`(maxWidth is 25) here `spacesToBeInserted` is 5 and `spacesInString`is 4, now we can\\'t divide spaces     evenly. In this case according to question we should divide the string as evenly as possible. To divide it evenly we will find reminder when `spacesToBeInserted` is divided by `spacesInString` which will tells us `leftOverSpaces` which we need to insert from left to right. below\\nhere first will find `eachSlot` value which is 5/4 = 1 and `leftOverSpaces` will be 5%4 = 1. now we will fill spaces from left to right :-\\n`\"so_ _fine_ _That_ _all_ _the\"` (underscore represent spaces)1 space is added at each slot now all slot have 2 spaces. \\nnow from left to right we will be adding 1 space to each slot till `leftOverSpaces` become zero.\\n`\"so_ _ _fine_ _That_ _all_ _the\"` after inserting space at first slot `leftOverSpaces` become 0 so no more space is added after that.\\n\\nbelow code add both `eachSlot` space and `leftOverSpaces` at same time so it will directly add 3 spaces between `\"so_ _ _fine\"`  instead of 2 spaces.\\n\\n**if there is a mistake please comment.**\\n\\n\\t\\n    string spaceJustifier(string str, int maxWidth, int isLast){\\n        //condition if line length is equal to maxWidth so return line as it is.\\n        if(str.length() == maxWidth)\\n            return str;\\n        \\n        int spacesInString = 0; //count total spaces in the line \\n        for(int i = 0; i<str.length(); i++){\\n            if(str[i] == \\' \\')\\n                spacesInString++;\\n        }\\n        int spacesToBeInserted = maxWidth - str.length(); //spaces to be inserted will be maxWidth - line length\\n        //Left Justifier \\n        //if line has only 1 word(number of spaces in one word is 0 ex \"hi\") || it\\'s last line then left justify the line\\n        if(spacesInString == 0 || isLast == 1){ \\n            str.insert(str.length(), spacesToBeInserted,\\' \\'); //insert required spaces in right of line ex \"do                  \"\\n            return str;\\n        }\\n        int eachSlot = spacesToBeInserted / spacesInString; \\n        int leftOverSpace = spacesToBeInserted % spacesInString; \\n        //EXPLANATION FOR EACH SLOT\\n        //(spacesToBeInserted / spacesInString) will tell us how much space should we insert at eachSlot\\n        //ex - (spacesToBeInserted = 6)/(spaces in string = 2) then each slot will get 3 extra spaces ex - \"hi_hi\" => \"hi_ _ _ _hi_ _ _ _\" will be output\\n        \\n        //EXPLANATION FOR LEFT OVER SPACE\\n        //when the spacesToBeInserted is not divisibe by spacesInString \\n        //EX if we spacesToBeInserted = 5 and spaces in string = 2.\\n        //since 5/2 is not fully Divisble we will find remainder 5%2 to get left overspace.\\n        \\n        \\n        //EX - so_fine_That_all_the. and maxWidth is 25\\n        //      in above case spacesToBeInserted = 5 and spaces in stirng = 4.\\n        //      eachSlot will be 5/4 is 1. ie increase spaces by 1 \\n        \\n        //output will be -> so_ _fine_ _That_ _all_ _the\\n        \\n        //      since 5/4 is not fully divisible. we will find leftOverSpaces = 5%4 = 1;\\n        //      this leftOverSpace will be distributed from left to right ie each slot will get 1,1,1 from left to right\\n        \\n        //output will be -> so_ _ _fine_ _That_ _all_ _the\\n        //                        \\u2191\\n        //                    leftOverSpace added \\n        \\n        //if we had more leftoverspaces then it will be added to next slot.\\n        \\n        for(int i = 0; i<str.length(); i++){\\n            if(str[i] == \\' \\' && (eachSlot > 0 || leftOverSpace >0 )){ //we add spaces till (eachSlot > 0 || leftOverSpace >0)\\n                //required noOfSpaces = eachSlot + (leftOverSpace-- > 0 ? 1:0)\\n                //((leftOverSpace--) > 0 ? 1:0) will return 1 if leftoverspace>0.\\n                //(leftOverSpace--) post decrement\\n                int noOfSpaces = eachSlot + ((leftOverSpace--) > 0 ? 1:0);\\n                str.insert(i, noOfSpaces , \\' \\'); //inserting spaces\\n                i+=noOfSpaces;   //increament count with no of spaces inserted each time \\n            }\\n            \\n        }\\n        return str;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result; //result vector which will store each line\\n        string output = words[0]; //add first word to output string\\n        for (int i = 1; i<words.size(); i++){\\n            if(output.length() + words[i].length() + 1 <= maxWidth) //+1 for space \\n\\t\\t\\t\\n\\t\\t\\t\\t\\toutput += \" \"+words[i]; //add space before adding word\\n            \\n            else{ \\n\\t\\t\\t   //this else will be executed when current line can\\'t add current words \\n                output = spaceJustifier(output, maxWidth, 0); //formatting space before adding it to result \\n                result.push_back(output);\\n                //now we added output to result vector now we can start a new line \\n                output = words[i]; //add current word to output(start of new line)\\n            }\\n        }\\n        //the above loop will not add last line to result because last line to will always satify (output.length()+words[i].length()+1<=maxWidth) condition\\n        output = spaceJustifier(output, maxWidth, 1); //justifying spaces in last line\\n        result.push_back(output); //adding last line to result array\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952119,
                "title": "94-14-2-approaches-greedy",
                "content": "# Interview Problem Understanding\\n\\nIn interviews, understanding the problem at hand is half the battle. Let\\'s break down the \"Text Justification\" challenge:\\n\\n**The Scenario**: Imagine you\\'re building a word processor, and you need to implement the \"Justify\" alignment feature. This means that when a user selects a group of words and chooses the \"Justify\" option, the text is adjusted so that each line spans the entire width of the available space. Words are spaced out, and additional spaces are added between them to achieve this uniform width.\\n\\n**The Challenge**: Given an array of strings (or words) and a defined maximum width for each line:\\n- Your task is to format the text such that each line is exactly the specified maximum width.\\n- Each line should be both left and right justified. This means the words on each line are separated by one or more spaces to ensure the line extends from the very left to the very right.\\n- There\\'s a catch, though. For lines that aren\\'t the last, if the spaces don\\'t divide evenly, the leftmost gaps get more spaces. For the very last line or a line with a single word, it should be left-justified, and the extra spaces are added to the end.\\n\\n**Example**:\\nSuppose you\\'re given the words `[\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]` and a `maxWidth` of 16. This means each line of the output can only be 16 characters wide. Your output should resemble:\\n\\n```\\n[\\n  \"This    is    an\",\\n  \"example  of text\",\\n  \"justification.  \"\\n]\\n```\\n\\n**Input/Output**:\\n- **Input**: You\\'re provided with an array of words and a maximum width for each line.\\n- **Output**: Your goal is to return a list of strings, where each string is a line of text that adheres to the justification rules.\\n\\n---\\n\\n# Live Coding + Explenation Modulo-based\\nhttps://youtu.be/KGfXrj7G0W0?si=VmyOm2RqX6yfMm9w\\n\\n---\\n\\n## Approach 1: Modulo-based Space Distribution\\n\\nTo solve the \"Text Justification\" problem using this approach, we pack words into each line using a greedy strategy. We then distribute spaces among the words on each line, using modulo arithmetic to decide where to place the extra spaces.\\n\\n### Key Data Structures:\\n- **List**: To store the current words for a line and the result.\\n\\n### Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - We start by initializing empty lists for the result and the current line words.\\n   - A counter is also initialized to keep track of the total length of words in the current line.\\n   \\n2. **Processing Each Word**:\\n   - For each word, we check if adding the next word to the current line would make it exceed the maximum width.\\n   - If it does, we proceed to justify the current line. This involves distributing spaces among the words. The modulo arithmetic is handy here, ensuring that extra spaces are evenly spread among the words.\\n   - Once the line is justified, we reset the lists and counter for the next line.\\n   - A special case is the last line, where we simply left-justify the words.\\n\\n3. **Wrap-up**:\\n   - Once all the words are processed and lines are justified, we return the result list.\\n\\n## Example:\\n\\nGiven the `words = [\"This\", \"is\", \"an\", \"example\"]` and `maxWidth = 16`:\\n\\n- The word \"This\" is added to the current line.\\n- The word \"is\" is added to the current line.\\n- The word \"an\" is added to the current line, completing it with the string \"This    is    an\".\\n- The word \"example\" starts a new line.\\n\\n---\\n\\n## Approach 2: Gap-based Space Distribution\\n\\nIn this method, the way we pack words into each line remains similar to the first approach. However, when it comes to distributing spaces, the logic is a tad different. Instead of using modulo arithmetic directly, we compute the number of gaps between words and then decide how many spaces to put in each gap. This makes the logic more intuitive.\\n\\n### Key Data Structures:\\n- **List**: To store the current words for a line and the result.\\n\\n### Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - As before, we initialize empty lists for the result and the current line words.\\n   - A counter keeps track of the total length of words in the current line.\\n   \\n2. **Processing Each Word**:\\n   - For every word, we check if adding it to the current line would cross the maximum width.\\n   - If yes, we justify the current line. This time, we compute the total number of spaces required for the current line. This is based on the maximum width and the length of words on the line.\\n   - We then determine how many gaps exist between the words and compute the number of spaces that can be evenly distributed across these gaps.\\n   - Any extra spaces that can\\'t be evenly distributed are then added to the gaps from left to right.\\n   - The last line is handled specially, where we left-justify the words.\\n\\n3. **Wrap-up**:\\n   - After processing all the words and justifying the lines, we return the result list.\\n\\n---\\n\\n# Complexity:\\n\\n**Time Complexity:** Both approaches process each word once and have a time complexity of $$O(n)$$, where $$n$$ is the number of words.\\n\\n**Space Complexity:** The space complexity for both methods is $$O(n \\\\times m)$$, where $$n$$ is the number of words and $$m$$ is the average length of the words.\\n\\n---\\n\\n# Performance:\\n\\n| Language    | Runtime (ms) | Memory (MB) |\\n|-------------|--------------|-------------|\\n| Rust        | 1 ms         | 2.1 MB      |\\n| Go          | 1 ms         | 2.1 MB      |\\n| Java        | 1 ms         | 40.7 MB     |\\n| C++         | 4 ms         | 7.6 MB      |\\n| Python3 (v2)| 34 ms        | 16.3 MB     |\\n| Python3 (v1)| 34 ms        | 16.1 MB     |\\n| JavaScript  | 55 ms        | 42.2 MB     |\\n| C#          | 139 ms       | 43.7 MB     |\\n\\n![p2a.png](https://assets.leetcode.com/users/images/4e42f0d5-2bfd-476c-b39e-40984d1d300a_1692839284.047317.png)\\n\\n# Code Modulo-based\\n``` Python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res, line, width = [], [], 0\\n\\n        for w in words:\\n            if width + len(w) + len(line) > maxWidth:\\n                for i in range(maxWidth - width): line[i % (len(line) - 1 or 1)] += \\' \\'\\n                res, line, width = res + [\\'\\'.join(line)], [], 0\\n            line += [w]\\n            width += len(w)\\n\\n        return res + [\\' \\'.join(line).ljust(maxWidth)]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> fullJustify(std::vector<std::string>& words, int maxWidth) {\\n        std::vector<std::string> res;\\n        std::vector<std::string> cur;\\n        int num_of_letters = 0;\\n\\n        for (std::string word : words) {\\n            if (word.size() + cur.size() + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.size() - 1 ? cur.size() - 1 : 1)] += \\' \\';\\n                }\\n                res.push_back(\"\");\\n                for (std::string s : cur) res.back() += s;\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.push_back(word);\\n            num_of_letters += word.size();\\n        }\\n\\n        std::string last_line = \"\";\\n        for (std::string s : cur) last_line += s + \\' \\';\\n        last_line = last_line.substr(0, last_line.size()-1);  // remove trailing space\\n        while (last_line.size() < maxWidth) last_line += \\' \\';\\n        res.push_back(last_line);\\n\\n        return res;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        int num_of_letters = 0;\\n\\n        for (String word : words) {\\n            if (word.length() + cur.size() + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur.set(i % (cur.size() - 1 > 0 ? cur.size() - 1 : 1), cur.get(i % (cur.size() - 1 > 0 ? cur.size() - 1 : 1)) + \" \");\\n                }\\n                StringBuilder sb = new StringBuilder();\\n                for (String s : cur) sb.append(s);\\n                res.add(sb.toString());\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.add(word);\\n            num_of_letters += word.length();\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder();\\n        for (int i = 0; i < cur.size(); i++) {\\n            lastLine.append(cur.get(i));\\n            if (i != cur.size() - 1) lastLine.append(\" \");\\n        }\\n        while (lastLine.length() < maxWidth) lastLine.append(\" \");\\n        res.add(lastLine.toString());\\n\\n        return res;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n        let res = [];\\n        let cur = [];\\n        let num_of_letters = 0;\\n\\n        for (let word of words) {\\n            if (word.length + cur.length + num_of_letters > maxWidth) {\\n                for (let i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.length - 1 || 1)] += \\' \\';\\n                }\\n                res.push(cur.join(\\'\\'));\\n                cur = [];\\n                num_of_letters = 0;\\n            }\\n            cur.push(word);\\n            num_of_letters += word.length;\\n        }\\n\\n        let lastLine = cur.join(\\' \\');\\n        while (lastLine.length < maxWidth) lastLine += \\' \\';\\n        res.push(lastLine);\\n\\n        return res;\\n    }\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        var res = new List<string>();\\n        var cur = new List<string>();\\n        int num_of_letters = 0;\\n\\n        foreach (var word in words) {\\n            if (word.Length + cur.Count + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.Count - 1 > 0 ? cur.Count - 1 : 1)] += \" \";\\n                }\\n                res.Add(string.Join(\"\", cur));\\n                cur.Clear();\\n                num_of_letters = 0;\\n            }\\n            cur.Add(word);\\n            num_of_letters += word.Length;\\n        }\\n\\n        string lastLine = string.Join(\" \", cur);\\n        while (lastLine.Length < maxWidth) lastLine += \" \";\\n        res.Add(lastLine);\\n\\n        return res;\\n    }\\n}\\n```\\n``` Go []\\nfunc fullJustify(words []string, maxWidth int) []string {\\n    var res []string\\n    var cur []string\\n    num_of_letters := 0\\n\\n    for _, word := range words {\\n        if len(word) + len(cur) + num_of_letters > maxWidth {\\n            for i := 0; i < maxWidth - num_of_letters; i++ {\\n                cur[i % max(1, len(cur) - 1)] += \" \"\\n            }\\n            res = append(res, strings.Join(cur, \"\"))\\n            cur = cur[:0]\\n            num_of_letters = 0\\n        }\\n        cur = append(cur, word)\\n        num_of_letters += len(word)\\n    }\\n\\n    lastLine := strings.Join(cur, \" \")\\n    for len(lastLine) < maxWidth {\\n        lastLine += \" \"\\n    }\\n    res = append(res, lastLine)\\n\\n    return res\\n}\\n\\n// Helper function to get the maximum of two integers\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn full_justify(words: Vec<String>, max_width: i32) -> Vec<String> {\\n        let mut res = Vec::new();\\n        let mut cur = Vec::new();\\n        let mut num_of_letters: i32 = 0;\\n\\n        for word in &words {\\n            if word.len() as i32 + cur.len() as i32 + num_of_letters > max_width {\\n                for i in 0..(max_width - num_of_letters) {\\n                    let idx = i as usize % (if cur.len() > 1 { cur.len() - 1 } else { cur.len() });\\n                    cur[idx] = format!(\"{} \", cur[idx]);\\n                }\\n                res.push(cur.join(\"\"));\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.push(word.clone());\\n            num_of_letters += word.len() as i32;\\n        }\\n\\n        let last_line = cur.join(\" \");\\n        res.push(format!(\"{:<width$}\", last_line, width=max_width as usize));\\n\\n        res\\n    }\\n}\\n```\\n\\n# Code Gap-based\\n``` Python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res, cur_words, cur_len = [], [], 0\\n\\n        for word in words:\\n            if cur_len + len(word) + len(cur_words) > maxWidth:\\n                total_spaces = maxWidth - cur_len\\n                gaps = len(cur_words) - 1\\n                if gaps == 0:\\n                    res.append(cur_words[0] + \\' \\' * total_spaces)\\n                else:\\n                    space_per_gap = total_spaces // gaps\\n                    extra_spaces = total_spaces % gaps\\n                    line = \\'\\'\\n                    for i, w in enumerate(cur_words):\\n                        line += w\\n                        if i < gaps:\\n                            line += \\' \\' * space_per_gap\\n                            if i < extra_spaces:\\n                                line += \\' \\'\\n                    res.append(line)\\n                cur_words, cur_len = [], 0\\n            cur_words.append(word)\\n            cur_len += len(word)\\n\\n        last_line = \\' \\'.join(cur_words)\\n        remaining_spaces = maxWidth - len(last_line)\\n        res.append(last_line + \\' \\' * remaining_spaces)\\n\\n        return res\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> fullJustify(std::vector<std::string>& words, int maxWidth) {\\n        std::vector<std::string> res, cur_words;\\n        int cur_len = 0;\\n\\n        for (const std::string& word : words) {\\n            if (cur_len + word.length() + cur_words.size() > maxWidth) {\\n                int total_spaces = maxWidth - cur_len;\\n                int gaps = cur_words.size() - 1;\\n                if (gaps == 0) {\\n                    res.push_back(cur_words[0] + std::string(total_spaces, \\' \\'));\\n                } else {\\n                    int space_per_gap = total_spaces / gaps;\\n                    int extra_spaces = total_spaces % gaps;\\n                    std::string line = \"\";\\n                    for (int i = 0; i < cur_words.size(); ++i) {\\n                        line += cur_words[i];\\n                        if (i < gaps) {\\n                            line += std::string(space_per_gap, \\' \\');\\n                            if (i < extra_spaces) {\\n                                line += \\' \\';\\n                            }\\n                        }\\n                    }\\n                    res.push_back(line);\\n                }\\n                cur_words.clear();\\n                cur_len = 0;\\n            }\\n            cur_words.push_back(word);\\n            cur_len += word.length();\\n        }\\n\\n        std::string last_line = \"\";\\n        for (const std::string& word : cur_words) {\\n            if (!last_line.empty()) {\\n                last_line += \\' \\';\\n            }\\n            last_line += word;\\n        }\\n        last_line += std::string(maxWidth - last_line.length(), \\' \\');\\n        res.push_back(last_line);\\n\\n        return res;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        List<String> curWords = new ArrayList<>();\\n        int curLen = 0;\\n\\n        for (String word : words) {\\n            if (curLen + word.length() + curWords.size() > maxWidth) {\\n                int totalSpaces = maxWidth - curLen;\\n                int gaps = curWords.size() - 1;\\n                if (gaps == 0) {\\n                    res.add(curWords.get(0) + \" \".repeat(totalSpaces));\\n                } else {\\n                    int spacePerGap = totalSpaces / gaps;\\n                    int extraSpaces = totalSpaces % gaps;\\n                    StringBuilder line = new StringBuilder();\\n                    for (int i = 0; i < curWords.size(); i++) {\\n                        line.append(curWords.get(i));\\n                        if (i < gaps) {\\n                            line.append(\" \".repeat(spacePerGap));\\n                            if (i < extraSpaces) {\\n                                line.append(\\' \\');\\n                            }\\n                        }\\n                    }\\n                    res.add(line.toString());\\n                }\\n                curWords.clear();\\n                curLen = 0;\\n            }\\n            curWords.add(word);\\n            curLen += word.length();\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder(String.join(\" \", curWords));\\n        while (lastLine.length() < maxWidth) {\\n            lastLine.append(\\' \\');\\n        }\\n        res.add(lastLine.toString());\\n\\n        return res;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> res = new List<string>();\\n        List<string> curWords = new List<string>();\\n        int curLen = 0;\\n\\n        foreach (string word in words) {\\n            if (curLen + word.Length + curWords.Count > maxWidth) {\\n                int totalSpaces = maxWidth - curLen;\\n                int gaps = curWords.Count - 1;\\n                if (gaps == 0) {\\n                    res.Add(curWords[0] + new string(\\' \\', totalSpaces));\\n                } else {\\n                    int spacePerGap = totalSpaces / gaps;\\n                    int extraSpaces = totalSpaces % gaps;\\n                    StringBuilder line = new StringBuilder();\\n                    for (int i = 0; i < curWords.Count; i++) {\\n                        line.Append(curWords[i]);\\n                        if (i < gaps) {\\n                            line.Append(new string(\\' \\', spacePerGap));\\n                            if (i < extraSpaces) {\\n                                line.Append(\\' \\');\\n                            }\\n                        }\\n                    }\\n                    res.Add(line.ToString());\\n                }\\n                curWords.Clear();\\n                curLen = 0;\\n            }\\n            curWords.Add(word);\\n            curLen += word.Length;\\n        }\\n\\n        string lastLine = string.Join(\" \", curWords);\\n        while (lastLine.Length < maxWidth) {\\n            lastLine += \\' \\';\\n        }\\n        res.Add(lastLine);\\n\\n        return res;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n        let res = [];\\n        let curWords = [];\\n        let curLen = 0;\\n\\n        for (let word of words) {\\n            if (curLen + word.length + curWords.length > maxWidth) {\\n                let totalSpaces = maxWidth - curLen;\\n                let gaps = curWords.length - 1;\\n                if (gaps === 0) {\\n                    res.push(curWords[0] + \\' \\'.repeat(totalSpaces));\\n                } else {\\n                    let spacePerGap = Math.floor(totalSpaces / gaps);\\n                    let extraSpaces = totalSpaces % gaps;\\n                    let line = \\'\\';\\n                    for (let i = 0; i < curWords.length; i++) {\\n                        line += curWords[i];\\n                        if (i < gaps) {\\n                            line += \\' \\'.repeat(spacePerGap);\\n                            if (i < extraSpaces) {\\n                                line += \\' \\';\\n                            }\\n                        }\\n                    }\\n                    res.push(line);\\n                }\\n                curWords = [];\\n                curLen = 0;\\n            }\\n            curWords.push(word);\\n            curLen += word.length;\\n        }\\n\\n        let lastLine = curWords.join(\\' \\');\\n        while (lastLine.length < maxWidth) {\\n            lastLine += \\' \\';\\n        }\\n        res.push(lastLine);\\n\\n        return res;\\n    }\\n```\\n\\nThe choice between the two methods will depend on the specific use-case and the preference for clarity vs. conciseness. Both approaches offer an efficient way to tackle the problem of text justification. \\uD83D\\uDCA1\\uD83C\\uDF20\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "String"
                ],
                "code": "```\\n[\\n  \"This    is    an\",\\n  \"example  of text\",\\n  \"justification.  \"\\n]\\n```\n``` Python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res, line, width = [], [], 0\\n\\n        for w in words:\\n            if width + len(w) + len(line) > maxWidth:\\n                for i in range(maxWidth - width): line[i % (len(line) - 1 or 1)] += \\' \\'\\n                res, line, width = res + [\\'\\'.join(line)], [], 0\\n            line += [w]\\n            width += len(w)\\n\\n        return res + [\\' \\'.join(line).ljust(maxWidth)]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> fullJustify(std::vector<std::string>& words, int maxWidth) {\\n        std::vector<std::string> res;\\n        std::vector<std::string> cur;\\n        int num_of_letters = 0;\\n\\n        for (std::string word : words) {\\n            if (word.size() + cur.size() + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.size() - 1 ? cur.size() - 1 : 1)] += \\' \\';\\n                }\\n                res.push_back(\"\");\\n                for (std::string s : cur) res.back() += s;\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.push_back(word);\\n            num_of_letters += word.size();\\n        }\\n\\n        std::string last_line = \"\";\\n        for (std::string s : cur) last_line += s + \\' \\';\\n        last_line = last_line.substr(0, last_line.size()-1);  // remove trailing space\\n        while (last_line.size() < maxWidth) last_line += \\' \\';\\n        res.push_back(last_line);\\n\\n        return res;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        int num_of_letters = 0;\\n\\n        for (String word : words) {\\n            if (word.length() + cur.size() + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur.set(i % (cur.size() - 1 > 0 ? cur.size() - 1 : 1), cur.get(i % (cur.size() - 1 > 0 ? cur.size() - 1 : 1)) + \" \");\\n                }\\n                StringBuilder sb = new StringBuilder();\\n                for (String s : cur) sb.append(s);\\n                res.add(sb.toString());\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.add(word);\\n            num_of_letters += word.length();\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder();\\n        for (int i = 0; i < cur.size(); i++) {\\n            lastLine.append(cur.get(i));\\n            if (i != cur.size() - 1) lastLine.append(\" \");\\n        }\\n        while (lastLine.length() < maxWidth) lastLine.append(\" \");\\n        res.add(lastLine.toString());\\n\\n        return res;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n        let res = [];\\n        let cur = [];\\n        let num_of_letters = 0;\\n\\n        for (let word of words) {\\n            if (word.length + cur.length + num_of_letters > maxWidth) {\\n                for (let i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.length - 1 || 1)] += \\' \\';\\n                }\\n                res.push(cur.join(\\'\\'));\\n                cur = [];\\n                num_of_letters = 0;\\n            }\\n            cur.push(word);\\n            num_of_letters += word.length;\\n        }\\n\\n        let lastLine = cur.join(\\' \\');\\n        while (lastLine.length < maxWidth) lastLine += \\' \\';\\n        res.push(lastLine);\\n\\n        return res;\\n    }\\n```\n``` C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        var res = new List<string>();\\n        var cur = new List<string>();\\n        int num_of_letters = 0;\\n\\n        foreach (var word in words) {\\n            if (word.Length + cur.Count + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.Count - 1 > 0 ? cur.Count - 1 : 1)] += \" \";\\n                }\\n                res.Add(string.Join(\"\", cur));\\n                cur.Clear();\\n                num_of_letters = 0;\\n            }\\n            cur.Add(word);\\n            num_of_letters += word.Length;\\n        }\\n\\n        string lastLine = string.Join(\" \", cur);\\n        while (lastLine.Length < maxWidth) lastLine += \" \";\\n        res.Add(lastLine);\\n\\n        return res;\\n    }\\n}\\n```\n``` Go []\\nfunc fullJustify(words []string, maxWidth int) []string {\\n    var res []string\\n    var cur []string\\n    num_of_letters := 0\\n\\n    for _, word := range words {\\n        if len(word) + len(cur) + num_of_letters > maxWidth {\\n            for i := 0; i < maxWidth - num_of_letters; i++ {\\n                cur[i % max(1, len(cur) - 1)] += \" \"\\n            }\\n            res = append(res, strings.Join(cur, \"\"))\\n            cur = cur[:0]\\n            num_of_letters = 0\\n        }\\n        cur = append(cur, word)\\n        num_of_letters += len(word)\\n    }\\n\\n    lastLine := strings.Join(cur, \" \")\\n    for len(lastLine) < maxWidth {\\n        lastLine += \" \"\\n    }\\n    res = append(res, lastLine)\\n\\n    return res\\n}\\n\\n// Helper function to get the maximum of two integers\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn full_justify(words: Vec<String>, max_width: i32) -> Vec<String> {\\n        let mut res = Vec::new();\\n        let mut cur = Vec::new();\\n        let mut num_of_letters: i32 = 0;\\n\\n        for word in &words {\\n            if word.len() as i32 + cur.len() as i32 + num_of_letters > max_width {\\n                for i in 0..(max_width - num_of_letters) {\\n                    let idx = i as usize % (if cur.len() > 1 { cur.len() - 1 } else { cur.len() });\\n                    cur[idx] = format!(\"{} \", cur[idx]);\\n                }\\n                res.push(cur.join(\"\"));\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.push(word.clone());\\n            num_of_letters += word.len() as i32;\\n        }\\n\\n        let last_line = cur.join(\" \");\\n        res.push(format!(\"{:<width$}\", last_line, width=max_width as usize));\\n\\n        res\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res, cur_words, cur_len = [], [], 0\\n\\n        for word in words:\\n            if cur_len + len(word) + len(cur_words) > maxWidth:\\n                total_spaces = maxWidth - cur_len\\n                gaps = len(cur_words) - 1\\n                if gaps == 0:\\n                    res.append(cur_words[0] + \\' \\' * total_spaces)\\n                else:\\n                    space_per_gap = total_spaces // gaps\\n                    extra_spaces = total_spaces % gaps\\n                    line = \\'\\'\\n                    for i, w in enumerate(cur_words):\\n                        line += w\\n                        if i < gaps:\\n                            line += \\' \\' * space_per_gap\\n                            if i < extra_spaces:\\n                                line += \\' \\'\\n                    res.append(line)\\n                cur_words, cur_len = [], 0\\n            cur_words.append(word)\\n            cur_len += len(word)\\n\\n        last_line = \\' \\'.join(cur_words)\\n        remaining_spaces = maxWidth - len(last_line)\\n        res.append(last_line + \\' \\' * remaining_spaces)\\n\\n        return res\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> fullJustify(std::vector<std::string>& words, int maxWidth) {\\n        std::vector<std::string> res, cur_words;\\n        int cur_len = 0;\\n\\n        for (const std::string& word : words) {\\n            if (cur_len + word.length() + cur_words.size() > maxWidth) {\\n                int total_spaces = maxWidth - cur_len;\\n                int gaps = cur_words.size() - 1;\\n                if (gaps == 0) {\\n                    res.push_back(cur_words[0] + std::string(total_spaces, \\' \\'));\\n                } else {\\n                    int space_per_gap = total_spaces / gaps;\\n                    int extra_spaces = total_spaces % gaps;\\n                    std::string line = \"\";\\n                    for (int i = 0; i < cur_words.size(); ++i) {\\n                        line += cur_words[i];\\n                        if (i < gaps) {\\n                            line += std::string(space_per_gap, \\' \\');\\n                            if (i < extra_spaces) {\\n                                line += \\' \\';\\n                            }\\n                        }\\n                    }\\n                    res.push_back(line);\\n                }\\n                cur_words.clear();\\n                cur_len = 0;\\n            }\\n            cur_words.push_back(word);\\n            cur_len += word.length();\\n        }\\n\\n        std::string last_line = \"\";\\n        for (const std::string& word : cur_words) {\\n            if (!last_line.empty()) {\\n                last_line += \\' \\';\\n            }\\n            last_line += word;\\n        }\\n        last_line += std::string(maxWidth - last_line.length(), \\' \\');\\n        res.push_back(last_line);\\n\\n        return res;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        List<String> curWords = new ArrayList<>();\\n        int curLen = 0;\\n\\n        for (String word : words) {\\n            if (curLen + word.length() + curWords.size() > maxWidth) {\\n                int totalSpaces = maxWidth - curLen;\\n                int gaps = curWords.size() - 1;\\n                if (gaps == 0) {\\n                    res.add(curWords.get(0) + \" \".repeat(totalSpaces));\\n                } else {\\n                    int spacePerGap = totalSpaces / gaps;\\n                    int extraSpaces = totalSpaces % gaps;\\n                    StringBuilder line = new StringBuilder();\\n                    for (int i = 0; i < curWords.size(); i++) {\\n                        line.append(curWords.get(i));\\n                        if (i < gaps) {\\n                            line.append(\" \".repeat(spacePerGap));\\n                            if (i < extraSpaces) {\\n                                line.append(\\' \\');\\n                            }\\n                        }\\n                    }\\n                    res.add(line.toString());\\n                }\\n                curWords.clear();\\n                curLen = 0;\\n            }\\n            curWords.add(word);\\n            curLen += word.length();\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder(String.join(\" \", curWords));\\n        while (lastLine.length() < maxWidth) {\\n            lastLine.append(\\' \\');\\n        }\\n        res.add(lastLine.toString());\\n\\n        return res;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> res = new List<string>();\\n        List<string> curWords = new List<string>();\\n        int curLen = 0;\\n\\n        foreach (string word in words) {\\n            if (curLen + word.Length + curWords.Count > maxWidth) {\\n                int totalSpaces = maxWidth - curLen;\\n                int gaps = curWords.Count - 1;\\n                if (gaps == 0) {\\n                    res.Add(curWords[0] + new string(\\' \\', totalSpaces));\\n                } else {\\n                    int spacePerGap = totalSpaces / gaps;\\n                    int extraSpaces = totalSpaces % gaps;\\n                    StringBuilder line = new StringBuilder();\\n                    for (int i = 0; i < curWords.Count; i++) {\\n                        line.Append(curWords[i]);\\n                        if (i < gaps) {\\n                            line.Append(new string(\\' \\', spacePerGap));\\n                            if (i < extraSpaces) {\\n                                line.Append(\\' \\');\\n                            }\\n                        }\\n                    }\\n                    res.Add(line.ToString());\\n                }\\n                curWords.Clear();\\n                curLen = 0;\\n            }\\n            curWords.Add(word);\\n            curLen += word.Length;\\n        }\\n\\n        string lastLine = string.Join(\" \", curWords);\\n        while (lastLine.Length < maxWidth) {\\n            lastLine += \\' \\';\\n        }\\n        res.Add(lastLine);\\n\\n        return res;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n        let res = [];\\n        let curWords = [];\\n        let curLen = 0;\\n\\n        for (let word of words) {\\n            if (curLen + word.length + curWords.length > maxWidth) {\\n                let totalSpaces = maxWidth - curLen;\\n                let gaps = curWords.length - 1;\\n                if (gaps === 0) {\\n                    res.push(curWords[0] + \\' \\'.repeat(totalSpaces));\\n                } else {\\n                    let spacePerGap = Math.floor(totalSpaces / gaps);\\n                    let extraSpaces = totalSpaces % gaps;\\n                    let line = \\'\\';\\n                    for (let i = 0; i < curWords.length; i++) {\\n                        line += curWords[i];\\n                        if (i < gaps) {\\n                            line += \\' \\'.repeat(spacePerGap);\\n                            if (i < extraSpaces) {\\n                                line += \\' \\';\\n                            }\\n                        }\\n                    }\\n                    res.push(line);\\n                }\\n                curWords = [];\\n                curLen = 0;\\n            }\\n            curWords.push(word);\\n            curLen += word.length;\\n        }\\n\\n        let lastLine = curWords.join(\\' \\');\\n        while (lastLine.length < maxWidth) {\\n            lastLine += \\' \\';\\n        }\\n        res.push(lastLine);\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191149,
                "title": "readable-python-solution-which-beats-99-65",
                "content": "The challenge  is to answer  two questions:\\n1.  How many words we need to form each line;  \\n2.  How many spaces we should insert between two words.\\n\\nThe first question is solved by the helper function: getKwords(), and the second question is solved by the helper function: insertSpace().\\n``` \\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \\'\\'\\'\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \\'\\'\\'\\n        n = len(words)\\n        L = maxWidth\\n        i = 0     # the index of the current word   \\n        ans = [] \\n        \\n        def getKwords(i):\\n            k = 0 # figure out how many words can fit into a line\\n            l = \\' \\'.join(words[i:i+k]) \\n            while len(l) <= L and i+k <= n:\\n                k += 1\\n                l = \\' \\'.join(words[i:i+k])\\n            k -= 1 \\n            return k\\n        \\n        \\n        def insertSpace(i, k):\\n            \\'\\'\\' concatenate words[i:i+k] into one line\\'\\'\\'\\n            l = \\' \\'.join(words[i:i+k])       \\n            if k == 1 or i + k == n:        # if the line contains only one word or it is the last line  \\n                spaces = L - len(l)         # we just need to left assigned it\\n                line = l + \\' \\' * spaces \\n            else:                           \\n                spaces = L - len(l) + (k-1) # total number of spaces we need insert  \\n                space = spaces // (k-1)     # average number of spaces we should insert between two words\\n                left = spaces % (k-1)       # number of \\'left\\' words, i.e. words that have 1 more space than the other words on the right side\\n                if left > 0:\\n                    line = ( \" \" * (space + 1) ).join(words[i:i+left])  # left words\\n                    line += \" \" * (space + 1)                           # spaces between left words & right words\\n                    line += (\" \" * space).join(words[i+left:i+k])       # right woreds\\n                else: \\n                    line = (\" \" * space).join(words[i:i+k])\\n            return line\\n        \\n\\n        while i < n: \\n            k = getKwords(i)  \\n            line = insertSpace(i, k) # create a line which contains words from words[i] to words[i+k-1]\\n            ans.append(line) \\n            i += k \\n        return ans\\t\\t\\n``` ",
                "solutionTags": [],
                "code": "``` \\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \\'\\'\\'\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \\'\\'\\'\\n        n = len(words)\\n        L = maxWidth\\n        i = 0     # the index of the current word   \\n        ans = [] \\n        \\n        def getKwords(i):\\n            k = 0 # figure out how many words can fit into a line\\n            l = \\' \\'.join(words[i:i+k]) \\n            while len(l) <= L and i+k <= n:\\n                k += 1\\n                l = \\' \\'.join(words[i:i+k])\\n            k -= 1 \\n            return k\\n        \\n        \\n        def insertSpace(i, k):\\n            \\'\\'\\' concatenate words[i:i+k] into one line\\'\\'\\'\\n            l = \\' \\'.join(words[i:i+k])       \\n            if k == 1 or i + k == n:        # if the line contains only one word or it is the last line  \\n                spaces = L - len(l)         # we just need to left assigned it\\n                line = l + \\' \\' * spaces \\n            else:                           \\n                spaces = L - len(l) + (k-1) # total number of spaces we need insert  \\n                space = spaces // (k-1)     # average number of spaces we should insert between two words\\n                left = spaces % (k-1)       # number of \\'left\\' words, i.e. words that have 1 more space than the other words on the right side\\n                if left > 0:\\n                    line = ( \" \" * (space + 1) ).join(words[i:i+left])  # left words\\n                    line += \" \" * (space + 1)                           # spaces between left words & right words\\n                    line += (\" \" * space).join(words[i+left:i+k])       # right woreds\\n                else: \\n                    line = (\" \" * space).join(words[i:i+k])\\n            return line\\n        \\n\\n        while i < n: \\n            k = getKwords(i)  \\n            line = insertSpace(i, k) # create a line which contains words from words[i] to words[i+k-1]\\n            ans.append(line) \\n            i += k \\n        return ans\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572814,
                "title": "one-pass-easy-to-understand-with-comments-o-n",
                "content": "We\\'ll build the result array line by line while iterating over words in the input. Whenever the current line gets too big, we\\'ll appropriately format it and proceed with the next line until for loop is over. Last but not least, we\\'ll need to left-justify the last line.\\n\\nTime complexity is **O(n)**:\\nThere is just one for loop, which iterates over words provided as input.\\nSpace complexity: **O(n + l)**\\nWhere **n** is lenght of words, and **l** max length of words in one line. Worst case scenario **l = n**, which will add up to **O(2n)** but in asymptotic analysis we don\\'t care about constants so final complexity is linear: **O(n)**\\n\\n```\\nclass Solution:\\n\\t# Why slots: https://docs.python.org/3/reference/datamodel.html#slots\\n    # TLDR: 1. faster attribute access. 2. space savings in memory.\\n    # For letcode problems this can save ~ 0.1MB of memory <insert is something meme>\\n    __slots__ = ()\\n\\t\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n\\t    # Init return array in which, we\\'ll store justified lines\\n        lines = []\\n\\t\\t# current line width\\n        width = 0\\n\\t\\t# current line words\\n        line = []\\n        \\n        for word in words:\\n\\t\\t\\t# Gather as many words that will fit under maxWidth restrictions.\\n\\t\\t\\t# Line length is a sum of:\\n\\t\\t\\t# 1) Current word length\\n\\t\\t\\t# 2) Sum of words already in the current line\\n\\t\\t\\t# 3) Number of spaces (each word needs to be separated by at least one space)\\n            if (len(word) + width + len(line)) <= maxWidth:\\n                width += len(word)\\n                line.append(word)\\n                continue\\n            \\n\\t\\t\\t# If the current line only contains one word, fill the remaining string with spaces.\\n            if len(line) == 1:\\n\\t\\t\\t\\t# Use the format function to fill the remaining string with spaces easily and readable.\\n\\t\\t\\t\\t# For letcode police, yes you could do something like:\\n\\t\\t\\t\\t#     line = \" \".join(line)\\n\\t\\t\\t\\t#     line += \" \" * (maxWidth - len(line))\\n\\t\\t\\t\\t#     lines.append(line)\\n\\t\\t\\t\\t# to be more \"raw\", but I see no point in that.\\n                lines.append(\\n                    \"{0: <{width}}\".format( \" \".join(line), width=maxWidth)\\n                )\\n            else:\\n\\t\\t\\t    # Else calculate how many common spaces and extra spaces are there for the current line.\\n\\t\\t\\t\\t# Example:\\n                #  line = [\\'a\\', \\'computer.\\', \\'Art\\', \\'is\\']\\n\\t\\t\\t\\t# width left in line equals to: maxWidth - width: 20 - 15 = 5\\n\\t\\t\\t\\t# len(line) - 1 because to the last word, we aren\\'t adding any spaces\\n\\t\\t\\t\\t# Now divmod will give us how many spaces are for all words and how many extra to distribute.\\n\\t\\t\\t\\t# divmod(5, 3) = 1, 2\\n\\t\\t\\t\\t# This means there should be one common space for each word, and for the first two, add one extra space.\\n                space, extra = divmod(\\n                    maxWidth - width,\\n                    len(line) - 1\\n                )\\n                \\n                i = 0\\n\\t\\t\\t\\t# Distribute extra spaces first\\n\\t\\t\\t\\t# There cannot be a case where extra spaces count is greater or equal to number words in the current line.\\n                while extra > 0:\\n                    line[i] += \" \"\\n                    extra -= 1\\n                    i += 1\\n                \\n\\t\\t\\t\\t# Join line array into a string by common spaces, and append to justified lines.\\n                lines.append(\\n                    (\" \" * space).join(line)\\n                )\\n            \\n\\t\\t\\t# Create new line array with the current word in iteration, and reset current line width as well.\\n            line = [word]\\n            width = len(word)\\n        \\n\\t\\t# Last but not least format last line to be left-justified with no extra space inserted between words.\\n\\t\\t# No matter the input, there always be the last line at the end of for loop, which makes things even easier considering the requirement.\\n        lines.append(\\n            \"{0: <{width}}\".format(\" \".join(line), width=maxWidth)\\n        )\\n        \\n        return lines\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\t# Why slots: https://docs.python.org/3/reference/datamodel.html#slots\\n    # TLDR: 1. faster attribute access. 2. space savings in memory.\\n    # For letcode problems this can save ~ 0.1MB of memory <insert is something meme>\\n    __slots__ = ()\\n\\t\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n\\t    # Init return array in which, we\\'ll store justified lines\\n        lines = []\\n\\t\\t# current line width\\n        width = 0\\n\\t\\t# current line words\\n        line = []\\n        \\n        for word in words:\\n\\t\\t\\t# Gather as many words that will fit under maxWidth restrictions.\\n\\t\\t\\t# Line length is a sum of:\\n\\t\\t\\t# 1) Current word length\\n\\t\\t\\t# 2) Sum of words already in the current line\\n\\t\\t\\t# 3) Number of spaces (each word needs to be separated by at least one space)\\n            if (len(word) + width + len(line)) <= maxWidth:\\n                width += len(word)\\n                line.append(word)\\n                continue\\n            \\n\\t\\t\\t# If the current line only contains one word, fill the remaining string with spaces.\\n            if len(line) == 1:\\n\\t\\t\\t\\t# Use the format function to fill the remaining string with spaces easily and readable.\\n\\t\\t\\t\\t# For letcode police, yes you could do something like:\\n\\t\\t\\t\\t#     line = \" \".join(line)\\n\\t\\t\\t\\t#     line += \" \" * (maxWidth - len(line))\\n\\t\\t\\t\\t#     lines.append(line)\\n\\t\\t\\t\\t# to be more \"raw\", but I see no point in that.\\n                lines.append(\\n                    \"{0: <{width}}\".format( \" \".join(line), width=maxWidth)\\n                )\\n            else:\\n\\t\\t\\t    # Else calculate how many common spaces and extra spaces are there for the current line.\\n\\t\\t\\t\\t# Example:\\n                #  line = [\\'a\\', \\'computer.\\', \\'Art\\', \\'is\\']\\n\\t\\t\\t\\t# width left in line equals to: maxWidth - width: 20 - 15 = 5\\n\\t\\t\\t\\t# len(line) - 1 because to the last word, we aren\\'t adding any spaces\\n\\t\\t\\t\\t# Now divmod will give us how many spaces are for all words and how many extra to distribute.\\n\\t\\t\\t\\t# divmod(5, 3) = 1, 2\\n\\t\\t\\t\\t# This means there should be one common space for each word, and for the first two, add one extra space.\\n                space, extra = divmod(\\n                    maxWidth - width,\\n                    len(line) - 1\\n                )\\n                \\n                i = 0\\n\\t\\t\\t\\t# Distribute extra spaces first\\n\\t\\t\\t\\t# There cannot be a case where extra spaces count is greater or equal to number words in the current line.\\n                while extra > 0:\\n                    line[i] += \" \"\\n                    extra -= 1\\n                    i += 1\\n                \\n\\t\\t\\t\\t# Join line array into a string by common spaces, and append to justified lines.\\n                lines.append(\\n                    (\" \" * space).join(line)\\n                )\\n            \\n\\t\\t\\t# Create new line array with the current word in iteration, and reset current line width as well.\\n            line = [word]\\n            width = len(word)\\n        \\n\\t\\t# Last but not least format last line to be left-justified with no extra space inserted between words.\\n\\t\\t# No matter the input, there always be the last line at the end of for loop, which makes things even easier considering the requirement.\\n        lines.append(\\n            \"{0: <{width}}\".format(\" \".join(line), width=maxWidth)\\n        )\\n        \\n        return lines\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24972,
                "title": "i-guess-i-just-wrote-an-essay-but-finally-passed-all-test-cases-ugh",
                "content": "    public List<String> fullJustify(String[] words, int L) {\\n        int length = L;\\n        ArrayList<String> cur_line = new ArrayList<String>();\\n        List<String> res = new ArrayList<String>();\\n        if(words[0]==\"\")\\n        {\\n            String resNull =\"\";\\n            for(int i=0; i<L;i++)\\n                resNull=resNull+\" \";\\n            res.add(resNull);\\n            return res;\\n        }\\n        for(int i=0; i<words.length; i++)\\n        {\\n            //there is room left for current line ex:\"this is a bat  \"\\n            if(length-(words[i].length()+1)>0)  \\n            {\\n                length=length-(words[i].length()+1); //get remainning available spaces in cur line\\n                cur_line.add(words[i]); //add the word to the list \\n            }\\n            //just fit in current line   ex:\"this is a book\" or \"this is a bat \"\\n            else if(length-(words[i].length()+1)==-1 ||length-(words[i].length()+1)==0) \\n            {\\n                cur_line.add(words[i]); //add the last word to the list\\n                //proccess line\\n                boolean lastLine;\\n                if(i==words.length-1) lastLine=true;\\n                else lastLine=false;\\n                res.add(processLine(cur_line, L, lastLine));\\n                //start a new line\\n                length=L; //recover length--next line\\n                cur_line = new ArrayList<String>();\\n            }\\n            //there is no room to fit this one\\n            else if(length-(words[i].length()+1)<-1)\\n            {\\n                //first proccess cur line\\n                res.add(processLine(cur_line, L, false));\\n                //start a new line\\n                length=L; //recover length--next line\\n                cur_line=new ArrayList<String>();\\n                //put this one it it\\n                length=length-(words[i].length()+1);\\n                cur_line.add(words[i]);\\n            }\\n        }\\n        if(cur_line.size()!=0)\\n            res.add(processLine(cur_line, L, true));\\n        return res;\\n    }\\n    public String processLine(ArrayList<String>words, int L, boolean lastLine)\\n    {\\n        String lineString=\"\";\\n        if(words.size()==1)\\n        {\\n            String singleWord = words.get(0);\\n            int len =singleWord.length();\\n            for(int i=0;i<L-len;i++)\\n                singleWord = singleWord+\" \";\\n            return singleWord;\\n        }\\n        int reminder = L;\\n        for(String word: words)\\n            reminder = reminder-word.length();\\n        if(lastLine==true)\\n        {\\n            for(String word:words)\\n            {\\n                if(reminder!=0)\\n                    lineString = lineString+word+\" \";\\n                else\\n                    lineString = lineString+word;\\n                reminder--;\\n            }\\n            for(int i=0; i<reminder;i++)\\n                lineString = lineString+\" \";\\n            return lineString;\\n        }\\n        //there is extra spaces-->reminder\\n        int flag = reminder % (words.size()-1);\\n        int commonSpace = reminder/(words.size()-1);\\n        int extra = flag>0? 1:0;\\n        for(int i=0; i<words.size()-1;i++)\\n        {\\n            String spaces=\"\";\\n            for(int count =0; count<(commonSpace+extra);count++)\\n                 spaces = spaces+\" \";\\n            lineString = lineString +words.get(i)+spaces;\\n            flag--;\\n            extra = flag>0? 1:0;\\n        }\\n        lineString = lineString +words.get(words.size()-1);\\n        return lineString;\\n    }",
                "solutionTags": [],
                "code": "    public List<String> fullJustify(String[] words, int L) {\\n        int length = L;\\n        ArrayList<String> cur_line = new ArrayList<String>();\\n        List<String> res = new ArrayList<String>();\\n        if(words[0]==\"\")\\n        {\\n            String resNull =\"\";\\n            for(int i=0; i<L;i++)\\n                resNull=resNull+\" \";\\n            res.add(resNull);\\n            return res;\\n        }\\n        for(int i=0; i<words.length; i++)\\n        {\\n            //there is room left for current line ex:\"this is a bat  \"\\n            if(length-(words[i].length()+1)>0)  \\n            {\\n                length=length-(words[i].length()+1); //get remainning available spaces in cur line\\n                cur_line.add(words[i]); //add the word to the list \\n            }\\n            //just fit in current line   ex:\"this is a book\" or \"this is a bat \"\\n            else if(length-(words[i].length()+1)==-1 ||length-(words[i].length()+1)==0) \\n            {\\n                cur_line.add(words[i]); //add the last word to the list\\n                //proccess line\\n                boolean lastLine;\\n                if(i==words.length-1) lastLine=true;\\n                else lastLine=false;\\n                res.add(processLine(cur_line, L, lastLine));\\n                //start a new line\\n                length=L; //recover length--next line\\n                cur_line = new ArrayList<String>();\\n            }\\n            //there is no room to fit this one\\n            else if(length-(words[i].length()+1)<-1)\\n            {\\n                //first proccess cur line\\n                res.add(processLine(cur_line, L, false));\\n                //start a new line\\n                length=L; //recover length--next line\\n                cur_line=new ArrayList<String>();\\n                //put this one it it\\n                length=length-(words[i].length()+1);\\n                cur_line.add(words[i]);\\n            }\\n        }\\n        if(cur_line.size()!=0)\\n            res.add(processLine(cur_line, L, true));\\n        return res;\\n    }\\n    public String processLine(ArrayList<String>words, int L, boolean lastLine)\\n    {\\n        String lineString=\"\";\\n        if(words.size()==1)\\n        {\\n            String singleWord = words.get(0);\\n            int len =singleWord.length();\\n            for(int i=0;i<L-len;i++)\\n                singleWord = singleWord+\" \";\\n            return singleWord;\\n        }\\n        int reminder = L;\\n        for(String word: words)\\n            reminder = reminder-word.length();\\n        if(lastLine==true)\\n        {\\n            for(String word:words)\\n            {\\n                if(reminder!=0)\\n                    lineString = lineString+word+\" \";\\n                else\\n                    lineString = lineString+word;\\n                reminder--;\\n            }\\n            for(int i=0; i<reminder;i++)\\n                lineString = lineString+\" \";\\n            return lineString;\\n        }\\n        //there is extra spaces-->reminder\\n        int flag = reminder % (words.size()-1);\\n        int commonSpace = reminder/(words.size()-1);\\n        int extra = flag>0? 1:0;\\n        for(int i=0; i<words.size()-1;i++)\\n        {\\n            String spaces=\"\";\\n            for(int count =0; count<(commonSpace+extra);count++)\\n                 spaces = spaces+\" \";\\n            lineString = lineString +words.get(i)+spaces;\\n            flag--;\\n            extra = flag>0? 1:0;\\n        }\\n        lineString = lineString +words.get(words.size()-1);\\n        return lineString;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 390686,
                "title": "straightforward-python-solution-with-detailed-explanation",
                "content": "```\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def justifySingleLine(line, width, max_width):\\n            num_words = len(line)\\n            total_spaces = max_width - width\\n            if num_words == 1:\\n                # if there is only word in line\\n                # just insert total_spaces for the remainder of line\\n                return line[0] + \\' \\' * total_spaces\\n            else:\\n                locations = num_words - 1\\n                # spaces_inserted[i] is the number of spaces inserted between the words line[i] and line[i+1]\\n                spaces_inserted = locations * [total_spaces // locations]\\n                # distribute the remaining spaces to the left positions\\n                for i in range(total_spaces % locations):\\n                    spaces_inserted[i] += 1\\n                s = \\'\\'\\n                for i in range(locations):\\n                    s += line[i] # add the word line[i]\\n                    s += spaces_inserted[i] * \\' \\'# insert spaces\\n                s += line[-1] # add the last word\\n                return s\\n\\n        answer = []\\n        line, width = [], 0\\n        for word in words:\\n            if width + len(word) + len(line) <= maxWidth:\\n                # keep adding words until we can fill out maxWidth\\n                # width = sum of length of all words\\n                # len(word) = length of current word\\n                # len(line) = least number of spaces needed to be inserted\\n                line.append(word)\\n                width += len(word)\\n            else:\\n                # justify the line and add it to result\\n                answer.append(justifySingleLine(line, width, maxWidth))\\n                # reset new line and new width\\n                line, width = [word], len(word)\\n        remaining_spaces = maxWidth - width - len(line)\\n        answer.append(\\' \\'.join(line) + (remaining_spaces + 1) * \\' \\')\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def justifySingleLine(line, width, max_width):\\n            num_words = len(line)\\n            total_spaces = max_width - width\\n            if num_words == 1:\\n                # if there is only word in line\\n                # just insert total_spaces for the remainder of line\\n                return line[0] + \\' \\' * total_spaces\\n            else:\\n                locations = num_words - 1\\n                # spaces_inserted[i] is the number of spaces inserted between the words line[i] and line[i+1]\\n                spaces_inserted = locations * [total_spaces // locations]\\n                # distribute the remaining spaces to the left positions\\n                for i in range(total_spaces % locations):\\n                    spaces_inserted[i] += 1\\n                s = \\'\\'\\n                for i in range(locations):\\n                    s += line[i] # add the word line[i]\\n                    s += spaces_inserted[i] * \\' \\'# insert spaces\\n                s += line[-1] # add the last word\\n                return s\\n\\n        answer = []\\n        line, width = [], 0\\n        for word in words:\\n            if width + len(word) + len(line) <= maxWidth:\\n                # keep adding words until we can fill out maxWidth\\n                # width = sum of length of all words\\n                # len(word) = length of current word\\n                # len(line) = least number of spaces needed to be inserted\\n                line.append(word)\\n                width += len(word)\\n            else:\\n                # justify the line and add it to result\\n                answer.append(justifySingleLine(line, width, maxWidth))\\n                # reset new line and new width\\n                line, width = [word], len(word)\\n        remaining_spaces = maxWidth - width - len(line)\\n        answer.append(\\' \\'.join(line) + (remaining_spaces + 1) * \\' \\')\\n        return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 149785,
                "title": "clean-javascript-solution",
                "content": "```javascript\\nconst fullJustify = (words, maxWidth) => {\\n  const n = words.length;\\n  const res = [];\\n\\n  for (var i = 0; i < n; i = j) {\\n    // Step 1. Use j to find out where to cut the row (i ... j-1)\\n    let len = -1;\\n    for (var j = i; j < n && len + 1 + words[j].length <= maxWidth; j++) {\\n      len += 1 + words[j].length;\\n    }\\n\\n    // Step 2. Calculate how many spaces to add for each word\\n    let spaces = 1; // avg. spaces reserved for each word\\n    let extra = 0; // extra left spaces\\n\\n    if (j !== i + 1 && j !== n) {\\n      spaces = (maxWidth - len) / (j - 1 - i) + 1;\\n      extra = (maxWidth - len) % (j - 1 - i);\\n    }\\n\\n    // Step 3. Build the row with spaces + extra space + word\\n    let row = words[i];\\n    for (let k = i + 1; k < j; k++, extra--) {\\n      row += \\' \\'.repeat(spaces + (extra > 0 ? 1 : 0)) + words[k];\\n    }\\n    row += \\' \\'.repeat(maxWidth - row.length);\\n\\n    // Step 4. Push the row to final result\\n    res.push(row);\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst fullJustify = (words, maxWidth) => {\\n  const n = words.length;\\n  const res = [];\\n\\n  for (var i = 0; i < n; i = j) {\\n    // Step 1. Use j to find out where to cut the row (i ... j-1)\\n    let len = -1;\\n    for (var j = i; j < n && len + 1 + words[j].length <= maxWidth; j++) {\\n      len += 1 + words[j].length;\\n    }\\n\\n    // Step 2. Calculate how many spaces to add for each word\\n    let spaces = 1; // avg. spaces reserved for each word\\n    let extra = 0; // extra left spaces\\n\\n    if (j !== i + 1 && j !== n) {\\n      spaces = (maxWidth - len) / (j - 1 - i) + 1;\\n      extra = (maxWidth - len) % (j - 1 - i);\\n    }\\n\\n    // Step 3. Build the row with spaces + extra space + word\\n    let row = words[i];\\n    for (let k = i + 1; k < j; k++, extra--) {\\n      row += \\' \\'.repeat(spaces + (extra > 0 ? 1 : 0)) + words[k];\\n    }\\n    row += \\' \\'.repeat(maxWidth - row.length);\\n\\n    // Step 4. Push the row to final result\\n    res.push(row);\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181479,
                "title": "very-easy-java-solution-with-explanation-beats-100",
                "content": "- The idea is to get the window from the words which can fit in a line.\\n    - while getting this window, we also keep following track:\\n        - len : len for the window from start to end including one space as minimum req \\n            Example len = 10 for \"THIS IS AN\"\\n        - count : keeps track of space holders in the string. Initial kept to -1.\\n            Example count = 2 for \"THIS IS AN\"\\n    - Upon getting the window, we now call a function addLine() which creates a line keeping track of 4 things\\n        - same : The equals spaces every word pair will have between them\\n        - extra : The extra ones, which are given one by one from left and decremented every time\\n        - trail : For cases such as last line OR only one word in the line, we need to append trail number of spaces to the line.\\n    \\n    Time Complexity : O(N*maxWidth) : N is number of lines\\n    Space Complexity : O(maxWidth)  : Space for a single line\\n\\t\\t\\n```\\npublic List<String> fullJustify(String[] words, int maxWidth) {\\n         \\n        List<String> result = new ArrayList<>();\\n        int len = -1 , count = -1, start = 0;\\n        \\n        for(int i=0;i<words.length;i++){            \\n            if(len+words[i].length()+1<=maxWidth){\\n                len += words[i].length()+1;\\n                count++;                \\n            }\\n            else{                 \\n                addLine(words,start,i-1,len,count,maxWidth,result,false);\\n                start = i;\\n                i--;\\n                len = -1;\\n                count= -1;\\n            }\\n        }\\n        addLine(words,start,words.length-1,len,count,maxWidth,result,true);\\n        return result;\\n    }\\n    \\n    public void addLine(String[] words,int start, int end, int len, int count, int maxWidth, List<String> result,boolean isLast){\\n        \\n            int spaces = maxWidth-len;\\n            spaces += count;         \\n            int same = isLast || (count==0)? 0 : spaces/count;\\n            int extra = isLast || (count==0)? count : spaces%count;        \\n            int trail = isLast || (count==0) ? maxWidth-len : 0;\\n\\t\\t\\t\\t\\t\\t\\n            StringBuilder line = new StringBuilder();\\n                \\n            while(start<=end){\\n                line.append(words[start]);                    \\n                for(int k=0;k<same && start!=end;k++)\\n                    line.append(\\' \\');\\n                    \\n                if(extra>0){\\n                    line.append(\\' \\');\\n                    extra--;\\n                }\\n                start++;\\n            }        \\n            while(trail>0){\\n                line.append(\\' \\');\\n                trail--;\\n            }                \\n            result.add(line.toString());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> fullJustify(String[] words, int maxWidth) {\\n         \\n        List<String> result = new ArrayList<>();\\n        int len = -1 , count = -1, start = 0;\\n        \\n        for(int i=0;i<words.length;i++){            \\n            if(len+words[i].length()+1<=maxWidth){\\n                len += words[i].length()+1;\\n                count++;                \\n            }\\n            else{                 \\n                addLine(words,start,i-1,len,count,maxWidth,result,false);\\n                start = i;\\n                i--;\\n                len = -1;\\n                count= -1;\\n            }\\n        }\\n        addLine(words,start,words.length-1,len,count,maxWidth,result,true);\\n        return result;\\n    }\\n    \\n    public void addLine(String[] words,int start, int end, int len, int count, int maxWidth, List<String> result,boolean isLast){\\n        \\n            int spaces = maxWidth-len;\\n            spaces += count;         \\n            int same = isLast || (count==0)? 0 : spaces/count;\\n            int extra = isLast || (count==0)? count : spaces%count;        \\n            int trail = isLast || (count==0) ? maxWidth-len : 0;\\n\\t\\t\\t\\t\\t\\t\\n            StringBuilder line = new StringBuilder();\\n                \\n            while(start<=end){\\n                line.append(words[start]);                    \\n                for(int k=0;k<same && start!=end;k++)\\n                    line.append(\\' \\');\\n                    \\n                if(extra>0){\\n                    line.append(\\' \\');\\n                    extra--;\\n                }\\n                start++;\\n            }        \\n            while(trail>0){\\n                line.append(\\' \\');\\n                trail--;\\n            }                \\n            result.add(line.toString());\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25002,
                "title": "share-my-2-ms-30-lines-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> fullJustify(vector<string> &words, int L) {\\n            vector<string> ans;\\n            int begin = 0;\\n            while (begin < words.size()) {\\n                int last = begin;\\n                int linesize = words[begin++].size();\\n                while (begin < words.size() && linesize + 1 + words[begin].size() <= L) {\\n                    linesize += 1 + words[begin].size();\\n                    begin++;\\n                }\\n                \\n                int spaces = 1, extra = 0;\\n                if (begin < words.size() && begin != last + 1) {\\n                    spaces = (L - linesize) / (begin - last - 1) + 1;\\n                    extra = (L - linesize) % (begin - last - 1);\\n                }\\n                \\n                ans.push_back(words[last++]);\\n                while (extra--) {\\n                    ans.back().append(spaces+1, ' ');\\n                    ans.back().append(words[last++]);\\n                }\\n                while (last < begin) {\\n                    ans.back().append(spaces, ' ');\\n                    ans.back().append(words[last++]);\\n                }\\n                ans.back().append(L-ans.back().size(), ' ');\\n            }\\n            \\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> fullJustify(vector<string> &words, int L) {\\n            vector<string> ans;\\n            int begin = 0;\\n            while (begin < words.size()) {\\n                int last = begin;\\n                int linesize = words[begin++].size();\\n                while (begin < words.size() && linesize + 1 + words[begin].size() <= L) {\\n                    linesize += 1 + words[begin].size();\\n                    begin++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3952309,
                "title": "100-fast-easy-code-with-explanation-c-java-python-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust use loops .Try to understand the problem otherwise question is easy.\\nFor detailed explanation you can refer to my youtube channel (Hindi Language)\\n\\n[ Video in Hindi click here](https://youtube.com/@LetsCodeTogether72/videos)\\n\\nor link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation.\\n\\n# Approach\\n\\n1. Initialize an empty vector `res` to store the justified lines of text.\\n\\n2. Iterate through the input `words` vector using an index `i` to keep track of the current word being processed.\\n\\n3. In each iteration, find a range of words that can fit within the `maxWidth` limit. To do this, increment the index `j` while the accumulated length of the words (including spaces) remains within the limit.\\n\\n4. There are three cases to consider for formatting the words into a line:\\n\\n   a. If the range `[i, j)` contains only one word, or it\\'s the last line, left-justify the words. Add spaces between each word and pad the line with spaces on the right to achieve the `maxWidth`.\\n\\n   b. If the line has more than one word but it\\'s not the last line, calculate the total number of words in the line `tw` and the total space available `ts`. Divide `ts` by `(tw - 1)` to determine the standard space between words, and calculate the extra spaces that need to be distributed.\\n\\n5. Construct the justified line of text:\\n\\n   a. Initialize an empty string `s` to build the line.\\n\\n   b. For each word in the range `[i, j)`, append the word to `s`.\\n\\n   c. If it\\'s not the last word in the line, add the standard spacing calculated earlier. Distribute the extra spaces if available.\\n\\n6. Push the constructed line `s` into the result vector `res`.\\n\\n7. Update the index `i` to the value of `j - 1` to move to the next line.\\n\\n8. Repeat the process until all words are processed.\\n\\n9. Return the `res` vector containing the justified lines of text.\\n\\n**Explanation**:\\n\\nThe approach divides the problem into two main cases based on the number of words in a line. For lines containing only one word or being the last line, the words are left-justified with spaces added to reach the `maxWidth`. For lines with multiple words that are not the last line, spaces are distributed evenly between words to achieve the target width.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![Screenshot (312).png](https://assets.leetcode.com/users/images/0c825012-e2c3-4f4e-9d13-5f02764c3ba8_1692850690.487161.png)\\n\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string>res;\\n        int n=words.size();\\n        int i=0;\\n        while(i<n){\\n            int j=i+1;\\n            int c=words[i].size();\\n            int wc=words[i].size();\\n            while(j<n&&c+words[j].size()+1<=maxWidth){\\n                c+=words[j].size()+1;\\n                wc+=words[j].length();\\n                j++;\\n            }\\n           if(j==n||(j-i)==1){\\n               string s=\"\";\\n               for(int p=i;p<j;p++){\\n                   s+=words[p];\\n                   if(p!=j-1)\\n                   s+=\\' \\';\\n               }\\n               int ts=maxWidth-s.size();\\n               for(int k=0;k<ts;k++){\\n                   s+=\\' \\';\\n               }\\n               res.push_back(s);\\n               i=j-1;\\n           }\\n           else{\\n             int tw=j-i;\\n             int ts=maxWidth-wc;\\n             int es=ts/(tw-1);\\n             int extra=ts%(tw-1);\\n             string s=\"\";\\n             for(int p=i;p<j;p++){\\n                 s+=words[p];\\n                 if(extra>0){\\n                    s+=\\' \\';\\n                    extra--;\\n                 }\\n                 if(p!=j-1){\\n                for(int k=0;k<es;k++){\\n                   s+=\\' \\';\\n               }\\n                 }\\n             }\\n             res.push_back(s);\\n              i=j-1;\\n           }\\n           i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        int n = words.length;\\n        int i = 0;\\n        while (i < n) {\\n            int j = i + 1;\\n            int c = words[i].length();\\n            int wc = words[i].length();\\n            while (j < n && c + words[j].length() + 1 <= maxWidth) {\\n                c += words[j].length() + 1;\\n                wc += words[j].length();\\n                j++;\\n            }\\n            if (j == n || j - i == 1) {\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.append(words[p]);\\n                    if (p != j - 1)\\n                        s.append(\\' \\');\\n                }\\n                int ts = maxWidth - s.length();\\n                for (int k = 0; k < ts; k++) {\\n                    s.append(\\' \\');\\n                }\\n                res.add(s.toString());\\n                i = j - 1;\\n            } else {\\n                int tw = j - i;\\n                int ts = maxWidth - wc;\\n                int es = ts / (tw - 1);\\n                int extra = ts % (tw - 1);\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.append(words[p]);\\n                    if (extra > 0) {\\n                        s.append(\\' \\');\\n                        extra--;\\n                    }\\n                    if (p != j - 1) {\\n                        for (int k = 0; k < es; k++) {\\n                            s.append(\\' \\');\\n                        }\\n                    }\\n                }\\n                res.add(s.toString());\\n                i = j - 1;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        n = len(words)\\n        i = 0\\n        while i < n:\\n            j = i + 1\\n            c = len(words[i])\\n            wc = len(words[i])\\n            while j < n and c + len(words[j]) + 1 <= maxWidth:\\n                c += len(words[j]) + 1\\n                wc += len(words[j])\\n                j += 1\\n            if j == n or j - i == 1:\\n                s = \\' \\'.join(words[i:j])\\n                ts = maxWidth - len(s)\\n                s += \\' \\' * ts\\n                res.append(s)\\n                i = j\\n            else:\\n                tw = j - i\\n                ts = maxWidth - wc\\n                es = ts // (tw - 1)\\n                extra = ts % (tw - 1)\\n                s = \\'\\'\\n                for p in range(i, j):\\n                    s += words[p]\\n                    if extra > 0:\\n                        s += \\' \\'\\n                        extra -= 1\\n                    if p != j - 1:\\n                        s += \\' \\' * es\\n                res.append(s)\\n                i = j\\n            i += 1\\n        return res\\n\\n```\\n```C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> res = new List<string>();\\n        int n = words.Length;\\n        int i = 0;\\n        while (i < n) {\\n            int j = i + 1;\\n            int c = words[i].Length;\\n            int wc = words[i].Length;\\n            while (j < n && c + words[j].Length + 1 <= maxWidth) {\\n                c += words[j].Length + 1;\\n                wc += words[j].Length;\\n                j++;\\n            }\\n            if (j == n || j - i == 1) {\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.Append(words[p]);\\n                    if (p != j - 1)\\n                        s.Append(\\' \\');\\n                }\\n                int ts = maxWidth - s.Length;\\n                s.Append(\\' \\', ts);\\n                res.Add(s.ToString());\\n                i = j;\\n            } else {\\n                int tw = j - i;\\n                int ts = maxWidth - wc;\\n                int es = ts / (tw - 1);\\n                int extra = ts % (tw - 1);\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.Append(words[p]);\\n                    if (extra > 0) {\\n                        s.Append(\\' \\');\\n                        extra--;\\n                    }\\n                    if (p != j - 1) {\\n                        s.Append(\\' \\', es);\\n                    }\\n                }\\n                res.Add(s.ToString());\\n                i = j;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string>res;\\n        int n=words.size();\\n        int i=0;\\n        while(i<n){\\n            int j=i+1;\\n            int c=words[i].size();\\n            int wc=words[i].size();\\n            while(j<n&&c+words[j].size()+1<=maxWidth){\\n                c+=words[j].size()+1;\\n                wc+=words[j].length();\\n                j++;\\n            }\\n           if(j==n||(j-i)==1){\\n               string s=\"\";\\n               for(int p=i;p<j;p++){\\n                   s+=words[p];\\n                   if(p!=j-1)\\n                   s+=\\' \\';\\n               }\\n               int ts=maxWidth-s.size();\\n               for(int k=0;k<ts;k++){\\n                   s+=\\' \\';\\n               }\\n               res.push_back(s);\\n               i=j-1;\\n           }\\n           else{\\n             int tw=j-i;\\n             int ts=maxWidth-wc;\\n             int es=ts/(tw-1);\\n             int extra=ts%(tw-1);\\n             string s=\"\";\\n             for(int p=i;p<j;p++){\\n                 s+=words[p];\\n                 if(extra>0){\\n                    s+=\\' \\';\\n                    extra--;\\n                 }\\n                 if(p!=j-1){\\n                for(int k=0;k<es;k++){\\n                   s+=\\' \\';\\n               }\\n                 }\\n             }\\n             res.push_back(s);\\n              i=j-1;\\n           }\\n           i++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        int n = words.length;\\n        int i = 0;\\n        while (i < n) {\\n            int j = i + 1;\\n            int c = words[i].length();\\n            int wc = words[i].length();\\n            while (j < n && c + words[j].length() + 1 <= maxWidth) {\\n                c += words[j].length() + 1;\\n                wc += words[j].length();\\n                j++;\\n            }\\n            if (j == n || j - i == 1) {\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.append(words[p]);\\n                    if (p != j - 1)\\n                        s.append(\\' \\');\\n                }\\n                int ts = maxWidth - s.length();\\n                for (int k = 0; k < ts; k++) {\\n                    s.append(\\' \\');\\n                }\\n                res.add(s.toString());\\n                i = j - 1;\\n            } else {\\n                int tw = j - i;\\n                int ts = maxWidth - wc;\\n                int es = ts / (tw - 1);\\n                int extra = ts % (tw - 1);\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.append(words[p]);\\n                    if (extra > 0) {\\n                        s.append(\\' \\');\\n                        extra--;\\n                    }\\n                    if (p != j - 1) {\\n                        for (int k = 0; k < es; k++) {\\n                            s.append(\\' \\');\\n                        }\\n                    }\\n                }\\n                res.add(s.toString());\\n                i = j - 1;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        n = len(words)\\n        i = 0\\n        while i < n:\\n            j = i + 1\\n            c = len(words[i])\\n            wc = len(words[i])\\n            while j < n and c + len(words[j]) + 1 <= maxWidth:\\n                c += len(words[j]) + 1\\n                wc += len(words[j])\\n                j += 1\\n            if j == n or j - i == 1:\\n                s = \\' \\'.join(words[i:j])\\n                ts = maxWidth - len(s)\\n                s += \\' \\' * ts\\n                res.append(s)\\n                i = j\\n            else:\\n                tw = j - i\\n                ts = maxWidth - wc\\n                es = ts // (tw - 1)\\n                extra = ts % (tw - 1)\\n                s = \\'\\'\\n                for p in range(i, j):\\n                    s += words[p]\\n                    if extra > 0:\\n                        s += \\' \\'\\n                        extra -= 1\\n                    if p != j - 1:\\n                        s += \\' \\' * es\\n                res.append(s)\\n                i = j\\n            i += 1\\n        return res\\n\\n```\n```C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> res = new List<string>();\\n        int n = words.Length;\\n        int i = 0;\\n        while (i < n) {\\n            int j = i + 1;\\n            int c = words[i].Length;\\n            int wc = words[i].Length;\\n            while (j < n && c + words[j].Length + 1 <= maxWidth) {\\n                c += words[j].Length + 1;\\n                wc += words[j].Length;\\n                j++;\\n            }\\n            if (j == n || j - i == 1) {\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.Append(words[p]);\\n                    if (p != j - 1)\\n                        s.Append(\\' \\');\\n                }\\n                int ts = maxWidth - s.Length;\\n                s.Append(\\' \\', ts);\\n                res.Add(s.ToString());\\n                i = j;\\n            } else {\\n                int tw = j - i;\\n                int ts = maxWidth - wc;\\n                int es = ts / (tw - 1);\\n                int extra = ts % (tw - 1);\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.Append(words[p]);\\n                    if (extra > 0) {\\n                        s.Append(\\' \\');\\n                        extra--;\\n                    }\\n                    if (p != j - 1) {\\n                        s.Append(\\' \\', es);\\n                    }\\n                }\\n                res.Add(s.ToString());\\n                i = j;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987109,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\nclass Solution {\\n     public List<String> fullJustify(String[] words, int maxWidth) {\\n        int left = 0; List<String> result = new ArrayList<>();\\n        \\n        while (left < words.length) {\\n            int right = findRight(left, words, maxWidth);\\n            result.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        \\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n            \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return padResult(words[left], maxWidth);\\n        \\n        boolean isLastLine = right == words.length - 1;\\n        int numSpaces = right - left;\\n        int totalSpace = maxWidth - wordsLength(left, right, words);\\n        \\n        String space = isLastLine ? \" \" : blank(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (int i = left; i <= right; i++)\\n            result.append(words[i])\\n                .append(space)\\n                .append(remainder-- > 0 ? \" \" : \"\");\\n        \\n        return padResult(result.toString().trim(), maxWidth);\\n    }\\n    \\n    private int wordsLength(int left, int right, String[] words) {\\n        int wordsLength = 0;\\n        for (int i = left; i <= right; i++) wordsLength += words[i].length();\\n        return wordsLength;\\n    }\\n    \\n    private String padResult(String result, int maxWidth) {\\n        return result + blank(maxWidth - result.length());\\n    }\\n    \\n    private String blank(int length) {\\n        return new String(new char[length]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n}\\n```\\n\\n***JavaScript***\\n```\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        const int totalWords = words.size()-1;\\n        for (int begin=0, moreWords=0; begin<=totalWords; begin=moreWords) {\\n            string currentBlock(maxWidth, \\' \\');\\n            /* In problem statement, it is specified that each word is guaranteed to be\\n             * grether than 0 and not exceed maxWidth, so I can safely add first word. */\\n            currentBlock.replace(0, words[begin].size(), words[begin]);\\n            /* Now current block of text is ready with first word and remainig spaces,\\n             * I just need to calculate how many more words I can fit in this block. */\\n            int remainingSpace = maxWidth - words[begin].size();\\n            for (moreWords=begin+1; moreWords <=totalWords && words[moreWords].size() < remainingSpace; moreWords++) {\\n                /* First word in current block is already added before this for loop.\\n                 * Additional word(s) can be added in current justification block. As this\\n                 * is additional word, at least one space is needed in calculation\\n                 * for remaining space. Above \\'<\\' condition make sure that we have space for\\n                 * one additional space */\\n                remainingSpace -= words[moreWords].size()+1;\\n            }\\n            /* Word joints are total separating gap between words, for which we need to do\\n             * space management */\\n            int wordJoints = moreWords - begin -1;\\n            if (wordJoints) {\\n                /*Ok so we have more than one word in this justification block*/\\n                int evenlyDistributedSpace = 1; /*One space is already provisioned in above loop */\\n                int unEvenSpace = 0;\\n                if (moreWords <= totalWords) {\\n                /* Control is here means current justification block is not the last\\n                 * block, so we need to do some mathematics on remaining space and evenly\\n                 * distribute it between the words (word joints). Remember for last block\\n                 * this is not needed as it is left aligned and additional words are only\\n                 * placed one white space apart */\\n                    evenlyDistributedSpace += remainingSpace / wordJoints;\\n                    unEvenSpace = remainingSpace % wordJoints;\\n                }\\n                for (int i=begin+1, index=words[begin].size(); i < moreWords; i++) {\\n                    index += evenlyDistributedSpace + (unEvenSpace-- > 0);\\n                    currentBlock.replace(index, words[i].size(), words[i]);\\n                    index += words[i].size();\\n                }\\n            }\\n            result.push_back(currentBlock);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans, cur = [], []\\n        chars = 0\\n        \\n        for word in words:\\n            # if cur is empty or the total chars + total needed spaces + next word fit\\n            if not cur or (len(word) + chars + len(cur)) <= maxWidth:\\n                cur.append(word)\\n                chars += len(word)\\n            else:\\n                # place spaces, append the line to the ans, and move on\\n                line = self.placeSpacesBetween(cur, maxWidth - chars)\\n                ans.append(line)\\n                cur.clear()\\n                cur.append(word)\\n                chars = len(word)\\n        \\n        # left justify any remaining text, which is easy\\n        if cur:\\n            extra_spaces = maxWidth - chars - len(cur) + 1\\n            ans.append(\\' \\'.join(cur) + \\' \\' * extra_spaces)\\n            \\n        return ans\\n    \\n    \\n    def placeSpacesBetween(self, words, spaces):\\n        if len(words) == 1: return words[0] + \\' \\' * spaces\\n        \\n        space_groups = len(words)-1\\n        spaces_between_words = spaces // space_groups\\n        extra_spaces = spaces % space_groups\\n        \\n        cur = []\\n        for word in words:\\n            cur.append(word)\\n            \\n            # place the min of remaining spaces or spaces between words plus an extra if available\\n            cur_extra = min(1, extra_spaces)\\n            spaces_to_place = min(spaces_between_words + cur_extra, spaces)\\n\\n            cur.append(\\' \\' * spaces_to_place)\\n            \\n            if extra_spaces: extra_spaces -= 1\\n            spaces -= spaces_to_place\\n        \\n        return \\'\\'.join(cur)\\n```\\n\\n***Kotlin***\\n```\\nclass Solution {\\n     private  val SEPARATOR = \" \" \\n    \\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\\n\\n        val result = mutableListOf<String>() // keeps the lines as a sting in a paragraph\\n        val currentLineWords = mutableListOf<String>()// keeps track of all the words for the current line\\n        var availableSpacePerLine = maxWidth //  keeps track of the available space in the current line\\n\\n        words.forEach { word ->\\n            availableSpacePerLine -= word.length\\n            when {\\n                (availableSpacePerLine == 0) -> { // the words perfectly fit\\n                    currentLineWords.add(word)\\n                    result.add(toLineString(availableSpacePerLine, currentLineWords))\\n\\n                    // Start a new line\\n                    currentLineWords.clear()\\n                    availableSpacePerLine = maxWidth\\n                }\\n                (availableSpacePerLine < 0) -> { // too much words in a line adjust!\\n                    availableSpacePerLine += (word.length + 1) //remove the claimed space for current\\n                    result.add(toLineString(availableSpacePerLine, currentLineWords))\\n\\n                    // Start a new line\\n                    currentLineWords.clear()\\n                    currentLineWords.add(word)\\n                    availableSpacePerLine = maxWidth - (word.length + 1)\\n                }\\n                (availableSpacePerLine > 0) -> { // space is still available in the current line\\n                    currentLineWords.add(word)\\n                    availableSpacePerLine--\\n                }\\n            }\\n        }\\n\\n        // Process the last line if there is one\\n        if (currentLineWords.isNotEmpty()) {\\n            result.add(toLineString(availableSpacePerLine + 1, currentLineWords, true))\\n        }\\n        return result\\n    }\\n    \\n\\n    private fun toLineString(\\n        noOfSpaceToBeDistributed: Int,\\n        wordsInLine: MutableList<String>,\\n        isLastLine: Boolean = false\\n    ): String {\\n        return if (wordsInLine.size == 1 || isLastLine) { // if there is only one word in a line or if the line is the last one , all the remaining spaces should just go to the end of the sentence\\n            wordsInLine.joinToString(SEPARATOR) + SEPARATOR.repeat(noOfSpaceToBeDistributed)\\n        } else { // other wise we have to evenly distribute the remaining lines\\n            val spaceToBeAddedToAllWords = (Math.floorDiv(\\n                noOfSpaceToBeDistributed,\\n                wordsInLine.lastIndex\\n            )) + 1 // the +1 is because we already take in to consideration a space when calculating noOfSpaceToBeDistributed\\n            \\n            for (i in 0 until noOfSpaceToBeDistributed % wordsInLine.lastIndex) {\\n                wordsInLine[i] += SEPARATOR\\n            }\\n            wordsInLine.joinToString(SEPARATOR.repeat(spaceToBeAddedToAllWords))\\n        }\\n    }\\n  \\n  \\n}\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\\n        var res: [String] = []\\n        var i = 0\\n        \\n        while i < words.count {\\n            var j = i\\n            var tmpLength = 0\\n            \\n            while j < words.count {\\n                tmpLength += words[j].count + ((j > i) ? 1 : 0)\\n                \\n                if tmpLength <= maxWidth { j += 1 } \\n                else {\\n                    res.append(stringWithWords(words, maxWidth, i, j))\\n                    break\\n                }\\n            }\\n            \\n            if j == words.count {\\n                res.append(stringWithWords(words, maxWidth, i, j))\\n            }\\n            i = j\\n        }\\n        \\n        return res\\n    }\\n\\n\\n    func stringWithWords(_ words: [String], _ maxWidth: Int, _ i: Int, _ j: Int) -> String {\\n        var length = 0\\n        var string = \"\"\\n        \\n        func space(_ n: Int) -> String {\\n            var string = \"\"\\n            for _ in 0..<n { string += \" \" }\\n            return string\\n        }\\n        \\n        func space(_ index: Int, _ count: Int, _ length: Int, _ maxWidth: Int, _ isLast: Bool) -> String {\\n            if isLast { return index == count - 1 ? space(maxWidth - length - count + 1) : \" \" }\\n            if count == 1 { return space(maxWidth - length) }\\n            if index == count - 1 { return \"\" }\\n            return space((maxWidth - length) / (count - 1)) + (index < ((maxWidth - length) % (count - 1)) ? \" \" : \"\")\\n        }\\n\\n        for k in i..<j { length += words[k].count }\\n        \\n        for k in i..<j {\\n            string += words[k] + space(k - i, j - i, length, maxWidth, j == words.count)\\n        }\\n        \\n        return string\\n    }\\n\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n     public List<String> fullJustify(String[] words, int maxWidth) {\\n        int left = 0; List<String> result = new ArrayList<>();\\n        \\n        while (left < words.length) {\\n            int right = findRight(left, words, maxWidth);\\n            result.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        \\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n            \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return padResult(words[left], maxWidth);\\n        \\n        boolean isLastLine = right == words.length - 1;\\n        int numSpaces = right - left;\\n        int totalSpace = maxWidth - wordsLength(left, right, words);\\n        \\n        String space = isLastLine ? \" \" : blank(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (int i = left; i <= right; i++)\\n            result.append(words[i])\\n                .append(space)\\n                .append(remainder-- > 0 ? \" \" : \"\");\\n        \\n        return padResult(result.toString().trim(), maxWidth);\\n    }\\n    \\n    private int wordsLength(int left, int right, String[] words) {\\n        int wordsLength = 0;\\n        for (int i = left; i <= right; i++) wordsLength += words[i].length();\\n        return wordsLength;\\n    }\\n    \\n    private String padResult(String result, int maxWidth) {\\n        return result + blank(maxWidth - result.length());\\n    }\\n    \\n    private String blank(int length) {\\n        return new String(new char[length]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n}\\n```\n```\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        const int totalWords = words.size()-1;\\n        for (int begin=0, moreWords=0; begin<=totalWords; begin=moreWords) {\\n            string currentBlock(maxWidth, \\' \\');\\n            /* In problem statement, it is specified that each word is guaranteed to be\\n             * grether than 0 and not exceed maxWidth, so I can safely add first word. */\\n            currentBlock.replace(0, words[begin].size(), words[begin]);\\n            /* Now current block of text is ready with first word and remainig spaces,\\n             * I just need to calculate how many more words I can fit in this block. */\\n            int remainingSpace = maxWidth - words[begin].size();\\n            for (moreWords=begin+1; moreWords <=totalWords && words[moreWords].size() < remainingSpace; moreWords++) {\\n                /* First word in current block is already added before this for loop.\\n                 * Additional word(s) can be added in current justification block. As this\\n                 * is additional word, at least one space is needed in calculation\\n                 * for remaining space. Above \\'<\\' condition make sure that we have space for\\n                 * one additional space */\\n                remainingSpace -= words[moreWords].size()+1;\\n            }\\n            /* Word joints are total separating gap between words, for which we need to do\\n             * space management */\\n            int wordJoints = moreWords - begin -1;\\n            if (wordJoints) {\\n                /*Ok so we have more than one word in this justification block*/\\n                int evenlyDistributedSpace = 1; /*One space is already provisioned in above loop */\\n                int unEvenSpace = 0;\\n                if (moreWords <= totalWords) {\\n                /* Control is here means current justification block is not the last\\n                 * block, so we need to do some mathematics on remaining space and evenly\\n                 * distribute it between the words (word joints). Remember for last block\\n                 * this is not needed as it is left aligned and additional words are only\\n                 * placed one white space apart */\\n                    evenlyDistributedSpace += remainingSpace / wordJoints;\\n                    unEvenSpace = remainingSpace % wordJoints;\\n                }\\n                for (int i=begin+1, index=words[begin].size(); i < moreWords; i++) {\\n                    index += evenlyDistributedSpace + (unEvenSpace-- > 0);\\n                    currentBlock.replace(index, words[i].size(), words[i]);\\n                    index += words[i].size();\\n                }\\n            }\\n            result.push_back(currentBlock);\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans, cur = [], []\\n        chars = 0\\n        \\n        for word in words:\\n            # if cur is empty or the total chars + total needed spaces + next word fit\\n            if not cur or (len(word) + chars + len(cur)) <= maxWidth:\\n                cur.append(word)\\n                chars += len(word)\\n            else:\\n                # place spaces, append the line to the ans, and move on\\n                line = self.placeSpacesBetween(cur, maxWidth - chars)\\n                ans.append(line)\\n                cur.clear()\\n                cur.append(word)\\n                chars = len(word)\\n        \\n        # left justify any remaining text, which is easy\\n        if cur:\\n            extra_spaces = maxWidth - chars - len(cur) + 1\\n            ans.append(\\' \\'.join(cur) + \\' \\' * extra_spaces)\\n            \\n        return ans\\n    \\n    \\n    def placeSpacesBetween(self, words, spaces):\\n        if len(words) == 1: return words[0] + \\' \\' * spaces\\n        \\n        space_groups = len(words)-1\\n        spaces_between_words = spaces // space_groups\\n        extra_spaces = spaces % space_groups\\n        \\n        cur = []\\n        for word in words:\\n            cur.append(word)\\n            \\n            # place the min of remaining spaces or spaces between words plus an extra if available\\n            cur_extra = min(1, extra_spaces)\\n            spaces_to_place = min(spaces_between_words + cur_extra, spaces)\\n\\n            cur.append(\\' \\' * spaces_to_place)\\n            \\n            if extra_spaces: extra_spaces -= 1\\n            spaces -= spaces_to_place\\n        \\n        return \\'\\'.join(cur)\\n```\n```\\nclass Solution {\\n     private  val SEPARATOR = \" \" \\n    \\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\\n\\n        val result = mutableListOf<String>() // keeps the lines as a sting in a paragraph\\n        val currentLineWords = mutableListOf<String>()// keeps track of all the words for the current line\\n        var availableSpacePerLine = maxWidth //  keeps track of the available space in the current line\\n\\n        words.forEach { word ->\\n            availableSpacePerLine -= word.length\\n            when {\\n                (availableSpacePerLine == 0) -> { // the words perfectly fit\\n                    currentLineWords.add(word)\\n                    result.add(toLineString(availableSpacePerLine, currentLineWords))\\n\\n                    // Start a new line\\n                    currentLineWords.clear()\\n                    availableSpacePerLine = maxWidth\\n                }\\n                (availableSpacePerLine < 0) -> { // too much words in a line adjust!\\n                    availableSpacePerLine += (word.length + 1) //remove the claimed space for current\\n                    result.add(toLineString(availableSpacePerLine, currentLineWords))\\n\\n                    // Start a new line\\n                    currentLineWords.clear()\\n                    currentLineWords.add(word)\\n                    availableSpacePerLine = maxWidth - (word.length + 1)\\n                }\\n                (availableSpacePerLine > 0) -> { // space is still available in the current line\\n                    currentLineWords.add(word)\\n                    availableSpacePerLine--\\n                }\\n            }\\n        }\\n\\n        // Process the last line if there is one\\n        if (currentLineWords.isNotEmpty()) {\\n            result.add(toLineString(availableSpacePerLine + 1, currentLineWords, true))\\n        }\\n        return result\\n    }\\n    \\n\\n    private fun toLineString(\\n        noOfSpaceToBeDistributed: Int,\\n        wordsInLine: MutableList<String>,\\n        isLastLine: Boolean = false\\n    ): String {\\n        return if (wordsInLine.size == 1 || isLastLine) { // if there is only one word in a line or if the line is the last one , all the remaining spaces should just go to the end of the sentence\\n            wordsInLine.joinToString(SEPARATOR) + SEPARATOR.repeat(noOfSpaceToBeDistributed)\\n        } else { // other wise we have to evenly distribute the remaining lines\\n            val spaceToBeAddedToAllWords = (Math.floorDiv(\\n                noOfSpaceToBeDistributed,\\n                wordsInLine.lastIndex\\n            )) + 1 // the +1 is because we already take in to consideration a space when calculating noOfSpaceToBeDistributed\\n            \\n            for (i in 0 until noOfSpaceToBeDistributed % wordsInLine.lastIndex) {\\n                wordsInLine[i] += SEPARATOR\\n            }\\n            wordsInLine.joinToString(SEPARATOR.repeat(spaceToBeAddedToAllWords))\\n        }\\n    }\\n  \\n  \\n}\\n```\n```\\nclass Solution {\\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\\n        var res: [String] = []\\n        var i = 0\\n        \\n        while i < words.count {\\n            var j = i\\n            var tmpLength = 0\\n            \\n            while j < words.count {\\n                tmpLength += words[j].count + ((j > i) ? 1 : 0)\\n                \\n                if tmpLength <= maxWidth { j += 1 } \\n                else {\\n                    res.append(stringWithWords(words, maxWidth, i, j))\\n                    break\\n                }\\n            }\\n            \\n            if j == words.count {\\n                res.append(stringWithWords(words, maxWidth, i, j))\\n            }\\n            i = j\\n        }\\n        \\n        return res\\n    }\\n\\n\\n    func stringWithWords(_ words: [String], _ maxWidth: Int, _ i: Int, _ j: Int) -> String {\\n        var length = 0\\n        var string = \"\"\\n        \\n        func space(_ n: Int) -> String {\\n            var string = \"\"\\n            for _ in 0..<n { string += \" \" }\\n            return string\\n        }\\n        \\n        func space(_ index: Int, _ count: Int, _ length: Int, _ maxWidth: Int, _ isLast: Bool) -> String {\\n            if isLast { return index == count - 1 ? space(maxWidth - length - count + 1) : \" \" }\\n            if count == 1 { return space(maxWidth - length) }\\n            if index == count - 1 { return \"\" }\\n            return space((maxWidth - length) / (count - 1)) + (index < ((maxWidth - length) % (count - 1)) ? \" \" : \"\")\\n        }\\n\\n        for k in i..<j { length += words[k].count }\\n        \\n        for k in i..<j {\\n            string += words[k] + space(k - i, j - i, length, maxWidth, j == words.count)\\n        }\\n        \\n        return string\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446139,
                "title": "well-commented-javascript-solution",
                "content": "```javascript\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [];\\n    let buf = [];\\n    let width = maxWidth;\\n    \\n    // Greedy pack each line\\n    // when that fails add the line to the result with the added padding\\n    // and start a new line\\n    words.forEach(word => {\\n        // Check if the word fits in the current line\\n        // A word fits if theres enough room for the word and\\n        // a space between it and the word to the left\\n        if (word.length <= (width - buf.length)) {\\n            buf.push(word);\\n            width -= word.length;\\n        } else {\\n            // The word did not fit on the line, send this line for padding\\n            addWordToResult(res, buf.slice(), maxWidth);\\n            \\n            // Start a new line with the current word\\n            buf = [word];\\n            // reset the current line width\\n            width = maxWidth - word.length;\\n        }\\n    });\\n    \\n    // This is the final lines processing\\n    // According the rules this should only be left justified\\n    // so add all padding to the right not between the words\\n    if (buf.length) {\\n        let str = buf.join(\\' \\');\\n        str += \\' \\'.repeat(maxWidth - str.length);\\n        res.push(str);\\n    }\\n    \\n    return res;\\n};\\n\\n// Max words are on each line now pad them with spaces\\nfunction addWordToResult(res, buf, maxWidth) {\\n    // How many spaces are needed\\n    let spaces = maxWidth - buf.reduce((acc, cur) => cur.length + acc, 0);\\n    \\n    // If there is only one word on the line\\n    // then just add the padding to the end and return\\n    if (buf.length === 1) {\\n        buf[0] += \\' \\'.repeat(spaces);\\n        res.push(buf[0]);\\n        return;\\n    }\\n    \\n    // If the line has more than one word,\\n    // decrement the spaces which are created during the buf.join(\\' \\')\\n    // which is n - 1 spaces\\n    spaces -= buf.length - 1;\\n    \\n    // All words except the last should have spaces added to their string\\n    const end = buf.length - 1;\\n    let index = 0;\\n    \\n    // If there are spaces to distribute, distribute them\\n    // evenly looping back to the beginning of the buffer\\n    while (spaces-- > 0) {\\n        buf[index] += \\' \\';\\n        \\n        index = (index + 1) % end;\\n    }\\n    \\n    res.push(buf.join(\\' \\'))\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [];\\n    let buf = [];\\n    let width = maxWidth;\\n    \\n    // Greedy pack each line\\n    // when that fails add the line to the result with the added padding\\n    // and start a new line\\n    words.forEach(word => {\\n        // Check if the word fits in the current line\\n        // A word fits if theres enough room for the word and\\n        // a space between it and the word to the left\\n        if (word.length <= (width - buf.length)) {\\n            buf.push(word);\\n            width -= word.length;\\n        } else {\\n            // The word did not fit on the line, send this line for padding\\n            addWordToResult(res, buf.slice(), maxWidth);\\n            \\n            // Start a new line with the current word\\n            buf = [word];\\n            // reset the current line width\\n            width = maxWidth - word.length;\\n        }\\n    });\\n    \\n    // This is the final lines processing\\n    // According the rules this should only be left justified\\n    // so add all padding to the right not between the words\\n    if (buf.length) {\\n        let str = buf.join(\\' \\');\\n        str += \\' \\'.repeat(maxWidth - str.length);\\n        res.push(str);\\n    }\\n    \\n    return res;\\n};\\n\\n// Max words are on each line now pad them with spaces\\nfunction addWordToResult(res, buf, maxWidth) {\\n    // How many spaces are needed\\n    let spaces = maxWidth - buf.reduce((acc, cur) => cur.length + acc, 0);\\n    \\n    // If there is only one word on the line\\n    // then just add the padding to the end and return\\n    if (buf.length === 1) {\\n        buf[0] += \\' \\'.repeat(spaces);\\n        res.push(buf[0]);\\n        return;\\n    }\\n    \\n    // If the line has more than one word,\\n    // decrement the spaces which are created during the buf.join(\\' \\')\\n    // which is n - 1 spaces\\n    spaces -= buf.length - 1;\\n    \\n    // All words except the last should have spaces added to their string\\n    const end = buf.length - 1;\\n    let index = 0;\\n    \\n    // If there are spaces to distribute, distribute them\\n    // evenly looping back to the beginning of the buffer\\n    while (spaces-- > 0) {\\n        buf[index] += \\' \\';\\n        \\n        index = (index + 1) % end;\\n    }\\n    \\n    res.push(buf.join(\\' \\'))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3953480,
                "title": "c-string-faster-than-100-day-24",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    vector<string> fullJustify(vector<string> &w, int check)\\n    {\\n        vector<string> ans;\\n        int i = 0;\\n        while (i < w.size())\\n        {\\n            int end = i;\\n            int space = 0;\\n            int word = 0;\\n            string s = \"\";\\n            int word_length = 0;\\n            for (int j = i; j < w.size(); j++)\\n            {\\n                if (j == i)\\n                {\\n                    word++;\\n                    word_length += w[j].size();\\n                }\\n                else\\n                {\\n                    if (word_length + space + 1 + w[j].size() > check)\\n                        break;\\n                    else\\n                    {\\n                        space++;\\n                        word++;\\n                        word_length += w[j].size();\\n                        end = j;\\n                    }\\n                }\\n            }\\n            if (end != w.size() - 1)\\n            {\\n                int extra = 0;\\n                int spc = 0;\\n                if (space)\\n                {\\n                    spc = (check - word_length) / space;\\n                    extra = (check - word_length) % space;\\n                }\\n                for (int j = i; j <= end; j++)\\n                {\\n                    s += w[j];\\n                    for (int k = 0; k < spc && j != end; k++)\\n                    {\\n                        s += \" \";\\n                    }\\n                    if (extra)\\n                    {\\n                        extra--;\\n                        s += \" \";\\n                    }\\n                }\\n                if (space == 0)\\n                {\\n                    int k = s.size();\\n                    for (int j = 1; j <= (check - k); j++)\\n                    {\\n                        s += \" \";\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for (int j = i; j <= end; j++)\\n                {\\n                    if (j == i)\\n                        s += w[j];\\n                    else\\n                    {\\n                        s += \" \";\\n                        s += w[j];\\n                    }\\n                }\\n                int k = s.size();\\n                for (int j = 1; j <= (check - k); j++)\\n                {\\n                    s += \" \";\\n                }\\n            }\\n            i = end + 1;\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/c55adefd-96e8-4eb9-93ba-fd2b676955cd_1692866831.3735065.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<string> fullJustify(vector<string> &w, int check)\\n    {\\n        vector<string> ans;\\n        int i = 0;\\n        while (i < w.size())\\n        {\\n            int end = i;\\n            int space = 0;\\n            int word = 0;\\n            string s = \"\";\\n            int word_length = 0;\\n            for (int j = i; j < w.size(); j++)\\n            {\\n                if (j == i)\\n                {\\n                    word++;\\n                    word_length += w[j].size();\\n                }\\n                else\\n                {\\n                    if (word_length + space + 1 + w[j].size() > check)\\n                        break;\\n                    else\\n                    {\\n                        space++;\\n                        word++;\\n                        word_length += w[j].size();\\n                        end = j;\\n                    }\\n                }\\n            }\\n            if (end != w.size() - 1)\\n            {\\n                int extra = 0;\\n                int spc = 0;\\n                if (space)\\n                {\\n                    spc = (check - word_length) / space;\\n                    extra = (check - word_length) % space;\\n                }\\n                for (int j = i; j <= end; j++)\\n                {\\n                    s += w[j];\\n                    for (int k = 0; k < spc && j != end; k++)\\n                    {\\n                        s += \" \";\\n                    }\\n                    if (extra)\\n                    {\\n                        extra--;\\n                        s += \" \";\\n                    }\\n                }\\n                if (space == 0)\\n                {\\n                    int k = s.size();\\n                    for (int j = 1; j <= (check - k); j++)\\n                    {\\n                        s += \" \";\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for (int j = i; j <= end; j++)\\n                {\\n                    if (j == i)\\n                        s += w[j];\\n                    else\\n                    {\\n                        s += \" \";\\n                        s += w[j];\\n                    }\\n                }\\n                int k = s.size();\\n                for (int j = 1; j <= (check - k); j++)\\n                {\\n                    s += \" \";\\n                }\\n            }\\n            i = end + 1;\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042723,
                "title": "intuitive-readable-python-solution-beats-95-90",
                "content": "I was just given a variant of this question on a Karat, so I wanted to solve it on LC. I noticed a lot of the discussion answers were a bit rough to read, so I wanted to share this readible yet performant answer.\\n\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans, cur = [], []\\n        chars = 0\\n        \\n        for word in words:\\n            # if cur is empty or the total chars + total needed spaces + next word fit\\n            if not cur or (len(word) + chars + len(cur)) <= maxWidth:\\n                cur.append(word)\\n                chars += len(word)\\n            else:\\n                # place spaces, append the line to the ans, and move on\\n                line = self.placeSpacesBetween(cur, maxWidth - chars)\\n                ans.append(line)\\n                cur.clear()\\n                cur.append(word)\\n                chars = len(word)\\n        \\n        # left justify any remaining text, which is easy\\n        if cur:\\n            extra_spaces = maxWidth - chars - len(cur) + 1\\n            ans.append(\\' \\'.join(cur) + \\' \\' * extra_spaces)\\n            \\n        return ans\\n    \\n    \\n    def placeSpacesBetween(self, words, spaces):\\n        if len(words) == 1: return words[0] + \\' \\' * spaces\\n        \\n        space_groups = len(words)-1\\n        spaces_between_words = spaces // space_groups\\n        extra_spaces = spaces % space_groups\\n        \\n        cur = []\\n        for word in words:\\n            cur.append(word)\\n            \\n            # place the min of remaining spaces or spaces between words plus an extra if available\\n            cur_extra = min(1, extra_spaces)\\n            spaces_to_place = min(spaces_between_words + cur_extra, spaces)\\n\\n            cur.append(\\' \\' * spaces_to_place)\\n            \\n            if extra_spaces: extra_spaces -= 1\\n            spaces -= spaces_to_place\\n        \\n        return \\'\\'.join(cur)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans, cur = [], []\\n        chars = 0\\n        \\n        for word in words:\\n            # if cur is empty or the total chars + total needed spaces + next word fit\\n            if not cur or (len(word) + chars + len(cur)) <= maxWidth:\\n                cur.append(word)\\n                chars += len(word)\\n            else:\\n                # place spaces, append the line to the ans, and move on\\n                line = self.placeSpacesBetween(cur, maxWidth - chars)\\n                ans.append(line)\\n                cur.clear()\\n                cur.append(word)\\n                chars = len(word)\\n        \\n        # left justify any remaining text, which is easy\\n        if cur:\\n            extra_spaces = maxWidth - chars - len(cur) + 1\\n            ans.append(\\' \\'.join(cur) + \\' \\' * extra_spaces)\\n            \\n        return ans\\n    \\n    \\n    def placeSpacesBetween(self, words, spaces):\\n        if len(words) == 1: return words[0] + \\' \\' * spaces\\n        \\n        space_groups = len(words)-1\\n        spaces_between_words = spaces // space_groups\\n        extra_spaces = spaces % space_groups\\n        \\n        cur = []\\n        for word in words:\\n            cur.append(word)\\n            \\n            # place the min of remaining spaces or spaces between words plus an extra if available\\n            cur_extra = min(1, extra_spaces)\\n            spaces_to_place = min(spaces_between_words + cur_extra, spaces)\\n\\n            cur.append(\\' \\' * spaces_to_place)\\n            \\n            if extra_spaces: extra_spaces -= 1\\n            spaces -= spaces_to_place\\n        \\n        return \\'\\'.join(cur)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24989,
                "title": "easy-java-implementation",
                "content": "- I divide the solution to this question into two parts:\\n - one is for counting the valid number of words which can fit into one line, i.e. helper() function does it and also passes the next index to be traversed in the next turn (it can be modified as iterative way if you are more comfortable with).\\n\\n - the other part serves as a string editor, i.e. addList() uses the actual valid words lengths (len) and index of start (i, inclusive) and end (j, exclusive) to count the spaces to be added.\\n\\n-\\n\\n    public class Solution {\\n    private List<String> result;\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        result = new ArrayList<String>();\\n        if (words == null || words.length == 0 || maxWidth < 0) return result;\\n        if (maxWidth == 0) {\\n            result.add(\"\");\\n            return result;\\n        }\\n        helper(words, 0, maxWidth);\\n        return result;\\n    }\\n    \\n    public void helper(String[] words, int start, int L) {\\n        if (start >= words.length) return;\\n        \\n        int i = start, len = 0, total = 0, next = -1;\\n        while (total < L && i < words.length) {\\n            total += words[i].length();\\n            if (total > L) { // only in this case we need skip i++\\n                next = i;\\n                break;\\n            }\\n            len += words[i].length();\\n            total++; // count space\\n            i++;\\n        }\\n        \\n        if (next == -1) next = i;\\n        addList(words, start, next, len, L);\\n        \\n        helper(words, next, L);\\n    }\\n    \\n    public void addList(String[] words, int i, int j, int len, int L) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int count = j-i-1, space = 0, more = 0, s = 0;\\n        if (count == 0 || j == words.length) { // the last line\\n            for (int k = i; k < j; k++) {\\n                sb.append(words[k]);\\n                if (k == j-1) break;\\n                sb.append(\" \");\\n            }\\n            space = L - sb.length();\\n            s = 0;\\n            while (s++ < space) sb.append(\" \");\\n        } else {\\n            space = (L - len) / count; more = (L - len) % count;\\n            for (int k = i; k < j; k++) {\\n                sb.append(words[k]);\\n                s = 0;\\n                if (k == j-1) break;\\n                while (s++ < space) sb.append(\" \");\\n                if (more-- > 0) sb.append(\" \");\\n            }\\n        }\\n        \\n        result.add(sb.toString());\\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    private List<String> result;\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        result = new ArrayList<String>();\\n        if (words == null || words.length == 0 || maxWidth < 0) return result;\\n        if (maxWidth == 0) {\\n            result.add(\"\");\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1810892,
                "title": "java-simple-approach-with-explanation-runtime-0-ms-100-faster",
                "content": "# **Please upvote if you like the solution**\\n\\n```\\nclass Solution {\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\n        List<String> result = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        int start = 0, length = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            /**\\n             * Try to add words till its under maxWidth length\\n             */\\n            if (words[i].length() <= (maxWidth - length)) {\\n                // + 1 because after each word there should be a space\\n                length += words[i].length() + 1;\\n                continue;\\n            }\\n            /**\\n             * Process the words which can be part of the justified sentence\\n             */\\n            else {\\n                /**\\n                 * Intention is try to get the remaining Spaces number and number of words part of the sentence\\n                 * As we have to distribute the spaces as evenly as possible, we can figure put the in between spaces\\n                 * between the words by doing remainingSpaces / noOfWords\\n                 * and there is a possibility that after evenly distributed the spaces also there can be some extra spaces\\n                 * which are pending.\\n                 *  Like for an example\\n                 *      remainingSpaces = 8 and noOfWords = 3\\n                 *      So in between spaces will be 8 / 3 = 2 spaces. But still 8 - (3 * 2) = 2 spaces are remaining\\n                 *      As per the problem those spaces can be placed sequentially between the words (till possible)\\n                 */\\n\\n                /**\\n                 * Adding + 1 because none of the justified sentence should end with \" \" (space) and we have added space\\n                 * for each word while calculating the length of the words. So, just removing the space after last word\\n                 */\\n                int remainingSpaces = maxWidth - length + 1;\\n\\n                /**\\n                 * Decreasing the number of word by 1 because\\n                 * If for a sentence 3 words are eligible the spaces should be distributed between\\n                 *  (word1 - word2) And (word2 - word3)\\n                 *  There should not be any trailing spaces.\\n                 */\\n                int noOfWords = i - start - 1;\\n                int extraSpaceBetweenWords = 0;\\n\\n                if (noOfWords > 0) {\\n                    extraSpaceBetweenWords = remainingSpaces / noOfWords;\\n                    remainingSpaces = remainingSpaces % noOfWords;\\n                }\\n\\n                /**\\n                 * Append the word, extra space & remainingSpaces (if present)\\n                 * Iterating till (i - 1) position as we want to add those extra spaces in between words not at end\\n                 * Like if for a sentence 3 words are eligible the spaces should be distributed between\\n                 *  (word1 - word2) And (word2 - word3)\\n                 */\\n                while (start < i - 1) {\\n                    sb.append(words[start++]).append(\" \");\\n                    int k = 0;\\n                    while (k < extraSpaceBetweenWords) {\\n                        sb.append(\" \");\\n                        k++;\\n                    }\\n                    if (remainingSpaces > 0) {\\n                        sb.append(\" \");\\n                        remainingSpaces--;\\n                    }\\n                }\\n                // Appending the last word part of sentence\\n                sb.append(words[start]);\\n\\n                /**\\n                 *  This will execute only for the cases where there is only 1 word part of the sentence\\n                 *  and its not covered as part of the previous while loop\\n                 */\\n                while (remainingSpaces > 0) {\\n                    sb.append(\" \");\\n                    remainingSpaces--;\\n                }\\n                result.add(sb.toString());\\n\\n                /**\\n                 * reset start position to current position\\n                 * update the length of the current word\\n                 * resetting the StringBuilder\\n                 */\\n                start = i;\\n                length = words[i].length() + 1;\\n                sb.setLength(0);\\n            }\\n        }\\n\\n        /**\\n         * Processing the last sentence, which should be left-justified and no extra space is inserted between words.\\n         *\\n         * Iterating till (words.length - 1) position as we want to add those extra spaces in between words not at end\\n         * Like if for a sentence 3 words are eligible the spaces should be distributed between\\n         *  (word1 - word2) And (word2 - word3)\\n         */\\n        sb.setLength(0);\\n        while (start < words.length - 1) {\\n            sb.append(words[start++]).append(\" \");\\n        }\\n        // Appending the last word part of sentence\\n        sb.append(words[start]);\\n\\n        /**\\n         * Filling the rest position with extra spaces\\n         */\\n        while (sb.length() < maxWidth) {\\n            sb.append(\" \");\\n        }\\n        result.add(sb.toString());\\n\\n        return result;\\n    }\\n    \\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/016be550-127a-490a-9021-3a5610a1fcb3_1646168702.7983997.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\n        List<String> result = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        int start = 0, length = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            /**\\n             * Try to add words till its under maxWidth length\\n             */\\n            if (words[i].length() <= (maxWidth - length)) {\\n                // + 1 because after each word there should be a space\\n                length += words[i].length() + 1;\\n                continue;\\n            }\\n            /**\\n             * Process the words which can be part of the justified sentence\\n             */\\n            else {\\n                /**\\n                 * Intention is try to get the remaining Spaces number and number of words part of the sentence\\n                 * As we have to distribute the spaces as evenly as possible, we can figure put the in between spaces\\n                 * between the words by doing remainingSpaces / noOfWords\\n                 * and there is a possibility that after evenly distributed the spaces also there can be some extra spaces\\n                 * which are pending.\\n                 *  Like for an example\\n                 *      remainingSpaces = 8 and noOfWords = 3\\n                 *      So in between spaces will be 8 / 3 = 2 spaces. But still 8 - (3 * 2) = 2 spaces are remaining\\n                 *      As per the problem those spaces can be placed sequentially between the words (till possible)\\n                 */\\n\\n                /**\\n                 * Adding + 1 because none of the justified sentence should end with \" \" (space) and we have added space\\n                 * for each word while calculating the length of the words. So, just removing the space after last word\\n                 */\\n                int remainingSpaces = maxWidth - length + 1;\\n\\n                /**\\n                 * Decreasing the number of word by 1 because\\n                 * If for a sentence 3 words are eligible the spaces should be distributed between\\n                 *  (word1 - word2) And (word2 - word3)\\n                 *  There should not be any trailing spaces.\\n                 */\\n                int noOfWords = i - start - 1;\\n                int extraSpaceBetweenWords = 0;\\n\\n                if (noOfWords > 0) {\\n                    extraSpaceBetweenWords = remainingSpaces / noOfWords;\\n                    remainingSpaces = remainingSpaces % noOfWords;\\n                }\\n\\n                /**\\n                 * Append the word, extra space & remainingSpaces (if present)\\n                 * Iterating till (i - 1) position as we want to add those extra spaces in between words not at end\\n                 * Like if for a sentence 3 words are eligible the spaces should be distributed between\\n                 *  (word1 - word2) And (word2 - word3)\\n                 */\\n                while (start < i - 1) {\\n                    sb.append(words[start++]).append(\" \");\\n                    int k = 0;\\n                    while (k < extraSpaceBetweenWords) {\\n                        sb.append(\" \");\\n                        k++;\\n                    }\\n                    if (remainingSpaces > 0) {\\n                        sb.append(\" \");\\n                        remainingSpaces--;\\n                    }\\n                }\\n                // Appending the last word part of sentence\\n                sb.append(words[start]);\\n\\n                /**\\n                 *  This will execute only for the cases where there is only 1 word part of the sentence\\n                 *  and its not covered as part of the previous while loop\\n                 */\\n                while (remainingSpaces > 0) {\\n                    sb.append(\" \");\\n                    remainingSpaces--;\\n                }\\n                result.add(sb.toString());\\n\\n                /**\\n                 * reset start position to current position\\n                 * update the length of the current word\\n                 * resetting the StringBuilder\\n                 */\\n                start = i;\\n                length = words[i].length() + 1;\\n                sb.setLength(0);\\n            }\\n        }\\n\\n        /**\\n         * Processing the last sentence, which should be left-justified and no extra space is inserted between words.\\n         *\\n         * Iterating till (words.length - 1) position as we want to add those extra spaces in between words not at end\\n         * Like if for a sentence 3 words are eligible the spaces should be distributed between\\n         *  (word1 - word2) And (word2 - word3)\\n         */\\n        sb.setLength(0);\\n        while (start < words.length - 1) {\\n            sb.append(words[start++]).append(\" \");\\n        }\\n        // Appending the last word part of sentence\\n        sb.append(words[start]);\\n\\n        /**\\n         * Filling the rest position with extra spaces\\n         */\\n        while (sb.length() < maxWidth) {\\n            sb.append(\" \");\\n        }\\n        result.add(sb.toString());\\n\\n        return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495455,
                "title": "simple-10-lines-c-solution-0ms-100-8-9mb-100",
                "content": "For the current line, the idea is to select a number of words based on their length. The selection is represented by the interval `[i,j)`. Each time a word is selected, we reduce the remaining `room`, until the next word doesn\\'t fit the line.\\n\\nThen, we compute the `gap` as the **quotient** of the `room` and the number of words *minus one* (`gap = room / (j - i - 1)`). There is possibly remaining `room` as the **remainder** of this division isn\\'t necessarily null (`room -= gap * (j - i - 1)`) . Therefore we add `gap + 1` spaces for the `room` first gaps and `gap` spaces for the others, i.e. `gap + (room-- > 0 ? 1 : 0)`.\\n\\nOnce the line is done (`i == j`), we start a new line and this until all words have been consumed (`i == n`).\\n\\n**Note :** One should pay attention that the *last* word of a line is treated differently.\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size(), room, gap;\\n        vector<string> text;\\n        \\n        for (int i = 0, j = 0; i < n;) { // Two pointers i and j\\n            for (room = maxWidth; j < n and room >= j - i + words[j].length();) // While there is enough room\\n                room -= words[j++].length();\\n\\n            gap = (j - i == 1) or (j == n) ? 0 : room / (j - i - 1); // If one word or last line gap is null\\n            room -= gap * (j - i - 1); // Remainder\\n            \\n            text.push_back(\"\");\\n            while (i < j - 1)\\n                text.back().append(words[i++]).append(gap + (room-- > 0 ? 1 : 0), \\' \\');\\n            text.back().append(words[i++]).append(max(room, 0), \\' \\');\\n        }\\n        \\n        return text;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size(), room, gap;\\n        vector<string> text;\\n        \\n        for (int i = 0, j = 0; i < n;) { // Two pointers i and j\\n            for (room = maxWidth; j < n and room >= j - i + words[j].length();) // While there is enough room\\n                room -= words[j++].length();\\n\\n            gap = (j - i == 1) or (j == n) ? 0 : room / (j - i - 1); // If one word or last line gap is null\\n            room -= gap * (j - i - 1); // Remainder\\n            \\n            text.push_back(\"\");\\n            while (i < j - 1)\\n                text.back().append(words[i++]).append(gap + (room-- > 0 ? 1 : 0), \\' \\');\\n            text.back().append(words[i++]).append(max(room, 0), \\' \\');\\n        }\\n        \\n        return text;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24898,
                "title": "short-javascript-o-n-solution",
                "content": "The two-pass version where we preprocess the words into rows is easier to understand:\\n```\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [[]];\\n    res[0].letters = 0;\\n    for (let word of words) {\\n        let row = res[res.length - 1];\\n        if (row.length && row.letters + row.length + word.length > maxWidth) {\\n            res.push([]);\\n            row = res[res.length - 1];\\n            row.letters = 0;\\n        }\\n        row.push(word);\\n        row.letters += word.length;\\n    }\\n    for (let r = 0; r < res.length; r++) {\\n        let row = res[r];\\n        if (row.length === 1 || r === res.length - 1) {\\n            res[r] = row.join(' ') + ' '.repeat(maxWidth - row.letters - row.length + 1);\\n            continue;\\n        }\\n        let line = row[0];\\n        let spaces = maxWidth - row.letters;\\n        let minSpaces = ' '.repeat(Math.floor(spaces / (row.length - 1)));\\n        let addSpace = spaces % (row.length - 1);\\n        for (let w = 1; w < row.length; w++) {\\n            line += minSpaces + (w <= addSpace ? ' ' : '') + row[w];\\n        }\\n        res[r] = line;\\n    }\\n    return res;\\n};\\n```\\nWe can also do this in one pass:\\n```\\nvar fullJustify = function(words, maxWidth) {\\n    for (let res = [[]], i = 0, letters = 0; i <= words.length; letters += words[i++].length) {\\n        let row = res[res.length - 1];\\n        if (i === words.length || row.length && letters + row.length + words[i].length > maxWidth) {\\n            if (row.length === 1 || i === words.length) {\\n                res[res.length - 1] = row.join(' ') + ' '.repeat(maxWidth - letters - row.length + 1);\\n                if (i === words.length) return res;\\n            } else {\\n                let line = row[0];\\n                let spaces = maxWidth - letters;\\n                let minSpaces = ' '.repeat(Math.floor(spaces / (row.length - 1)));\\n                let addSpace = spaces % (row.length - 1);\\n                for (let w = 1; w < row.length; w++) {\\n                    line += minSpaces + (w <= addSpace ? ' ' : '') + row[w];\\n                }\\n                res[res.length - 1] = line;\\n            }\\n            res.push([]);\\n            letters = 0;\\n        }\\n        res[res.length - 1].push(words[i]);\\n    }\\n};\\n```\\nI prefer the longer version, as there isn't any speed/space advantage either way.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [[]];\\n    res[0].letters = 0;\\n    for (let word of words) {\\n        let row = res[res.length - 1];\\n        if (row.length && row.letters + row.length + word.length > maxWidth) {\\n            res.push([]);\\n            row = res[res.length - 1];\\n            row.letters = 0;\\n        }\\n        row.push(word);\\n        row.letters += word.length;\\n    }\\n    for (let r = 0; r < res.length; r++) {\\n        let row = res[r];\\n        if (row.length === 1 || r === res.length - 1) {\\n            res[r] = row.join(' ') + ' '.repeat(maxWidth - row.letters - row.length + 1);\\n            continue;\\n        }\\n        let line = row[0];\\n        let spaces = maxWidth - row.letters;\\n        let minSpaces = ' '.repeat(Math.floor(spaces / (row.length - 1)));\\n        let addSpace = spaces % (row.length - 1);\\n        for (let w = 1; w < row.length; w++) {\\n            line += minSpaces + (w <= addSpace ? ' ' : '') + row[w];\\n        }\\n        res[r] = line;\\n    }\\n    return res;\\n};\\n```\n```\\nvar fullJustify = function(words, maxWidth) {\\n    for (let res = [[]], i = 0, letters = 0; i <= words.length; letters += words[i++].length) {\\n        let row = res[res.length - 1];\\n        if (i === words.length || row.length && letters + row.length + words[i].length > maxWidth) {\\n            if (row.length === 1 || i === words.length) {\\n                res[res.length - 1] = row.join(' ') + ' '.repeat(maxWidth - letters - row.length + 1);\\n                if (i === words.length) return res;\\n            } else {\\n                let line = row[0];\\n                let spaces = maxWidth - letters;\\n                let minSpaces = ' '.repeat(Math.floor(spaces / (row.length - 1)));\\n                let addSpace = spaces % (row.length - 1);\\n                for (let w = 1; w < row.length; w++) {\\n                    line += minSpaces + (w <= addSpace ? ' ' : '') + row[w];\\n                }\\n                res[res.length - 1] = line;\\n            }\\n            res.push([]);\\n            letters = 0;\\n        }\\n        res[res.length - 1].push(words[i]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24962,
                "title": "15-line-python-solution-40ms",
                "content": "    def fullJustify(self, words, maxWidth):\\n        i, N, result = 0, len(words), []\\n        while i < N:\\n            # decide how many words to be put in one line\\n            oneLine, j, currWidth, positionNum, spaceNum = [words[i]], i + 1, len(words[i]), 0, maxWidth - len(words[i])\\n            while j < N and currWidth + 1 + len(words[j]) <= maxWidth:\\n                oneLine.append(words[j])\\n                currWidth += 1 + len(words[j])\\n                spaceNum -= len(words[j])\\n                positionNum, j = positionNum + 1, j + 1\\n            i = j\\n            # decide the layout of one line\\n            if i < N and positionNum:\\n                spaces = [' ' * (spaceNum / positionNum + (k < spaceNum % positionNum)) for k in range(positionNum)] + ['']\\n            else: # last line or the line only has one word\\n                spaces = [' '] * positionNum + [' ' * (maxWidth - currWidth)]\\n            result.append(''.join([s for pair in zip(oneLine, spaces) for s in pair]))\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def fullJustify(self, words, maxWidth):\\n        i, N, result = 0, len(words), []\\n        while i < N:\\n            # decide how many words to be put in one line\\n            oneLine, j, currWidth, positionNum, spaceNum = [words[i]], i + 1, len(words[i]), 0, maxWidth - len(words[i])\\n            while j < N and currWidth + 1 + len(words[j]) <= maxWidth:\\n                oneLine.append(words[j])\\n                currWidth += 1 + len(words[j])\\n                spaceNum -= len(words[j])\\n                positionNum, j = positionNum + 1, j + 1\\n            i = j\\n            # decide the layout of one line\\n            if i < N and positionNum:\\n                spaces = [' ' * (spaceNum / positionNum + (k < spaceNum % positionNum)) for k in range(positionNum)] + ['']\\n            else: # last line or the line only has one word\\n                spaces = [' '] * positionNum + [' ' * (maxWidth - currWidth)]\\n            result.append(''.join([s for pair in zip(oneLine, spaces) for s in pair]))\\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 3952295,
                "title": "ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nThe algorithm justifies a given list of words into lines with a specified maximum width. It iterates through the words, adding them to a line if they fit within the width limit, or starts a new line if not. After splitting the text into lines, it evenly distributes extra spaces among words to justify the lines, ensuring the last line is left-justified. The final justified lines are returned as a result.\\n\\n---\\n\\n\\n# Solution Video\\nUsually, I put a video to visualize solution but today I have to go on business trip and come back at late night. Please subscribe to my channel from URL below and don\\'t miss my latest solution videos in the future.\\n\\nI have 247 videos as of August 24th, 2023. Currently there are 2,071 subscribers.\\n\\n\\u25A0 Subscribe URL\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. **Initialization of Variables:**\\n   - Initialize an empty list `result` to store the final justified lines.\\n   - Initialize an empty list `line` to temporarily store words for the current line being processed.\\n   - Initialize an integer variable `line_length` to track the length of words in the current line.\\n\\n2. **Loop through Words:**\\n   - Loop through each word in the `words` list.\\n   - Check if adding the current `word` to the current line would exceed the `maxWidth` for the line.\\n   - If the addition doesn\\'t exceed, append the `word` to the `line` and update the `line_length` accordingly.\\n   - If the addition exceeds, append the current `line` to the `result`, start a new line with the current `word`, and update `line_length`.\\n\\n3. **Append Last Line:**\\n   - Append the last `line` to the `result`.\\n\\n4. **Initialization for Justified Lines:**\\n   - Initialize an empty list `justified_lines` to store the lines after justification.\\n\\n5. **Loop through Lines for Justification:**\\n   - Loop through each line in `result` except the last one (from 0 to `len(result) - 2`).\\n   - Get the current `line` from the `result`.\\n   - Calculate the total number of words in the `line` as `num_words`.\\n   - Calculate the total number of spaces available for justification as `num_spaces` by subtracting the sum of lengths of words in the line from `maxWidth`.\\n\\n6. **Handle Zero Space Gaps:**\\n   - Calculate the number of space gaps (`space_gaps`) by taking the maximum of `num_words - 1` and 1 (to ensure there\\'s at least one gap).\\n\\n7. **Calculate Spaces per Gap:**\\n   - Calculate the number of spaces per gap (`spaces_per_gap`) by performing integer division `num_spaces // space_gaps`.\\n\\n8. **Calculate Extra Spaces:**\\n   - Calculate the remaining extra spaces (`extra_spaces`) after distributing spaces evenly among gaps using modulo `num_spaces % space_gaps`.\\n\\n9. **Building Justified Line:**\\n   - Initialize an empty string `justified_line` to build the justified line.\\n   - Iterate through each `word` in the `line`.\\n   - Concatenate the `word` to the `justified_line`.\\n   - Check if there are more spaces to distribute (`space_gaps > 0`).\\n   - If yes, calculate the number of spaces to add (`spaces_to_add`) by adding `spaces_per_gap` and an extra space if `extra_spaces` is greater than 0.\\n   - Concatenate the calculated number of spaces to the `justified_line`.\\n   - Decrement `extra_spaces` and `space_gaps`.\\n\\n10. **Append Justified Line:**\\n    - Append the `justified_line` to the `justified_lines` list.\\n\\n11. **Construct the Last Line:**\\n    - Join the words in the last `result` line with a single space to form the `last_line`.\\n    - Add the required number of spaces at the end to make the total length `maxWidth`.\\n\\n12. **Append Last Line to Justified Lines:**\\n    - Append the `last_line` to the `justified_lines` list.\\n\\n13. **Return Justified Lines:**\\n    - Return the list of `justified_lines`.\\n\\n```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []  # To store the final justified lines\\n        line = []    # To temporarily store words for current line\\n        line_length = 0  # To track the length of the words in the current line\\n        \\n        # Loop through each word in the input words list\\n        for word in words:\\n            # Check if adding the current word exceeds the maxWidth for the line\\n            if line_length + len(line) + len(word) <= maxWidth:\\n                line.append(word)  # Add the word to the line\\n                line_length += len(word)  # Update the line length\\n            else:\\n                result.append(line)  # Add the words in the line to the result\\n                line = [word]  # Start a new line with the current word\\n                line_length = len(word)  # Set the line length to the word\\'s length\\n        \\n        result.append(line)  # Append the last line to the result\\n        \\n        justified_lines = []\\n        \\n        # Loop through each line except the last one\\n        for i in range(len(result) - 1):\\n            line = result[i]\\n            num_words = len(line)\\n            num_spaces = maxWidth - sum(len(word) for word in line)\\n            \\n            # Handle the case when space_gaps is zero\\n            space_gaps = max(num_words - 1, 1)\\n            \\n            spaces_per_gap = num_spaces // space_gaps\\n            extra_spaces = num_spaces % space_gaps\\n\\n            justified_line = \"\"\\n            \\n            # Iterate through each word in the line\\n            for word in line:\\n                justified_line += word\\n                \\n                # Check if there are more spaces to distribute\\n                if space_gaps > 0:\\n                    spaces_to_add = spaces_per_gap + (1 if extra_spaces > 0 else 0)\\n                    justified_line += \" \" * spaces_to_add\\n                    extra_spaces -= 1\\n                    space_gaps -= 1\\n\\n            justified_lines.append(justified_line)\\n\\n        last_line = \" \".join(result[-1])\\n        last_line += \" \" * (maxWidth - len(last_line))\\n        justified_lines.append(last_line)\\n\\n        return justified_lines\\n```\\n```javascript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const result = [];\\n    let line = [];\\n    let lineLength = 0;\\n\\n    for (const word of words) {\\n        if (lineLength + line.length + word.length <= maxWidth) {\\n            line.push(word);\\n            lineLength += word.length;\\n        } else {\\n            result.push(line);\\n            line = [word];\\n            lineLength = word.length;\\n        }\\n    }\\n\\n    result.push(line);\\n\\n    const justifiedLines = [];\\n    for (let i = 0; i < result.length - 1; i++) {\\n        line = result[i];\\n        const numWords = line.length;\\n        const numSpaces = maxWidth - line.reduce((acc, word) => acc + word.length, 0);\\n\\n        let spaceGaps = Math.max(numWords - 1, 1);\\n        const spacesPerGap = Math.floor(numSpaces / spaceGaps);\\n        let extraSpaces = numSpaces % spaceGaps;\\n\\n        let justifiedLine = \"\";\\n        for (const word of line) {\\n            justifiedLine += word;\\n\\n            if (spaceGaps > 0) {\\n                const spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                justifiedLine += \" \".repeat(spacesToAdd);\\n                extraSpaces -= 1;\\n                spaceGaps -= 1;\\n            }\\n        }\\n\\n        justifiedLines.push(justifiedLine);\\n    }\\n\\n    const lastLine = result[result.length - 1].join(\" \");\\n    justifiedLines.push(lastLine + \" \".repeat(maxWidth - lastLine.length));\\n\\n    return justifiedLines;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<List<String>> result = new ArrayList<>();\\n        List<String> line = new ArrayList<>();\\n        int lineLength = 0;\\n\\n        for (String word : words) {\\n            if (lineLength + line.size() + word.length() <= maxWidth) {\\n                line.add(word);\\n                lineLength += word.length();\\n            } else {\\n                result.add(line);\\n                line = new ArrayList<>();\\n                line.add(word);\\n                lineLength = word.length();\\n            }\\n        }\\n\\n        result.add(line);\\n\\n        List<String> justifiedLines = new ArrayList<>();\\n        for (int i = 0; i < result.size() - 1; i++) {\\n            line = result.get(i);\\n            int numWords = line.size();\\n            int numSpaces = maxWidth - line.stream().mapToInt(String::length).sum();\\n\\n            int spaceGaps = Math.max(numWords - 1, 1);\\n            int spacesPerGap = numSpaces / spaceGaps;\\n            int extraSpaces = numSpaces % spaceGaps;\\n\\n            StringBuilder justifiedLine = new StringBuilder();\\n            for (String word : line) {\\n                justifiedLine.append(word);\\n\\n                if (spaceGaps > 0) {\\n                    int spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                    justifiedLine.append(\" \".repeat(spacesToAdd));\\n                    extraSpaces -= 1;\\n                    spaceGaps -= 1;\\n                }\\n            }\\n\\n            justifiedLines.add(justifiedLine.toString());\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder(String.join(\" \", result.get(result.size() - 1)));\\n        lastLine.append(\" \".repeat(maxWidth - lastLine.length()));\\n        justifiedLines.add(lastLine.toString());\\n\\n        return justifiedLines;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        std::vector<std::vector<std::string>> result;\\n        std::vector<std::string> line;\\n        int lineLength = 0;\\n\\n        for (const std::string& word : words) {\\n            if (lineLength + line.size() + word.length() <= maxWidth) {\\n                line.push_back(word);\\n                lineLength += word.length();\\n            } else {\\n                result.push_back(line);\\n                line.clear();\\n                line.push_back(word);\\n                lineLength = word.length();\\n            }\\n        }\\n\\n        result.push_back(line);\\n\\n        std::vector<std::string> justifiedLines;\\n        for (int i = 0; i < result.size() - 1; i++) {\\n            line = result[i];\\n            int numWords = line.size();\\n            int numSpaces = maxWidth;\\n            for (const std::string& word : line) {\\n                numSpaces -= word.length();\\n            }\\n\\n            int spaceGaps = std::max(numWords - 1, 1);\\n            int spacesPerGap = numSpaces / spaceGaps;\\n            int extraSpaces = numSpaces % spaceGaps;\\n\\n            std::string justifiedLine = \"\";\\n            for (const std::string& word : line) {\\n                justifiedLine += word;\\n\\n                if (spaceGaps > 0) {\\n                    int spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                    justifiedLine += std::string(spacesToAdd, \\' \\');\\n                    extraSpaces -= 1;\\n                    spaceGaps -= 1;\\n                }\\n            }\\n\\n            justifiedLines.push_back(justifiedLine);\\n        }\\n\\n        std::string lastLine = \"\";\\n        for (const std::string& word : result[result.size() - 1]) {\\n            lastLine += word + \" \";\\n        }\\n        lastLine.pop_back();\\n        lastLine += std::string(maxWidth - lastLine.length(), \\' \\');\\n        justifiedLines.push_back(lastLine);\\n\\n        return justifiedLines;      \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []  # To store the final justified lines\\n        line = []    # To temporarily store words for current line\\n        line_length = 0  # To track the length of the words in the current line\\n        \\n        # Loop through each word in the input words list\\n        for word in words:\\n            # Check if adding the current word exceeds the maxWidth for the line\\n            if line_length + len(line) + len(word) <= maxWidth:\\n                line.append(word)  # Add the word to the line\\n                line_length += len(word)  # Update the line length\\n            else:\\n                result.append(line)  # Add the words in the line to the result\\n                line = [word]  # Start a new line with the current word\\n                line_length = len(word)  # Set the line length to the word\\'s length\\n        \\n        result.append(line)  # Append the last line to the result\\n        \\n        justified_lines = []\\n        \\n        # Loop through each line except the last one\\n        for i in range(len(result) - 1):\\n            line = result[i]\\n            num_words = len(line)\\n            num_spaces = maxWidth - sum(len(word) for word in line)\\n            \\n            # Handle the case when space_gaps is zero\\n            space_gaps = max(num_words - 1, 1)\\n            \\n            spaces_per_gap = num_spaces // space_gaps\\n            extra_spaces = num_spaces % space_gaps\\n\\n            justified_line = \"\"\\n            \\n            # Iterate through each word in the line\\n            for word in line:\\n                justified_line += word\\n                \\n                # Check if there are more spaces to distribute\\n                if space_gaps > 0:\\n                    spaces_to_add = spaces_per_gap + (1 if extra_spaces > 0 else 0)\\n                    justified_line += \" \" * spaces_to_add\\n                    extra_spaces -= 1\\n                    space_gaps -= 1\\n\\n            justified_lines.append(justified_line)\\n\\n        last_line = \" \".join(result[-1])\\n        last_line += \" \" * (maxWidth - len(last_line))\\n        justified_lines.append(last_line)\\n\\n        return justified_lines\\n```\n```javascript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const result = [];\\n    let line = [];\\n    let lineLength = 0;\\n\\n    for (const word of words) {\\n        if (lineLength + line.length + word.length <= maxWidth) {\\n            line.push(word);\\n            lineLength += word.length;\\n        } else {\\n            result.push(line);\\n            line = [word];\\n            lineLength = word.length;\\n        }\\n    }\\n\\n    result.push(line);\\n\\n    const justifiedLines = [];\\n    for (let i = 0; i < result.length - 1; i++) {\\n        line = result[i];\\n        const numWords = line.length;\\n        const numSpaces = maxWidth - line.reduce((acc, word) => acc + word.length, 0);\\n\\n        let spaceGaps = Math.max(numWords - 1, 1);\\n        const spacesPerGap = Math.floor(numSpaces / spaceGaps);\\n        let extraSpaces = numSpaces % spaceGaps;\\n\\n        let justifiedLine = \"\";\\n        for (const word of line) {\\n            justifiedLine += word;\\n\\n            if (spaceGaps > 0) {\\n                const spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                justifiedLine += \" \".repeat(spacesToAdd);\\n                extraSpaces -= 1;\\n                spaceGaps -= 1;\\n            }\\n        }\\n\\n        justifiedLines.push(justifiedLine);\\n    }\\n\\n    const lastLine = result[result.length - 1].join(\" \");\\n    justifiedLines.push(lastLine + \" \".repeat(maxWidth - lastLine.length));\\n\\n    return justifiedLines;    \\n};\\n```\n```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<List<String>> result = new ArrayList<>();\\n        List<String> line = new ArrayList<>();\\n        int lineLength = 0;\\n\\n        for (String word : words) {\\n            if (lineLength + line.size() + word.length() <= maxWidth) {\\n                line.add(word);\\n                lineLength += word.length();\\n            } else {\\n                result.add(line);\\n                line = new ArrayList<>();\\n                line.add(word);\\n                lineLength = word.length();\\n            }\\n        }\\n\\n        result.add(line);\\n\\n        List<String> justifiedLines = new ArrayList<>();\\n        for (int i = 0; i < result.size() - 1; i++) {\\n            line = result.get(i);\\n            int numWords = line.size();\\n            int numSpaces = maxWidth - line.stream().mapToInt(String::length).sum();\\n\\n            int spaceGaps = Math.max(numWords - 1, 1);\\n            int spacesPerGap = numSpaces / spaceGaps;\\n            int extraSpaces = numSpaces % spaceGaps;\\n\\n            StringBuilder justifiedLine = new StringBuilder();\\n            for (String word : line) {\\n                justifiedLine.append(word);\\n\\n                if (spaceGaps > 0) {\\n                    int spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                    justifiedLine.append(\" \".repeat(spacesToAdd));\\n                    extraSpaces -= 1;\\n                    spaceGaps -= 1;\\n                }\\n            }\\n\\n            justifiedLines.add(justifiedLine.toString());\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder(String.join(\" \", result.get(result.size() - 1)));\\n        lastLine.append(\" \".repeat(maxWidth - lastLine.length()));\\n        justifiedLines.add(lastLine.toString());\\n\\n        return justifiedLines;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        std::vector<std::vector<std::string>> result;\\n        std::vector<std::string> line;\\n        int lineLength = 0;\\n\\n        for (const std::string& word : words) {\\n            if (lineLength + line.size() + word.length() <= maxWidth) {\\n                line.push_back(word);\\n                lineLength += word.length();\\n            } else {\\n                result.push_back(line);\\n                line.clear();\\n                line.push_back(word);\\n                lineLength = word.length();\\n            }\\n        }\\n\\n        result.push_back(line);\\n\\n        std::vector<std::string> justifiedLines;\\n        for (int i = 0; i < result.size() - 1; i++) {\\n            line = result[i];\\n            int numWords = line.size();\\n            int numSpaces = maxWidth;\\n            for (const std::string& word : line) {\\n                numSpaces -= word.length();\\n            }\\n\\n            int spaceGaps = std::max(numWords - 1, 1);\\n            int spacesPerGap = numSpaces / spaceGaps;\\n            int extraSpaces = numSpaces % spaceGaps;\\n\\n            std::string justifiedLine = \"\";\\n            for (const std::string& word : line) {\\n                justifiedLine += word;\\n\\n                if (spaceGaps > 0) {\\n                    int spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                    justifiedLine += std::string(spacesToAdd, \\' \\');\\n                    extraSpaces -= 1;\\n                    spaceGaps -= 1;\\n                }\\n            }\\n\\n            justifiedLines.push_back(justifiedLine);\\n        }\\n\\n        std::string lastLine = \"\";\\n        for (const std::string& word : result[result.size() - 1]) {\\n            lastLine += word + \" \";\\n        }\\n        lastLine.pop_back();\\n        lastLine += std::string(maxWidth - lastLine.length(), \\' \\');\\n        justifiedLines.push_back(lastLine);\\n\\n        return justifiedLines;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048424,
                "title": "short-python-code-with-explanation",
                "content": "If you like my code, please hit ^ button. \\uD83D\\uDE0A Good luck at the interview!\\n```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        # We\\'ll pop from words so reversing it first\\n        words = list(reversed(words))\\n        result = []\\n        \\n        while words:\\n            line = []\\n            \\n            # while the next word, wont be too much, I keep adding\\n            while words and len(\\'\\'.join(line)) + len(words[-1]) <= maxWidth:        \\n                line.append(words.pop() + \\' \\')\\n                \\n            # fixing the last word by removing extra space\\n            line[-1] = line[-1][:-1]\\n                \\n            # if last line or single word, I\\'ll just left justify the line\\n            if not words or len(line) == 1:\\n                result.append(\\'\\'.join(line).ljust(maxWidth))\\n                \\n            # otherwise, I\\'ll add spaces to all words except to last one\\n            # until we reach the desired maxWidth\\n            else:\\n                n = len(\\'\\'.join(line))\\n                while n < maxWidth:\\n                    for i in range(len(line) -1):\\n                        if n == maxWidth: break\\n                        line[i] += \\' \\'\\n                        n += 1\\n                        \\n                result.append(\\'\\'.join(line))\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        # We\\'ll pop from words so reversing it first\\n        words = list(reversed(words))\\n        result = []\\n        \\n        while words:\\n            line = []\\n            \\n            # while the next word, wont be too much, I keep adding\\n            while words and len(\\'\\'.join(line)) + len(words[-1]) <= maxWidth:        \\n                line.append(words.pop() + \\' \\')\\n                \\n            # fixing the last word by removing extra space\\n            line[-1] = line[-1][:-1]\\n                \\n            # if last line or single word, I\\'ll just left justify the line\\n            if not words or len(line) == 1:\\n                result.append(\\'\\'.join(line).ljust(maxWidth))\\n                \\n            # otherwise, I\\'ll add spaces to all words except to last one\\n            # until we reach the desired maxWidth\\n            else:\\n                n = len(\\'\\'.join(line))\\n                while n < maxWidth:\\n                    for i in range(len(line) -1):\\n                        if n == maxWidth: break\\n                        line[i] += \\' \\'\\n                        n += 1\\n                        \\n                result.append(\\'\\'.join(line))\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952704,
                "title": "100-fast-easy-greedy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**The key intuition behind this problem is to understand how to distribute the spaces between words in each line in order to achieve both left and right justification.**\\n\\nSee the code you will be easily understand.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int start = 0;\\n\\n        while (start <words.size()) {\\n            int end = start;\\n            int lineLength = words[end].length();\\n\\n            while (end + 1 < words.size() && lineLength + words[end + 1].length() + (end + 1 - start) <= maxWidth) {\\n                ++end;\\n                lineLength += words[end].length();\\n            }\\n\\n            string line = words[start];\\n            int numWords = end - start;\\n\\n            if (end == words.size() - 1 || numWords == 0) { // Left justify for last line or single word line\\n                for (int i = start + 1; i <= end; ++i) {\\n                    line += \" \" + words[i];\\n                }\\n                line += string(maxWidth - line.length(), \\' \\');\\n            } else {\\n                int totalSpaces = maxWidth - lineLength;\\n                int spacesBetweenWords = totalSpaces / numWords;\\n                int extraSpaces = totalSpaces % numWords;\\n\\n                for (int i = start + 1; i <= end; ++i) {\\n                    int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n                    line += string(spaces, \\' \\') + words[i];\\n                }\\n            }\\n\\n            result.push_back(line);\\n            start = end + 1;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```\\n# PLS UPVOTE IF HELPFUL.",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int start = 0;\\n\\n        while (start <words.size()) {\\n            int end = start;\\n            int lineLength = words[end].length();\\n\\n            while (end + 1 < words.size() && lineLength + words[end + 1].length() + (end + 1 - start) <= maxWidth) {\\n                ++end;\\n                lineLength += words[end].length();\\n            }\\n\\n            string line = words[start];\\n            int numWords = end - start;\\n\\n            if (end == words.size() - 1 || numWords == 0) { // Left justify for last line or single word line\\n                for (int i = start + 1; i <= end; ++i) {\\n                    line += \" \" + words[i];\\n                }\\n                line += string(maxWidth - line.length(), \\' \\');\\n            } else {\\n                int totalSpaces = maxWidth - lineLength;\\n                int spacesBetweenWords = totalSpaces / numWords;\\n                int extraSpaces = totalSpaces % numWords;\\n\\n                for (int i = start + 1; i <= end; ++i) {\\n                    int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n                    line += string(spaces, \\' \\') + words[i];\\n                }\\n            }\\n\\n            result.push_back(line);\\n            start = end + 1;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778961,
                "title": "easy-modulated-c-solution-100-faster-no-kidding-with-comments",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\n// function to find the length of the words in the temp vector used to storing answer of every row\\nint findLen(vector<string> s) {\\n    int cnt = 0;\\n    for(auto it: s) {\\n        cnt += it.length();\\n    }\\n    return cnt;\\n}\\n\\n// function used to make the string -> more than 1 string in 1 row\\nstring makeString(vector<string> s, int div, int rem) {\\n    string news = \"\";\\n    for(int i = 0; i < s.size(); i++) {\\n        news += s[i];\\n        if(i != s.size() - 1) {\\n            for(int j = 0; j < div; j++) news += \" \";\\n            if(rem > 0) {\\n                news += \" \";\\n                rem--;\\n            }\\n        }\\n    }\\n    return news;\\n}\\n\\n// function used to make the string -> 1 string in 1 row\\nstring makeStringOne(vector<string> temp, int maxWidth) {\\n    string s = \"\";\\n    for(int i = 0; i < temp.size(); i++) {\\n        s += temp[i];\\n        if(i != temp.size() - 1) s += \" \";\\n    }\\n    int left = maxWidth - s.length();\\n    while(left--) s += \" \";\\n    return s;\\n}\\n\\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int n = words.size();\\n    vector<string> ans;\\n    vector<string> temp;\\n    int left = maxWidth;\\n    bool isFirst = true;\\n    for(int i = 0; i < n; i++) {\\n        // we\\'re checking the length of every word, if the length of the word plus the one space needed before it(if it\\'s not the first word) is less than equal to the length left, then we add it else we add it to the next row.\\n        int wordLen = words[i].length();\\n        if(isFirst && wordLen <= left) {\\n            temp.push_back(words[i]);\\n            left -= wordLen;\\n            isFirst = false;\\n        } else if(!isFirst && wordLen + 1 <= left) {\\n            temp.push_back(words[i]);\\n            left -= (wordLen + 1);\\n        } else {\\n            string s = \"\";\\n            int totalLen = findLen(temp);\\n            int spacesLeft = maxWidth - totalLen;\\n            int wordCount = temp.size();\\n            // if there is one word in the vector we add it specially as the spaces would be different than the ones with more than 1 word in the vector.\\n            if(wordCount == 1) {\\n                s = makeStringOne(temp, maxWidth); \\n            } else {\\n                int div = 0, rem = 0;\\n                div = spacesLeft / (wordCount - 1);\\n                if(spacesLeft % (wordCount-1) != 0)\\n                rem = spacesLeft % (wordCount-1);\\n                s = makeString(temp, div, rem);\\n            }\\n            ans.push_back(s); \\n            temp.clear();\\n            left = maxWidth;\\n            isFirst = true;\\n            i--;\\n        }\\n    }\\n    if(temp.size() > 0) {\\n        string s = \"\";\\n        s = makeStringOne(temp, maxWidth);\\n        ans.push_back(s);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\n// function to find the length of the words in the temp vector used to storing answer of every row\\nint findLen(vector<string> s) {\\n    int cnt = 0;\\n    for(auto it: s) {\\n        cnt += it.length();\\n    }\\n    return cnt;\\n}\\n\\n// function used to make the string -> more than 1 string in 1 row\\nstring makeString(vector<string> s, int div, int rem) {\\n    string news = \"\";\\n    for(int i = 0; i < s.size(); i++) {\\n        news += s[i];\\n        if(i != s.size() - 1) {\\n            for(int j = 0; j < div; j++) news += \" \";\\n            if(rem > 0) {\\n                news += \" \";\\n                rem--;\\n            }\\n        }\\n    }\\n    return news;\\n}\\n\\n// function used to make the string -> 1 string in 1 row\\nstring makeStringOne(vector<string> temp, int maxWidth) {\\n    string s = \"\";\\n    for(int i = 0; i < temp.size(); i++) {\\n        s += temp[i];\\n        if(i != temp.size() - 1) s += \" \";\\n    }\\n    int left = maxWidth - s.length();\\n    while(left--) s += \" \";\\n    return s;\\n}\\n\\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int n = words.size();\\n    vector<string> ans;\\n    vector<string> temp;\\n    int left = maxWidth;\\n    bool isFirst = true;\\n    for(int i = 0; i < n; i++) {\\n        // we\\'re checking the length of every word, if the length of the word plus the one space needed before it(if it\\'s not the first word) is less than equal to the length left, then we add it else we add it to the next row.\\n        int wordLen = words[i].length();\\n        if(isFirst && wordLen <= left) {\\n            temp.push_back(words[i]);\\n            left -= wordLen;\\n            isFirst = false;\\n        } else if(!isFirst && wordLen + 1 <= left) {\\n            temp.push_back(words[i]);\\n            left -= (wordLen + 1);\\n        } else {\\n            string s = \"\";\\n            int totalLen = findLen(temp);\\n            int spacesLeft = maxWidth - totalLen;\\n            int wordCount = temp.size();\\n            // if there is one word in the vector we add it specially as the spaces would be different than the ones with more than 1 word in the vector.\\n            if(wordCount == 1) {\\n                s = makeStringOne(temp, maxWidth); \\n            } else {\\n                int div = 0, rem = 0;\\n                div = spacesLeft / (wordCount - 1);\\n                if(spacesLeft % (wordCount-1) != 0)\\n                rem = spacesLeft % (wordCount-1);\\n                s = makeString(temp, div, rem);\\n            }\\n            ans.push_back(s); \\n            temp.clear();\\n            left = maxWidth;\\n            isFirst = true;\\n            i--;\\n        }\\n    }\\n    if(temp.size() > 0) {\\n        string s = \"\";\\n        s = makeStringOne(temp, maxWidth);\\n        ans.push_back(s);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2082328,
                "title": "c-easy-to-understand-break-into-small-functions",
                "content": "May look a bit long but each function should be easy to understand\\n\\n```\\nclass Solution {\\nprivate:\\n    /*\\n    starts from words[index], try pack max number of words into a line\\n    return packed words in \"lineWords\"\\n    be aware \"index\" is passed as reference hence it will be changed for the entire solution\\n    */\\n    void packWords(const vector<string>& words, int maxWidth, int& index, vector<string>& lineWords) {\\n        while (index < words.size()) {\\n            int wordSize = words[index].size();\\n            if (wordSize > maxWidth) { // cant fit any more word\\n                break;\\n            }\\n            maxWidth -= words[index].size();\\n            --maxWidth; // count one space between words\\n            lineWords.push_back(words[index]);\\n            ++index; // point index to next available word\\n        }\\n    }\\n    \\n    /*\\n    justify words to left side for last line and for the line with only one word\\n    return justified result in \"line\"\\n    */\\n    void leftJustify(const vector<string>& words, int maxWidth, string& line) {\\n        for (int i = 0; i < words.size(); ++i) {\\n            line += words[i];\\n            if (i != words.size() - 1) { // append one space for each word, except last word\\n                line += \" \";\\n            }\\n        }\\n        \\n        // append spaces to fill up the line\\n        int extraSpaces = maxWidth - line.size();\\n        line.append(extraSpaces, \\' \\');\\n    }\\n    \\n    /*\\n    fully justify one line\\n    return justified result in \"line\"\\n    */\\n    void fullJustify(const vector<string>& words, int maxWidth, string& line) {\\n        if (words.size() == 1) { // for lines with only one word we should do left justify\\n            leftJustify(words, maxWidth, line);\\n            return;\\n        }\\n        \\n        int totalCharLen = 0;\\n        for (const auto& word : words) {\\n            totalCharLen += word.size();\\n        }\\n        \\n        int totalSpaces = maxWidth - totalCharLen;\\n        int spaceSize = totalSpaces / (words.size() - 1);\\n        int extraSpaces = totalSpaces % (words.size() - 1);\\n        for (int i = 0; i < words.size(); ++i) {\\n            line += words[i];\\n            if (i != words.size() - 1) { // append spaces for each word except last one\\n                line.append(spaceSize, \\' \\');\\n                if (extraSpaces > 0) {\\n                    line += \" \";\\n                    --extraSpaces;\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> output;\\n        string line = \"\";\\n        vector<string> lineWords; // words to fit into each line\\n        int index = 0;\\n        while (index < words.size()) { // loop through all words\\n            packWords(words, maxWidth, index, lineWords);\\n            if (index < words.size()) {\\n                fullJustify(lineWords, maxWidth, line);\\n            }\\n            else {\\n                leftJustify(lineWords, maxWidth, line);\\n            }\\n            output.push_back(line);\\n            \\n            // clear cache and start processing a new line\\n            line.clear();\\n            lineWords.clear();\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    /*\\n    starts from words[index], try pack max number of words into a line\\n    return packed words in \"lineWords\"\\n    be aware \"index\" is passed as reference hence it will be changed for the entire solution\\n    */\\n    void packWords(const vector<string>& words, int maxWidth, int& index, vector<string>& lineWords) {\\n        while (index < words.size()) {\\n            int wordSize = words[index].size();\\n            if (wordSize > maxWidth) { // cant fit any more word\\n                break;\\n            }\\n            maxWidth -= words[index].size();\\n            --maxWidth; // count one space between words\\n            lineWords.push_back(words[index]);\\n            ++index; // point index to next available word\\n        }\\n    }\\n    \\n    /*\\n    justify words to left side for last line and for the line with only one word\\n    return justified result in \"line\"\\n    */\\n    void leftJustify(const vector<string>& words, int maxWidth, string& line) {\\n        for (int i = 0; i < words.size(); ++i) {\\n            line += words[i];\\n            if (i != words.size() - 1) { // append one space for each word, except last word\\n                line += \" \";\\n            }\\n        }\\n        \\n        // append spaces to fill up the line\\n        int extraSpaces = maxWidth - line.size();\\n        line.append(extraSpaces, \\' \\');\\n    }\\n    \\n    /*\\n    fully justify one line\\n    return justified result in \"line\"\\n    */\\n    void fullJustify(const vector<string>& words, int maxWidth, string& line) {\\n        if (words.size() == 1) { // for lines with only one word we should do left justify\\n            leftJustify(words, maxWidth, line);\\n            return;\\n        }\\n        \\n        int totalCharLen = 0;\\n        for (const auto& word : words) {\\n            totalCharLen += word.size();\\n        }\\n        \\n        int totalSpaces = maxWidth - totalCharLen;\\n        int spaceSize = totalSpaces / (words.size() - 1);\\n        int extraSpaces = totalSpaces % (words.size() - 1);\\n        for (int i = 0; i < words.size(); ++i) {\\n            line += words[i];\\n            if (i != words.size() - 1) { // append spaces for each word except last one\\n                line.append(spaceSize, \\' \\');\\n                if (extraSpaces > 0) {\\n                    line += \" \";\\n                    --extraSpaces;\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> output;\\n        string line = \"\";\\n        vector<string> lineWords; // words to fit into each line\\n        int index = 0;\\n        while (index < words.size()) { // loop through all words\\n            packWords(words, maxWidth, index, lineWords);\\n            if (index < words.size()) {\\n                fullJustify(lineWords, maxWidth, line);\\n            }\\n            else {\\n                leftJustify(lineWords, maxWidth, line);\\n            }\\n            output.push_back(line);\\n            \\n            // clear cache and start processing a new line\\n            line.clear();\\n            lineWords.clear();\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915710,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\\n        var res: [String] = []\\n        var i = 0\\n        \\n        while i < words.count {\\n            var j = i\\n            var tmpLength = 0\\n            \\n            while j < words.count {\\n                tmpLength += words[j].count + ((j > i) ? 1 : 0)\\n                \\n                if tmpLength <= maxWidth { j += 1 } \\n                else {\\n                    res.append(stringWithWords(words, maxWidth, i, j))\\n                    break\\n                }\\n            }\\n            \\n            if j == words.count {\\n                res.append(stringWithWords(words, maxWidth, i, j))\\n            }\\n            i = j\\n        }\\n        \\n        return res\\n    }\\n\\n\\n    func stringWithWords(_ words: [String], _ maxWidth: Int, _ i: Int, _ j: Int) -> String {\\n        var length = 0\\n        var string = \"\"\\n        \\n        func space(_ n: Int) -> String {\\n            var string = \"\"\\n            for _ in 0..<n { string += \" \" }\\n            return string\\n        }\\n        \\n        func space(_ index: Int, _ count: Int, _ length: Int, _ maxWidth: Int, _ isLast: Bool) -> String {\\n            if isLast { return index == count - 1 ? space(maxWidth - length - count + 1) : \" \" }\\n            if count == 1 { return space(maxWidth - length) }\\n            if index == count - 1 { return \"\" }\\n            return space((maxWidth - length) / (count - 1)) + (index < ((maxWidth - length) % (count - 1)) ? \" \" : \"\")\\n        }\\n\\n        for k in i..<j { length += words[k].count }\\n        \\n        for k in i..<j {\\n            string += words[k] + space(k - i, j - i, length, maxWidth, j == words.count)\\n        }\\n        \\n        return string\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\\n        var res: [String] = []\\n        var i = 0\\n        \\n        while i < words.count {\\n            var j = i\\n            var tmpLength = 0\\n            \\n            while j < words.count {\\n                tmpLength += words[j].count + ((j > i) ? 1 : 0)\\n                \\n                if tmpLength <= maxWidth { j += 1 } \\n                else {\\n                    res.append(stringWithWords(words, maxWidth, i, j))\\n                    break\\n                }\\n            }\\n            \\n            if j == words.count {\\n                res.append(stringWithWords(words, maxWidth, i, j))\\n            }\\n            i = j\\n        }\\n        \\n        return res\\n    }\\n\\n\\n    func stringWithWords(_ words: [String], _ maxWidth: Int, _ i: Int, _ j: Int) -> String {\\n        var length = 0\\n        var string = \"\"\\n        \\n        func space(_ n: Int) -> String {\\n            var string = \"\"\\n            for _ in 0..<n { string += \" \" }\\n            return string\\n        }\\n        \\n        func space(_ index: Int, _ count: Int, _ length: Int, _ maxWidth: Int, _ isLast: Bool) -> String {\\n            if isLast { return index == count - 1 ? space(maxWidth - length - count + 1) : \" \" }\\n            if count == 1 { return space(maxWidth - length) }\\n            if index == count - 1 { return \"\" }\\n            return space((maxWidth - length) / (count - 1)) + (index < ((maxWidth - length) % (count - 1)) ? \" \" : \"\")\\n        }\\n\\n        for k in i..<j { length += words[k].count }\\n        \\n        for k in i..<j {\\n            string += words[k] + space(k - i, j - i, length, maxWidth, j == words.count)\\n        }\\n        \\n        return string\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954308,
                "title": "100-faster-c-solution-beginner-friendly-two-pointer",
                "content": "# Do upvote, if it helped :)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##### The idea here is to see how many words can be added to a line with only one space between the words, and then adding the required padding to the sentences, if needed. And left justify the last line of the paragraph.\\n\\n__Its is easy to understand that__ `n` __words on a line with require__`n-1`__space, at least. Now, if we have `k` words on a line and__ `maxWidth` __as__ `mw`__. Then the extra space available to us will be__ `mw` - `length of all words combine`, __say__ `extra space`.\\nNow This extra space has to be even distributed among the k words, i.e. in `k-1` spaces between the words.__\\n\\n__One more thing to note here is that if only one word can be accomodated in the line, then we just have to fill the rest of the line with spaces,__ `extra space`__.__\\n\\n##### Lets take an Example :\\n`Words: {\"This\",\"is\",\"my\",\"house\"}`, `maxWidth` __= 34\\nNow in order to check how many words can be placed in one line, we can traverse the entire array of words, and we can keep adding the words to a line till the following condition is satisfied:__ \\n\\n`curr_length of words` + `number of words - 1` <= `maxWidth`\\n\\n `number of words - 1` : This is used because we will be putting atleast one space between the words on the same line.\\n\\n__Once the we know the number of words, we can get the minimum spaces that has to be put between the words, For our example__\\n`Length of all words` = 13, `number of words` = 4;\\n__therefore, by the condition mentioned before, all the words can be placed in one line.__\\n`extra space` = `maxWidth` - `length of all words combined`\\n`extra space` = 35 - 13 = 22\\n__So 22 spaces are to filled in 3 blanks, between 4 words__\\npadding : Minimum spaces to be filled in between gaps to reach maxWidth\\n__`padding` = `extra space`/ `number of words - 1` = 22/3 = 7__\\n__We still have 1 space left, that needs to be adjusted, \\nconsider ut as `extra padding`, that is given by \\n`extra space` % `number of words - 1`__\\n__This means 1 extra space will be added to first `x` pairs,__\\n`x` = `extra padding`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n__We will be using a two pointer approach to add the words from the starting index to the ending index. To do this create two variables:\\n `start`: To track the index of the first word of the current line \\n`end` : To track the index of last word of the current line\\n`curr_len` : To store the current length of the sentence__\\n\\n\\n>## Traverse the array of words\\n> `wd` = `end - start + 1` __gives the number of words in the current line__\\n   `curr_len` = `length of the words in the line` + `wd`\\n__adding wd accounts for the minimum number of spaces between each pair of words(i.e. 1).__\\n>### If `curr_len`  + `size of the current word` <= `maxWidth`\\n>> __Add the size of current word to `curr_len`, and incresae the word count, by increasing `end` = `end + 1`__\\n> \\n> ### Else\\n>> __It\\'s time to fix the current line / sentence and move on to the next one__\\n>> __Start the `sentence` as the word at index `start`\\nCalculate the `extra_space` = `maxWidth` - `curr_len`\\n`padding` = `extra_space` / `max(1 , wd - 1)`\\n`extra` = `extra_space` % `max(1 , wd - 1)`__\\n>> ###### __Padding adding is the minimum space that will be added between each pair of words, even distribution__\\n>> ###### __Extra is the uneven distribution of space required to reach the `maxWidth` length__\\n>> __Traverse from index `start + 1` to `end`__\\n>>>__Add the padding to the `sentence`\\nAdd the extra padding\\nAdd the `curr_word`\\nIF there is only one word__\\n>>>> __Fill the rest of the line with space__\\n>>>\\n>>> __Add the `sentence` to the `ans` vector\\nSet :\\n`start` as `end + 1`, \\n`curr_len` = `curr_word.size()`, \\n`end` = `end + 1`__\\n>>\\n> #### __Once the Loop is exited, we are left with the last line, that is to be left-justified__\\n>__Start the `sentence` as the word at index `start`\\nTraverse from index `start + 1` to `end`__\\n>>__Add a space to the `sentence`\\nAdd the `curr_word`__\\n>\\n>__Fill the rest of the line with spaces\\nAdd the `sentence` to the `ans` vector\\nReturn the answer vector `ans`__\\n\\n# Complexity\\n- Time complexity: $$O(n*k*padding)$$ \\n   n = number of words\\n   k = max number of words that can be added in a line\\n   padding = minimum space between a pair of words\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/68402346-1a9f-44f3-847d-4f00250e0d6d_1692880996.3664916.png)\\n\\n\\n# Code\\n``` cpp []\\nclass Solution // 100% faster\\n{\\npublic:\\n    vector<string> fullJustify(vector<string> &words, int maxWidth)\\n    {\\n        // Vector to store the sentences\\n        vector<string> ans;\\n        int curr_len = 0, start = 0, end = -1;\\n        for (string s : words)\\n        {\\n            if ((end - start + 1) + curr_len + s.size() <= maxWidth)\\n                curr_len += s.size(), end++;\\n            else\\n            {\\n                // Start the current line as the word at index start\\n                string sentence = words[start];\\n                int extra_space = maxWidth - curr_len, padding = extra_space / max(1, end - start);\\n                // extra is the extra space that has to be adjusted so as to make the length equal to maxWidth\\n                int extra = extra_space % max(1, end - start);\\n                // Now add the words from \\'start index + 1\\' to \\'end index\\'\\n                for (int i = start + 1; i <= end; i++)\\n                {\\n                    // Add the padding first\\n                    for (int j = 0; j < padding; j++)\\n                        sentence += \" \";\\n                    // Add the xtra padding, if needed\\n                    if (extra)\\n                        sentence += \" \", extra--;\\n                    sentence += words[i];\\n                }\\n                // Just in case the sentence has only one word\\n                while (sentence.size() < maxWidth)\\n                    sentence += \" \";\\n                ans.push_back(sentence);\\n                // Set the current word as the starting point of the new line\\n                start = end + 1, curr_len = s.size(), end++;\\n            }\\n        }\\n        // Last line has to be dealt with a bit differently, i.e. left justified\\n        string sentence = words[start];\\n        for (int i = start + 1; i <= end; i++)\\n            sentence += \" \" + words[i];\\n        while (sentence.size() < maxWidth)\\n            sentence += \" \";\\n        ans.push_back(sentence);\\n        return ans;\\n    }\\n};\\n```\\n![upvote.png](https://assets.leetcode.com/users/images/864f254a-ae64-4983-937e-f741badbc63b_1692881287.4776943.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "``` cpp []\\nclass Solution // 100% faster\\n{\\npublic:\\n    vector<string> fullJustify(vector<string> &words, int maxWidth)\\n    {\\n        // Vector to store the sentences\\n        vector<string> ans;\\n        int curr_len = 0, start = 0, end = -1;\\n        for (string s : words)\\n        {\\n            if ((end - start + 1) + curr_len + s.size() <= maxWidth)\\n                curr_len += s.size(), end++;\\n            else\\n            {\\n                // Start the current line as the word at index start\\n                string sentence = words[start];\\n                int extra_space = maxWidth - curr_len, padding = extra_space / max(1, end - start);\\n                // extra is the extra space that has to be adjusted so as to make the length equal to maxWidth\\n                int extra = extra_space % max(1, end - start);\\n                // Now add the words from \\'start index + 1\\' to \\'end index\\'\\n                for (int i = start + 1; i <= end; i++)\\n                {\\n                    // Add the padding first\\n                    for (int j = 0; j < padding; j++)\\n                        sentence += \" \";\\n                    // Add the xtra padding, if needed\\n                    if (extra)\\n                        sentence += \" \", extra--;\\n                    sentence += words[i];\\n                }\\n                // Just in case the sentence has only one word\\n                while (sentence.size() < maxWidth)\\n                    sentence += \" \";\\n                ans.push_back(sentence);\\n                // Set the current word as the starting point of the new line\\n                start = end + 1, curr_len = s.size(), end++;\\n            }\\n        }\\n        // Last line has to be dealt with a bit differently, i.e. left justified\\n        string sentence = words[start];\\n        for (int i = start + 1; i <= end; i++)\\n            sentence += \" \" + words[i];\\n        while (sentence.size() < maxWidth)\\n            sentence += \" \";\\n        ans.push_back(sentence);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952302,
                "title": "python-java-c-simple-solution",
                "content": "# ANNOUNCEMENT:\\n**Join the discord and don\\'t forget to Subscribe the youtube channel to access the premium content materials related to computer science and data science in the discord. (For Only first 10,000 Subscribers)**\\n\\n**Happy Learning,  Cheers Guys \\uD83D\\uDE0A**\\n\\n# Click the Link in my Profile to Subscribe\\n\\n# An UPVOTE will be encouraging \\uD83D\\uDC4D\\n\\n#Intuition\\n\\n- Initialize an empty result list to store the justified lines, an empty current line (cur), and a variable to keep track of the total number of letters in the current line (numOfLetters).\\n\\n- Iterate through the list of words one by one.\\n\\nFor each word:\\n\\n- Check if adding the word to the current line would exceed the maximum width. If it would, it\\'s time to justify the current line.\\n- Calculate the number of spaces that need to be added to distribute them evenly. This is done by finding the difference between the maximum width and the total number of letters in the current line.\\n- Distribute these spaces evenly among the words in the current line. The modulo operator is used to ensure that spaces are distributed evenly, even if there are more words than spaces.\\n- Add the justified line to the result list.\\n- Clear the current line and reset the numOfLetters counter.\\n- Continue adding words to the current line until you reach a point where adding the next word would exceed the maximum width.\\n\\n- For the last line of text, left-justify it by adding spaces between words. Ensure that the total width of the line matches the maximum width.\\n\\n- Return the list of justified lines as the final result.\\n\\n```Python []\\nclass Solution:\\n    def fullJustify(self, words, maxWidth):\\n        result, cur, num_of_letters = [], [], 0\\n\\n        for word in words:\\n            if num_of_letters + len(word) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i % (len(cur) - 1 or 1)] += \\' \\'\\n                result.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n\\n            cur += [word]\\n            num_of_letters += len(word)\\n\\n        return result + [\\' \\'.join(cur).ljust(maxWidth)]\\n```\\n```Java []\\n\\npublic class TextJustification {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        int numOfLetters = 0;\\n\\n        for (String word : words) {\\n            if (numOfLetters + word.length() + cur.size() > maxWidth) {\\n                int spacesToAdd = maxWidth - numOfLetters;\\n                for (int i = 0; i < spacesToAdd; i++) {\\n                    cur.set(i % (cur.size() - 1), cur.get(i % (cur.size() - 1)) + \" \");\\n                }\\n                result.add(String.join(\"\", cur));\\n                cur.clear();\\n                numOfLetters = 0;\\n            }\\n\\n            cur.add(word);\\n            numOfLetters += word.length();\\n        }\\n\\n        result.add(String.join(\" \", cur) + \" \".repeat(maxWidth - numOfLetters - cur.size() + 1));\\n\\n        return result;\\n    }\\n}\\n\\n```\\n```C++ []\\n\\nclass TextJustification {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        vector<string> cur;\\n        int numOfLetters = 0;\\n\\n        for (const string& word : words) {\\n            if (numOfLetters + word.length() + cur.size() > maxWidth) {\\n                int spacesToAdd = maxWidth - numOfLetters;\\n                for (int i = 0; i < spacesToAdd; i++) {\\n                    cur[i % (cur.size() - 1)] += \\' \\';\\n                }\\n                result.push_back(accumulate(cur.begin(), cur.end(), string(\"\")));\\n                cur.clear();\\n                numOfLetters = 0;\\n            }\\n\\n            cur.push_back(word);\\n            numOfLetters += word.length();\\n        }\\n\\n        string lastLine = accumulate(cur.begin(), cur.end(), string(\" \"));\\n        lastLine += string(maxWidth - numOfLetters - cur.size() + 1, \\' \\');\\n        result.push_back(lastLine);\\n\\n        return result;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```Python []\\nclass Solution:\\n    def fullJustify(self, words, maxWidth):\\n        result, cur, num_of_letters = [], [], 0\\n\\n        for word in words:\\n            if num_of_letters + len(word) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i % (len(cur) - 1 or 1)] += \\' \\'\\n                result.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n\\n            cur += [word]\\n            num_of_letters += len(word)\\n\\n        return result + [\\' \\'.join(cur).ljust(maxWidth)]\\n```\n```Java []\\n\\npublic class TextJustification {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        int numOfLetters = 0;\\n\\n        for (String word : words) {\\n            if (numOfLetters + word.length() + cur.size() > maxWidth) {\\n                int spacesToAdd = maxWidth - numOfLetters;\\n                for (int i = 0; i < spacesToAdd; i++) {\\n                    cur.set(i % (cur.size() - 1), cur.get(i % (cur.size() - 1)) + \" \");\\n                }\\n                result.add(String.join(\"\", cur));\\n                cur.clear();\\n                numOfLetters = 0;\\n            }\\n\\n            cur.add(word);\\n            numOfLetters += word.length();\\n        }\\n\\n        result.add(String.join(\" \", cur) + \" \".repeat(maxWidth - numOfLetters - cur.size() + 1));\\n\\n        return result;\\n    }\\n}\\n\\n```\n```C++ []\\n\\nclass TextJustification {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        vector<string> cur;\\n        int numOfLetters = 0;\\n\\n        for (const string& word : words) {\\n            if (numOfLetters + word.length() + cur.size() > maxWidth) {\\n                int spacesToAdd = maxWidth - numOfLetters;\\n                for (int i = 0; i < spacesToAdd; i++) {\\n                    cur[i % (cur.size() - 1)] += \\' \\';\\n                }\\n                result.push_back(accumulate(cur.begin(), cur.end(), string(\"\")));\\n                cur.clear();\\n                numOfLetters = 0;\\n            }\\n\\n            cur.push_back(word);\\n            numOfLetters += word.length();\\n        }\\n\\n        string lastLine = accumulate(cur.begin(), cur.end(), string(\" \"));\\n        lastLine += string(maxWidth - numOfLetters - cur.size() + 1, \\' \\');\\n        result.push_back(lastLine);\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300817,
                "title": "java-solution-with-comments-beats-100",
                "content": "```\\npublic List<String> fullJustify(String[] words, int maxLen) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> tempList = new ArrayList<>();  //to store the words that can be put in one same line\\n        int tempLen = 0;     // track the length of current line: wordsLen + spaces between words\\n        int index = 0;      //index of word in words array\\n        int wordsLen = 0;   // sum of all words that can be put in same line\\n        int spaces = 0;     // sapces that need to be filled\\n        \\n        while(index < words.length) {\\n            if((tempLen + words[index].length()) <= maxLen) {   //check if cur word can be put in cur line\\n                tempLen += words[index].length() + 1;\\n                tempList.add(words[index++]);\\n            }else {\\n                StringBuilder sb = new StringBuilder();\\n                wordsLen = tempLen - tempList.size();\\n                spaces = maxLen - wordsLen;\\n                if(tempList.size() == 1) {          // there\\'s only one word at cur line, then just fill the spaces\\n                    sb.append(tempList.get(0));\\n                    for(int i = 0; i < spaces; i++) {\\n                        sb.append(\" \");\\n                    }\\n                    ans.add(sb.toString());\\n                }else if(tempList.size() > 1){      // there\\'s many words in cur line, do the evenly spaceing\\n                    int distance = spaces / (tempList.size() - 1);\\n                    int reminder = spaces % (tempList.size() - 1);\\n                    \\n                    for(int i = 0; i < tempList.size() - 1; i++) {\\n                        sb.append(tempList.get(i));\\n                        if(reminder > 0){\\n                            sb.append(\" \");\\n                            reminder--;\\n                        }\\n                        for(int j = 0; j < distance; j++)\\n                            sb.append(\" \");\\n                    }\\n                    sb.append(tempList.get(tempList.size() - 1));\\n                    ans.add(sb.toString());   \\n                }\\n                tempList.clear();  \\n                tempLen = 0;\\n            }\\n        }\\n        \\n        // dealing with last line\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < tempList.size() - 1; i++) {\\n            sb.append(tempList.get(i));\\n            sb.append(\" \");\\n        }\\n        sb.append(tempList.get(tempList.size() - 1));\\n        for(int i = 0; i < maxLen - (tempLen - 1); i++)\\n                  sb.append(\" \");\\n        ans.add(sb.toString());\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> fullJustify(String[] words, int maxLen) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> tempList = new ArrayList<>();  //to store the words that can be put in one same line\\n        int tempLen = 0;     // track the length of current line: wordsLen + spaces between words\\n        int index = 0;      //index of word in words array\\n        int wordsLen = 0;   // sum of all words that can be put in same line\\n        int spaces = 0;     // sapces that need to be filled\\n        \\n        while(index < words.length) {\\n            if((tempLen + words[index].length()) <= maxLen) {   //check if cur word can be put in cur line\\n                tempLen += words[index].length() + 1;\\n                tempList.add(words[index++]);\\n            }else {\\n                StringBuilder sb = new StringBuilder();\\n                wordsLen = tempLen - tempList.size();\\n                spaces = maxLen - wordsLen;\\n                if(tempList.size() == 1) {          // there\\'s only one word at cur line, then just fill the spaces\\n                    sb.append(tempList.get(0));\\n                    for(int i = 0; i < spaces; i++) {\\n                        sb.append(\" \");\\n                    }\\n                    ans.add(sb.toString());\\n                }else if(tempList.size() > 1){      // there\\'s many words in cur line, do the evenly spaceing\\n                    int distance = spaces / (tempList.size() - 1);\\n                    int reminder = spaces % (tempList.size() - 1);\\n                    \\n                    for(int i = 0; i < tempList.size() - 1; i++) {\\n                        sb.append(tempList.get(i));\\n                        if(reminder > 0){\\n                            sb.append(\" \");\\n                            reminder--;\\n                        }\\n                        for(int j = 0; j < distance; j++)\\n                            sb.append(\" \");\\n                    }\\n                    sb.append(tempList.get(tempList.size() - 1));\\n                    ans.add(sb.toString());   \\n                }\\n                tempList.clear();  \\n                tempLen = 0;\\n            }\\n        }\\n        \\n        // dealing with last line\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < tempList.size() - 1; i++) {\\n            sb.append(tempList.get(i));\\n            sb.append(\" \");\\n        }\\n        sb.append(tempList.get(tempList.size() - 1));\\n        for(int i = 0; i < maxLen - (tempLen - 1); i++)\\n                  sb.append(\" \");\\n        ans.add(sb.toString());\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1297598,
                "title": "the-first-hard-level-question-i-ve-ever-solved",
                "content": "The function reorderSpaces is basically a updated version of an easy level problem on leetcode (https://leetcode.com/problems/rearrange-spaces-between-words/) , if you haven\\'t solved that yet just go through it once.\\n```\\nclass Solution:\\n    def reorderSpaces(self, text: str) -> str:\\n        spaces = text.count(\" \")\\n        s = text.split(\" \")\\n        \\n        while \"\" in s :\\n            s.remove(\"\")\\n            \\n        if len(s) == 1:\\n            return s[0] + \" \"*spaces\\n        \\n        #min no of spaces between each word\\n        nsw = spaces//(len(s)-1)\\n        #no. of spaces left \\n        nsl = spaces%(len(s)-1)\\n        result = \"\"\\n        for i in range(len(s)) :\\n            if i != len(s)-1 :\\n                result += s[i] + (\" \")*nsw\\n                if nsl > 0:\\n                    result += \" \"\\n                    nsl -= 1\\n            else:\\n                result += s[i]  \\n        return result\\n            \\n\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        result = []\\n        \\n        last = words.pop(0)\\n        while words:\\n            if len(last) + len(words[0])  >= maxWidth :\\n                t = last + (\" \")*(maxWidth-len(last))\\n                last = words.pop(0)\\n                result.append(t)\\n            \\n            elif len(last) + len(words[0]) < maxWidth :\\n                last = last + \" \" + words.pop(0)             \\n        result.append(last + (\" \")*(maxWidth-len(last)))\\n        \\n        for i in range(len(result)-1):\\n            result[i] = self.reorderSpaces(result[i])\\n            \\n            \\n        return result          \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reorderSpaces(self, text: str) -> str:\\n        spaces = text.count(\" \")\\n        s = text.split(\" \")\\n        \\n        while \"\" in s :\\n            s.remove(\"\")\\n            \\n        if len(s) == 1:\\n            return s[0] + \" \"*spaces\\n        \\n        #min no of spaces between each word\\n        nsw = spaces//(len(s)-1)\\n        #no. of spaces left \\n        nsl = spaces%(len(s)-1)\\n        result = \"\"\\n        for i in range(len(s)) :\\n            if i != len(s)-1 :\\n                result += s[i] + (\" \")*nsw\\n                if nsl > 0:\\n                    result += \" \"\\n                    nsl -= 1\\n            else:\\n                result += s[i]  \\n        return result\\n            \\n\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        result = []\\n        \\n        last = words.pop(0)\\n        while words:\\n            if len(last) + len(words[0])  >= maxWidth :\\n                t = last + (\" \")*(maxWidth-len(last))\\n                last = words.pop(0)\\n                result.append(t)\\n            \\n            elif len(last) + len(words[0]) < maxWidth :\\n                last = last + \" \" + words.pop(0)             \\n        result.append(last + (\" \")*(maxWidth-len(last)))\\n        \\n        for i in range(len(result)-1):\\n            result[i] = self.reorderSpaces(result[i])\\n            \\n            \\n        return result          \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065918,
                "title": "java-0ms-clean-code-with-fully-documentation",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        // the final justified list of lines to return.\\n        List<String> justified = new ArrayList();\\n       \\n        // a queue to store all the words of a current line.\\n        Queue<String> currentLine = new LinkedList();\\n        \\n        // efficiently build a new line with a string builder.\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // keep track of all the lengths of each word on the current line (to compare to maxWidth).\\n        int currentLineLen = 0;\\n        \\n        for(String word : words){\\n            \\n            // track both the current words length and the count of all the words in the current line \\n            // (this count represents the single space between each word so far)\\n            int n = word.length();\\n            int m = currentLine.size();\\n            \\n            // if all the words so far in the line, plus a single space between each of them, plus the current word length is \\n            // less than or equal to the max width of a line, then add the current word to the current line.\\n            if(currentLineLen + n + m <= maxWidth){\\n                currentLine.add(word);\\n                currentLineLen += n;\\n            \\n            // otherwise, render the current line with the correct spacing between each word and start a new line with the current word.\\n            }else{\\n                int extraSpace = maxWidth - currentLineLen;\\n                justified.add(getLine(extraSpace, currentLine, sb));\\n                \\n                currentLine.add(word);\\n                sb.setLength(0);\\n                currentLineLen = n;\\n            }\\n        }\\n        \\n        // if after looping through each word, there are still words left in the current line\\n        // then add them to the justified list of lines through a special final string.\\n        if(!currentLine.isEmpty()){\\n            int remainingSpace = maxWidth - (currentLineLen + currentLine.size() - 1);\\n            justified.add(generateLastLine(remainingSpace, currentLine, sb));\\n        }\\n        \\n        return justified;\\n    }\\n    \\n    /**\\n     * This method renders a standard line (not the final line) by taking the total amount of space\\n     * left in the line an distributing the space as equally as possible between the words of the, but \\n     * giving words on the left more space between them than words on the right if the remaining free space\\n     * cant be split equally between all the words.\\n    **/\\n    private String getLine(int extraSpace, Queue<String> currentLine, StringBuilder sb){\\n        \\n        int wordCount = currentLine.size() - 1;\\n        \\n        boolean singleWordLine = wordCount == 0;\\n        \\n        while(!currentLine.isEmpty()){\\n            sb.append(currentLine.poll());\\n\\n            if(!currentLine.isEmpty() || singleWordLine){\\n                \\n                int currentSpace = !singleWordLine ? extraSpace / wordCount : extraSpace;\\n                \\n                if(!singleWordLine && extraSpace % wordCount != 0)\\n                    currentSpace++;\\n                \\n                addEmptySpace(currentSpace, sb);\\n                \\n                extraSpace -= currentSpace;\\n                wordCount--;\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    /**\\n     * This method renders the final line by placing a single space in between each word and then adding\\n     * any remaing empty space to the end of the line.\\n    **/ \\n    private String generateLastLine(int remainingSpace, Queue<String> currentLine, StringBuilder sb){\\n         \\n        while(!currentLine.isEmpty()){\\n            sb.append(currentLine.poll());\\n            \\n            if(!currentLine.isEmpty())\\n                sb.append(\" \");\\n        }\\n        \\n        if(remainingSpace > 0)\\n            addEmptySpace(remainingSpace, sb);\\n        \\n        return sb.toString();\\n    }\\n    \\n    /**\\n     * This method will add the number of empty spaces to the current string builder to match a given length.\\n    **/\\n    private void addEmptySpace(int len, StringBuilder sb){\\n        for(int i = 0; i < len; i++)\\n            sb.append(\" \");\\n    }\\n}\\n```\\n\\nruntime: O(n)\\nspace O(n)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        // the final justified list of lines to return.\\n        List<String> justified = new ArrayList();\\n       \\n        // a queue to store all the words of a current line.\\n        Queue<String> currentLine = new LinkedList();\\n        \\n        // efficiently build a new line with a string builder.\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // keep track of all the lengths of each word on the current line (to compare to maxWidth).\\n        int currentLineLen = 0;\\n        \\n        for(String word : words){\\n            \\n            // track both the current words length and the count of all the words in the current line \\n            // (this count represents the single space between each word so far)\\n            int n = word.length();\\n            int m = currentLine.size();\\n            \\n            // if all the words so far in the line, plus a single space between each of them, plus the current word length is \\n            // less than or equal to the max width of a line, then add the current word to the current line.\\n            if(currentLineLen + n + m <= maxWidth){\\n                currentLine.add(word);\\n                currentLineLen += n;\\n            \\n            // otherwise, render the current line with the correct spacing between each word and start a new line with the current word.\\n            }else{\\n                int extraSpace = maxWidth - currentLineLen;\\n                justified.add(getLine(extraSpace, currentLine, sb));\\n                \\n                currentLine.add(word);\\n                sb.setLength(0);\\n                currentLineLen = n;\\n            }\\n        }\\n        \\n        // if after looping through each word, there are still words left in the current line\\n        // then add them to the justified list of lines through a special final string.\\n        if(!currentLine.isEmpty()){\\n            int remainingSpace = maxWidth - (currentLineLen + currentLine.size() - 1);\\n            justified.add(generateLastLine(remainingSpace, currentLine, sb));\\n        }\\n        \\n        return justified;\\n    }\\n    \\n    /**\\n     * This method renders a standard line (not the final line) by taking the total amount of space\\n     * left in the line an distributing the space as equally as possible between the words of the, but \\n     * giving words on the left more space between them than words on the right if the remaining free space\\n     * cant be split equally between all the words.\\n    **/\\n    private String getLine(int extraSpace, Queue<String> currentLine, StringBuilder sb){\\n        \\n        int wordCount = currentLine.size() - 1;\\n        \\n        boolean singleWordLine = wordCount == 0;\\n        \\n        while(!currentLine.isEmpty()){\\n            sb.append(currentLine.poll());\\n\\n            if(!currentLine.isEmpty() || singleWordLine){\\n                \\n                int currentSpace = !singleWordLine ? extraSpace / wordCount : extraSpace;\\n                \\n                if(!singleWordLine && extraSpace % wordCount != 0)\\n                    currentSpace++;\\n                \\n                addEmptySpace(currentSpace, sb);\\n                \\n                extraSpace -= currentSpace;\\n                wordCount--;\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    /**\\n     * This method renders the final line by placing a single space in between each word and then adding\\n     * any remaing empty space to the end of the line.\\n    **/ \\n    private String generateLastLine(int remainingSpace, Queue<String> currentLine, StringBuilder sb){\\n         \\n        while(!currentLine.isEmpty()){\\n            sb.append(currentLine.poll());\\n            \\n            if(!currentLine.isEmpty())\\n                sb.append(\" \");\\n        }\\n        \\n        if(remainingSpace > 0)\\n            addEmptySpace(remainingSpace, sb);\\n        \\n        return sb.toString();\\n    }\\n    \\n    /**\\n     * This method will add the number of empty spaces to the current string builder to match a given length.\\n    **/\\n    private void addEmptySpace(int len, StringBuilder sb){\\n        for(int i = 0; i < len; i++)\\n            sb.append(\" \");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24885,
                "title": "share-my-ac-easy-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string>res;\\n        if(maxWidth == 0) return {\"\"};\\n        int i = 0, j = 0;\\n        while(j != words.size()){\\n            int len = -1;\\n            while(j < words.size() && len + words[j].size() + 1 <= maxWidth)\\n                len += words[j++].size() + 1;\\n            int space = maxWidth - len + j - i - 1;\\n            int k = i;\\n            while(space){\\n                words[k++] += \" \";\\n                space--;\\n                if(j != words.size() && (k == j - 1 || k == j)) k = i;\\n                if(j == words.size() && k == j) k = j - 1;\\n            }\\n            string line = \"\";\\n            for(int l = i; l < j; l++)\\n                line += words[l];\\n            res.push_back(line);\\n            i = j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string>res;\\n        if(maxWidth == 0) return {\"\"};\\n        int i = 0, j = 0;\\n        while(j != words.size()){\\n            int len = -1;\\n            while(j < words.size() && len + words[j].size() + 1 <= maxWidth)\\n                len += words[j++].size() + 1;\\n            int space = maxWidth - len + j - i - 1;\\n            int k = i;\\n            while(space){\\n                words[k++] += \" \";\\n                space--;\\n                if(j != words.size() && (k == j - 1 || k == j)) k = i;\\n                if(j == words.size() && k == j) k = j - 1;\\n            }\\n            string line = \"\";\\n            for(int l = i; l < j; l++)\\n                line += words[l];\\n            res.push_back(line);\\n            i = j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24969,
                "title": "long-but-working-dp-java-solution",
                "content": "This is based on Roy Tushar's solution. See https://www.youtube.com/watch?v=RORuwHiblPc\\n\\n\\n\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {    \\t\\n        \\n        List<String> results = new LinkedList<>();   \\n        \\n        if(words == null) {\\n            return results;\\n        }        \\n        \\n        int[][] costsMatrix = createCostMatrix(words, maxWidth);\\n        \\n        int len = words.length;\\n        \\n        int[] minCosts = new int[len];\\n        int[] paths = new int[len];\\n        \\n        Arrays.fill(minCosts, Integer.MAX_VALUE);\\n        \\n        for(int i = len-1; i >= 0; i--) {\\n            \\n            minCosts[i] = costsMatrix[i][len-1];\\n            paths[i] = len;         \\n            \\n            for(int j = i+1; j < len; j++) {\\n                \\n                if(costsMatrix[i][j-1] != Integer.MAX_VALUE &&\\n                    minCosts[j] + costsMatrix[i][j-1] < minCosts[i]) {\\n                    \\n                    minCosts[i] = minCosts[j] + costsMatrix[i][j-1];\\n                    paths[i] = j;                            \\n                }\\n            }            \\n        }\\n\\n        JustifierIterator iter = new JustifierIterator(words, paths, maxWidth);\\n        \\n        while(iter.hasNext()) {\\n            results.add(iter.next());\\n        }\\n        \\n        return results;        \\n    }\\n    \\n    private int[][] createCostMatrix(String[] words, int maxWidth) {\\n        \\n        int len = words.length;\\n        int[][] costMatrix = new int[len][len];\\n        \\n        for(int row = 0; row < len-1; row++) {\\n            \\n            int usedSpace = 0;\\n            Arrays.fill(costMatrix[row], Integer.MAX_VALUE);\\n            \\n            for(int col = row; col < len; col++) {\\n                \\n            \\tusedSpace += words[col].length();\\n                if(usedSpace <= maxWidth) {\\n                \\tif(col == len-1) {\\n                \\t\\tcostMatrix[row][col] = 0;\\n                \\t} else {                \\t\\n\\t                \\tint unusedSpace = maxWidth - usedSpace;\\n\\t                    costMatrix[row][col] = unusedSpace * unusedSpace;\\n                \\t}\\n                } else {\\n                \\tif(col > 0) {\\n                \\t\\tcostMatrix[row][col-1] = 0;\\n                \\t}\\n                    break;\\n                }\\n                usedSpace++;\\n            }                        \\n        }\\n        \\n        costMatrix[len-1][len-1] = 0;\\n        \\n        return costMatrix;\\n    }\\n    \\n    private class JustifierIterator {\\n        \\n        String[] words;\\n        int[] paths;\\n        int maxWidth;\\n        \\n        int pathsIndex;\\n        \\n        public JustifierIterator(String[] words, int[] paths, int maxWidth) {\\n        \\tthis.paths = paths;\\n            this.words = words;\\n            this.maxWidth = maxWidth;\\n        }\\n        \\n        public boolean hasNext() {\\n            return pathsIndex < words.length;\\n        }\\n        \\n        public String next() {\\n        \\t\\n            int numWords = paths[pathsIndex] - pathsIndex; \\n            int spacesCount = calculateNumSpaces(pathsIndex, numWords);\\n            \\n            String result = generateSentence(pathsIndex, numWords, spacesCount);\\n            pathsIndex = paths[pathsIndex];\\n            \\n            return result;\\n        }\\n        \\n        private int calculateNumSpaces(int initialIndex, int numWords) {\\n            \\n            int numChars = 0;\\n            \\n            for(int i = 0; i < numWords; i++) {\\n                \\n                numChars += words[initialIndex + i].length();\\n            }\\n            \\n            return maxWidth - numChars;\\n        }\\n        \\n        private String generateSentence(int initialIndex, int numWords, int spacesCount) {\\n            \\n            StringBuilder sentence = new StringBuilder();\\n            \\n            if(numWords == 1) {\\n                sentence.append(words[initialIndex]);\\n                sentence.append(generateSpaces(maxWidth-words[initialIndex].length()));\\n                return sentence.toString();\\n            }\\n            \\n            if(initialIndex + numWords == words.length) {\\n                \\n                int len = 0;\\n                \\n                for(int i = 0; i < numWords; i++) {\\n\\n                    sentence.append(words[initialIndex+i]);\\n                    len += words[initialIndex+i].length();\\n                    \\n                    if(len < maxWidth) {\\n                        sentence.append(\" \");\\n                        len++;\\n                    }\\n                }                \\n                sentence.append(generateSpaces(maxWidth-len));\\n                return sentence.toString();\\n            }\\n            \\n            int evenDivision = spacesCount / (numWords-1);\\n            int leftOverSpaces = spacesCount % (numWords-1);\\n            \\n            for(int i = 0; i < numWords-1; i++) {\\n                \\n                int spacesToAdd = evenDivision;\\n                if(leftOverSpaces > 0) {\\n                    spacesToAdd++;\\n                    leftOverSpaces--;\\n                }\\n                \\n                sentence.append(words[initialIndex+i]);\\n                sentence.append(generateSpaces(spacesToAdd));\\n            }\\n            \\n            sentence.append(words[initialIndex+numWords-1]);\\n            \\n            return sentence.toString();\\n        }\\n        \\n        private char[] generateSpaces(int spacesCount) {\\n            \\n            char[] blankSequence = new char[spacesCount];\\n            Arrays.fill(blankSequence, ' ');\\n            \\n            return blankSequence;\\n        }        \\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "This is based on Roy Tushar's solution. See https://www.youtube.com/watch?v=RORuwHiblPc\\n\\n\\n\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {    \\t\\n        \\n        List<String> results = new LinkedList<>();   \\n        \\n        if(words == null) {\\n            return results;\\n        }        \\n        \\n        int[][] costsMatrix = createCostMatrix(words, maxWidth);\\n        \\n        int len = words.length;\\n        \\n        int[] minCosts = new int[len];\\n        int[] paths = new int[len];\\n        \\n        Arrays.fill(minCosts, Integer.MAX_VALUE);\\n        \\n        for(int i = len-1; i >= 0; i--) {\\n            \\n            minCosts[i] = costsMatrix[i][len-1];\\n            paths[i] = len;         \\n            \\n            for(int j = i+1; j < len; j++) {\\n                \\n                if(costsMatrix[i][j-1] != Integer.MAX_VALUE &&\\n                    minCosts[j] + costsMatrix[i][j-1] < minCosts[i]) {\\n                    \\n                    minCosts[i] = minCosts[j] + costsMatrix[i][j-1];\\n                    paths[i] = j;                            \\n                }\\n            }            \\n        }\\n\\n        JustifierIterator iter = new JustifierIterator(words, paths, maxWidth);\\n        \\n        while(iter.hasNext()) {\\n            results.add(iter.next());\\n        }\\n        \\n        return results;        \\n    }\\n    \\n    private int[][] createCostMatrix(String[] words, int maxWidth) {\\n        \\n        int len = words.length;\\n        int[][] costMatrix = new int[len][len];\\n        \\n        for(int row = 0; row < len-1; row++) {\\n            \\n            int usedSpace = 0;\\n            Arrays.fill(costMatrix[row], Integer.MAX_VALUE);\\n            \\n            for(int col = row; col < len; col++) {\\n                \\n            \\tusedSpace += words[col].length();\\n                if(usedSpace <= maxWidth) {\\n                \\tif(col == len-1) {\\n                \\t\\tcostMatrix[row][col] = 0;\\n                \\t} else {                \\t\\n\\t                \\tint unusedSpace = maxWidth - usedSpace;\\n\\t                    costMatrix[row][col] = unusedSpace * unusedSpace;\\n                \\t}\\n                } else {\\n                \\tif(col > 0) {\\n                \\t\\tcostMatrix[row][col-1] = 0;\\n                \\t}\\n                    break;\\n                }\\n                usedSpace++;\\n            }                        \\n        }\\n        \\n        costMatrix[len-1][len-1] = 0;\\n        \\n        return costMatrix;\\n    }\\n    \\n    private class JustifierIterator {\\n        \\n        String[] words;\\n        int[] paths;\\n        int maxWidth;\\n        \\n        int pathsIndex;\\n        \\n        public JustifierIterator(String[] words, int[] paths, int maxWidth) {\\n        \\tthis.paths = paths;\\n            this.words = words;\\n            this.maxWidth = maxWidth;\\n        }\\n        \\n        public boolean hasNext() {\\n            return pathsIndex < words.length;\\n        }\\n        \\n        public String next() {\\n        \\t\\n            int numWords = paths[pathsIndex] - pathsIndex; \\n            int spacesCount = calculateNumSpaces(pathsIndex, numWords);\\n            \\n            String result = generateSentence(pathsIndex, numWords, spacesCount);\\n            pathsIndex = paths[pathsIndex];\\n            \\n            return result;\\n        }\\n        \\n        private int calculateNumSpaces(int initialIndex, int numWords) {\\n            \\n            int numChars = 0;\\n            \\n            for(int i = 0; i < numWords; i++) {\\n                \\n                numChars += words[initialIndex + i].length();\\n            }\\n            \\n            return maxWidth - numChars;\\n        }\\n        \\n        private String generateSentence(int initialIndex, int numWords, int spacesCount) {\\n            \\n            StringBuilder sentence = new StringBuilder();\\n            \\n            if(numWords == 1) {\\n                sentence.append(words[initialIndex]);\\n                sentence.append(generateSpaces(maxWidth-words[initialIndex].length()));\\n                return sentence.toString();\\n            }\\n            \\n            if(initialIndex + numWords == words.length) {\\n                \\n                int len = 0;\\n                \\n                for(int i = 0; i < numWords; i++) {\\n\\n                    sentence.append(words[initialIndex+i]);\\n                    len += words[initialIndex+i].length();\\n                    \\n                    if(len < maxWidth) {\\n                        sentence.append(\" \");\\n                        len++;\\n                    }\\n                }                \\n                sentence.append(generateSpaces(maxWidth-len));\\n                return sentence.toString();\\n            }\\n            \\n            int evenDivision = spacesCount / (numWords-1);\\n            int leftOverSpaces = spacesCount % (numWords-1);\\n            \\n            for(int i = 0; i < numWords-1; i++) {\\n                \\n                int spacesToAdd = evenDivision;\\n                if(leftOverSpaces > 0) {\\n                    spacesToAdd++;\\n                    leftOverSpaces--;\\n                }\\n                \\n                sentence.append(words[initialIndex+i]);\\n                sentence.append(generateSpaces(spacesToAdd));\\n            }\\n            \\n            sentence.append(words[initialIndex+numWords-1]);\\n            \\n            return sentence.toString();\\n        }\\n        \\n        private char[] generateSpaces(int spacesCount) {\\n            \\n            char[] blankSequence = new char[spacesCount];\\n            Arrays.fill(blankSequence, ' ');\\n            \\n            return blankSequence;\\n        }        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3952544,
                "title": "putta-easy-solution-c-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string> &words, int L) {\\n    vector<string> res;\\n    for(int i = 0, k, l; i < words.size(); i += k) {\\n        for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n            l += words[i+k].size();\\n        }\\n        string tmp = words[i];\\n        for(int j = 0; j < k - 1; j++) {\\n            if(i + k >= words.size()) tmp += \" \";\\n            else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), \\' \\');\\n            tmp += words[i+j+1];\\n        }\\n        tmp += string(L - tmp.size(), \\' \\');\\n        res.push_back(tmp);\\n    }\\n    return res;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string> &words, int L) {\\n    vector<string> res;\\n    for(int i = 0, k, l; i < words.size(); i += k) {\\n        for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n            l += words[i+k].size();\\n        }\\n        string tmp = words[i];\\n        for(int j = 0; j < k - 1; j++) {\\n            if(i + k >= words.size()) tmp += \" \";\\n            else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), \\' \\');\\n            tmp += words[i+j+1];\\n        }\\n        tmp += string(L - tmp.size(), \\' \\');\\n        res.push_back(tmp);\\n    }\\n    return res;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952161,
                "title": "beats-100-js-ts-java-c-c-c-python-python3-kotlin-php",
                "content": "---\\n![header_.png](https://assets.leetcode.com/users/images/ab4510d5-90e7-4616-b1e1-aac91ec90eea_1692159981.2067795.png)\\n\\n---\\n```C []\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize) {\\n    char **result = (char **)malloc(sizeof(char *) * wordsSize);\\n    *returnSize = 0;\\n    \\n    int start = 0;  // Index of the first word in the current line.\\n    \\n    while (start < wordsSize) {\\n        int end = start;  // Index of the last word in the current line.\\n        int lineLength = 0;  // Length of the words and spaces in the current line.\\n        \\n        // Calculate the number of words and total length that can fit in the current line.\\n        while (end < wordsSize && lineLength + strlen(words[end]) + end - start <= maxWidth) {\\n            lineLength += strlen(words[end]);\\n            end++;\\n        }\\n        \\n        // Calculate the total number of spaces needed in the line.\\n        int totalSpaces = maxWidth - lineLength;\\n        \\n        // If it\\'s the last line or only one word in the line, left-justify.\\n        if (end == wordsSize || end - start == 1) {\\n            result[*returnSize] = (char *)malloc(sizeof(char) * (maxWidth + 1));\\n            int idx = 0;\\n            for (int i = start; i < end; i++) {\\n                strcpy(result[*returnSize] + idx, words[i]);\\n                idx += strlen(words[i]);\\n                if (i != end - 1) {\\n                    result[*returnSize][idx++] = \\' \\';\\n                }\\n            }\\n            while (idx < maxWidth) {\\n                result[*returnSize][idx++] = \\' \\';\\n            }\\n            result[*returnSize][maxWidth] = \\'\\\\0\\';\\n        } else {\\n            int spaceBetweenWords = totalSpaces / (end - start - 1);\\n            int extraSpaces = totalSpaces % (end - start - 1);\\n            \\n            result[*returnSize] = (char *)malloc(sizeof(char) * (maxWidth + 1));\\n            int idx = 0;\\n            for (int i = start; i < end; i++) {\\n                strcpy(result[*returnSize] + idx, words[i]);\\n                idx += strlen(words[i]);\\n                if (i != end - 1) {\\n                    int spaces = spaceBetweenWords + (extraSpaces > 0 ? 1 : 0);\\n                    extraSpaces--;\\n                    for (int j = 0; j < spaces; j++) {\\n                        result[*returnSize][idx++] = \\' \\';\\n                    }\\n                }\\n            }\\n            result[*returnSize][maxWidth] = \\'\\\\0\\';\\n        }\\n        \\n        (*returnSize)++;\\n        start = end;\\n    }\\n    \\n    return result;\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int i = 0;\\n        \\n        while (i < words.size()) {\\n            int lineLen = words[i].size();\\n            int j = i + 1;\\n            \\n            // Find the words that can fit in the current line\\n            while (j < words.size() && lineLen + 1 + words[j].size() <= maxWidth) {\\n                lineLen += 1 + words[j].size();\\n                j++;\\n            }\\n            \\n            int numWords = j - i;\\n            int totalSpaces = maxWidth - lineLen + numWords - 1;\\n            \\n            // Construct the formatted line\\n            string line = words[i];\\n            if (numWords == 1 || j == words.size()) { // Left-justify\\n                for (int k = i + 1; k < j; k++) {\\n                    line += \" \" + words[k];\\n                }\\n                line += string(maxWidth - line.size(), \\' \\'); // Pad with spaces\\n            } else { // Fully justify\\n                int spacesBetweenWords = totalSpaces / (numWords - 1);\\n                int extraSpaces = totalSpaces % (numWords - 1);\\n                for (int k = i + 1; k < j; k++) {\\n                    int spaces = k - i <= extraSpaces ? spacesBetweenWords + 1 : spacesBetweenWords;\\n                    line += string(spaces, \\' \\') + words[k];\\n                }\\n            }\\n            \\n            result.push_back(line);\\n            i = j;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n```Typescript []\\nfunction fullJustify(words: string[], maxWidth: number): string[] {\\n    let res = [], str = \"\", i = 0, n = words.length, x = 0;\\n    while( i < n ){\\n        if( (str + words[i]).length === maxWidth ){\\n            str += words[i++];\\n            res.push(str);\\n            str = \"\";\\n            x = i;\\n        }\\n        else if( (str + words[i]).length > maxWidth ){\\n            let j = x, cnt = maxWidth - (str.length - 1);\\n            while( cnt > 0 && j < i - 1 ){\\n                words[j++] += \" \";\\n                cnt--;\\n                if( j === i - 1 && cnt > 0 )j = x\\n            }\\n            let tempStr = \"\"; j = x;\\n            while( j < i )tempStr += j < i - 1 ?  words[j++] + \" \" : words[j++];\\n            while( tempStr.length < maxWidth )tempStr += \" \"\\n            res.push(tempStr);\\n            str = \"\";\\n            x = i;\\n        }\\n        else str += words[i++] + \" \";\\n    }\\n    if( str.length > 0 ){\\n        let cnt = maxWidth - str.length;\\n        while( cnt > 0 ){\\n            str += \" \";\\n            cnt--;\\n        }\\n        res.push(str)\\n    }\\n    return res\\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        int index = 0;\\n\\n        while (index < words.length) {\\n            int lineStart = index;\\n            int lineLength = words[index].length();\\n            index++;\\n\\n            while (index < words.length && lineLength + words[index].length() + (index - lineStart) <= maxWidth) {\\n                lineLength += words[index].length();\\n                index++;\\n            }\\n\\n            int totalSpaces = maxWidth - lineLength;\\n            int numWords = index - lineStart;\\n\\n            StringBuilder line = new StringBuilder(words[lineStart]);\\n            \\n            if (numWords == 1 || index == words.length) { // Left-justify last line or single-word lines\\n                for (int i = lineStart + 1; i < index; i++) {\\n                    line.append(\\' \\').append(words[i]);\\n                }\\n                line.append(String.valueOf(\\' \\').repeat(maxWidth - line.length())); // Add extra spaces at the end\\n            } else {\\n                int spacesBetweenWords = totalSpaces / (numWords - 1);\\n                int extraSpaces = totalSpaces % (numWords - 1);\\n                \\n                for (int i = lineStart + 1; i < index; i++) {\\n                    int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n                    line.append(String.valueOf(\\' \\').repeat(spaces)).append(words[i]);\\n                }\\n            }\\n\\n            result.add(line.toString());\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        result = []\\n        line = []\\n        line_length = 0\\n        \\n        for word in words:\\n            if line_length + len(line) + len(word) > maxWidth:\\n                # Justify the current line\\n                spaces_to_add = maxWidth - line_length\\n                if len(line) == 1:\\n                    result.append(line[0] + \\' \\' * spaces_to_add)\\n                else:\\n                    num_gaps = len(line) - 1\\n                    spaces_per_gap = spaces_to_add // num_gaps\\n                    extra_spaces = spaces_to_add % num_gaps\\n                    justified_line = line[0]\\n                    for i in range(1, len(line)):\\n                        spaces = spaces_per_gap + (1 if i <= extra_spaces else 0)\\n                        justified_line += \\' \\' * spaces + line[i]\\n                    result.append(justified_line)\\n                \\n                # Reset line and line_length\\n                line = []\\n                line_length = 0\\n            \\n            line.append(word)\\n            line_length += len(word)\\n        \\n        # Left-justify the last line\\n        last_line = \\' \\'.join(line)\\n        last_line += \\' \\' * (maxWidth - len(last_line))\\n        result.append(last_line)\\n        \\n        return result\\n```\\n```Python3 []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []\\n        line = []  # Stores words for the current line\\n        line_length = 0\\n        \\n        for word in words:\\n            # Check if adding the current word to the line exceeds the maxWidth\\n            if line_length + len(line) + len(word) > maxWidth:\\n                # Distribute extra spaces between words\\n                num_words = len(line)\\n                total_spaces = maxWidth - line_length\\n                \\n                if num_words == 1:\\n                    # Left-justify if there\\'s only one word in the line\\n                    result.append(line[0] + \\' \\' * (maxWidth - len(line[0])))\\n                else:\\n                    # Calculate even and extra spaces\\n                    spaces_per_word = total_spaces // (num_words - 1)\\n                    extra_spaces = total_spaces % (num_words - 1)\\n                    \\n                    # Create the justified line\\n                    justified_line = \"\"\\n                    for i in range(num_words - 1):\\n                        justified_line += line[i] + \\' \\' * spaces_per_word\\n                        if extra_spaces > 0:\\n                            justified_line += \\' \\'\\n                            extra_spaces -= 1\\n                    justified_line += line[num_words - 1]\\n                    result.append(justified_line)\\n                \\n                # Reset line variables for the next line\\n                line = []\\n                line_length = 0\\n            \\n            line.append(word)\\n            line_length += len(word)\\n        \\n        # Last line: left-justify and no extra spaces\\n        result.append(\\' \\'.join(line) + \\' \\' * (maxWidth - line_length - len(line) + 1))\\n        \\n        return result\\n```\\n```C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> result = new List<string>();\\n        int startIndex = 0;\\n\\n        while (startIndex < words.Length) {\\n            int endIndex = startIndex;\\n            int lineLength = 0;\\n\\n            // Find the range of words that can fit in the current line\\n            while (endIndex < words.Length && lineLength + words[endIndex].Length + (endIndex - startIndex) <= maxWidth) {\\n                lineLength += words[endIndex].Length;\\n                endIndex++;\\n            }\\n\\n            // Calculate the number of total spaces and gaps between words\\n            int totalSpaces = maxWidth - lineLength;\\n            int totalGaps = endIndex - startIndex - 1;\\n            \\n            StringBuilder lineBuilder = new StringBuilder();\\n\\n            // If it\\'s the last line or only one word in the line, left-justify\\n            if (endIndex == words.Length || totalGaps == 0) {\\n                for (int i = startIndex; i < endIndex; i++) {\\n                    lineBuilder.Append(words[i]);\\n                    if (i < endIndex - 1) {\\n                        lineBuilder.Append(\\' \\');\\n                    }\\n                }\\n                while (lineBuilder.Length < maxWidth) {\\n                    lineBuilder.Append(\\' \\');\\n                }\\n            } else {\\n                int spacesPerGap = totalSpaces / totalGaps;\\n                int extraSpaces = totalSpaces % totalGaps;\\n\\n                for (int i = startIndex; i < endIndex; i++) {\\n                    lineBuilder.Append(words[i]);\\n                    if (i < endIndex - 1) {\\n                        int spacesToAdd = spacesPerGap + (i - startIndex < extraSpaces ? 1 : 0);\\n                        lineBuilder.Append(\\' \\', spacesToAdd);\\n                    }\\n                }\\n            }\\n\\n            result.Add(lineBuilder.ToString());\\n            startIndex = endIndex;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n```Javascript []\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```\\n```Kotlin []\\nclass Solution {\\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\\n        val result = mutableListOf<String>()\\n        var lineWords = mutableListOf<String>()\\n        var lineLength = 0\\n        \\n        for (word in words) {\\n            if (lineLength + lineWords.size + word.length <= maxWidth) {\\n                lineWords.add(word)\\n                lineLength += word.length\\n            } else {\\n                result.add(constructLine(lineWords, maxWidth, lineLength))\\n                lineWords.clear()\\n                lineWords.add(word)\\n                lineLength = word.length\\n            }\\n        }\\n        \\n        // Last line\\n        if (lineWords.isNotEmpty()) {\\n            val lastLine = lineWords.joinToString(\" \")\\n            result.add(lastLine.padEnd(maxWidth))\\n        }\\n        \\n        return result\\n    }\\n    \\n    private fun constructLine(words: List<String>, maxWidth: Int, lineLength: Int): String {\\n        val numWords = words.size\\n        if (numWords == 1) {\\n            return words[0].padEnd(maxWidth)\\n        }\\n        \\n        val totalSpaces = maxWidth - lineLength\\n        val spaceSlots = numWords - 1\\n        val baseSpace = totalSpaces / spaceSlots\\n        val extraSpaceSlots = totalSpaces % spaceSlots\\n        \\n        val lineBuilder = StringBuilder()\\n        for (i in 0 until numWords - 1) {\\n            lineBuilder.append(words[i])\\n            lineBuilder.append(\" \".repeat(baseSpace))\\n            if (i < extraSpaceSlots) {\\n                lineBuilder.append(\" \")\\n            }\\n        }\\n        lineBuilder.append(words.last())\\n        \\n        return lineBuilder.toString()\\n    }\\n}\\n```\\n```PHP []\\nclass Solution {\\n    /**\\n     * @param String[] $words\\n     * @param Integer $maxWidth\\n     * @return String[]\\n     */\\n    function fullJustify($words, $maxWidth) {\\n        $result = [];\\n        $line = [];\\n        $lineWidth = 0;\\n        \\n        foreach ($words as $word) {\\n            // Check if adding the next word exceeds maxWidth\\n            if ($lineWidth + count($line) + strlen($word) > $maxWidth) {\\n                $formattedLine = $this->formatLine($line, $lineWidth, $maxWidth);\\n                $result[] = $formattedLine;\\n                \\n                $line = [];\\n                $lineWidth = 0;\\n            }\\n            \\n            $line[] = $word;\\n            $lineWidth += strlen($word);\\n        }\\n        \\n        // Handle the last line\\n        $lastLine = implode(\\' \\', $line);\\n        $lastLine .= str_repeat(\\' \\', $maxWidth - strlen($lastLine));\\n        $result[] = $lastLine;\\n        \\n        return $result;\\n    }\\n    \\n    // Helper function to format a line\\n    private function formatLine($line, $lineWidth, $maxWidth) {\\n        $numWords = count($line);\\n        $numSpaces = $maxWidth - $lineWidth;\\n        \\n        if ($numWords === 1) {\\n            return $line[0] . str_repeat(\\' \\', $numSpaces);\\n        }\\n        \\n        $avgSpaces = floor($numSpaces / ($numWords - 1));\\n        $extraSpaces = $numSpaces % ($numWords - 1);\\n        \\n        $formattedLine = $line[0];\\n        \\n        for ($i = 1; $i < $numWords; $i++) {\\n            $numPaddingSpaces = $avgSpaces + ($i <= $extraSpaces ? 1 : 0);\\n            $formattedLine .= str_repeat(\\' \\', $numPaddingSpaces) . $line[$i];\\n        }\\n        \\n        return $formattedLine;\\n    }\\n}\\n```\\n\\n\\n---\\n![download.jpg](https://assets.leetcode.com/users/images/5196fec2-1dd4-4b82-9700-36c5a0e72623_1692159956.9446952.jpeg)\\n\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#",
                    "JavaScript",
                    "Kotlin",
                    "PHP",
                    "TypeScript"
                ],
                "code": "```C []\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize) {\\n    char **result = (char **)malloc(sizeof(char *) * wordsSize);\\n    *returnSize = 0;\\n    \\n    int start = 0;  // Index of the first word in the current line.\\n    \\n    while (start < wordsSize) {\\n        int end = start;  // Index of the last word in the current line.\\n        int lineLength = 0;  // Length of the words and spaces in the current line.\\n        \\n        // Calculate the number of words and total length that can fit in the current line.\\n        while (end < wordsSize && lineLength + strlen(words[end]) + end - start <= maxWidth) {\\n            lineLength += strlen(words[end]);\\n            end++;\\n        }\\n        \\n        // Calculate the total number of spaces needed in the line.\\n        int totalSpaces = maxWidth - lineLength;\\n        \\n        // If it\\'s the last line or only one word in the line, left-justify.\\n        if (end == wordsSize || end - start == 1) {\\n            result[*returnSize] = (char *)malloc(sizeof(char) * (maxWidth + 1));\\n            int idx = 0;\\n            for (int i = start; i < end; i++) {\\n                strcpy(result[*returnSize] + idx, words[i]);\\n                idx += strlen(words[i]);\\n                if (i != end - 1) {\\n                    result[*returnSize][idx++] = \\' \\';\\n                }\\n            }\\n            while (idx < maxWidth) {\\n                result[*returnSize][idx++] = \\' \\';\\n            }\\n            result[*returnSize][maxWidth] = \\'\\\\0\\';\\n        } else {\\n            int spaceBetweenWords = totalSpaces / (end - start - 1);\\n            int extraSpaces = totalSpaces % (end - start - 1);\\n            \\n            result[*returnSize] = (char *)malloc(sizeof(char) * (maxWidth + 1));\\n            int idx = 0;\\n            for (int i = start; i < end; i++) {\\n                strcpy(result[*returnSize] + idx, words[i]);\\n                idx += strlen(words[i]);\\n                if (i != end - 1) {\\n                    int spaces = spaceBetweenWords + (extraSpaces > 0 ? 1 : 0);\\n                    extraSpaces--;\\n                    for (int j = 0; j < spaces; j++) {\\n                        result[*returnSize][idx++] = \\' \\';\\n                    }\\n                }\\n            }\\n            result[*returnSize][maxWidth] = \\'\\\\0\\';\\n        }\\n        \\n        (*returnSize)++;\\n        start = end;\\n    }\\n    \\n    return result;\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int i = 0;\\n        \\n        while (i < words.size()) {\\n            int lineLen = words[i].size();\\n            int j = i + 1;\\n            \\n            // Find the words that can fit in the current line\\n            while (j < words.size() && lineLen + 1 + words[j].size() <= maxWidth) {\\n                lineLen += 1 + words[j].size();\\n                j++;\\n            }\\n            \\n            int numWords = j - i;\\n            int totalSpaces = maxWidth - lineLen + numWords - 1;\\n            \\n            // Construct the formatted line\\n            string line = words[i];\\n            if (numWords == 1 || j == words.size()) { // Left-justify\\n                for (int k = i + 1; k < j; k++) {\\n                    line += \" \" + words[k];\\n                }\\n                line += string(maxWidth - line.size(), \\' \\'); // Pad with spaces\\n            } else { // Fully justify\\n                int spacesBetweenWords = totalSpaces / (numWords - 1);\\n                int extraSpaces = totalSpaces % (numWords - 1);\\n                for (int k = i + 1; k < j; k++) {\\n                    int spaces = k - i <= extraSpaces ? spacesBetweenWords + 1 : spacesBetweenWords;\\n                    line += string(spaces, \\' \\') + words[k];\\n                }\\n            }\\n            \\n            result.push_back(line);\\n            i = j;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```Typescript []\\nfunction fullJustify(words: string[], maxWidth: number): string[] {\\n    let res = [], str = \"\", i = 0, n = words.length, x = 0;\\n    while( i < n ){\\n        if( (str + words[i]).length === maxWidth ){\\n            str += words[i++];\\n            res.push(str);\\n            str = \"\";\\n            x = i;\\n        }\\n        else if( (str + words[i]).length > maxWidth ){\\n            let j = x, cnt = maxWidth - (str.length - 1);\\n            while( cnt > 0 && j < i - 1 ){\\n                words[j++] += \" \";\\n                cnt--;\\n                if( j === i - 1 && cnt > 0 )j = x\\n            }\\n            let tempStr = \"\"; j = x;\\n            while( j < i )tempStr += j < i - 1 ?  words[j++] + \" \" : words[j++];\\n            while( tempStr.length < maxWidth )tempStr += \" \"\\n            res.push(tempStr);\\n            str = \"\";\\n            x = i;\\n        }\\n        else str += words[i++] + \" \";\\n    }\\n    if( str.length > 0 ){\\n        let cnt = maxWidth - str.length;\\n        while( cnt > 0 ){\\n            str += \" \";\\n            cnt--;\\n        }\\n        res.push(str)\\n    }\\n    return res\\n};\\n```\n```Java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        int index = 0;\\n\\n        while (index < words.length) {\\n            int lineStart = index;\\n            int lineLength = words[index].length();\\n            index++;\\n\\n            while (index < words.length && lineLength + words[index].length() + (index - lineStart) <= maxWidth) {\\n                lineLength += words[index].length();\\n                index++;\\n            }\\n\\n            int totalSpaces = maxWidth - lineLength;\\n            int numWords = index - lineStart;\\n\\n            StringBuilder line = new StringBuilder(words[lineStart]);\\n            \\n            if (numWords == 1 || index == words.length) { // Left-justify last line or single-word lines\\n                for (int i = lineStart + 1; i < index; i++) {\\n                    line.append(\\' \\').append(words[i]);\\n                }\\n                line.append(String.valueOf(\\' \\').repeat(maxWidth - line.length())); // Add extra spaces at the end\\n            } else {\\n                int spacesBetweenWords = totalSpaces / (numWords - 1);\\n                int extraSpaces = totalSpaces % (numWords - 1);\\n                \\n                for (int i = lineStart + 1; i < index; i++) {\\n                    int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n                    line.append(String.valueOf(\\' \\').repeat(spaces)).append(words[i]);\\n                }\\n            }\\n\\n            result.add(line.toString());\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        result = []\\n        line = []\\n        line_length = 0\\n        \\n        for word in words:\\n            if line_length + len(line) + len(word) > maxWidth:\\n                # Justify the current line\\n                spaces_to_add = maxWidth - line_length\\n                if len(line) == 1:\\n                    result.append(line[0] + \\' \\' * spaces_to_add)\\n                else:\\n                    num_gaps = len(line) - 1\\n                    spaces_per_gap = spaces_to_add // num_gaps\\n                    extra_spaces = spaces_to_add % num_gaps\\n                    justified_line = line[0]\\n                    for i in range(1, len(line)):\\n                        spaces = spaces_per_gap + (1 if i <= extra_spaces else 0)\\n                        justified_line += \\' \\' * spaces + line[i]\\n                    result.append(justified_line)\\n                \\n                # Reset line and line_length\\n                line = []\\n                line_length = 0\\n            \\n            line.append(word)\\n            line_length += len(word)\\n        \\n        # Left-justify the last line\\n        last_line = \\' \\'.join(line)\\n        last_line += \\' \\' * (maxWidth - len(last_line))\\n        result.append(last_line)\\n        \\n        return result\\n```\n```Python3 []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []\\n        line = []  # Stores words for the current line\\n        line_length = 0\\n        \\n        for word in words:\\n            # Check if adding the current word to the line exceeds the maxWidth\\n            if line_length + len(line) + len(word) > maxWidth:\\n                # Distribute extra spaces between words\\n                num_words = len(line)\\n                total_spaces = maxWidth - line_length\\n                \\n                if num_words == 1:\\n                    # Left-justify if there\\'s only one word in the line\\n                    result.append(line[0] + \\' \\' * (maxWidth - len(line[0])))\\n                else:\\n                    # Calculate even and extra spaces\\n                    spaces_per_word = total_spaces // (num_words - 1)\\n                    extra_spaces = total_spaces % (num_words - 1)\\n                    \\n                    # Create the justified line\\n                    justified_line = \"\"\\n                    for i in range(num_words - 1):\\n                        justified_line += line[i] + \\' \\' * spaces_per_word\\n                        if extra_spaces > 0:\\n                            justified_line += \\' \\'\\n                            extra_spaces -= 1\\n                    justified_line += line[num_words - 1]\\n                    result.append(justified_line)\\n                \\n                # Reset line variables for the next line\\n                line = []\\n                line_length = 0\\n            \\n            line.append(word)\\n            line_length += len(word)\\n        \\n        # Last line: left-justify and no extra spaces\\n        result.append(\\' \\'.join(line) + \\' \\' * (maxWidth - line_length - len(line) + 1))\\n        \\n        return result\\n```\n```C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> result = new List<string>();\\n        int startIndex = 0;\\n\\n        while (startIndex < words.Length) {\\n            int endIndex = startIndex;\\n            int lineLength = 0;\\n\\n            // Find the range of words that can fit in the current line\\n            while (endIndex < words.Length && lineLength + words[endIndex].Length + (endIndex - startIndex) <= maxWidth) {\\n                lineLength += words[endIndex].Length;\\n                endIndex++;\\n            }\\n\\n            // Calculate the number of total spaces and gaps between words\\n            int totalSpaces = maxWidth - lineLength;\\n            int totalGaps = endIndex - startIndex - 1;\\n            \\n            StringBuilder lineBuilder = new StringBuilder();\\n\\n            // If it\\'s the last line or only one word in the line, left-justify\\n            if (endIndex == words.Length || totalGaps == 0) {\\n                for (int i = startIndex; i < endIndex; i++) {\\n                    lineBuilder.Append(words[i]);\\n                    if (i < endIndex - 1) {\\n                        lineBuilder.Append(\\' \\');\\n                    }\\n                }\\n                while (lineBuilder.Length < maxWidth) {\\n                    lineBuilder.Append(\\' \\');\\n                }\\n            } else {\\n                int spacesPerGap = totalSpaces / totalGaps;\\n                int extraSpaces = totalSpaces % totalGaps;\\n\\n                for (int i = startIndex; i < endIndex; i++) {\\n                    lineBuilder.Append(words[i]);\\n                    if (i < endIndex - 1) {\\n                        int spacesToAdd = spacesPerGap + (i - startIndex < extraSpaces ? 1 : 0);\\n                        lineBuilder.Append(\\' \\', spacesToAdd);\\n                    }\\n                }\\n            }\\n\\n            result.Add(lineBuilder.ToString());\\n            startIndex = endIndex;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```Javascript []\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```\n```Kotlin []\\nclass Solution {\\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\\n        val result = mutableListOf<String>()\\n        var lineWords = mutableListOf<String>()\\n        var lineLength = 0\\n        \\n        for (word in words) {\\n            if (lineLength + lineWords.size + word.length <= maxWidth) {\\n                lineWords.add(word)\\n                lineLength += word.length\\n            } else {\\n                result.add(constructLine(lineWords, maxWidth, lineLength))\\n                lineWords.clear()\\n                lineWords.add(word)\\n                lineLength = word.length\\n            }\\n        }\\n        \\n        // Last line\\n        if (lineWords.isNotEmpty()) {\\n            val lastLine = lineWords.joinToString(\" \")\\n            result.add(lastLine.padEnd(maxWidth))\\n        }\\n        \\n        return result\\n    }\\n    \\n    private fun constructLine(words: List<String>, maxWidth: Int, lineLength: Int): String {\\n        val numWords = words.size\\n        if (numWords == 1) {\\n            return words[0].padEnd(maxWidth)\\n        }\\n        \\n        val totalSpaces = maxWidth - lineLength\\n        val spaceSlots = numWords - 1\\n        val baseSpace = totalSpaces / spaceSlots\\n        val extraSpaceSlots = totalSpaces % spaceSlots\\n        \\n        val lineBuilder = StringBuilder()\\n        for (i in 0 until numWords - 1) {\\n            lineBuilder.append(words[i])\\n            lineBuilder.append(\" \".repeat(baseSpace))\\n            if (i < extraSpaceSlots) {\\n                lineBuilder.append(\" \")\\n            }\\n        }\\n        lineBuilder.append(words.last())\\n        \\n        return lineBuilder.toString()\\n    }\\n}\\n```\n```PHP []\\nclass Solution {\\n    /**\\n     * @param String[] $words\\n     * @param Integer $maxWidth\\n     * @return String[]\\n     */\\n    function fullJustify($words, $maxWidth) {\\n        $result = [];\\n        $line = [];\\n        $lineWidth = 0;\\n        \\n        foreach ($words as $word) {\\n            // Check if adding the next word exceeds maxWidth\\n            if ($lineWidth + count($line) + strlen($word) > $maxWidth) {\\n                $formattedLine = $this->formatLine($line, $lineWidth, $maxWidth);\\n                $result[] = $formattedLine;\\n                \\n                $line = [];\\n                $lineWidth = 0;\\n            }\\n            \\n            $line[] = $word;\\n            $lineWidth += strlen($word);\\n        }\\n        \\n        // Handle the last line\\n        $lastLine = implode(\\' \\', $line);\\n        $lastLine .= str_repeat(\\' \\', $maxWidth - strlen($lastLine));\\n        $result[] = $lastLine;\\n        \\n        return $result;\\n    }\\n    \\n    // Helper function to format a line\\n    private function formatLine($line, $lineWidth, $maxWidth) {\\n        $numWords = count($line);\\n        $numSpaces = $maxWidth - $lineWidth;\\n        \\n        if ($numWords === 1) {\\n            return $line[0] . str_repeat(\\' \\', $numSpaces);\\n        }\\n        \\n        $avgSpaces = floor($numSpaces / ($numWords - 1));\\n        $extraSpaces = $numSpaces % ($numWords - 1);\\n        \\n        $formattedLine = $line[0];\\n        \\n        for ($i = 1; $i < $numWords; $i++) {\\n            $numPaddingSpaces = $avgSpaces + ($i <= $extraSpaces ? 1 : 0);\\n            $formattedLine .= str_repeat(\\' \\', $numPaddingSpaces) . $line[$i];\\n        }\\n        \\n        return $formattedLine;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3952159,
                "title": "c-strings-with-examples-beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe fundamental operations for strings should be known to solve such questions. LC has different kinds of hard questions. To solve this question one does not need special algorithms or tricks.\\nBut it is  very annoying for debugging until to get right answer!\\n\\nMaybe solve the easy question first.\\n[1592. Rearrange Spaces Between Words](https://leetcode.com/problems/rearrange-spaces-between-words/description/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDetermine which words are in which line.\\nThe function ```print_wIdx``` handles where extra whitespaces to insert.\\n\\nFor 2nd approach, every line is initialized with\\n```\\nline = string(maxWidth, \\' \\');\\n```\\nand then the function copy in C++ algorithm is used for copying the ```words[i]``` to the right place; its performance is better than operator+ and beats 100.00% with runtime 0 ms. It is to mention that if operator+ for strings is used, the string line will be allocated several times.\\n\\nLet\\'s consider the string words=\\n```[\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]```\\n\\nTake care where extra whitespaces to insert\\n\\nmaxWidth=20 \\n```\\n|Science  is  what we|\\n|understand      well|\\n|enough to explain to|\\n|a  computer.  Art is|\\n|everything  else  we|\\n|do                  |\\n```\\nmaxWidth=19\\n```\\n|Science  is what we|\\n|understand     well|\\n|enough  to  explain|\\n|to  a computer. Art|\\n|is  everything else|\\n|we do              |\\n```\\nmaxWidth=21\\n```\\n|Science  is  what  we|\\n|understand       well|\\n|enough  to explain to|\\n|a  computer.  Art  is|\\n|everything else we do|\\n```\\nOther testcase:\\n```\\n[\"My\",\"momma\",\"always\",\"said,\",\"\\\\\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you\\'re\",\"gonna\",\"get.\"]\\n20\\n```\\nans\\n```\\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\\n|you\\'re gonna get.   | no extra space\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    string space(int c) {\\n        return string(c, \\' \\');\\n    }\\n\\n    vector<string> print_wIdx(vector<string>& words, vector<pair<vector<int>, int>>& wIdx, int maxWidth) {\\n        for (int i = 0; i < wIdx.size(); i++) {\\n            int numWords = wIdx[i].first.size();\\n            int totalLen = wIdx[i].second;\\n            int totalSpaces = maxWidth - totalLen;\\n            int numGaps = numWords - 1;\\n            int numSpaces = 1;\\n            int remainingSpaces = 0;\\n\\n            if (numGaps > 0) {\\n                numSpaces = totalSpaces / numGaps;\\n                remainingSpaces = totalSpaces % numGaps;\\n            }\\n\\n            string line = words[wIdx[i].first[0]]; // Start with the first word\\n            for (int j = 1; j < numWords; j++) {\\n                if (i == wIdx.size() - 1) {\\n                    // Last line, left justify\\n                    line += space(1);\\n                } \\n                else {\\n                    line+= space(numSpaces+(remainingSpaces>0?1:0));\\n                    remainingSpaces--;\\n                }\\n                line+= words[wIdx[i].first[j]];\\n            }\\n\\n            if (line.size() < maxWidth)\\n                line+= space(maxWidth-line.size());\\n\\n            ans.push_back(line);\\n        }\\n\\n        return ans;\\n    }\\n\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<pair<vector<int>, int>> wIdx(1);\\n        int cur = 0;\\n        int len = 0;\\n        for (int i = 0; i < n; i++) {\\n            //wlen=sum of length of words w/o space in 1 line\\n            int wlen = words[i].size();\\n            len += wlen;\\n            if (len > maxWidth) {\\n                wIdx.push_back({{i}, wlen});\\n                cur++;\\n                len = wlen;\\n            } \\n            else {\\n                wIdx[cur].first.push_back(i);\\n                wIdx[cur].second += wlen;\\n            }\\n            len++; //at least 1 whitespace between words\\n        }\\n\\n        return print_wIdx(words, wIdx, maxWidth);\\n    }\\n};\\n\\n```\\n# Other implementation for print_wIdx using C++ algorithm copy has runtime 0 ms and beats 100.00%\\n```\\nvector<string> print_wIdx(vector<string>& words, vector<pair<vector<int>, int>>& wIdx, int maxWidth) {\\n    vector<string> ans;\\n\\n    for (int i = 0; i < wIdx.size(); i++) {\\n        int numWords = wIdx[i].first.size();\\n        int totalSpaces = maxWidth - wIdx[i].second;\\n        int numGaps = numWords-1;\\n        int numSpaces = 1;\\n        int remainingSpaces = 0;\\n\\n        if (numGaps > 0) {\\n            auto [q, r] = div(totalSpaces, numGaps);\\n            numSpaces = q, remainingSpaces = r;\\n    //        cout<<q<<\"\\\\n\"<<r<<endl;\\n        }\\n\\n        string line = string(maxWidth, \\' \\');\\n        auto& w0 = words[wIdx[i].first[0]];\\n        copy(w0.begin(), w0.end(), line.begin()); // Copy the first word\\n\\n        int pos = w0.size();\\n        for (int j = 1; j < numWords; j++) {\\n            if (i != wIdx.size() - 1) {\\n                pos += numSpaces +(remainingSpaces > 0 ? 1 : 0);\\n                remainingSpaces--;\\n            }\\n            else pos++;\\n            auto& w = words[wIdx[i].first[j]];\\n            copy(w.begin(), w.end(), line.begin() + pos); // Copy each word\\n            pos += w.size();\\n        }\\n        ans.push_back(line);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```print_wIdx```\n```\\nline = string(maxWidth, \\' \\');\\n```\n```words[i]```\n```[\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]```\n```\\n|Science  is  what we|\\n|understand      well|\\n|enough to explain to|\\n|a  computer.  Art is|\\n|everything  else  we|\\n|do                  |\\n```\n```\\n|Science  is what we|\\n|understand     well|\\n|enough  to  explain|\\n|to  a computer. Art|\\n|is  everything else|\\n|we do              |\\n```\n```\\n|Science  is  what  we|\\n|understand       well|\\n|enough  to explain to|\\n|a  computer.  Art  is|\\n|everything else we do|\\n```\n```\\n[\"My\",\"momma\",\"always\",\"said,\",\"\\\\\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you\\'re\",\"gonna\",\"get.\"]\\n20\\n```\n```\\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\\n|you\\'re gonna get.   | no extra space\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    string space(int c) {\\n        return string(c, \\' \\');\\n    }\\n\\n    vector<string> print_wIdx(vector<string>& words, vector<pair<vector<int>, int>>& wIdx, int maxWidth) {\\n        for (int i = 0; i < wIdx.size(); i++) {\\n            int numWords = wIdx[i].first.size();\\n            int totalLen = wIdx[i].second;\\n            int totalSpaces = maxWidth - totalLen;\\n            int numGaps = numWords - 1;\\n            int numSpaces = 1;\\n            int remainingSpaces = 0;\\n\\n            if (numGaps > 0) {\\n                numSpaces = totalSpaces / numGaps;\\n                remainingSpaces = totalSpaces % numGaps;\\n            }\\n\\n            string line = words[wIdx[i].first[0]]; // Start with the first word\\n            for (int j = 1; j < numWords; j++) {\\n                if (i == wIdx.size() - 1) {\\n                    // Last line, left justify\\n                    line += space(1);\\n                } \\n                else {\\n                    line+= space(numSpaces+(remainingSpaces>0?1:0));\\n                    remainingSpaces--;\\n                }\\n                line+= words[wIdx[i].first[j]];\\n            }\\n\\n            if (line.size() < maxWidth)\\n                line+= space(maxWidth-line.size());\\n\\n            ans.push_back(line);\\n        }\\n\\n        return ans;\\n    }\\n\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<pair<vector<int>, int>> wIdx(1);\\n        int cur = 0;\\n        int len = 0;\\n        for (int i = 0; i < n; i++) {\\n            //wlen=sum of length of words w/o space in 1 line\\n            int wlen = words[i].size();\\n            len += wlen;\\n            if (len > maxWidth) {\\n                wIdx.push_back({{i}, wlen});\\n                cur++;\\n                len = wlen;\\n            } \\n            else {\\n                wIdx[cur].first.push_back(i);\\n                wIdx[cur].second += wlen;\\n            }\\n            len++; //at least 1 whitespace between words\\n        }\\n\\n        return print_wIdx(words, wIdx, maxWidth);\\n    }\\n};\\n\\n```\n```\\nvector<string> print_wIdx(vector<string>& words, vector<pair<vector<int>, int>>& wIdx, int maxWidth) {\\n    vector<string> ans;\\n\\n    for (int i = 0; i < wIdx.size(); i++) {\\n        int numWords = wIdx[i].first.size();\\n        int totalSpaces = maxWidth - wIdx[i].second;\\n        int numGaps = numWords-1;\\n        int numSpaces = 1;\\n        int remainingSpaces = 0;\\n\\n        if (numGaps > 0) {\\n            auto [q, r] = div(totalSpaces, numGaps);\\n            numSpaces = q, remainingSpaces = r;\\n    //        cout<<q<<\"\\\\n\"<<r<<endl;\\n        }\\n\\n        string line = string(maxWidth, \\' \\');\\n        auto& w0 = words[wIdx[i].first[0]];\\n        copy(w0.begin(), w0.end(), line.begin()); // Copy the first word\\n\\n        int pos = w0.size();\\n        for (int j = 1; j < numWords; j++) {\\n            if (i != wIdx.size() - 1) {\\n                pos += numSpaces +(remainingSpaces > 0 ? 1 : 0);\\n                remainingSpaces--;\\n            }\\n            else pos++;\\n            auto& w = words[wIdx[i].first[j]];\\n            copy(w.begin(), w.end(), line.begin() + pos); // Copy each word\\n            pos += w.size();\\n        }\\n        ans.push_back(line);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 948678,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def justify(part, totalLen):\\n        \\n            if len(part) == 1:\\n                return justifyLeft(part, totalLen)\\n            \\n            tatalSpaces = maxWidth - totalLen\\n            minSpaces = tatalSpaces // (len(part) - 1)\\n            extraSpaces = tatalSpaces % (len(part) - 1)\\n            \\n            spaces = [\\'\\'] * len(words)\\n            for i in range(1, len(words)):\\n                space = \\' \\' * minSpaces\\n                if extraSpaces > 0:\\n                    space += \\' \\'\\n                    extraSpaces -= 1\\n                spaces[i] = space\\n\\n            return \"\".join(map(lambda x: x[0] + x[1], zip(spaces, part)))\\n        \\n        def justifyLeft(part, totalLen):\\n            extraSpaces = len(part) - 1 if len(part) >= 2 else 0             \\n            return \" \".join(part) + \\' \\' * (maxWidth - totalLen - extraSpaces)\\n        \\n        result = []\\n        \\n        currentLen = 0\\n        current = []\\n        \\n        for word in words:\\n            spaces = len(current)\\n            \\n            if currentLen + len(word) + spaces > maxWidth:\\n                row = justify(current, currentLen)                    \\n                result.append(row)\\n\\n                currentLen = 0                \\n                current = []\\n                \\n            current.append(word)\\n            currentLen += len(word)\\n\\n        row = justifyLeft(current, currentLen)                    \\n        result.append(row)\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def justify(part, totalLen):\\n        \\n            if len(part) == 1:\\n                return justifyLeft(part, totalLen)\\n            \\n            tatalSpaces = maxWidth - totalLen\\n            minSpaces = tatalSpaces // (len(part) - 1)\\n            extraSpaces = tatalSpaces % (len(part) - 1)\\n            \\n            spaces = [\\'\\'] * len(words)\\n            for i in range(1, len(words)):\\n                space = \\' \\' * minSpaces\\n                if extraSpaces > 0:\\n                    space += \\' \\'\\n                    extraSpaces -= 1\\n                spaces[i] = space\\n\\n            return \"\".join(map(lambda x: x[0] + x[1], zip(spaces, part)))\\n        \\n        def justifyLeft(part, totalLen):\\n            extraSpaces = len(part) - 1 if len(part) >= 2 else 0             \\n            return \" \".join(part) + \\' \\' * (maxWidth - totalLen - extraSpaces)\\n        \\n        result = []\\n        \\n        currentLen = 0\\n        current = []\\n        \\n        for word in words:\\n            spaces = len(current)\\n            \\n            if currentLen + len(word) + spaces > maxWidth:\\n                row = justify(current, currentLen)                    \\n                result.append(row)\\n\\n                currentLen = 0                \\n                current = []\\n                \\n            current.append(word)\\n            currentLen += len(word)\\n\\n        row = justifyLeft(current, currentLen)                    \\n        result.append(row)\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952386,
                "title": "beginner-friendly-simple-java-solution-easy-to-understand-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n#### This code  justifies an array of words within a given `maxWidth`:\\n1. Iterate through words, grouping them into lines that fit within `maxWidth`, and adjust spaces between words to achieve full justification. Add each line to the `result` list.\\n2. Return the `result` list containing justified lines.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize an empty list `result` to store the final justified lines.\\n- Loop through the array of words:\\n         - For each iteration, set i as the current index and initialize `wordCount` and `lineLength` to 0.\\n         - Increment `wordCount` while the accumulated length of words within the line does not exceed `maxWidth`.\\n- Inside the loop, create a `lineBuilder` and start appending the words:\\n            - If `wordCount` is 1 or at the end of the array, append the words with single spaces in between.\\n            - Otherwise, calculate `totalSpaces` and `extraSpaces` for justification.\\n            - Append words with calculated spaces.\\n- Add the completed line (in `lineBuilder`) to the `result` list.\\n- Continue the outer loop using the next index after the current line (`i += wordCount`).\\n- After processing all lines, return the `result` list.\\n\\n    \\n    \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        \\n        for (int i = 0, wordCount, lineLength; i < words.length; i += wordCount) {\\n            for (wordCount = 0, lineLength = 0; \\n                 i + wordCount < words.length && \\n                 lineLength + words[i + wordCount].length() + wordCount <= maxWidth; \\n                 wordCount++) {\\n                lineLength += words[i + wordCount].length();\\n            }\\n            \\n            StringBuilder lineBuilder = new StringBuilder(words[i]);\\n            \\n            if (wordCount == 1 || i + wordCount == words.length) {\\n                for (int j = 1; j < wordCount; j++) {\\n                    lineBuilder.append(\" \").append(words[i + j]);\\n                }\\n                lineBuilder.append(\" \".repeat(maxWidth - lineBuilder.length()));\\n            } else {\\n                int totalSpaces = (maxWidth - lineLength) / (wordCount - 1);\\n                int extraSpaces = (maxWidth - lineLength) % (wordCount - 1);\\n                \\n                for (int j = 1; j < wordCount; j++) {\\n                    int spacesToAdd = totalSpaces + (extraSpaces-- > 0 ? 1 : 0);\\n                    lineBuilder.append(\" \".repeat(spacesToAdd)).append(words[i + j]);\\n                }\\n            } \\n            result.add(lineBuilder.toString());\\n        }   \\n        return result;\\n    }\\n}\\n\\n```\\n# If you like the solution please Upvote.\\n![29c341f2-e223-4bc6-8894-efb9ed7a6744_1692496789.0986528.png](https://assets.leetcode.com/users/images/2c413272-3028-4385-896a-9f49ca949dd3_1692845736.9024503.png)\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        \\n        for (int i = 0, wordCount, lineLength; i < words.length; i += wordCount) {\\n            for (wordCount = 0, lineLength = 0; \\n                 i + wordCount < words.length && \\n                 lineLength + words[i + wordCount].length() + wordCount <= maxWidth; \\n                 wordCount++) {\\n                lineLength += words[i + wordCount].length();\\n            }\\n            \\n            StringBuilder lineBuilder = new StringBuilder(words[i]);\\n            \\n            if (wordCount == 1 || i + wordCount == words.length) {\\n                for (int j = 1; j < wordCount; j++) {\\n                    lineBuilder.append(\" \").append(words[i + j]);\\n                }\\n                lineBuilder.append(\" \".repeat(maxWidth - lineBuilder.length()));\\n            } else {\\n                int totalSpaces = (maxWidth - lineLength) / (wordCount - 1);\\n                int extraSpaces = (maxWidth - lineLength) % (wordCount - 1);\\n                \\n                for (int j = 1; j < wordCount; j++) {\\n                    int spacesToAdd = totalSpaces + (extraSpaces-- > 0 ? 1 : 0);\\n                    lineBuilder.append(\" \".repeat(spacesToAdd)).append(words[i + j]);\\n                }\\n            } \\n            result.add(lineBuilder.toString());\\n        }   \\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707606,
                "title": "c-readable-modularized-code",
                "content": "```\\nclass Solution {\\nprivate:\\n    /** \\n     * Returns string containing left-aligned line formed using words[low..high]\\n     * @param maxWidth: Total length of the line\\n     */\\n    string getLeftAlignedLine(int low, int high, vector<string>& words, int maxWidth) {\\n        string line;\\n        for(int i = low; i <= high; i++)\\n            line += words[i] + \" \";\\n        line.pop_back();\\n        line += string(maxWidth - line.size(), \\' \\');\\n        return line;\\n    }\\n    \\n    /**\\n     * Returns string containing justified line formed using words[low..high]\\n     * @param extraSpace: Number of extra spaces that need to be spread evenly between\\n     *      the words. This count doesn\\'t include the single spaces that already need\\n     *      to be inserted between each pair of words.\\n     */\\n    string getJustifiedLine(int low, int high, vector<string>& words, int extraSpaces) {\\n        string line;\\n        int n = high - low + 1, slots = n - 1;\\n        \\n        // The number of extra spaces that must be inserted between every pair of words.\\n        // Some pairs might have (space+1) spaces between them if the total is in excess.\\n        int space = slots > 0 ? extraSpaces / slots : -1;        \\n\\n        for(int i = 0; i < n - 1; i++) {\\n            line += words[low + i] + \" \" + string(space, \\' \\');\\n            slots--;\\n            extraSpaces -= space;\\n            \\n            // Greedily add an extra space after the current word if the remaining\\n            // spaces are still in excess.\\n            if(extraSpaces > slots * space) {\\n                line += \" \";\\n                extraSpaces--;\\n            }\\n        }\\n        line += words[high] + string(extraSpaces, \\' \\');\\n        return line;\\n    }\\n\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        for(int i = 0; i < words.size(); i++) {\\n            int currWidth = 0;\\n            int j = i;\\n            while(j < words.size() && (currWidth + words[j].size()) <= maxWidth)\\n                currWidth += words[j++].size() + 1;\\n            j < words.size()\\n                ? res.push_back(getJustifiedLine(i, j - 1, words, maxWidth - currWidth + 1))\\n                : res.push_back(getLeftAlignedLine(i, j - 1, words, maxWidth));\\n            i = j - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    /** \\n     * Returns string containing left-aligned line formed using words[low..high]\\n     * @param maxWidth: Total length of the line\\n     */\\n    string getLeftAlignedLine(int low, int high, vector<string>& words, int maxWidth) {\\n        string line;\\n        for(int i = low; i <= high; i++)\\n            line += words[i] + \" \";\\n        line.pop_back();\\n        line += string(maxWidth - line.size(), \\' \\');\\n        return line;\\n    }\\n    \\n    /**\\n     * Returns string containing justified line formed using words[low..high]\\n     * @param extraSpace: Number of extra spaces that need to be spread evenly between\\n     *      the words. This count doesn\\'t include the single spaces that already need\\n     *      to be inserted between each pair of words.\\n     */\\n    string getJustifiedLine(int low, int high, vector<string>& words, int extraSpaces) {\\n        string line;\\n        int n = high - low + 1, slots = n - 1;\\n        \\n        // The number of extra spaces that must be inserted between every pair of words.\\n        // Some pairs might have (space+1) spaces between them if the total is in excess.\\n        int space = slots > 0 ? extraSpaces / slots : -1;        \\n\\n        for(int i = 0; i < n - 1; i++) {\\n            line += words[low + i] + \" \" + string(space, \\' \\');\\n            slots--;\\n            extraSpaces -= space;\\n            \\n            // Greedily add an extra space after the current word if the remaining\\n            // spaces are still in excess.\\n            if(extraSpaces > slots * space) {\\n                line += \" \";\\n                extraSpaces--;\\n            }\\n        }\\n        line += words[high] + string(extraSpaces, \\' \\');\\n        return line;\\n    }\\n\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        for(int i = 0; i < words.size(); i++) {\\n            int currWidth = 0;\\n            int j = i;\\n            while(j < words.size() && (currWidth + words[j].size()) <= maxWidth)\\n                currWidth += words[j++].size() + 1;\\n            j < words.size()\\n                ? res.push_back(getJustifiedLine(i, j - 1, words, maxWidth - currWidth + 1))\\n                : res.push_back(getLeftAlignedLine(i, j - 1, words, maxWidth));\\n            i = j - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633915,
                "title": "fast-and-thoroughly-explained-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        const int totalWords = words.size()-1;\\n        for (int begin=0, moreWords=0; begin<=totalWords; begin=moreWords) {\\n            string currentBlock(maxWidth, \\' \\');\\n            /* In problem statement, it is specified that each word is guaranteed to be\\n             * grether than 0 and not exceed maxWidth, so I can safely add first word. */\\n            currentBlock.replace(0, words[begin].size(), words[begin]);\\n            /* Now current block of text is ready with first word and remainig spaces,\\n             * I just need to calculate how many more words I can fit in this block. */\\n            int remainingSpace = maxWidth - words[begin].size();\\n            for (moreWords=begin+1; moreWords <=totalWords && words[moreWords].size() < remainingSpace; moreWords++) {\\n                /* First word in current block is already added before this for loop.\\n                 * Additional word(s) can be added in current justification block. As this\\n                 * is additional word, at least one space is needed in calculation\\n                 * for remaining space. Above \\'<\\' condition make sure that we have space for\\n                 * one additional space */\\n                remainingSpace -= words[moreWords].size()+1;\\n            }\\n            /* Word joints are total separating gap between words, for which we need to do\\n             * space management */\\n            int wordJoints = moreWords - begin -1;\\n            if (wordJoints) {\\n                /*Ok so we have more than one word in this justification block*/\\n                int evenlyDistributedSpace = 1; /*One space is already provisioned in above loop */\\n                int unEvenSpace = 0;\\n                if (moreWords <= totalWords) {\\n                /* Control is here means current justification block is not the last\\n                 * block, so we need to do some mathematics on remaining space and evenly\\n                 * distribute it between the words (word joints). Remember for last block\\n                 * this is not needed as it is left aligned and additional words are only\\n                 * placed one white space apart */\\n                    evenlyDistributedSpace += remainingSpace / wordJoints;\\n                    unEvenSpace = remainingSpace % wordJoints;\\n                }\\n                for (int i=begin+1, index=words[begin].size(); i < moreWords; i++) {\\n                    index += evenlyDistributedSpace + (unEvenSpace-- > 0);\\n                    currentBlock.replace(index, words[i].size(), words[i]);\\n                    index += words[i].size();\\n                }\\n            }\\n            result.push_back(currentBlock);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        const int totalWords = words.size()-1;\\n        for (int begin=0, moreWords=0; begin<=totalWords; begin=moreWords) {\\n            string currentBlock(maxWidth, \\' \\');\\n            /* In problem statement, it is specified that each word is guaranteed to be\\n             * grether than 0 and not exceed maxWidth, so I can safely add first word. */\\n            currentBlock.replace(0, words[begin].size(), words[begin]);\\n            /* Now current block of text is ready with first word and remainig spaces,\\n             * I just need to calculate how many more words I can fit in this block. */\\n            int remainingSpace = maxWidth - words[begin].size();\\n            for (moreWords=begin+1; moreWords <=totalWords && words[moreWords].size() < remainingSpace; moreWords++) {\\n                /* First word in current block is already added before this for loop.\\n                 * Additional word(s) can be added in current justification block. As this\\n                 * is additional word, at least one space is needed in calculation\\n                 * for remaining space. Above \\'<\\' condition make sure that we have space for\\n                 * one additional space */\\n                remainingSpace -= words[moreWords].size()+1;\\n            }\\n            /* Word joints are total separating gap between words, for which we need to do\\n             * space management */\\n            int wordJoints = moreWords - begin -1;\\n            if (wordJoints) {\\n                /*Ok so we have more than one word in this justification block*/\\n                int evenlyDistributedSpace = 1; /*One space is already provisioned in above loop */\\n                int unEvenSpace = 0;\\n                if (moreWords <= totalWords) {\\n                /* Control is here means current justification block is not the last\\n                 * block, so we need to do some mathematics on remaining space and evenly\\n                 * distribute it between the words (word joints). Remember for last block\\n                 * this is not needed as it is left aligned and additional words are only\\n                 * placed one white space apart */\\n                    evenlyDistributedSpace += remainingSpace / wordJoints;\\n                    unEvenSpace = remainingSpace % wordJoints;\\n                }\\n                for (int i=begin+1, index=words[begin].size(); i < moreWords; i++) {\\n                    index += evenlyDistributedSpace + (unEvenSpace-- > 0);\\n                    currentBlock.replace(index, words[i].size(), words[i]);\\n                    index += words[i].size();\\n                }\\n            }\\n            result.push_back(currentBlock);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529356,
                "title": "python-3-o-n",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        count, cur_words = 0, []\\n        res = []\\n        for word in words:\\n            if count+ len(word) + len(cur_words) > maxWidth:\\n                spaces = maxWidth - count\\n                for i in range(spaces):\\n                    cur_words[i % (len(cur_words)-1 if len(cur_words)>1 else 1)] += \\' \\'\\n                res.append(\"\".join(cur_words))\\n                count, cur_words = 0, []\\n            count+=len(word)\\n            cur_words.append(word)\\n        \\n\\t\\t# last row\\n        spaces = maxWidth - count - (len(cur_words)-1)\\n        res.append(\" \".join(cur_words)+\" \"*spaces)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        count, cur_words = 0, []\\n        res = []\\n        for word in words:\\n            if count+ len(word) + len(cur_words) > maxWidth:\\n                spaces = maxWidth - count\\n                for i in range(spaces):\\n                    cur_words[i % (len(cur_words)-1 if len(cur_words)>1 else 1)] += \\' \\'\\n                res.append(\"\".join(cur_words))\\n                count, cur_words = 0, []\\n            count+=len(word)\\n            cur_words.append(word)\\n        \\n\\t\\t# last row\\n        spaces = maxWidth - count - (len(cur_words)-1)\\n        res.append(\" \".join(cur_words)+\" \"*spaces)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117010,
                "title": "clear-and-readable-c-solution-beats-100",
                "content": "I'm not sure if they upgraded the C# compiler, but this solution appears to be 100ms faster than previous solutions. Additionally, it is intuitive to read.\n\n```\npublic class Line {\n    private readonly int TotalChars;\n    private int CharsLeft;\n    public List<string> Words;\n    \n    public int Spaces {\n        get {\n            int allWordsLen = Words.Aggregate(0, (prev, next) => prev + next.Length);\n            return TotalChars - allWordsLen - (Words.Count - 1);\n        }\n    }\n    public Line(int avail) {\n        TotalChars = avail;\n        CharsLeft = avail;\n        \n        Words = new List<string>();\n    }\n    public bool Consume(string word) {\n        if (word.Length <= CharsLeft) {\n            CharsLeft -= word.Length + 1; //+1 for a space\n            Words.Add(word);\n            return true;\n        }\n        \n        return false;\n    }\n    \n    public override string ToString() {        \n        return Words.Aggregate((prev, next) => string.Format(\"{0} {1}\", prev, next));  \n    }\n}\n\npublic class Solution {\n    \n    public static string Justify(Line line) {\n        //We want to distribute the available spaces into a few different buckets.\n        //To be correct, the last bucket must always contain zero spaces.\n        //This is why I'm % by buckets.Length - 1 in the loop\n        \n        int[] buckets = new int[line.Words.Count];\n        int totalToDistribute = line.Spaces;\n        int index = 0;\n        \n        int totalBuckets = Math.Max(buckets.Length - 1, 1);\n        while (totalToDistribute > 0) {\n            buckets[index]++;\n            totalToDistribute--;\n            index = (index + 1) % totalBuckets;\n        }\n        \n        var withPadding = line.Words.Zip(buckets, (word, bucket) => {\n            return string.Concat(word, new String(' ', bucket));\n        });\n        \n        return withPadding.Aggregate((first, second) => string.Format(\"{0} {1}\", first, second));\n    }\n    \n    public static string LeftJustify(Line line) {\n        return string.Concat(line.ToString(), new String(' ', line.Spaces));\n    }\n    \n    public IList<string> FullJustify(string[] wordsArray, int maxWidth) {\n        Queue<string> words = new Queue<string>(wordsArray);\n        List<Line> lines = new List<Line>();\n        \n        while (words.Count > 0) {\n            Line line = new Line(maxWidth);\n            while (words.Count > 0 && line.Consume(words.Peek())) {\n                words.Dequeue();\n            }\n            lines.Add(line);\n        }\n        \n        //We justify all the lines until the very last\n        List<string> result = new List<string>();\n        for (int i = 0; i < lines.Count - 1; i++) {\n            result.Add(Justify(lines[i]));\n        }\n        //And then do a special left justify on the last.\n        result.Add(LeftJustify(lines.Last()));\n        return result;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\npublic class Line {\n    private readonly int TotalChars;\n    private int CharsLeft;\n    public List<string> Words;\n    \n    public int Spaces {\n        get {\n            int allWordsLen = Words.Aggregate(0, (prev, next) => prev + next.Length);\n            return TotalChars - allWordsLen - (Words.Count - 1);\n        }\n    }\n    public Line(int avail) {\n        TotalChars = avail;\n        CharsLeft = avail;\n        \n        Words = new List<string>();\n    }\n    public bool Consume(string word) {\n        if (word.Length <= CharsLeft) {\n            CharsLeft -= word.Length + 1; //+1 for a space\n            Words.Add(word);\n            return true;\n        }\n        \n        return false;\n    }\n    \n    public override string ToString() {        \n        return Words.Aggregate((prev, next) => string.Format(\"{0} {1}\", prev, next));  \n    }\n}\n\npublic class Solution {\n    \n    public static string Justify(Line line) {\n        //We want to distribute the available spaces into a few different buckets.\n        //To be correct, the last bucket must always contain zero spaces.\n        //This is why I'm % by buckets.Length - 1 in the loop\n        \n        int[] buckets = new int[line.Words.Count];\n        int totalToDistribute = line.Spaces;\n        int index = 0;\n        \n        int totalBuckets = Math.Max(buckets.Length - 1, 1);\n        while (totalToDistribute > 0) {\n            buckets[index]++;\n            totalToDistribute--;\n            index = (index + 1) % totalBuckets;\n        }\n        \n        var withPadding = line.Words.Zip(buckets, (word, bucket) => {\n            return string.Concat(word, new String(' ', bucket));\n        });\n        \n        return withPadding.Aggregate((first, second) => string.Format(\"{0} {1}\", first, second));\n    }\n    \n    public static string LeftJustify(Line line) {\n        return string.Concat(line.ToString(), new String(' ', line.Spaces));\n    }\n    \n    public IList<string> FullJustify(string[] wordsArray, int maxWidth) {\n        Queue<string> words = new Queue<string>(wordsArray);\n        List<Line> lines = new List<Line>();\n        \n        while (words.Count > 0) {\n            Line line = new Line(maxWidth);\n            while (words.Count > 0 && line.Consume(words.Peek())) {\n                words.Dequeue();\n            }\n            lines.Add(line);\n        }\n        \n        //We justify all the lines until the very last\n        List<string> result = new List<string>();\n        for (int i = 0; i < lines.Count - 1; i++) {\n            result.Add(Justify(lines[i]));\n        }\n        //And then do a special left justify on the last.\n        result.Add(LeftJustify(lines.Last()));\n        return result;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 24974,
                "title": "concise-solution-in-ruby",
                "content": "fit as many words into one line as possible, then join the words with proper number of spaces.\\n\\n    def full_justify(words, max_width)\\n      v, line = [], []\\n      words.each do |word|\\n        if (line+[word]).join(' ').size > max_width\\n          v.push(join_line(line, max_width))\\n          line = []\\n        end\\n        line.push(word)\\n      end\\n      v.push(join_line(line, max_width, true))\\n    end\\n    \\n    def join_line(line, max_width, last = false)\\n      return line.join(' ') + ' '*(max_width-line.join(' ').size) if (line.size == 1 or last == true)\\n      space, extra = (max_width-line.join.size).divmod(line.size-1)\\n      line[0..extra].join(' '*(space+1)) + ' '*space + line[extra+1..-1].join(' '*space)\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "fit as many words into one line as possible, then join the words with proper number of spaces.\\n\\n    def full_justify(words, max_width)\\n      v, line = [], []\\n      words.each do |word|\\n        if (line+[word]).join(' ').size > max_width\\n          v.push(join_line(line, max_width))\\n          line = []\\n        end\\n        line.push(word)\\n      end\\n      v.push(join_line(line, max_width, true))\\n    end\\n    \\n    def join_line(line, max_width, last = false)\\n      return line.join(' ') + ' '*(max_width-line.join(' ').size) if (line.size == 1 or last == true)\\n      space, extra = (max_width-line.join.size).divmod(line.size-1)\\n      line[0..extra].join(' '*(space+1)) + ' '*space + line[extra+1..-1].join(' '*space)\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 1324217,
                "title": "python-version-of-the-nicely-broken-java-code",
                "content": "Python version of the amazing Java code https://leetcode.com/problems/text-justification/discuss/24902/Java-easy-to-understand-broken-into-several-functions\\n```\\n\\'\\'\\'\\nAlgorithm: https://leetcode.com/problems/text-justification/discuss/24902/Java-easy-to-understand-broken-into-several-functions\\n1. while there are words:\\n2.     collect words that will go in the same line\\n3.     fix spaces in these words\\n\\'\\'\\'\\nclass Solution:\\n    def findSameLineWords(self, start, maxWidth, words):\\n        chars = 0\\n        \\'\\'\\'\\n        maxWidth + 1 cause the last word of every sentence doesn\\'t have a space, so in case the last word of the sentence fits exactly we need to accomodate the fact that it has no trailing space\\n        \"enough to explain to\" maxWidth=20\\n        \\'\\'\\' \\n        while start < len(words) and chars + len(words[start]) + 1 <= maxWidth + 1:\\n            chars += len(words[start]) + 1\\n            start += 1\\n        return start - 1\\n    \\n    \\n    def fixSpaces(self, start, end, words, maxWidth):\\n        generate_spaces = lambda x: \\' \\' * x\\n        \\n        answer = []\\n        \\n        # if only 1 word: pad spaces at the end\\n        if end == start:\\n            answer.append(words[start])\\n            answer.append(generate_spaces(maxWidth - len(words[start])))\\n            return \\'\\'.join(answer)\\n        \\n        # special care is required for the last line as it has no spaces between words \\n        is_last_line = (end == len(words) - 1)\\n        total_chars = sum(len(words[i]) for i in range(start, end + 1))\\n        total_spaces = maxWidth - total_chars \\n        even_spaces = total_spaces // (end - start) if is_last_line is False else 1\\n        remainder_spaces = total_spaces - even_spaces * (end - start) if is_last_line is False else 0\\n        \\n        # print(words[start : end + 1], \\'total_chars:\\', total_chars, \\'total_spaces:\\', total_spaces, \\'even_spaces:\\', even_spaces, \\'remainder_spaces:\\', remainder_spaces)\\n        \\n        for idx in range(start, end + 1):\\n            answer.append(words[idx])\\n            answer.append(generate_spaces(even_spaces))\\n            if remainder_spaces > 0:\\n                answer.append(generate_spaces(1))\\n                remainder_spaces -= 1\\n        sentence = \\'\\'.join(answer[: -1])     # remove the trailing spaces\\n        if is_last_line is False:            # if not the last sentence return without the trailing spaces\\n            return sentence\\n        else:                                # add the trailing spaces\\n            return sentence + generate_spaces(maxWidth - len(sentence))\\n                \\n        \\n        \\n    def fullJustify(self, words, maxWidth):\\n        start = 0\\n        answer = []\\n        while start < len(words):\\n            end = self.findSameLineWords(start, maxWidth, words)\\n            answer.append(self.fixSpaces(start, end, words, maxWidth))\\n            # print(start, end)\\n            start = end + 1\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nAlgorithm: https://leetcode.com/problems/text-justification/discuss/24902/Java-easy-to-understand-broken-into-several-functions\\n1. while there are words:\\n2.     collect words that will go in the same line\\n3.     fix spaces in these words\\n\\'\\'\\'\\nclass Solution:\\n    def findSameLineWords(self, start, maxWidth, words):\\n        chars = 0\\n        \\'\\'\\'\\n        maxWidth + 1 cause the last word of every sentence doesn\\'t have a space, so in case the last word of the sentence fits exactly we need to accomodate the fact that it has no trailing space\\n        \"enough to explain to\" maxWidth=20\\n        \\'\\'\\' \\n        while start < len(words) and chars + len(words[start]) + 1 <= maxWidth + 1:\\n            chars += len(words[start]) + 1\\n            start += 1\\n        return start - 1\\n    \\n    \\n    def fixSpaces(self, start, end, words, maxWidth):\\n        generate_spaces = lambda x: \\' \\' * x\\n        \\n        answer = []\\n        \\n        # if only 1 word: pad spaces at the end\\n        if end == start:\\n            answer.append(words[start])\\n            answer.append(generate_spaces(maxWidth - len(words[start])))\\n            return \\'\\'.join(answer)\\n        \\n        # special care is required for the last line as it has no spaces between words \\n        is_last_line = (end == len(words) - 1)\\n        total_chars = sum(len(words[i]) for i in range(start, end + 1))\\n        total_spaces = maxWidth - total_chars \\n        even_spaces = total_spaces // (end - start) if is_last_line is False else 1\\n        remainder_spaces = total_spaces - even_spaces * (end - start) if is_last_line is False else 0\\n        \\n        # print(words[start : end + 1], \\'total_chars:\\', total_chars, \\'total_spaces:\\', total_spaces, \\'even_spaces:\\', even_spaces, \\'remainder_spaces:\\', remainder_spaces)\\n        \\n        for idx in range(start, end + 1):\\n            answer.append(words[idx])\\n            answer.append(generate_spaces(even_spaces))\\n            if remainder_spaces > 0:\\n                answer.append(generate_spaces(1))\\n                remainder_spaces -= 1\\n        sentence = \\'\\'.join(answer[: -1])     # remove the trailing spaces\\n        if is_last_line is False:            # if not the last sentence return without the trailing spaces\\n            return sentence\\n        else:                                # add the trailing spaces\\n            return sentence + generate_spaces(maxWidth - len(sentence))\\n                \\n        \\n        \\n    def fullJustify(self, words, maxWidth):\\n        start = 0\\n        answer = []\\n        while start < len(words):\\n            end = self.findSameLineWords(start, maxWidth, words)\\n            answer.append(self.fixSpaces(start, end, words, maxWidth))\\n            # print(start, end)\\n            start = end + 1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129791,
                "title": "java-solution-with-explanation-0-ms",
                "content": "The idea was to keep adding words to a buffer (an ArrayList) while the width is under the maxWidth and build a new line if it overflows.\\nIn particular, a width is the sum of following two values ```A``` and ```B```:\\n\\n- ```A``` Sum of number of characters of words in the buffer\\n- ```B``` Minimal number of necessary spaces for building a line from the words in the buffer\\n\\n```B``` can be simply calculated from the size of the buffer.\\nI.e. if we want to build a line from N words then we need at least N-1 spaces in total to separate each word.\\n\\nWhen we build a new line from the words in the buffer, we will need ```maxWidth - A```  spaces in total.\\nDepending on if it is the last line or not, we need to distribute these spaces accordingly.\\n\\nTime complexity: O(N): N is number of words\\nSpace complexity: O(N): In worst case, I\\'ll store all words to the buffer\\n\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> answer = new ArrayList<>();\\n        \\n        List<String> buffer = new ArrayList<>();\\n        \\n        // Sum of characters of words in the buffer\\n        int sumChars = 0;\\n        \\n        for(int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            \\n            // Build a new line when it exceeds the maxWidth if you append the current word to the buffer too.\\n            // buffer.size() represents the minimal number of spaces we need to build a line.\\n            if(word.length() + sumChars + buffer.size() > maxWidth) {\\n                // maxWidth - sumChars is the total number of spaces we need to build this line\\n                String line = buildLine(buffer, maxWidth - sumChars, false);\\n                answer.add(line);\\n                sumChars = 0;\\n                buffer.clear();\\n            }\\n            \\n            sumChars += word.length();\\n            buffer.add(word);\\n            \\n            // Build the last line if it is the last word\\n            if(i == words.length - 1) {\\n                String line = buildLine(buffer, maxWidth - sumChars, true);\\n                answer.add(line);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    // Helper method that builds a line from a list of words and number of spaces to be distributed.\\n    private String buildLine(List<String> words, int spaces, boolean isLastLine) {\\n        StringBuilder builder = new StringBuilder();\\n        \\n        // Last line: separate the words with single spaces\\n        if(isLastLine) {\\n            for(Iterator<String> it = words.iterator(); it.hasNext();) {\\n                builder.append(it.next());\\n                \\n                if(it.hasNext()) {\\n                    builder.append(\" \");\\n                    spaces--;\\n                }\\n            }\\n        // Otherwise, calculate necessary amount of spaces to be add in each iteration\\n        } else {\\n            for(int i = 0; i < words.size(); i++) {\\n                builder.append(words.get(i));\\n                \\n                if(i < words.size() -1) {\\n                    // If we still have N words in the list then we need to distribute the remaining spaces to N-1 slots.\\n                    int divisor = (words.size() - i) - 1;\\n                    int spacesForThisSlot = (spaces + divisor - 1) / divisor; // round up\\n                    \\n                    for(int j = 0; j < spacesForThisSlot; j++) {\\n                        builder.append(\" \");\\n                        spaces--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // Fill the rest of the line with spaces when there are leftovers\\n        // This happens if it is the last line or the words list had only one element\\n        for(int i = 0; i < spaces; i++) {\\n            builder.append(\" \");\\n        }\\n        \\n        return builder.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```A```\n```B```\n```A```\n```B```\n```B```\n```maxWidth - A```\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> answer = new ArrayList<>();\\n        \\n        List<String> buffer = new ArrayList<>();\\n        \\n        // Sum of characters of words in the buffer\\n        int sumChars = 0;\\n        \\n        for(int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            \\n            // Build a new line when it exceeds the maxWidth if you append the current word to the buffer too.\\n            // buffer.size() represents the minimal number of spaces we need to build a line.\\n            if(word.length() + sumChars + buffer.size() > maxWidth) {\\n                // maxWidth - sumChars is the total number of spaces we need to build this line\\n                String line = buildLine(buffer, maxWidth - sumChars, false);\\n                answer.add(line);\\n                sumChars = 0;\\n                buffer.clear();\\n            }\\n            \\n            sumChars += word.length();\\n            buffer.add(word);\\n            \\n            // Build the last line if it is the last word\\n            if(i == words.length - 1) {\\n                String line = buildLine(buffer, maxWidth - sumChars, true);\\n                answer.add(line);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    // Helper method that builds a line from a list of words and number of spaces to be distributed.\\n    private String buildLine(List<String> words, int spaces, boolean isLastLine) {\\n        StringBuilder builder = new StringBuilder();\\n        \\n        // Last line: separate the words with single spaces\\n        if(isLastLine) {\\n            for(Iterator<String> it = words.iterator(); it.hasNext();) {\\n                builder.append(it.next());\\n                \\n                if(it.hasNext()) {\\n                    builder.append(\" \");\\n                    spaces--;\\n                }\\n            }\\n        // Otherwise, calculate necessary amount of spaces to be add in each iteration\\n        } else {\\n            for(int i = 0; i < words.size(); i++) {\\n                builder.append(words.get(i));\\n                \\n                if(i < words.size() -1) {\\n                    // If we still have N words in the list then we need to distribute the remaining spaces to N-1 slots.\\n                    int divisor = (words.size() - i) - 1;\\n                    int spacesForThisSlot = (spaces + divisor - 1) / divisor; // round up\\n                    \\n                    for(int j = 0; j < spacesForThisSlot; j++) {\\n                        builder.append(\" \");\\n                        spaces--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // Fill the rest of the line with spaces when there are leftovers\\n        // This happens if it is the last line or the words list had only one element\\n        for(int i = 0; i < spaces; i++) {\\n            builder.append(\" \");\\n        }\\n        \\n        return builder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 908663,
                "title": "short-java",
                "content": "The idea is from [@ashish-sjc](https://leetcode.com/problems/text-justification/discuss/24891/Concise-python-solution-10-lines./303690). \\n1. Use List<StringBuilder> to store a line so we can add space after each word without creating a new string.\\n2. Iterate through each word, add to the current line, if current line is full, format the current line and add word to next line.\\n3. In #2, a line is fully justified when the next word does not fit the line. In other words, the current line won\\'t be fully justified until we process the next word. Since the last line does not have the next word, it won\\'t be fully justified. This fits the requirement perfectly because the last line requires a different format, left justification.\\n```\\n\\t public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res=new ArrayList<>();\\n        List<StringBuilder> line=new ArrayList<>();\\n        int totLetters=0;\\n        for(String word:words) {\\n            int len=word.length(), size=line.size();\\n            if(totLetters+size+len>maxWidth) {\\n                int space = maxWidth - totLetters;\\n                if(size==1) {\\n                    res.add(line.get(0).toString()+\" \".repeat(space));\\n                } else {\\n                    int spc=space/(size-1), r=space%(size-1);\\n                    for(int i=0;i<r;i++)\\n                        line.get(i).append(\" \");\\n                    res.add(String.join(\" \".repeat(spc),line));\\n                }\\n                totLetters=0;\\n                line.clear();\\n            }\\n            totLetters+=len;\\n            line.add(new StringBuilder(word));\\n        }\\n        String last=String.join(\" \",line);\\n        res.add(String.format(\"%-\"+maxWidth+\"s\",last));\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\t public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res=new ArrayList<>();\\n        List<StringBuilder> line=new ArrayList<>();\\n        int totLetters=0;\\n        for(String word:words) {\\n            int len=word.length(), size=line.size();\\n            if(totLetters+size+len>maxWidth) {\\n                int space = maxWidth - totLetters;\\n                if(size==1) {\\n                    res.add(line.get(0).toString()+\" \".repeat(space));\\n                } else {\\n                    int spc=space/(size-1), r=space%(size-1);\\n                    for(int i=0;i<r;i++)\\n                        line.get(i).append(\" \");\\n                    res.add(String.join(\" \".repeat(spc),line));\\n                }\\n                totLetters=0;\\n                line.clear();\\n            }\\n            totLetters+=len;\\n            line.add(new StringBuilder(word));\\n        }\\n        String last=String.join(\" \",line);\\n        res.add(String.format(\"%-\"+maxWidth+\"s\",last));\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 672626,
                "title": "python3-a-concise-solution",
                "content": "This implementation is based on the amazing solution given by @sherlock321 in this [thread](https://leetcode.com/problems/text-justification/discuss/24891/Concise-python-solution-10-lines.). I\\'ve made a few changes to reflect my coding style. Credit goes to the original author. \\n\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans = []\\n        line, width = [], 0\\n        \\n        for word in words: \\n            if width + len(line) + len(word) > maxWidth: \\n                n, k = divmod(maxWidth - width, max(1, len(line)-1))\\n                for i in range(max(1, len(line)-1)): \\n                    line[i] += \" \" * (n + (i < k))\\n                ans.append(\"\".join(line))\\n                line, width = [], 0\\n            line.append(word)\\n            width += len(word)\\n            \\n        ans.append(\" \".join(line).ljust(maxWidth))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans = []\\n        line, width = [], 0\\n        \\n        for word in words: \\n            if width + len(line) + len(word) > maxWidth: \\n                n, k = divmod(maxWidth - width, max(1, len(line)-1))\\n                for i in range(max(1, len(line)-1)): \\n                    line[i] += \" \" * (n + (i < k))\\n                ans.append(\"\".join(line))\\n                line, width = [], 0\\n            line.append(word)\\n            width += len(word)\\n            \\n        ans.append(\" \".join(line).ljust(maxWidth))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 519796,
                "title": "go-0ms-solution-easy-to-understand",
                "content": "```go\\nfunc fullJustify(words []string, maxWidth int) []string {\\n\\tjustify := []string{}\\n\\tcurrent, curLength := []string{}, 0\\n\\tfor i, w := range words {\\n\\t\\tif curLength + len(current) + len(w) > maxWidth {\\n\\t\\t\\tif len(current) == 1 {\\n\\t\\t\\t\\t// only one word, all spaces are to the right of the word\\n\\t\\t\\t\\tcurLine := current[0] + strings.Repeat(\" \", maxWidth-len(current[0]))\\n\\t\\t\\t\\tjustify = append(justify, curLine)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdiff := maxWidth - curLength\\n\\t\\t\\t\\tspaces := diff / (len(current)-1)\\n\\t\\t\\t\\tmore := diff % (len(current)-1)\\n\\t\\t\\t\\tcurLine := bytes.Buffer{}\\n\\t\\t\\t\\tfor ci, cw := range current {\\n\\t\\t\\t\\t\\tcurLine.WriteString(cw)\\n\\t\\t\\t\\t\\tif ci != len(current) - 1 {\\n\\t\\t\\t\\t\\t\\tmoreBlanks := 0\\n\\t\\t\\t\\t\\t\\tif more > 0 {\\n\\t\\t\\t\\t\\t\\t\\tmoreBlanks = 1\\n\\t\\t\\t\\t\\t\\t\\tmore--\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurLine.WriteString(strings.Repeat(\" \", spaces+ moreBlanks))\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tjustify = append(justify, curLine.String())\\n\\t\\t\\t}\\n\\t\\t\\tcurrent, curLength = []string{}, 0\\n\\t\\t}\\n\\n\\t\\tcurLength += len(w)\\n\\t\\tcurrent = append(current, w)\\n\\n\\t\\t// last line, left justified and no extra space is inserted between words\\n\\t\\tif i == len(words) - 1 {\\n\\t\\t\\tlastLine := strings.Join(current, \" \")\\n\\t\\t\\tlastLine = lastLine + strings.Repeat(\" \", maxWidth-len(lastLine))\\n\\t\\t\\tjustify = append(justify, lastLine)\\n\\t\\t}\\n\\t}\\n\\treturn justify\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc fullJustify(words []string, maxWidth int) []string {\\n\\tjustify := []string{}\\n\\tcurrent, curLength := []string{}, 0\\n\\tfor i, w := range words {\\n\\t\\tif curLength + len(current) + len(w) > maxWidth {\\n\\t\\t\\tif len(current) == 1 {\\n\\t\\t\\t\\t// only one word, all spaces are to the right of the word\\n\\t\\t\\t\\tcurLine := current[0] + strings.Repeat(\" \", maxWidth-len(current[0]))\\n\\t\\t\\t\\tjustify = append(justify, curLine)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdiff := maxWidth - curLength\\n\\t\\t\\t\\tspaces := diff / (len(current)-1)\\n\\t\\t\\t\\tmore := diff % (len(current)-1)\\n\\t\\t\\t\\tcurLine := bytes.Buffer{}\\n\\t\\t\\t\\tfor ci, cw := range current {\\n\\t\\t\\t\\t\\tcurLine.WriteString(cw)\\n\\t\\t\\t\\t\\tif ci != len(current) - 1 {\\n\\t\\t\\t\\t\\t\\tmoreBlanks := 0\\n\\t\\t\\t\\t\\t\\tif more > 0 {\\n\\t\\t\\t\\t\\t\\t\\tmoreBlanks = 1\\n\\t\\t\\t\\t\\t\\t\\tmore--\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurLine.WriteString(strings.Repeat(\" \", spaces+ moreBlanks))\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tjustify = append(justify, curLine.String())\\n\\t\\t\\t}\\n\\t\\t\\tcurrent, curLength = []string{}, 0\\n\\t\\t}\\n\\n\\t\\tcurLength += len(w)\\n\\t\\tcurrent = append(current, w)\\n\\n\\t\\t// last line, left justified and no extra space is inserted between words\\n\\t\\tif i == len(words) - 1 {\\n\\t\\t\\tlastLine := strings.Join(current, \" \")\\n\\t\\t\\tlastLine = lastLine + strings.Repeat(\" \", maxWidth-len(lastLine))\\n\\t\\t\\tjustify = append(justify, lastLine)\\n\\t\\t}\\n\\t}\\n\\treturn justify\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 156704,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        curr_line = []\\n        curr_line_width = 0\\n        lines = []\\n        \\n        for word in words:\\n            if len(word) + curr_line_width + len(curr_line) > maxWidth:\\n                # Need to add justified line\\n                nspaces = len(curr_line) - 1 if len(curr_line) - 1 else 1\\n                for i in range(maxWidth - curr_line_width):\\n                    curr_line[i % nspaces] += \" \"\\n                lines.append(\"\".join(curr_line))\\n                curr_line = []\\n                curr_line_width = 0\\n            curr_line.append(word)\\n            curr_line_width += len(word)\\n        \\n        last_line = \" \".join(curr_line)\\n        last_line = last_line.strip()\\n        last_line = last_line + \" \"*(maxWidth - len(last_line))\\n        lines.append(last_line)\\n        return lines\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        curr_line = []\\n        curr_line_width = 0\\n        lines = []\\n        \\n        for word in words:\\n            if len(word) + curr_line_width + len(curr_line) > maxWidth:\\n                # Need to add justified line\\n                nspaces = len(curr_line) - 1 if len(curr_line) - 1 else 1\\n                for i in range(maxWidth - curr_line_width):\\n                    curr_line[i % nspaces] += \" \"\\n                lines.append(\"\".join(curr_line))\\n                curr_line = []\\n                curr_line_width = 0\\n            curr_line.append(word)\\n            curr_line_width += len(word)\\n        \\n        last_line = \" \".join(curr_line)\\n        last_line = last_line.strip()\\n        last_line = last_line + \" \"*(maxWidth - len(last_line))\\n        lines.append(last_line)\\n        return lines\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955974,
                "title": "c-beats-100-binary-search-detailed-explaination",
                "content": "# Intuition\\nUpon examining the problem, it becomes clear that the task involves determining the number of words that can fit on each line while considering the need for padding. The solution is achieved by first calculating the required padding for even distribution, with any extra padding allocated to the left side of the words.\\n\\nTo illustrate, the arrangement should resemble:\\n[**WORD1**]--*PADDING*--[**WORD2**]--*PADDING*--[**WORD3**]\\n\\nThe goal is to ensure that this entire construction spans a length equal to \"maxWidth\". The process for calculating word counts and arranging padding is elaborated in the forthcoming \"Approach\" section.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach to solving this problem can be divided into several steps:\\n\\n**Word Length Prefix Sum:** Construct an array to hold the lengths of individual words (or you can do the prefix sum directly), and another array for their prefix sum. The prefix sum array, being non-decreasing, allows efficient binary search. This binary search aids in determining the number of words that can fit within a given line length.\\n\\n**Predicate Function** - Feasibility Check: Define a predicate function called isPossible, which checks if a specific word count can fit within a line. This function relies on the prefix sum array and the given conditions to decide if a certain word count is feasible for the line length.\\n\\n**Binary Search**: Utilize binary search to find the optimal word count that can be accommodated in a line, while meeting the length constraint. The binary search narrows down the word count to a feasible range.\\n\\n**Padding Calculation:** Calculate the padding required for distribution. Determine the minimum length of padding between words and the remaining padding that needs to be allocated. Extra padding, if applicable, is distributed starting from the left.\\n\\n**Line Formation:** Create a string named curr with the length of maxWidth, initialized with spaces. Insert words into the curr string, followed by the calculated padding. This process is continued until the desired line length is achieved.\\n\\n**Updating Pointers:** Update the alreadyTaken pointer to indicate the words that have been included in the current line.\\n\\n**Iterative Process:** Iterate through the words while constructing lines until all words are processed.\\n\\nThe provided code implementation employs this approach, integrating binary search, padding distribution, and line formation to produce justified lines of text.\\n\\nThis approach ensures that each line adheres to the \"maxWidth\" criterion while optimizing word distribution and padding arrangement. The binary search and efficient padding calculations contribute to a time complexity of O(N * (maxWidth + log N)), where N represents the number of words in the input. The space complexity is O(N) due to the storage of the word length prefix sum array.\\n\\nCheck the Comments in \"Source Code\".\\nIf you have any question, put them in the comment section.\\nPlease upvote. If you have liked it.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N * (maxWidth + log N))\\n- N : words.size()\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int N;\\n    int maxWidth;\\n    int alreadyTaken;\\n    vector<int> preFixLength;\\n    bool isPossible(int count) {                    // T.C: O(1)\\n        int spaceNeeded = count - alreadyTaken - 1;\\n        int totalWordsLen = preFixLength[count] - preFixLength[alreadyTaken];\\n        return (totalWordsLen + spaceNeeded) <= maxWidth;\\n    }\\n    int fitWords(int fromIndex, vector<string> &words, vector<string> &ans) {\\n        // Binary Search\\n        int l = alreadyTaken, r = N + 1;\\n        // Invariance\\n        // isPossible(l) is always true\\n        // isPossible(r) is always false\\n        while (l + 1 < r) {                         // T.C: O(log n)\\n            int m = l + (r - l) / 2;\\n            if (isPossible(m))\\n                l = m;\\n            else\\n                r = m;\\n        }\\n        // We can place (alreadyTaken, l] in our curr\\n        int wordCount = l - alreadyTaken;\\n        int totalWordsLen = preFixLength[l] - preFixLength[alreadyTaken];\\n        int spaceNeeded = maxWidth - totalWordsLen;\\n        int gapNeeded = 1, extraGap = 0;\\n        if (wordCount > 1 && l != N) {\\n            gapNeeded = spaceNeeded / (wordCount - 1);\\n            extraGap = spaceNeeded % (wordCount - 1);\\n        } \\n        int k = 0;\\n        string curr(maxWidth, \\' \\');                 // T.C: O(maxWidth)\\n        for (int i = alreadyTaken; i < l; i++) {    // T.C: O(maxWidth)\\n            for (int j = 0; j < words[i].size(); j++) {\\n                curr[k++] = words[i][j]; \\n            }\\n            // Put Spaces\\n            k += gapNeeded;\\n            if (extraGap) {\\n                k++;\\n                extraGap--;\\n            }\\n        }\\n        // Update alreadyTaken\\n        alreadyTaken = l;\\n        ans.push_back(curr);\\n        return l;\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int _maxWidth) {\\n        /* Approach:\\n            1. Binary Search -- T.C: O(n * (maxWidth + log n)), S.C: O(n)\\n        */\\n\\n        // Approach 1\\n        alreadyTaken = 0;\\n        N = words.size();\\n        maxWidth = _maxWidth;\\n        preFixLength.assign(N + 1, 0);\\n        // Calculate Prefix Length\\n        for (int i = 1; i <= N; i++) {\\n            preFixLength[i] = preFixLength[i - 1] + words[i - 1].size();\\n        }\\n\\n        vector<string> ans;\\n\\n        int i = 0;\\n        while (i < N) {     // T.C: O(n * (maxWidth + log n))\\n            i = fitWords(i, words, ans);\\n        }\\n        /* Reasoning behind the time complexity:\\n            In the worst case, we are given such words, that our output contains only one word in each line\\n            Complexity of our fitWords() function is O(maxWidth + log (Search Range))\\n            In this case:\\n                i is incremented by 1 and serach space reduces by 1\\n                so the while loop will run \\'N\\' times to call fitWords() function\\n                Time Complexity:\\n                    [maxWidth + log (N)] + [maxWidth + log (N - 1)] + . . . . . [maxWidth + log (2)]\\n                    Which is = N * (maxWidth + log N)\\n        */\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int N;\\n    int maxWidth;\\n    int alreadyTaken;\\n    vector<int> preFixLength;\\n    bool isPossible(int count) {                    // T.C: O(1)\\n        int spaceNeeded = count - alreadyTaken - 1;\\n        int totalWordsLen = preFixLength[count] - preFixLength[alreadyTaken];\\n        return (totalWordsLen + spaceNeeded) <= maxWidth;\\n    }\\n    int fitWords(int fromIndex, vector<string> &words, vector<string> &ans) {\\n        // Binary Search\\n        int l = alreadyTaken, r = N + 1;\\n        // Invariance\\n        // isPossible(l) is always true\\n        // isPossible(r) is always false\\n        while (l + 1 < r) {                         // T.C: O(log n)\\n            int m = l + (r - l) / 2;\\n            if (isPossible(m))\\n                l = m;\\n            else\\n                r = m;\\n        }\\n        // We can place (alreadyTaken, l] in our curr\\n        int wordCount = l - alreadyTaken;\\n        int totalWordsLen = preFixLength[l] - preFixLength[alreadyTaken];\\n        int spaceNeeded = maxWidth - totalWordsLen;\\n        int gapNeeded = 1, extraGap = 0;\\n        if (wordCount > 1 && l != N) {\\n            gapNeeded = spaceNeeded / (wordCount - 1);\\n            extraGap = spaceNeeded % (wordCount - 1);\\n        } \\n        int k = 0;\\n        string curr(maxWidth, \\' \\');                 // T.C: O(maxWidth)\\n        for (int i = alreadyTaken; i < l; i++) {    // T.C: O(maxWidth)\\n            for (int j = 0; j < words[i].size(); j++) {\\n                curr[k++] = words[i][j]; \\n            }\\n            // Put Spaces\\n            k += gapNeeded;\\n            if (extraGap) {\\n                k++;\\n                extraGap--;\\n            }\\n        }\\n        // Update alreadyTaken\\n        alreadyTaken = l;\\n        ans.push_back(curr);\\n        return l;\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int _maxWidth) {\\n        /* Approach:\\n            1. Binary Search -- T.C: O(n * (maxWidth + log n)), S.C: O(n)\\n        */\\n\\n        // Approach 1\\n        alreadyTaken = 0;\\n        N = words.size();\\n        maxWidth = _maxWidth;\\n        preFixLength.assign(N + 1, 0);\\n        // Calculate Prefix Length\\n        for (int i = 1; i <= N; i++) {\\n            preFixLength[i] = preFixLength[i - 1] + words[i - 1].size();\\n        }\\n\\n        vector<string> ans;\\n\\n        int i = 0;\\n        while (i < N) {     // T.C: O(n * (maxWidth + log n))\\n            i = fitWords(i, words, ans);\\n        }\\n        /* Reasoning behind the time complexity:\\n            In the worst case, we are given such words, that our output contains only one word in each line\\n            Complexity of our fitWords() function is O(maxWidth + log (Search Range))\\n            In this case:\\n                i is incremented by 1 and serach space reduces by 1\\n                so the while loop will run \\'N\\' times to call fitWords() function\\n                Time Complexity:\\n                    [maxWidth + log (N)] + [maxWidth + log (N - 1)] + . . . . . [maxWidth + log (2)]\\n                    Which is = N * (maxWidth + log N)\\n        */\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721607,
                "title": "beats-100-full-explaination-tc-o-n-maxwidth",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPartition approach will work as we have to store as many consecutive words possible in a line, with a constraint that every word is separate by atleast one space with another word. \\n\\nSo, for a line to be valid, the constraints come out to be -\\n`totalLengthOfTheWordsInTheLine + totalNumberOfWordsInTheCurrentLine - 1 <= maxWidth`\\nSo for a line to contain 3 words,the sum  of lengths of all the three words and 2 spaces should be less than or equal to maxWidth.\\n\\nAs soon as the constraint is broken or the length of the line becomes greater than maxWidth, we start storing word in a new line.\\n\\n---\\n```\\nFor Example -\\nwords = [\"abc\",\"ab\",\"ab\",\"a\",\"fgabc\"]\\nmaxWidth = 7\\n\\nOutput - \\n\"abc-ab-\"\\n\"ab---a-\"\\n\"fgabc--\"\\n\\nwhere \\'-\\' represent a single space\\n```\\n\\nThe first line contains abc,ab only and not abc,ab,ab because the words need to be separated by atleast one space, so the length of line abc,ab,ab would be `(3 + 2 + 2) + (3-1) = 7 + 2 = 9`, that would excede the maxWidth criteria, so \"ab\" on index 2 goes to a new line.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe initialize line1 with length of `word[0]`. Since it is the only word in the line and the last word should not be followed by a space, the total length of the line1 remains the same.\\nWe iterate over the words array from `i = 1 to n-1`, storing words in a vector `temp`that belongs to same line, checking if the ith word can be added to the current line. We will be taking a separate variable,`prevLen` to store the totalLengthOfTheWords in the current line, and updating it while iterating. The least number of spaces the current line will be having for adding the current word is `lineSpaces = temp.size()`,i.e., `temp.size() - 1` for existing words, and `+ 1` for adding current word, so overall, `temp.size()` spaces.\\n\\nThe condition of being added to the current line being - \\n`prevLen + lineSpaces + curWordLength <= maxWidth`.\\nSo for creating a new line, condition becomes - \\n`prevLen + lineSpaces + curWordLength > maxWidth`\\nAfter a line, `temp`, can no longer hold more words, we add it to the `lines` vector, and store the space the line can have in a `space` vector, as `maxWidth - prevLen`.\\n\\nNote - After iteration, we have to add the last line in the `lines` vector as it won\\'t be added in the iterating loop.\\n\\nAfter storing all the lines and the corresponding number of spaces they can have. We will be iterating over all the lines and converting them into string with spaces, and store in the `ans` vector.\\n\\nWe have two justifications for a line-\\n1. <b>Left Only Justification</b> - For line containing one word, and the last line.\\n2. <b>Left and Right Justification</b> - For all the other lines not mentioned in 1.\\n\\nSo to append spaces, we have three states -\\n1. <b>When the line is the last line, or the line contains only one word -</b>\\nIn this case, we will be adding only one space after every word, except the last word. The remaining spaces will be added after the last word, to make it left justified \\n\\n2. <b>The line which is not the last line, and contains more than one word-</b>\\nIn this case, we will find out the least number of spaces that we can add between two consecutive words by `sp = space[i]/(numberOfWords-1)`, extra space being `spExtra = space[i]%(numberOfWords-1)`.\\nAs to distribute `space[i]` between `numberOfWords` words, even space will be `sp`, and `extraSpace` that is used only `1` time after each word until it becomes `0`. <i>As per the question statement - <b>\\'Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\\'</b></i>\\nSince extra spaces will be less than the total positions where we can add space, i.e., `spExtra < sp`, therefore we will be adding only `1` extra space, if `spExtra` is not already exhausted.\\n\\n# Complexity\\n- <b>Time complexity: $$O(n+n*maxWidth)$$</b>\\n-$$O(n)$$ for storing character in their respective line\\n-$$O(n.maxWidth)$$ for iterating over all lines to store answer.\\nIn worst case, every line contains a single word, so `n` lines, and for each line we iterate over `maxWidth` characters, to append word characters and spaces. So total iteration becomse $$n*maxWidth$$\\n\\n- <b>Space complexity: $$O(n + n*TotalWordLength+TotalWrdLength + maxWidth)$$</b>\\nSince, maximmum number of lines will be `n` in worst case, therefore space utiltized by \\n-`space` vector for storing space will be $$O(n)$$.\\n-Maximum space utilized by `line` vector will be $$O(n*totalWordLength)$$. Since it stores words only.\\n-$$O(TotalWordLength)$$ for `temp` vector.\\n-String `curr` will also have space complexity of $$O(maxWidth)$$, as it will contain maxWidth characters.\\nSo total space complexity will be $$O(n + n*TotalWordLength+TotalWrdLength + maxWidth)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<vector<string>> lines;\\n        vector<int> spaces;\\n\\n        vector<string> temp = {words[0]};\\n        int i = 1, prevLen = words[0].length();\\n        while(i<n){\\n            int curWordLength = words[i].length();\\n            int prevLineSpaces = temp.size();\\n            if(prevLen + prevLineSpaces + curWordLength > maxWidth){\\n                //if cannot add current word to prev line\\n\\n                //adding prev line to ansvector\\n                lines.push_back(temp);\\n                spaces.push_back(maxWidth - prevLen);\\n\\n                //creating new line\\n                prevLen = curWordLength;\\n                temp.clear();\\n                temp.push_back(words[i]);\\n            }\\n            else{\\n                //adding word to current line\\n                prevLen += curWordLength;\\n                temp.push_back(words[i]);\\n            }\\n            i++;\\n        }\\n        //adding last line\\n        lines.push_back(temp);\\n        spaces.push_back(maxWidth-prevLen);\\n\\n        vector<string> ans;\\n        int sz = lines.size();\\n        //generating line string\\n        for(int j = 0;j<sz;++j){\\n            int numberOfWords = lines[j].size();\\n            int sp = spaces[j];\\n            string cur;\\n            //if last line or contains a single character\\n            if(j == sz-1 || numberOfWords==1){\\n                //left only justified\\n                for(int l = 0;l<numberOfWords;++l){\\n                    string s = lines[j][l];\\n                    cur += s;\\n                    //not to add space after last character if no extra space is there\\n                    if(sp){\\n                        cur += \\' \\';\\n                        sp--;\\n                    }\\n                }\\n                //padding extra space after last word\\n                if(sp) while(sp--) cur+=\\' \\';\\n            }\\n            else{\\n                //left & right justified\\n                //extra space to be added after first word\\n                int spExtra = sp%(numberOfWords-1);\\n                sp = sp/(numberOfWords-1);\\n                for(int l = 0;l<numberOfWords;++l){\\n                    string s = lines[j][l];\\n                    cur += s;\\n                    //adding even space\\n                    if(l!=numberOfWords-1) for(int k=0;k<sp;++k) cur+=\\' \\';\\n                    //adding extra space after first word only\\n                    if(spExtra){\\n                        cur += \\' \\';\\n                        spExtra--;\\n                    }\\n                }\\n            }\\n            ans.push_back(cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nFor Example -\\nwords = [\"abc\",\"ab\",\"ab\",\"a\",\"fgabc\"]\\nmaxWidth = 7\\n\\nOutput - \\n\"abc-ab-\"\\n\"ab---a-\"\\n\"fgabc--\"\\n\\nwhere \\'-\\' represent a single space\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<vector<string>> lines;\\n        vector<int> spaces;\\n\\n        vector<string> temp = {words[0]};\\n        int i = 1, prevLen = words[0].length();\\n        while(i<n){\\n            int curWordLength = words[i].length();\\n            int prevLineSpaces = temp.size();\\n            if(prevLen + prevLineSpaces + curWordLength > maxWidth){\\n                //if cannot add current word to prev line\\n\\n                //adding prev line to ansvector\\n                lines.push_back(temp);\\n                spaces.push_back(maxWidth - prevLen);\\n\\n                //creating new line\\n                prevLen = curWordLength;\\n                temp.clear();\\n                temp.push_back(words[i]);\\n            }\\n            else{\\n                //adding word to current line\\n                prevLen += curWordLength;\\n                temp.push_back(words[i]);\\n            }\\n            i++;\\n        }\\n        //adding last line\\n        lines.push_back(temp);\\n        spaces.push_back(maxWidth-prevLen);\\n\\n        vector<string> ans;\\n        int sz = lines.size();\\n        //generating line string\\n        for(int j = 0;j<sz;++j){\\n            int numberOfWords = lines[j].size();\\n            int sp = spaces[j];\\n            string cur;\\n            //if last line or contains a single character\\n            if(j == sz-1 || numberOfWords==1){\\n                //left only justified\\n                for(int l = 0;l<numberOfWords;++l){\\n                    string s = lines[j][l];\\n                    cur += s;\\n                    //not to add space after last character if no extra space is there\\n                    if(sp){\\n                        cur += \\' \\';\\n                        sp--;\\n                    }\\n                }\\n                //padding extra space after last word\\n                if(sp) while(sp--) cur+=\\' \\';\\n            }\\n            else{\\n                //left & right justified\\n                //extra space to be added after first word\\n                int spExtra = sp%(numberOfWords-1);\\n                sp = sp/(numberOfWords-1);\\n                for(int l = 0;l<numberOfWords;++l){\\n                    string s = lines[j][l];\\n                    cur += s;\\n                    //adding even space\\n                    if(l!=numberOfWords-1) for(int k=0;k<sp;++k) cur+=\\' \\';\\n                    //adding extra space after first word only\\n                    if(spExtra){\\n                        cur += \\' \\';\\n                        spExtra--;\\n                    }\\n                }\\n            }\\n            ans.push_back(cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033003,
                "title": "c-implementation-easy-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    string get_spaces(int n) {\\n        string spaces = \"\";\\n        for(int i = 0; i < n; i++)\\n            spaces += \" \";\\n        return spaces;\\n    }\\n    \\n    \\n    string justify(vector<string> &words, int mxWidth) {\\n        int len = 0;\\n        for(string word: words) \\n            len += word.length();\\n        \\n        int total = mxWidth - len;\\n        \\n        if(words.size() == 1) \\n            return words[0] + get_spaces(total);\\n        \\n        \\n        int space = total / (words.size()-1);\\n        int rem = total % (words.size()-1);\\n        \\n        string line = words[0];\\n        for(int i = 1; i < words.size(); i++) {\\n            // extra spaces give to leftmost rem words\\n            if(i <= rem)\\n                line += get_spaces(space+1) + words[i];\\n            else \\n                line += get_spaces(space) + words[i];\\n        }\\n        \\n        return line;\\n    }\\n    \\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int curr = 0;\\n        vector<string> tmp;\\n        vector<string> ans;\\n        \\n        for(string word: words) {\\n            if(curr + word.length() <= maxWidth) {\\n                tmp.push_back(word);\\n                curr += word.length() + 1;\\n            } else {\\n                curr = 0;\\n                string line = justify(tmp, maxWidth);\\n                ans.push_back(line);\\n                tmp.clear();\\n                \\n                tmp.push_back(word);\\n                curr += word.length() + 1;\\n            }\\n        }\\n        \\n        string line = tmp[0];\\n        for(int i = 1; i < tmp.size(); i++)\\n            line += \" \" + tmp[i];\\n        \\n        // add extra spaces to the end\\n        line += get_spaces(maxWidth-line.length());\\n        ans.push_back(line);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    string get_spaces(int n) {\\n        string spaces = \"\";\\n        for(int i = 0; i < n; i++)\\n            spaces += \" \";\\n        return spaces;\\n    }\\n    \\n    \\n    string justify(vector<string> &words, int mxWidth) {\\n        int len = 0;\\n        for(string word: words) \\n            len += word.length();\\n        \\n        int total = mxWidth - len;\\n        \\n        if(words.size() == 1) \\n            return words[0] + get_spaces(total);\\n        \\n        \\n        int space = total / (words.size()-1);\\n        int rem = total % (words.size()-1);\\n        \\n        string line = words[0];\\n        for(int i = 1; i < words.size(); i++) {\\n            // extra spaces give to leftmost rem words\\n            if(i <= rem)\\n                line += get_spaces(space+1) + words[i];\\n            else \\n                line += get_spaces(space) + words[i];\\n        }\\n        \\n        return line;\\n    }\\n    \\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int curr = 0;\\n        vector<string> tmp;\\n        vector<string> ans;\\n        \\n        for(string word: words) {\\n            if(curr + word.length() <= maxWidth) {\\n                tmp.push_back(word);\\n                curr += word.length() + 1;\\n            } else {\\n                curr = 0;\\n                string line = justify(tmp, maxWidth);\\n                ans.push_back(line);\\n                tmp.clear();\\n                \\n                tmp.push_back(word);\\n                curr += word.length() + 1;\\n            }\\n        }\\n        \\n        string line = tmp[0];\\n        for(int i = 1; i < tmp.size(); i++)\\n            line += \" \" + tmp[i];\\n        \\n        // add extra spaces to the end\\n        line += get_spaces(maxWidth-line.length());\\n        ans.push_back(line);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005474,
                "title": "very-clean-and-clear-python-solution-easy-to-understand",
                "content": "Really **not easy**, requiring no algorithm but good coding skills!\\n\\nInitiate a **running line**.\\nInitiate a **running line length**.\\nWrite helper function **format()**\\nWrite helper function **formatLastline()**\\nIn the main function, we **check and collect the words that could put in one line**, and call helper fumction.\\n\\n**Time:** O(n)\\n**Space:** O(n)\\n\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        running_line = []\\n        line_length = 0\\n        res = []\\n        for word in words:\\n            if line_length + len(running_line) + len(word) <= maxWidth:\\n                line_length += len(word)\\n                running_line.append(word)\\n            else:\\n                res.append(self._format(running_line, maxWidth))\\n                line_length = len(word)\\n                running_line = [word]\\n        if len(running_line):\\n            res.append(self._formatLast(running_line, maxWidth))\\n        return res\\n\\n    def _format(self, line, maxWidth):\\n        if len(line) == 1:\\n            return line[0] + \" \" * (maxWidth - len(line[0]))\\n        \\n        length = sum([len(word) for word in line])\\n        gaps = len(line) - 1\\n        s = line[0]\\n        for index, word in enumerate(line[1:]):\\n            if index < (maxWidth - length) % gaps:\\n                s = s + \" \" * ((maxWidth - length) // gaps) + \" \" + word\\n            else:\\n                s = s + \" \" * ((maxWidth - length) // gaps) + word\\n        return s\\n        \\n    def _formatLast(self, line, maxWidth):\\n        s = \" \".join(line)\\n        return s + \" \" * (maxWidth - len(s))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        running_line = []\\n        line_length = 0\\n        res = []\\n        for word in words:\\n            if line_length + len(running_line) + len(word) <= maxWidth:\\n                line_length += len(word)\\n                running_line.append(word)\\n            else:\\n                res.append(self._format(running_line, maxWidth))\\n                line_length = len(word)\\n                running_line = [word]\\n        if len(running_line):\\n            res.append(self._formatLast(running_line, maxWidth))\\n        return res\\n\\n    def _format(self, line, maxWidth):\\n        if len(line) == 1:\\n            return line[0] + \" \" * (maxWidth - len(line[0]))\\n        \\n        length = sum([len(word) for word in line])\\n        gaps = len(line) - 1\\n        s = line[0]\\n        for index, word in enumerate(line[1:]):\\n            if index < (maxWidth - length) % gaps:\\n                s = s + \" \" * ((maxWidth - length) // gaps) + \" \" + word\\n            else:\\n                s = s + \" \" * ((maxWidth - length) // gaps) + word\\n        return s\\n        \\n    def _formatLast(self, line, maxWidth):\\n        s = \" \".join(line)\\n        return s + \" \" * (maxWidth - len(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938449,
                "title": "easy-python-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # Input check\\n        if not len(words):\\n            return []\\n        \\n        result = []\\n        current_line_len, curr_line = 0, []\\n        \\n        for word in words: \\n            # Incase the new word cannot fit the current line,\\n            # add the spaces and create a new entry in final result\\n            if current_line_len + len(word) + len(curr_line) > maxWidth:    \\n                for i in range(maxWidth - current_line_len): \\n                    curr_line[i % (len(curr_line) - 1 or 1) ] += \\' \\'\\n                    \\n                result.append(\\'\\'.join(curr_line))   # Add to result\\n                current_line_len, curr_line = 0, [] # Reset curr_line and len of current line\\n                \\n            current_line_len += len(word)\\n            curr_line.append(word)\\n            \\n        return result + [\\' \\'.join(curr_line).ljust(maxWidth)]\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # Input check\\n        if not len(words):\\n            return []\\n        \\n        result = []\\n        current_line_len, curr_line = 0, []\\n        \\n        for word in words: \\n            # Incase the new word cannot fit the current line,\\n            # add the spaces and create a new entry in final result\\n            if current_line_len + len(word) + len(curr_line) > maxWidth:    \\n                for i in range(maxWidth - current_line_len): \\n                    curr_line[i % (len(curr_line) - 1 or 1) ] += \\' \\'\\n                    \\n                result.append(\\'\\'.join(curr_line))   # Add to result\\n                current_line_len, curr_line = 0, [] # Reset curr_line and len of current line\\n                \\n            current_line_len += len(word)\\n            curr_line.append(word)\\n            \\n        return result + [\\' \\'.join(curr_line).ljust(maxWidth)]\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1895596,
                "title": "python-clean-and-simple",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def fullJustify(self, words, maxWidth):\\n        lines = self.constructLines(words, maxWidth)\\n        lines = self.addSpaces(lines, maxWidth)\\n        lines = list(map(lambda x : \"\".join(x), lines))\\n        return lines\\n    \\n    def constructLines(self, words, maxWidth):\\n        lines = []\\n        \\n        # Construct words per line\\n        wordLensInPara = list(map(len, words))\\n        i, j = 0, 0\\n        while i < len(words):\\n            while j < len(words):\\n                totalWordLen, numSpaces = sum(wordLensInPara[i:j+1]), (j-i)\\n                width = totalWordLen + numSpaces\\n                if width > maxWidth: break\\n                else: j += 1\\n            lines.append(words[i:j])\\n            i = j\\n        \\n        return lines\\n    \\n    def addSpaces(self, lines, maxWidth):\\n        for line in lines:\\n            numWords = len(line)\\n            lineLen = sum(map(len, line))\\n            numSpaces = maxWidth - lineLen\\n            \\n            # Standard line\\n            if lines.index(line) < len(lines)-1:\\n                if numWords == 1: # One word\\n                    line[0] += \" \" * numSpaces\\n                else: # Multiple words\\n                    numSpacesPerWord, extraSpaces = divmod(numSpaces,numWords-1)\\n                    for i in range(len(line)-1):\\n                        line[i] += \" \" * numSpacesPerWord\\n\\n                        if extraSpaces > 0:\\n                            line[i] += \" \"\\n                            extraSpaces -= 1\\n            # Last line\\n            else:\\n                for i in range(len(line)-1):\\n                    line[i] += \" \"\\n                    numSpaces -= 1\\n                line[-1] += \" \" * numSpaces\\n            \\n        return lines\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words, maxWidth):\\n        lines = self.constructLines(words, maxWidth)\\n        lines = self.addSpaces(lines, maxWidth)\\n        lines = list(map(lambda x : \"\".join(x), lines))\\n        return lines\\n    \\n    def constructLines(self, words, maxWidth):\\n        lines = []\\n        \\n        # Construct words per line\\n        wordLensInPara = list(map(len, words))\\n        i, j = 0, 0\\n        while i < len(words):\\n            while j < len(words):\\n                totalWordLen, numSpaces = sum(wordLensInPara[i:j+1]), (j-i)\\n                width = totalWordLen + numSpaces\\n                if width > maxWidth: break\\n                else: j += 1\\n            lines.append(words[i:j])\\n            i = j\\n        \\n        return lines\\n    \\n    def addSpaces(self, lines, maxWidth):\\n        for line in lines:\\n            numWords = len(line)\\n            lineLen = sum(map(len, line))\\n            numSpaces = maxWidth - lineLen\\n            \\n            # Standard line\\n            if lines.index(line) < len(lines)-1:\\n                if numWords == 1: # One word\\n                    line[0] += \" \" * numSpaces\\n                else: # Multiple words\\n                    numSpacesPerWord, extraSpaces = divmod(numSpaces,numWords-1)\\n                    for i in range(len(line)-1):\\n                        line[i] += \" \" * numSpacesPerWord\\n\\n                        if extraSpaces > 0:\\n                            line[i] += \" \"\\n                            extraSpaces -= 1\\n            # Last line\\n            else:\\n                for i in range(len(line)-1):\\n                    line[i] += \" \"\\n                    numSpaces -= 1\\n                line[-1] += \" \" * numSpaces\\n            \\n        return lines\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746085,
                "title": "clean-c-code-faster-than-100",
                "content": "class Solution {\\npublic:\\n    \\n    string makeLine(vector<string>&v, int toFill){\\n        string res = \"\";\\n        // One word line\\n        if(v.size() == 1){\\n            res += v[0];\\n            while(toFill--) res += \\' \\';\\n            return res;\\n        }\\n        \\n        //Multiple word line\\n        int space = toFill / (v.size()-1);\\n        int extras = toFill % (v.size()-1);\\n        res += v[0];\\n        for(int i=1;i<v.size();i++){\\n            for(int j=0;j<space;j++) res += \\' \\';\\n            if(extras){\\n                extras --;\\n                res += \\' \\';\\n            }\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    \\n     string makeLastLine(vector<string>&v, int toFill){\\n        string res = v[0];\\n        for(int i=1;i<v.size();i++){\\n            toFill --;\\n            res += \\' \\';\\n            res += v[i];\\n        }\\n        while(toFill --) res += \\' \\';\\n        return res;\\n     }\\n    \\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        vector<string> taken;\\n        int lineLen = 0;\\n        for(auto word: words){\\n            if(lineLen+word.size()+taken.size() > maxWidth){\\n                res.push_back(makeLine(taken, maxWidth-lineLen));\\n                taken.clear();\\n                taken.push_back(word);\\n                lineLen = word.size();\\n            } else{\\n                taken.push_back(word);\\n                lineLen += word.size();\\n            }\\n        }\\n        // Last line\\n        res.push_back(makeLastLine(taken, maxWidth-lineLen));\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    string makeLine(vector<string>&v, int toFill){\\n        string res = \"\";\\n        // One word line\\n        if(v.size() == 1){\\n            res += v[0];\\n            while(toFill--) res += \\' \\';\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1396429,
                "title": "java-life-is-easier-by-using-stringjoiner",
                "content": "The biggest headache for this problem is corner cases with padding space. By using StringJoiner would avoid most of them .\\nAt least allow you focus on the logic but not the stupid missing or extra space here and there . \\n```\\nimport java.util.StringJoiner;\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        // Final result\\n        List<String> result = new ArrayList<>(); \\n        // List of words fit in one line \\n        List<String> line = new ArrayList<>();\\n        \\n        int lineCount = 0; \\n        for (String word : words) {\\n            if ((lineCount + word.length() + line.size() - 1) >= maxWidth) {\\n                 result.add(indent(line, lineCount, maxWidth, false));\\n                 line.clear();\\n                 lineCount = 0; \\n            } \\n            line.add(word);           \\n            lineCount += word.length();\\n        }\\n        result.add(indent(line, lineCount, maxWidth, true));\\n        return result; \\n    }\\n    private String indent(List<String> line, int lineCount, int maxWidth, boolean last) {\\n        StringJoiner sj = new StringJoiner(\" \"); \\n        // Last Line \\n        if (last) {\\n           for (String w : line) {\\n               sj.add(w);\\n           }\\n           int remain = maxWidth - sj.length(); \\n           appendSpace(sj, remain);\\n           return sj.toString(); \\n        }\\n        sj.add(line.get(0));\\n        int spaces = maxWidth - lineCount; \\n        int gapSize = line.size() - 1;\\n        // Only one word , add padding and return ; \\n        if (line.size() == 1) {\\n            appendSpace(sj, spaces);\\n            return sj.toString();             \\n        }\\n        int gap = spaces / gapSize;\\n        // Extra space after average gap \\n        int leftOver = spaces % gapSize; \\n        for (int j = 1; j < line.size(); j++) {\\n            int g = gap ;\\n            if (leftOver > 0) {\\n                g++; \\n                leftOver--;\\n            }\\n            appendSpace(sj, g - 1);\\n            sj.add(line.get(j));\\n        }\\n        return sj.toString(); \\n    }\\n    \\n    private void appendSpace(StringJoiner sj, int count) {\\n           for (int i = 0; i < count ; i++) {\\n               sj.add(\"\");\\n           }        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.StringJoiner;\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        // Final result\\n        List<String> result = new ArrayList<>(); \\n        // List of words fit in one line \\n        List<String> line = new ArrayList<>();\\n        \\n        int lineCount = 0; \\n        for (String word : words) {\\n            if ((lineCount + word.length() + line.size() - 1) >= maxWidth) {\\n                 result.add(indent(line, lineCount, maxWidth, false));\\n                 line.clear();\\n                 lineCount = 0; \\n            } \\n            line.add(word);           \\n            lineCount += word.length();\\n        }\\n        result.add(indent(line, lineCount, maxWidth, true));\\n        return result; \\n    }\\n    private String indent(List<String> line, int lineCount, int maxWidth, boolean last) {\\n        StringJoiner sj = new StringJoiner(\" \"); \\n        // Last Line \\n        if (last) {\\n           for (String w : line) {\\n               sj.add(w);\\n           }\\n           int remain = maxWidth - sj.length(); \\n           appendSpace(sj, remain);\\n           return sj.toString(); \\n        }\\n        sj.add(line.get(0));\\n        int spaces = maxWidth - lineCount; \\n        int gapSize = line.size() - 1;\\n        // Only one word , add padding and return ; \\n        if (line.size() == 1) {\\n            appendSpace(sj, spaces);\\n            return sj.toString();             \\n        }\\n        int gap = spaces / gapSize;\\n        // Extra space after average gap \\n        int leftOver = spaces % gapSize; \\n        for (int j = 1; j < line.size(); j++) {\\n            int g = gap ;\\n            if (leftOver > 0) {\\n                g++; \\n                leftOver--;\\n            }\\n            appendSpace(sj, g - 1);\\n            sj.add(line.get(j));\\n        }\\n        return sj.toString(); \\n    }\\n    \\n    private void appendSpace(StringJoiner sj, int count) {\\n           for (int i = 0; i < count ; i++) {\\n               sj.add(\"\");\\n           }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744200,
                "title": "100-java-this-is-how-normal-programmer-thinks-p",
                "content": "**Inline comments**\\n\\n```\\n        List<String> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; ) {\\n            int current_length = 0; // get the current length\\n            ArrayList<String> current = new ArrayList<>(); // make a list of current strings\\n            while (i < words.length && current_length < maxWidth) { // add to the list till the length reaches the maxwidth\\n                if (words[i].length() + current_length <= maxWidth) {\\n                    current.add(words[i]);\\n                    current_length += words[i].length();\\n                    current_length += 1; // add space for each of the words\\n                    i++;\\n                } else {\\n                    break;\\n                }\\n            }\\n            current_length--; // once we have list of words and length, remove the last space\\n            int num_of_words = current.size();\\n            /*\\n            below code has 3 cases\\n            case 1: when we have reached the last words in total list,so the result should be left justified.\\n             */\\n            if (i >= words.length) { // check if i is greater than equal to input list.\\n                // left justify the output.\\n                StringBuilder stringBuilder = new StringBuilder();\\n                for (int j = 0; j < current.size(); j++) {\\n                    if (j == current.size() - 1) stringBuilder.append(current.get(j));\\n                    else {\\n                        stringBuilder.append(current.get(j));\\n                        stringBuilder.append(\" \");\\n                    }\\n                }\\n                int len = stringBuilder.toString().length();\\n                for (int j = len; j < maxWidth; j++)\\n                    stringBuilder.append(\" \");\\n                result.add(stringBuilder.toString());\\n            } \\n              /*\\n            below code has 3 cases\\n            case 2: when there are more than one word in the current list.\\n             */\\n            else if (num_of_words > 1) {\\n                int rem = maxWidth - current_length; // get the remaining number of character\\n                // note : current_length already consist one space between words.\\n                int space_between_words = rem / (current.size() - 1); // so the remaining space is remaining length / (number of words)\\n                int extra = rem % (current.size() - 1); // this extra should be left as possible.\\n                StringBuilder stringBuilder = new StringBuilder();\\n                for (int j = 0; j < current.size(); j++) {\\n                    if (j == current.size() - 1) stringBuilder.append(current.get(j));\\n                    else {\\n                        stringBuilder.append(current.get(j));\\n                        stringBuilder.append(\" \"); // current word space\\n                        for (int k = 0; k < space_between_words; k++) { // add remaing space for each word as per formula\\n                            stringBuilder.append(\" \");\\n                        }\\n                        if (extra > 0) { // extra is added as left as possible, till we have.\\n                            stringBuilder.append(\" \");\\n                            extra--;\\n                        }\\n                    }\\n                }\\n                result.add(stringBuilder.toString());\\n                  /*\\n            below code has 3 cases\\n            case 3:when the current list contains single word\\n            make it left justified\\n             */\\n            } else {\\n                StringBuilder stringBuilder = new StringBuilder();\\n                stringBuilder.append(current.get(0));\\n                for (int j = current.get(0).length(); j < maxWidth; j++) stringBuilder.append(\" \");\\n                result.add(stringBuilder.toString());\\n            }\\n        }\\n        return result;\\n```",
                "solutionTags": [],
                "code": "```\\n        List<String> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; ) {\\n            int current_length = 0; // get the current length\\n            ArrayList<String> current = new ArrayList<>(); // make a list of current strings\\n            while (i < words.length && current_length < maxWidth) { // add to the list till the length reaches the maxwidth\\n                if (words[i].length() + current_length <= maxWidth) {\\n                    current.add(words[i]);\\n                    current_length += words[i].length();\\n                    current_length += 1; // add space for each of the words\\n                    i++;\\n                } else {\\n                    break;\\n                }\\n            }\\n            current_length--; // once we have list of words and length, remove the last space\\n            int num_of_words = current.size();\\n            /*\\n            below code has 3 cases\\n            case 1: when we have reached the last words in total list,so the result should be left justified.\\n             */\\n            if (i >= words.length) { // check if i is greater than equal to input list.\\n                // left justify the output.\\n                StringBuilder stringBuilder = new StringBuilder();\\n                for (int j = 0; j < current.size(); j++) {\\n                    if (j == current.size() - 1) stringBuilder.append(current.get(j));\\n                    else {\\n                        stringBuilder.append(current.get(j));\\n                        stringBuilder.append(\" \");\\n                    }\\n                }\\n                int len = stringBuilder.toString().length();\\n                for (int j = len; j < maxWidth; j++)\\n                    stringBuilder.append(\" \");\\n                result.add(stringBuilder.toString());\\n            } \\n              /*\\n            below code has 3 cases\\n            case 2: when there are more than one word in the current list.\\n             */\\n            else if (num_of_words > 1) {\\n                int rem = maxWidth - current_length; // get the remaining number of character\\n                // note : current_length already consist one space between words.\\n                int space_between_words = rem / (current.size() - 1); // so the remaining space is remaining length / (number of words)\\n                int extra = rem % (current.size() - 1); // this extra should be left as possible.\\n                StringBuilder stringBuilder = new StringBuilder();\\n                for (int j = 0; j < current.size(); j++) {\\n                    if (j == current.size() - 1) stringBuilder.append(current.get(j));\\n                    else {\\n                        stringBuilder.append(current.get(j));\\n                        stringBuilder.append(\" \"); // current word space\\n                        for (int k = 0; k < space_between_words; k++) { // add remaing space for each word as per formula\\n                            stringBuilder.append(\" \");\\n                        }\\n                        if (extra > 0) { // extra is added as left as possible, till we have.\\n                            stringBuilder.append(\" \");\\n                            extra--;\\n                        }\\n                    }\\n                }\\n                result.add(stringBuilder.toString());\\n                  /*\\n            below code has 3 cases\\n            case 3:when the current list contains single word\\n            make it left justified\\n             */\\n            } else {\\n                StringBuilder stringBuilder = new StringBuilder();\\n                stringBuilder.append(current.get(0));\\n                for (int j = current.get(0).length(); j < maxWidth; j++) stringBuilder.append(\" \");\\n                result.add(stringBuilder.toString());\\n            }\\n        }\\n        return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 363913,
                "title": "very-simple-and-straightforward-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        int curLen = 0;\\n        List<String> curLine = new LinkedList<>(); \\n        for(int i = 0; i < words.length; i++){\\n            if(curLen == 0){\\n                curLen += words[i].length();\\n                curLine.add(words[i]);\\n            }\\n            else if(curLen+1+words[i].length()>maxWidth){\\n                addLine(res, maxWidth, curLine, false);\\n                curLine.clear();\\n                i--;\\n                curLen = 0;\\n            }else{\\n                curLen += words[i].length()+1;\\n                curLine.add(words[i]);                \\n            }            \\n        }\\n        //add last line \\n        addLine(res, maxWidth, curLine, true);\\n        return res;        \\n    }\\n    void addLine(List<String> res, int maxWidth, List<String> curLine, boolean isLastLine){\\n        StringBuilder sb = new StringBuilder();\\n        if(isLastLine||curLine.size()==1){\\n            // left-justified\\n            for(int i = 0; i < curLine.size(); i++){\\n                if(i!=0)\\n                    sb.append(\\' \\');\\n                sb.append(curLine.get(i));\\n            }\\n            while(sb.length()<maxWidth)\\n                sb.append(\\' \\');\\n        }else{\\n            //fully-justified\\n            int len = maxWidth;\\n            for(String s: curLine)\\n                len -= s.length();\\n            int j = 0;\\n            j = len % (curLine.size() - 1);\\n            len = len / (curLine.size() - 1);\\n            for(int i = 0; i < curLine.size(); i++){\\n                if(i!=0){\\n                    for(int k = 0; k < len; k++)\\n                        sb.append(\\' \\');\\n                    if(j>0){\\n                        sb.append(\\' \\');\\n                        j--;\\n                    }\\n                }\\n                sb.append(curLine.get(i));                \\n            }                       \\n        }\\n        res.add(sb.toString());\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        int curLen = 0;\\n        List<String> curLine = new LinkedList<>(); \\n        for(int i = 0; i < words.length; i++){\\n            if(curLen == 0){\\n                curLen += words[i].length();\\n                curLine.add(words[i]);\\n            }\\n            else if(curLen+1+words[i].length()>maxWidth){\\n                addLine(res, maxWidth, curLine, false);\\n                curLine.clear();\\n                i--;\\n                curLen = 0;\\n            }else{\\n                curLen += words[i].length()+1;\\n                curLine.add(words[i]);                \\n            }            \\n        }\\n        //add last line \\n        addLine(res, maxWidth, curLine, true);\\n        return res;        \\n    }\\n    void addLine(List<String> res, int maxWidth, List<String> curLine, boolean isLastLine){\\n        StringBuilder sb = new StringBuilder();\\n        if(isLastLine||curLine.size()==1){\\n            // left-justified\\n            for(int i = 0; i < curLine.size(); i++){\\n                if(i!=0)\\n                    sb.append(\\' \\');\\n                sb.append(curLine.get(i));\\n            }\\n            while(sb.length()<maxWidth)\\n                sb.append(\\' \\');\\n        }else{\\n            //fully-justified\\n            int len = maxWidth;\\n            for(String s: curLine)\\n                len -= s.length();\\n            int j = 0;\\n            j = len % (curLine.size() - 1);\\n            len = len / (curLine.size() - 1);\\n            for(int i = 0; i < curLine.size(); i++){\\n                if(i!=0){\\n                    for(int k = 0; k < len; k++)\\n                        sb.append(\\' \\');\\n                    if(j>0){\\n                        sb.append(\\' \\');\\n                        j--;\\n                    }\\n                }\\n                sb.append(curLine.get(i));                \\n            }                       \\n        }\\n        res.add(sb.toString());\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954437,
                "title": "brute-force-easy-to-understand-simulation-c-full-explanation-step-by-step",
                "content": "# Intuition\\nThe idea is to analyse the constraints first. On analysis it is well observed that simulating the entire process is time friendly. Therefore we think on designing a justification algorithm for each sentence and then present our answer.\\n\\n# Approach\\nThe approach is pretty straight forward.\\n\\n**Step 1:** Form sentences. \\n1. To do this iterate over all the words and check if words combined together, exceed the max width or not. Once this happens start forming a new sentence. \\n2. There is a catch here. Every word has to be counted with atleast one space for presentation reasons. (Each word must be separated by atleast one space).\\n3. The last word in every sentence can go without the space described above.\\n\\n**Step 2:** Once we have the sentences in the form of words they are going to contain, we now have to calculate the number of spaces we have insert at the end of each word.(excluding the last)\\n1. Note: If number of words in a sentence are \\'N\\', the number of spaces between these words would be \\'N-1\\'.\\n2. Note: Each space should be equal or almost equal (depending on division of total extra space among words).\\n3. For every sentence:\\n   `Total charCount = sum of word sizes`\\n   `Spaces feasible = maxWidth- charCount`\\n4. Space per word (sppw) = total space / (number of words-1)\\n   `sppw = spaces / (sentences[i].size() -1)` \\n\\n**Step 3:** Insert the spaces calculated to each word.\\nHowever this is not enough.\\n\\n**WHAT IF THE SPACES DONT DISTRIBUTE EQUALLY?**\\n1. To handle such a case when the spaces leave a remainder, you would have to iterate over all the words one by one and give them one extra space until the remainder exhausts.\\n2. This would ensure near equal distribution.\\n\\n**Step 3:** Handle Special Cases\\n1. Sentence with only one word\\n   In such a case, all the spaces feasible go after that single word and makes the entire string left aligned.\\n2. The last sentence\\n   According to the question the last sentence should be left aligned, i.e. every word should be spaced by 1, and the remaining spaces should be added to the last.\\n\\n# Complexity\\n- Time complexity:\\nTo calculate the upper bound, lets assume that every sentence has max width, and contains one word only.\\nTherefore, number of character comparisions is given by\\n```\\nNumber of sentences * max width of a sentence\\nNumber of sentences = number of words = 300 (at max).\\nMax width of a sentence = 100\\n```\\n\\nTotal number of character comparisions made= 300 * 100 = 3e4 operations (upper bound).\\n\\n- Space complexity:\\nIn the same way the space required to store the words, in an array of array of strings, would take up 3e4 space (upper bound).\\n\\n\\n# **An upvote would be highly appreaciated if you understand. Happy Learning!**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<vector<string>> sentences;\\n        \\n        int curSize=0;\\n        vector<string> sentence;\\n\\n        // Step 1: Form sentences.\\n        for(auto word: words)\\n        {\\n            curSize+= word.size()+1;\\n            if(curSize> maxWidth+1)\\n            {\\n                sentences.push_back(sentence);\\n                sentence.clear();\\n                sentence.push_back(word);\\n                curSize= word.size()+1;\\n                continue;\\n            }\\n            \\n            sentence.push_back(word);\\n        }\\n        \\n        sentences.push_back(sentence);\\n        \\n        for(int i=0; i<sentences.size(); i++)\\n        {\\n            int m= sentences[i].size();\\n            if(m==1) //Step 3: Case of 1 word sentence\\n            {\\n                // cout<<sentences[i][0]<<endl;\\n                int sz= sentences[i][0].size();\\n                for(int j=0; j< maxWidth- sz; j++)\\n                    sentences[i][0].push_back(\\' \\');\\n                \\n                // cout<<sentences[i][0].size()<<endl;\\n                continue;\\n            }\\n            \\n            if(i==sentences.size()-1) // Case of last sentence\\n            {\\n                int sz=0;\\n                for(int j=0; j<sentences[i].size()-1; j++) //words\\n                {\\n                    sentences[i][j].push_back(\\' \\');\\n                    sz+= sentences[i][j].size();\\n                }\\n                // cout<<sz<<endl;\\n                sz+= sentences[i][sentences[i].size()-1].size();\\n                // cout<<sz<<endl;\\n                \\n                for(int j=0; j< maxWidth- sz; j++)\\n                    sentences[i][sentences[i].size()-1].push_back(\\' \\');\\n                \\n                continue;\\n            }\\n            \\n            // Step 2: Calculation of spaces per word\\n            int sz=0;\\n            for(int j=0; j<sentences[i].size(); j++)\\n                sz+= sentences[i][j].size();\\n            \\n            int sp= maxWidth - sz;\\n            int sppw=  sp/(m-1);\\n            int nsz=0;\\n            \\n            for(int j=0; j< sentences[i].size()-1; j++)\\n            {\\n                for(int k=0; k<sppw; k++)\\n                    sentences[i][j].push_back(\\' \\');\\n                \\n                nsz+= sentences[i][j].size();\\n            }\\n            \\n            nsz+= sentences[i][sentences[i].size()-1].size();\\n            \\n            // Handle remainder\\n            for(int j=0, k=0; j<sentences[i].size()&&  k< maxWidth-nsz; k++,j++)\\n            {\\n                sentences[i][j].push_back(\\' \\');\\n            }\\n            \\n        }\\n        \\n        // Form answer in required format\\n        vector<string> ans;\\n        \\n        for(auto s: sentences)\\n        {\\n            string sen;\\n            for(auto w: s)\\n                sen+= w;\\n            ans.push_back(sen);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nNumber of sentences * max width of a sentence\\nNumber of sentences = number of words = 300 (at max).\\nMax width of a sentence = 100\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<vector<string>> sentences;\\n        \\n        int curSize=0;\\n        vector<string> sentence;\\n\\n        // Step 1: Form sentences.\\n        for(auto word: words)\\n        {\\n            curSize+= word.size()+1;\\n            if(curSize> maxWidth+1)\\n            {\\n                sentences.push_back(sentence);\\n                sentence.clear();\\n                sentence.push_back(word);\\n                curSize= word.size()+1;\\n                continue;\\n            }\\n            \\n            sentence.push_back(word);\\n        }\\n        \\n        sentences.push_back(sentence);\\n        \\n        for(int i=0; i<sentences.size(); i++)\\n        {\\n            int m= sentences[i].size();\\n            if(m==1) //Step 3: Case of 1 word sentence\\n            {\\n                // cout<<sentences[i][0]<<endl;\\n                int sz= sentences[i][0].size();\\n                for(int j=0; j< maxWidth- sz; j++)\\n                    sentences[i][0].push_back(\\' \\');\\n                \\n                // cout<<sentences[i][0].size()<<endl;\\n                continue;\\n            }\\n            \\n            if(i==sentences.size()-1) // Case of last sentence\\n            {\\n                int sz=0;\\n                for(int j=0; j<sentences[i].size()-1; j++) //words\\n                {\\n                    sentences[i][j].push_back(\\' \\');\\n                    sz+= sentences[i][j].size();\\n                }\\n                // cout<<sz<<endl;\\n                sz+= sentences[i][sentences[i].size()-1].size();\\n                // cout<<sz<<endl;\\n                \\n                for(int j=0; j< maxWidth- sz; j++)\\n                    sentences[i][sentences[i].size()-1].push_back(\\' \\');\\n                \\n                continue;\\n            }\\n            \\n            // Step 2: Calculation of spaces per word\\n            int sz=0;\\n            for(int j=0; j<sentences[i].size(); j++)\\n                sz+= sentences[i][j].size();\\n            \\n            int sp= maxWidth - sz;\\n            int sppw=  sp/(m-1);\\n            int nsz=0;\\n            \\n            for(int j=0; j< sentences[i].size()-1; j++)\\n            {\\n                for(int k=0; k<sppw; k++)\\n                    sentences[i][j].push_back(\\' \\');\\n                \\n                nsz+= sentences[i][j].size();\\n            }\\n            \\n            nsz+= sentences[i][sentences[i].size()-1].size();\\n            \\n            // Handle remainder\\n            for(int j=0, k=0; j<sentences[i].size()&&  k< maxWidth-nsz; k++,j++)\\n            {\\n                sentences[i][j].push_back(\\' \\');\\n            }\\n            \\n        }\\n        \\n        // Form answer in required format\\n        vector<string> ans;\\n        \\n        for(auto s: sentences)\\n        {\\n            string sen;\\n            for(auto w: s)\\n                sen+= w;\\n            ans.push_back(sen);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3668893,
                "title": "beats-92-14",
                "content": "# Code\\n```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n    List<string> result = new List<string>();\\n    List<string> currentLine = new List<string>();\\n    int currentLength = 0;\\n\\n    foreach (string word in words)\\n    {\\n        if (currentLength + currentLine.Count + word.Length > maxWidth)\\n        {\\n            int numWords = currentLine.Count;\\n            int numSpaces = maxWidth - currentLength;\\n            string justifiedLine = \"\";\\n\\n            if (numWords == 1)\\n                justifiedLine = currentLine[0] + new string(\\' \\', numSpaces);\\n            else\\n            {\\n                int spacesBetweenWords = numSpaces / (numWords - 1);\\n                int extraSpaces = numSpaces % (numWords - 1);\\n\\n                StringBuilder sb = new StringBuilder();\\n\\n                for (int i = 0; i < numWords - 1; i++)\\n                {\\n                    sb.Append(currentLine[i]);\\n                    sb.Append(new string(\\' \\', spacesBetweenWords));\\n\\n                    if (i < extraSpaces)\\n                    {\\n                        sb.Append(\\' \\');\\n                    }\\n                }\\n\\n                sb.Append(currentLine[numWords - 1]);\\n                justifiedLine = sb.ToString();\\n            }\\n\\n            result.Add(justifiedLine);\\n            currentLine.Clear();\\n            currentLength = 0;\\n        }\\n\\n        currentLine.Add(word);\\n        currentLength += word.Length;\\n    }\\n\\n    string lastLine = string.Join(\" \", currentLine);\\n    lastLine += new string(\\' \\', maxWidth - lastLine.Length);\\n    result.Add(lastLine);\\n\\n    return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n    List<string> result = new List<string>();\\n    List<string> currentLine = new List<string>();\\n    int currentLength = 0;\\n\\n    foreach (string word in words)\\n    {\\n        if (currentLength + currentLine.Count + word.Length > maxWidth)\\n        {\\n            int numWords = currentLine.Count;\\n            int numSpaces = maxWidth - currentLength;\\n            string justifiedLine = \"\";\\n\\n            if (numWords == 1)\\n                justifiedLine = currentLine[0] + new string(\\' \\', numSpaces);\\n            else\\n            {\\n                int spacesBetweenWords = numSpaces / (numWords - 1);\\n                int extraSpaces = numSpaces % (numWords - 1);\\n\\n                StringBuilder sb = new StringBuilder();\\n\\n                for (int i = 0; i < numWords - 1; i++)\\n                {\\n                    sb.Append(currentLine[i]);\\n                    sb.Append(new string(\\' \\', spacesBetweenWords));\\n\\n                    if (i < extraSpaces)\\n                    {\\n                        sb.Append(\\' \\');\\n                    }\\n                }\\n\\n                sb.Append(currentLine[numWords - 1]);\\n                justifiedLine = sb.ToString();\\n            }\\n\\n            result.Add(justifiedLine);\\n            currentLine.Clear();\\n            currentLength = 0;\\n        }\\n\\n        currentLine.Add(word);\\n        currentLength += word.Length;\\n    }\\n\\n    string lastLine = string.Join(\" \", currentLine);\\n    lastLine += new string(\\' \\', maxWidth - lastLine.Length);\\n    result.Add(lastLine);\\n\\n    return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180889,
                "title": "68-text-justification-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        i = 0\\n        while i < len(words):\\n            j, total_len = i, 0\\n            while j < len(words) and total_len + len(words[j]) + j - i <= maxWidth:\\n                total_len += len(words[j])\\n                j += 1\\n            if j == len(words):\\n                res.append(\" \".join(words[i:j]) + \" \" * (maxWidth - total_len - (j - i - 1)))\\n            else:\\n                spaces = maxWidth - total_len\\n                slots = j - i - 1\\n                if slots == 0:\\n                    res.append(words[i] + \" \" * spaces)\\n                else:\\n                    spaces_per_slot = spaces // slots\\n                    extra_spaces = spaces % slots\\n                    line = words[i]\\n                    for k in range(i + 1, j):\\n                        line += \" \" * (spaces_per_slot + (1 if extra_spaces > 0 else 0))\\n                        extra_spaces -= 1\\n                        line += words[k]\\n                    res.append(line)\\n            i = j\\n        return res\\n\\n``````\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # list to store the justified lines\\n        justified_lines = []\\n        # list to store the current line of words\\n        line = []\\n        # length of the current line\\n        line_length = 0\\n        # loop through all words\\n        for word in words:\\n            # if adding the current word to the line and a space would exceed the maxWidth\\n            if line_length + len(word) + len(line) > maxWidth:\\n                # calculate the number of spaces needed to be added to the line\\n                spaces = maxWidth - line_length\\n                # distribute the spaces as evenly as possible between the words\\n                for i in range(spaces):\\n                    line[i % (len(line) - 1 or 1)] += \\' \\'\\n                # add the line to the justified_lines list\\n                justified_lines.append(\\'\\'.join(line))\\n                # reset line and line_length for the next line\\n                line = []\\n                line_length = 0\\n            # add the current word to the line\\n            line.append(word)\\n            line_length += len(word)\\n        # handle the last line, which is left-justified\\n        last_line = \\' \\'.join(line)\\n        last_line += \\' \\' * (maxWidth - len(last_line))\\n        justified_lines.append(last_line)\\n        return justified_lines\\n\\n```\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        i = 0\\n        while i < len(words):\\n            j, total_len = i, 0\\n            while j < len(words) and total_len + len(words[j]) + j - i <= maxWidth:\\n                total_len += len(words[j])\\n                j += 1\\n            if j == len(words):\\n                res.append(\" \".join(words[i:j]) + \" \" * (maxWidth - total_len - (j - i - 1)))\\n            else:\\n                spaces = maxWidth - total_len\\n                slots = j - i - 1\\n                if slots == 0:\\n                    res.append(words[i] + \" \" * spaces)\\n                else:\\n                    spaces_per_slot = spaces // slots\\n                    extra_spaces = spaces % slots\\n                    line = words[i]\\n                    for k in range(i + 1, j):\\n                        line += \" \" * (spaces_per_slot + (1 if extra_spaces > 0 else 0))\\n                        extra_spaces -= 1\\n                        line += words[k]\\n                    res.append(line)\\n            i = j\\n        return res\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795688,
                "title": "easy-to-understand-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        if (words == null || words.length == 0 || maxWidth <= 0) {\\n            return new ArrayList<String>();\\n        }\\n\\n        List<String> result = new ArrayList<String>();\\n        List<String> row = new ArrayList<String>();\\n        int index = 0, len = 0;\\n        while (index < words.length) {\\n            String word = words[index];\\n            if ((row.size() == 0 && len + word.length() > maxWidth) \\n                || (row.size() > 0 && len + word.length() + 1 > maxWidth)) {\\n                result.add(formatHelper(row, len, maxWidth, false));\\n                row = new ArrayList<String>();\\n                len = 0;\\n            } else {\\n                row.add(word);\\n                if (len == 0) {\\n                    len += word.length();\\n                } else {\\n                    len += (word.length() + 1);\\n                }\\n                index++;\\n            }\\n        }\\n        if (!row.isEmpty()) {\\n            result.add(formatHelper(row, len, maxWidth, true));\\n        }\\n        return result;\\n    }\\n\\n    private String formatHelper(List<String> row, int len, int maxWidth, boolean isLastRow) {\\n        StringBuilder result = new StringBuilder();\\n        int diff = maxWidth - len;\\n        int interLen = (row.size() > 1) ? (diff / (row.size() - 1)) : diff;\\n        StringBuilder interString = new StringBuilder();\\n        for (int i = 0; i < interLen; i++) {\\n            interString.append(\" \");\\n        }\\n        int largerInterCount = diff - interLen * (row.size() == 1 ? 1 : (row.size() - 1));\\n        for (int i = 0; i < row.size(); i++) {\\n            result.append(row.get(i));\\n            if (isLastRow) {\\n                if (i < row.size() - 1) {\\n                    result.append(\" \");\\n                }\\n            } else if (i < row.size() - 1 || row.size() == 1) {\\n                if (i < row.size() - 1) {\\n                    result.append(\" \");\\n                }\\n                result.append(interString);\\n                if (largerInterCount-- > 0) {\\n                    result.append(\" \");\\n                }\\n            }\\n        }\\n        if (isLastRow) {\\n            while (result.length() < maxWidth) {\\n                result.append(\" \");\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        if (words == null || words.length == 0 || maxWidth <= 0) {\\n            return new ArrayList<String>();\\n        }\\n\\n        List<String> result = new ArrayList<String>();\\n        List<String> row = new ArrayList<String>();\\n        int index = 0, len = 0;\\n        while (index < words.length) {\\n            String word = words[index];\\n            if ((row.size() == 0 && len + word.length() > maxWidth) \\n                || (row.size() > 0 && len + word.length() + 1 > maxWidth)) {\\n                result.add(formatHelper(row, len, maxWidth, false));\\n                row = new ArrayList<String>();\\n                len = 0;\\n            } else {\\n                row.add(word);\\n                if (len == 0) {\\n                    len += word.length();\\n                } else {\\n                    len += (word.length() + 1);\\n                }\\n                index++;\\n            }\\n        }\\n        if (!row.isEmpty()) {\\n            result.add(formatHelper(row, len, maxWidth, true));\\n        }\\n        return result;\\n    }\\n\\n    private String formatHelper(List<String> row, int len, int maxWidth, boolean isLastRow) {\\n        StringBuilder result = new StringBuilder();\\n        int diff = maxWidth - len;\\n        int interLen = (row.size() > 1) ? (diff / (row.size() - 1)) : diff;\\n        StringBuilder interString = new StringBuilder();\\n        for (int i = 0; i < interLen; i++) {\\n            interString.append(\" \");\\n        }\\n        int largerInterCount = diff - interLen * (row.size() == 1 ? 1 : (row.size() - 1));\\n        for (int i = 0; i < row.size(); i++) {\\n            result.append(row.get(i));\\n            if (isLastRow) {\\n                if (i < row.size() - 1) {\\n                    result.append(\" \");\\n                }\\n            } else if (i < row.size() - 1 || row.size() == 1) {\\n                if (i < row.size() - 1) {\\n                    result.append(\" \");\\n                }\\n                result.append(interString);\\n                if (largerInterCount-- > 0) {\\n                    result.append(\" \");\\n                }\\n            }\\n        }\\n        if (isLastRow) {\\n            while (result.length() < maxWidth) {\\n                result.append(\" \");\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742430,
                "title": "c-solution-with-inline-comments",
                "content": "**For Details see inline comments in the following code:**\\nm --> Number of words.\\nn --> Total number of characters.\\n**Time Complexity:** O(mn)\\n**Space complexity:**  O(mn)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int n = words.size();\\n        \\n        for(int i = 0, w; i < n; i = w) {\\n            // Length of text with 1 space (except at end of a line)              \\n            int len = -1; // last word in a line doesn\\'t require space at end.\\n            // Check how much can be accomodated in a line\\n            for(w = i; w < n && len + words[w].length() + 1 <= maxWidth; w++) {\\n                len += words[w].length() + 1;\\n            }\\n            \\n            string str = words[i];\\n            \\n            // Initially only one space and zero extra spaces.\\n            int space = 1, extra = 0;\\n            if(w != i + 1 && w != words.size()) { // not 1 string, not last line -> ###\\n                // Spaces remaining at end -> (maxWidth - len)\\n                // Slots --> (w - i - 1)\\n                space = (maxWidth - len) / (w - i - 1) + 1;\\n                extra = (maxWidth - len) % (w - i - 1);\\n            }\\n            \\n            // Debug Info: (Uncomment to see)\\n            // cout<<\"w: \"<<w<<\" \";\\n            // cout<<\"len: \"<<len<<\" \";\\n            // cout<<\"space: \"<<space<<\" \";\\n            // cout<<\"extra: \"<<extra<<endl;\\n            \\n            // Adjust spaces remaining in slots \\n            for(int j = i + 1; j < w; ++j) {\\n                for(int s = space; s > 0; s--) str += \\' \\';\\n                // Put extra spaces in left aligned manner as we going left to right\\n                if(extra-- > 0) str += \\' \\';\\n                str += words[j];\\n            }\\n            \\n            // Putting extra spaces for last line -> ###\\n            int strLen = maxWidth - str.length();\\n            while(strLen-- > 0) str += \\' \\';\\n            ans.push_back(str);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int n = words.size();\\n        \\n        for(int i = 0, w; i < n; i = w) {\\n            // Length of text with 1 space (except at end of a line)              \\n            int len = -1; // last word in a line doesn\\'t require space at end.\\n            // Check how much can be accomodated in a line\\n            for(w = i; w < n && len + words[w].length() + 1 <= maxWidth; w++) {\\n                len += words[w].length() + 1;\\n            }\\n            \\n            string str = words[i];\\n            \\n            // Initially only one space and zero extra spaces.\\n            int space = 1, extra = 0;\\n            if(w != i + 1 && w != words.size()) { // not 1 string, not last line -> ###\\n                // Spaces remaining at end -> (maxWidth - len)\\n                // Slots --> (w - i - 1)\\n                space = (maxWidth - len) / (w - i - 1) + 1;\\n                extra = (maxWidth - len) % (w - i - 1);\\n            }\\n            \\n            // Debug Info: (Uncomment to see)\\n            // cout<<\"w: \"<<w<<\" \";\\n            // cout<<\"len: \"<<len<<\" \";\\n            // cout<<\"space: \"<<space<<\" \";\\n            // cout<<\"extra: \"<<extra<<endl;\\n            \\n            // Adjust spaces remaining in slots \\n            for(int j = i + 1; j < w; ++j) {\\n                for(int s = space; s > 0; s--) str += \\' \\';\\n                // Put extra spaces in left aligned manner as we going left to right\\n                if(extra-- > 0) str += \\' \\';\\n                str += words[j];\\n            }\\n            \\n            // Putting extra spaces for last line -> ###\\n            int strLen = maxWidth - str.length();\\n            while(strLen-- > 0) str += \\' \\';\\n            ans.push_back(str);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2701534,
                "title": "simle-java-solution",
                "content": "This is my intuitive and somple solution on Java:\\n\\n```\\nclass Solution {\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> processedStrings = new ArrayList<>();\\n        int width = 0, wordsCount = 0;\\n\\n        for (int wordIndex = 0; wordIndex < words.length; wordIndex++) {\\n            width += words[wordIndex].length();\\n            wordsCount++;\\n\\n            if (wordIndex == words.length - 1\\n                    || width + words[wordIndex + 1].length() + wordsCount - 1 >= maxWidth) {\\n                int allSpaces = maxWidth - width;\\n                StringBuilder processedString = new StringBuilder();\\n\\n                while (--wordsCount >= 0) {\\n                    processedString.append(words[wordIndex - wordsCount]);\\n                    int spaces = wordIndex == words.length - 1\\n                            ? 1\\n                            : (int) Math.ceil((double) allSpaces / wordsCount);\\n                    processedString.append(\" \".repeat(Math.max(0, Math.min(spaces, allSpaces))));\\n                    allSpaces -= spaces;\\n                }\\n\\n                processedString.append(\" \".repeat(Math.max(0, allSpaces)));\\n                processedStrings.add(processedString.toString());\\n                wordsCount = 0;\\n                width = 0;\\n            }\\n        }\\n\\n        return processedStrings;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> processedStrings = new ArrayList<>();\\n        int width = 0, wordsCount = 0;\\n\\n        for (int wordIndex = 0; wordIndex < words.length; wordIndex++) {\\n            width += words[wordIndex].length();\\n            wordsCount++;\\n\\n            if (wordIndex == words.length - 1\\n                    || width + words[wordIndex + 1].length() + wordsCount - 1 >= maxWidth) {\\n                int allSpaces = maxWidth - width;\\n                StringBuilder processedString = new StringBuilder();\\n\\n                while (--wordsCount >= 0) {\\n                    processedString.append(words[wordIndex - wordsCount]);\\n                    int spaces = wordIndex == words.length - 1\\n                            ? 1\\n                            : (int) Math.ceil((double) allSpaces / wordsCount);\\n                    processedString.append(\" \".repeat(Math.max(0, Math.min(spaces, allSpaces))));\\n                    allSpaces -= spaces;\\n                }\\n\\n                processedString.append(\" \".repeat(Math.max(0, allSpaces)));\\n                processedStrings.add(processedString.toString());\\n                wordsCount = 0;\\n                width = 0;\\n            }\\n        }\\n\\n        return processedStrings;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616085,
                "title": "python-solution",
                "content": "```python\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        lines = [] # Collections used to get all the lines.\\n        \\n        i = 0 # Index of the current word\\n        current_width = 0 # Keeps track of the current width we\\'ve processed for a given line.\\n        line = []\\n        \\n        while i < len(words):\\n            word = words[i]\\n            \\n\\t\\t\\t# Verify that the current_width + current word does not exceed the max width.\\n            if (current_width + len(word)) <= maxWidth:\\n                line.append(word)\\n                current_width += len(word) + 1 # Since all words must have a minimum of 1 space, that +1 is for the space\\n                i += 1\\n            else: \\n\\t\\t\\t\\t# We\\'ve reached the point where we can\\'t process any new words. So we process the line seen so far.\\n\\t\\t\\t\\t# Note: We don\\'t increment i here because we want to reprocess it for the next line.\\n                current_line = \"\"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Calculate the total number of spaces we need. In the if statement above, we added +1 for space between words.\\n\\t\\t\\t\\t# Here we\\'re removing all those for easier calculation in the future. That is what the + len(line) is for; 1 space per word.\\n                necessary_spaces = maxWidth - current_width + len(line) \\n                if len(line) == 1: # Edge case where the line only has 1 word.\\n                    current_line += line[0] + \" \" * necessary_spaces # Append all spaces at the end in this instance.\\n                else: # There\\'s more than 1 word in the line so we need to process all of them.\\n                    for j in range(len(line)):\\n                        line_word = line[j]\\n\\t\\t\\t\\t\\t\\t# So between each word we need to distribute spaces evenly. \\n\\t\\t\\t\\t\\t\\t# The intuition here is that, except for the last word, we\\'ll need to calculate how many spaces we need.\\n\\t\\t\\t\\t\\t\\t# Example: if you have these words for a line [\"This\", \"is\", \"an\"] with a maxWidth = 16\\n\\t\\t\\t\\t\\t\\t# there are 3 words and you need to divide it between 2 spaces: \"this\" and \"is\" and \"is\" and \"an\" so that means\\n\\t\\t\\t\\t\\t\\t# you need 8 spaces evenly. We use remaining_words below to calculate the required_spaces below using the logic seen below.\\n\\t\\t\\t\\t\\t\\t# For the last word in a line, we don\\'t need any spaces so it is always 0.\\n\\t\\t\\t\\t\\t\\t# We use the ceil function here because if maxWidth is odd, then we have to distribute to the left side first (or greedily).\\n                        remaining_words = len(line) - (j + 1)\\n                        required_spaces = ceil(necessary_spaces / remaining_words) if remaining_words else 0\\n                        current_line += line_word + \" \" * required_spaces\\n                        necessary_spaces -= required_spaces # Subtract from necessary spaces. In the example above it would take 8 -> 4.\\n\\t\\t\\t\\t\\t\\t\\n                lines.append(current_line) # Add the result of the current line.\\n                line = []\\n                current_width = 0\\n\\n\\t\\t# It\\'s possible that we have processed all the words, but have some left over in the line. So we\\'ll add the remainder.\\n\\t\\t# Based on the problem description we want to only add a space between each word here and then add any remaining\\n\\t\\t# spaces at the end.\\n        if line: \\n            necessary_spaces = maxWidth - current_width + 1\\n            current_line = \\' \\'.join(line) + \" \" * necessary_spaces\\n            lines.append(current_line)\\n        return lines\\n```\\n\\nSome optimizations exist. I\\'m using string concatenation for the current line, but appending to the list may be preferred,.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        lines = [] # Collections used to get all the lines.\\n        \\n        i = 0 # Index of the current word\\n        current_width = 0 # Keeps track of the current width we\\'ve processed for a given line.\\n        line = []\\n        \\n        while i < len(words):\\n            word = words[i]\\n            \\n\\t\\t\\t# Verify that the current_width + current word does not exceed the max width.\\n            if (current_width + len(word)) <= maxWidth:\\n                line.append(word)\\n                current_width += len(word) + 1 # Since all words must have a minimum of 1 space, that +1 is for the space\\n                i += 1\\n            else: \\n\\t\\t\\t\\t# We\\'ve reached the point where we can\\'t process any new words. So we process the line seen so far.\\n\\t\\t\\t\\t# Note: We don\\'t increment i here because we want to reprocess it for the next line.\\n                current_line = \"\"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Calculate the total number of spaces we need. In the if statement above, we added +1 for space between words.\\n\\t\\t\\t\\t# Here we\\'re removing all those for easier calculation in the future. That is what the + len(line) is for; 1 space per word.\\n                necessary_spaces = maxWidth - current_width + len(line) \\n                if len(line) == 1: # Edge case where the line only has 1 word.\\n                    current_line += line[0] + \" \" * necessary_spaces # Append all spaces at the end in this instance.\\n                else: # There\\'s more than 1 word in the line so we need to process all of them.\\n                    for j in range(len(line)):\\n                        line_word = line[j]\\n\\t\\t\\t\\t\\t\\t# So between each word we need to distribute spaces evenly. \\n\\t\\t\\t\\t\\t\\t# The intuition here is that, except for the last word, we\\'ll need to calculate how many spaces we need.\\n\\t\\t\\t\\t\\t\\t# Example: if you have these words for a line [\"This\", \"is\", \"an\"] with a maxWidth = 16\\n\\t\\t\\t\\t\\t\\t# there are 3 words and you need to divide it between 2 spaces: \"this\" and \"is\" and \"is\" and \"an\" so that means\\n\\t\\t\\t\\t\\t\\t# you need 8 spaces evenly. We use remaining_words below to calculate the required_spaces below using the logic seen below.\\n\\t\\t\\t\\t\\t\\t# For the last word in a line, we don\\'t need any spaces so it is always 0.\\n\\t\\t\\t\\t\\t\\t# We use the ceil function here because if maxWidth is odd, then we have to distribute to the left side first (or greedily).\\n                        remaining_words = len(line) - (j + 1)\\n                        required_spaces = ceil(necessary_spaces / remaining_words) if remaining_words else 0\\n                        current_line += line_word + \" \" * required_spaces\\n                        necessary_spaces -= required_spaces # Subtract from necessary spaces. In the example above it would take 8 -> 4.\\n\\t\\t\\t\\t\\t\\t\\n                lines.append(current_line) # Add the result of the current line.\\n                line = []\\n                current_width = 0\\n\\n\\t\\t# It\\'s possible that we have processed all the words, but have some left over in the line. So we\\'ll add the remainder.\\n\\t\\t# Based on the problem description we want to only add a space between each word here and then add any remaining\\n\\t\\t# spaces at the end.\\n        if line: \\n            necessary_spaces = maxWidth - current_width + 1\\n            current_line = \\' \\'.join(line) + \" \" * necessary_spaces\\n            lines.append(current_line)\\n        return lines\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564093,
                "title": "easy-to-understand-java-greedy-solution",
                "content": "I am going solve this problem using greedy approach.\\n\\nThe greedy approach involves having two pointers \"i\" and \"j\". We move our \"j\" pointer forward until we get to a point where the words in the line go over our \"maxWidth\" parameter. Once that occurs, we now know all of the words that are going to be inside of the line.\\n\\nNext, we will count the number of words we have in the line. If we have a single word OR we are on the last line, then we will be left justifying the line, otherwise we middle justify. To left justify a line, we take the difference between the total amount of word characters we have and our \"maxWidth\" and this will tell us how many spaces there needs to be inside of the line.\\nThere should only be a single space between each word, but the last word will have the rest of the unused spaces to the very right of it, causing the line to left justify properly. In order to middle justify, we take the the number of spaces needed and the number of sections of spaces required. To get the section number, we do \"j\" - \"i\" - 1. Then divide our spaces with the section number which gives us a number to evenly distribute the spaces in between each word in the line. If we have extra spaces, the spaces will be added to the left-most words from left to right.\\n\\nThe time and space complexity of our solution is going to be O(lines * maxWidth). We must iterate, for each potential line, to the \"maxWidth\" since the spaces will be repeated. Under the hood, the \"repeat\" function is just running a for loop duplicating the character.\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result=new ArrayList<>();\\n        int n = words.length;\\n        int i=0,j,lineLength;\\n        while(i<n){\\n            j=i+1;\\n            lineLength=words[i].length();\\n          while(j<n&&(lineLength+words[j].length()+(j-i-1)<maxWidth))\\n            {\\n              lineLength+=words[j].length();\\n              j++;\\n            }\\n          int diff =maxWidth-lineLength;\\n          int noOfWords=j-i;\\n            if(noOfWords==1||j>=n)\\n                result.add(leftJustify(diff,noOfWords,words,i,j));\\n            else\\n                result.add(middleJustify(diff,noOfWords,words,i,j));\\n            i=j;\\n        }\\n        return result;\\n    }\\n    public static String leftJustify(int diff,int noOfWords,String[] words,int i,int j)\\n    {\\n        StringBuilder  leftJustifyAns = new StringBuilder(words[i]);\\n        int spacesOnRight=diff-(j-i-1);\\n        for(int k=i+1;k<j;k++){\\n           leftJustifyAns.append(\" \"+words[k]);\\n        }\\n       leftJustifyAns.append(\" \".repeat(spacesOnRight));\\n        return  leftJustifyAns.toString();\\n    }\\n    public static String middleJustify(int diff,int noOfWords,String[] words,int i,int j)\\n    {\\n         StringBuilder  middleJustifyAns = new StringBuilder(words[i]);\\n       \\n        int spacesNeeded= j-i-1;\\n        int spaces =diff/spacesNeeded;\\n        int extraSpaces = diff%spaces;\\n        for(int k=i+1;k<j;++k){\\n            int spacesToApply=spaces+(extraSpaces-- > 0 ? 1 : 0);\\n            middleJustifyAns.append(\" \".repeat(spacesToApply)+words[k]);\\n        }\\n        return  middleJustifyAns.toString();\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result=new ArrayList<>();\\n        int n = words.length;\\n        int i=0,j,lineLength;\\n        while(i<n){\\n            j=i+1;\\n            lineLength=words[i].length();\\n          while(j<n&&(lineLength+words[j].length()+(j-i-1)<maxWidth))\\n            {\\n              lineLength+=words[j].length();\\n              j++;\\n            }\\n          int diff =maxWidth-lineLength;\\n          int noOfWords=j-i;\\n            if(noOfWords==1||j>=n)\\n                result.add(leftJustify(diff,noOfWords,words,i,j));\\n            else\\n                result.add(middleJustify(diff,noOfWords,words,i,j));\\n            i=j;\\n        }\\n        return result;\\n    }\\n    public static String leftJustify(int diff,int noOfWords,String[] words,int i,int j)\\n    {\\n        StringBuilder  leftJustifyAns = new StringBuilder(words[i]);\\n        int spacesOnRight=diff-(j-i-1);\\n        for(int k=i+1;k<j;k++){\\n           leftJustifyAns.append(\" \"+words[k]);\\n        }\\n       leftJustifyAns.append(\" \".repeat(spacesOnRight));\\n        return  leftJustifyAns.toString();\\n    }\\n    public static String middleJustify(int diff,int noOfWords,String[] words,int i,int j)\\n    {\\n         StringBuilder  middleJustifyAns = new StringBuilder(words[i]);\\n       \\n        int spacesNeeded= j-i-1;\\n        int spaces =diff/spacesNeeded;\\n        int extraSpaces = diff%spaces;\\n        for(int k=i+1;k<j;++k){\\n            int spacesToApply=spaces+(extraSpaces-- > 0 ? 1 : 0);\\n            middleJustifyAns.append(\" \".repeat(spacesToApply)+words[k]);\\n        }\\n        return  middleJustifyAns.toString();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418813,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Simulation***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int max_width) {\\n        \\n        int n = words.size();\\n        \\n        vector<string> res;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            int start = i;\\n            \\n            // total characters keeps track of count of included characters\\n            \\n            int total_characters = 0;\\n            \\n            // count_words keeps track of no. of included words\\n            \\n            int count_words = 0;\\n            \\n            // include the words \\n            \\n            while(i < n && total_characters + count_words + words[i].size() <= max_width)\\n            {\\n                total_characters += words[i].size();\\n                \\n                count_words++;\\n                \\n                i++;\\n            }\\n            \\n            // calculate the no. of spaces we have to insert\\n           \\n            int total_spaces = max_width - total_characters;\\n            \\n            // if no. of words included = 1, then provide all the spaces after the word\\n            \\n            if(count_words == 1)\\n            {\\n                string temp_res = \"\";\\n                \\n                // append the word\\n                \\n                temp_res += words[start];\\n                \\n                // now append the spaces\\n                \\n                string space(total_spaces, \\' \\');\\n                \\n                temp_res += space;\\n                \\n                res.push_back(temp_res);\\n                \\n                continue;\\n            }\\n            \\n            // if no. of word is more than 1\\n            \\n            // 1st provide equal spaces between words, then distribute the remaining spaces \\n            \\n            // no. of places where space will be provided is = total words - 1\\n            \\n            int equal_spaces = total_spaces / (count_words - 1);\\n            \\n            int rem_spaces = total_spaces % (count_words - 1);\\n            \\n            // create a spaces array, which will store the no. of spaces provided between words from left side\\n            \\n            vector<int> spaces(count_words - 1, equal_spaces);\\n            \\n            // distribute the rem spaces from left to right\\n            \\n            int j = 0;\\n            \\n            while(rem_spaces)\\n            {\\n                spaces[j++] += 1;\\n                \\n                rem_spaces--;\\n            }  \\n            \\n            // j will point to the index of spaces array\\n            \\n            j = 0;\\n            \\n            string temp_res = \"\";\\n            \\n            // 1st case, if the text is not in the last line\\n            \\n            if(i < n)\\n            {\\n                for(int k = start; k < i; k++)\\n                {\\n                    // push the word into temp res\\n                    \\n                    temp_res += words[k];\\n                    \\n                    // provide the spaces\\n                    \\n                    if(j < spaces.size())\\n                    {\\n                        string space(spaces[j++], \\' \\');\\n                        \\n                        temp_res += space;\\n                    } \\n                }\\n            }\\n            \\n            // second case if the text is in the last line\\n            \\n            else\\n            {\\n                for(int k = start; k < i; k++)\\n                {\\n                    // push the word into temp res\\n                    \\n                    temp_res += words[k];\\n                    \\n                    // provide spaces\\n                    \\n                    temp_res += \\' \\';\\n                    \\n                    // decrement the spaces\\n                    \\n                    total_spaces--;\\n                }\\n                \\n                // if the total_spaces <= 0, then pop the last extra space\\n                \\n                if(total_spaces <= 0)\\n                {\\n                    temp_res.pop_back();\\n                }\\n                \\n                // otherwise push the spaces into temp_res\\n                \\n                else\\n                {\\n                    string space(total_spaces, \\' \\');\\n                    \\n                    temp_res += space;\\n                } \\n            }\\n            \\n            // push the temp_res into res array\\n            \\n            res.push_back(temp_res);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int max_width) {\\n        \\n        int n = words.size();\\n        \\n        vector<string> res;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            int start = i;\\n            \\n            // total characters keeps track of count of included characters\\n            \\n            int total_characters = 0;\\n            \\n            // count_words keeps track of no. of included words\\n            \\n            int count_words = 0;\\n            \\n            // include the words \\n            \\n            while(i < n && total_characters + count_words + words[i].size() <= max_width)\\n            {\\n                total_characters += words[i].size();\\n                \\n                count_words++;\\n                \\n                i++;\\n            }\\n            \\n            // calculate the no. of spaces we have to insert\\n           \\n            int total_spaces = max_width - total_characters;\\n            \\n            // if no. of words included = 1, then provide all the spaces after the word\\n            \\n            if(count_words == 1)\\n            {\\n                string temp_res = \"\";\\n                \\n                // append the word\\n                \\n                temp_res += words[start];\\n                \\n                // now append the spaces\\n                \\n                string space(total_spaces, \\' \\');\\n                \\n                temp_res += space;\\n                \\n                res.push_back(temp_res);\\n                \\n                continue;\\n            }\\n            \\n            // if no. of word is more than 1\\n            \\n            // 1st provide equal spaces between words, then distribute the remaining spaces \\n            \\n            // no. of places where space will be provided is = total words - 1\\n            \\n            int equal_spaces = total_spaces / (count_words - 1);\\n            \\n            int rem_spaces = total_spaces % (count_words - 1);\\n            \\n            // create a spaces array, which will store the no. of spaces provided between words from left side\\n            \\n            vector<int> spaces(count_words - 1, equal_spaces);\\n            \\n            // distribute the rem spaces from left to right\\n            \\n            int j = 0;\\n            \\n            while(rem_spaces)\\n            {\\n                spaces[j++] += 1;\\n                \\n                rem_spaces--;\\n            }  \\n            \\n            // j will point to the index of spaces array\\n            \\n            j = 0;\\n            \\n            string temp_res = \"\";\\n            \\n            // 1st case, if the text is not in the last line\\n            \\n            if(i < n)\\n            {\\n                for(int k = start; k < i; k++)\\n                {\\n                    // push the word into temp res\\n                    \\n                    temp_res += words[k];\\n                    \\n                    // provide the spaces\\n                    \\n                    if(j < spaces.size())\\n                    {\\n                        string space(spaces[j++], \\' \\');\\n                        \\n                        temp_res += space;\\n                    } \\n                }\\n            }\\n            \\n            // second case if the text is in the last line\\n            \\n            else\\n            {\\n                for(int k = start; k < i; k++)\\n                {\\n                    // push the word into temp res\\n                    \\n                    temp_res += words[k];\\n                    \\n                    // provide spaces\\n                    \\n                    temp_res += \\' \\';\\n                    \\n                    // decrement the spaces\\n                    \\n                    total_spaces--;\\n                }\\n                \\n                // if the total_spaces <= 0, then pop the last extra space\\n                \\n                if(total_spaces <= 0)\\n                {\\n                    temp_res.pop_back();\\n                }\\n                \\n                // otherwise push the spaces into temp_res\\n                \\n                else\\n                {\\n                    string space(total_spaces, \\' \\');\\n                    \\n                    temp_res += space;\\n                } \\n            }\\n            \\n            // push the temp_res into res array\\n            \\n            res.push_back(temp_res);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338338,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int L) {\\n         vector<string> res;\\n    for(int i = 0, k, l; i < words.size(); i += k) {\\n        for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n            l += words[i+k].size();\\n        }\\n        string tmp = words[i];\\n        for(int j = 0; j < k - 1; j++) {\\n            if(i + k >= words.size()) tmp += \" \";\\n            else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), \\' \\');\\n            tmp += words[i+j+1];\\n        }\\n        tmp += string(L - tmp.size(), \\' \\');\\n        res.push_back(tmp);\\n    }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int L) {\\n         vector<string> res;\\n    for(int i = 0, k, l; i < words.size(); i += k) {\\n        for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n            l += words[i+k].size();\\n        }\\n        string tmp = words[i];\\n        for(int j = 0; j < k - 1; j++) {\\n            if(i + k >= words.size()) tmp += \" \";\\n            else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), \\' \\');\\n            tmp += words[i+j+1];\\n        }\\n        tmp += string(L - tmp.size(), \\' \\');\\n        res.push_back(tmp);\\n    }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192845,
                "title": "java-solution-with-o-n-time-o-1-space-complexity",
                "content": "```\\npublic List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n\\n        for(int i=0; i<words.length; i++) {\\n            StringBuilder line = new StringBuilder();\\n            int len = 0;\\n            int wlen =0;\\n            int start=i;\\n            int end = i;\\n            while(end<words.length && len + words[end].length() <= maxWidth) {\\n                len += words[end].length()+1;\\n                wlen += words[end].length();\\n                end++;\\n            }\\n            int gaps = end - start - 1;\\n            int padding = end == words.length ? gaps : maxWidth-wlen;\\n\\n            int spacing = gaps == 0 ? 1 : padding / gaps;\\n            int extraSpace = gaps != 0 ? padding % gaps : 0;\\n            for(int j=start; j<end; j++) {\\n                line.append(words[j]);\\n                if(j!= end-1) {\\n                    line.append(\" \".repeat(spacing));\\n                }\\n                if(extraSpace>0) {\\n                    line.append(\" \");\\n                    extraSpace--;\\n                }\\n            }\\n            while(line.length() < maxWidth) {\\n                line.append(\" \");\\n            }\\n            i = end-1;\\n            result.add(line.toString());\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n\\n        for(int i=0; i<words.length; i++) {\\n            StringBuilder line = new StringBuilder();\\n            int len = 0;\\n            int wlen =0;\\n            int start=i;\\n            int end = i;\\n            while(end<words.length && len + words[end].length() <= maxWidth) {\\n                len += words[end].length()+1;\\n                wlen += words[end].length();\\n                end++;\\n            }\\n            int gaps = end - start - 1;\\n            int padding = end == words.length ? gaps : maxWidth-wlen;\\n\\n            int spacing = gaps == 0 ? 1 : padding / gaps;\\n            int extraSpace = gaps != 0 ? padding % gaps : 0;\\n            for(int j=start; j<end; j++) {\\n                line.append(words[j]);\\n                if(j!= end-1) {\\n                    line.append(\" \".repeat(spacing));\\n                }\\n                if(extraSpace>0) {\\n                    line.append(\" \");\\n                    extraSpace--;\\n                }\\n            }\\n            while(line.length() < maxWidth) {\\n                line.append(\" \");\\n            }\\n            i = end-1;\\n            result.add(line.toString());\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176270,
                "title": "javascript-simple-commented-iterative-solution",
                "content": "Based on [this solution](https://leetcode.com/problems/text-justification/discuss/446139/Well-commented-JavaScript-solution)\\n\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n\\n**Intuition**\\n\\nAs we iterate through the words to form a line, we need to keep track of two things:\\n\\n1) How much space is left in that line\\n2) The words we\\'ve used so far in the line\\n\\nFor the space left, we can start with the `maxWidth` and decrease it by the length of any newly added word and the space needed to separate it from the previous word.  We can use an array to keep track of the words added so far to the line and perform a simple join operation later on to construct the line with a space between each word.  If a new word would cause the line to exceed the `maxWidth`, we can justify the existing line and start a new line with that word.\\n\\nThe tricky part comes from figuring out how to justify a line.  If a line only has a single word, it\\'s treated like the final line in which the word is left justified and any remaining space is added to the end.  If there\\'s more than one word, we\\'ll need to iteratively add the space remaining to each letter at a time which can be accomplished with a while loop that keeps track of which index in the array of words we should be on in each iteration.\\n\\nAfter we exit the for loop, we\\'ve finished checking each word, but if the line array still has words in it, we treat it as the final line in which everything needs to be left justified and whatever is left is filled with trailing spaces.  We simply join the words with an empty space and add on the difference between `maxWidth` and the length of the words + the spaces between them.\\n\\n```\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [];\\n    let line = [words[0]];\\n\\t// spaceLeft will keep track of the trailing space left after\\n\\t// accounting for both the length of the words and the spaces between them\\n    let spaceLeft = maxWidth - words[0].length;\\n    \\n    for (let i = 1; i < words.length; i++) {\\n        // Only add a new word to the line if\\n        // there\\'s enough space for it and the \\n        // space before it.\\n        const word = words[i];\\n        if (spaceLeft >= word.length + 1) {\\n            line.push(word);\\n            spaceLeft -= (word.length + 1);\\n        } else {\\n\\t\\t\\t// There\\'s not enough space left for the word\\n\\t\\t\\t// and the space before it.  Justify the existing\\n\\t\\t\\t// line and start a new line with the word.\\n            res.push(justifyLine(line, spaceLeft));\\n            line = [word];\\n            spaceLeft = maxWidth - word.length;\\n        }\\n    }\\n    \\n    // We\\'ve added the final word but there\\'s still space \\n    // left. In this case, we justify the line left and add\\n    // all the left over space to the end of the line.\\n    if (line.length) {\\n        let lastLine = line.join(\\' \\');\\n        lastLine += \\' \\'.repeat(maxWidth - lastLine.length);\\n        res.push(lastLine);\\n    }\\n    \\n    return res;\\n};\\n\\nconst justifyLine = (line, spaceLeft) => {\\n    // Remember, if there\\'s only a single word, it\\'s treated\\n\\t// as being left justified so all the spaces are added to the end\\n\\tif (line.length === 1) {\\n        return line[0] + \\' \\'.repeat(spaceLeft);\\n    }\\n    \\n    // The total amount of spacing will be the spaces\\n    // between words and the space left. Since we can let\\n    // the join operation take care of the spaces between\\n    // words, we only need to add the space left.\\n    let i = 0;\\n    while (spaceLeft > 0) {\\n        line[i] += \\' \\';\\n        // We don\\'t want to add a space to the final word\\n        // so when we reach it, we loop back to the start\\n        i = (i + 1) % (line.length - 1);\\n        spaceLeft--;\\n    }\\n    \\n    return line.join(\\' \\');\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/9862f77b-4ef5-4cba-9de3-a64aeb7ef0d1_1655759410.4639826.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [];\\n    let line = [words[0]];\\n\\t// spaceLeft will keep track of the trailing space left after\\n\\t// accounting for both the length of the words and the spaces between them\\n    let spaceLeft = maxWidth - words[0].length;\\n    \\n    for (let i = 1; i < words.length; i++) {\\n        // Only add a new word to the line if\\n        // there\\'s enough space for it and the \\n        // space before it.\\n        const word = words[i];\\n        if (spaceLeft >= word.length + 1) {\\n            line.push(word);\\n            spaceLeft -= (word.length + 1);\\n        } else {\\n\\t\\t\\t// There\\'s not enough space left for the word\\n\\t\\t\\t// and the space before it.  Justify the existing\\n\\t\\t\\t// line and start a new line with the word.\\n            res.push(justifyLine(line, spaceLeft));\\n            line = [word];\\n            spaceLeft = maxWidth - word.length;\\n        }\\n    }\\n    \\n    // We\\'ve added the final word but there\\'s still space \\n    // left. In this case, we justify the line left and add\\n    // all the left over space to the end of the line.\\n    if (line.length) {\\n        let lastLine = line.join(\\' \\');\\n        lastLine += \\' \\'.repeat(maxWidth - lastLine.length);\\n        res.push(lastLine);\\n    }\\n    \\n    return res;\\n};\\n\\nconst justifyLine = (line, spaceLeft) => {\\n    // Remember, if there\\'s only a single word, it\\'s treated\\n\\t// as being left justified so all the spaces are added to the end\\n\\tif (line.length === 1) {\\n        return line[0] + \\' \\'.repeat(spaceLeft);\\n    }\\n    \\n    // The total amount of spacing will be the spaces\\n    // between words and the space left. Since we can let\\n    // the join operation take care of the spaces between\\n    // words, we only need to add the space left.\\n    let i = 0;\\n    while (spaceLeft > 0) {\\n        line[i] += \\' \\';\\n        // We don\\'t want to add a space to the final word\\n        // so when we reach it, we loop back to the start\\n        i = (i + 1) % (line.length - 1);\\n        spaceLeft--;\\n    }\\n    \\n    return line.join(\\' \\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2033072,
                "title": "python-easy-solution-explanation-faster-than-92-03-o-n",
                "content": "\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:    \\n        justified = []\\n        currRow = [] # the current row of strings that fit in maxWidth accounting for additional spaces\\n\\t\\t\\n        for i in range(len(words)):\\n            space = maxWidth # track space available\\n            space_occupied = 0 # track space taken\\n            for j in range(len(currRow)):\\n                wordLength = len(currRow[j])\\n                space_occupied += wordLength\\n                space -= wordLength\\n            \\n            # adjust for the spaces needed for each word which is the number of words - 1\\n            space -= len(currRow) - 1\\n            \\n            # if there is still space for another word and a space\\n            # append the word to the current row\\n            if space >= len(words[i]) + 1:\\n                currRow.append(words[i])\\n                \\n            # if not, append the justified row and assign the word the current row as the first  and only element\\n            else:\\n                row = self.justifyRow(currRow, maxWidth, space_occupied)\\n                justified.append(row)\\n                currRow = [words[i]]\\n               \\n\\t\\t# append the last row justifying it left\\n        if len(currRow) > 0:\\n            last = \"\"\\n            for i in range(len(currRow)):\\n                last += currRow[i] + \" \" if len(last) + len(currRow[i]) < maxWidth else currRow[i]\\n            justified.append(last.ljust(maxWidth))\\n            \\n        return justified\\n                \\n    # justifies the row given the row, max width, and the space occupied\\n    def justifyRow(self, row: List[str], maxWidth: int, space_occupied: int) -> str:\\n        length = len(row)\\n\\t\\t# return left justified if it is the only word in the row\\n        if length == 1:\\n            return row[0].ljust(maxWidth)\\n        else:\\n            justifiedRow = \"\"\\n            space_avail = maxWidth - space_occupied\\n            additional = space_avail % (length - 1)  # number of additional spaces needed for unevenness\\n            space_between = space_avail // (length - 1)  # the base number of spaces in between each word\\n            for i in range(length):\\n                justLen = len(row[i]) + space_between  # number of spaces for each word without additional\\n                # if there are additional spaces left, append it to the current word\\n\\t\\t\\t\\tif additional > 0:\\n                    justifiedRow += row[i].ljust(justLen + 1)\\n                    additional -= 1\\n\\t\\t\\t\\t# since all words and their spaces in between are accounted for, append the last word\\n                elif i == length - 1:\\n                    justifiedRow += row[i]\\n\\t\\t\\t\\t# everything else needs to add the space between\\n                else:\\n                    justifiedRow += row[i].ljust(justLen)\\n            \\n            return justifiedRow",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:    \\n        justified = []\\n        currRow = [] # the current row of strings that fit in maxWidth accounting for additional spaces\\n\\t\\t\\n        for i in range(len(words)):\\n            space = maxWidth # track space available\\n            space_occupied = 0 # track space taken\\n            for j in range(len(currRow)):\\n                wordLength = len(currRow[j])\\n                space_occupied += wordLength\\n                space -= wordLength\\n            \\n            # adjust for the spaces needed for each word which is the number of words - 1\\n            space -= len(currRow) - 1\\n            \\n            # if there is still space for another word and a space\\n            # append the word to the current row\\n            if space >= len(words[i]) + 1:\\n                currRow.append(words[i])\\n                \\n            # if not, append the justified row and assign the word the current row as the first  and only element\\n            else:\\n                row = self.justifyRow(currRow, maxWidth, space_occupied)\\n                justified.append(row)\\n                currRow = [words[i]]\\n               \\n\\t\\t# append the last row justifying it left\\n        if len(currRow) > 0:\\n            last = \"\"\\n            for i in range(len(currRow)):\\n                last += currRow[i] + \" \" if len(last) + len(currRow[i]) < maxWidth else currRow[i]\\n            justified.append(last.ljust(maxWidth))\\n            \\n        return justified\\n                \\n    # justifies the row given the row, max width, and the space occupied\\n    def justifyRow(self, row: List[str], maxWidth: int, space_occupied: int) -> str:\\n        length = len(row)\\n\\t\\t# return left justified if it is the only word in the row\\n        if length == 1:\\n            return row[0].ljust(maxWidth)\\n        else:\\n            justifiedRow = \"\"\\n            space_avail = maxWidth - space_occupied\\n            additional = space_avail % (length - 1)  # number of additional spaces needed for unevenness\\n            space_between = space_avail // (length - 1)  # the base number of spaces in between each word\\n            for i in range(length):\\n                justLen = len(row[i]) + space_between  # number of spaces for each word without additional\\n                # if there are additional spaces left, append it to the current word\\n\\t\\t\\t\\tif additional > 0:\\n                    justifiedRow += row[i].ljust(justLen + 1)\\n                    additional -= 1\\n\\t\\t\\t\\t# since all words and their spaces in between are accounted for, append the last word\\n                elif i == length - 1:\\n                    justifiedRow += row[i]\\n\\t\\t\\t\\t# everything else needs to add the space between\\n                else:\\n                    justifiedRow += row[i].ljust(justLen)\\n            \\n            return justifiedRow",
                "codeTag": "Python3"
            },
            {
                "id": 2023640,
                "title": "simple-java-solution-with-detailed-explanation",
                "content": "Break this problem into two parts.\\n1. Separate the words for each line\\n2. Format each line by applying text alignment (Either middle alignment or left alignment)\\n\\n# Now Lets see how can we separate words from the input per line.\\nSuppose our input looks like below\\n**Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16**\\nThe output will be like below\\n**\"This    is    an\",\\n\"example  of text\",\\n\"justification.  \"**\\n\\nSo for each line we may have multiple words(String). So lets declare a List which items is aslo a list to store our word. Again the end result will be just a plain string list. Lets define also\\n```\\nList<List<String>> lines = new ArrayList<>();\\nList<String> result = new ArrayList<>();\\n```\\n\\nNow how we are going to pick word for a line? Suppose you have a word and a line. You can place this word in that line if after adding the word total size of this line (Total character) will not increase the maxWidth. So suppose you picked that word. Now for the next word you need to know how many remaining characters you have. So we need to track the remaining characters per line. Initially remaining characters will be maxWidth. So inside a map we the key will be line index and value will be the remaining characters.\\n\\nLets declare the map as well as insert initial value for the lines and remaining characters for that line like below\\n```\\nint currentLine = 0;\\nlines.add(new ArrayList<String>());\\ncharMap.put(currentLine, maxWidth);\\n```\\n\\nNow we have the initial setup. In which line we are adding the next word will be determined by **currentLine** variable. Iniially it is 0 as we are filling from the first line (index 0).\\n\\nNow we loop through all the words and try to put those words in the line. \\n```\\nfor (String word : words) {\\n     int remainingChar = charMap.get(currentLine);\\n     if (word.length() <= remainingChar) {\\n         addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n      } else {\\n         currentLine++;\\n         lines.add(new ArrayList<String>());\\n         charMap.put(currentLine, maxWidth);\\n         addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n      }\\n}\\n```\\n\\nThats it. So what we did? Initially currentLine = 0 and at first we inserted maxWidth for the 0 in the **charMap**. So remainingChar is 16 here. Now we are checking if **current word <= remainingChar** . If it is we will add this word in the line by calling the function addWordToLine. \\n\\nIf not that means we need a new line. Right? So we are incrementing the currentLine number adding a new ArrayList in the lines as well as remainingCharacter for that line. So we have a new line setup. Now we can call addWordToLine() function to add the word in the line.\\n\\n**Now lets look what is happening inside addWordToLine function.**\\n\\n```\\n public void addWordToLine(\\n        Integer currentLine, \\n        List<List<String>> lines, \\n        Map<Integer, Integer> charMap, \\n        String word,\\n        int maxWidth) {\\n        \\n        lines.get(currentLine).add(word);\\n        // Now change remaining and add space if required\\n        charMap.put(currentLine, charMap.get(currentLine) - word.length());\\n       \\n        // We have to add a space if at least one position left otherwise we\\n        // can not add a new word. So subtracting one from remaining character\\n        if (charMap.get(currentLine) != 0) {\\n            charMap.put(currentLine, charMap.get(currentLine) - 1);\\n        }\\n    }\\n```\\n\\nAs this function called, we know that we can add the word. So added the word in the first line. As we added the word we need to subtract the word length from the remainingChar. So we did that in the second line.\\n\\nNow we have a very crucial trick here. After adding a word it may cover the maxLength. Its ok. But if we have more space left then a new word can come in this line next. So between two words we must seprate them by a space. Right? So if for this line if we have space left we will consider a space. Hence, we subtracted 1 from the remainingChar. (This is important. If you find difficult read this paragraph and rethink multiple times.) \\n\\nSo we have separated all the words based on lines. Now we need to format those line to generate the output.\\n\\n# Lets see how can we format the lines?\\n```\\n public void formatLines(\\n        List<List<String>> lines, \\n        List<String> result, \\n        int maxWidth\\n    ) {\\n       for (int currentLine = 0; currentLine < lines.size(); currentLine++) {\\n           List<String> line = lines.get(currentLine);\\n           \\n           if (line.size() == 1 || currentLine == lines.size() - 1) {\\n               result.add(makeLeftAligned(line, maxWidth));\\n           } else {\\n               result.add(makeMiddleAligned(line, maxWidth));\\n           }\\n       }  \\n    }\\n```\\n\\nSimple function. Right? Now think when you will do left justification and when midddle justification? If a line contains only one word it will be left justified or left aligned. Also if a line is the last line it will be left justified. So we did this here. For the alignment we passing the line and maxWidth to two separate function **makeLeftAligned** and **makeMiddleAligned**\\n\\n**Now first see what is happening inside makeLeftAligned function**\\nPreviously in a line list we just added the string but did not added any spaces. Now we have to add spaces between word as well as space in the end if required.\\n\\n```\\n ublic String makeLeftAligned(List<String> words, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingPos = maxWidth - getCharacterCount(words);\\n        \\n        for (String word : words) {\\n            builder.append(word);\\n            if (remainingPos > 0) {\\n                builder.append(\\' \\');\\n                remainingPos--;\\n            }\\n        }\\n        \\n        while (remainingPos > 0) {\\n            builder.append(\\' \\');\\n            remainingPos--;\\n        }\\n        \\n        return builder.toString();\\n    }\\n```\\n\\nI think you understand what I did. First we called a function **getCharacterCount** which just return the total word. You can optmize here. You can calculate this while adding word in the line in the first method. However, I did like this to keep my code clean. Here is the getCharacterCount function\\n\\n```\\n private int getCharacterCount(List<String> line) {\\n        int count = 0;\\n        for (String word : line) {\\n            count += word.length();\\n        }\\n        return count;\\n    }\\n```\\n\\nSo we first get the actual character count. Then we subtracted it from maxWidth to get the remainingCharacter. This we need to fill with spacea. So for each character we are adding a space and we decrementing the remainingPos variable. So we added one space between words. But we may have remaining position in the end. So we fill those position with space inside while loop.\\n\\n**Now see what we did inside makeMiddleAligned function?**\\n\\n```\\n public String makeMiddleAligned(List<String> line, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingChar = maxWidth - getCharacterCount(line);\\n        \\n        for (int i = 0; i < line.size(); i++) {\\n            builder.append(line.get(i));\\n            \\n            // Do not add space after last word\\n            if (i != line.size() - 1) {\\n                int wordsRequiredSpaceCount = line.size() -i - 1;\\n                int spaces = (int) Math.ceil((double) remainingChar / (double) wordsRequiredSpaceCount);\\n                remainingChar -= spaces;\\n                \\n                for (int j = 0; j < spaces; j++) {\\n                    builder.append(\\' \\');\\n                }\\n            } \\n        }\\n        \\n        return builder.toString();\\n    }\\n```\\n\\nFirst calculated the remainingChar which we need to fillup. In case of middle alignment it is littlle bit tricky. We need to add spaces between words. So we could not add space after last word. Now how can we know how many space we need to add after each word? Again remainingChar can be odd number. So how we are going to distribute those spaces?\\n\\nDon\\'t worry. Space after each word will be\\nint spaces = Ceil(remainingChar / (wordCountPerLine - i - 1))\\nWhy we are doing that? If we have 3 word we are putting the spaces before two words or we can say after two words. So thats why -1. Now why -i? Suppose we have 5 remainingChar and wordCountPerLine = 3.\\nSo after adding 1 word to stringbuilder it will go inside if and i = 0 so\\nspaces = Ceil(5 / ( 3 - 0 - 1) )\\nspaces = Ceil (5 / 2)\\nspaces = 3\\n\\nSo after the first word it will put three spaces and we subtract this from remainChar as it has been full filled with spaces.\\nremainChar = 5 - 3 = 2\\nNow when i = 1 means adding another word what will happen?\\nspaces = Ceil (2 / (3 - 1 - 1))\\nspaces = Ceil (2 / 1)\\nspaces = 2\\n\\nSo we need to give 2 spaces. After that remainingChar will be 0. \\n\\nNow we can return the result. Lets look the whole code at once\\n\\n```\\n public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<List<String>> lines = new ArrayList<>();\\n        List<String> result = new ArrayList<>();\\n        Map<Integer, Integer> charMap = new HashMap<>();\\n        int currentLine = 0;\\n        \\n        lines.add(new ArrayList<String>());\\n        charMap.put(currentLine, maxWidth);\\n        \\n        for (String word : words) {\\n            int remainingChar = charMap.get(currentLine);\\n            if (word.length() <= remainingChar) {\\n                addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n            } else {\\n                currentLine++;\\n                lines.add(new ArrayList<String>());\\n                charMap.put(currentLine, maxWidth);\\n                addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n            }\\n        }\\n            \\n        formatLines(lines, result, maxWidth);\\n        return result;\\n    }\\n    \\n    public void addWordToLine(\\n        Integer currentLine, \\n        List<List<String>> lines, \\n        Map<Integer, Integer> charMap, \\n        String word,\\n        int maxWidth) {\\n        \\n        lines.get(currentLine).add(word);\\n        // Now change remaining and add space if required\\n        charMap.put(currentLine, charMap.get(currentLine) - word.length());\\n       \\n        // We have to add a space if at least one position left otherwise we\\n        // can not add a new word. So subtracting one from remaining character\\n        if (charMap.get(currentLine) != 0) {\\n            charMap.put(currentLine, charMap.get(currentLine) - 1);\\n        }\\n    }              \\n    \\n    public void formatLines(\\n        List<List<String>> lines, \\n        List<String> result, \\n        int maxWidth\\n    ) {\\n       for (int currentLine = 0; currentLine < lines.size(); currentLine++) {\\n           List<String> line = lines.get(currentLine);\\n           \\n           if (line.size() == 1 || currentLine == lines.size() - 1) {\\n               result.add(makeLeftAligned(line, maxWidth));\\n           } else {\\n               result.add(makeMiddleAligned(line, maxWidth));\\n           }\\n       }  \\n    }\\n    \\n    public String makeLeftAligned(List<String> words, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingPos = maxWidth - getCharacterCount(words);\\n        \\n        for (String word : words) {\\n            builder.append(word);\\n            if (remainingPos > 0) {\\n                builder.append(\\' \\');\\n                remainingPos--;\\n            }\\n        }\\n        \\n        while (remainingPos > 0) {\\n            builder.append(\\' \\');\\n            remainingPos--;\\n        }\\n        \\n        return builder.toString();\\n    }\\n    \\n    public String makeMiddleAligned(List<String> line, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingChar = maxWidth - getCharacterCount(line);\\n        \\n        for (int i = 0; i < line.size(); i++) {\\n            builder.append(line.get(i));\\n            \\n            // Do not add space after last word\\n            if (i != line.size() - 1) {\\n                int wordsRequiredSpaceCount = line.size() -i - 1;\\n                int spaces = (int) Math.ceil((double) remainingChar / (double) wordsRequiredSpaceCount);\\n                remainingChar -= spaces;\\n                \\n                for (int j = 0; j < spaces; j++) {\\n                    builder.append(\\' \\');\\n                }\\n            } \\n        }\\n        \\n        return builder.toString();\\n    }\\n    \\n    private int getCharacterCount(List<String> line) {\\n        int count = 0;\\n        for (String word : line) {\\n            count += word.length();\\n        }\\n        return count;\\n    }\\n```\\n\\nIt looks large. But if you break down the problem multiple steps you can unit test each and every function and can check your logic. \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nList<List<String>> lines = new ArrayList<>();\\nList<String> result = new ArrayList<>();\\n```\n```\\nint currentLine = 0;\\nlines.add(new ArrayList<String>());\\ncharMap.put(currentLine, maxWidth);\\n```\n```\\nfor (String word : words) {\\n     int remainingChar = charMap.get(currentLine);\\n     if (word.length() <= remainingChar) {\\n         addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n      } else {\\n         currentLine++;\\n         lines.add(new ArrayList<String>());\\n         charMap.put(currentLine, maxWidth);\\n         addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n      }\\n}\\n```\n```\\n public void addWordToLine(\\n        Integer currentLine, \\n        List<List<String>> lines, \\n        Map<Integer, Integer> charMap, \\n        String word,\\n        int maxWidth) {\\n        \\n        lines.get(currentLine).add(word);\\n        // Now change remaining and add space if required\\n        charMap.put(currentLine, charMap.get(currentLine) - word.length());\\n       \\n        // We have to add a space if at least one position left otherwise we\\n        // can not add a new word. So subtracting one from remaining character\\n        if (charMap.get(currentLine) != 0) {\\n            charMap.put(currentLine, charMap.get(currentLine) - 1);\\n        }\\n    }\\n```\n```\\n public void formatLines(\\n        List<List<String>> lines, \\n        List<String> result, \\n        int maxWidth\\n    ) {\\n       for (int currentLine = 0; currentLine < lines.size(); currentLine++) {\\n           List<String> line = lines.get(currentLine);\\n           \\n           if (line.size() == 1 || currentLine == lines.size() - 1) {\\n               result.add(makeLeftAligned(line, maxWidth));\\n           } else {\\n               result.add(makeMiddleAligned(line, maxWidth));\\n           }\\n       }  \\n    }\\n```\n```\\n ublic String makeLeftAligned(List<String> words, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingPos = maxWidth - getCharacterCount(words);\\n        \\n        for (String word : words) {\\n            builder.append(word);\\n            if (remainingPos > 0) {\\n                builder.append(\\' \\');\\n                remainingPos--;\\n            }\\n        }\\n        \\n        while (remainingPos > 0) {\\n            builder.append(\\' \\');\\n            remainingPos--;\\n        }\\n        \\n        return builder.toString();\\n    }\\n```\n```\\n private int getCharacterCount(List<String> line) {\\n        int count = 0;\\n        for (String word : line) {\\n            count += word.length();\\n        }\\n        return count;\\n    }\\n```\n```\\n public String makeMiddleAligned(List<String> line, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingChar = maxWidth - getCharacterCount(line);\\n        \\n        for (int i = 0; i < line.size(); i++) {\\n            builder.append(line.get(i));\\n            \\n            // Do not add space after last word\\n            if (i != line.size() - 1) {\\n                int wordsRequiredSpaceCount = line.size() -i - 1;\\n                int spaces = (int) Math.ceil((double) remainingChar / (double) wordsRequiredSpaceCount);\\n                remainingChar -= spaces;\\n                \\n                for (int j = 0; j < spaces; j++) {\\n                    builder.append(\\' \\');\\n                }\\n            } \\n        }\\n        \\n        return builder.toString();\\n    }\\n```\n```\\n public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<List<String>> lines = new ArrayList<>();\\n        List<String> result = new ArrayList<>();\\n        Map<Integer, Integer> charMap = new HashMap<>();\\n        int currentLine = 0;\\n        \\n        lines.add(new ArrayList<String>());\\n        charMap.put(currentLine, maxWidth);\\n        \\n        for (String word : words) {\\n            int remainingChar = charMap.get(currentLine);\\n            if (word.length() <= remainingChar) {\\n                addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n            } else {\\n                currentLine++;\\n                lines.add(new ArrayList<String>());\\n                charMap.put(currentLine, maxWidth);\\n                addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n            }\\n        }\\n            \\n        formatLines(lines, result, maxWidth);\\n        return result;\\n    }\\n    \\n    public void addWordToLine(\\n        Integer currentLine, \\n        List<List<String>> lines, \\n        Map<Integer, Integer> charMap, \\n        String word,\\n        int maxWidth) {\\n        \\n        lines.get(currentLine).add(word);\\n        // Now change remaining and add space if required\\n        charMap.put(currentLine, charMap.get(currentLine) - word.length());\\n       \\n        // We have to add a space if at least one position left otherwise we\\n        // can not add a new word. So subtracting one from remaining character\\n        if (charMap.get(currentLine) != 0) {\\n            charMap.put(currentLine, charMap.get(currentLine) - 1);\\n        }\\n    }              \\n    \\n    public void formatLines(\\n        List<List<String>> lines, \\n        List<String> result, \\n        int maxWidth\\n    ) {\\n       for (int currentLine = 0; currentLine < lines.size(); currentLine++) {\\n           List<String> line = lines.get(currentLine);\\n           \\n           if (line.size() == 1 || currentLine == lines.size() - 1) {\\n               result.add(makeLeftAligned(line, maxWidth));\\n           } else {\\n               result.add(makeMiddleAligned(line, maxWidth));\\n           }\\n       }  \\n    }\\n    \\n    public String makeLeftAligned(List<String> words, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingPos = maxWidth - getCharacterCount(words);\\n        \\n        for (String word : words) {\\n            builder.append(word);\\n            if (remainingPos > 0) {\\n                builder.append(\\' \\');\\n                remainingPos--;\\n            }\\n        }\\n        \\n        while (remainingPos > 0) {\\n            builder.append(\\' \\');\\n            remainingPos--;\\n        }\\n        \\n        return builder.toString();\\n    }\\n    \\n    public String makeMiddleAligned(List<String> line, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingChar = maxWidth - getCharacterCount(line);\\n        \\n        for (int i = 0; i < line.size(); i++) {\\n            builder.append(line.get(i));\\n            \\n            // Do not add space after last word\\n            if (i != line.size() - 1) {\\n                int wordsRequiredSpaceCount = line.size() -i - 1;\\n                int spaces = (int) Math.ceil((double) remainingChar / (double) wordsRequiredSpaceCount);\\n                remainingChar -= spaces;\\n                \\n                for (int j = 0; j < spaces; j++) {\\n                    builder.append(\\' \\');\\n                }\\n            } \\n        }\\n        \\n        return builder.toString();\\n    }\\n    \\n    private int getCharacterCount(List<String> line) {\\n        int count = 0;\\n        for (String word : line) {\\n            count += word.length();\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640627,
                "title": "java-much-more-readable-clean-1ms-solution-with-inline-comments",
                "content": "```\\n  public List<String> fullJustify(String[] words, int maxWidth) {\\n    var result = new ArrayList<String>();\\n    // Trick: Use queue and poll, cleaner way to collect & process words. No messy cursors\\n    // No need to renew too, naturally polled empty\\n    var wordList = new LinkedList<String>();\\n    var textWidth = 0;\\n\\n    for (int i = 0; i < words.length; ) {\\n      // Need minimum 1 whitespace btw words!\\n      // Trick: Use wordsToAdd.size to account for whitespaces, instead of +1 to width!\\n      // Naturally excludes last word\\'s, doesn\\'t include curr count.\\n      if (textWidth + words[i].length() + wordList.size() <= maxWidth) {\\n        textWidth += words[i].length();\\n        wordList.add(words[i]);\\n        i++;\\n        continue;\\n      }\\n\\n      var spacesInbtw = (maxWidth - textWidth) / Math.max(1, wordList.size() - 1);\\n      var extraSpaces = (maxWidth - textWidth) % Math.max(1, wordList.size() - 1);\\n\\n      var line = generateLine(wordList, maxWidth, spacesInbtw, extraSpaces--);\\n      result.add(line);\\n      textWidth = 0;\\n    }\\n\\n    var line = generateLine(wordList, maxWidth, 1, 0);\\n    result.add(line);\\n\\n    return result;\\n  }\\n\\n  private String generateLine(LinkedList<String> wordsToAdd, int maxWidth, int spacesBtw, int extraSpaces) {\\n    var line = new StringBuffer();\\n    var spaces = addSpaces(spacesBtw);\\n    while (wordsToAdd.size() > 0) {\\n      line.append(wordsToAdd.poll())\\n        .append(spaces)\\n        .append(extraSpaces-- > 0 ? \" \" : \"\");\\n    }\\n    // For filling last line\\n    line.append(addSpaces(maxWidth - line.length()));\\n    return line.substring(0, maxWidth);\\n  }\\n\\n  private String addSpaces(int spaceWidth) {\\n    var spaces = new StringBuffer();\\n    while (spaceWidth-- > 0) {\\n      spaces.append(\" \");\\n    }\\n    return spaces.toString();\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public List<String> fullJustify(String[] words, int maxWidth) {\\n    var result = new ArrayList<String>();\\n    // Trick: Use queue and poll, cleaner way to collect & process words. No messy cursors\\n    // No need to renew too, naturally polled empty\\n    var wordList = new LinkedList<String>();\\n    var textWidth = 0;\\n\\n    for (int i = 0; i < words.length; ) {\\n      // Need minimum 1 whitespace btw words!\\n      // Trick: Use wordsToAdd.size to account for whitespaces, instead of +1 to width!\\n      // Naturally excludes last word\\'s, doesn\\'t include curr count.\\n      if (textWidth + words[i].length() + wordList.size() <= maxWidth) {\\n        textWidth += words[i].length();\\n        wordList.add(words[i]);\\n        i++;\\n        continue;\\n      }\\n\\n      var spacesInbtw = (maxWidth - textWidth) / Math.max(1, wordList.size() - 1);\\n      var extraSpaces = (maxWidth - textWidth) % Math.max(1, wordList.size() - 1);\\n\\n      var line = generateLine(wordList, maxWidth, spacesInbtw, extraSpaces--);\\n      result.add(line);\\n      textWidth = 0;\\n    }\\n\\n    var line = generateLine(wordList, maxWidth, 1, 0);\\n    result.add(line);\\n\\n    return result;\\n  }\\n\\n  private String generateLine(LinkedList<String> wordsToAdd, int maxWidth, int spacesBtw, int extraSpaces) {\\n    var line = new StringBuffer();\\n    var spaces = addSpaces(spacesBtw);\\n    while (wordsToAdd.size() > 0) {\\n      line.append(wordsToAdd.poll())\\n        .append(spaces)\\n        .append(extraSpaces-- > 0 ? \" \" : \"\");\\n    }\\n    // For filling last line\\n    line.append(addSpaces(maxWidth - line.length()));\\n    return line.substring(0, maxWidth);\\n  }\\n\\n  private String addSpaces(int spaceWidth) {\\n    var spaces = new StringBuffer();\\n    while (spaceWidth-- > 0) {\\n      spaces.append(\" \");\\n    }\\n    return spaces.toString();\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1518515,
                "title": "c-90-speed",
                "content": "I never see .NET code on here so here is my C# version. I tried to break out the functions to make it easier to read.\\n\\n```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        IList<string> retval = new List<string>();\\n        \\n        List<string> lwords = new List<string>();\\n        int sublen = 0;\\n        int words_len = 0;\\n        foreach(string word in words){\\n            sublen += word.Length + 1;\\n            //\\'+1\\' is for the space added above\\n            if(sublen > maxWidth + 1){ \\n                string line = BuildLine(lwords, maxWidth, words_len);\\n                retval.Add(line);\\n                lwords.Clear();\\n                //Remember to add back in the current word\\n                sublen = word.Length + 1;\\n                words_len = 0;\\n            }\\n            lwords.Add(word);     \\n            words_len += word.Length;       \\n        }\\n        \\n        //Do any remaining words\\n        if(lwords.Count() > 0 ){\\n            string line = \"\";\\n            foreach(string word in lwords){\\n                line += $\"{word} \";\\n            }\\n            //NOTE: \\'Trim()\\' is to remove the space on the last word\\n            line = line.Trim().PadRight(maxWidth);\\n            retval.Add(line);\\n        }\\n        \\n        return retval;\\n    }\\n    \\n    private string BuildLine(List<string> words, int maxWidth, int words_len){\\n        int word_count = words.Count();\\n        int spaces = maxWidth - words_len;\\n        \\n        //Special Cases: Handle a single or double word\\n        if(word_count == 1){\\n            return words[0].PadRight(maxWidth);\\n        }else if (word_count == 2){\\n            return words[0] + \"\".PadRight(spaces) + words[1];\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        //Number of space blocks\\n        int num_of_spaces = word_count - 1;\\n        //spaces per space block\\n        int spaces_per_word = spaces / num_of_spaces;\\n        //Extra spaces\\n        int extra = spaces % num_of_spaces;\\n        \\n        for(int i = 0; i < word_count; i++){\\n            string word = words[i];\\n            sb.Append(word);\\n            //Append spaces except for the last word\\n            if( i != word_count - 1)\\n                sb.Append(\\' \\',spaces_per_word);\\n            //Check for extra spaces\\n            if( extra > 0 ){\\n                sb.Append(\\' \\',1);\\n                extra--;\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        IList<string> retval = new List<string>();\\n        \\n        List<string> lwords = new List<string>();\\n        int sublen = 0;\\n        int words_len = 0;\\n        foreach(string word in words){\\n            sublen += word.Length + 1;\\n            //\\'+1\\' is for the space added above\\n            if(sublen > maxWidth + 1){ \\n                string line = BuildLine(lwords, maxWidth, words_len);\\n                retval.Add(line);\\n                lwords.Clear();\\n                //Remember to add back in the current word\\n                sublen = word.Length + 1;\\n                words_len = 0;\\n            }\\n            lwords.Add(word);     \\n            words_len += word.Length;       \\n        }\\n        \\n        //Do any remaining words\\n        if(lwords.Count() > 0 ){\\n            string line = \"\";\\n            foreach(string word in lwords){\\n                line += $\"{word} \";\\n            }\\n            //NOTE: \\'Trim()\\' is to remove the space on the last word\\n            line = line.Trim().PadRight(maxWidth);\\n            retval.Add(line);\\n        }\\n        \\n        return retval;\\n    }\\n    \\n    private string BuildLine(List<string> words, int maxWidth, int words_len){\\n        int word_count = words.Count();\\n        int spaces = maxWidth - words_len;\\n        \\n        //Special Cases: Handle a single or double word\\n        if(word_count == 1){\\n            return words[0].PadRight(maxWidth);\\n        }else if (word_count == 2){\\n            return words[0] + \"\".PadRight(spaces) + words[1];\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        //Number of space blocks\\n        int num_of_spaces = word_count - 1;\\n        //spaces per space block\\n        int spaces_per_word = spaces / num_of_spaces;\\n        //Extra spaces\\n        int extra = spaces % num_of_spaces;\\n        \\n        for(int i = 0; i < word_count; i++){\\n            string word = words[i];\\n            sb.Append(word);\\n            //Append spaces except for the last word\\n            if( i != word_count - 1)\\n                sb.Append(\\' \\',spaces_per_word);\\n            //Check for extra spaces\\n            if( extra > 0 ){\\n                sb.Append(\\' \\',1);\\n                extra--;\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456052,
                "title": "python-3-easy-implementation",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        bucket = []\\n        \\n        ans = []\\n        \\n        count = 0\\n        \\n        for word in words:\\n\\t\\t\\t#Keep track of total length so far including 1 space per word\\n            if count + len(bucket) + len(word) > maxWidth:\\n\\t\\t\\t\\t#Calculate total spaces needed\\n                spaces = maxWidth - count\\n                i = 0\\n\\t\\t\\t\\t#Distribute spaces evenly in all words except the last\\n                while spaces > 0:\\n                    bucket[i] += \\' \\'\\n                    if len(bucket) > 1:\\n                        i =  ( i + 1 ) % ( len( bucket ) - 1 )\\n                    spaces -= 1\\n                ans .append(\\'\\'.join(bucket))\\n                bucket, count = [], 0\\n            bucket.append(word)\\n            count += len(word)\\n        \\n        #Last line should be left justifies, so append normally\\n        ans.append(\\' \\'.join(bucket))\\n\\t\\t#Add additional spaces in the end\\n\\t\\tspaces = maxWidth - count - (len(bucket)-1)\\n        ans[-1] += \\' \\'*spaces\\n        \\n\\t\\t#Voila you get the ans in O(n) time\\n        return (ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        bucket = []\\n        \\n        ans = []\\n        \\n        count = 0\\n        \\n        for word in words:\\n\\t\\t\\t#Keep track of total length so far including 1 space per word\\n            if count + len(bucket) + len(word) > maxWidth:\\n\\t\\t\\t\\t#Calculate total spaces needed\\n                spaces = maxWidth - count\\n                i = 0\\n\\t\\t\\t\\t#Distribute spaces evenly in all words except the last\\n                while spaces > 0:\\n                    bucket[i] += \\' \\'\\n                    if len(bucket) > 1:\\n                        i =  ( i + 1 ) % ( len( bucket ) - 1 )\\n                    spaces -= 1\\n                ans .append(\\'\\'.join(bucket))\\n                bucket, count = [], 0\\n            bucket.append(word)\\n            count += len(word)\\n        \\n        #Last line should be left justifies, so append normally\\n        ans.append(\\' \\'.join(bucket))\\n\\t\\t#Add additional spaces in the end\\n\\t\\tspaces = maxWidth - count - (len(bucket)-1)\\n        ans[-1] += \\' \\'*spaces\\n        \\n\\t\\t#Voila you get the ans in O(n) time\\n        return (ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184405,
                "title": "java-20-lines-100",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> output= new ArrayList<>();\\n        int n= words.length;\\n        for(int i= 0, k= 1; i<n; i+= k, k= 1){\\n            // calculate k == how many words we can fit in this line (always at least one) with minimum gap of 1 space\\n\\t\\t\\t// and len == what is the total length of these words (then reduced by number of gaps k-1 before passing into printJustified)\\n\\t\\t\\tint len= words[i].length();\\n            for(int j= i+1, nextLen; j<n; j++, k++, len= nextLen)\\n                if((nextLen= len+1 + words[j].length()) > maxWidth) break;\\n\\t\\t\\t// justify left if there is only one word in the line or if it is the last line\\n            output.add(printJustified(words, maxWidth, i, k, len-k+1, k==1 || i+k == n));\\n        }\\n        return output;\\n    }\\n\\n    // i: first word, k: word count, len: line length (no spaces), left: left-justified otherwise full\\n    private String printJustified(String[] words, int maxWidth, int i, int k, int len, boolean left){\\n        int gapLen= left?1:(maxWidth-len)/(k-1), longGaps= left?0:(maxWidth-len)%(k-1);\\n        String gap= \" \".repeat(gapLen), longGap= \" \".repeat(gapLen+1);\\n        StringBuilder line= new StringBuilder(words[i]);\\n        for(int j=1; j<k; j++)\\n            line.append(j<=longGaps?longGap:gap).append(words[i+j]);\\n        if(left) line.append(\" \".repeat(maxWidth-line.length()));\\n        return line.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> output= new ArrayList<>();\\n        int n= words.length;\\n        for(int i= 0, k= 1; i<n; i+= k, k= 1){\\n            // calculate k == how many words we can fit in this line (always at least one) with minimum gap of 1 space\\n\\t\\t\\t// and len == what is the total length of these words (then reduced by number of gaps k-1 before passing into printJustified)\\n\\t\\t\\tint len= words[i].length();\\n            for(int j= i+1, nextLen; j<n; j++, k++, len= nextLen)\\n                if((nextLen= len+1 + words[j].length()) > maxWidth) break;\\n\\t\\t\\t// justify left if there is only one word in the line or if it is the last line\\n            output.add(printJustified(words, maxWidth, i, k, len-k+1, k==1 || i+k == n));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 997123,
                "title": "python-3-99-faster",
                "content": "```\\ndef fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        cur,st,i,ans=len(words[0]),0,1,[]\\n        while i<len(words):\\n            while i<len(words) and  cur+len(words[i])+1<=maxWidth:\\n                cur+=len(words[i])+1\\n                i+=1\\n            if i==len(words):\\n                tmp=\"\"\\n                for x in range(st,i):\\n                    tmp+=words[x]+\" \"\\n                if len(tmp)>maxWidth:\\n                    ans.append(tmp[:maxWidth])\\n                else:\\n                    ans.append(tmp+\" \"*(maxWidth-len(tmp)))\\n                return ans\\n            else:\\n                if i-st==1:\\n                    ans.append(words[st]+\" \"*(maxWidth-len(words[st])))\\n                else:\\n                    gap=i-st-1\\n                    sp=maxWidth-sum(map(len,words[st:i]))\\n                    nor=sp//gap\\n                    mor=sp%gap\\n                    tmp=\"\"\\n                    for x in range(mor):\\n                        tmp+=words[st+x]+\" \"*(nor+1)\\n                    for x in range(mor,gap):\\n                        tmp+=words[st+x]+\" \"*nor\\n                    tmp+=words[st+gap]\\n                    ans.append(tmp)\\n            st=i\\n            cur=len(words[st])\\n            i+=1\\n        if i==len(words):\\n            ans.append(words[i-1]+\" \"*(maxWidth-len(words[st])))\\n            return ans\\n\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\ndef fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        cur,st,i,ans=len(words[0]),0,1,[]\\n        while i<len(words):\\n            while i<len(words) and  cur+len(words[i])+1<=maxWidth:\\n                cur+=len(words[i])+1\\n                i+=1\\n            if i==len(words):\\n                tmp=\"\"\\n                for x in range(st,i):\\n                    tmp+=words[x]+\" \"\\n                if len(tmp)>maxWidth:\\n                    ans.append(tmp[:maxWidth])\\n                else:\\n                    ans.append(tmp+\" \"*(maxWidth-len(tmp)))\\n                return ans\\n            else:\\n                if i-st==1:\\n                    ans.append(words[st]+\" \"*(maxWidth-len(words[st])))\\n                else:\\n                    gap=i-st-1\\n                    sp=maxWidth-sum(map(len,words[st:i]))\\n                    nor=sp//gap\\n                    mor=sp%gap\\n                    tmp=\"\"\\n                    for x in range(mor):\\n                        tmp+=words[st+x]+\" \"*(nor+1)\\n                    for x in range(mor,gap):\\n                        tmp+=words[st+x]+\" \"*nor\\n                    tmp+=words[st+gap]\\n                    ans.append(tmp)\\n            st=i\\n            cur=len(words[st])\\n            i+=1\\n        if i==len(words):\\n            ans.append(words[i-1]+\" \"*(maxWidth-len(words[st])))\\n            return ans\\n\\t\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 748432,
                "title": "java-solution",
                "content": "I followed video here to understand, easy to do it afterwards.\\nhttps://www.youtube.com/watch?v=TePHubQTgQ8\\n```\\nclass Solution {\\n        public List<String> fullJustify(String[] words, int maxWidth) {\\n            if(words.length==0 || maxWidth==0) return new ArrayList<>();\\n            int index = 0;\\n            int last = 0;\\n            int n = words.length;\\n\\n            List<String> res = new ArrayList<>();\\n\\n            while(index < n){\\n                int totalChars = words[index].length();\\n                int gaps = 0;\\n                last = index+1;\\n                while(last < n && (totalChars +1+ words[last].length()) <= maxWidth){\\n                    totalChars += (1 + words[last].length());\\n                    last ++;\\n                }\\n                StringBuilder sb = new StringBuilder(\"\");\\n                gaps = last - index - 1;\\n                if(last == n || gaps ==0){\\n                    for(int i=index;i<last;i++){\\n                        sb.append(words[i]);\\n                        sb.append(\" \");\\n                    }\\n                    sb.delete(sb.length()-1,sb.length());\\n                    for(int i=0;i<maxWidth - totalChars;i++){\\n                        sb.append(\" \");\\n                    }\\n                }else{\\n                    int spaces = (maxWidth - totalChars)/( gaps);\\n                    int extra = (maxWidth-totalChars) % (gaps);\\n                    for(int i=index;i<last-1;i++){\\n                        sb.append(words[i]);\\n                        sb.append(\" \");\\n\\n                        for(int j=0;j<spaces + (i-index<extra?1:0);j++){\\n                            sb.append(\" \");\\n                        }\\n                    }\\n                    sb.append(words[last-1]);\\n                }\\n                res.add(sb.toString());\\n                index = last;\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public List<String> fullJustify(String[] words, int maxWidth) {\\n            if(words.length==0 || maxWidth==0) return new ArrayList<>();\\n            int index = 0;\\n            int last = 0;\\n            int n = words.length;\\n\\n            List<String> res = new ArrayList<>();\\n\\n            while(index < n){\\n                int totalChars = words[index].length();\\n                int gaps = 0;\\n                last = index+1;\\n                while(last < n && (totalChars +1+ words[last].length()) <= maxWidth){\\n                    totalChars += (1 + words[last].length());\\n                    last ++;\\n                }\\n                StringBuilder sb = new StringBuilder(\"\");\\n                gaps = last - index - 1;\\n                if(last == n || gaps ==0){\\n                    for(int i=index;i<last;i++){\\n                        sb.append(words[i]);\\n                        sb.append(\" \");\\n                    }\\n                    sb.delete(sb.length()-1,sb.length());\\n                    for(int i=0;i<maxWidth - totalChars;i++){\\n                        sb.append(\" \");\\n                    }\\n                }else{\\n                    int spaces = (maxWidth - totalChars)/( gaps);\\n                    int extra = (maxWidth-totalChars) % (gaps);\\n                    for(int i=index;i<last-1;i++){\\n                        sb.append(words[i]);\\n                        sb.append(\" \");\\n\\n                        for(int j=0;j<spaces + (i-index<extra?1:0);j++){\\n                            sb.append(\" \");\\n                        }\\n                    }\\n                    sb.append(words[last-1]);\\n                }\\n                res.add(sb.toString());\\n                index = last;\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481553,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<string>results;\\n        vector<string>vec;\\n        string str;\\n        int length = 0;\\n        \\n        for(int i=0; i<words.size(); i++)\\n        {\\n            int total_length = words[i].size() + length + vec.size();\\n            if(total_length <= maxWidth) //Can the word fit in the line\\n            {\\n                vec.push_back(words[i]);\\n                length += words[i].length();\\n            }\\n            else//vec is full. No more words fit in a line\\n            {\\n                if(vec.size() == 1)\\n                {\\n                    str = vec[0];\\n                    str.append(maxWidth - str.size(), \\' \\');\\n                    results.push_back(str);\\n                }\\n                else if(vec.size() > 1)\\n                {\\n                    int divide = (maxWidth - length) / (vec.size()-1);\\n                    int mod = (maxWidth - length) % (vec.size() - 1);\\n                    \\n                    str = vec[0];\\n                    \\n                    for(int j = 1; j<vec.size(); j++)\\n                    {\\n                        if(j <= mod)\\n                        {\\n                            str.append(divide+1, \\' \\');\\n                        }\\n                        else\\n                        {\\n                            str.append(divide, \\' \\');\\n                        }\\n                        str += vec[j];\\n                    }\\n                    results.push_back(str);\\n                }\\n                vec.clear();\\n                vec.push_back(words[i]);\\n                length = words[i].size();\\n            }\\n        }\\n        \\n        str = vec[0];\\n        for (int j = 1; j < vec.size(); ++j) str += \\' \\' + vec[j];\\n\\t    str.append(maxWidth - str.size(), \\' \\');\\n\\t    results.push_back(str);\\n\\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<string>results;\\n        vector<string>vec;\\n        string str;\\n        int length = 0;\\n        \\n        for(int i=0; i<words.size(); i++)\\n        {\\n            int total_length = words[i].size() + length + vec.size();\\n            if(total_length <= maxWidth) //Can the word fit in the line\\n            {\\n                vec.push_back(words[i]);\\n                length += words[i].length();\\n            }\\n            else//vec is full. No more words fit in a line\\n            {\\n                if(vec.size() == 1)\\n                {\\n                    str = vec[0];\\n                    str.append(maxWidth - str.size(), \\' \\');\\n                    results.push_back(str);\\n                }\\n                else if(vec.size() > 1)\\n                {\\n                    int divide = (maxWidth - length) / (vec.size()-1);\\n                    int mod = (maxWidth - length) % (vec.size() - 1);\\n                    \\n                    str = vec[0];\\n                    \\n                    for(int j = 1; j<vec.size(); j++)\\n                    {\\n                        if(j <= mod)\\n                        {\\n                            str.append(divide+1, \\' \\');\\n                        }\\n                        else\\n                        {\\n                            str.append(divide, \\' \\');\\n                        }\\n                        str += vec[j];\\n                    }\\n                    results.push_back(str);\\n                }\\n                vec.clear();\\n                vec.push_back(words[i]);\\n                length = words[i].size();\\n            }\\n        }\\n        \\n        str = vec[0];\\n        for (int j = 1; j < vec.size(); ++j) str += \\' \\' + vec[j];\\n\\t    str.append(maxWidth - str.size(), \\' \\');\\n\\t    results.push_back(str);\\n\\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313566,
                "title": "c-85-beaten-brute-force-beatings-iterative-solution-o-n-some-clever-tricks",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<string> aResult;\\n        \\n        int aLineStart = 0;\\n        int aSeek = 0;\\n        \\n        char aBuff[maxWidth + 1];\\n        aBuff[maxWidth] = 0;\\n        \\n        for (aLineStart=0;aLineStart<words.size();aLineStart=aSeek) {\\n            \\n            int aWidth = 0;\\n            for (aSeek=aLineStart;aSeek<words.size() && aWidth + words[aSeek].size() + (aSeek - aLineStart) <= maxWidth;aSeek++) {\\n                aWidth += words[aSeek].size();\\n            }\\n            \\n            int aSpacing = 1;\\n            int aExtra = 0;\\n            if ((aSeek - aLineStart) > 1 && aSeek < words.size()) {\\n                aSpacing = (maxWidth - aWidth) / (aSeek - aLineStart - 1);\\n                aExtra   = (maxWidth - aWidth) % (aSeek - aLineStart - 1);\\n            }\\n            \\n            int aPaste = 0;\\n            for (int i=aLineStart;i<aSeek;i++) {\\n                for (int k=0;k<words[i].size();k++) {\\n                    aBuff[aPaste++] = words[i][k];\\n                }\\n                if (i < (aSeek - 1)) {\\n                    for (int k=0;k<aSpacing;k++) { aBuff[aPaste++] = \\' \\'; }\\n                    if (aExtra-- > 0) { aBuff[aPaste++] = \\' \\'; }\\n                }\\n            }\\n            \\n            while (aPaste < maxWidth) { aBuff[aPaste++] = \\' \\'; }\\n            \\n            aResult.push_back(string(aBuff));\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nKaboom, baby. I thought I could squeak out extra speed with the static buffer. Doesn\\'t seem to beat the top 20%.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<string> aResult;\\n        \\n        int aLineStart = 0;\\n        int aSeek = 0;\\n        \\n        char aBuff[maxWidth + 1];\\n        aBuff[maxWidth] = 0;\\n        \\n        for (aLineStart=0;aLineStart<words.size();aLineStart=aSeek) {\\n            \\n            int aWidth = 0;\\n            for (aSeek=aLineStart;aSeek<words.size() && aWidth + words[aSeek].size() + (aSeek - aLineStart) <= maxWidth;aSeek++) {\\n                aWidth += words[aSeek].size();\\n            }\\n            \\n            int aSpacing = 1;\\n            int aExtra = 0;\\n            if ((aSeek - aLineStart) > 1 && aSeek < words.size()) {\\n                aSpacing = (maxWidth - aWidth) / (aSeek - aLineStart - 1);\\n                aExtra   = (maxWidth - aWidth) % (aSeek - aLineStart - 1);\\n            }\\n            \\n            int aPaste = 0;\\n            for (int i=aLineStart;i<aSeek;i++) {\\n                for (int k=0;k<words[i].size();k++) {\\n                    aBuff[aPaste++] = words[i][k];\\n                }\\n                if (i < (aSeek - 1)) {\\n                    for (int k=0;k<aSpacing;k++) { aBuff[aPaste++] = \\' \\'; }\\n                    if (aExtra-- > 0) { aBuff[aPaste++] = \\' \\'; }\\n                }\\n            }\\n            \\n            while (aPaste < maxWidth) { aBuff[aPaste++] = \\' \\'; }\\n            \\n            aResult.push_back(string(aBuff));\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242607,
                "title": "python-solution",
                "content": "Time complexity: `O(n)`, space complexity: `O(n)`, where `n` is the total number of characters in the text.\\n\\n```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        line = []\\n        word_count = 0\\n        char_count = 0\\n        res = []\\n        for word in words:\\n            length = char_count+1+len(word)\\n            if length > maxWidth:\\n                space_left = maxWidth - char_count\\n                if word_count == 1:\\n                    string = line[0]+\" \"*(maxWidth-len(line[0]))\\n                    res.append(string)\\n                    line = [word]\\n                    char_count = len(word)\\n                else:\\n                    q, r = divmod(space_left, word_count-1)\\n                    front = (\" \"*(q+2)).join(line[:r+1])\\n                    end = (\" \"*(q+1)).join(line[r+1:])\\n                    string = front+\" \"*(q+1)+end\\n                    if string:\\n                        res.append(string)\\n                    line = [word]\\n                    word_count = 1\\n                    char_count = len(word)\\n            else:\\n                if line:\\n                    char_count += len(word)+1\\n                else:\\n                    char_count += len(word)\\n                line.append(word)\\n                word_count += 1\\n        if line:\\n            line = \" \".join(line)\\n            line += \" \"*(maxWidth-len(line))\\n            res.append(line)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        line = []\\n        word_count = 0\\n        char_count = 0\\n        res = []\\n        for word in words:\\n            length = char_count+1+len(word)\\n            if length > maxWidth:\\n                space_left = maxWidth - char_count\\n                if word_count == 1:\\n                    string = line[0]+\" \"*(maxWidth-len(line[0]))\\n                    res.append(string)\\n                    line = [word]\\n                    char_count = len(word)\\n                else:\\n                    q, r = divmod(space_left, word_count-1)\\n                    front = (\" \"*(q+2)).join(line[:r+1])\\n                    end = (\" \"*(q+1)).join(line[r+1:])\\n                    string = front+\" \"*(q+1)+end\\n                    if string:\\n                        res.append(string)\\n                    line = [word]\\n                    word_count = 1\\n                    char_count = len(word)\\n            else:\\n                if line:\\n                    char_count += len(word)+1\\n                else:\\n                    char_count += len(word)\\n                line.append(word)\\n                word_count += 1\\n        if line:\\n            line = \" \".join(line)\\n            line += \" \"*(maxWidth-len(line))\\n            res.append(line)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213677,
                "title": "verbose-python-solution",
                "content": "```python\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        i, l = 0, len(words)\\n        output = []\\n        \\n        while i < l:\\n            j, line_words, line, rem_width = i, [], \\'\\', maxWidth\\n\\n            # if only the word can fit in the line, no remaining cols\\n            if len(words[i]) == maxWidth:\\n                i+= 1\\n                output.append(words[i-1])\\n                continue\\n\\n            # calculate remaining width after fitting words on line\\n            while i < len(words) and len(words[i]) +1 <= rem_width:\\n                # ignore first word but add spaces to rest\\n                if len(line_words) > 0: rem_width -=1\\n                rem_width -= len(words[i])\\n                line_words.append(words[i])\\n                i+=1\\n\\n            # left justify if no extra spaces or words\\n            if i == len(words) or rem_width == 0 or len(line_words) == 1:\\n                line += words[j]\\n                j+=1\\n                while j < i:\\n                    line += \\' \\'\\n                    line += words[j]\\n                    j+= 1\\n                while rem_width > 0:\\n                    line += \\' \\'\\n                    rem_width -= 1\\n                output.append(line)\\n                continue\\n\\n            # if there are leftover spaces after fitting words    \\n            if rem_width > 0:\\n                num_spaces = rem_width //(len(line_words) -1) + 1\\n                extra_spaces = rem_width % (len(line_words) -1)\\n                \\n                line += words[j]\\n                j+=1\\n                while j < i:\\n                    k = num_spaces\\n                    while k > 0:\\n                        line += \\' \\'\\n                        k-=1\\n                    if extra_spaces > 0:\\n                        extra_spaces -= 1\\n                        line += \\' \\'\\n                    line += words[j]\\n                    j+=1\\n                output.append(line)\\n                continue\\n            \\n            \\n        return output\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        i, l = 0, len(words)\\n        output = []\\n        \\n        while i < l:\\n            j, line_words, line, rem_width = i, [], \\'\\', maxWidth\\n\\n            # if only the word can fit in the line, no remaining cols\\n            if len(words[i]) == maxWidth:\\n                i+= 1\\n                output.append(words[i-1])\\n                continue\\n\\n            # calculate remaining width after fitting words on line\\n            while i < len(words) and len(words[i]) +1 <= rem_width:\\n                # ignore first word but add spaces to rest\\n                if len(line_words) > 0: rem_width -=1\\n                rem_width -= len(words[i])\\n                line_words.append(words[i])\\n                i+=1\\n\\n            # left justify if no extra spaces or words\\n            if i == len(words) or rem_width == 0 or len(line_words) == 1:\\n                line += words[j]\\n                j+=1\\n                while j < i:\\n                    line += \\' \\'\\n                    line += words[j]\\n                    j+= 1\\n                while rem_width > 0:\\n                    line += \\' \\'\\n                    rem_width -= 1\\n                output.append(line)\\n                continue\\n\\n            # if there are leftover spaces after fitting words    \\n            if rem_width > 0:\\n                num_spaces = rem_width //(len(line_words) -1) + 1\\n                extra_spaces = rem_width % (len(line_words) -1)\\n                \\n                line += words[j]\\n                j+=1\\n                while j < i:\\n                    k = num_spaces\\n                    while k > 0:\\n                        line += \\' \\'\\n                        k-=1\\n                    if extra_spaces > 0:\\n                        extra_spaces -= 1\\n                        line += \\' \\'\\n                    line += words[j]\\n                    j+=1\\n                output.append(line)\\n                continue\\n            \\n            \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197996,
                "title": "javascript-90-with-comments",
                "content": "I was asked this in an Uber interview...Perfect justify logic was complicated...I adapted the algorithm from \\n\\nhttps://leetcode.com/problems/text-justification/discuss/24891/Concise-python-solution-10-lines.\\n\\n...as the author says...the justification explanation is a complicated way to just say round robin distribution...\\n\\n```\\n// You should pack your words in a greedy approach; \\n// that is, pack as many words as you can in each line. \\n// Pad extra spaces \\' \\' when necessary so that each line \\n// has exactly maxWidth characters.\\nvar createLines = function(words, maxWidth) {\\n    let lines = [];\\n    \\n    let p = 0;\\n    \\n    while(p < words.length) {\\n        let line = [];\\n        \\n        while(p < words.length) {\\n            let peek = words[p];\\n            let peeklen = [...line, peek].join(\\' \\').length;\\n\\n            if(peeklen <= maxWidth) {\\n                line.push(peek);\\n                \\n                p++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        lines.push(line);\\n    }\\n    \\n    return lines;\\n};\\n\\nvar justifyLines = function(lines, maxWidth) {\\n    const justified = [];\\n    \\n    const push = (line, space) => {\\n        let text = line.join(space);\\n       \\n        let extra = \\' \\'.repeat(maxWidth-text.length);\\n        \\n        justified.push(text + extra);\\n    };\\n    \\n    for(let l = 0; l < lines.length -1; l++) {\\n        const line = lines[l];\\n        \\n        let spaces = (maxWidth - line.join(\\'\\').length);\\n        \\n\\t\\t// Extra spaces between words should be distributed as evenly as possible. \\n\\t\\t// If the number of spaces on a line do not divide evenly between words, \\n\\t\\t// the empty slots on the left will be assigned more spaces than the slots on the right.\\n        for(let i = 0; i < spaces; i++) {\\n            const index = i%((line.length-1) || 1);\\n\\n            line[index] += \\' \\';\\n        }\\n        \\n        push(line, \\'\\');\\n    };\\n    \\n\\t// For the last line of text, it should be left justified \\n\\t// and no extra space is inserted between words.\\n    push(lines[lines.length-1],  \\' \\');\\n    \\n    return justified;\\n}\\n\\nvar fullJustify = function(words, maxWidth) {\\n    let lines = createLines(words, maxWidth);\\n    \\n    lines = justifyLines(lines, maxWidth);\\n    \\n    return lines;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// You should pack your words in a greedy approach; \\n// that is, pack as many words as you can in each line. \\n// Pad extra spaces \\' \\' when necessary so that each line \\n// has exactly maxWidth characters.\\nvar createLines = function(words, maxWidth) {\\n    let lines = [];\\n    \\n    let p = 0;\\n    \\n    while(p < words.length) {\\n        let line = [];\\n        \\n        while(p < words.length) {\\n            let peek = words[p];\\n            let peeklen = [...line, peek].join(\\' \\').length;\\n\\n            if(peeklen <= maxWidth) {\\n                line.push(peek);\\n                \\n                p++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        lines.push(line);\\n    }\\n    \\n    return lines;\\n};\\n\\nvar justifyLines = function(lines, maxWidth) {\\n    const justified = [];\\n    \\n    const push = (line, space) => {\\n        let text = line.join(space);\\n       \\n        let extra = \\' \\'.repeat(maxWidth-text.length);\\n        \\n        justified.push(text + extra);\\n    };\\n    \\n    for(let l = 0; l < lines.length -1; l++) {\\n        const line = lines[l];\\n        \\n        let spaces = (maxWidth - line.join(\\'\\').length);\\n        \\n\\t\\t// Extra spaces between words should be distributed as evenly as possible. \\n\\t\\t// If the number of spaces on a line do not divide evenly between words, \\n\\t\\t// the empty slots on the left will be assigned more spaces than the slots on the right.\\n        for(let i = 0; i < spaces; i++) {\\n            const index = i%((line.length-1) || 1);\\n\\n            line[index] += \\' \\';\\n        }\\n        \\n        push(line, \\'\\');\\n    };\\n    \\n\\t// For the last line of text, it should be left justified \\n\\t// and no extra space is inserted between words.\\n    push(lines[lines.length-1],  \\' \\');\\n    \\n    return justified;\\n}\\n\\nvar fullJustify = function(words, maxWidth) {\\n    let lines = createLines(words, maxWidth);\\n    \\n    lines = justifyLines(lines, maxWidth);\\n    \\n    return lines;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24952,
                "title": "recursive-python-solution-with-detailed-comments",
                "content": "    import math\\n\\n    def fullJustify(self, words, maxWidth):\\n        \\n        # Handle corner cases\\n        \\n        n = len(words)\\n        if n == 0:\\n            return words\\n        if words[0] == \"\":\\n            return [\" \" * maxWidth]\\n            \\n        # Greedily put words in words_line until full\\n            \\n        words_line = [words[0]]\\n        i, len_words, len_spaces = 1, len(words[0]), 0\\n        while i < len(words) and len_spaces + len_words <= maxWidth:\\n            words_line.append(words[i])\\n            len_words += len(words[i])\\n            len_spaces += 1\\n            i += 1\\n        \\n        # Remove last word if went beyond maxWidth\\n        \\n        if len_spaces + len_words > maxWidth:\\n            a = words_line.pop()\\n            len_words -= len(a)\\n            len_spaces -= 1\\n        \\n        # Need to fill slots with spaces\\n        \\n        slots = len(words_line) - 1 if len(words_line) > 1 else 1\\n        spaces = maxWidth - len_words\\n        padding = []\\n        \\n        # Fill padding between words depending on the case\\n        \\n        spaces_, slots_ = spaces, slots\\n        while spaces_ % slots_ != 0:\\n            sp = int(math.ceil(spaces_/float(slots_)))\\n            padding += [sp]\\n            spaces_ -= sp\\n            slots_ -= 1\\n        padding += [int(spaces_ // slots_)] * slots_\\n\\n        # Last line, padding is different\\n\\n        if len(words[len(words_line):]) == 0:\\n            padding = [1] * (len(words_line) - 1) + [spaces - (len(words_line) - 1)]\\n            \\n        # Construct line\\n        \\n        i, line = 0, \"\"\\n        for word in words_line:\\n            line += word\\n            if i < len(padding):\\n                line += \" \" * padding[i]\\n            i += 1\\n            \\n        # Recursive call on rest of phrase\\n\\n        further_lines = self.fullJustify(words[len(words_line):], maxWidth)\\n        return [line] + further_lines",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "    import math\\n\\n    def fullJustify(self, words, maxWidth):\\n        \\n        # Handle corner cases\\n        \\n        n = len(words)\\n        if n == 0:\\n            return words\\n        if words[0] == \"\":\\n            return [\" \" * maxWidth]\\n            \\n        # Greedily put words in words_line until full\\n            \\n        words_line = [words[0]]\\n        i, len_words, len_spaces = 1, len(words[0]), 0\\n        while i < len(words) and len_spaces + len_words <= maxWidth:\\n            words_line.append(words[i])\\n            len_words += len(words[i])\\n            len_spaces += 1\\n            i += 1\\n        \\n        # Remove last word if went beyond maxWidth\\n        \\n        if len_spaces + len_words > maxWidth:\\n            a = words_line.pop()\\n            len_words -= len(a)\\n            len_spaces -= 1\\n        \\n        # Need to fill slots with spaces\\n        \\n        slots = len(words_line) - 1 if len(words_line) > 1 else 1\\n        spaces = maxWidth - len_words\\n        padding = []\\n        \\n        # Fill padding between words depending on the case\\n        \\n        spaces_, slots_ = spaces, slots\\n        while spaces_ % slots_ != 0:\\n            sp = int(math.ceil(spaces_/float(slots_)))\\n            padding += [sp]\\n            spaces_ -= sp\\n            slots_ -= 1\\n        padding += [int(spaces_ // slots_)] * slots_\\n\\n        # Last line, padding is different\\n\\n        if len(words[len(words_line):]) == 0:\\n            padding = [1] * (len(words_line) - 1) + [spaces - (len(words_line) - 1)]\\n            \\n        # Construct line\\n        \\n        i, line = 0, \"\"\\n        for word in words_line:\\n            line += word\\n            if i < len(padding):\\n                line += \" \" * padding[i]\\n            i += 1\\n            \\n        # Recursive call on rest of phrase\\n\\n        further_lines = self.fullJustify(words[len(words_line):], maxWidth)\\n        return [line] + further_lines",
                "codeTag": "Python3"
            },
            {
                "id": 24975,
                "title": "c-solution-with-comments",
                "content": "    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n          int idx = 0;\\n          vector<string> ret;\\n          while (idx < words.size()) {\\n            // get the current line\\n            int end = idx;\\n            int total = 0;\\n            vector<string> line;\\n            while (end < words.size() \\\\\\n        \\t   && total+line.size()+words[end].length() <= maxWidth) {\\n              line.push_back(words[end]);\\n              total += words[end].length();\\n              end ++;\\n            }\\n            // the last line or just a single word -> left alignment\\n            // just pad the end with spaces\\n            string l = words[idx];\\n            if (end == words.size() || line.size()==1) {      \\n              for (int i = idx+1; i < end; i ++)\\n                l += \" \" + words[i];\\n              l += string(maxWidth-(total+line.size()-1), ' ');\\n            }\\n            // distribute the spaces evenly\\n            else {\\n              int space_len = maxWidth - total;\\n              int left = space_len % (line.size()-1);\\n              int base = space_len / (line.size()-1);\\n              int cnt = 0;\\n              for (int i = idx+1; i < end; i ++) {\\n                l += string(base, ' ');\\n                // add extra\\n                if (cnt < left) {\\n                  l += \" \";\\n                  cnt ++;\\n                }\\n                l += words[i];\\n              }\\n            }\\n            ret.push_back(l);\\n            idx = end;\\n          }\\n          return ret;\\n    }",
                "solutionTags": [],
                "code": "    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n          int idx = 0;\\n          vector<string> ret;\\n          while (idx < words.size()) {\\n            // get the current line\\n            int end = idx;\\n            int total = 0;\\n            vector<string> line;\\n            while (end < words.size() \\\\\\n        \\t   && total+line.size()+words[end].length() <= maxWidth) {\\n              line.push_back(words[end]);\\n              total += words[end].length();\\n              end ++;\\n            }\\n            // the last line or just a single word -> left alignment\\n            // just pad the end with spaces\\n            string l = words[idx];\\n            if (end == words.size() || line.size()==1) {      \\n              for (int i = idx+1; i < end; i ++)\\n                l += \" \" + words[i];\\n              l += string(maxWidth-(total+line.size()-1), ' ');\\n            }\\n            // distribute the spaces evenly\\n            else {\\n              int space_len = maxWidth - total;\\n              int left = space_len % (line.size()-1);\\n              int base = space_len / (line.size()-1);\\n              int cnt = 0;\\n              for (int i = idx+1; i < end; i ++) {\\n                l += string(base, ' ');\\n                // add extra\\n                if (cnt < left) {\\n                  l += \" \";\\n                  cnt ++;\\n                }\\n                l += words[i];\\n              }\\n            }\\n            ret.push_back(l);\\n            idx = end;\\n          }\\n          return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4050577,
                "title": "text-justification-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        for(int i = 0, j; i < words.size(); i = j) {\\n            int width = 0;\\n            for(j = i; j < words.size() && width + words[j].size() + j - i <= maxWidth; j++) {\\n                width += words[j].size();\\n            }\\n            int space = 1, extra = 0;\\n            if(j - i != 1 && j != words.size()) {\\n                space = (maxWidth - width) / (j - i - 1);\\n                extra = (maxWidth - width) % (j - i - 1);\\n            }\\n            string line = words[i];\\n            for(int k = i + 1; k < j; k++) {\\n                line += string(space, \\' \\');\\n                if(extra > 0) {\\n                    extra--;\\n                    line += \" \";\\n                }\\n                line += words[k];\\n            }\\n            \\n            line += string(maxWidth - line.size(), \\' \\');\\n            result.push_back(line);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        for(int i = 0, j; i < words.size(); i = j) {\\n            int width = 0;\\n            for(j = i; j < words.size() && width + words[j].size() + j - i <= maxWidth; j++) {\\n                width += words[j].size();\\n            }\\n            int space = 1, extra = 0;\\n            if(j - i != 1 && j != words.size()) {\\n                space = (maxWidth - width) / (j - i - 1);\\n                extra = (maxWidth - width) % (j - i - 1);\\n            }\\n            string line = words[i];\\n            for(int k = i + 1; k < j; k++) {\\n                line += string(space, \\' \\');\\n                if(extra > 0) {\\n                    extra--;\\n                    line += \" \";\\n                }\\n                line += words[k];\\n            }\\n            \\n            line += string(maxWidth - line.size(), \\' \\');\\n            result.push_back(line);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955510,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\niterate through the input words and form lines that fit within the maximum width.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe main logic is within the fullJustify function. It iterates through the input words and forms lines that fit within the maximum width. It then uses the addSpaces function to create the justified lines.\\n\\nThe condition for the last line is checked using the isLastLine boolean flag.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(M), M-No of input characteres in a stream\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string addSpaces(vector<string>& words, int maxWidth, int i, int j, bool isLast) {\\n        string result = words[i];\\n        if (i == j || isLast) {  // For a single-word line or last line\\n            for (int k = i + 1; k <= j; ++k) {\\n                result += \" \" + words[k];\\n            }\\n            result += string(maxWidth - result.length(), \\' \\');\\n            return result;\\n        }\\n\\n        int totalSpaces = maxWidth - accumulate(words.begin() + i, words.begin() + j + 1, 0, [](int len, const string& word) { return len + word.length(); });\\n        int slots = j - i;  // Number of slots between words\\n        int spacesBetweenWords = totalSpaces / slots;\\n        int extraSpaces = totalSpaces % slots;\\n\\n        for (int k = i + 1; k <= j; ++k) {\\n            int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n            result += string(spaces, \\' \\') + words[k];\\n        }\\n\\n        return result;\\n    }\\n\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int i = 0, n = words.size();\\n\\n        while (i < n) {\\n            int j = i, lineLength = 0;\\n            while (j < n && lineLength + words[j].length() + (j - i) <= maxWidth) {\\n                lineLength += words[j].length();\\n                j++;\\n            }\\n\\n            bool isLastLine = (j == n);\\n            result.push_back(addSpaces(words, maxWidth, i, j - 1, isLastLine));\\n\\n            i = j;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addSpaces(vector<string>& words, int maxWidth, int i, int j, bool isLast) {\\n        string result = words[i];\\n        if (i == j || isLast) {  // For a single-word line or last line\\n            for (int k = i + 1; k <= j; ++k) {\\n                result += \" \" + words[k];\\n            }\\n            result += string(maxWidth - result.length(), \\' \\');\\n            return result;\\n        }\\n\\n        int totalSpaces = maxWidth - accumulate(words.begin() + i, words.begin() + j + 1, 0, [](int len, const string& word) { return len + word.length(); });\\n        int slots = j - i;  // Number of slots between words\\n        int spacesBetweenWords = totalSpaces / slots;\\n        int extraSpaces = totalSpaces % slots;\\n\\n        for (int k = i + 1; k <= j; ++k) {\\n            int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n            result += string(spaces, \\' \\') + words[k];\\n        }\\n\\n        return result;\\n    }\\n\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int i = 0, n = words.size();\\n\\n        while (i < n) {\\n            int j = i, lineLength = 0;\\n            while (j < n && lineLength + words[j].length() + (j - i) <= maxWidth) {\\n                lineLength += words[j].length();\\n                j++;\\n            }\\n\\n            bool isLastLine = (j == n);\\n            result.push_back(addSpaces(words, maxWidth, i, j - 1, isLastLine));\\n\\n            i = j;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954019,
                "title": "easy-ad-hoc-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n    vector<string> fullJustify(vector<string> &words, int maxWidth)\\n    {\\n        vector<string> ans;\\n        int i = 0, j = 0;\\n        while (i < words.size())\\n        {\\n            int charCnt = words[i].length(), spaceCnt = 0;\\n            j = i + 1;\\n            while (j < words.size() && charCnt + spaceCnt + 1 + words[j].length() <= maxWidth)\\n            {\\n                charCnt += words[j].length();\\n                spaceCnt++;\\n                j++;\\n            }\\n            int rem = maxWidth - charCnt;\\n            int equalDistribute = (spaceCnt == 0) ? 0 : rem / spaceCnt;\\n            int extraDistribute = (spaceCnt == 0) ? 0 : rem % spaceCnt;\\n            if (j == words.size())\\n            {\\n                equalDistribute = 1;\\n                extraDistribute = 0;\\n            }\\n            string s;\\n            for (int k = i; k < j; ++k)\\n            {\\n                s += words[k];\\n                if (k == j - 1)\\n                    break;\\n                for (int p = 0; p < equalDistribute; ++p)\\n                {\\n                    s.push_back(\\' \\');\\n                }\\n                if (extraDistribute > 0)\\n                {\\n                    s.push_back(\\' \\');\\n                    extraDistribute--;\\n                }\\n            }\\n            while (s.length() < maxWidth)\\n            {\\n                s.push_back(\\' \\');\\n            }\\n            ans.push_back(s);\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    vector<string> fullJustify(vector<string> &words, int maxWidth)\\n    {\\n        vector<string> ans;\\n        int i = 0, j = 0;\\n        while (i < words.size())\\n        {\\n            int charCnt = words[i].length(), spaceCnt = 0;\\n            j = i + 1;\\n            while (j < words.size() && charCnt + spaceCnt + 1 + words[j].length() <= maxWidth)\\n            {\\n                charCnt += words[j].length();\\n                spaceCnt++;\\n                j++;\\n            }\\n            int rem = maxWidth - charCnt;\\n            int equalDistribute = (spaceCnt == 0) ? 0 : rem / spaceCnt;\\n            int extraDistribute = (spaceCnt == 0) ? 0 : rem % spaceCnt;\\n            if (j == words.size())\\n            {\\n                equalDistribute = 1;\\n                extraDistribute = 0;\\n            }\\n            string s;\\n            for (int k = i; k < j; ++k)\\n            {\\n                s += words[k];\\n                if (k == j - 1)\\n                    break;\\n                for (int p = 0; p < equalDistribute; ++p)\\n                {\\n                    s.push_back(\\' \\');\\n                }\\n                if (extraDistribute > 0)\\n                {\\n                    s.push_back(\\' \\');\\n                    extraDistribute--;\\n                }\\n            }\\n            while (s.length() < maxWidth)\\n            {\\n                s.push_back(\\' \\');\\n            }\\n            ans.push_back(s);\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954009,
                "title": "optimal-text-justification-a-deep-dive-into-greedy-line-formatting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this post, we will tackle the \"Text Justification\" problem, where we are given an array of words and a maximum width, and we need to format the text such that each line has exactly the specified width and is fully justified. We\\'ll discuss the intuition behind the solution, step-by-step approach to solve the problem, the provided code solution, as well as the time and space complexity analysis.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo tackle this problem, we\\'ll use a greedy approach. We will iterate through the `words` array and try to pack as many words as possible in each line while adhering to the `maxWidth` constraint. We\\'ll maintain a begin pointer to track the start of the current line, a `len` variable to track the length of words in the current line, and iterate through the words.\\n\\nWhenever adding a new word to the current line would exceed the `maxWidth`, we will finalize the current line by calling a helper function `connect()`. This function will construct the line by adding the words and the appropriate number of spaces between them. If it\\'s the last line, we\\'ll add only single spaces between words.\\n\\nFinally, we\\'ll handle the last line separately, ensuring it\\'s left-justified with no extra spaces added.\\n\\n# Complexity\\n- Time Complexity:\\nThe time complexity of this solution is O(N), where N is the number of words in the input array. We iterate through the words once to construct the lines, and the connect function runs in constant time since it\\'s processing a fixed number of words.\\n\\n- Space Complexity:\\nThe space complexity is also O(N), as we are using additional space to store the output lines.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        const int n = words.size();\\n        int begin = 0, len = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (len + words[i].size() + (i - begin) > maxWidth) {\\n                res.emplace_back(connect(words, maxWidth, begin, i, len, false));\\n                begin = i;\\n                len = 0;\\n            }\\n            len += words[i].size();\\n        }\\n        res.emplace_back(connect(words, maxWidth, begin, n, len, true));\\n        return res;\\n    }\\nprivate:\\n    string connect(const vector<string>& words, int maxWidth,\\n                   int begin, int end, int len,\\n                   bool is_last) {\\n        string s;\\n        int n = end - begin;\\n        for (int i = 0; i < n; ++i) {\\n            s += words[begin + i];\\n            addSpaces(i, n - 1, maxWidth - len, is_last, &s);\\n        }\\n        if (s.size() < maxWidth) {\\n            s.append(maxWidth - s.size(), \\' \\');\\n        }\\n        return s;\\n    }\\n    void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {\\n        if (i < spaceCnt) {\\n            int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);\\n            s->append(spaces, \\' \\');\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        const int n = words.size();\\n        int begin = 0, len = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (len + words[i].size() + (i - begin) > maxWidth) {\\n                res.emplace_back(connect(words, maxWidth, begin, i, len, false));\\n                begin = i;\\n                len = 0;\\n            }\\n            len += words[i].size();\\n        }\\n        res.emplace_back(connect(words, maxWidth, begin, n, len, true));\\n        return res;\\n    }\\nprivate:\\n    string connect(const vector<string>& words, int maxWidth,\\n                   int begin, int end, int len,\\n                   bool is_last) {\\n        string s;\\n        int n = end - begin;\\n        for (int i = 0; i < n; ++i) {\\n            s += words[begin + i];\\n            addSpaces(i, n - 1, maxWidth - len, is_last, &s);\\n        }\\n        if (s.size() < maxWidth) {\\n            s.append(maxWidth - s.size(), \\' \\');\\n        }\\n        return s;\\n    }\\n    void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {\\n        if (i < spaceCnt) {\\n            int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);\\n            s->append(spaces, \\' \\');\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953512,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition and approach dicussed in detail in video solution\\nhttps://youtu.be/hLXrrg-cd98\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int left = 0;\\n        std::vector<string> answer;\\n        while (left < words.size()) {\\n            int right = getRightPtr(left, words, maxWidth);\\n            answer.push_back(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        return answer;\\n    }\\nprivate:\\n\\n    int getRightPtr(int left, vector<string>& words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        while (right < words.size() && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n        return right - 1;\\n    }\\n\\n    string justify(int left, int right, vector<string>& words, int maxWidth) {\\n        if (right - left == 0) return addRemSpaces(words[left], maxWidth);\\n\\n        bool isLastLine = right == words.size() - 1;\\n    \\n        int numSpaces = right - left;\\n    \\n        int totalSpace = maxWidth - findLengthOfRange(left, right, words);\\n    \\n        string space = isLastLine ? \" \" : findSpaceSeq(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n    \\n        string answer = \"\";\\n        for (int i = left; i <= right; i++) {\\n            answer += (words[i]) + (space) + (remainder-- > 0 ? \" \" : \"\");\\n        }\\n    \\n        int leftPtr = 0, rightPtr = answer.size() - 1;\\n\\n        //removing trailing spaces\\n        while(left < answer.size() && answer[leftPtr]  ==  \\' \\'){\\n            leftPtr++;\\n        }\\n        while(rightPtr > - 1 && answer[rightPtr] == \\' \\'){\\n            rightPtr--;\\n        }\\n        return addRemSpaces(answer.substr(leftPtr, rightPtr + 1 - leftPtr), maxWidth);\\n        }\\n\\n    string addRemSpaces(string answer, int maxWidth) {\\n        if (answer.length() >= maxWidth) return answer;\\n        return answer + string(maxWidth - answer.length(), \\' \\');\\n    }\\n\\n    int findLengthOfRange(int left, int right, vector<string>& words) {\\n        int length = 0;\\n        for (int i = left; i <= right; i++) {\\n            length += words[i].length();\\n        }\\n        return length;\\n    }\\n\\n    string findSpaceSeq(int count) {\\n        return std::string(count, \\' \\');\\n    }\\n    \\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n    int left = 0;\\n        List<String> answer = new ArrayList<>();\\n        while (left < words.length) {\\n            int right = getRightPtr(left, words, maxWidth);\\n            answer.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        return answer;\\n    }\\n    int getRightPtr(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n        return right - 1;\\n    }\\n\\n    String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return addRemSpaces(words[left], maxWidth);\\n\\n        boolean isLastLine = right == words.length - 1;\\n    \\n        int numSpaces = right - left;\\n    \\n        int totalSpace = maxWidth - findLengthOfRange(left, right, words);\\n    \\n        String space = isLastLine ? \" \" : findSpaceSeq(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n    \\n        String answer = \"\";\\n        for (int i = left; i <= right; i++) {\\n            answer += (words[i]) + (space) + (remainder-- > 0 ? \" \" : \"\");\\n        }\\n    \\n        int leftPtr = 0, rightPtr = answer.length() - 1;\\n\\n        //removing trailing spaces\\n        while(left < answer.length() && answer.charAt(leftPtr)  ==  \\' \\'){\\n            leftPtr++;\\n        }\\n        while(rightPtr > - 1 && answer.charAt(rightPtr) == \\' \\'){\\n            rightPtr--;\\n        }\\n        return addRemSpaces(answer.substring(leftPtr, rightPtr + 1 - leftPtr), maxWidth);\\n        }\\n\\n    String addRemSpaces(String answer, int maxWidth) {\\n        if (answer.length() >= maxWidth) return answer;\\n        return answer + new String(new char[maxWidth - answer.length()]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n\\n    int findLengthOfRange(int left, int right, String[] words) {\\n        int length = 0;\\n        for (int i = left; i <= right; i++) {\\n            length += words[i].length();\\n        }\\n        return length;\\n    }\\n\\n    String findSpaceSeq(int count) {\\n        return new String(new char[count]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int left = 0;\\n        std::vector<string> answer;\\n        while (left < words.size()) {\\n            int right = getRightPtr(left, words, maxWidth);\\n            answer.push_back(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        return answer;\\n    }\\nprivate:\\n\\n    int getRightPtr(int left, vector<string>& words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        while (right < words.size() && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n        return right - 1;\\n    }\\n\\n    string justify(int left, int right, vector<string>& words, int maxWidth) {\\n        if (right - left == 0) return addRemSpaces(words[left], maxWidth);\\n\\n        bool isLastLine = right == words.size() - 1;\\n    \\n        int numSpaces = right - left;\\n    \\n        int totalSpace = maxWidth - findLengthOfRange(left, right, words);\\n    \\n        string space = isLastLine ? \" \" : findSpaceSeq(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n    \\n        string answer = \"\";\\n        for (int i = left; i <= right; i++) {\\n            answer += (words[i]) + (space) + (remainder-- > 0 ? \" \" : \"\");\\n        }\\n    \\n        int leftPtr = 0, rightPtr = answer.size() - 1;\\n\\n        //removing trailing spaces\\n        while(left < answer.size() && answer[leftPtr]  ==  \\' \\'){\\n            leftPtr++;\\n        }\\n        while(rightPtr > - 1 && answer[rightPtr] == \\' \\'){\\n            rightPtr--;\\n        }\\n        return addRemSpaces(answer.substr(leftPtr, rightPtr + 1 - leftPtr), maxWidth);\\n        }\\n\\n    string addRemSpaces(string answer, int maxWidth) {\\n        if (answer.length() >= maxWidth) return answer;\\n        return answer + string(maxWidth - answer.length(), \\' \\');\\n    }\\n\\n    int findLengthOfRange(int left, int right, vector<string>& words) {\\n        int length = 0;\\n        for (int i = left; i <= right; i++) {\\n            length += words[i].length();\\n        }\\n        return length;\\n    }\\n\\n    string findSpaceSeq(int count) {\\n        return std::string(count, \\' \\');\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n    int left = 0;\\n        List<String> answer = new ArrayList<>();\\n        while (left < words.length) {\\n            int right = getRightPtr(left, words, maxWidth);\\n            answer.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        return answer;\\n    }\\n    int getRightPtr(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n        return right - 1;\\n    }\\n\\n    String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return addRemSpaces(words[left], maxWidth);\\n\\n        boolean isLastLine = right == words.length - 1;\\n    \\n        int numSpaces = right - left;\\n    \\n        int totalSpace = maxWidth - findLengthOfRange(left, right, words);\\n    \\n        String space = isLastLine ? \" \" : findSpaceSeq(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n    \\n        String answer = \"\";\\n        for (int i = left; i <= right; i++) {\\n            answer += (words[i]) + (space) + (remainder-- > 0 ? \" \" : \"\");\\n        }\\n    \\n        int leftPtr = 0, rightPtr = answer.length() - 1;\\n\\n        //removing trailing spaces\\n        while(left < answer.length() && answer.charAt(leftPtr)  ==  \\' \\'){\\n            leftPtr++;\\n        }\\n        while(rightPtr > - 1 && answer.charAt(rightPtr) == \\' \\'){\\n            rightPtr--;\\n        }\\n        return addRemSpaces(answer.substring(leftPtr, rightPtr + 1 - leftPtr), maxWidth);\\n        }\\n\\n    String addRemSpaces(String answer, int maxWidth) {\\n        if (answer.length() >= maxWidth) return answer;\\n        return answer + new String(new char[maxWidth - answer.length()]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n\\n    int findLengthOfRange(int left, int right, String[] words) {\\n        int length = 0;\\n        for (int i = left; i <= right; i++) {\\n            length += words[i].length();\\n        }\\n        return length;\\n    }\\n\\n    String findSpaceSeq(int count) {\\n        return new String(new char[count]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953504,
                "title": "simple-c-solution",
                "content": "# Intuition\\nAdd as many words to a line while it is <= maxWidth\\nJustify by then adding spaces until that line == maxWidth\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n\\t\\tList<string> result = new List<string>();\\n\\t\\tList<string> temp = new List<string>();\\n\\t\\tstring line = string.Empty;\\n\\t\\tforeach (string word in words)\\n\\t\\t{\\n\\t\\t\\tif (temp.Count + word.Length + temp.Sum(x => x.Length) <= maxWidth)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp.Add(word);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Justify\\n\\t\\t\\t\\tresult.Add(Justify(temp, maxWidth));\\n\\t\\t\\t\\ttemp = new List<string>() { word };\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (temp.Count > 0)\\n\\t\\t{\\n\\t\\t\\tresult.Add(string.Join(\" \", temp).PadRight(maxWidth));\\n\\t\\t}\\n\\t\\treturn result.ToArray();\\n    }\\n\\n\\tpublic string Justify(List<string> words, int maxWidth)\\n\\t{\\n\\t\\tif (words.Count == 1)\\n\\t\\t{\\n\\t\\t\\treturn words[0].PadRight(maxWidth);\\n\\t\\t}\\n        while (words.Sum(x => x.Length) < maxWidth)\\n        {\\n            // We can\\'t justify last word\\n            for (int i = 0; i < words.Count - 1; i++)\\n            {\\n                words[i] = words[i] + \" \";\\n                if (words.Sum(x => x.Length) == maxWidth)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n\\t\\treturn string.Join(\"\", words);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n\\t\\tList<string> result = new List<string>();\\n\\t\\tList<string> temp = new List<string>();\\n\\t\\tstring line = string.Empty;\\n\\t\\tforeach (string word in words)\\n\\t\\t{\\n\\t\\t\\tif (temp.Count + word.Length + temp.Sum(x => x.Length) <= maxWidth)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp.Add(word);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Justify\\n\\t\\t\\t\\tresult.Add(Justify(temp, maxWidth));\\n\\t\\t\\t\\ttemp = new List<string>() { word };\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (temp.Count > 0)\\n\\t\\t{\\n\\t\\t\\tresult.Add(string.Join(\" \", temp).PadRight(maxWidth));\\n\\t\\t}\\n\\t\\treturn result.ToArray();\\n    }\\n\\n\\tpublic string Justify(List<string> words, int maxWidth)\\n\\t{\\n\\t\\tif (words.Count == 1)\\n\\t\\t{\\n\\t\\t\\treturn words[0].PadRight(maxWidth);\\n\\t\\t}\\n        while (words.Sum(x => x.Length) < maxWidth)\\n        {\\n            // We can\\'t justify last word\\n            for (int i = 0; i < words.Count - 1; i++)\\n            {\\n                words[i] = words[i] + \" \";\\n                if (words.Sum(x => x.Length) == maxWidth)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n\\t\\treturn string.Join(\"\", words);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953142,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nWe have a task of justifying a list of words into lines of equal width while adhering to a specified maximum width. So we iterate through the words, progressively building lines and calculating the total length of characters in the current line. When the addition of a new word would exceed the maximum width, we distribute spaces evenly between words to achieve the target width. The last line is handled separately, being left-aligned with extra spaces added to the right.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n- So we iterate through each word in the words vector. We check if adding the current word to the current line would exceed the maxWidth limit. If it does, we enter a block to format and justify the current line. We distribute spaces evenly between words to achieve the desired line width, with the exception of the last line which is left-aligned.\\n\\n- After formatting the current line, it is added to the result vector, and the current vector is cleared along with resetting numLen to 0.\\n\\n- If the current word can be added to the current line without exceeding the maxWidth, the word is added to the current vector, and its length is added to numLen.\\n\\n- Once all words have been processed, we handle the last line by concatenating the words with single spaces between them, and then adding extra spaces to the right to achieve the maxWidth.\\n\\n- The last line is added to the result vector, and the final result vector containing justified lines is returned.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        vector<string> current;\\n        int numLen=0;\\n        for(string word:words){\\n            if(word.size()+current.size()+numLen>maxWidth){\\n                for(int i=0;i<maxWidth-numLen;i++){\\n                    current[i%(current.size()-1?current.size()-1:1)]+=\\' \\';\\n                }\\n                result.push_back(\"\");\\n                for(string s:current) result.back()+=s;\\n                current.clear();\\n                numLen=0;\\n            }\\n            current.push_back(word);\\n            numLen+=word.size();\\n        }\\n        string lastLine=\"\";\\n        for(string s:current) lastLine+=s+\\' \\';\\n        lastLine=lastLine.substr(0,lastLine.size()-1);\\n        while(lastLine.size()<maxWidth) lastLine+=\\' \\';\\n        result.push_back(lastLine);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        vector<string> current;\\n        int numLen=0;\\n        for(string word:words){\\n            if(word.size()+current.size()+numLen>maxWidth){\\n                for(int i=0;i<maxWidth-numLen;i++){\\n                    current[i%(current.size()-1?current.size()-1:1)]+=\\' \\';\\n                }\\n                result.push_back(\"\");\\n                for(string s:current) result.back()+=s;\\n                current.clear();\\n                numLen=0;\\n            }\\n            current.push_back(word);\\n            numLen+=word.size();\\n        }\\n        string lastLine=\"\";\\n        for(string s:current) lastLine+=s+\\' \\';\\n        lastLine=lastLine.substr(0,lastLine.size()-1);\\n        while(lastLine.size()<maxWidth) lastLine+=\\' \\';\\n        result.push_back(lastLine);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952495,
                "title": "c-easy-solution-faster-than-100-excellent-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // Intution\\n        // The idea in here is really very simple. What we will do is we will maintain the spaces required for the words in the temporary vector and also the number of characters in the current word. If we found that the total lenght is greater than or equal to maximum length then we will perform the operation.\\n\\n        int spacesReq;\\n        int currLen = 0;\\n\\n        vector<string> temp;\\n        vector<string> result;\\n\\n        for(auto &word : words){\\n            int wordLen = word.size();\\n            spacesReq = temp.size();\\n            if(currLen + wordLen + spacesReq > maxWidth){\\n                string answer = \"\";\\n                int spaces = maxWidth - currLen;\\n                if(temp.size() == 1){\\n                    answer = temp[0];\\n                    while(spaces --> 0) answer += \" \";\\n                    result.push_back(answer);\\n                }\\n                else{\\n                    int spaceBetween = spaces / (temp.size() - 1);\\n                    int extraSpaces = maxWidth - currLen - spaceBetween * (temp.size() - 1);\\n                    answer = temp[0];\\n                    string bet = \"\";\\n                    while(spaceBetween --> 0) bet += \" \";\\n                    for(int i = 1 ; i < temp.size() ; i++){\\n                        answer += bet;\\n                        if(extraSpaces > 0){\\n                            answer += \" \";\\n                            extraSpaces -= 1;\\n                        }\\n                        answer += temp[i];\\n                    }\\n                    result.push_back(answer);\\n                }\\n                temp.clear();\\n                currLen = wordLen;\\n                temp.push_back(word);\\n            }\\n            else{\\n                currLen += wordLen;\\n                temp.push_back(word);\\n            }\\n        }\\n\\n        if(temp.size() >= 1){\\n            string answer = temp[0];\\n            for(int i = 1 ; i < temp.size() ; i++){\\n                answer += \" \" + temp[i];\\n            }\\n            while(answer.size() < maxWidth) answer += \" \";\\n            result.push_back(answer);\\n        }\\n\\n        return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // Intution\\n        // The idea in here is really very simple. What we will do is we will maintain the spaces required for the words in the temporary vector and also the number of characters in the current word. If we found that the total lenght is greater than or equal to maximum length then we will perform the operation.\\n\\n        int spacesReq;\\n        int currLen = 0;\\n\\n        vector<string> temp;\\n        vector<string> result;\\n\\n        for(auto &word : words){\\n            int wordLen = word.size();\\n            spacesReq = temp.size();\\n            if(currLen + wordLen + spacesReq > maxWidth){\\n                string answer = \"\";\\n                int spaces = maxWidth - currLen;\\n                if(temp.size() == 1){\\n                    answer = temp[0];\\n                    while(spaces --> 0) answer += \" \";\\n                    result.push_back(answer);\\n                }\\n                else{\\n                    int spaceBetween = spaces / (temp.size() - 1);\\n                    int extraSpaces = maxWidth - currLen - spaceBetween * (temp.size() - 1);\\n                    answer = temp[0];\\n                    string bet = \"\";\\n                    while(spaceBetween --> 0) bet += \" \";\\n                    for(int i = 1 ; i < temp.size() ; i++){\\n                        answer += bet;\\n                        if(extraSpaces > 0){\\n                            answer += \" \";\\n                            extraSpaces -= 1;\\n                        }\\n                        answer += temp[i];\\n                    }\\n                    result.push_back(answer);\\n                }\\n                temp.clear();\\n                currLen = wordLen;\\n                temp.push_back(word);\\n            }\\n            else{\\n                currLen += wordLen;\\n                temp.push_back(word);\\n            }\\n        }\\n\\n        if(temp.size() >= 1){\\n            string answer = temp[0];\\n            for(int i = 1 ; i < temp.size() ; i++){\\n                answer += \" \" + temp[i];\\n            }\\n            while(answer.size() < maxWidth) answer += \" \";\\n            result.push_back(answer);\\n        }\\n\\n        return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952371,
                "title": "c-solution-for-text-justification-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to format a given list of words into lines of a given maximum width while adhering to the specified rules for justification. The key intuition is to process the words one by one, adding them to the current line as long as they fit within the maxWidth. If the current line is not full, we distribute extra spaces between the words to achieve full justification. When a line is full, we move on to the next line. We repeat this process until all words are processed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an empty list to store the resulting lines.\\n1. Loop through the words array, processing each word and building lines.\\n1. For each line, calculate the number of words that can fit in the line without exceeding maxWidth.\\n1. Calculate the total spaces needed to achieve full justification for the words in the line.\\n1. Depending on whether it\\'s the last line or there\\'s only one word in the line, handle left justification.\\n1. For other lines, calculate the spaces between words and distribute them evenly.\\n1. Add the constructed line to the result list.\\n1. Move the word index to the next word that was not included in the current line.\\n1. Return the list of formatted lines.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is O(n), where n is the number of words in the input array. We iterate through each word once, and for each word, we perform constant time operations like calculating lengths and spaces.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n + m), where n is the number of words in the input array and m is the length of the longest word. We store the formatted lines in a list, which takes O(n) space. Additionally, we use StringBuilder to construct the lines, which might require up to O(m) space for each line during the construction process.\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> result = new List<string>();\\n        int startIndex = 0;\\n\\n        while (startIndex < words.Length) {\\n            int endIndex = GetEndIndex(words, startIndex, maxWidth);\\n            int spaceCount = endIndex - startIndex;\\n\\n            StringBuilder line = new StringBuilder();\\n\\n            if (spaceCount == 0 || endIndex == words.Length - 1) {\\n                // Left-justify the last line or lines with only one word.\\n                for (int i = startIndex; i <= endIndex; i++) {\\n                    line.Append(words[i]);\\n                    if (i < endIndex) {\\n                        line.Append(\\' \\');\\n                    }\\n                }\\n                line.Append(\\' \\', maxWidth - line.Length);\\n            } else {\\n                int totalSpaces = maxWidth - CalculateWordLength(words, startIndex, endIndex);\\n                int spacesBetweenWords = totalSpaces / spaceCount;\\n                int extraSpaces = totalSpaces % spaceCount;\\n\\n                for (int i = startIndex; i <= endIndex; i++) {\\n                    line.Append(words[i]);\\n                    if (i < endIndex) {\\n                        int spaces = spacesBetweenWords + (extraSpaces > 0 ? 1 : 0);\\n                        line.Append(\\' \\', spaces);\\n                        extraSpaces--;\\n                    }\\n                }\\n            }\\n\\n            result.Add(line.ToString());\\n            startIndex = endIndex + 1;\\n        }\\n\\n        return result;\\n    }\\n\\n    private int GetEndIndex(string[] words, int startIndex, int maxWidth) {\\n        int endIndex = startIndex;\\n        int lineLength = words[startIndex].Length;\\n\\n        while (endIndex + 1 < words.Length && lineLength + words[endIndex + 1].Length + 1 <= maxWidth) {\\n            endIndex++;\\n            lineLength += words[endIndex].Length + 1;\\n        }\\n\\n        return endIndex;\\n    }\\n\\n    private int CalculateWordLength(string[] words, int startIndex, int endIndex) {\\n        int length = 0;\\n        for (int i = startIndex; i <= endIndex; i++) {\\n            length += words[i].Length;\\n        }\\n        return length;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> result = new List<string>();\\n        int startIndex = 0;\\n\\n        while (startIndex < words.Length) {\\n            int endIndex = GetEndIndex(words, startIndex, maxWidth);\\n            int spaceCount = endIndex - startIndex;\\n\\n            StringBuilder line = new StringBuilder();\\n\\n            if (spaceCount == 0 || endIndex == words.Length - 1) {\\n                // Left-justify the last line or lines with only one word.\\n                for (int i = startIndex; i <= endIndex; i++) {\\n                    line.Append(words[i]);\\n                    if (i < endIndex) {\\n                        line.Append(\\' \\');\\n                    }\\n                }\\n                line.Append(\\' \\', maxWidth - line.Length);\\n            } else {\\n                int totalSpaces = maxWidth - CalculateWordLength(words, startIndex, endIndex);\\n                int spacesBetweenWords = totalSpaces / spaceCount;\\n                int extraSpaces = totalSpaces % spaceCount;\\n\\n                for (int i = startIndex; i <= endIndex; i++) {\\n                    line.Append(words[i]);\\n                    if (i < endIndex) {\\n                        int spaces = spacesBetweenWords + (extraSpaces > 0 ? 1 : 0);\\n                        line.Append(\\' \\', spaces);\\n                        extraSpaces--;\\n                    }\\n                }\\n            }\\n\\n            result.Add(line.ToString());\\n            startIndex = endIndex + 1;\\n        }\\n\\n        return result;\\n    }\\n\\n    private int GetEndIndex(string[] words, int startIndex, int maxWidth) {\\n        int endIndex = startIndex;\\n        int lineLength = words[startIndex].Length;\\n\\n        while (endIndex + 1 < words.Length && lineLength + words[endIndex + 1].Length + 1 <= maxWidth) {\\n            endIndex++;\\n            lineLength += words[endIndex].Length + 1;\\n        }\\n\\n        return endIndex;\\n    }\\n\\n    private int CalculateWordLength(string[] words, int startIndex, int endIndex) {\\n        int length = 0;\\n        for (int i = startIndex; i <= endIndex; i++) {\\n            length += words[i].Length;\\n        }\\n        return length;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952286,
                "title": "c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        for(int i = 0, j; i < words.size(); i = j) {\\n            int width = 0;\\n            for(j = i; j < words.size() && width + words[j].size() + j - i <= maxWidth; j++) {\\n                width += words[j].size();\\n            }\\n            int space = 1, extra = 0;\\n            if(j - i != 1 && j != words.size()) {\\n                space = (maxWidth - width) / (j - i - 1);\\n                extra = (maxWidth - width) % (j - i - 1);\\n            }\\n            string line = words[i];\\n            for(int k = i + 1; k < j; k++) {\\n                line += string(space, \\' \\');\\n                if(extra > 0) {\\n                    extra--;\\n                    line += \" \";\\n                }\\n                line += words[k];\\n            }\\n            \\n            line += string(maxWidth - line.size(), \\' \\');\\n            result.push_back(line);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        for(int i = 0, j; i < words.size(); i = j) {\\n            int width = 0;\\n            for(j = i; j < words.size() && width + words[j].size() + j - i <= maxWidth; j++) {\\n                width += words[j].size();\\n            }\\n            int space = 1, extra = 0;\\n            if(j - i != 1 && j != words.size()) {\\n                space = (maxWidth - width) / (j - i - 1);\\n                extra = (maxWidth - width) % (j - i - 1);\\n            }\\n            string line = words[i];\\n            for(int k = i + 1; k < j; k++) {\\n                line += string(space, \\' \\');\\n                if(extra > 0) {\\n                    extra--;\\n                    line += \" \";\\n                }\\n                line += words[k];\\n            }\\n            \\n            line += string(maxWidth - line.size(), \\' \\');\\n            result.push_back(line);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952236,
                "title": "0ms-o-n-most-efficient-solution-simplest-code-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem, despite marked hard, is actually a simple one. It requires no algorithm skills but edge case handlings. The key is to simply keep your code simple and readable, so that you know the edge cases are properly covered.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first scan words, do some arithmetics to find width and decide a line, then we pack a line, in simple iterations.\\n```\\nint width = words[start].size();\\nint end = start + 1;\\nwhile (end < words.size()) {\\n  int new_width = width + words[end].size() + 1;\\n  if (new_width > maxWidth) {\\n    break;\\n  }\\n  width = new_width;\\n  ++end;\\n}\\n// Now we pack words[start, end) into a line.\\n```\\nNothing is tricky here except to remember the `+1` for each extra words.\\n\\nThen we pack `words[start, end)` into a single text line, with spaces properly distributed.\\nBy default each gap between words have one space, but in order to (also) right justify the text line we need to add extra spaces. And we might also need to add one more extra space for some gaps in the left. These can all be calculated using simple arithmetics.\\nMake sure to compute `extra_space_per_gap` and `one_more_space_gaps` **outside the inner loop** as a good habit for performance and readability.\\n```\\nint count = end - start;\\nstring& line = text.emplace_back();\\nline.append(words[start]);\\n\\nint extra_space_per_gap = 0;\\nint one_more_space_gaps = 0;\\nif (count > 1 && end < words.size()) {  // Not last line or single word line.\\n  int gap = count - 1;\\n  int extra_space = maxWidth - width;\\n  extra_space_per_gap = extra_space / gap;\\n  one_more_space_gaps = extra_space % gap;\\n}\\nfor (int i = 1; i < count; ++i) {\\n  int space_count = 1 + extra_space_per_gap + (one_more_space_gaps-- > 0);\\n  line.resize(line.size() + space_count, \\' \\');\\n  line.append(words[start + i]);\\n}\\nline.resize(maxWidth, \\' \\');\\n```\\nNote that we need to handle last line differently.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N)$$ Where $N$ is the size of the input data. More specifically $N$ is the sum of the lengths of all the `words`.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int start = 0;\\n    vector<string> text;\\n    while (start < words.size()) {\\n      int width = words[start].size();\\n      int end = start + 1;\\n      while (end < words.size()) {\\n        int new_width = width + words[end].size() + 1;\\n        if (new_width > maxWidth) {\\n          break;\\n        }\\n        width = new_width;\\n        ++end;\\n      }\\n      // Now we pack words[start, end) into a line.\\n      int count = end - start;\\n      string& line = text.emplace_back();\\n      line.append(words[start]);\\n\\n      int extra_space_per_gap = 0;\\n      int one_more_space_gaps = 0;\\n      if (count > 1 && end < words.size()) {  // Not last line or single word line.\\n        int gap = count - 1;\\n        int extra_space = maxWidth - width;\\n        extra_space_per_gap = extra_space / gap;\\n        one_more_space_gaps = extra_space % gap;\\n      }\\n      for (int i = 1; i < count; ++i) {\\n        int space_count = 1 + extra_space_per_gap + (one_more_space_gaps-- > 0);\\n        line.resize(line.size() + space_count, \\' \\');\\n        line.append(words[start + i]);\\n      }\\n      line.resize(maxWidth, \\' \\');\\n      start = end;\\n    }\\n    return text;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nint width = words[start].size();\\nint end = start + 1;\\nwhile (end < words.size()) {\\n  int new_width = width + words[end].size() + 1;\\n  if (new_width > maxWidth) {\\n    break;\\n  }\\n  width = new_width;\\n  ++end;\\n}\\n// Now we pack words[start, end) into a line.\\n```\n```\\nint count = end - start;\\nstring& line = text.emplace_back();\\nline.append(words[start]);\\n\\nint extra_space_per_gap = 0;\\nint one_more_space_gaps = 0;\\nif (count > 1 && end < words.size()) {  // Not last line or single word line.\\n  int gap = count - 1;\\n  int extra_space = maxWidth - width;\\n  extra_space_per_gap = extra_space / gap;\\n  one_more_space_gaps = extra_space % gap;\\n}\\nfor (int i = 1; i < count; ++i) {\\n  int space_count = 1 + extra_space_per_gap + (one_more_space_gaps-- > 0);\\n  line.resize(line.size() + space_count, \\' \\');\\n  line.append(words[start + i]);\\n}\\nline.resize(maxWidth, \\' \\');\\n```\n```\\nclass Solution {\\npublic:\\n  vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int start = 0;\\n    vector<string> text;\\n    while (start < words.size()) {\\n      int width = words[start].size();\\n      int end = start + 1;\\n      while (end < words.size()) {\\n        int new_width = width + words[end].size() + 1;\\n        if (new_width > maxWidth) {\\n          break;\\n        }\\n        width = new_width;\\n        ++end;\\n      }\\n      // Now we pack words[start, end) into a line.\\n      int count = end - start;\\n      string& line = text.emplace_back();\\n      line.append(words[start]);\\n\\n      int extra_space_per_gap = 0;\\n      int one_more_space_gaps = 0;\\n      if (count > 1 && end < words.size()) {  // Not last line or single word line.\\n        int gap = count - 1;\\n        int extra_space = maxWidth - width;\\n        extra_space_per_gap = extra_space / gap;\\n        one_more_space_gaps = extra_space % gap;\\n      }\\n      for (int i = 1; i < count; ++i) {\\n        int space_count = 1 + extra_space_per_gap + (one_more_space_gaps-- > 0);\\n        line.resize(line.size() + space_count, \\' \\');\\n        line.append(words[start + i]);\\n      }\\n      line.resize(maxWidth, \\' \\');\\n      start = end;\\n    }\\n    return text;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952203,
                "title": "c-easy-solution-100-o-n",
                "content": "#### Approach:\\nI will break the question into 2 sub questions: \\n1. First part is finding which how many words I can include in my current line. I would just be finding be the words not adding them in the line now, I will add the words in the line in second part.\\n2.  Second part is adding words in the line and also justifying the line at the same time.\\n3. Repeating the 1st and 2nd part for every line till every word is added in some line.\\n\\n#### Points to Note: \\n1. I will **not** make the line first and then justify it.\\n2. While updating current length of line I am adding 1+words[i].size() (except when current length is 0 where I add words[i[.size()).\\n\\tThis extra plus 1 is kept because every word in a line must have atleast 1 space between them.\\n3. Say there are m words in line for justifying the line and *left* is the amount of extra space in line. \\n\\tSo in total there will m-1 number of gaps in the line , so *left* number of spaces needs to be added in the line for justifying. \\n\\tIn the 1st (left%(m-1) ) gaps there will be *((left/gap)+1)* extra spaces and in the remaining spaces there will be *(left/gap)* extra spaces.\\n4. In case there is only a single word in line or it is the last line then all the extra spaces needs to be added at the end of the line.\\n5. Try to use words[i].size() instead of words[i].length to find out size of word. The .size() method runs in O(1) time while the .length() runs in O(n) time.\\n\\n\\n#### Code:\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n\\t\\tint k=maxWidth;\\n        string temp=\"\";\\n        int n=words.size();\\n        \\n        vector<string> ans;\\n        \\n        int i=0;\\n        int currsize=0;\\n        int prev=0;\\n        \\n        while(i<n){\\n            \\n            \\n            \\n            int curr=words[i].size();\\n            i++;\\n            \\n            while(i<n and (curr+words[i].size()+1)<=k){\\n                curr+=(words[i].size()+1);\\n                i++;\\n            }\\n            \\n            string temp=\"\";\\n            ans.push_back(temp);\\n            int m=i-prev;\\n            \\n            if(i==n or m==1){\\n                \\n                for(int j=prev;j<i;j++){\\n                    ans[currsize]+=words[j];\\n                    if(j!=(i-1)){\\n                        ans[currsize]+=\\' \\';\\n                    }\\n                }\\n                \\n                int z=ans[currsize].size();\\n                while(z<k){\\n                    ans[currsize]+=\\' \\';\\n                    z++;\\n                }\\n                \\n            }else{\\n                \\n                int gap=m-1;\\n                int left=k-curr;\\n                \\n                int a=left/gap;\\n                \\n                int x=(gap-(left%gap)) ; // gaps with \\'a\\' no. of spaces\\n                int y=left%gap ; // gaps with \\'a+1\\' no. of spaces\\n                \\n                \\n                for(int j=prev;j<i;j++){\\n                    \\n                    ans[currsize]+=words[j];\\n                    if(j!=(i-1)){\\n                        ans[currsize]+=\\' \\';\\n                    }\\n                    \\n                    if(x>0 or y>0){\\n                        for(int t=0;t<a;t++){\\n                            ans[currsize]+=\\' \\';\\n                        }\\n                    }\\n                    \\n                    if(y>0){\\n                        ans[currsize]+=\\' \\';\\n                        y--;\\n                    }else{\\n                        x--;\\n                    }\\n                    \\n                }\\n            }\\n            \\n            currsize++;\\n            prev=i;\\n            \\n        }\\n        \\n        \\n        return(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n\\t\\tint k=maxWidth;\\n        string temp=\"\";\\n        int n=words.size();\\n        \\n        vector<string> ans;\\n        \\n        int i=0;\\n        int currsize=0;\\n        int prev=0;\\n        \\n        while(i<n){\\n            \\n            \\n            \\n            int curr=words[i].size();\\n            i++;\\n            \\n            while(i<n and (curr+words[i].size()+1)<=k){\\n                curr+=(words[i].size()+1);\\n                i++;\\n            }\\n            \\n            string temp=\"\";\\n            ans.push_back(temp);\\n            int m=i-prev;\\n            \\n            if(i==n or m==1){\\n                \\n                for(int j=prev;j<i;j++){\\n                    ans[currsize]+=words[j];\\n                    if(j!=(i-1)){\\n                        ans[currsize]+=\\' \\';\\n                    }\\n                }\\n                \\n                int z=ans[currsize].size();\\n                while(z<k){\\n                    ans[currsize]+=\\' \\';\\n                    z++;\\n                }\\n                \\n            }else{\\n                \\n                int gap=m-1;\\n                int left=k-curr;\\n                \\n                int a=left/gap;\\n                \\n                int x=(gap-(left%gap)) ; // gaps with \\'a\\' no. of spaces\\n                int y=left%gap ; // gaps with \\'a+1\\' no. of spaces\\n                \\n                \\n                for(int j=prev;j<i;j++){\\n                    \\n                    ans[currsize]+=words[j];\\n                    if(j!=(i-1)){\\n                        ans[currsize]+=\\' \\';\\n                    }\\n                    \\n                    if(x>0 or y>0){\\n                        for(int t=0;t<a;t++){\\n                            ans[currsize]+=\\' \\';\\n                        }\\n                    }\\n                    \\n                    if(y>0){\\n                        ans[currsize]+=\\' \\';\\n                        y--;\\n                    }else{\\n                        x--;\\n                    }\\n                    \\n                }\\n            }\\n            \\n            currsize++;\\n            prev=i;\\n            \\n        }\\n        \\n        \\n        return(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952174,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        n=len(words)\\n        ans=[]\\n        i=0\\n        while i<n:\\n            temp=[]\\n            seen=0\\n            cur=\"\"\\n            while i<n and seen+len(words[i])+len(temp)<=maxWidth:\\n                temp.append(words[i])\\n                seen+=len(words[i])\\n                i+=1\\n\\n            m=len(temp)\\n            if (m-1)!=0 and i!=n:\\n                q,r=divmod(maxWidth-seen,(m-1))\\n                sp=[q+(1 if j<r else 0) for j in range(m-1)]\\n                for j in range(m-1):\\n                    cur+=temp[j]+\\' \\'*sp[j]\\n                cur+=temp[-1]\\n\\n            else:\\n                for j in range(m-1):\\n                    cur+=temp[j]+\\' \\'\\n                cur+=temp[-1]\\n                cur+=\\' \\'*(maxWidth-len(cur))\\n\\n            ans.append(cur)\\n        return ans                        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        n=len(words)\\n        ans=[]\\n        i=0\\n        while i<n:\\n            temp=[]\\n            seen=0\\n            cur=\"\"\\n            while i<n and seen+len(words[i])+len(temp)<=maxWidth:\\n                temp.append(words[i])\\n                seen+=len(words[i])\\n                i+=1\\n\\n            m=len(temp)\\n            if (m-1)!=0 and i!=n:\\n                q,r=divmod(maxWidth-seen,(m-1))\\n                sp=[q+(1 if j<r else 0) for j in range(m-1)]\\n                for j in range(m-1):\\n                    cur+=temp[j]+\\' \\'*sp[j]\\n                cur+=temp[-1]\\n\\n            else:\\n                for j in range(m-1):\\n                    cur+=temp[j]+\\' \\'\\n                cur+=temp[-1]\\n                cur+=\\' \\'*(maxWidth-len(cur))\\n\\n            ans.append(cur)\\n        return ans                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771390,
                "title": "text-justification-o-n-javascript-memory-87-99-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\nvar fullJustify = function (words, maxWidth) {\\n  const builtArray = [];\\n  let tempArray = [];\\n  let tempLen = 0;\\n\\n  const createSpaceOfGivenSize = size => {\\n    let space = ``;\\n    for (let index = 0; index < size; index++) {\\n      space += ` `;\\n    }\\n    return space;\\n  };\\n\\n  //pack your words in a greedy approach; that is, pack as many words as you can in each line\\n  for (let index = 0; index < words.length; index++) {\\n    if (tempLen + tempArray.length + words[index].length <= maxWidth) {\\n      tempArray.push (words[index]);\\n      tempLen += words[index].length;\\n    } else {\\n      builtArray.push ({\\n        array: tempArray,\\n        size: tempLen,\\n      });\\n      tempArray = [words[index]];\\n      tempLen = words[index].length;\\n      continue;\\n    }\\n  }\\n\\n  //for last iteration\\n  builtArray.push ({\\n    array: tempArray,\\n    size: tempLen,\\n  });\\n  const output = [];\\n  for (let index = 0; index < builtArray.length; index++) {\\n    let {array, size} = builtArray[index];\\n    const totalWord = array.length;\\n    const totalRequiredSpace = maxWidth - size;\\n    if (index === builtArray.length - 1) {\\n      // because the last line must be left-justified instead of fully-justified.\\n      const str =\\n        array.join (` `) +\\n        createSpaceOfGivenSize (totalRequiredSpace - (array.length - 1));\\n      output.push (str);\\n    } else {\\n      let extraSpace = totalRequiredSpace % (totalWord - 1);\\n      //If the number of spaces on a line does not divide evenly between words,\\n      if (extraSpace) {\\n        const spaces = [];\\n        //Extra spaces between words should be distributed as evenly as possible.\\n        let spacePerWord = (totalRequiredSpace - extraSpace) / (totalWord - 1);\\n        for (let index = 0; index < totalWord - 1; index++) {\\n          spaces.push (createSpaceOfGivenSize (spacePerWord));\\n        }\\n        let tempTotalWord = totalWord - 1 - 1;\\n        // the empty slots on the left will be assigned more spaces than the slots on the right.\\n        while (extraSpace) {\\n          const temp = extraSpace % tempTotalWord;\\n          spacePerWord = parseInt (extraSpace / tempTotalWord);\\n          for (let index = 0; index < tempTotalWord; index++) {\\n            spaces[index] += createSpaceOfGivenSize (spacePerWord);\\n          }\\n          tempTotalWord -= 1;\\n          extraSpace = temp;\\n        }\\n        let tempString = ``;\\n        for (let index = 0; index < totalWord; index++) {\\n          //Each line has exactly maxWidth characters.\\n          if (spaces[index]) {\\n            tempString += array[index] + spaces[index] || ``;\\n          } else {\\n            tempString += array[index];\\n          }\\n        }\\n        output.push (tempString);\\n      } else {\\n        //If the number of spaces on a line divide evenly between words,\\n        if (totalWord - 1) {\\n          output.push (\\n            array.join (\\n              createSpaceOfGivenSize (totalRequiredSpace / (totalWord - 1))\\n            )\\n          );\\n        } else {\\n          output.push (array[0] + createSpaceOfGivenSize (totalRequiredSpace));\\n        }\\n      }\\n    }\\n  }\\n  return output;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/dee00410-e5ae-4791-a47c-9d22b55f5f1b_1689480610.4518938.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fullJustify = function (words, maxWidth) {\\n  const builtArray = [];\\n  let tempArray = [];\\n  let tempLen = 0;\\n\\n  const createSpaceOfGivenSize = size => {\\n    let space = ``;\\n    for (let index = 0; index < size; index++) {\\n      space += ` `;\\n    }\\n    return space;\\n  };\\n\\n  //pack your words in a greedy approach; that is, pack as many words as you can in each line\\n  for (let index = 0; index < words.length; index++) {\\n    if (tempLen + tempArray.length + words[index].length <= maxWidth) {\\n      tempArray.push (words[index]);\\n      tempLen += words[index].length;\\n    } else {\\n      builtArray.push ({\\n        array: tempArray,\\n        size: tempLen,\\n      });\\n      tempArray = [words[index]];\\n      tempLen = words[index].length;\\n      continue;\\n    }\\n  }\\n\\n  //for last iteration\\n  builtArray.push ({\\n    array: tempArray,\\n    size: tempLen,\\n  });\\n  const output = [];\\n  for (let index = 0; index < builtArray.length; index++) {\\n    let {array, size} = builtArray[index];\\n    const totalWord = array.length;\\n    const totalRequiredSpace = maxWidth - size;\\n    if (index === builtArray.length - 1) {\\n      // because the last line must be left-justified instead of fully-justified.\\n      const str =\\n        array.join (` `) +\\n        createSpaceOfGivenSize (totalRequiredSpace - (array.length - 1));\\n      output.push (str);\\n    } else {\\n      let extraSpace = totalRequiredSpace % (totalWord - 1);\\n      //If the number of spaces on a line does not divide evenly between words,\\n      if (extraSpace) {\\n        const spaces = [];\\n        //Extra spaces between words should be distributed as evenly as possible.\\n        let spacePerWord = (totalRequiredSpace - extraSpace) / (totalWord - 1);\\n        for (let index = 0; index < totalWord - 1; index++) {\\n          spaces.push (createSpaceOfGivenSize (spacePerWord));\\n        }\\n        let tempTotalWord = totalWord - 1 - 1;\\n        // the empty slots on the left will be assigned more spaces than the slots on the right.\\n        while (extraSpace) {\\n          const temp = extraSpace % tempTotalWord;\\n          spacePerWord = parseInt (extraSpace / tempTotalWord);\\n          for (let index = 0; index < tempTotalWord; index++) {\\n            spaces[index] += createSpaceOfGivenSize (spacePerWord);\\n          }\\n          tempTotalWord -= 1;\\n          extraSpace = temp;\\n        }\\n        let tempString = ``;\\n        for (let index = 0; index < totalWord; index++) {\\n          //Each line has exactly maxWidth characters.\\n          if (spaces[index]) {\\n            tempString += array[index] + spaces[index] || ``;\\n          } else {\\n            tempString += array[index];\\n          }\\n        }\\n        output.push (tempString);\\n      } else {\\n        //If the number of spaces on a line divide evenly between words,\\n        if (totalWord - 1) {\\n          output.push (\\n            array.join (\\n              createSpaceOfGivenSize (totalRequiredSpace / (totalWord - 1))\\n            )\\n          );\\n        } else {\\n          output.push (array[0] + createSpaceOfGivenSize (totalRequiredSpace));\\n        }\\n      }\\n    }\\n  }\\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3631796,
                "title": "solution-in-java-python",
                "content": "## Just follow through the code and you will be good to go.\\n---\\n# Code\\n```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        ArrayList<String> result = new ArrayList<>();\\n        ArrayList<String> line = new ArrayList<>();\\n        int ctr = 0;\\n        int width = 0;\\n        while(ctr<words.length)\\n        {\\n            String word = words[ctr];\\n            if(word.length()+width<=maxWidth)\\n            {\\n                line.add(word);\\n                width+=word.length()+1;\\n                ctr++;\\n            }\\n            else\\n            {\\n                int spaces = maxWidth-width+line.size();\\n                int j = 0;\\n                int k = 0;\\n                while(k < spaces)\\n                {\\n                    if(j>=line.size()-1)\\n                    {\\n                        j = 0;\\n                    }\\n                    line.set(j,line.get(j)+\" \");\\n                    k++;\\n                    j++;\\n                }\\n                String temp = \"\";\\n                for(String str: line)\\n                {\\n                    temp+=str;\\n                }\\n                result.add(temp);\\n                line.clear();\\n                width = 0;\\n            }\\n        }\\n        for(int i = 0;i<line.size()-1;i++)\\n        {\\n            line.set(i,line.get(i)+\" \");\\n        }\\n        for(int x = 0;x<maxWidth-width+1;x++)\\n        {\\n            line.set(line.size()-1,line.get(line.size()-1)+\" \");\\n        }\\n        String temp = \"\";\\n        for(String str: line)\\n        {\\n            temp+=str;\\n        }\\n        result.add(temp);\\n        return result;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []\\n        line = []\\n        width = 0 \\n        i = 0\\n        while i<len(words):\\n            word = words[i]\\n            if width+len(word)<=maxWidth:\\n                line.append(word)\\n                width+=len(word)+1\\n                i+=1\\n            else:\\n                spaces = maxWidth-width+len(line)\\n                j = 0\\n                s = 0\\n                while s<spaces:\\n                    if j>=len(line)-1:\\n                        j=0\\n                    line[j]+=\" \"\\n                    s+=1\\n                    j+=1\\n                result.append(\"\".join(line))\\n                line = []\\n                width = 0\\n        for word in range(len(line)-1):\\n            line[word]+=\" \"\\n        line[-1]+=\" \" * (maxWidth-width+1)\\n        result.append(\"\".join(line))\\n        return result\\n\\n\\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my solution.\\uD83D\\uDC4D*\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String"
                ],
                "code": "```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        ArrayList<String> result = new ArrayList<>();\\n        ArrayList<String> line = new ArrayList<>();\\n        int ctr = 0;\\n        int width = 0;\\n        while(ctr<words.length)\\n        {\\n            String word = words[ctr];\\n            if(word.length()+width<=maxWidth)\\n            {\\n                line.add(word);\\n                width+=word.length()+1;\\n                ctr++;\\n            }\\n            else\\n            {\\n                int spaces = maxWidth-width+line.size();\\n                int j = 0;\\n                int k = 0;\\n                while(k < spaces)\\n                {\\n                    if(j>=line.size()-1)\\n                    {\\n                        j = 0;\\n                    }\\n                    line.set(j,line.get(j)+\" \");\\n                    k++;\\n                    j++;\\n                }\\n                String temp = \"\";\\n                for(String str: line)\\n                {\\n                    temp+=str;\\n                }\\n                result.add(temp);\\n                line.clear();\\n                width = 0;\\n            }\\n        }\\n        for(int i = 0;i<line.size()-1;i++)\\n        {\\n            line.set(i,line.get(i)+\" \");\\n        }\\n        for(int x = 0;x<maxWidth-width+1;x++)\\n        {\\n            line.set(line.size()-1,line.get(line.size()-1)+\" \");\\n        }\\n        String temp = \"\";\\n        for(String str: line)\\n        {\\n            temp+=str;\\n        }\\n        result.add(temp);\\n        return result;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []\\n        line = []\\n        width = 0 \\n        i = 0\\n        while i<len(words):\\n            word = words[i]\\n            if width+len(word)<=maxWidth:\\n                line.append(word)\\n                width+=len(word)+1\\n                i+=1\\n            else:\\n                spaces = maxWidth-width+len(line)\\n                j = 0\\n                s = 0\\n                while s<spaces:\\n                    if j>=len(line)-1:\\n                        j=0\\n                    line[j]+=\" \"\\n                    s+=1\\n                    j+=1\\n                result.append(\"\".join(line))\\n                line = []\\n                width = 0\\n        for word in range(len(line)-1):\\n            line[word]+=\" \"\\n        line[-1]+=\" \" * (maxWidth-width+1)\\n        result.append(\"\".join(line))\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525236,
                "title": "pure-c",
                "content": "# Implemented:\\n```\\n1. cJust()        - Center justify\\n2. lJust()        - Left justify for last string\\n3. countStrings() - Strings counter for accurate mem alloc\\n```\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n\\nint countStrings(char ** words, int wordsSize, int maxWidth);\\nvoid cJust(char ** words, int wordsSize, int maxWidth, int extraSpaces, char * jStr);\\nvoid lJust(char ** words, int wordsSize, int maxWidth, char * jStr);\\n\\nchar ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize)\\n{\\n    *returnSize = countStrings(words, wordsSize, maxWidth);     // Get Number Of Justified Strings\\n    int currStr = 0;                                            // Current Result String Index\\n    const char **strings = calloc(sizeof(char *), *returnSize); // Mem Alloc\\n    for(int i = 0; i < *returnSize; i++)                        // Mem Alloc\\n        strings[i] = calloc(sizeof(char), ( maxWidth + 1 ) );   // Mem Alloc\\n\\n    char ** tail     = &words[0]; // Tail of Accumulated Words\\n    char ** head     = tail;      // Head of Accumulated Words\\n    char ** lastWord = &words[wordsSize-1];\\n    int len = strlen(*head);   // Init len with first word length value\\n\\n    for ( head; ; head++ )  // Iterate Each Word\\n    {\\n        if ( head == lastWord ) { // If Last Word - Justify Accumulated Words and Break\\n            lJust(tail, head - tail + 1, maxWidth, strings[currStr]);\\n            break;\\n        }\\n        \\n        const int  nextWordLen = strlen(*(head + 1));\\n        const int  nextLen     = len + 1 + nextWordLen; // Accumulate String length. +1 space \\n        const bool lenExceeded = nextLen > maxWidth;  \\n\\n        if ( lenExceeded ) {\\n            cJust(tail, head - tail + 1, maxWidth, maxWidth - len, strings[currStr++]); // Justify String\\n            tail = head + 1; // Set New Tail\\n        }\\n\\n        len  = lenExceeded ?  nextWordLen : nextLen;  // Accumulate Length or Reset\\n    }\\n    return strings;\\n}\\n\\n// -------------------------------------------------------------------------------------------------------\\n// -------------------------------------------------------------------------------------------------------\\n// -------------------------------------------------------------------------------------------------------\\n\\nint countStrings(char ** words, int wordsSize, int maxWidth)\\n{\\n    int counter = 0; // Strings Counter\\n    int len = strlen(words[0]); // Init Len With First Word Length Value\\n\\n    for (int i = 0; i < wordsSize; i++ )  // Iterate Each Word\\n    {\\n        bool isLastWord = ( i == wordsSize - 1 );\\n\\n        if ( isLastWord ) { // If Last Word - Increase Counter And Break\\n            ++counter;\\n            break;\\n        }\\n        int nextWordLen = strlen(words[i + 1]); // Get Next Word Length\\n        int nextLen = len + 1 + nextWordLen;    // Get Summary Length Including Next Word And Spaces Between\\n\\n        if (nextLen > maxWidth) { // If Length Oversized - Increase Counter\\n            ++counter;\\n        }\\n        len = nextLen > maxWidth ? nextWordLen : nextLen;  // Update Summary Length\\n    }\\n    return counter;\\n}\\n\\nvoid cJust(char ** words, int wordsSize, int maxWidth, int extraSpaces, char * jStr)\\n{\\n    int n = 0; // Index For jStr\\n    const int gaps = wordsSize == 1 ? 1 : wordsSize - 1; // Total Space Gaps\\n    int spaces = wordsSize-1 + extraSpaces; // Total Spaces To Insert\\n\\n    for( int i = 0; i<wordsSize; i++) // Iterate Each Word\\n    {\\n        while(*words[i]) {\\n            jStr[n++] = *(words[i]++); // Copy Aa Word To Result String\\n        }\\n        if ( n < maxWidth ) {            \\n            int nSp = spaces / ( gaps - i ) + ( spaces % ( gaps - i ) ? 1 : 0 ); // Calc Number Of Spaces To Insert\\n            spaces -= nSp;\\n            while(nSp--) { // Append Spaces After Word\\n                jStr[n++] = \\' \\';\\n            }\\n        }\\n    }\\n    jStr[n] =\\'\\\\0\\'; // Terminate String\\n}\\n\\nvoid lJust(char ** words, int wordsSize, int maxWidth, char * jStr)\\n{\\n    int n = 0;\\n    for (int i = 0; i < wordsSize; i++ )  // Iterate Each Word\\n    {\\n        bool isLastWord = ( i == wordsSize - 1 );\\n\\n        while(*words[i]) { // Copy Aa Word To Result String\\n            jStr[n++] = *(words[i]++);\\n        }\\n        if ( isLastWord ) { // Last Word - Break\\n            break;\\n        }\\n        jStr[n++] = \\' \\'; // +1 Space\\n    }\\n    while ( n < maxWidth ) { // Fill The End With Spaces\\n        jStr[n++] = \\' \\';\\n    }\\n    jStr[n] =\\'\\\\0\\'; // Terminate String\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1. cJust()        - Center justify\\n2. lJust()        - Left justify for last string\\n3. countStrings() - Strings counter for accurate mem alloc\\n```\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n\\nint countStrings(char ** words, int wordsSize, int maxWidth);\\nvoid cJust(char ** words, int wordsSize, int maxWidth, int extraSpaces, char * jStr);\\nvoid lJust(char ** words, int wordsSize, int maxWidth, char * jStr);\\n\\nchar ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize)\\n{\\n    *returnSize = countStrings(words, wordsSize, maxWidth);     // Get Number Of Justified Strings\\n    int currStr = 0;                                            // Current Result String Index\\n    const char **strings = calloc(sizeof(char *), *returnSize); // Mem Alloc\\n    for(int i = 0; i < *returnSize; i++)                        // Mem Alloc\\n        strings[i] = calloc(sizeof(char), ( maxWidth + 1 ) );   // Mem Alloc\\n\\n    char ** tail     = &words[0]; // Tail of Accumulated Words\\n    char ** head     = tail;      // Head of Accumulated Words\\n    char ** lastWord = &words[wordsSize-1];\\n    int len = strlen(*head);   // Init len with first word length value\\n\\n    for ( head; ; head++ )  // Iterate Each Word\\n    {\\n        if ( head == lastWord ) { // If Last Word - Justify Accumulated Words and Break\\n            lJust(tail, head - tail + 1, maxWidth, strings[currStr]);\\n            break;\\n        }\\n        \\n        const int  nextWordLen = strlen(*(head + 1));\\n        const int  nextLen     = len + 1 + nextWordLen; // Accumulate String length. +1 space \\n        const bool lenExceeded = nextLen > maxWidth;  \\n\\n        if ( lenExceeded ) {\\n            cJust(tail, head - tail + 1, maxWidth, maxWidth - len, strings[currStr++]); // Justify String\\n            tail = head + 1; // Set New Tail\\n        }\\n\\n        len  = lenExceeded ?  nextWordLen : nextLen;  // Accumulate Length or Reset\\n    }\\n    return strings;\\n}\\n\\n// -------------------------------------------------------------------------------------------------------\\n// -------------------------------------------------------------------------------------------------------\\n// -------------------------------------------------------------------------------------------------------\\n\\nint countStrings(char ** words, int wordsSize, int maxWidth)\\n{\\n    int counter = 0; // Strings Counter\\n    int len = strlen(words[0]); // Init Len With First Word Length Value\\n\\n    for (int i = 0; i < wordsSize; i++ )  // Iterate Each Word\\n    {\\n        bool isLastWord = ( i == wordsSize - 1 );\\n\\n        if ( isLastWord ) { // If Last Word - Increase Counter And Break\\n            ++counter;\\n            break;\\n        }\\n        int nextWordLen = strlen(words[i + 1]); // Get Next Word Length\\n        int nextLen = len + 1 + nextWordLen;    // Get Summary Length Including Next Word And Spaces Between\\n\\n        if (nextLen > maxWidth) { // If Length Oversized - Increase Counter\\n            ++counter;\\n        }\\n        len = nextLen > maxWidth ? nextWordLen : nextLen;  // Update Summary Length\\n    }\\n    return counter;\\n}\\n\\nvoid cJust(char ** words, int wordsSize, int maxWidth, int extraSpaces, char * jStr)\\n{\\n    int n = 0; // Index For jStr\\n    const int gaps = wordsSize == 1 ? 1 : wordsSize - 1; // Total Space Gaps\\n    int spaces = wordsSize-1 + extraSpaces; // Total Spaces To Insert\\n\\n    for( int i = 0; i<wordsSize; i++) // Iterate Each Word\\n    {\\n        while(*words[i]) {\\n            jStr[n++] = *(words[i]++); // Copy Aa Word To Result String\\n        }\\n        if ( n < maxWidth ) {            \\n            int nSp = spaces / ( gaps - i ) + ( spaces % ( gaps - i ) ? 1 : 0 ); // Calc Number Of Spaces To Insert\\n            spaces -= nSp;\\n            while(nSp--) { // Append Spaces After Word\\n                jStr[n++] = \\' \\';\\n            }\\n        }\\n    }\\n    jStr[n] =\\'\\\\0\\'; // Terminate String\\n}\\n\\nvoid lJust(char ** words, int wordsSize, int maxWidth, char * jStr)\\n{\\n    int n = 0;\\n    for (int i = 0; i < wordsSize; i++ )  // Iterate Each Word\\n    {\\n        bool isLastWord = ( i == wordsSize - 1 );\\n\\n        while(*words[i]) { // Copy Aa Word To Result String\\n            jStr[n++] = *(words[i]++);\\n        }\\n        if ( isLastWord ) { // Last Word - Break\\n            break;\\n        }\\n        jStr[n++] = \\' \\'; // +1 Space\\n    }\\n    while ( n < maxWidth ) { // Fill The End With Spaces\\n        jStr[n++] = \\' \\';\\n    }\\n    jStr[n] =\\'\\\\0\\'; // Terminate String\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3481581,
                "title": "c-100-fast-30-lines-comments-added",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<string> answer;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // Step 1: find out how many words can fit on line with one space between words\\n            int begin = i, lineSize = words[i].size();\\n            while (i + 1 < n && words[i + 1].size() + lineSize + 1 <= maxWidth) {\\n                lineSize += words[++i].size() + 1; // +1 for space between prev and cur words\\n            }\\n            \\n            // Step 2: determine space size (round-robin distribution)\\n            int numWords = i - begin + 1, spaceSize = 1, numExtraSpaces = 0;\\n            if (numWords > 1 && i < n - 1) { // if greater than one word in line and this isn\\'t the last line\\n                int remaining = maxWidth - lineSize;\\n                spaceSize = remaining / (numWords - 1) + 1; // +1 since lineSize already includes 1 space betweeen words\\n                numExtraSpaces = remaining % (numWords - 1);\\n            }\\n            \\n            // Step 3: create line\\n            string line = words[begin];\\n            for (int j = 1; j < numWords; ++j) {\\n                // add space between prev and cur words\\n                line.append(spaceSize, \\' \\');\\n                if (j <= numExtraSpaces) {\\n                    line.push_back(\\' \\');\\n                }\\n                line += words[begin + j];\\n            }\\n            if (line.size() < maxWidth) { // add right padding\\n                line.append(maxWidth - line.size(), \\' \\');\\n            }\\n            \\n            answer.emplace_back(line);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\\n\\n![upvote2.jpg](https://assets.leetcode.com/users/images/a531facd-2a18-429a-9d39-94d46cddaf4b_1689310705.582009.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<string> answer;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // Step 1: find out how many words can fit on line with one space between words\\n            int begin = i, lineSize = words[i].size();\\n            while (i + 1 < n && words[i + 1].size() + lineSize + 1 <= maxWidth) {\\n                lineSize += words[++i].size() + 1; // +1 for space between prev and cur words\\n            }\\n            \\n            // Step 2: determine space size (round-robin distribution)\\n            int numWords = i - begin + 1, spaceSize = 1, numExtraSpaces = 0;\\n            if (numWords > 1 && i < n - 1) { // if greater than one word in line and this isn\\'t the last line\\n                int remaining = maxWidth - lineSize;\\n                spaceSize = remaining / (numWords - 1) + 1; // +1 since lineSize already includes 1 space betweeen words\\n                numExtraSpaces = remaining % (numWords - 1);\\n            }\\n            \\n            // Step 3: create line\\n            string line = words[begin];\\n            for (int j = 1; j < numWords; ++j) {\\n                // add space between prev and cur words\\n                line.append(spaceSize, \\' \\');\\n                if (j <= numExtraSpaces) {\\n                    line.push_back(\\' \\');\\n                }\\n                line += words[begin + j];\\n            }\\n            if (line.size() < maxWidth) { // add right padding\\n                line.append(maxWidth - line.size(), \\' \\');\\n            }\\n            \\n            answer.emplace_back(line);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907088,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // step 1: find words that can fit this line\\n        // step 2: justify\\n        int start = 0, end = 0;\\n        vector<string> res;\\n        while (end < words.size()) {\\n            int len = 0, total = 0;\\n            while (end < words.size() && len + words[end].size() <= maxWidth) {\\n                len += words[end].size() + 1;\\n                total += words[end].size();\\n                ++end;\\n            }\\n            bool isLast = (end == words.size());\\n            res.push_back(justify(words, start, end, maxWidth - total, isLast));\\n            start = end;\\n        }\\n        return res;\\n    }\\n    \\n    string justify(const vector<string>& words, int start, int end, int space, bool isLast) {\\n        string line;\\n        if (!isLast) {\\n            // eg: \"Science  is  what we\" maxwidth = 20\\n            // characters: 7 + 2 + 4 + 2 = 15\\n            // left = 20 - 15 = 5\\n            // 5/3 => 5 % 3 != 0? => space 1 = 5/3 + 1 = 2\\n            // 3/2 -> 3 % 2 != 0? => space 2 = 3/2 + 1 = 2\\n            // 1 => space 3 = 1\\n\\t\\t\\tint count = end - start - 1;  // number of space slots = number of words - 1\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (count > 0) {\\n                    int cur = space % count != 0? space/count + 1: space/count;\\n                    line.insert(line.end(), cur, \\' \\');\\n                    space -= cur;\\n                    --count;\\n                }\\n            }\\n        } else {\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (space-- > 0) line.push_back(\\' \\');\\n            }\\n\\n        }\\n        if (space > 0) line.insert(line.end(), space, \\' \\');\\n        return line;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // step 1: find words that can fit this line\\n        // step 2: justify\\n        int start = 0, end = 0;\\n        vector<string> res;\\n        while (end < words.size()) {\\n            int len = 0, total = 0;\\n            while (end < words.size() && len + words[end].size() <= maxWidth) {\\n                len += words[end].size() + 1;\\n                total += words[end].size();\\n                ++end;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2853652,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.List;\\nimport java.util.ArrayList;\\n\\npublic class Solution {\\n\\n    private class LineData {\\n\\n        int startIndexWords;\\n        int endIndexWords;\\n        int textLength;\\n        int singleSapcesBetweenWordsLength;\\n\\n        LineData(int index, String[] words) {\\n            if (index < words.length) {\\n                startIndexWords = index;\\n                endIndexWords = index;\\n                textLength = words[index].length();\\n                singleSapcesBetweenWordsLength = 0;\\n            }\\n        }\\n    }\\n\\n    private static final int SINGLE_SPACE = 1;\\n    private LineData lineData;\\n    private int maxWidth;\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        this.maxWidth = maxWidth;\\n        lineData = new LineData(0, words);\\n        List<String> fullyJustifiedText = new ArrayList<>();\\n\\n        for (int i = 1; i < words.length; ++i) {\\n\\n            if (lineData.textLength + lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() < maxWidth) {\\n                lineData.textLength += words[i].length();\\n                ++lineData.singleSapcesBetweenWordsLength;\\n                ++lineData.endIndexWords;\\n                continue;\\n            }\\n            if (lineData.textLength + lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() == maxWidth) {\\n                lineData.textLength += words[i].length();\\n                ++lineData.singleSapcesBetweenWordsLength;\\n                ++lineData.endIndexWords;\\n\\n                createLine(fullyJustifiedText, words, false);\\n                lineData = new LineData(++i, words);\\n                continue;\\n            }\\n            createLine(fullyJustifiedText, words, false);\\n            lineData = new LineData(i, words);\\n        }\\n\\n        if (lineData.textLength > 0) {\\n            createLine(fullyJustifiedText, words, true);\\n        }\\n        return fullyJustifiedText;\\n    }\\n\\n    private void createLine(List<String> fullyJustifiedText, String[] words, boolean isLastLine) {\\n\\n        int totalSpaceInLine = maxWidth - lineData.textLength;\\n        int spaceBetweenWordsWithoutRemainder = 0;\\n        int totalSpaceRemainder = 0;\\n        int spaceAfterLastWordInLastLine = 0;\\n        int numberOfWords = lineData.endIndexWords - lineData.startIndexWords + 1;\\n\\n        if (!isLastLine) {\\n            spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? totalSpaceInLine / (numberOfWords - 1) : totalSpaceInLine;\\n            totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n        } else {\\n            spaceBetweenWordsWithoutRemainder = 1;\\n            spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n        }\\n\\n        StringBuilder line = new StringBuilder();\\n\\n        if (numberOfWords == 1 && !isLastLine) {\\n            line.append(words[lineData.startIndexWords]);\\n            appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n            fullyJustifiedText.add(line.toString());\\n            return;\\n        }\\n\\n        while (lineData.startIndexWords < lineData.endIndexWords) {\\n            line.append(words[lineData.startIndexWords]);\\n            int spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n            appendSpaceToLine(spaceBetweenWords, line);\\n            ++lineData.startIndexWords;\\n        }\\n        line.append(words[lineData.endIndexWords]);\\n        appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n        fullyJustifiedText.add(line.toString());\\n    }\\n\\n    private void appendSpaceToLine(int spacesToAppend, StringBuilder line) {\\n        while (spacesToAppend-- > 0) {\\n            line.append(\" \");\\n        }\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function (words, maxWidth) {\\n    const SINGLE_SPACE = 1;\\n    this.maxWidth = maxWidth;\\n    this.lineData = new LineData(0, words);\\n    const fullyJustifiedText = [];\\n\\n    for (let i = 1; i < words.length; ++i) {\\n\\n        if (this.lineData.textLength + this.lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length < maxWidth) {\\n            this.lineData.textLength += words[i].length;\\n            ++this.lineData.singleSapcesBetweenWordsLength;\\n            ++this.lineData.endIndexWords;\\n            continue;\\n        }\\n        if (this.lineData.textLength + this.lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length === maxWidth) {\\n            lineData.textLength += words[i].length;\\n            ++this.lineData.singleSapcesBetweenWordsLength;\\n            ++this.lineData.endIndexWords;\\n\\n            createLine(fullyJustifiedText, words, false);\\n            this.lineData = new LineData(++i, words);\\n            continue;\\n        }\\n        createLine(fullyJustifiedText, words, false);\\n        this.lineData = new LineData(i, words);\\n    }\\n\\n    if (this.lineData.textLength > 0) {\\n        createLine(fullyJustifiedText, words, true);\\n    }\\n    return fullyJustifiedText;\\n};\\n\\nclass LineData {\\n\\n    startIndexWords = 0;\\n    endIndexWords = 0;\\n    textLength = 0;\\n    singleSapcesBetweenWordsLength = 0;\\n\\n    /**\\n     * @param {number} index\\n     * @param {string[]} words\\n     */\\n    constructor(index, words) {\\n        if (index < words.length) {\\n            this.startIndexWords = index;\\n            this.endIndexWords = index;\\n            this.textLength = words[index].length;\\n            this.singleSapcesBetweenWordsLength = 0;\\n        }\\n    }\\n}\\n\\n/**\\n * @param {string[]} fullyJustifiedText\\n * @param {string[]} words \\n * @param {boolean} isLastLine\\n * @return {void}\\n */\\nfunction createLine(fullyJustifiedText, words, isLastLine) {\\n\\n    let totalSpaceInLine = this.maxWidth - this.lineData.textLength;\\n    let spaceBetweenWordsWithoutRemainder = 0;\\n    let totalSpaceRemainder = 0;\\n    let spaceAfterLastWordInLastLine = 0;\\n    let numberOfWords = this.lineData.endIndexWords - this.lineData.startIndexWords + 1;\\n\\n    if (!isLastLine) {\\n        spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? Math.floor(totalSpaceInLine / (numberOfWords - 1)) : totalSpaceInLine;\\n        totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n    } else {\\n        spaceBetweenWordsWithoutRemainder = 1;\\n        spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n    }\\n\\n    let line = [];\\n\\n    if (numberOfWords === 1 && !isLastLine) {\\n        line.push(words[this.lineData.startIndexWords]);\\n        appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n        fullyJustifiedText.push(line.join(\\'\\'));\\n        return;\\n    }\\n\\n    while (this.lineData.startIndexWords < this.lineData.endIndexWords) {\\n        line.push(words[this.lineData.startIndexWords]);\\n        let spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n        appendSpaceToLine(spaceBetweenWords, line);\\n        ++this.lineData.startIndexWords;\\n    }\\n    line.push(words[this.lineData.endIndexWords]);\\n    appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n    fullyJustifiedText.push(line.join(\\'\\'));\\n}\\n\\n/**\\n * @param {number} spacesToAppend\\n * @param {string[]} line \\n * @return {void}\\n */\\nfunction appendSpaceToLine(spacesToAppend, line) {\\n    while (spacesToAppend-- > 0) {\\n        line.push(\" \");\\n    }\\n}\\n```\\n**C++**\\n```\\n#include <string>\\n#include <memory>\\n#include <vector>\\nusing namespace std;\\n\\nstruct LineData {\\n    int startIndexWords = 0;\\n    int endIndexWords = 0;\\n    int textLength = 0;\\n    int singleSapcesBetweenWordsLength = 0;\\n\\n    LineData() = default;\\n\\n    LineData(int index, const vector<string>& words) {\\n        if (index < words.size()) {\\n            startIndexWords = index;\\n            endIndexWords = index;\\n            textLength = words[index].length();\\n            singleSapcesBetweenWordsLength = 0;\\n        }\\n    }\\n};\\n\\nclass Solution {\\n    \\n    inline static const int SINGLE_SPACE = 1;\\n    unique_ptr<LineData> lineData;\\n    size_t maxWidth;\\n\\npublic:\\n    vector<string> fullJustify(const vector<string>& words, int maxWidth) {\\n        this->maxWidth = maxWidth;\\n        lineData = make_unique<LineData>(0, words);\\n        vector<string> fullyJustifiedText;\\n\\n        for (int i = 1; i < words.size(); ++i) {\\n\\n            if (lineData->textLength + lineData->singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() < maxWidth) {\\n                lineData->textLength += words[i].length();\\n                ++lineData->singleSapcesBetweenWordsLength;\\n                ++lineData->endIndexWords;\\n                continue;\\n            }\\n            if (lineData->textLength + lineData->singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() == maxWidth) {\\n                lineData->textLength += words[i].length();\\n                ++lineData->singleSapcesBetweenWordsLength;\\n                ++lineData->endIndexWords;\\n\\n                createLine(fullyJustifiedText, words, false);\\n                lineData = make_unique<LineData>(++i, words);\\n                continue;\\n            }\\n            createLine(fullyJustifiedText, words, false);\\n            lineData = make_unique<LineData>(i, words);\\n        }\\n\\n        if (lineData->textLength > 0) {\\n            createLine(fullyJustifiedText, words, true);\\n        }\\n        return fullyJustifiedText;\\n    }\\n\\nprivate:\\n    void createLine(vector<string>& fullyJustifiedText, const vector<string>& words, bool isLastLine) const {\\n\\n        int totalSpaceInLine = maxWidth - lineData->textLength;\\n        int spaceBetweenWordsWithoutRemainder = 0;\\n        int totalSpaceRemainder = 0;\\n        int spaceAfterLastWordInLastLine = 0;\\n        int numberOfWords = lineData->endIndexWords - lineData->startIndexWords + 1;\\n\\n        if (!isLastLine) {\\n            spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? totalSpaceInLine / (numberOfWords - 1) : totalSpaceInLine;\\n            totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n        } else {\\n            spaceBetweenWordsWithoutRemainder = 1;\\n            spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n        }\\n\\n        string line;\\n\\n        if (numberOfWords == 1 && !isLastLine) {\\n            line.append(words[lineData->startIndexWords]);\\n            appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n            fullyJustifiedText.push_back(line);\\n            return;\\n        }\\n\\n        while (lineData->startIndexWords < lineData->endIndexWords) {\\n            line.append(words[lineData->startIndexWords]);\\n            int spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n            appendSpaceToLine(spaceBetweenWords, line);\\n            ++lineData->startIndexWords;\\n        }\\n        line.append(words[lineData->endIndexWords]);\\n        appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n        fullyJustifiedText.push_back(line);\\n    }\\n\\n    void appendSpaceToLine(int spacesToAppend, string& line) const {\\n        while (spacesToAppend-- > 0) {\\n            line.append(\" \");\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nimport java.util.List;\\nimport java.util.ArrayList;\\n\\npublic class Solution {\\n\\n    private class LineData {\\n\\n        int startIndexWords;\\n        int endIndexWords;\\n        int textLength;\\n        int singleSapcesBetweenWordsLength;\\n\\n        LineData(int index, String[] words) {\\n            if (index < words.length) {\\n                startIndexWords = index;\\n                endIndexWords = index;\\n                textLength = words[index].length();\\n                singleSapcesBetweenWordsLength = 0;\\n            }\\n        }\\n    }\\n\\n    private static final int SINGLE_SPACE = 1;\\n    private LineData lineData;\\n    private int maxWidth;\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        this.maxWidth = maxWidth;\\n        lineData = new LineData(0, words);\\n        List<String> fullyJustifiedText = new ArrayList<>();\\n\\n        for (int i = 1; i < words.length; ++i) {\\n\\n            if (lineData.textLength + lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() < maxWidth) {\\n                lineData.textLength += words[i].length();\\n                ++lineData.singleSapcesBetweenWordsLength;\\n                ++lineData.endIndexWords;\\n                continue;\\n            }\\n            if (lineData.textLength + lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() == maxWidth) {\\n                lineData.textLength += words[i].length();\\n                ++lineData.singleSapcesBetweenWordsLength;\\n                ++lineData.endIndexWords;\\n\\n                createLine(fullyJustifiedText, words, false);\\n                lineData = new LineData(++i, words);\\n                continue;\\n            }\\n            createLine(fullyJustifiedText, words, false);\\n            lineData = new LineData(i, words);\\n        }\\n\\n        if (lineData.textLength > 0) {\\n            createLine(fullyJustifiedText, words, true);\\n        }\\n        return fullyJustifiedText;\\n    }\\n\\n    private void createLine(List<String> fullyJustifiedText, String[] words, boolean isLastLine) {\\n\\n        int totalSpaceInLine = maxWidth - lineData.textLength;\\n        int spaceBetweenWordsWithoutRemainder = 0;\\n        int totalSpaceRemainder = 0;\\n        int spaceAfterLastWordInLastLine = 0;\\n        int numberOfWords = lineData.endIndexWords - lineData.startIndexWords + 1;\\n\\n        if (!isLastLine) {\\n            spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? totalSpaceInLine / (numberOfWords - 1) : totalSpaceInLine;\\n            totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n        } else {\\n            spaceBetweenWordsWithoutRemainder = 1;\\n            spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n        }\\n\\n        StringBuilder line = new StringBuilder();\\n\\n        if (numberOfWords == 1 && !isLastLine) {\\n            line.append(words[lineData.startIndexWords]);\\n            appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n            fullyJustifiedText.add(line.toString());\\n            return;\\n        }\\n\\n        while (lineData.startIndexWords < lineData.endIndexWords) {\\n            line.append(words[lineData.startIndexWords]);\\n            int spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n            appendSpaceToLine(spaceBetweenWords, line);\\n            ++lineData.startIndexWords;\\n        }\\n        line.append(words[lineData.endIndexWords]);\\n        appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n        fullyJustifiedText.add(line.toString());\\n    }\\n\\n    private void appendSpaceToLine(int spacesToAppend, StringBuilder line) {\\n        while (spacesToAppend-- > 0) {\\n            line.append(\" \");\\n        }\\n    }\\n}\\n```\n```\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function (words, maxWidth) {\\n    const SINGLE_SPACE = 1;\\n    this.maxWidth = maxWidth;\\n    this.lineData = new LineData(0, words);\\n    const fullyJustifiedText = [];\\n\\n    for (let i = 1; i < words.length; ++i) {\\n\\n        if (this.lineData.textLength + this.lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length < maxWidth) {\\n            this.lineData.textLength += words[i].length;\\n            ++this.lineData.singleSapcesBetweenWordsLength;\\n            ++this.lineData.endIndexWords;\\n            continue;\\n        }\\n        if (this.lineData.textLength + this.lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length === maxWidth) {\\n            lineData.textLength += words[i].length;\\n            ++this.lineData.singleSapcesBetweenWordsLength;\\n            ++this.lineData.endIndexWords;\\n\\n            createLine(fullyJustifiedText, words, false);\\n            this.lineData = new LineData(++i, words);\\n            continue;\\n        }\\n        createLine(fullyJustifiedText, words, false);\\n        this.lineData = new LineData(i, words);\\n    }\\n\\n    if (this.lineData.textLength > 0) {\\n        createLine(fullyJustifiedText, words, true);\\n    }\\n    return fullyJustifiedText;\\n};\\n\\nclass LineData {\\n\\n    startIndexWords = 0;\\n    endIndexWords = 0;\\n    textLength = 0;\\n    singleSapcesBetweenWordsLength = 0;\\n\\n    /**\\n     * @param {number} index\\n     * @param {string[]} words\\n     */\\n    constructor(index, words) {\\n        if (index < words.length) {\\n            this.startIndexWords = index;\\n            this.endIndexWords = index;\\n            this.textLength = words[index].length;\\n            this.singleSapcesBetweenWordsLength = 0;\\n        }\\n    }\\n}\\n\\n/**\\n * @param {string[]} fullyJustifiedText\\n * @param {string[]} words \\n * @param {boolean} isLastLine\\n * @return {void}\\n */\\nfunction createLine(fullyJustifiedText, words, isLastLine) {\\n\\n    let totalSpaceInLine = this.maxWidth - this.lineData.textLength;\\n    let spaceBetweenWordsWithoutRemainder = 0;\\n    let totalSpaceRemainder = 0;\\n    let spaceAfterLastWordInLastLine = 0;\\n    let numberOfWords = this.lineData.endIndexWords - this.lineData.startIndexWords + 1;\\n\\n    if (!isLastLine) {\\n        spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? Math.floor(totalSpaceInLine / (numberOfWords - 1)) : totalSpaceInLine;\\n        totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n    } else {\\n        spaceBetweenWordsWithoutRemainder = 1;\\n        spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n    }\\n\\n    let line = [];\\n\\n    if (numberOfWords === 1 && !isLastLine) {\\n        line.push(words[this.lineData.startIndexWords]);\\n        appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n        fullyJustifiedText.push(line.join(\\'\\'));\\n        return;\\n    }\\n\\n    while (this.lineData.startIndexWords < this.lineData.endIndexWords) {\\n        line.push(words[this.lineData.startIndexWords]);\\n        let spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n        appendSpaceToLine(spaceBetweenWords, line);\\n        ++this.lineData.startIndexWords;\\n    }\\n    line.push(words[this.lineData.endIndexWords]);\\n    appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n    fullyJustifiedText.push(line.join(\\'\\'));\\n}\\n\\n/**\\n * @param {number} spacesToAppend\\n * @param {string[]} line \\n * @return {void}\\n */\\nfunction appendSpaceToLine(spacesToAppend, line) {\\n    while (spacesToAppend-- > 0) {\\n        line.push(\" \");\\n    }\\n}\\n```\n```\\n#include <string>\\n#include <memory>\\n#include <vector>\\nusing namespace std;\\n\\nstruct LineData {\\n    int startIndexWords = 0;\\n    int endIndexWords = 0;\\n    int textLength = 0;\\n    int singleSapcesBetweenWordsLength = 0;\\n\\n    LineData() = default;\\n\\n    LineData(int index, const vector<string>& words) {\\n        if (index < words.size()) {\\n            startIndexWords = index;\\n            endIndexWords = index;\\n            textLength = words[index].length();\\n            singleSapcesBetweenWordsLength = 0;\\n        }\\n    }\\n};\\n\\nclass Solution {\\n    \\n    inline static const int SINGLE_SPACE = 1;\\n    unique_ptr<LineData> lineData;\\n    size_t maxWidth;\\n\\npublic:\\n    vector<string> fullJustify(const vector<string>& words, int maxWidth) {\\n        this->maxWidth = maxWidth;\\n        lineData = make_unique<LineData>(0, words);\\n        vector<string> fullyJustifiedText;\\n\\n        for (int i = 1; i < words.size(); ++i) {\\n\\n            if (lineData->textLength + lineData->singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() < maxWidth) {\\n                lineData->textLength += words[i].length();\\n                ++lineData->singleSapcesBetweenWordsLength;\\n                ++lineData->endIndexWords;\\n                continue;\\n            }\\n            if (lineData->textLength + lineData->singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() == maxWidth) {\\n                lineData->textLength += words[i].length();\\n                ++lineData->singleSapcesBetweenWordsLength;\\n                ++lineData->endIndexWords;\\n\\n                createLine(fullyJustifiedText, words, false);\\n                lineData = make_unique<LineData>(++i, words);\\n                continue;\\n            }\\n            createLine(fullyJustifiedText, words, false);\\n            lineData = make_unique<LineData>(i, words);\\n        }\\n\\n        if (lineData->textLength > 0) {\\n            createLine(fullyJustifiedText, words, true);\\n        }\\n        return fullyJustifiedText;\\n    }\\n\\nprivate:\\n    void createLine(vector<string>& fullyJustifiedText, const vector<string>& words, bool isLastLine) const {\\n\\n        int totalSpaceInLine = maxWidth - lineData->textLength;\\n        int spaceBetweenWordsWithoutRemainder = 0;\\n        int totalSpaceRemainder = 0;\\n        int spaceAfterLastWordInLastLine = 0;\\n        int numberOfWords = lineData->endIndexWords - lineData->startIndexWords + 1;\\n\\n        if (!isLastLine) {\\n            spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? totalSpaceInLine / (numberOfWords - 1) : totalSpaceInLine;\\n            totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n        } else {\\n            spaceBetweenWordsWithoutRemainder = 1;\\n            spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n        }\\n\\n        string line;\\n\\n        if (numberOfWords == 1 && !isLastLine) {\\n            line.append(words[lineData->startIndexWords]);\\n            appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n            fullyJustifiedText.push_back(line);\\n            return;\\n        }\\n\\n        while (lineData->startIndexWords < lineData->endIndexWords) {\\n            line.append(words[lineData->startIndexWords]);\\n            int spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n            appendSpaceToLine(spaceBetweenWords, line);\\n            ++lineData->startIndexWords;\\n        }\\n        line.append(words[lineData->endIndexWords]);\\n        appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n        fullyJustifiedText.push_back(line);\\n    }\\n\\n    void appendSpaceToLine(int spacesToAppend, string& line) const {\\n        while (spacesToAppend-- > 0) {\\n            line.append(\" \");\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2526012,
                "title": "c-fast-and-brief-solution-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> output;\\n        for (int i = 0, j;i < words.size();) {\\n            int len = -1; // remove the first space\\n            for (j = i;j < words.size() && len + words[j].length() + 1 <= maxWidth;j++) {\\n                len += (words[j].length() + 1); // add the space and the word\\n            }\\n            string line = words[i++]; // get the first word\\n            int num_words = j - i; // number of words\\n            int num_space = maxWidth - len; // number of spaces (exclude the single space above)\\n            int extra = (num_words > 0) ? num_space%num_words : 0; // extra spaces\\n            for (;i < j;i++) {\\n                int space = (j == words.size()) ? 0 : // if last line, no space needed\\n                    (num_space/num_words + (extra-- > 0)); // else append average, then the extra\\n                line += string(space+1, \\' \\') + words[i];\\n            }\\n            line += string(maxWidth - line.length(), \\' \\'); // add the remaining\\n            output.push_back(line);\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> output;\\n        for (int i = 0, j;i < words.size();) {\\n            int len = -1; // remove the first space\\n            for (j = i;j < words.size() && len + words[j].length() + 1 <= maxWidth;j++) {\\n                len += (words[j].length() + 1); // add the space and the word\\n            }\\n            string line = words[i++]; // get the first word\\n            int num_words = j - i; // number of words\\n            int num_space = maxWidth - len; // number of spaces (exclude the single space above)\\n            int extra = (num_words > 0) ? num_space%num_words : 0; // extra spaces\\n            for (;i < j;i++) {\\n                int space = (j == words.size()) ? 0 : // if last line, no space needed\\n                    (num_space/num_words + (extra-- > 0)); // else append average, then the extra\\n                line += string(space+1, \\' \\') + words[i];\\n            }\\n            line += string(maxWidth - line.length(), \\' \\'); // add the remaining\\n            output.push_back(line);\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468109,
                "title": "easy-to-understand-python-solution-by-intution",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # Initilize three varaibles as we form line-by-line\\n        current_line_length = 0\\n        current_line_words = []\\n        ans = []\\n        for word in words: #-----> O(n)\\n            word_length = len(word)\\n            \"\"\"For each word, we consider the space after that word also\\n                We check if current line length exceeds the maxiWidth if this word is added or not\"\"\"\\n            if current_line_length+word_length+1 <= maxWidth or (current_line_length+word_length == maxWidth):\\n                \"\"\"\\n                Append the word to current line words\\n                \"\"\"\\n                current_line_words.append(word)\\n                current_line_length += word_length+1\\n            else:\\n                if len(current_line_words) == 1:\\n                    \"\"\"\\n                    If there is only word for this line, that word should be left-justified\\n                    \"\"\"\\n                    characters = len(current_line_words[0])\\n                    spaces = maxWidth-characters\\n                    ans.append(\"\".join(current_line_words+([\\' \\']*spaces)))\\n                else:\\n                    \"\"\"\\n                    If there are multiple words for this line\\n                    \"\"\"\\n                    characters = current_line_length-len(current_line_words)\\n                    spaces = maxWidth-characters\\n                    distribution_spaces = spaces//(len(current_line_words)-1)\\n                    if not spaces%(len(current_line_words)-1):\\n                        \"\"\"\\n                        If the spaces divide evenly between words\\n                        \"\"\"\\n                        spaces = \"\".join([\\' \\']*distribution_spaces)\\n                        ans.append(spaces.join(current_line_words))\\n                    else:\\n                        \"\"\"\\n                        If spaces does not divide evenly with words\\n                        \"\"\"\\n                        extras = spaces%(len(current_line_words)-1)\\n                        temp = \"\"\\n                        for i in range(len(current_line_words)-1):\\n                            temp += current_line_words[i]\\n                            if extras:\\n                                temp += \"\".join(([\\' \\']*distribution_spaces)+[\\' \\'])\\n                                extras -= 1\\n                            else:\\n                                temp += \"\".join(([\\' \\'] * distribution_spaces))\\n                        temp += current_line_words[-1]\\n                        ans.append(temp)\\n                \"\"\"\\n                This is the last line and should be justified evenly\\n                \"\"\"\\n                current_line_length = len(word)+1\\n                current_line_words.clear()\\n                current_line_words.append(word)\\n        temp = \" \".join(current_line_words)\\n        temp += \"\".join([\\' \\']*(maxWidth-len(temp)))\\n        ans.append(temp)\\n        return ans\\n```\\n\\nPlease vote this solution if you feel its helpful",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # Initilize three varaibles as we form line-by-line\\n        current_line_length = 0\\n        current_line_words = []\\n        ans = []\\n        for word in words: #-----> O(n)\\n            word_length = len(word)\\n            \"\"\"For each word, we consider the space after that word also\\n                We check if current line length exceeds the maxiWidth if this word is added or not\"\"\"\\n            if current_line_length+word_length+1 <= maxWidth or (current_line_length+word_length == maxWidth):\\n                \"\"\"\\n                Append the word to current line words\\n                \"\"\"\\n                current_line_words.append(word)\\n                current_line_length += word_length+1\\n            else:\\n                if len(current_line_words) == 1:\\n                    \"\"\"\\n                    If there is only word for this line, that word should be left-justified\\n                    \"\"\"\\n                    characters = len(current_line_words[0])\\n                    spaces = maxWidth-characters\\n                    ans.append(\"\".join(current_line_words+([\\' \\']*spaces)))\\n                else:\\n                    \"\"\"\\n                    If there are multiple words for this line\\n                    \"\"\"\\n                    characters = current_line_length-len(current_line_words)\\n                    spaces = maxWidth-characters\\n                    distribution_spaces = spaces//(len(current_line_words)-1)\\n                    if not spaces%(len(current_line_words)-1):\\n                        \"\"\"\\n                        If the spaces divide evenly between words\\n                        \"\"\"\\n                        spaces = \"\".join([\\' \\']*distribution_spaces)\\n                        ans.append(spaces.join(current_line_words))\\n                    else:\\n                        \"\"\"\\n                        If spaces does not divide evenly with words\\n                        \"\"\"\\n                        extras = spaces%(len(current_line_words)-1)\\n                        temp = \"\"\\n                        for i in range(len(current_line_words)-1):\\n                            temp += current_line_words[i]\\n                            if extras:\\n                                temp += \"\".join(([\\' \\']*distribution_spaces)+[\\' \\'])\\n                                extras -= 1\\n                            else:\\n                                temp += \"\".join(([\\' \\'] * distribution_spaces))\\n                        temp += current_line_words[-1]\\n                        ans.append(temp)\\n                \"\"\"\\n                This is the last line and should be justified evenly\\n                \"\"\"\\n                current_line_length = len(word)+1\\n                current_line_words.clear()\\n                current_line_words.append(word)\\n        temp = \" \".join(current_line_words)\\n        temp += \"\".join([\\' \\']*(maxWidth-len(temp)))\\n        ans.append(temp)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392508,
                "title": "easy-understanding-java-solution",
                "content": "to further understand, please check the below link\\nhttps://www.youtube.com/watch?v=GqXlEbFVTXY\\n\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result=new ArrayList<>();\\n        int i=0, n=words.length;\\n        while(i<n) {\\n            int j=i+1;\\n            int lineLength=words[i].length();\\n            while(j<n && (lineLength+words[j].length()+(j-i-1)<maxWidth)) {\\n                lineLength+=words[j].length();\\n                j++;\\n            }\\n            int diff=maxWidth-lineLength;\\n            int noOfWords=j-i;\\n            if(noOfWords==1 || j>=n)\\n                result.add(leftJustify(words,diff,i,j));\\n            else\\n                result.add(middleJustify(words,diff,i,j));\\n            i=j;\\n        }\\n        return result;\\n    }\\n    private String leftJustify(String[] words, int diff, int i, int j) {\\n        StringBuilder sb=new StringBuilder(words[i]);\\n        int spacesOnRight=diff-(j-i-1);\\n        for(int k=i+1;k<j;k++) {\\n            sb.append(\" \"+words[k]);\\n        }\\n        sb.append(\" \".repeat(spacesOnRight));\\n        return sb.toString();\\n    }\\n    private String middleJustify(String[] words, int diff, int i, int j) {\\n        StringBuilder sb=new StringBuilder(words[i]);\\n        int spacesNeeded=j-i-1;\\n        int spaces=diff/spacesNeeded;\\n        int extraSpaces=diff%spacesNeeded;\\n        for(int k=i+1;k<j;k++) {\\n            int spacesToApply=spaces+(extraSpaces-->0?1:0);\\n            sb.append(\" \".repeat(spacesToApply)+words[k]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result=new ArrayList<>();\\n        int i=0, n=words.length;\\n        while(i<n) {\\n            int j=i+1;\\n            int lineLength=words[i].length();\\n            while(j<n && (lineLength+words[j].length()+(j-i-1)<maxWidth)) {\\n                lineLength+=words[j].length();\\n                j++;\\n            }\\n            int diff=maxWidth-lineLength;\\n            int noOfWords=j-i;\\n            if(noOfWords==1 || j>=n)\\n                result.add(leftJustify(words,diff,i,j));\\n            else\\n                result.add(middleJustify(words,diff,i,j));\\n            i=j;\\n        }\\n        return result;\\n    }\\n    private String leftJustify(String[] words, int diff, int i, int j) {\\n        StringBuilder sb=new StringBuilder(words[i]);\\n        int spacesOnRight=diff-(j-i-1);\\n        for(int k=i+1;k<j;k++) {\\n            sb.append(\" \"+words[k]);\\n        }\\n        sb.append(\" \".repeat(spacesOnRight));\\n        return sb.toString();\\n    }\\n    private String middleJustify(String[] words, int diff, int i, int j) {\\n        StringBuilder sb=new StringBuilder(words[i]);\\n        int spacesNeeded=j-i-1;\\n        int spaces=diff/spacesNeeded;\\n        int extraSpaces=diff%spacesNeeded;\\n        for(int k=i+1;k<j;k++) {\\n            int spacesToApply=spaces+(extraSpaces-->0?1:0);\\n            sb.append(\" \".repeat(spacesToApply)+words[k]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376795,
                "title": "simple-js-solution-w-comments",
                "content": "```\\n/**\\n * *Time: O(N^2)\\n * *Space: O(N)\\n */\\n// Runtime: 89 ms, faster than 45.91% of JavaScript online submissions for Text Justification.\\n// Memory Usage: 42 MB, less than 58.01% of JavaScript online submissions for Text Justification.\\nconst fullJustify = (words, maxWidth) => {\\n\\tconst justifyLine = (line, width) => {\\n\\t\\t// if single word, it\\'s left justified, add spaces to the end\\n\\t\\tif (line.length === 1) {\\n\\t\\t\\tlet word = line[0];\\n\\n\\t\\t\\tword += \\' \\'.repeat(width);\\n\\t\\t\\treturn word;\\n\\n\\t\\t}\\n\\n\\t\\tconst end = line.length - 1; // all words except the last word should have spaced added to their string\\n\\t\\tlet i = 0;\\n\\n\\t\\t// distribute spaces evenly among the words\\n\\t\\twhile (width-- > 0) {\\n\\t\\t\\tline[i++] += \\' \\';\\n\\t\\t\\ti = i % end; // loop back to start to avoid adding space to the final word\\n\\t\\t}\\n\\n\\t\\treturn line.join(\\'\\');\\n\\t};\\n\\n\\tconst output = [];\\n\\tlet line = [];\\n\\tlet width = maxWidth; // spaces left\\n\\n\\t// greedily add words to each line\\n\\t// when current word cannot be added\\n\\t// justify and add current line and start a new line\\n\\tfor (const word of words) {\\n\\t\\t// if word fits: add word and update spaces left\\n\\t\\tif (word.length <= width - line.length) {\\n\\t\\t\\tline.push(word); // word fits: add word to current line\\n\\t\\t\\twidth -= word.length; // subtract length of current word and update spaces left\\n\\t\\t} else {\\n\\t\\t\\t// not enough spaces, word does not fit: justify current line and add to output\\n\\t\\t\\tconst justified = justifyLine(line, width);\\n\\n\\t\\t\\toutput.push(justified); // add justified line to output\\n\\t\\t\\tline = [word]; // start a new line with current word\\n\\t\\t\\twidth = maxWidth - word.length; // reset current line width\\n\\t\\t}\\n\\t}\\n\\n\\t// handle last line: justify words to the left and add spaces to the right\\n\\tif (line.length) {\\n\\t\\tlet lastLine = line.join(\\' \\'); // convert last line into string\\n\\t\\tconst spacesLeft = maxWidth - lastLine.length; // spaces left for last line\\n\\n\\t\\tlastLine += \\' \\'.repeat(spacesLeft);\\n\\t\\toutput.push(lastLine);\\n\\t}\\n\\n\\treturn output;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * *Time: O(N^2)\\n * *Space: O(N)\\n */\\n// Runtime: 89 ms, faster than 45.91% of JavaScript online submissions for Text Justification.\\n// Memory Usage: 42 MB, less than 58.01% of JavaScript online submissions for Text Justification.\\nconst fullJustify = (words, maxWidth) => {\\n\\tconst justifyLine = (line, width) => {\\n\\t\\t// if single word, it\\'s left justified, add spaces to the end\\n\\t\\tif (line.length === 1) {\\n\\t\\t\\tlet word = line[0];\\n\\n\\t\\t\\tword += \\' \\'.repeat(width);\\n\\t\\t\\treturn word;\\n\\n\\t\\t}\\n\\n\\t\\tconst end = line.length - 1; // all words except the last word should have spaced added to their string\\n\\t\\tlet i = 0;\\n\\n\\t\\t// distribute spaces evenly among the words\\n\\t\\twhile (width-- > 0) {\\n\\t\\t\\tline[i++] += \\' \\';\\n\\t\\t\\ti = i % end; // loop back to start to avoid adding space to the final word\\n\\t\\t}\\n\\n\\t\\treturn line.join(\\'\\');\\n\\t};\\n\\n\\tconst output = [];\\n\\tlet line = [];\\n\\tlet width = maxWidth; // spaces left\\n\\n\\t// greedily add words to each line\\n\\t// when current word cannot be added\\n\\t// justify and add current line and start a new line\\n\\tfor (const word of words) {\\n\\t\\t// if word fits: add word and update spaces left\\n\\t\\tif (word.length <= width - line.length) {\\n\\t\\t\\tline.push(word); // word fits: add word to current line\\n\\t\\t\\twidth -= word.length; // subtract length of current word and update spaces left\\n\\t\\t} else {\\n\\t\\t\\t// not enough spaces, word does not fit: justify current line and add to output\\n\\t\\t\\tconst justified = justifyLine(line, width);\\n\\n\\t\\t\\toutput.push(justified); // add justified line to output\\n\\t\\t\\tline = [word]; // start a new line with current word\\n\\t\\t\\twidth = maxWidth - word.length; // reset current line width\\n\\t\\t}\\n\\t}\\n\\n\\t// handle last line: justify words to the left and add spaces to the right\\n\\tif (line.length) {\\n\\t\\tlet lastLine = line.join(\\' \\'); // convert last line into string\\n\\t\\tconst spacesLeft = maxWidth - lastLine.length; // spaces left for last line\\n\\n\\t\\tlastLine += \\' \\'.repeat(spacesLeft);\\n\\t\\toutput.push(lastLine);\\n\\t}\\n\\n\\treturn output;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2252192,
                "title": "simple-java-solution-0ms",
                "content": "\\n\\n\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {        \\n        List<String> result = new ArrayList<>();\\n        int nextWordIndex = 0;\\n        while(nextWordIndex < words.length){\\n            int endIndex = wordsAllowed(words, nextWordIndex, maxWidth);\\n            result.add(createLine(words, nextWordIndex, endIndex, maxWidth));\\n            nextWordIndex = endIndex + 1;\\n        }\\n        return result;        \\n    }\\n        \\n    \\n    private int wordsAllowed(String[] words, int startIndex, int maxWidth){\\n        int spaceLeft = maxWidth;\\n        int endIndex = startIndex;\\n        spaceLeft -= words[endIndex].length();\\n        \\n        while(endIndex+1 < words.length && spaceLeft >= 1 + words[endIndex+1].length() ) {\\n            spaceLeft -= 1 + words[endIndex+1].length();\\n            endIndex++;\\n        }\\n        return endIndex;        \\n    }\\n    \\n    \\n    private String createLine(String[] words, int startIndex, int endIndex, int maxWidth){\\n        StringBuilder sb = new StringBuilder(maxWidth);        \\n        \\n        // Last Line or a single word line\\n        if (endIndex == words.length-1 || endIndex == startIndex) {\\n            for(int i = startIndex; i < endIndex ; i++){\\n                sb.append(words[i]);\\n                sb.append(\\' \\');\\n            }\\n            sb.append(words[endIndex]);\\n            for(int i = sb.length() + 1; i <= maxWidth; i++) sb.append(\\' \\');\\n        }\\n                \\n        else{\\n            int spaceSlots = endIndex - startIndex;\\n            int totalSpacesRequired = maxWidth;\\n            \\n            for(int i =startIndex; i<= endIndex; i++){\\n                totalSpacesRequired -= words[i].length();\\n            }\\n           \\n            String commonSpace = \" \".repeat(totalSpacesRequired / spaceSlots);\\n            int remainder = totalSpacesRequired % spaceSlots;\\n            \\n            int nextSpaceSlot = 1;\\n            for(int i = startIndex; i< endIndex; i++){\\n                sb.append(words[i]);\\n                sb.append(commonSpace);\\n                if (nextSpaceSlot++<= remainder) sb.append(\\' \\');               \\n            }   \\n            sb.append(words[endIndex]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {        \\n        List<String> result = new ArrayList<>();\\n        int nextWordIndex = 0;\\n        while(nextWordIndex < words.length){\\n            int endIndex = wordsAllowed(words, nextWordIndex, maxWidth);\\n            result.add(createLine(words, nextWordIndex, endIndex, maxWidth));\\n            nextWordIndex = endIndex + 1;\\n        }\\n        return result;        \\n    }\\n        \\n    \\n    private int wordsAllowed(String[] words, int startIndex, int maxWidth){\\n        int spaceLeft = maxWidth;\\n        int endIndex = startIndex;\\n        spaceLeft -= words[endIndex].length();\\n        \\n        while(endIndex+1 < words.length && spaceLeft >= 1 + words[endIndex+1].length() ) {\\n            spaceLeft -= 1 + words[endIndex+1].length();\\n            endIndex++;\\n        }\\n        return endIndex;        \\n    }\\n    \\n    \\n    private String createLine(String[] words, int startIndex, int endIndex, int maxWidth){\\n        StringBuilder sb = new StringBuilder(maxWidth);        \\n        \\n        // Last Line or a single word line\\n        if (endIndex == words.length-1 || endIndex == startIndex) {\\n            for(int i = startIndex; i < endIndex ; i++){\\n                sb.append(words[i]);\\n                sb.append(\\' \\');\\n            }\\n            sb.append(words[endIndex]);\\n            for(int i = sb.length() + 1; i <= maxWidth; i++) sb.append(\\' \\');\\n        }\\n                \\n        else{\\n            int spaceSlots = endIndex - startIndex;\\n            int totalSpacesRequired = maxWidth;\\n            \\n            for(int i =startIndex; i<= endIndex; i++){\\n                totalSpacesRequired -= words[i].length();\\n            }\\n           \\n            String commonSpace = \" \".repeat(totalSpacesRequired / spaceSlots);\\n            int remainder = totalSpacesRequired % spaceSlots;\\n            \\n            int nextSpaceSlot = 1;\\n            for(int i = startIndex; i< endIndex; i++){\\n                sb.append(words[i]);\\n                sb.append(commonSpace);\\n                if (nextSpaceSlot++<= remainder) sb.append(\\' \\');               \\n            }   \\n            sb.append(words[endIndex]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249331,
                "title": "0ms-with-detailed-comments",
                "content": "```\\nclass Solution {\\n  \\n  public List<String> fullJustify(String[] words, int maxLen) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> tempList = new ArrayList<>();  //to store the words that can be put in one same line\\n        int tempLen = 0;     // track the length of current line: wordsLen + spaces between words\\n        int index = 0;       // index of word in words array\\n        int wordsLen = 0;    // sum of all words that can be put in same line\\n        int spaces = 0;      // spaces that need to be filled\\n        \\n        while (index < words.length) { // check if the index is less than the length ...\\n            if ((tempLen + words[index].length()) <= maxLen) { // making sure that the current temp len is less than \\n                // max length ... so keep adding words as long as the length is less than max length ...\\n                // and this is the greedy algorithm ...\\n                tempLen += words[index].length() + 1; // increase the temp length by adding the current word ...\\n                tempList.add(words[index++]); // increase the index post addition to the temp list ...\\n            } else {\\n                StringBuilder sb = new StringBuilder();\\n                wordsLen = tempLen - tempList.size(); // temp length has the additional +1\\'s ... line 15 ...\\n                spaces = maxLen - wordsLen; // so this is the total number of spaces ... i.e., maxlen <minus> word len ...\\n                if(tempList.size() == 1) { // there\\'s only one word at cur line, then just fill the spaces\\n                    sb.append(tempList.get(0)); // add the first and only word ...\\n                    for(int i = 0; i < spaces; i++) { // fill the rest with spaces ...\\n                        sb.append(\" \"); // append with spaces ...\\n                    }\\n                    ans.add(sb.toString()); // add this string to the final answer\\n                } else if (tempList.size() > 1) { // there\\'s many words in cur line, do the evenly spaceing\\n                    \\n                    // you see tempList - 1 because ... lets say, you have 3 words\\n                    // w1 space1 w2 space2 w3\\n                    // as you can see ... spaces will be 1 less than the words ...\\n                    // \\n                    int distance = spaces / (tempList.size() - 1);\\n                    int reminder = spaces % (tempList.size() - 1);\\n                    \\n                    for(int i = 0; i < tempList.size() - 1; i++) { // if 3 words ...\\n                        // you are only going up to 2 ... and adding the last in line 48 ...\\n                        sb.append(tempList.get(i));\\n                        if(reminder > 0){ // here we are adding the extra spaces\\n                            // because the question says \\n                            // If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\\n                            sb.append(\" \");\\n                            reminder--;\\n                        }\\n                        for(int j = 0; j < distance; j++)\\n                            sb.append(\" \"); // and here we are adding the spaces ...\\n                    }\\n                    sb.append(tempList.get(tempList.size() - 1)); // line 48, adding the last word ...\\n                    ans.add(sb.toString());   \\n                }\\n                tempList.clear(); // clear the temp list ...\\n                tempLen = 0; // set the temp length back to 0 ...\\n            }\\n        }\\n        \\n        // dealing with last line\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < tempList.size() - 1; i++) { // the -1 is because ... we want to keep that last space ...\\n            sb.append(tempList.get(i));\\n            sb.append(\" \");\\n        }\\n        sb.append(tempList.get(tempList.size() - 1));\\n        for(int i = 0; i < maxLen - (tempLen - 1); i++) {\\n          sb.append(\" \");          \\n        }\\n\\n        ans.add(sb.toString());\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  \\n  public List<String> fullJustify(String[] words, int maxLen) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> tempList = new ArrayList<>();  //to store the words that can be put in one same line\\n        int tempLen = 0;     // track the length of current line: wordsLen + spaces between words\\n        int index = 0;       // index of word in words array\\n        int wordsLen = 0;    // sum of all words that can be put in same line\\n        int spaces = 0;      // spaces that need to be filled\\n        \\n        while (index < words.length) { // check if the index is less than the length ...\\n            if ((tempLen + words[index].length()) <= maxLen) { // making sure that the current temp len is less than \\n                // max length ... so keep adding words as long as the length is less than max length ...\\n                // and this is the greedy algorithm ...\\n                tempLen += words[index].length() + 1; // increase the temp length by adding the current word ...\\n                tempList.add(words[index++]); // increase the index post addition to the temp list ...\\n            } else {\\n                StringBuilder sb = new StringBuilder();\\n                wordsLen = tempLen - tempList.size(); // temp length has the additional +1\\'s ... line 15 ...\\n                spaces = maxLen - wordsLen; // so this is the total number of spaces ... i.e., maxlen <minus> word len ...\\n                if(tempList.size() == 1) { // there\\'s only one word at cur line, then just fill the spaces\\n                    sb.append(tempList.get(0)); // add the first and only word ...\\n                    for(int i = 0; i < spaces; i++) { // fill the rest with spaces ...\\n                        sb.append(\" \"); // append with spaces ...\\n                    }\\n                    ans.add(sb.toString()); // add this string to the final answer\\n                } else if (tempList.size() > 1) { // there\\'s many words in cur line, do the evenly spaceing\\n                    \\n                    // you see tempList - 1 because ... lets say, you have 3 words\\n                    // w1 space1 w2 space2 w3\\n                    // as you can see ... spaces will be 1 less than the words ...\\n                    // \\n                    int distance = spaces / (tempList.size() - 1);\\n                    int reminder = spaces % (tempList.size() - 1);\\n                    \\n                    for(int i = 0; i < tempList.size() - 1; i++) { // if 3 words ...\\n                        // you are only going up to 2 ... and adding the last in line 48 ...\\n                        sb.append(tempList.get(i));\\n                        if(reminder > 0){ // here we are adding the extra spaces\\n                            // because the question says \\n                            // If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\\n                            sb.append(\" \");\\n                            reminder--;\\n                        }\\n                        for(int j = 0; j < distance; j++)\\n                            sb.append(\" \"); // and here we are adding the spaces ...\\n                    }\\n                    sb.append(tempList.get(tempList.size() - 1)); // line 48, adding the last word ...\\n                    ans.add(sb.toString());   \\n                }\\n                tempList.clear(); // clear the temp list ...\\n                tempLen = 0; // set the temp length back to 0 ...\\n            }\\n        }\\n        \\n        // dealing with last line\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < tempList.size() - 1; i++) { // the -1 is because ... we want to keep that last space ...\\n            sb.append(tempList.get(i));\\n            sb.append(\" \");\\n        }\\n        sb.append(tempList.get(tempList.size() - 1));\\n        for(int i = 0; i < maxLen - (tempLen - 1); i++) {\\n          sb.append(\" \");          \\n        }\\n\\n        ans.add(sb.toString());\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125624,
                "title": "c-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    //\\u5F88\\u6076\\u5FC3\\u7684\\u4E00\\u9053\\u9898\\u76EE\\uFF0C\\u5B9E\\u73B0\\u633A\\u96BE\\n    //\\u4E3B\\u8981\\u662F3\\u70B9\\n    //1. \\u9700\\u8981\\u5BF9\\u6BCF\\u4E2A\\u5355\\u8BCD\\u4E2D\\u95F4\\u586B\\u4E0A\\u975E\\u5E38\\u5E73\\u5747\\u7684\\u7A7A\\u683C\\uFF0C\\u8FD9\\u4E2A\\u7528line[i % (gaps)].Append(\" \");\\u6765\\u89E3\\u51B3\\uFF0C\\u8FD9\\u91CC\\u7528line.Count-1\\u6765\\u5F97\\u5230\\u5355\\u8BCD\\u4E4B\\u95F4\\u7684gaps\\u9700\\u8981\\u591A\\u5C11,\\u7136\\u540E\\u901A\\u8FC7\\u4F59\\u6570\\u6765\\u6765\\u56DE\\u7ED9\\u5355\\u8BCD\\u4E2D\\u95F4\\u52A0\\u4E0A\\u5E73\\u5747\\u7684\\u7A7A\\u683C\\n    //Ex This_is_an_ _ _\\n    //   \\u4E0A\\u9762\\u8FD9\\u4E2A\\u4F8B\\u5B50\\u6211\\u4EEC\\u53EF\\u4EE5\\u770B\\u5230\\u4E00\\u4E2Aline\\u4E0A\\u603B\\u5171\\u67093\\u4E2A\\u5355\\u8BCD\\u7136\\u540E\\u9700\\u89812\\u4E2Agaps,\\u5982\\u4F55\\u628A\\u8FD9\\u4E9Bgap\\u5747\\u5300\\u5206\\u914D\\u7A7A\\u683C\\u5462\\uFF0C\\u90A3\\u5C31\\u662Fline[i%gaps].Append(\" \")\\n    //2. \\u5F53\\u524D\\u6240\\u6709\\u5355\\u8BCD\\u7684\\u957F\\u5EA6\\u52A0\\u4E0A\\u65B0\\u5355\\u8BCD\\u7684\\u957F\\u5EA6\\u52A0\\u4E0A\\u5355\\u8BCD\\u4E4B\\u95F4\\u9700\\u8981\\u9884\\u7559\\u7684\\u7A7A\\u683C\\u5982\\u679C\\u5927\\u4E8EmaxWidth\\u90A3\\u5C31\\u9700\\u8981\\u5228\\u53BB\\u65B0\\u5355\\u8BCD\\u5BF9\\u5F53\\u524D\\u6240\\u6709\\u5355\\u8BCD\\u4E2Dgaps\\u505A\\u7A7A\\u683C\\u5747\\u8861\\n    //3. \\u6700\\u540E\\u4E00\\u884C\\u5904\\u7406\\u7684\\u65F6\\u5019\\u76F4\\u63A5\\u7528string.Join(\" \", line)\\u628A\\u5355\\u8BCD\\u9694\\u5F00\\uFF0C\\u7136\\u540E\\u7528string.PadRight(maxWidth)\\u628A\\u5355\\u8BCD\\u505A\\u5DE6\\u5BF9\\u9F50\\u4E5F\\u5C31\\u662F\\u5F80\\u53F3\\u586B\\u5145\\u8DB3\\u591F\\u7684\\u7A7A\\u683C\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        IList<string> res = new List<string>();\\n        List<StringBuilder> wordsEachLine = new List<StringBuilder>();\\n        int totalCharsEachLine = 0;\\n        int wordIndex = 0;\\n        while(wordIndex < words.Length)\\n        {\\n            string word = words[wordIndex];\\n            wordsEachLine.Add(new StringBuilder(word));\\n            totalCharsEachLine+=word.Length;\\n            //\\u5148\\u8BA1\\u7B97\\u5F53\\u524Dsingle gap\\u9700\\u8981\\u591A\\u5C11\\u4E2A\\n            // Ex This_is_an  \\u8FD9\\u91CC\\u5C31\\u9700\\u89812\\u4E2A\\n            int gaps = wordsEachLine.Count - 1;\\n            \\n            //\\u5982\\u679C\\u73B0\\u5728line\\u4E0A\\u5F53\\u524D\\u6240\\u5B58\\u5728\\u7684word\\u52A0\\u4E0A\\u4E0B\\u4E00\\u4E2Aword\\u548C\\u9700\\u8981\\u7684singleGaps\\u6570\\u91CF\\u518D\\u52A0\\u4E0A\\u989D\\u5916\\u76841\\uFF08\\u8FD9\\u91CC\\u56E0\\u4E3A\\u591A\\u52A0\\u4E86\\u4E00\\u4E2Aword\\uFF09\\u957F\\u5EA6\\u5927\\u4E8EmaxWidth\\uFF0C\\n            //\\u6211\\u4EEC\\u5C31\\u9700\\u8981\\u5F80gaps\\u91CC\\u9762\\u6DFB\\u52A0\\u65B0\\u7684\\u7A7A\\u683C\\u6765\\u5747\\u8861gap\\u7684\\u7A7A\\u683C\\u6570\\u91CF\\n            if (wordIndex + 1 < words.Length && totalCharsEachLine + words[wordIndex+1].Length + gaps + 1 > maxWidth)\\n            {\\n                int restSpaces = maxWidth - totalCharsEachLine;\\n                for(int i = 0; i < restSpaces; i++)\\n                {\\n                    if (wordsEachLine.Count == 1)\\n                    {\\n                        wordsEachLine[0].Append(\" \");\\n                    }\\n                    else\\n                    {\\n                        wordsEachLine[i % gaps].Append(\" \");\\n                    }\\n                }\\n                \\n                res.Add(string.Join(\"\", wordsEachLine));\\n                wordsEachLine = new List<StringBuilder>();\\n                totalCharsEachLine = 0;\\n            }\\n            \\n            wordIndex++;\\n        }\\n        \\n        if (wordsEachLine.Count > 0)\\n        {\\n            string lastLine = string.Join(\" \", wordsEachLine);\\n            string lastLineRightpad = lastLine.PadRight(maxWidth);\\n            res.Add(lastLineRightpad);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    //\\u5F88\\u6076\\u5FC3\\u7684\\u4E00\\u9053\\u9898\\u76EE\\uFF0C\\u5B9E\\u73B0\\u633A\\u96BE\\n    //\\u4E3B\\u8981\\u662F3\\u70B9\\n    //1. \\u9700\\u8981\\u5BF9\\u6BCF\\u4E2A\\u5355\\u8BCD\\u4E2D\\u95F4\\u586B\\u4E0A\\u975E\\u5E38\\u5E73\\u5747\\u7684\\u7A7A\\u683C\\uFF0C\\u8FD9\\u4E2A\\u7528line[i % (gaps)].Append(\" \");\\u6765\\u89E3\\u51B3\\uFF0C\\u8FD9\\u91CC\\u7528line.Count-1\\u6765\\u5F97\\u5230\\u5355\\u8BCD\\u4E4B\\u95F4\\u7684gaps\\u9700\\u8981\\u591A\\u5C11,\\u7136\\u540E\\u901A\\u8FC7\\u4F59\\u6570\\u6765\\u6765\\u56DE\\u7ED9\\u5355\\u8BCD\\u4E2D\\u95F4\\u52A0\\u4E0A\\u5E73\\u5747\\u7684\\u7A7A\\u683C\\n    //Ex This_is_an_ _ _\\n    //   \\u4E0A\\u9762\\u8FD9\\u4E2A\\u4F8B\\u5B50\\u6211\\u4EEC\\u53EF\\u4EE5\\u770B\\u5230\\u4E00\\u4E2Aline\\u4E0A\\u603B\\u5171\\u67093\\u4E2A\\u5355\\u8BCD\\u7136\\u540E\\u9700\\u89812\\u4E2Agaps,\\u5982\\u4F55\\u628A\\u8FD9\\u4E9Bgap\\u5747\\u5300\\u5206\\u914D\\u7A7A\\u683C\\u5462\\uFF0C\\u90A3\\u5C31\\u662Fline[i%gaps].Append(\" \")\\n    //2. \\u5F53\\u524D\\u6240\\u6709\\u5355\\u8BCD\\u7684\\u957F\\u5EA6\\u52A0\\u4E0A\\u65B0\\u5355\\u8BCD\\u7684\\u957F\\u5EA6\\u52A0\\u4E0A\\u5355\\u8BCD\\u4E4B\\u95F4\\u9700\\u8981\\u9884\\u7559\\u7684\\u7A7A\\u683C\\u5982\\u679C\\u5927\\u4E8EmaxWidth\\u90A3\\u5C31\\u9700\\u8981\\u5228\\u53BB\\u65B0\\u5355\\u8BCD\\u5BF9\\u5F53\\u524D\\u6240\\u6709\\u5355\\u8BCD\\u4E2Dgaps\\u505A\\u7A7A\\u683C\\u5747\\u8861\\n    //3. \\u6700\\u540E\\u4E00\\u884C\\u5904\\u7406\\u7684\\u65F6\\u5019\\u76F4\\u63A5\\u7528string.Join(\" \", line)\\u628A\\u5355\\u8BCD\\u9694\\u5F00\\uFF0C\\u7136\\u540E\\u7528string.PadRight(maxWidth)\\u628A\\u5355\\u8BCD\\u505A\\u5DE6\\u5BF9\\u9F50\\u4E5F\\u5C31\\u662F\\u5F80\\u53F3\\u586B\\u5145\\u8DB3\\u591F\\u7684\\u7A7A\\u683C\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        IList<string> res = new List<string>();\\n        List<StringBuilder> wordsEachLine = new List<StringBuilder>();\\n        int totalCharsEachLine = 0;\\n        int wordIndex = 0;\\n        while(wordIndex < words.Length)\\n        {\\n            string word = words[wordIndex];\\n            wordsEachLine.Add(new StringBuilder(word));\\n            totalCharsEachLine+=word.Length;\\n            //\\u5148\\u8BA1\\u7B97\\u5F53\\u524Dsingle gap\\u9700\\u8981\\u591A\\u5C11\\u4E2A\\n            // Ex This_is_an  \\u8FD9\\u91CC\\u5C31\\u9700\\u89812\\u4E2A\\n            int gaps = wordsEachLine.Count - 1;\\n            \\n            //\\u5982\\u679C\\u73B0\\u5728line\\u4E0A\\u5F53\\u524D\\u6240\\u5B58\\u5728\\u7684word\\u52A0\\u4E0A\\u4E0B\\u4E00\\u4E2Aword\\u548C\\u9700\\u8981\\u7684singleGaps\\u6570\\u91CF\\u518D\\u52A0\\u4E0A\\u989D\\u5916\\u76841\\uFF08\\u8FD9\\u91CC\\u56E0\\u4E3A\\u591A\\u52A0\\u4E86\\u4E00\\u4E2Aword\\uFF09\\u957F\\u5EA6\\u5927\\u4E8EmaxWidth\\uFF0C\\n            //\\u6211\\u4EEC\\u5C31\\u9700\\u8981\\u5F80gaps\\u91CC\\u9762\\u6DFB\\u52A0\\u65B0\\u7684\\u7A7A\\u683C\\u6765\\u5747\\u8861gap\\u7684\\u7A7A\\u683C\\u6570\\u91CF\\n            if (wordIndex + 1 < words.Length && totalCharsEachLine + words[wordIndex+1].Length + gaps + 1 > maxWidth)\\n            {\\n                int restSpaces = maxWidth - totalCharsEachLine;\\n                for(int i = 0; i < restSpaces; i++)\\n                {\\n                    if (wordsEachLine.Count == 1)\\n                    {\\n                        wordsEachLine[0].Append(\" \");\\n                    }\\n                    else\\n                    {\\n                        wordsEachLine[i % gaps].Append(\" \");\\n                    }\\n                }\\n                \\n                res.Add(string.Join(\"\", wordsEachLine));\\n                wordsEachLine = new List<StringBuilder>();\\n                totalCharsEachLine = 0;\\n            }\\n            \\n            wordIndex++;\\n        }\\n        \\n        if (wordsEachLine.Count > 0)\\n        {\\n            string lastLine = string.Join(\" \", wordsEachLine);\\n            string lastLineRightpad = lastLine.PadRight(maxWidth);\\n            res.Add(lastLineRightpad);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112533,
                "title": "cpp-with-proper-thinking-process-commented",
                "content": "First thing, text justification is very common in word processing tools like MSWord `(Ctrl + j)`.\\n\\n**We need to think on below points:**\\n\\n1. How do we know how many words would fit in each line?\\n2. Once we know the how many words would fit in current line, how do we divide the spaces? What if spaces are uneven? How do we handle such part?\\n3. How do we handle last line?\\n\\n**Lets think . . .** \\n\\nWe can add the length of the words as we go forward + we need to add 1 space at-least just after every word we encounter. We\\u2019ll stop as soon as we couldn\\u2019t fit any more word bounded by `maxWidth`.\\n\\n**We can use two pointers to do that. Previous pointer will mark the starting of the word and next pointer will mark the ending of the word for the current line. We also need a sum that keeps track of how many characters it has seen yet.**\\n\\nLet\\u2019s code the basic part\\n\\n```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nwhile (endWordIndex < int(words.size())) {\\n    if (charsTillNow + int(words[endWordIndex].size()) <= maxWidth) {\\n        charsTillNow += int(words[endWordIndex].size());\\n        endWordIndex++;\\n    }\\n}\\n```\\n\\nAbove logic is wrong, we also need to add \\u201Cspace\\u201D while checking `<= maxWidth`. \\n\\n```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nwhile (endWordIndex < int(words.size())) {\\n    if (charsTillNow + 1 + int(words[endWordIndex].size()) <= maxWidth) {\\n        charsTillNow += int(words[endWordIndex].size());\\n        endWordIndex++;\\n    }\\n    // we come here means we cannot accomodate any more word for current line\\n}\\n```\\n\\nAbove logic is also wrong, we can\\u2019t add 1 for the first word of the current line. We need something that will make above code add 0 for the first time then 1 each time afterwards.\\n\\n```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nbool startWord = true; // true for first word for each new line**\\nwhile (endWordIndex < int(words.size())) {\\n    int tempCharCount = charsTillNow + int(words[endWordIndex].size());\\n    if (!startWord) tempCharCount++; // For space after if not the first word\\n    if (tempCharCount <= maxWidth) {\\n        charsTillNow += tempCharCount;\\n        endWordIndex++;\\n        startWord = false;\\n        continue;\\n    }\\n    // we come here means we cannot accomodate any more word for current line\\n\\t\\t// means after this next time while loop will be executed that would be for new line\\n    startWord = true;\\n}\\n```\\n\\nNow, `charTillNow` will have all the valid chars count + 1 space b/w each word.\\n\\n**How many words?**  `wordCount = endWordIndex - startWordIndex`\\n\\n**How many spaces?** We must subtract the additional spaces we considered in `charsTillNow`. Those would be `wordCount-1`.\\n\\n`spaceCount = maxWidth - (charsTillNow - (wordCount-1))`\\n\\n**How much minimum space to allocate?**\\n\\n`minSpaceForEachWord = spaceCount / (wordCount-1)` \\u2014> Division by 0 is likely\\n\\n**What about any extra space left? Due to improper division of spaceCount and space locations**\\n\\n`extraSpace = spaceCount - (spaceLocations * minSpaceForEachWord)`\\n\\nWe\\u2019ll add these additional space from left to right as we go forward with each word of the current line. Note that `extraSpace` will be less than `minSpaceForEachWord` as its the remainder. so if we add 1 by 1 if its more than 0, we\\u2019ll run out before the last word. [as per problem constraint]\\n\\n**Let\\u2019s add these words bounded by [startWordIndex : endWordIndex)**\\n\\n```cpp\\nstring currentLine;\\n\\nwhile(startWordIndex < endWordIndex) {\\n    currentLine.append(words[startWordIndex]);\\n    // Now add space but do not add space for last word\\n    if (startWordIndex != endWordIndex - 1)\\n        currentLine.append(string(minSpaceForEachWord + int(extraSpace > 0), \\' \\'));\\n    startWordIndex++;\\n\\t\\textraSpace--; // even goes to negative, we really don\\'t care\\n}\\n```\\n\\nNote: if `extraSpace > 0` \\u2192 `int(extraspace>0)` will return 1 for `true`.\\n\\nFull code till now:\\n```\\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int startWordIndex = 0;\\n        int endWordIndex = 0;\\n        int charsTillNow = 0;\\n        int wordCount, spaceLocations, spaceCount, minSpaceForEachWord, extraSpace;\\n        string currentLine;\\n\\n        bool startWord = true;\\n        while (endWordIndex < int(words.size())) {\\n            int tempCharCount = int(words[endWordIndex].size());\\n            if (!startWord) tempCharCount++; // For space\\n            if (tempCharCount + charsTillNow <= maxWidth) {\\n                charsTillNow += tempCharCount;\\n                endWordIndex++;\\n                startWord = false;\\n                continue;\\n            }\\n\\n            startWord = true;\\n            wordCount = endWordIndex - startWordIndex;\\n            spaceLocations = wordCount - 1; // we put space b/w each word so it will always be wordCount-1\\n            spaceCount = maxWidth - (charsTillNow - spaceLocations);\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t// put the default value as full space count as we also need to handle if we found just one word\\n            // for one word, assign all spaceCount just after that word and there wouldn\\'t be any extraSpace thing if there is just one word\\n            minSpaceForEachWord = spaceCount;\\n            extraSpace = 0;\\n            if (wordCount > 1) { // if word is more than 1, then calculate properly\\n                minSpaceForEachWord = spaceCount / spaceLocations;\\n                extraSpace = spaceCount - (spaceLocations * minSpaceForEachWord);\\n            }\\n\\n\\t\\t\\t// Create current Line\\n            while (startWordIndex < endWordIndex) {\\n                currentLine.append(words[startWordIndex]);\\n                // Now add space but do not add space for last word\\n                if (startWordIndex != endWordIndex - 1)\\n                    currentLine.append(string(minSpaceForEachWord + int(extraSpace > 0), \\' \\'));\\n                else if (wordCount == 1) // if word length is 1, above condition will fail always, so in that case put all the spaces behind\\n                    currentLine.append(string(spaceCount, \\' \\'));\\n                startWordIndex++;\\n                extraSpace--; // even go to negative, we really don\\'t care\\n            }\\n            ans.push_back(currentLine);\\n            currentLine.clear();\\n            charsTillNow = 0;\\n        }\\n\\t\\t\\n\\t\\t// Above while loop breaks leaving us handle the last line separately\\n        // we\\'ll come here for last line. It has different rule\\n        wordCount = endWordIndex - startWordIndex;\\n        spaceLocations = wordCount - 1;\\n        spaceCount = maxWidth - (charsTillNow - spaceLocations);\\n        while (startWordIndex < endWordIndex) {\\n            currentLine.append(words[startWordIndex]);\\n            // For last line, just add one space\\n            if (startWordIndex != endWordIndex - 1)\\n                currentLine.append(\" \");\\n            startWordIndex++;\\n        }\\n\\t\\t// append the remaining spaces [totalspace - how much we already filled (spaceLocations)]\\n        currentLine.append(string(spaceCount-spaceLocations, \\' \\'));\\n        ans.push_back(currentLine);\\n        \\n        return ans;\\n\\n    }\\n```\\n\\n\\nPS: Above code can be modularized but I didn\\'t want to break the flow of going through the code.\\nI have also one solution that\\'s a little modularized that uses similar logic.\\n[https://leetcode.com/submissions/detail/714605666/]\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nwhile (endWordIndex < int(words.size())) {\\n    if (charsTillNow + int(words[endWordIndex].size()) <= maxWidth) {\\n        charsTillNow += int(words[endWordIndex].size());\\n        endWordIndex++;\\n    }\\n}\\n```\n```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nwhile (endWordIndex < int(words.size())) {\\n    if (charsTillNow + 1 + int(words[endWordIndex].size()) <= maxWidth) {\\n        charsTillNow += int(words[endWordIndex].size());\\n        endWordIndex++;\\n    }\\n    // we come here means we cannot accomodate any more word for current line\\n}\\n```\n```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nbool startWord = true; // true for first word for each new line**\\nwhile (endWordIndex < int(words.size())) {\\n    int tempCharCount = charsTillNow + int(words[endWordIndex].size());\\n    if (!startWord) tempCharCount++; // For space after if not the first word\\n    if (tempCharCount <= maxWidth) {\\n        charsTillNow += tempCharCount;\\n        endWordIndex++;\\n        startWord = false;\\n        continue;\\n    }\\n    // we come here means we cannot accomodate any more word for current line\\n\\t\\t// means after this next time while loop will be executed that would be for new line\\n    startWord = true;\\n}\\n```\n```cpp\\nstring currentLine;\\n\\nwhile(startWordIndex < endWordIndex) {\\n    currentLine.append(words[startWordIndex]);\\n    // Now add space but do not add space for last word\\n    if (startWordIndex != endWordIndex - 1)\\n        currentLine.append(string(minSpaceForEachWord + int(extraSpace > 0), \\' \\'));\\n    startWordIndex++;\\n\\t\\textraSpace--; // even goes to negative, we really don\\'t care\\n}\\n```\n```\\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int startWordIndex = 0;\\n        int endWordIndex = 0;\\n        int charsTillNow = 0;\\n        int wordCount, spaceLocations, spaceCount, minSpaceForEachWord, extraSpace;\\n        string currentLine;\\n\\n        bool startWord = true;\\n        while (endWordIndex < int(words.size())) {\\n            int tempCharCount = int(words[endWordIndex].size());\\n            if (!startWord) tempCharCount++; // For space\\n            if (tempCharCount + charsTillNow <= maxWidth) {\\n                charsTillNow += tempCharCount;\\n                endWordIndex++;\\n                startWord = false;\\n                continue;\\n            }\\n\\n            startWord = true;\\n            wordCount = endWordIndex - startWordIndex;\\n            spaceLocations = wordCount - 1; // we put space b/w each word so it will always be wordCount-1\\n            spaceCount = maxWidth - (charsTillNow - spaceLocations);\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t// put the default value as full space count as we also need to handle if we found just one word\\n            // for one word, assign all spaceCount just after that word and there wouldn\\'t be any extraSpace thing if there is just one word\\n            minSpaceForEachWord = spaceCount;\\n            extraSpace = 0;\\n            if (wordCount > 1) { // if word is more than 1, then calculate properly\\n                minSpaceForEachWord = spaceCount / spaceLocations;\\n                extraSpace = spaceCount - (spaceLocations * minSpaceForEachWord);\\n            }\\n\\n\\t\\t\\t// Create current Line\\n            while (startWordIndex < endWordIndex) {\\n                currentLine.append(words[startWordIndex]);\\n                // Now add space but do not add space for last word\\n                if (startWordIndex != endWordIndex - 1)\\n                    currentLine.append(string(minSpaceForEachWord + int(extraSpace > 0), \\' \\'));\\n                else if (wordCount == 1) // if word length is 1, above condition will fail always, so in that case put all the spaces behind\\n                    currentLine.append(string(spaceCount, \\' \\'));\\n                startWordIndex++;\\n                extraSpace--; // even go to negative, we really don\\'t care\\n            }\\n            ans.push_back(currentLine);\\n            currentLine.clear();\\n            charsTillNow = 0;\\n        }\\n\\t\\t\\n\\t\\t// Above while loop breaks leaving us handle the last line separately\\n        // we\\'ll come here for last line. It has different rule\\n        wordCount = endWordIndex - startWordIndex;\\n        spaceLocations = wordCount - 1;\\n        spaceCount = maxWidth - (charsTillNow - spaceLocations);\\n        while (startWordIndex < endWordIndex) {\\n            currentLine.append(words[startWordIndex]);\\n            // For last line, just add one space\\n            if (startWordIndex != endWordIndex - 1)\\n                currentLine.append(\" \");\\n            startWordIndex++;\\n        }\\n\\t\\t// append the remaining spaces [totalspace - how much we already filled (spaceLocations)]\\n        currentLine.append(string(spaceCount-spaceLocations, \\' \\'));\\n        ans.push_back(currentLine);\\n        \\n        return ans;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1897672,
                "title": "simple-solution-in-java-100-faster",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        List<String> resText = new ArrayList<>();\\n        int i = 0;\\n        while(i < words.length){\\n            StringBuilder resStr = new StringBuilder(words[i]);\\n            \\n            int j = i + 1;\\n            int currWidth = words[i].length();\\n            while(j < words.length && currWidth + 1 + words[j].length() <= maxWidth){\\n                currWidth += 1 + words[j].length();\\n                j++;\\n            }\\n            \\n            // Number of words in the current line are: (excluding the first one)\\n            int numWords = j - i - 1;\\n            \\n            if(numWords == 0 || j == words.length){\\n                // Last Line\\n                for(int k=i+1; k<j; k++){\\n                    resStr.append(\" \");\\n                    resStr.append(words[k]);\\n                }\\n                \\n                // Do padding at the end \\n                int remLen = maxWidth - resStr.length();\\n                for(int space=0; space < remLen; space++){\\n                    resStr.append(\" \");\\n                }\\n                \\n            }else{\\n                int numSpace = (maxWidth - currWidth)/numWords;\\n                int extraSpace = (maxWidth - currWidth)%numWords;\\n                \\n                for(int k=i+1; k<j; k++){\\n                    for(int space=0; space < numSpace; space++){\\n                        resStr.append(\" \");\\n                    }\\n                    \\n                    if(extraSpace > 0){\\n                        resStr.append(\" \");\\n                        extraSpace--;\\n                    }\\n                    \\n                    resStr.append(\" \"); // One space was already included \\n                    resStr.append(words[k]);\\n                }\\n                \\n            }\\n            \\n            resText.add(resStr.toString());\\n            i = j;\\n        }\\n        \\n        return resText;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        List<String> resText = new ArrayList<>();\\n        int i = 0;\\n        while(i < words.length){\\n            StringBuilder resStr = new StringBuilder(words[i]);\\n            \\n            int j = i + 1;\\n            int currWidth = words[i].length();\\n            while(j < words.length && currWidth + 1 + words[j].length() <= maxWidth){\\n                currWidth += 1 + words[j].length();\\n                j++;\\n            }\\n            \\n            // Number of words in the current line are: (excluding the first one)\\n            int numWords = j - i - 1;\\n            \\n            if(numWords == 0 || j == words.length){\\n                // Last Line\\n                for(int k=i+1; k<j; k++){\\n                    resStr.append(\" \");\\n                    resStr.append(words[k]);\\n                }\\n                \\n                // Do padding at the end \\n                int remLen = maxWidth - resStr.length();\\n                for(int space=0; space < remLen; space++){\\n                    resStr.append(\" \");\\n                }\\n                \\n            }else{\\n                int numSpace = (maxWidth - currWidth)/numWords;\\n                int extraSpace = (maxWidth - currWidth)%numWords;\\n                \\n                for(int k=i+1; k<j; k++){\\n                    for(int space=0; space < numSpace; space++){\\n                        resStr.append(\" \");\\n                    }\\n                    \\n                    if(extraSpace > 0){\\n                        resStr.append(\" \");\\n                        extraSpace--;\\n                    }\\n                    \\n                    resStr.append(\" \"); // One space was already included \\n                    resStr.append(words[k]);\\n                }\\n                \\n            }\\n            \\n            resText.add(resStr.toString());\\n            i = j;\\n        }\\n        \\n        return resText;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804542,
                "title": "clean-easy-to-understand-python-o-n",
                "content": "```\\nclass Solution:\\n    def createSentence(self, line):\\n        sentence = \\'\\'\\n        for word, spaceCount in line:\\n            sentence+=word\\n            sentence+=\\' \\'*spaceCount\\n            \\n        return sentence\\n    \\n    def adjustSpaces(self, line, spaceLeft):\\n        lastSpaces = line[-1][1]\\n        line[-1][1] = 0\\n        spaceLeft +=lastSpaces\\n        totalWords = len(line)\\n        \\n        if totalWords == 1:\\n            line[0][1] = spaceLeft\\n            return self.createSentence(line)\\n        \\n        for i in range(totalWords-1, 0, -1):\\n            spaceAfterWord = spaceLeft//i\\n            spaceLeft-=spaceAfterWord\\n            \\n            line[i-1][1] += spaceAfterWord\\n            \\n        return self.createSentence(line)    \\n        \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        line = []\\n        cUsage = 0\\n        output = []\\n        for word in words:\\n            if cUsage + len(word) > maxWidth:\\n                output.append(self.adjustSpaces(line, maxWidth-cUsage))\\n                cUsage = len(word)+1\\n                line = [[word,1]]\\n                \\n            elif cUsage + len(word) == maxWidth:\\n                line.append([word,0])\\n                cUsage = maxWidth\\n                \\n            else:\\n                line.append([word,1])\\n                cUsage+=len(word)+1\\n                \\n        line[-1][1] += maxWidth - cUsage\\n        output.append(self.createSentence(line))\\n                \\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def createSentence(self, line):\\n        sentence = \\'\\'\\n        for word, spaceCount in line:\\n            sentence+=word\\n            sentence+=\\' \\'*spaceCount\\n            \\n        return sentence\\n    \\n    def adjustSpaces(self, line, spaceLeft):\\n        lastSpaces = line[-1][1]\\n        line[-1][1] = 0\\n        spaceLeft +=lastSpaces\\n        totalWords = len(line)\\n        \\n        if totalWords == 1:\\n            line[0][1] = spaceLeft\\n            return self.createSentence(line)\\n        \\n        for i in range(totalWords-1, 0, -1):\\n            spaceAfterWord = spaceLeft//i\\n            spaceLeft-=spaceAfterWord\\n            \\n            line[i-1][1] += spaceAfterWord\\n            \\n        return self.createSentence(line)    \\n        \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        line = []\\n        cUsage = 0\\n        output = []\\n        for word in words:\\n            if cUsage + len(word) > maxWidth:\\n                output.append(self.adjustSpaces(line, maxWidth-cUsage))\\n                cUsage = len(word)+1\\n                line = [[word,1]]\\n                \\n            elif cUsage + len(word) == maxWidth:\\n                line.append([word,0])\\n                cUsage = maxWidth\\n                \\n            else:\\n                line.append([word,1])\\n                cUsage+=len(word)+1\\n                \\n        line[-1][1] += maxWidth - cUsage\\n        output.append(self.createSentence(line))\\n                \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740385,
                "title": "python-simple-faster-than-97-60",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        def balanceSpaces(string, isLast):\\n            spacesToAdd = maxWidth - len(string)\\n            stringAsList = string.split(\\' \\')\\n            \\n            if len(stringAsList) == 1 or isLast:\\n                return string + (\\' \\' * spacesToAdd)\\n            else:\\n                while spacesToAdd:\\n                    for i in range(len(stringAsList) - 1):\\n                        if spacesToAdd:\\n                            stringAsList[i] += \\' \\'\\n                            spacesToAdd -= 1\\n                        else:\\n                            break\\n            return \\' \\'.join(stringAsList)\\n        \\n        output = []\\n        \\n        currLayer = \"\"\\n        for each in words:\\n            if not currLayer:\\n                currLayer += each\\n            elif len(currLayer + \\' \\' + each) <= maxWidth:\\n                currLayer += \\' \\' + each\\n            else:\\n                output.append(balanceSpaces(currLayer, False))\\n                currLayer = each\\n        \\n        output.append(balanceSpaces(currLayer, True))\\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        def balanceSpaces(string, isLast):\\n            spacesToAdd = maxWidth - len(string)\\n            stringAsList = string.split(\\' \\')\\n            \\n            if len(stringAsList) == 1 or isLast:\\n                return string + (\\' \\' * spacesToAdd)\\n            else:\\n                while spacesToAdd:\\n                    for i in range(len(stringAsList) - 1):\\n                        if spacesToAdd:\\n                            stringAsList[i] += \\' \\'\\n                            spacesToAdd -= 1\\n                        else:\\n                            break\\n            return \\' \\'.join(stringAsList)\\n        \\n        output = []\\n        \\n        currLayer = \"\"\\n        for each in words:\\n            if not currLayer:\\n                currLayer += each\\n            elif len(currLayer + \\' \\' + each) <= maxWidth:\\n                currLayer += \\' \\' + each\\n            else:\\n                output.append(balanceSpaces(currLayer, False))\\n                currLayer = each\\n        \\n        output.append(balanceSpaces(currLayer, True))\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731481,
                "title": "greedy-python-solution",
                "content": "I split this up into three parts: First, partitioning the array into blocks to be justified, then justifying these blocks either left or right. Partitioning is easy, we just take as many words as we can, considering that we need at least one space after the first word. Justifying left is very easy as well.\\n\\nFully justifying is also not hard, the number of spaces you use is the integer division of the number of gaps and the difference between the width and the used space. We need the reminder of this division as well to distribute the excess space on the left.\\n\\n```python\\nclass Solution:\\n    def justifyFull(self, curLine: List[str], maxWidth: int) -> str:\\n        spacingNeeded: int = maxWidth - sum([len(word) for word in curLine])\\n        numGaps: int = max(1, len(curLine) - 1)\\n        numSpacesBase: int = spacingNeeded // numGaps\\n        numExtra: int = spacingNeeded % numGaps\\n        \\n        line: List[str] = []\\n        \\n        for i, word in enumerate(curLine):\\n            if i == 0:\\n                line.append(word)\\n            else:\\n                line.append(\" \" * numSpacesBase)\\n                if i <= numExtra:\\n                    line.append(\" \")\\n                line.append(word)\\n        return \"\".join(line)\\n    \\n    def justifyLeft(self, curLine: List[str], maxWidth: int) -> str:\\n        line: List[str] = []\\n        spaceUsed: int = 0\\n            \\n        for i, word in enumerate(curLine):\\n            if i == 0:\\n                line.append(word)\\n                spaceUsed += len(word)\\n            else:\\n                line.append(\" \")\\n                line.append(word)\\n                spaceUsed += len(word) + 1\\n        if spaceUsed < maxWidth:\\n            line.append(\" \" * (maxWidth - spaceUsed))\\n        return \"\".join(line)\\n\\n                \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        curWidth: int = 0\\n        curLine: List[str] = []\\n        justified: List[str] = []\\n        \\n        for i, word in enumerate(words):\\n            addedLength = 0\\n            if curWidth == 0:\\n                addedLength = len(word)\\n            else:\\n                addedLength = len(word) + 1\\n            \\n            if curWidth + addedLength > maxWidth:\\n                if len(curLine) > 1:\\n                    justified.append(self.justifyFull(curLine, maxWidth))\\n                else:\\n                    justified.append(self.justifyLeft(curLine, maxWidth))\\n                    \\n                curWidth = len(word)\\n                curLine = [word]\\n            else:\\n                curWidth += addedLength\\n                curLine.append(word)\\n                \\n        if curWidth > 0:\\n            justified.append(self.justifyLeft(curLine, maxWidth))\\n        \\n        return justified\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def justifyFull(self, curLine: List[str], maxWidth: int) -> str:\\n        spacingNeeded: int = maxWidth - sum([len(word) for word in curLine])\\n        numGaps: int = max(1, len(curLine) - 1)\\n        numSpacesBase: int = spacingNeeded // numGaps\\n        numExtra: int = spacingNeeded % numGaps\\n        \\n        line: List[str] = []\\n        \\n        for i, word in enumerate(curLine):\\n            if i == 0:\\n                line.append(word)\\n            else:\\n                line.append(\" \" * numSpacesBase)\\n                if i <= numExtra:\\n                    line.append(\" \")\\n                line.append(word)\\n        return \"\".join(line)\\n    \\n    def justifyLeft(self, curLine: List[str], maxWidth: int) -> str:\\n        line: List[str] = []\\n        spaceUsed: int = 0\\n            \\n        for i, word in enumerate(curLine):\\n            if i == 0:\\n                line.append(word)\\n                spaceUsed += len(word)\\n            else:\\n                line.append(\" \")\\n                line.append(word)\\n                spaceUsed += len(word) + 1\\n        if spaceUsed < maxWidth:\\n            line.append(\" \" * (maxWidth - spaceUsed))\\n        return \"\".join(line)\\n\\n                \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        curWidth: int = 0\\n        curLine: List[str] = []\\n        justified: List[str] = []\\n        \\n        for i, word in enumerate(words):\\n            addedLength = 0\\n            if curWidth == 0:\\n                addedLength = len(word)\\n            else:\\n                addedLength = len(word) + 1\\n            \\n            if curWidth + addedLength > maxWidth:\\n                if len(curLine) > 1:\\n                    justified.append(self.justifyFull(curLine, maxWidth))\\n                else:\\n                    justified.append(self.justifyLeft(curLine, maxWidth))\\n                    \\n                curWidth = len(word)\\n                curLine = [word]\\n            else:\\n                curWidth += addedLength\\n                curLine.append(word)\\n                \\n        if curWidth > 0:\\n            justified.append(self.justifyLeft(curLine, maxWidth))\\n        \\n        return justified\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643285,
                "title": "c-easy-to-understand-broken-into-several-methods",
                "content": "```\\npublic class Solution\\n{\\n    public IList<string> FullJustify(string[] words, int maxWidth)\\n    {\\n        var lines = new List<string>();\\n\\n        var left = 0;\\n        var lineLength = 0;\\n        var wordsLength = 0;\\n\\n        for (var i = 0; i < words.Length; i++)\\n        {\\n            var word = words[i];\\n            if (lineLength + word.Length > maxWidth)\\n            {\\n                lines.Add(JustifyLine(words, maxWidth, left, i - 1, wordsLength));\\n                \\n                // reset state\\n                lineLength = 0;\\n                wordsLength = 0;\\n                left = i;\\n            }\\n\\n            lineLength += word.Length + 1;\\n            wordsLength += word.Length;\\n        }\\n\\n        // yustify the last line\\n        if (left <= words.Length - 1)\\n        {\\n            var line = string.Join(\" \", words.Skip(left));\\n            lines.Add(line + new string(\\' \\', maxWidth - line.Length));\\n        }\\n\\n        return lines;\\n    }\\n\\n    private string JustifyLine(string[] words, int maxWidth, int start, int end, int wordsLength)\\n    {\\n        var builder = new StringBuilder();\\n        var spaces = maxWidth - wordsLength;\\n\\n        // justify one word\\n        if (start == end)\\n        {\\n            builder.Append(words[start]);\\n            builder.Append(\\' \\', spaces);\\n\\n            return builder.ToString();\\n        }\\n\\n        // justify multiple words\\n        var gaps = end - start;\\n\\n        for (var i = start; i <= end; i++)\\n        {\\n            builder.Append(words[i]);\\n\\n            // adding spaces if the word isn\\'t last\\n            if (i != end)\\n            {\\n                var count = spaces / gaps + (spaces % gaps == 0 ? 0 : 1);\\n                builder.Append(\\' \\', count);\\n\\n                spaces -= count;\\n                gaps--;\\n            }\\n        }\\n\\n        return builder.ToString();\\n    }\\n}\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public IList<string> FullJustify(string[] words, int maxWidth)\\n    {\\n        var lines = new List<string>();\\n\\n        var left = 0;\\n        var lineLength = 0;\\n        var wordsLength = 0;\\n\\n        for (var i = 0; i < words.Length; i++)\\n        {\\n            var word = words[i];\\n            if (lineLength + word.Length > maxWidth)\\n            {\\n                lines.Add(JustifyLine(words, maxWidth, left, i - 1, wordsLength));\\n                \\n                // reset state\\n                lineLength = 0;\\n                wordsLength = 0;\\n                left = i;\\n            }\\n\\n            lineLength += word.Length + 1;\\n            wordsLength += word.Length;\\n        }\\n\\n        // yustify the last line\\n        if (left <= words.Length - 1)\\n        {\\n            var line = string.Join(\" \", words.Skip(left));\\n            lines.Add(line + new string(\\' \\', maxWidth - line.Length));\\n        }\\n\\n        return lines;\\n    }\\n\\n    private string JustifyLine(string[] words, int maxWidth, int start, int end, int wordsLength)\\n    {\\n        var builder = new StringBuilder();\\n        var spaces = maxWidth - wordsLength;\\n\\n        // justify one word\\n        if (start == end)\\n        {\\n            builder.Append(words[start]);\\n            builder.Append(\\' \\', spaces);\\n\\n            return builder.ToString();\\n        }\\n\\n        // justify multiple words\\n        var gaps = end - start;\\n\\n        for (var i = start; i <= end; i++)\\n        {\\n            builder.Append(words[i]);\\n\\n            // adding spaces if the word isn\\'t last\\n            if (i != end)\\n            {\\n                var count = spaces / gaps + (spaces % gaps == 0 ? 0 : 1);\\n                builder.Append(\\' \\', count);\\n\\n                spaces -= count;\\n                gaps--;\\n            }\\n        }\\n\\n        return builder.ToString();\\n    }\\n}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1620628,
                "title": "java-100-faster-with-explanation",
                "content": "Overall time: O(n)\\nspace: O(n)\\nPlease consider upvote if you like my solution. Thank you!\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\t\\t// list to be returned\\n        List<String> list = new ArrayList<>();\\n        \\n\\t\\t// store the combined word length in *section* list\\n        int length = 0;\\n\\t\\t// *section* list to store the words at current iteration\\n        List<String> section = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n\\t\\t\\t// if and only if the word that we are currently looking at exceeds the wordWidth limit\\n\\t\\t\\t// we start to build a solution at this level\\n            if (length + section.size() + words[i].length() > maxWidth) {\\n\\t\\t\\t\\t// number of spaces total\\n                int diff = maxWidth - length;\\n                StringBuilder sb = new StringBuilder();\\n                int spaceCount = section.size() > 1 ? diff / (section.size() - 1) : diff;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// extra spaces when we can\\'t evenly distribute them\\n                int extraCount = section.size() > 1 ? diff % (section.size() - 1) : 0;\\n                diff -= extraCount;\\n                for (int j = 0; j < section.size(); j++) {\\n                    sb.append(section.get(j));\\n                    if (extraCount > 0) {\\n                        addSpace(sb, 1);\\n                        extraCount -= 1;\\n                    }\\n                    if (diff > 0) {\\n                        addSpace(sb, spaceCount);\\n                        diff -= spaceCount;\\n                    }\\n                }\\n                \\n                list.add(sb.toString());\\n\\t\\t\\t\\t// clear section list for next iteration\\n                section.clear();\\n\\t\\t\\t\\t// clear length counter for next iteration\\n                length = 0;\\n            }\\n            section.add(words[i]);\\n            length += words[i].length();\\n        }\\n        // build the last line differently\\n        if (!section.isEmpty()) {\\n            StringBuilder sb = new StringBuilder();\\n            int count = 0;\\n            for (int j = 0; j < section.size(); j++) {\\n                sb.append(section.get(j));\\n                if (j != section.size() - 1) {\\n                    addSpace(sb, 1);\\n                    count += 1;\\n                }\\n            }\\n            int diff = maxWidth - length - count;\\n            addSpace(sb, diff);\\n            list.add(sb.toString());\\n        }\\n        \\n        return list;\\n    }\\n    // helper function to append spaces to string builder\\n    private void addSpace(StringBuilder sb, int count) {\\n        for (int i = 0; i < count; i++) {\\n            sb.append(\" \");\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\t\\t// list to be returned\\n        List<String> list = new ArrayList<>();\\n        \\n\\t\\t// store the combined word length in *section* list\\n        int length = 0;\\n\\t\\t// *section* list to store the words at current iteration\\n        List<String> section = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n\\t\\t\\t// if and only if the word that we are currently looking at exceeds the wordWidth limit\\n\\t\\t\\t// we start to build a solution at this level\\n            if (length + section.size() + words[i].length() > maxWidth) {\\n\\t\\t\\t\\t// number of spaces total\\n                int diff = maxWidth - length;\\n                StringBuilder sb = new StringBuilder();\\n                int spaceCount = section.size() > 1 ? diff / (section.size() - 1) : diff;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// extra spaces when we can\\'t evenly distribute them\\n                int extraCount = section.size() > 1 ? diff % (section.size() - 1) : 0;\\n                diff -= extraCount;\\n                for (int j = 0; j < section.size(); j++) {\\n                    sb.append(section.get(j));\\n                    if (extraCount > 0) {\\n                        addSpace(sb, 1);\\n                        extraCount -= 1;\\n                    }\\n                    if (diff > 0) {\\n                        addSpace(sb, spaceCount);\\n                        diff -= spaceCount;\\n                    }\\n                }\\n                \\n                list.add(sb.toString());\\n\\t\\t\\t\\t// clear section list for next iteration\\n                section.clear();\\n\\t\\t\\t\\t// clear length counter for next iteration\\n                length = 0;\\n            }\\n            section.add(words[i]);\\n            length += words[i].length();\\n        }\\n        // build the last line differently\\n        if (!section.isEmpty()) {\\n            StringBuilder sb = new StringBuilder();\\n            int count = 0;\\n            for (int j = 0; j < section.size(); j++) {\\n                sb.append(section.get(j));\\n                if (j != section.size() - 1) {\\n                    addSpace(sb, 1);\\n                    count += 1;\\n                }\\n            }\\n            int diff = maxWidth - length - count;\\n            addSpace(sb, diff);\\n            list.add(sb.toString());\\n        }\\n        \\n        return list;\\n    }\\n    // helper function to append spaces to string builder\\n    private void addSpace(StringBuilder sb, int count) {\\n        for (int i = 0; i < count; i++) {\\n            sb.append(\" \");\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613771,
                "title": "0-ms-java-solution-faster-than-100-of-java-solutions",
                "content": "I really sacrificed readability/elegance for performance on this one. I use start and end pointers into the given array to avoid keeping a list of words. Use linked list to avoid cost of resizing array list (even though it is amortized constant, we never index into the list so a linked list works fine). Used loops rather than streams, also for speed. \\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Text Justification.\\nMemory Usage: 37.1 MB, less than 95.74% of Java online submissions for Text Justification.\\n\\n```\\nclass Solution {\\n    private int maxWidth;\\n    private String[] words;\\n    \\n    public List<String> fullJustify(String[] ws, int maxW) {        \\n        \\n        List<String> text = new LinkedList<>();        \\n        maxWidth = maxW;\\n        words = ws; \\n        // Use start/end indexes into words array to avoid making a list of words in current line (for efficiency).\\n        int start = 0; \\n        int end = 1;\\n        int lineLen = words[start].length();\\n        \\n        for (; end < words.length; end++) {\\n            String word = words[end];\\n            \\n            if (lineLen + word.length() + 1 <= maxWidth) { // Word fits in this line. Plus one is for a space.\\n                lineLen += word.length() + 1; \\n            } else { // Word does not fit in this line, space out current line and start a new one.\\n                text.add(constructLine(start, end, lineLen));\\n                start = end;\\n                lineLen = word.length();\\n            }   \\n        }\\n        \\n        if (end - start > 0) {\\n            text.add(lineWithoutInterWordPadding(start, end, lineLen));\\n        }\\n        \\n        return text;\\n    }\\n    \\n    private String lineWithoutInterWordPadding(int start, int end, int lineLength) {\\n        // Don\\'t use stream Collectors.joining(\" \") here, even though it is more readable. The below is faster.\\n        StringBuilder line = new StringBuilder();\\n        line.append(words[start]);\\n        for (int i = start + 1; i < end; i++) {\\n            line.append(\" \");\\n            line.append(words[i]);\\n        }\\n        return line.toString() + \" \".repeat(maxWidth - lineLength);\\n    }\\n    \\n    private String constructLine(int start, int end, int lineLength) {\\n        int numSpaces = end - (start + 1);\\n        \\n        if (numSpaces == 0) { // Only one word in the line.\\n            return lineWithoutInterWordPadding(start, end, lineLength);\\n        }\\n        \\n        int padding = maxWidth - lineLength;       // Extra padding needed.\\n        int spaceNeeded = padding / numSpaces + 1; // Padding between each word (extra + minimum one).\\n        int leftOverSpaces = padding % numSpaces;  // Extra spaces that don\\'t divide evenly between words.\\n        \\n        StringBuilder line = new StringBuilder();\\n        line.append(words[start]);\\n        \\n        for (int i = start + 1; i < end; i++) {\\n            line.append(\" \".repeat(spaceNeeded));\\n            if (leftOverSpaces-- > 0) {\\n                line.append(\\' \\');\\n            }\\n            line.append(words[i]);\\n        }\\n        \\n        return line.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int maxWidth;\\n    private String[] words;\\n    \\n    public List<String> fullJustify(String[] ws, int maxW) {        \\n        \\n        List<String> text = new LinkedList<>();        \\n        maxWidth = maxW;\\n        words = ws; \\n        // Use start/end indexes into words array to avoid making a list of words in current line (for efficiency).\\n        int start = 0; \\n        int end = 1;\\n        int lineLen = words[start].length();\\n        \\n        for (; end < words.length; end++) {\\n            String word = words[end];\\n            \\n            if (lineLen + word.length() + 1 <= maxWidth) { // Word fits in this line. Plus one is for a space.\\n                lineLen += word.length() + 1; \\n            } else { // Word does not fit in this line, space out current line and start a new one.\\n                text.add(constructLine(start, end, lineLen));\\n                start = end;\\n                lineLen = word.length();\\n            }   \\n        }\\n        \\n        if (end - start > 0) {\\n            text.add(lineWithoutInterWordPadding(start, end, lineLen));\\n        }\\n        \\n        return text;\\n    }\\n    \\n    private String lineWithoutInterWordPadding(int start, int end, int lineLength) {\\n        // Don\\'t use stream Collectors.joining(\" \") here, even though it is more readable. The below is faster.\\n        StringBuilder line = new StringBuilder();\\n        line.append(words[start]);\\n        for (int i = start + 1; i < end; i++) {\\n            line.append(\" \");\\n            line.append(words[i]);\\n        }\\n        return line.toString() + \" \".repeat(maxWidth - lineLength);\\n    }\\n    \\n    private String constructLine(int start, int end, int lineLength) {\\n        int numSpaces = end - (start + 1);\\n        \\n        if (numSpaces == 0) { // Only one word in the line.\\n            return lineWithoutInterWordPadding(start, end, lineLength);\\n        }\\n        \\n        int padding = maxWidth - lineLength;       // Extra padding needed.\\n        int spaceNeeded = padding / numSpaces + 1; // Padding between each word (extra + minimum one).\\n        int leftOverSpaces = padding % numSpaces;  // Extra spaces that don\\'t divide evenly between words.\\n        \\n        StringBuilder line = new StringBuilder();\\n        line.append(words[start]);\\n        \\n        for (int i = start + 1; i < end; i++) {\\n            line.append(\" \".repeat(spaceNeeded));\\n            if (leftOverSpaces-- > 0) {\\n                line.append(\\' \\');\\n            }\\n            line.append(words[i]);\\n        }\\n        \\n        return line.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603795,
                "title": "c-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int n = words.size();\\n        string s;\\n        for(auto it:words) \\n        {\\n            if(s.length() + it.length() > maxWidth) \\n            {\\n                s = s.substr(1);\\n                s = add_spaces(s, s.length(), maxWidth, maxWidth-s.length());\\n                ans.push_back(s);\\n                s = \" \" + it;\\n            }\\n            else \\n            {\\n                s = s + \" \" + it;\\n            }\\n        }\\n        s = s.substr(1);\\n        ans.push_back(s);\\n        string tmp = ans.back();\\n        ans.pop_back();\\n        int sz = tmp.size();\\n        for(int i=0; i<maxWidth-sz; i++) tmp += \" \";\\n        ans.push_back(tmp);\\n        return ans;\\n    }\\n    \\n    string add_spaces(string s, int sz, int maxWidth, int extra) \\n    {\\n        int cnt = 0;\\n        vector<string> v;\\n        string tmp;\\n        \\n        // count total numbet=r of spaces necessary and storing all the words in given string\\n        for(int i=0; i<sz; i++) \\n        {\\n            if(s[i] != \\' \\') tmp += s[i];\\n            else {\\n                v.push_back(tmp);\\n                cnt++;\\n                tmp = \" \";\\n            }\\n        }\\n        v.push_back(tmp);\\n        extra += cnt;\\n        \\n        int tot = v.size();\\n        // if there\\'s only one word simply add spaces after the word\\n        if(cnt == 0) \\n        {\\n            string ans;\\n            ans += v[0];\\n            for(int i=0; i<extra; i++) ans += \" \";\\n            return ans;\\n        }\\n        \\n        string ans;\\n        // if total spaces are evenly divided between words\\n        // insert (totalSpaces)/(totalWords-1) spaces between each words\\n        if(extra % (tot-1) == 0) \\n        {\\n            for(int i=0; i<v.size(); i++) \\n            {\\n                ans += v[i];\\n                if(i != v.size()-1)\\n                {\\n                    for(int j=0; j<(extra/(tot-1))-1; j++) ans +=  \" \";\\n                }\\n            }\\n            return ans;\\n        } \\n        else // else insert extra spaces between first (totalSpaces)%(totalWords-1) words\\n        {\\n            int extra_space = extra % (tot-1);\\n            int y = extra / (tot-1);\\n            for(int i=0; i<v.size(); i++) \\n            {\\n                ans += v[i];\\n                if(i != v.size()-1)\\n                {\\n                    if(extra_space > 0) {\\n                        for(int j=0; j<y; j++) ans +=  \" \";\\n                        extra_space--;\\n                    }\\n                    else for(int j=0; j<y-1; j++) ans +=  \" \";\\n                }\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int n = words.size();\\n        string s;\\n        for(auto it:words) \\n        {\\n            if(s.length() + it.length() > maxWidth) \\n            {\\n                s = s.substr(1);\\n                s = add_spaces(s, s.length(), maxWidth, maxWidth-s.length());\\n                ans.push_back(s);\\n                s = \" \" + it;\\n            }\\n            else \\n            {\\n                s = s + \" \" + it;\\n            }\\n        }\\n        s = s.substr(1);\\n        ans.push_back(s);\\n        string tmp = ans.back();\\n        ans.pop_back();\\n        int sz = tmp.size();\\n        for(int i=0; i<maxWidth-sz; i++) tmp += \" \";\\n        ans.push_back(tmp);\\n        return ans;\\n    }\\n    \\n    string add_spaces(string s, int sz, int maxWidth, int extra) \\n    {\\n        int cnt = 0;\\n        vector<string> v;\\n        string tmp;\\n        \\n        // count total numbet=r of spaces necessary and storing all the words in given string\\n        for(int i=0; i<sz; i++) \\n        {\\n            if(s[i] != \\' \\') tmp += s[i];\\n            else {\\n                v.push_back(tmp);\\n                cnt++;\\n                tmp = \" \";\\n            }\\n        }\\n        v.push_back(tmp);\\n        extra += cnt;\\n        \\n        int tot = v.size();\\n        // if there\\'s only one word simply add spaces after the word\\n        if(cnt == 0) \\n        {\\n            string ans;\\n            ans += v[0];\\n            for(int i=0; i<extra; i++) ans += \" \";\\n            return ans;\\n        }\\n        \\n        string ans;\\n        // if total spaces are evenly divided between words\\n        // insert (totalSpaces)/(totalWords-1) spaces between each words\\n        if(extra % (tot-1) == 0) \\n        {\\n            for(int i=0; i<v.size(); i++) \\n            {\\n                ans += v[i];\\n                if(i != v.size()-1)\\n                {\\n                    for(int j=0; j<(extra/(tot-1))-1; j++) ans +=  \" \";\\n                }\\n            }\\n            return ans;\\n        } \\n        else // else insert extra spaces between first (totalSpaces)%(totalWords-1) words\\n        {\\n            int extra_space = extra % (tot-1);\\n            int y = extra / (tot-1);\\n            for(int i=0; i<v.size(); i++) \\n            {\\n                ans += v[i];\\n                if(i != v.size()-1)\\n                {\\n                    if(extra_space > 0) {\\n                        for(int j=0; j<y; j++) ans +=  \" \";\\n                        extra_space--;\\n                    }\\n                    else for(int j=0; j<y-1; j++) ans +=  \" \";\\n                }\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597909,
                "title": "python-solution-with-recursive-helper-function",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: list[str], maxWidth: int) -> list[str]:\\n        \"\"\"Given a list of words and a max line width, justify the text to fit each line.\\n        \\n        Take a greedy approach.\\n        Words by themselves AND the line will be left-justified.\\n            The last line will have no extra spaces between words.\\n        Normal lines will have spaces evenly distributed between words, with more\\n            spaces going to the left-most slots.\\n        \"\"\"\\n        output = []\\n\\n        while words:\\n            # Calling this with maxWidth + 1 accomodates for the \\n            # recursive fit_line function adding +1 space\\n            # for every word (when in reality there\\'s one less space than words)\\n            line = self.fit_line(words, maxWidth + 1)\\n            # This shortens the list to only include the remaining words,\\n            # and gives the loop a termination condition.\\n            words = words[len(line):]\\n\\n            # Case for the last line, or any line that only has one word.\\n            if len(line) == 1 or not words:\\n                output.append(self.left_justify(line, maxWidth))\\n            # Case for normal lines.\\n            else:\\n                output.append(self.center_justify(line, maxWidth))\\n        \\n        return output\\n    \\n    def fit_line(self, sublist: list[str], max_width) -> list[str]:\\n        \"\"\"Fit as many words as possible from sublist onto a line.\"\"\"\\n        # If the sublist is empty or if we can\\'t put anything else onto the line.\\n        if not sublist or max_width == 0:\\n            return []\\n        # We can\\'t fit any more words on this line (no more space left).\\n        elif len(sublist[0]) + 1 > max_width:\\n            return []\\n        else:\\n            # The first word in this list, plus the most words from the remaining\\n            # sublist that can fit. The +1 at the end is to account for the 1\\n            # mandatory space between words.\\n            return [sublist[0]] + self.fit_line(sublist[1:], max_width - (len(sublist[0]) + 1))\\n    \\n    def center_justify(self, sublist: list[str], max_width: int) -> str:\\n        \"\"\"Center justify the words in sublist, and return that as a string.\"\"\"\\n        # Calculate how much space we have left.\\n        space_left = self.find_space_left(sublist, max_width)\\n\\n        # Create space slots.\\n        # There are one less slots than number of words.\\n        space_slots = [\" \"] * (len(sublist) - 1)\\n\\n        slot_index = 0\\n        while space_left:\\n            space_slots[slot_index] += \" \"\\n            space_left -= 1\\n            # This will keep the index between 0 and the number of space_slots.\\n            slot_index += 1\\n            slot_index = slot_index % len(space_slots)\\n        \\n        # Add a blank space slot before the first word, now space_slots and\\n        # sublist have the same number of elements.\\n        space_slots.insert(0, \"\")\\n\\n        together = zip(space_slots, sublist)\\n        together = [s + w for s, w in together]\\n        return \"\".join(together)\\n    \\n    def left_justify(self, sublist: list[str], max_width: int) -> str:\\n        space_left = self.find_space_left(sublist, max_width)\\n        \\n        # Create space slots as though we were center justifying.\\n        # The difference is we don\\'t need to rotate bewteen slots.\\n        space_slots = [\"\"] + [\" \"] * (len(sublist) - 1)\\n\\n        # Join the words and the space slots.\\n        together = zip(space_slots, sublist)\\n        together = [s + w for s, w in together]\\n        output = \"\".join(together)\\n        # Add all the remaining spaces to the end.\\n        output += \" \" * space_left\\n\\n        return output\\n    \\n    def find_space_left(self, words: list[str], max_width: int) -> int:\\n        # The max width - minimum number of spaces - combined length of words.\\n        return max_width - (len(words) - 1) - sum([len(w) for w in words])\\n\\'\\'\\'\\n\\nThere\\'s probably room for some optimization, but I feel like this one is easy to understand.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: list[str], maxWidth: int) -> list[str]:\\n        \"\"\"Given a list of words and a max line width, justify the text to fit each line.\\n        \\n        Take a greedy approach.\\n        Words by themselves AND the line will be left-justified.\\n            The last line will have no extra spaces between words.\\n        Normal lines will have spaces evenly distributed between words, with more\\n            spaces going to the left-most slots.\\n        \"\"\"\\n        output = []\\n\\n        while words:\\n            # Calling this with maxWidth + 1 accomodates for the \\n            # recursive fit_line function adding +1 space\\n            # for every word (when in reality there\\'s one less space than words)\\n            line = self.fit_line(words, maxWidth + 1)\\n            # This shortens the list to only include the remaining words,\\n            # and gives the loop a termination condition.\\n            words = words[len(line):]\\n\\n            # Case for the last line, or any line that only has one word.\\n            if len(line) == 1 or not words:\\n                output.append(self.left_justify(line, maxWidth))\\n            # Case for normal lines.\\n            else:\\n                output.append(self.center_justify(line, maxWidth))\\n        \\n        return output\\n    \\n    def fit_line(self, sublist: list[str], max_width) -> list[str]:\\n        \"\"\"Fit as many words as possible from sublist onto a line.\"\"\"\\n        # If the sublist is empty or if we can\\'t put anything else onto the line.\\n        if not sublist or max_width == 0:\\n            return []\\n        # We can\\'t fit any more words on this line (no more space left).\\n        elif len(sublist[0]) + 1 > max_width:\\n            return []\\n        else:\\n            # The first word in this list, plus the most words from the remaining\\n            # sublist that can fit. The +1 at the end is to account for the 1\\n            # mandatory space between words.\\n            return [sublist[0]] + self.fit_line(sublist[1:], max_width - (len(sublist[0]) + 1))\\n    \\n    def center_justify(self, sublist: list[str], max_width: int) -> str:\\n        \"\"\"Center justify the words in sublist, and return that as a string.\"\"\"\\n        # Calculate how much space we have left.\\n        space_left = self.find_space_left(sublist, max_width)\\n\\n        # Create space slots.\\n        # There are one less slots than number of words.\\n        space_slots = [\" \"] * (len(sublist) - 1)\\n\\n        slot_index = 0\\n        while space_left:\\n            space_slots[slot_index] += \" \"\\n            space_left -= 1\\n            # This will keep the index between 0 and the number of space_slots.\\n            slot_index += 1\\n            slot_index = slot_index % len(space_slots)\\n        \\n        # Add a blank space slot before the first word, now space_slots and\\n        # sublist have the same number of elements.\\n        space_slots.insert(0, \"\")\\n\\n        together = zip(space_slots, sublist)\\n        together = [s + w for s, w in together]\\n        return \"\".join(together)\\n    \\n    def left_justify(self, sublist: list[str], max_width: int) -> str:\\n        space_left = self.find_space_left(sublist, max_width)\\n        \\n        # Create space slots as though we were center justifying.\\n        # The difference is we don\\'t need to rotate bewteen slots.\\n        space_slots = [\"\"] + [\" \"] * (len(sublist) - 1)\\n\\n        # Join the words and the space slots.\\n        together = zip(space_slots, sublist)\\n        together = [s + w for s, w in together]\\n        output = \"\".join(together)\\n        # Add all the remaining spaces to the end.\\n        output += \" \" * space_left\\n\\n        return output\\n    \\n    def find_space_left(self, words: list[str], max_width: int) -> int:\\n        # The max width - minimum number of spaces - combined length of words.\\n        return max_width - (len(words) - 1) - sum([len(w) for w in words])\\n\\'\\'\\'\\n\\nThere\\'s probably room for some optimization, but I feel like this one is easy to understand.",
                "codeTag": "Java"
            },
            {
                "id": 1590497,
                "title": "go-solution-0-ms-100-00-2-3-mb-52-44",
                "content": "```\\npackage main\\n\\nimport (\\n\\t\"fmt\"\\n\\t\"strings\"\\n)\\n\\n/*\\n\\n68. Text Justification\\n\\nhttps://leetcode.com/problems/text-justification/\\n\\n*/\\n\\nfunc nextWords(words []string, maxWidth int, index int) ([]string, int) {\\n\\tresult := make([]string, 0)\\n\\n\\twidth := 0\\n\\tfirst := true\\n\\n\\tfor {\\n\\t\\tif index >= len(words) {\\n\\t\\t\\treturn result, index\\n\\t\\t}\\n\\n\\t\\tword := words[index]\\n\\n\\t\\twidth += len(word)\\n\\t\\tif !first {\\n\\t\\t\\twidth++\\n\\t\\t} else {\\n\\t\\t\\tfirst = false\\n\\t\\t}\\n\\n\\t\\tif width > maxWidth {\\n\\t\\t\\treturn result, index\\n\\t\\t}\\n\\n\\t\\tresult = append(result, word)\\n\\n\\t\\tindex++\\n\\t}\\n}\\n\\nfunc generateRow(words []string, maxWidth int, lastRow bool) string {\\n\\tif lastRow {\\n\\t\\tresult := strings.Join(words, \" \")\\n\\n\\t\\treturn result + strings.Repeat(\" \", maxWidth-len(result))\\n\\t}\\n\\n\\ttotalWordsWidth := 0\\n\\tfor _, word := range words {\\n\\t\\ttotalWordsWidth += len(word)\\n\\t}\\n\\n\\tresult := \"\"\\n\\tfor index, word := range words {\\n\\t\\tresult += word\\n\\t\\ttotalWordsWidth -= len(word)\\n\\t\\textraSpace := maxWidth - len(result) - totalWordsWidth\\n\\t\\twordsLeft := len(words) - index - 1\\n\\n\\t\\tif wordsLeft == 0 {\\n\\t\\t\\tresult += strings.Repeat(\" \", maxWidth-len(result))\\n\\t\\t} else {\\n\\t\\t\\tresult += strings.Repeat(\" \", extraSpace/wordsLeft)\\n\\t\\t\\tif extraSpace%wordsLeft != 0 {\\n\\t\\t\\t\\tresult += \" \"\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc fullJustify(words []string, maxWidth int) []string {\\n\\tresults := make([]string, 0)\\n\\n\\tindex := 0\\n\\n\\tfor {\\n\\t\\tvar row []string\\n\\t\\trow, index = nextWords(words, maxWidth, index)\\n\\n\\t\\tresults = append(results, generateRow(row, maxWidth, index >= len(words)))\\n\\n\\t\\tif index >= len(words) {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn results\\n}\\n\\nfunc printResult(result []string) {\\n\\tfor _, row := range result {\\n\\t\\tfmt.Println(\"[\" + row + \"]\")\\n\\t}\\n\\n\\tfmt.Println()\\n}\\n\\nfunc main() {\\n\\twords1 := []string{\\n\\t\\t\"This\",\\n\\t\\t\"is\",\\n\\t\\t\"an\",\\n\\t\\t\"example\",\\n\\t\\t\"of\",\\n\\t\\t\"text\",\\n\\t\\t\"justification.\",\\n\\t}\\n\\n\\t// [This    is    an]\\n\\t// [example  of text]\\n\\t// [justification.  ]\\n\\n\\tprintResult(fullJustify(words1, 16))\\n\\n\\twords2 := []string{\\n\\t\\t\"What\",\\n\\t\\t\"must\",\\n\\t\\t\"be\",\\n\\t\\t\"acknowledgment\",\\n\\t\\t\"shall\",\\n\\t\\t\"be\",\\n\\t}\\n\\n\\t// [What   must   be]\\n\\t// [acknowledgment  ]\\n\\t// [shall be        ]\\n\\n\\tprintResult(fullJustify(words2, 16))\\n\\n\\twords3 := []string{\\n\\t\\t\"Science\",\\n\\t\\t\"is\",\\n\\t\\t\"what\",\\n\\t\\t\"we\",\\n\\t\\t\"understand\",\\n\\t\\t\"well\",\\n\\t\\t\"enough\",\\n\\t\\t\"to\",\\n\\t\\t\"explain\",\\n\\t\\t\"to\",\\n\\t\\t\"a\",\\n\\t\\t\"computer.\",\\n\\t\\t\"Art\",\\n\\t\\t\"is\",\\n\\t\\t\"everything\",\\n\\t\\t\"else\",\\n\\t\\t\"we\",\\n\\t\\t\"do\",\\n\\t}\\n\\n\\t// [Science  is  what we]\\n\\t// [understand      well]\\n\\t// [enough to explain to]\\n\\t// [a  computer.  Art is]\\n\\t// [everything  else  we]\\n\\t// [do                  ]\\n\\n\\tprintResult(fullJustify(words3, 20))\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Iterator"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"fmt\"\\n\\t\"strings\"\\n)\\n\\n/*\\n\\n68. Text Justification\\n\\nhttps://leetcode.com/problems/text-justification/\\n\\n*/\\n\\nfunc nextWords(words []string, maxWidth int, index int) ([]string, int) {\\n\\tresult := make([]string, 0)\\n\\n\\twidth := 0\\n\\tfirst := true\\n\\n\\tfor {\\n\\t\\tif index >= len(words) {\\n\\t\\t\\treturn result, index\\n\\t\\t}\\n\\n\\t\\tword := words[index]\\n\\n\\t\\twidth += len(word)\\n\\t\\tif !first {\\n\\t\\t\\twidth++\\n\\t\\t} else {\\n\\t\\t\\tfirst = false\\n\\t\\t}\\n\\n\\t\\tif width > maxWidth {\\n\\t\\t\\treturn result, index\\n\\t\\t}\\n\\n\\t\\tresult = append(result, word)\\n\\n\\t\\tindex++\\n\\t}\\n}\\n\\nfunc generateRow(words []string, maxWidth int, lastRow bool) string {\\n\\tif lastRow {\\n\\t\\tresult := strings.Join(words, \" \")\\n\\n\\t\\treturn result + strings.Repeat(\" \", maxWidth-len(result))\\n\\t}\\n\\n\\ttotalWordsWidth := 0\\n\\tfor _, word := range words {\\n\\t\\ttotalWordsWidth += len(word)\\n\\t}\\n\\n\\tresult := \"\"\\n\\tfor index, word := range words {\\n\\t\\tresult += word\\n\\t\\ttotalWordsWidth -= len(word)\\n\\t\\textraSpace := maxWidth - len(result) - totalWordsWidth\\n\\t\\twordsLeft := len(words) - index - 1\\n\\n\\t\\tif wordsLeft == 0 {\\n\\t\\t\\tresult += strings.Repeat(\" \", maxWidth-len(result))\\n\\t\\t} else {\\n\\t\\t\\tresult += strings.Repeat(\" \", extraSpace/wordsLeft)\\n\\t\\t\\tif extraSpace%wordsLeft != 0 {\\n\\t\\t\\t\\tresult += \" \"\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc fullJustify(words []string, maxWidth int) []string {\\n\\tresults := make([]string, 0)\\n\\n\\tindex := 0\\n\\n\\tfor {\\n\\t\\tvar row []string\\n\\t\\trow, index = nextWords(words, maxWidth, index)\\n\\n\\t\\tresults = append(results, generateRow(row, maxWidth, index >= len(words)))\\n\\n\\t\\tif index >= len(words) {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn results\\n}\\n\\nfunc printResult(result []string) {\\n\\tfor _, row := range result {\\n\\t\\tfmt.Println(\"[\" + row + \"]\")\\n\\t}\\n\\n\\tfmt.Println()\\n}\\n\\nfunc main() {\\n\\twords1 := []string{\\n\\t\\t\"This\",\\n\\t\\t\"is\",\\n\\t\\t\"an\",\\n\\t\\t\"example\",\\n\\t\\t\"of\",\\n\\t\\t\"text\",\\n\\t\\t\"justification.\",\\n\\t}\\n\\n\\t// [This    is    an]\\n\\t// [example  of text]\\n\\t// [justification.  ]\\n\\n\\tprintResult(fullJustify(words1, 16))\\n\\n\\twords2 := []string{\\n\\t\\t\"What\",\\n\\t\\t\"must\",\\n\\t\\t\"be\",\\n\\t\\t\"acknowledgment\",\\n\\t\\t\"shall\",\\n\\t\\t\"be\",\\n\\t}\\n\\n\\t// [What   must   be]\\n\\t// [acknowledgment  ]\\n\\t// [shall be        ]\\n\\n\\tprintResult(fullJustify(words2, 16))\\n\\n\\twords3 := []string{\\n\\t\\t\"Science\",\\n\\t\\t\"is\",\\n\\t\\t\"what\",\\n\\t\\t\"we\",\\n\\t\\t\"understand\",\\n\\t\\t\"well\",\\n\\t\\t\"enough\",\\n\\t\\t\"to\",\\n\\t\\t\"explain\",\\n\\t\\t\"to\",\\n\\t\\t\"a\",\\n\\t\\t\"computer.\",\\n\\t\\t\"Art\",\\n\\t\\t\"is\",\\n\\t\\t\"everything\",\\n\\t\\t\"else\",\\n\\t\\t\"we\",\\n\\t\\t\"do\",\\n\\t}\\n\\n\\t// [Science  is  what we]\\n\\t// [understand      well]\\n\\t// [enough to explain to]\\n\\t// [a  computer.  Art is]\\n\\t// [everything  else  we]\\n\\t// [do                  ]\\n\\n\\tprintResult(fullJustify(words3, 20))\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1566039,
                "title": "python-concise-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # number of characters that a group of words occupy is\\n        # numTotalLetters + words - 1 (for spaces)\\n        # The moment a new word causes this computation to exceed max width is when we introduce a new row\\n        # Spread the spaces of the remainder of maxwidth and this computation as spaces for each word in a round robin left to right \\n        \\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n                res.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        \\n        remainder = \\' \\'.join(cur)\\n        remainder += \\' \\' * (maxWidth - len(remainder))\\n        \\n        return res + [remainder]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # number of characters that a group of words occupy is\\n        # numTotalLetters + words - 1 (for spaces)\\n        # The moment a new word causes this computation to exceed max width is when we introduce a new row\\n        # Spread the spaces of the remainder of maxwidth and this computation as spaces for each word in a round robin left to right \\n        \\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n                res.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        \\n        remainder = \\' \\'.join(cur)\\n        remainder += \\' \\' * (maxWidth - len(remainder))\\n        \\n        return res + [remainder]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546004,
                "title": "java-simple-short-and-easy-for-dummies-like-me-heavily-commented",
                "content": "```\\n/*\\nBasic Idea:\\n1. Add words to each line until they fit within maxWidth\\n2. Calculate the extra spaces remaining, (maxWidth - characterCountAdded)\\n3. Distribute the extra spaces among every word in the line in a Round Robin Fashion. Now your line is justified.\\n4. Add the justified line to the resultList\\n5. Repeat it for the rest of the words\\n*/\\n\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        // ArrayList to store the justified text result\\n        List<String> result = new ArrayList<>();\\n        \\n        // ArrayList to store a justified line\\n        // We use StringBuilder instead of String, because we want to append spaces to it\\n        List<StringBuilder> line = new ArrayList<>();\\n        \\n        // No of characters in a given line\\n        int charCount = 0;\\n        \\n        for (String word : words) {\\n            \\n            int spacesNeeded = line.size(); // represents single space needed between words\\n            if (charCount + word.length() + spacesNeeded > maxWidth) {\\n                // We could not add the new word to the line\\n                // Hence, lets justify the words already present in the line\\n                \\n                // In order to justify, we need to calculate the extra spaces\\n                // and distribute the spaces among the words in a Round Robin Fashion\\n                int spacesAvailable = maxWidth - charCount;\\n                for (int i = 0; i < spacesAvailable; i++) {\\n                    if (line.size() == 1) {\\n                        // If there is only one word present in the line,\\n                        // keep adding all the available spaces to the end of the single word\\n                        line.get(0).append(\" \");    \\n                    } else {\\n                        // If there are more than 1 word in the line,\\n                        // Add spaces to every word one after the other, except the last word (question\\'s requirement)\\n                        // Since we do not want to add space to the last word, we are doing line.size() - 1, else it would be just line.size()\\n                        line.get(i % (line.size() - 1)).append(\" \");\\n                    }\\n                }\\n                \\n                // convert the line list to String\\n                // Since we already added all the necessary spacing,\\n                // we just need to join with empty string \"\"\\n                result.add(String.join(\"\", line));\\n                line.clear(); // empty the line\\n                charCount = 0; // clear the charCount\\n            }\\n            \\n            \\n            // Add the current word, because we are within the maxWidth\\n            line.add(new StringBuilder(word));\\n            charCount += word.length(); // Increment the charCount for the word added\\n            \\n        }\\n        \\n        // We are at the last line\\n        // Last line needs to be Left Justified,\\n        // meaning we still need to add all the extra spaces to the right\\n        if (!line.isEmpty()) { // check if line is not empty, (not sure if this is needed, just to be safe)\\n            // Build the lastLine String,\\n            // for which we need to join with a single space because we did not add any space before\\n            String lastLine = String.join(\" \", line);\\n            // Left Justification is done here,\\n            // Ex: String.format(\"%-6s\", \"12345\") will give \"12345 \"  (12345 and 1 extra space)\\n            // Ex: String.format(\"%-7s\", \"12345\") will give \"12345  \" (12345 and 2 extra spaces)\\n            // Ex: String.format(\"%-5s\", \"12345\") will give \"12345\"   (12345 and 0 extra spaces)\\n            String justifiedLastLine = String.format(\"%-\"+maxWidth+\"s\", lastLine);\\n            result.add(justifiedLastLine); // Add to result\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nBasic Idea:\\n1. Add words to each line until they fit within maxWidth\\n2. Calculate the extra spaces remaining, (maxWidth - characterCountAdded)\\n3. Distribute the extra spaces among every word in the line in a Round Robin Fashion. Now your line is justified.\\n4. Add the justified line to the resultList\\n5. Repeat it for the rest of the words\\n*/\\n\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        // ArrayList to store the justified text result\\n        List<String> result = new ArrayList<>();\\n        \\n        // ArrayList to store a justified line\\n        // We use StringBuilder instead of String, because we want to append spaces to it\\n        List<StringBuilder> line = new ArrayList<>();\\n        \\n        // No of characters in a given line\\n        int charCount = 0;\\n        \\n        for (String word : words) {\\n            \\n            int spacesNeeded = line.size(); // represents single space needed between words\\n            if (charCount + word.length() + spacesNeeded > maxWidth) {\\n                // We could not add the new word to the line\\n                // Hence, lets justify the words already present in the line\\n                \\n                // In order to justify, we need to calculate the extra spaces\\n                // and distribute the spaces among the words in a Round Robin Fashion\\n                int spacesAvailable = maxWidth - charCount;\\n                for (int i = 0; i < spacesAvailable; i++) {\\n                    if (line.size() == 1) {\\n                        // If there is only one word present in the line,\\n                        // keep adding all the available spaces to the end of the single word\\n                        line.get(0).append(\" \");    \\n                    } else {\\n                        // If there are more than 1 word in the line,\\n                        // Add spaces to every word one after the other, except the last word (question\\'s requirement)\\n                        // Since we do not want to add space to the last word, we are doing line.size() - 1, else it would be just line.size()\\n                        line.get(i % (line.size() - 1)).append(\" \");\\n                    }\\n                }\\n                \\n                // convert the line list to String\\n                // Since we already added all the necessary spacing,\\n                // we just need to join with empty string \"\"\\n                result.add(String.join(\"\", line));\\n                line.clear(); // empty the line\\n                charCount = 0; // clear the charCount\\n            }\\n            \\n            \\n            // Add the current word, because we are within the maxWidth\\n            line.add(new StringBuilder(word));\\n            charCount += word.length(); // Increment the charCount for the word added\\n            \\n        }\\n        \\n        // We are at the last line\\n        // Last line needs to be Left Justified,\\n        // meaning we still need to add all the extra spaces to the right\\n        if (!line.isEmpty()) { // check if line is not empty, (not sure if this is needed, just to be safe)\\n            // Build the lastLine String,\\n            // for which we need to join with a single space because we did not add any space before\\n            String lastLine = String.join(\" \", line);\\n            // Left Justification is done here,\\n            // Ex: String.format(\"%-6s\", \"12345\") will give \"12345 \"  (12345 and 1 extra space)\\n            // Ex: String.format(\"%-7s\", \"12345\") will give \"12345  \" (12345 and 2 extra spaces)\\n            // Ex: String.format(\"%-5s\", \"12345\") will give \"12345\"   (12345 and 0 extra spaces)\\n            String justifiedLastLine = String.format(\"%-\"+maxWidth+\"s\", lastLine);\\n            result.add(justifiedLastLine); // Add to result\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531563,
                "title": "c-solutuion",
                "content": "class Solution\\n{\\n\\tpublic:\\n\\t\\tvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n\\t\\t\\tvector<string> vec;\\n        \\n        int i = 0;\\n        \\n        while(i<words.size())\\n        {\\n            int j = i+1;\\n            int sum = words[i].length();\\n            int curr = 0;\\n            while(j<words.size() and sum+words[j].size()+1+curr<=maxWidth)\\n            {\\n                sum += words[j].length();\\n                j++;\\n                curr++;\\n            }\\n            string now = \"\";\\n            int extra = (curr==0)?0:(maxWidth - sum)/curr;\\n            int more = (curr==0)?0:(maxWidth - sum)%curr;\\n            if(j==words.size())\\n            {\\n                 for(int k=i;k<j;k++)\\n                {\\n                      now += words[k];\\n                     now += \" \";\\n                }\\n                now.pop_back();\\n            }\\n            else\\n            {\\n                 for(int k=i;k<j;k++)\\n                {\\n                    now += words[k];\\n                    if(k==j-1)\\n                        break;\\n                    for(int g=0;g<extra;g++)\\n                    {\\n                        now += \" \";\\n                    }\\n                    if(more)\\n                    {\\n                        now += \" \";\\n                        more--;\\n                    }\\n                }\\n            }\\n           \\n            cout<<now.length()<<\" \";\\n            while(now.length()<maxWidth)\\n                now += \" \";\\n            vec.push_back(now);\\n            i=j;\\n        }\\n        \\n        return vec;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution\\n{\\n\\tpublic:\\n\\t\\tvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n\\t\\t\\tvector<string> vec;\\n        \\n        int i = 0;\\n        \\n        while(i<words.size())\\n        {\\n            int j = i+1;\\n            int sum = words[i].length();\\n            int curr = 0;\\n            while(j<words.size() and sum+words[j].size()+1+curr<=maxWidth)\\n            {\\n                sum += words[j].length();\\n                j++;\\n                curr++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1525084,
                "title": "python-approach-with-comments-to-explain-the-logic",
                "content": "**I divided the code in 2 methods:**\\n1. One that have the Justify logic\\n2. The main method\\n\\nThe one with the Justify logic will check an edge case where only 1 word fits into the line so it has to fill blanks at the end of the line.\\n\\nThe rest is just calculating the length of the spaces and how many reminders are so we need to an extra space.\\n\\nThe main method will start with the first word in the current line and check if we can add another word to the line and meet the condition that fits in a line of max_width.\\n\\n**O(N) Time Complexity:** We have to traverse the words 1 time in the main method which is O(N) + another time when formatting which is O(N) and join method will traverse the words and its spaces ~O(N+N-1) = O(2N-1) which is in total O(4N) ~= O(N)\\n\\n**O(N) Space Complexity:** Current Line can store potentially all the words which is an additional space of O(N) + O(N+N-1) for the words and spaces in the formating which is still O(N) so the space will require O(3N-1) ~= O(N)\\n\\n```\\nclass Solution:\\n    \\n    # formatLine will justify left and right sizes or just left\\n    # if there are only 1 word\\n    def formatLine(self, line, cur_len, max_length):\\n        \\n        # If we have N words we need N-1 spaces to separate\\n        spaces = len(line) - 1\\n        if spaces == 0:\\n            line.append(\\' \\' * (max_length - cur_len))\\n            return \\'\\'.join(line)\\n        \\n        # To know the length of spaces we need to know the remaining\\n        # characters to fill the line (max_length - cur_len) and divide\\n        # this remaining characters between the amount of spaces\\n        space_length = (max_length - cur_len) // spaces\\n\\t\\t\\n        # We might have a reminder and we will use an extra space from left\\n        # to right until we fill the gaps\\n        space_reminders = (max_length - cur_len) % spaces\\n        \\n        sb = [line[0]]\\n        space = \\' \\' * space_length\\n        \\n        for i in range(1, len(line)):\\n            # space already have the right length except for the reminder\\n            sb.append(space)\\n            if space_reminders > 0:\\n                # adding one reminder if we have\\n                sb.append(\\' \\')\\n                space_reminders -= 1\\n            # Adding the actual word\\n            sb.append(line[i])\\n        \\n        # This will finally format the line\\n        return \\'\\'.join(sb)\\n    \\n    \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # line have all de words we can add in a single line\\n        line = [words[0]]\\n\\t\\t\\n        # length for all the words in the current line but not taking in count\\n        # the spaces\\n        cur_len = len(words[0])\\n\\t\\t\\n        # final answer\\n        ans = []\\n        \\n        for i in range(1, len(words)):\\n            # If we add another word there will be N+1 words in the line so we\\n            # need N spaces at least\\n            min_need_spaces = len(line)\\n            \\n            # If we add another word the minimum length of the line will be\\n            # the total length we have so far for that line + the length of the\\n            # word we want to add and the minimum amount of spaces that we need\\n            # to separate the words\\n            if (cur_len + len(words[i]) + min_need_spaces) > maxWidth:\\n                # If the condition is met, we can\\'t add another word\\n                ans.append(self.formatLine(line, cur_len, maxWidth))\\n\\t\\t\\t\\t\\n                # As the line has been formatted we start over\\n                line.clear()\\n                cur_len = 0\\n            \\n            line.append(words[i])\\n            cur_len += len(words[i])\\n        \\n        # We just fill the last line with spaces at the end so it reaches the maxWidth\\n        last = \\' \\'.join(line)\\n        ans.append(last + (\\' \\' * (maxWidth - len(last))))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    # formatLine will justify left and right sizes or just left\\n    # if there are only 1 word\\n    def formatLine(self, line, cur_len, max_length):\\n        \\n        # If we have N words we need N-1 spaces to separate\\n        spaces = len(line) - 1\\n        if spaces == 0:\\n            line.append(\\' \\' * (max_length - cur_len))\\n            return \\'\\'.join(line)\\n        \\n        # To know the length of spaces we need to know the remaining\\n        # characters to fill the line (max_length - cur_len) and divide\\n        # this remaining characters between the amount of spaces\\n        space_length = (max_length - cur_len) // spaces\\n\\t\\t\\n        # We might have a reminder and we will use an extra space from left\\n        # to right until we fill the gaps\\n        space_reminders = (max_length - cur_len) % spaces\\n        \\n        sb = [line[0]]\\n        space = \\' \\' * space_length\\n        \\n        for i in range(1, len(line)):\\n            # space already have the right length except for the reminder\\n            sb.append(space)\\n            if space_reminders > 0:\\n                # adding one reminder if we have\\n                sb.append(\\' \\')\\n                space_reminders -= 1\\n            # Adding the actual word\\n            sb.append(line[i])\\n        \\n        # This will finally format the line\\n        return \\'\\'.join(sb)\\n    \\n    \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # line have all de words we can add in a single line\\n        line = [words[0]]\\n\\t\\t\\n        # length for all the words in the current line but not taking in count\\n        # the spaces\\n        cur_len = len(words[0])\\n\\t\\t\\n        # final answer\\n        ans = []\\n        \\n        for i in range(1, len(words)):\\n            # If we add another word there will be N+1 words in the line so we\\n            # need N spaces at least\\n            min_need_spaces = len(line)\\n            \\n            # If we add another word the minimum length of the line will be\\n            # the total length we have so far for that line + the length of the\\n            # word we want to add and the minimum amount of spaces that we need\\n            # to separate the words\\n            if (cur_len + len(words[i]) + min_need_spaces) > maxWidth:\\n                # If the condition is met, we can\\'t add another word\\n                ans.append(self.formatLine(line, cur_len, maxWidth))\\n\\t\\t\\t\\t\\n                # As the line has been formatted we start over\\n                line.clear()\\n                cur_len = 0\\n            \\n            line.append(words[i])\\n            cur_len += len(words[i])\\n        \\n        # We just fill the last line with spaces at the end so it reaches the maxWidth\\n        last = \\' \\'.join(line)\\n        ans.append(last + (\\' \\' * (maxWidth - len(last))))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485789,
                "title": "object-oriented-approach-java",
                "content": "I solved this using an object-oriented approach where I created a `Line` object for each line that was going to be returned. Each `Line` object contains a list of words, and concatenates the words in its `toString()` method. I just found this approach clean, but in other regards it is no different from solutions already shared here. The `fullJustify` method itself is very small with this approach.\\n\\n```\\nclass Solution {\\n    private static final class Line {\\n        private int maxLength;\\n        private int currentLength = 0;\\n        private List<String> words = new ArrayList<>();\\n        private boolean lastWord = false;\\n        \\n        private Line(int maxLength) {\\n            this.maxLength = maxLength;\\n        }\\n        \\n        private boolean tryAdd(String word) {\\n            if (currentLength == 0) {\\n                currentLength += word.length();\\n                words.add(word);\\n                return true;\\n            }\\n            boolean canAddWord = currentLength + word.length() + 1 <= maxLength;\\n            if (canAddWord) {\\n                currentLength += word.length() + 1;\\n                words.add(word);\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        private void flagAsLastWord() {\\n            lastWord = true;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            if (lastWord) {\\n                return toStringLastWord();\\n            } else {\\n                return toStringNotLastWord();\\n            }\\n        }\\n        \\n        private String toStringNotLastWord() {\\n            \\n            int charCount = 0;\\n            for (String word : words) {\\n                charCount += word.length();\\n            }\\n            int emptySpaces = this.maxLength - charCount;\\n            int numEmptySpots = this.words.size() == 1 ? 1 : this.words.size() - 1;\\n            int spareSpaces = emptySpaces % numEmptySpots;\\n            int minSpacesPerSpot = emptySpaces / numEmptySpots;\\n            \\n            StringBuilder sb = new StringBuilder(this.maxLength);\\n            for (int i = 0; i < words.size(); i++) {\\n                String word = words.get(i);\\n                sb.append(word);\\n                if (emptySpaces > 0) {\\n                    int spacesAfterWord;\\n                    if (spareSpaces > 0) {\\n                        spacesAfterWord = minSpacesPerSpot + 1;\\n                        spareSpaces--;\\n                    } else {\\n                        spacesAfterWord = minSpacesPerSpot;\\n                    }\\n                    emptySpaces -= spacesAfterWord;\\n                    for (int j = 0; j < spacesAfterWord; j++) {\\n                        sb.append(\\' \\');\\n                    }\\n                }\\n                \\n            }\\n            return sb.toString();\\n        }\\n        \\n        private String toStringLastWord() {\\n            int charCount = 0;\\n            for (String word : words) {\\n                charCount += word.length();\\n            }\\n            int emptySpaces = this.maxLength - charCount;\\n            \\n            StringBuilder sb = new StringBuilder(this.maxLength);\\n            for (String word : words) {\\n                sb.append(word);\\n                if (emptySpaces > 0) {\\n                    sb.append(\\' \\');\\n                    emptySpaces--;\\n                }\\n            }\\n            for (int i = 0; i < emptySpaces; i++) {\\n                sb.append(\\' \\');\\n            }\\n            return sb.toString();\\n        }\\n    }\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        List<Line> lines = new ArrayList<>();\\n        lines.add(new Line(maxWidth));\\n        \\n        for (String word : words) {\\n            Line last = lines.get(lines.size() - 1);\\n            if (!last.tryAdd(word)) {\\n                Line newLine = new Line(maxWidth);\\n                lines.add(newLine);\\n                newLine.tryAdd(word);\\n            }\\n        }\\n        \\n        Line last = lines.get(lines.size() - 1);\\n        last.flagAsLastWord();\\n        \\n        List<String> result = new ArrayList<>(lines.size());\\n        for (Line line : lines) {\\n            result.add(line.toString());\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final class Line {\\n        private int maxLength;\\n        private int currentLength = 0;\\n        private List<String> words = new ArrayList<>();\\n        private boolean lastWord = false;\\n        \\n        private Line(int maxLength) {\\n            this.maxLength = maxLength;\\n        }\\n        \\n        private boolean tryAdd(String word) {\\n            if (currentLength == 0) {\\n                currentLength += word.length();\\n                words.add(word);\\n                return true;\\n            }\\n            boolean canAddWord = currentLength + word.length() + 1 <= maxLength;\\n            if (canAddWord) {\\n                currentLength += word.length() + 1;\\n                words.add(word);\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        private void flagAsLastWord() {\\n            lastWord = true;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            if (lastWord) {\\n                return toStringLastWord();\\n            } else {\\n                return toStringNotLastWord();\\n            }\\n        }\\n        \\n        private String toStringNotLastWord() {\\n            \\n            int charCount = 0;\\n            for (String word : words) {\\n                charCount += word.length();\\n            }\\n            int emptySpaces = this.maxLength - charCount;\\n            int numEmptySpots = this.words.size() == 1 ? 1 : this.words.size() - 1;\\n            int spareSpaces = emptySpaces % numEmptySpots;\\n            int minSpacesPerSpot = emptySpaces / numEmptySpots;\\n            \\n            StringBuilder sb = new StringBuilder(this.maxLength);\\n            for (int i = 0; i < words.size(); i++) {\\n                String word = words.get(i);\\n                sb.append(word);\\n                if (emptySpaces > 0) {\\n                    int spacesAfterWord;\\n                    if (spareSpaces > 0) {\\n                        spacesAfterWord = minSpacesPerSpot + 1;\\n                        spareSpaces--;\\n                    } else {\\n                        spacesAfterWord = minSpacesPerSpot;\\n                    }\\n                    emptySpaces -= spacesAfterWord;\\n                    for (int j = 0; j < spacesAfterWord; j++) {\\n                        sb.append(\\' \\');\\n                    }\\n                }\\n                \\n            }\\n            return sb.toString();\\n        }\\n        \\n        private String toStringLastWord() {\\n            int charCount = 0;\\n            for (String word : words) {\\n                charCount += word.length();\\n            }\\n            int emptySpaces = this.maxLength - charCount;\\n            \\n            StringBuilder sb = new StringBuilder(this.maxLength);\\n            for (String word : words) {\\n                sb.append(word);\\n                if (emptySpaces > 0) {\\n                    sb.append(\\' \\');\\n                    emptySpaces--;\\n                }\\n            }\\n            for (int i = 0; i < emptySpaces; i++) {\\n                sb.append(\\' \\');\\n            }\\n            return sb.toString();\\n        }\\n    }\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        List<Line> lines = new ArrayList<>();\\n        lines.add(new Line(maxWidth));\\n        \\n        for (String word : words) {\\n            Line last = lines.get(lines.size() - 1);\\n            if (!last.tryAdd(word)) {\\n                Line newLine = new Line(maxWidth);\\n                lines.add(newLine);\\n                newLine.tryAdd(word);\\n            }\\n        }\\n        \\n        Line last = lines.get(lines.size() - 1);\\n        last.flagAsLastWord();\\n        \\n        List<String> result = new ArrayList<>(lines.size());\\n        for (Line line : lines) {\\n            result.add(line.toString());\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465043,
                "title": "java-simple-implementation-faster-than-100",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> list = new ArrayList<>();\\n        int i = 0;\\n        while(true){\\n            List<String> al = new ArrayList<>();\\n            int len = 0;\\n            while(i < words.length && len + words[i].length() <= maxWidth){\\n                al.add(words[i]);\\n                len += words[i].length() + 1;\\n                i++;\\n            }\\n            len--;\\n            int remLen = maxWidth - len;\\n            if(i == words.length){\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                int j = 1;\\n                while(j < al.size()){\\n                    sb.append(\" \");\\n                    sb.append(al.get(j++));\\n                }\\n                while(remLen-- > 0)\\n                    sb.append(\" \");\\n                list.add(sb.toString());\\n                break;\\n            } else if(al.size() == 1){\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                while(remLen-- > 0)\\n                    sb.append(\" \");\\n                list.add(sb.toString());\\n            } else{\\n                int div = remLen / (al.size() - 1), rem = remLen % (al.size() - 1);\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                int j = 1;\\n                while(j < al.size()){\\n                    sb.append(\" \");\\n                    for(int k = 0; k < div; k++)\\n                        sb.append(\" \");\\n                    if(rem-- > 0)\\n                        sb.append(\" \");\\n                    sb.append(al.get(j++));\\n                }\\n                list.add(sb.toString());\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> list = new ArrayList<>();\\n        int i = 0;\\n        while(true){\\n            List<String> al = new ArrayList<>();\\n            int len = 0;\\n            while(i < words.length && len + words[i].length() <= maxWidth){\\n                al.add(words[i]);\\n                len += words[i].length() + 1;\\n                i++;\\n            }\\n            len--;\\n            int remLen = maxWidth - len;\\n            if(i == words.length){\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                int j = 1;\\n                while(j < al.size()){\\n                    sb.append(\" \");\\n                    sb.append(al.get(j++));\\n                }\\n                while(remLen-- > 0)\\n                    sb.append(\" \");\\n                list.add(sb.toString());\\n                break;\\n            } else if(al.size() == 1){\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                while(remLen-- > 0)\\n                    sb.append(\" \");\\n                list.add(sb.toString());\\n            } else{\\n                int div = remLen / (al.size() - 1), rem = remLen % (al.size() - 1);\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                int j = 1;\\n                while(j < al.size()){\\n                    sb.append(\" \");\\n                    for(int k = 0; k < div; k++)\\n                        sb.append(\" \");\\n                    if(rem-- > 0)\\n                        sb.append(\" \");\\n                    sb.append(al.get(j++));\\n                }\\n                list.add(sb.toString());\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435489,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // step 1: find words that can fit this line\\n        // step 2: justify\\n        int start = 0, end = 0;\\n        vector<string> res;\\n        while (end < words.size()) {\\n            int len = 0, total = 0;\\n            while (end < words.size() && len + words[end].size() <= maxWidth) {\\n                len += words[end].size() + 1;\\n                total += words[end].size();\\n                ++end;\\n            }\\n            bool isLast = (end == words.size());\\n            res.push_back(justify(words, start, end, maxWidth - total, isLast));\\n            start = end;\\n        }\\n        return res;\\n    }\\n    \\n    string justify(const vector<string>& words, int start, int end, int space, bool isLast) {\\n        string line;\\n        if (!isLast) {\\n            // eg: \"Science  is  what we\" maxwidth = 20\\n            // characters: 7 + 2 + 4 + 2 = 15\\n            // left = 20 - 15 = 5\\n            // 5/3 => 5 % 3 != 0? => space 1 = 5/3 + 1 = 2\\n            // 3/2 -> 3 % 2 != 0? => space 2 = 3/2 + 1 = 2\\n            // 1 => space 3 = 1\\n\\t\\t\\tint count = end - start - 1;  // number of space slots = number of words - 1\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (count > 0) {\\n                    int cur = space % count != 0? space/count + 1: space/count;\\n                    line.insert(line.end(), cur, \\' \\');\\n                    space -= cur;\\n                    --count;\\n                }\\n            }\\n        } else {\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (space-- > 0) line.push_back(\\' \\');\\n            }\\n        }\\n        if (space > 0) line.insert(line.end(), space, \\' \\');\\n        return line;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // step 1: find words that can fit this line\\n        // step 2: justify\\n        int start = 0, end = 0;\\n        vector<string> res;\\n        while (end < words.size()) {\\n            int len = 0, total = 0;\\n            while (end < words.size() && len + words[end].size() <= maxWidth) {\\n                len += words[end].size() + 1;\\n                total += words[end].size();\\n                ++end;\\n            }\\n            bool isLast = (end == words.size());\\n            res.push_back(justify(words, start, end, maxWidth - total, isLast));\\n            start = end;\\n        }\\n        return res;\\n    }\\n    \\n    string justify(const vector<string>& words, int start, int end, int space, bool isLast) {\\n        string line;\\n        if (!isLast) {\\n            // eg: \"Science  is  what we\" maxwidth = 20\\n            // characters: 7 + 2 + 4 + 2 = 15\\n            // left = 20 - 15 = 5\\n            // 5/3 => 5 % 3 != 0? => space 1 = 5/3 + 1 = 2\\n            // 3/2 -> 3 % 2 != 0? => space 2 = 3/2 + 1 = 2\\n            // 1 => space 3 = 1\\n\\t\\t\\tint count = end - start - 1;  // number of space slots = number of words - 1\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (count > 0) {\\n                    int cur = space % count != 0? space/count + 1: space/count;\\n                    line.insert(line.end(), cur, \\' \\');\\n                    space -= cur;\\n                    --count;\\n                }\\n            }\\n        } else {\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (space-- > 0) line.push_back(\\' \\');\\n            }\\n        }\\n        if (space > 0) line.insert(line.end(), space, \\' \\');\\n        return line;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429859,
                "title": "simplest-and-cleanest-solutions-java-and-python",
                "content": "Java\\n```\\nclass Solution {\\n    public void appendSpaces(StringBuilder sb, int spaces) {\\n        for (int i = 0; i < spaces; i++) {\\n            sb.append(\\' \\');\\n        }\\n    }\\n    \\n    public String makeLeftJustifiedLine(List<String> row, int totalSpaces) {\\n        StringBuilder sb = new StringBuilder(row.get(0));\\n        for (int i = 1; i < row.size(); i++) {\\n            sb.append(\\' \\');\\n            sb.append(row.get(i));\\n        }\\n        appendSpaces(sb, totalSpaces + 1 - row.size());\\n        return sb.toString();\\n    }\\n    \\n    public String makeJustifiedLine(List<String> row, int totalSpaces) {\\n        StringBuilder sb = new StringBuilder(row.get(0));\\n        if (row.size() <= 1) {\\n            // only one word in row: left-justify\\n            appendSpaces(sb, totalSpaces);\\n        } else {\\n            int n = row.size() - 1;\\n            // distribute total spaces among n slots\\n            int q = totalSpaces / n;\\n            int r = totalSpaces % n;\\n            for (int i = 1; i <= n; i++) {\\n                int spaces = q + (i <= r ? 1 : 0);\\n                appendSpaces(sb, spaces);\\n                sb.append(row.get(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        ArrayList<String> result = new ArrayList<>();\\n        ArrayList<String> row = new ArrayList<>();\\n        int charCount = 0;\\n        for (String word : words) {\\n            // check if we exceed maxWidth if we add word to the current row\\n            // remember that for k words, we need at least k-1 spaces\\n            if (charCount + word.length() + row.size() > maxWidth) {\\n                result.add(makeJustifiedLine(row, maxWidth - charCount));\\n                row.clear();\\n                charCount = 0;\\n            }\\n            row.add(word);\\n            charCount += word.length();\\n        }\\n        // last row is left-justified\\n        result.add(makeLeftJustifiedLine(row, maxWidth - charCount));\\n        return result;\\n    }\\n}\\n```\\nPython3\\n```\\n class Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def makeLeftJustifiedLine(wordsRow, totalSpaces):\\n            return \\' \\'.join(wordsRow) + (\\' \\' *  (totalSpaces + 1 - len(wordsRow)))\\n        def makeJustifiedLine(wordsRow, totalSpaces):\\n            l = len(wordsRow)\\n            if l <= 1:\\n                return \\'\\'.join(wordsRow) + (\\' \\' * totalSpaces)\\n            # distribute total spaces among l-1 slots\\n            q, r = divmod(totalSpaces, l-1)\\n            line = [wordsRow[0]]\\n            for i in range(1,l):\\n                spaces = q + (1 if i <= r else 0)\\n                line.append(\\' \\' * spaces)\\n                line.append(wordsRow[i])\\n            return \\'\\'.join(line)\\n        result = []\\n        row = []\\n        charCount = 0\\n        for word in words:\\n            # check if we exceed maxWidth if we add word to the current row\\n            # remember that for k words, we need at least k-1 spaces\\n            if charCount + len(word) + len(row) > maxWidth:\\n                result.append(makeJustifiedLine(row, maxWidth - charCount))\\n                row.clear()\\n                charCount = 0\\n            row.append(word)\\n            charCount += len(word)\\n        # last row is left-justified\\n        result.append(makeLeftJustifiedLine(row, maxWidth - charCount))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void appendSpaces(StringBuilder sb, int spaces) {\\n        for (int i = 0; i < spaces; i++) {\\n            sb.append(\\' \\');\\n        }\\n    }\\n    \\n    public String makeLeftJustifiedLine(List<String> row, int totalSpaces) {\\n        StringBuilder sb = new StringBuilder(row.get(0));\\n        for (int i = 1; i < row.size(); i++) {\\n            sb.append(\\' \\');\\n            sb.append(row.get(i));\\n        }\\n        appendSpaces(sb, totalSpaces + 1 - row.size());\\n        return sb.toString();\\n    }\\n    \\n    public String makeJustifiedLine(List<String> row, int totalSpaces) {\\n        StringBuilder sb = new StringBuilder(row.get(0));\\n        if (row.size() <= 1) {\\n            // only one word in row: left-justify\\n            appendSpaces(sb, totalSpaces);\\n        } else {\\n            int n = row.size() - 1;\\n            // distribute total spaces among n slots\\n            int q = totalSpaces / n;\\n            int r = totalSpaces % n;\\n            for (int i = 1; i <= n; i++) {\\n                int spaces = q + (i <= r ? 1 : 0);\\n                appendSpaces(sb, spaces);\\n                sb.append(row.get(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        ArrayList<String> result = new ArrayList<>();\\n        ArrayList<String> row = new ArrayList<>();\\n        int charCount = 0;\\n        for (String word : words) {\\n            // check if we exceed maxWidth if we add word to the current row\\n            // remember that for k words, we need at least k-1 spaces\\n            if (charCount + word.length() + row.size() > maxWidth) {\\n                result.add(makeJustifiedLine(row, maxWidth - charCount));\\n                row.clear();\\n                charCount = 0;\\n            }\\n            row.add(word);\\n            charCount += word.length();\\n        }\\n        // last row is left-justified\\n        result.add(makeLeftJustifiedLine(row, maxWidth - charCount));\\n        return result;\\n    }\\n}\\n```\n```\\n class Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def makeLeftJustifiedLine(wordsRow, totalSpaces):\\n            return \\' \\'.join(wordsRow) + (\\' \\' *  (totalSpaces + 1 - len(wordsRow)))\\n        def makeJustifiedLine(wordsRow, totalSpaces):\\n            l = len(wordsRow)\\n            if l <= 1:\\n                return \\'\\'.join(wordsRow) + (\\' \\' * totalSpaces)\\n            # distribute total spaces among l-1 slots\\n            q, r = divmod(totalSpaces, l-1)\\n            line = [wordsRow[0]]\\n            for i in range(1,l):\\n                spaces = q + (1 if i <= r else 0)\\n                line.append(\\' \\' * spaces)\\n                line.append(wordsRow[i])\\n            return \\'\\'.join(line)\\n        result = []\\n        row = []\\n        charCount = 0\\n        for word in words:\\n            # check if we exceed maxWidth if we add word to the current row\\n            # remember that for k words, we need at least k-1 spaces\\n            if charCount + len(word) + len(row) > maxWidth:\\n                result.append(makeJustifiedLine(row, maxWidth - charCount))\\n                row.clear()\\n                charCount = 0\\n            row.append(word)\\n            charCount += len(word)\\n        # last row is left-justified\\n        result.append(makeLeftJustifiedLine(row, maxWidth - charCount))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331025,
                "title": "python-easy-to-understand",
                "content": "```python\\nclass Solution:\\n    def fullJustify(self, words: List[str], max_width: int) -> List[str]:        \\n        def left_justify(line):\\n            tmp = \" \".join(line)\\n            return tmp + \" \" * (max_width - len(tmp))\\n\\n        def justify(line):\\n            number_of_spaces = len(line) - 1\\n            if number_of_spaces == 0:\\n                return left_justify(line)\\n            \\n            available_space = max_width - sum(len(w) for w in line)\\n            space_size = available_space // number_of_spaces\\n            extra = available_space % number_of_spaces\\n            \\n            result = \"\"\\n            for i, word in enumerate(line):\\n                result += word\\n                if i != len(line) - 1:\\n                    result += \" \" * (space_size + int(i < extra))\\n            return result\\n        \\n        result = []\\n        current = [words[0]]\\n        counter = len(words[0])\\n\\n        for word in words[1:]:\\n            if counter + 1 + len(word) <= max_width:\\n                current.append(word)\\n                counter += 1 + len(word)\\n            else:\\n                result.append(justify(current))\\n                current = [word]\\n                counter = len(word)\\n        \\n        result.append(left_justify(current))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def fullJustify(self, words: List[str], max_width: int) -> List[str]:        \\n        def left_justify(line):\\n            tmp = \" \".join(line)\\n            return tmp + \" \" * (max_width - len(tmp))\\n\\n        def justify(line):\\n            number_of_spaces = len(line) - 1\\n            if number_of_spaces == 0:\\n                return left_justify(line)\\n            \\n            available_space = max_width - sum(len(w) for w in line)\\n            space_size = available_space // number_of_spaces\\n            extra = available_space % number_of_spaces\\n            \\n            result = \"\"\\n            for i, word in enumerate(line):\\n                result += word\\n                if i != len(line) - 1:\\n                    result += \" \" * (space_size + int(i < extra))\\n            return result\\n        \\n        result = []\\n        current = [words[0]]\\n        counter = len(words[0])\\n\\n        for word in words[1:]:\\n            if counter + 1 + len(word) <= max_width:\\n                current.append(word)\\n                counter += 1 + len(word)\\n            else:\\n                result.append(justify(current))\\n                current = [word]\\n                counter = len(word)\\n        \\n        result.append(left_justify(current))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316379,
                "title": "java-solution-with-detailed-explanation-0ms-100-runtime-97-memory",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        int wordCount = 0;\\n        int lastIndex = 0;\\n        int runningLength=0;\\n        List<String> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            String s = words[i];\\n            /**\\n            * runningLength : total length of words until current word is added\\n            * s.length() : length of current word\\n            * wordCount : count of words till now (represents minimum spaces we would need with all the words already include)\\n            * Adding all of this tells us if current word can fit into current line\\n            *\\n            */\\n            if (runningLength + s.length() + wordCount > maxWidth) {\\n                //create a line since adding current word crosses the width\\n                int extraSpace = maxWidth - runningLength;\\n                // space per word, but not if wordCount is only 1                 \\n                int spw = wordCount > 1 ? extraSpace / (wordCount - 1) : 0;\\n                // left over spaces which need to be added 1 after each word until it last\\n                int los = wordCount > 1 ? extraSpace % (wordCount - 1) : 0;\\n                // construct line\\n                result.add(constructLine(words, lastIndex, wordCount, spw, los, maxWidth));\\n                // reset word count and running length\\n                wordCount = 0;\\n                runningLength = 0;\\n                // update last index to indicate index of word to start new line from\\n                lastIndex = i;\\n            }\\n            // add word length to running length\\n            runningLength += s.length();             \\n            wordCount ++;\\n        }\\n        // last line\\n        if (runningLength > 0) {\\n            result.add(constructLine(words, lastIndex, wordCount, 1, 0, maxWidth));\\n        }\\n        return result;\\n    }\\n    \\n    private String constructLine(String[] words, int li, int n, int spw, int los, int maxWidth) {\\n        StringBuffer sb = new StringBuffer();\\n        // start appending words in the line\\n        for (int i = li; i < li + n - 1; i ++) {\\n            sb.append(words[i]);\\n            // append `space per word` spaces after each word, until last word\\n            for (int j = 0; j < spw; j++) {\\n                sb.append(\" \");\\n            }\\n            // append one space from `left over space` after each word, and decrement left over space\\n            sb.append(los-- > 0 ? \" \" : \"\");\\n        }\\n        // append last word\\n        sb.append(words[li + n - 1]);\\n        \\n        // this is specifically for situation when line length still not matches width, append spaces at the end\\n        // Two situation can lead to this:\\n        // 1. line only has one word, so we are not adding any space from above logic\\n        // 2. its last line, so  we are only adding one space per word\\n        if (sb.length() < maxWidth) {\\n            int diff = maxWidth - sb.length();\\n            while (diff-- > 0) {\\n                sb.append(\" \");\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        int wordCount = 0;\\n        int lastIndex = 0;\\n        int runningLength=0;\\n        List<String> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            String s = words[i];\\n            /**\\n            * runningLength : total length of words until current word is added\\n            * s.length() : length of current word\\n            * wordCount : count of words till now (represents minimum spaces we would need with all the words already include)\\n            * Adding all of this tells us if current word can fit into current line\\n            *\\n            */\\n            if (runningLength + s.length() + wordCount > maxWidth) {\\n                //create a line since adding current word crosses the width\\n                int extraSpace = maxWidth - runningLength;\\n                // space per word, but not if wordCount is only 1                 \\n                int spw = wordCount > 1 ? extraSpace / (wordCount - 1) : 0;\\n                // left over spaces which need to be added 1 after each word until it last\\n                int los = wordCount > 1 ? extraSpace % (wordCount - 1) : 0;\\n                // construct line\\n                result.add(constructLine(words, lastIndex, wordCount, spw, los, maxWidth));\\n                // reset word count and running length\\n                wordCount = 0;\\n                runningLength = 0;\\n                // update last index to indicate index of word to start new line from\\n                lastIndex = i;\\n            }\\n            // add word length to running length\\n            runningLength += s.length();             \\n            wordCount ++;\\n        }\\n        // last line\\n        if (runningLength > 0) {\\n            result.add(constructLine(words, lastIndex, wordCount, 1, 0, maxWidth));\\n        }\\n        return result;\\n    }\\n    \\n    private String constructLine(String[] words, int li, int n, int spw, int los, int maxWidth) {\\n        StringBuffer sb = new StringBuffer();\\n        // start appending words in the line\\n        for (int i = li; i < li + n - 1; i ++) {\\n            sb.append(words[i]);\\n            // append `space per word` spaces after each word, until last word\\n            for (int j = 0; j < spw; j++) {\\n                sb.append(\" \");\\n            }\\n            // append one space from `left over space` after each word, and decrement left over space\\n            sb.append(los-- > 0 ? \" \" : \"\");\\n        }\\n        // append last word\\n        sb.append(words[li + n - 1]);\\n        \\n        // this is specifically for situation when line length still not matches width, append spaces at the end\\n        // Two situation can lead to this:\\n        // 1. line only has one word, so we are not adding any space from above logic\\n        // 2. its last line, so  we are only adding one space per word\\n        if (sb.length() < maxWidth) {\\n            int diff = maxWidth - sb.length();\\n            while (diff-- > 0) {\\n                sb.append(\" \");\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242044,
                "title": "easy-to-understand-java-solution-with-comments",
                "content": "Ask of the problem is to justify the words on each line. For the solution, we will try to place each word on the current line. We will try to fit as many words as we can on each line by trying to keep \"at least one space\" between each word.\\n\\nLogic is straightforward:\\n*  Iterate over each word and ask:\\n\\t*  Can this word \"fit\" on the current line?\\n\\t\\t*  If yes, add it to the sentence list, reduce the remaining characters\\n\\t\\t*  If no, Justify all the words added so far in the sentence and reiterate on this word so that it can be considered for next line\\n\\t\\t\\t*  If there\\'s only one word on this line, we leftJustify() it\\n\\t\\t\\t*  For more than one word, we fullJustify() them\\n*  How do we determine whether the current word will \"fit\" on the current line?\\n\\t*  By comparing the length of the current word with the remaining character count\\n\\t*  if the word.length() <= remaining, it fits\\n\\t*  In this case, remaining = remaining - (word.length()+1)\\n\\t*  Why + 1 ? Because there must be \"at least one space\" between this word and next word\\n*  What about the last line?\\n\\t*  In case of the last line, we will reach the end of the array and there will be still some words in the sentence list, we will simply call leftJustify()\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        //Stores num of words on each line in the output\\n        int numWords = 0;\\n        //Stores the sum of lengths of all the words on a line in the output - Doesn\\'t account for spaces\\n        int sum = 0;\\n        //Stores how many more characters are remaining on the current line of the output\\n        int remaining = maxWidth;\\n        //Stores all the words that will go on the current line of the output\\n        List<String> sentence = new ArrayList<>();\\n        for(int i = 0; i < words.length; i++) {\\n            //Checks if the word can be chosen for current line\\n            if(words[i].length() <= remaining) {\\n                //If the word is chosen for current line, add it to sentence list\\n                sentence.add(words[i]);\\n                //Remaining = Remaining - size of the word + 1 character for space after it\\n                remaining -= (words[i].length()+1);\\n                //Increasing num of words on this line of the output\\n                numWords++;\\n                //sum = sum of length of all the words on current line + length of chosen word\\n                sum += words[i].length();\\n            }\\n            //If the word can\\'t fit on the current line, Justify the words of current line and\\n            //Iterate over this word again to consider it for next line\\n            else {\\n                //Checking if the line has more than 1 word\\n                if(numWords > 1) {\\n                    //space[] stores the number of space between each word\\n                    //Total number of spaces = maxWidth-sum\\n                    //Total number of slots for spaces = numWords - 1\\n                    //eg: \"Science is what we\" - numWords = 4, total slots for spaces = 4-1 = 3 (between each word)\\n                    int[] space = new int[numWords-1];\\n                    calcSpaces(space, maxWidth-sum);\\n                    res.add(fullJustify(sentence, space));\\n                } else {\\n                    res.add(leftJustify(sentence, maxWidth));\\n                }\\n                //Since the current word was not taken on current line, we need to reiterate on this word, therefore --i\\n                --i;\\n                //Reinitializing all the counters for next line\\n                sum = 0;\\n                numWords = 0;\\n                remaining = maxWidth;\\n                sentence = new ArrayList<>();\\n            }\\n        }\\n        //If the sentence still has words, then leftJustify the sentence\\n        //Eg: \"Leetcode is fun\", maxWidth = 20\\n        //All the words fit on same line, so leftJustify. This is also useful for last line of the output\\n        if(!sentence.isEmpty()) {\\n            res.add(leftJustify(sentence, maxWidth));\\n        }\\n        return res;\\n    }\\n    \\n    void calcSpaces(int[] space, int numSpace) {\\n        int n = space.length;\\n        Arrays.fill(space, numSpace/n);\\n        int remaining = numSpace%n;\\n        int i = 0;\\n        while(remaining > 0) {\\n            space[i]++;\\n            ++i;\\n            --remaining;\\n        }\\n    }\\n    \\n    String leftJustify(List<String> sentence, int maxWidth) {\\n        StringBuilder sb = new StringBuilder();\\n        for(String w : sentence) {\\n            sb.append(w).append(\" \");\\n        }\\n        //In case the last character of the last word of the sentence occupy maxWidth, we don\\'t need that leading space, so removing it\\n        sb.deleteCharAt(sb.length()-1);\\n        //Padding with spaces to reach maxWidth\\n        while(sb.length() < maxWidth) {\\n            sb.append(\" \");\\n        }\\n        return sb.toString();\\n    }\\n    \\n    String fullJustify(List<String> sentence, int[] space) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < sentence.size()-1; i++) {\\n            sb.append(sentence.get(i));\\n            while(space[i] > 0) {\\n                sb.append(\" \");\\n                space[i]--;\\n            }\\n        }\\n        sb.append(sentence.get(sentence.size()-1));\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        //Stores num of words on each line in the output\\n        int numWords = 0;\\n        //Stores the sum of lengths of all the words on a line in the output - Doesn\\'t account for spaces\\n        int sum = 0;\\n        //Stores how many more characters are remaining on the current line of the output\\n        int remaining = maxWidth;\\n        //Stores all the words that will go on the current line of the output\\n        List<String> sentence = new ArrayList<>();\\n        for(int i = 0; i < words.length; i++) {\\n            //Checks if the word can be chosen for current line\\n            if(words[i].length() <= remaining) {\\n                //If the word is chosen for current line, add it to sentence list\\n                sentence.add(words[i]);\\n                //Remaining = Remaining - size of the word + 1 character for space after it\\n                remaining -= (words[i].length()+1);\\n                //Increasing num of words on this line of the output\\n                numWords++;\\n                //sum = sum of length of all the words on current line + length of chosen word\\n                sum += words[i].length();\\n            }\\n            //If the word can\\'t fit on the current line, Justify the words of current line and\\n            //Iterate over this word again to consider it for next line\\n            else {\\n                //Checking if the line has more than 1 word\\n                if(numWords > 1) {\\n                    //space[] stores the number of space between each word\\n                    //Total number of spaces = maxWidth-sum\\n                    //Total number of slots for spaces = numWords - 1\\n                    //eg: \"Science is what we\" - numWords = 4, total slots for spaces = 4-1 = 3 (between each word)\\n                    int[] space = new int[numWords-1];\\n                    calcSpaces(space, maxWidth-sum);\\n                    res.add(fullJustify(sentence, space));\\n                } else {\\n                    res.add(leftJustify(sentence, maxWidth));\\n                }\\n                //Since the current word was not taken on current line, we need to reiterate on this word, therefore --i\\n                --i;\\n                //Reinitializing all the counters for next line\\n                sum = 0;\\n                numWords = 0;\\n                remaining = maxWidth;\\n                sentence = new ArrayList<>();\\n            }\\n        }\\n        //If the sentence still has words, then leftJustify the sentence\\n        //Eg: \"Leetcode is fun\", maxWidth = 20\\n        //All the words fit on same line, so leftJustify. This is also useful for last line of the output\\n        if(!sentence.isEmpty()) {\\n            res.add(leftJustify(sentence, maxWidth));\\n        }\\n        return res;\\n    }\\n    \\n    void calcSpaces(int[] space, int numSpace) {\\n        int n = space.length;\\n        Arrays.fill(space, numSpace/n);\\n        int remaining = numSpace%n;\\n        int i = 0;\\n        while(remaining > 0) {\\n            space[i]++;\\n            ++i;\\n            --remaining;\\n        }\\n    }\\n    \\n    String leftJustify(List<String> sentence, int maxWidth) {\\n        StringBuilder sb = new StringBuilder();\\n        for(String w : sentence) {\\n            sb.append(w).append(\" \");\\n        }\\n        //In case the last character of the last word of the sentence occupy maxWidth, we don\\'t need that leading space, so removing it\\n        sb.deleteCharAt(sb.length()-1);\\n        //Padding with spaces to reach maxWidth\\n        while(sb.length() < maxWidth) {\\n            sb.append(\" \");\\n        }\\n        return sb.toString();\\n    }\\n    \\n    String fullJustify(List<String> sentence, int[] space) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < sentence.size()-1; i++) {\\n            sb.append(sentence.get(i));\\n            while(space[i] > 0) {\\n                sb.append(\" \");\\n                space[i]--;\\n            }\\n        }\\n        sb.append(sentence.get(sentence.size()-1));\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228647,
                "title": "thinking-process-greedy-approach",
                "content": "**Insights from problem description:**\\n* Two types of line to form\\n\\t* Fully-Justified (all lines except last line)\\n\\t* Left-justified (last line)\\n\\n**For each fully justified line, we can form the line in greedy way**- \\n1. Include as many word as possible in the current line where consecuative words are separated by single space until current line length smaller than maxWidth\\n2. Add one more word in current line and If **currentLineLength == maxWidth**, current line fits in the maxWidth perfectly where consecuative words in current line are separated by single space. Add this line to final result. \\n3. Add one more word in current line and If **current Line Length exceeds maxWidth**, exclude last added word from the current line-\\n\\t1. Distribute remaining-width-to-fill number of space evenly among each space placeholder of current line. **Number of space placeholder in current line = number of word in current line - 1**\\n\\t2. Number of space in each space placeholder = **((maxWidth - currentLineLength) // ( Number of space placeholder in current line)) +1**\\n\\t3. If there are some width to fill up ( **(maxWidth - currentLineLength)% ( Number of space placeholder in current line)** ) which can not be distributed evenly among each space placeholder of current line, distribute it from leftmost space placeholder to rightmost space placeholder of current line\\n\\n**For the last line which is left-justified**, \\n1. Include all remaining words in the current line where consecuative words are sperated by single space\\n2. Add  **(maxWidth - currentLineLength)** number of space at the end of current line\\n\\n**Time Complexity**:\\nWe have to traverse the words list at most 2 times and for each word, we have to calculate corresponding word length. Thus, the time complexity will be **O(len(words) * maxWordLen)**.\\n\\n**Space Complexity**:\\nWe are not using any additional space except the list to store the final result. In the worst case, each word in the words list can form a  line. Thus, **O(len(words) * maxWidth)**.\\n\\n**Code**\\n```\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        lines = [] #final result\\n        currentLine = \\'\\'\\n        left = 0 # tracks first word in current line\\n        \\n        currentLineLength = 0\\n        remainingWidth = 0 \\n        \\n        firstWord = True\\n        wordsLen = len(words)\\n        \\n        for i in range(wordsLen):\\n            wordLen = len(words[i])  \\n            \\n            # First word of the current line\\n            if firstWord:\\n                firstWord = False\\n                currentLineLength = wordLen\\n                left = i\\n            \\n            # Adding words[i] and a single space in the current line exceeds the maxWidth, thus words[i] will not be included in current line\\n            elif currentLineLength + 1 + wordLen > maxWidth:\\n                #  wordCount = number of words in the current line\\n                wordCount = i - left\\n                \\n                # For all lines except last line, distribute remaining width evenly among the each space placeholder\\n                if wordCount > 1: \\n                    # Number of space in each space placeholder = (remaining place to fill // (number of space placeholder)) + 1 (single space counted in currentLineLength). This is evenly distributed space\\n                    # Number of space placeholder in the current line = wordCount - 1 \\n                    totalSpaceInEachPlaceHolder = ((maxWidth - currentLineLength) // (wordCount - 1)) + 1 \\n            \\n                    # remainingWidth number of space can not be distributed evenly\\n                    remainingWidth = (maxWidth - currentLineLength) % (wordCount - 1)\\n                    \\n                else:\\n                    # Current line contains single word, thus 0 space placeHolder\\n                    totalSpaceInEachPlaceHolder = 0\\n                    remainingWidth = maxWidth - currentLineLength\\n                    \\n                line = words[left]\\n                left += 1\\n                \\n                # Process the current line and add it to final result\\n                # For fully-justified lines(all lines except last line), we have to distribute remainingWidth number of space to the space placeholder from leftmost space placeholder of current line to right\\n                while left < i:\\n                    line += (\" \"* totalSpaceInEachPlaceHolder)\\n                    if remainingWidth > 0:\\n                        line += \" \"\\n                        remainingWidth -= 1\\n                    line += words[left]\\n                    left += 1\\n                    \\n                if remainingWidth > 0:\\n                    line += (\" \"* remainingWidth)\\n                if line:\\n                    lines.append(line)\\n                \\n                currentLineLength = wordLen\\n                \\n            # Current line containing words[left], words[left+1], ..., words[i] fits perfectly in the maxWidth. Start new line after processing this line\\n            elif currentLineLength + 1 + wordLen == maxWidth:\\n                lines.append(\" \".join(words[left:i+1]))\\n                firstWord = True\\n                \\n            # Current line containing words[left], words[left+1], ..., words[i] does not fill upto maxWidth. Add one space and current word to the current line\\n            else:\\n                currentLineLength += 1 + wordLen\\n        \\n        # All words are processed and no remaingwidth to fill with space\\n        if firstWord:\\n            return lines\\n        \\n        \\n        # Process the last line. \\n        # It is left-justified: Add single space between consecutive word and remainingWidth number of space at the end\\n        wordCount = wordsLen - left\\n        if wordCount > 1:\\n            totalSpaceInEachPlaceHolder =  1\\n        else:\\n            totalSpaceInEachPlaceHolder = 0\\n            \\n        remainingWidth = maxWidth - currentLineLength\\n        line = words[left]\\n        left += 1\\n\\n        # Add single space between consecutive word of last line\\n        while left < wordsLen:\\n            line += (\" \"* totalSpaceInEachPlaceHolder)\\n            line += words[left]\\n            left += 1\\n\\n        # Add remainingWidth number of space at the end of last line\\n        if remainingWidth > 0:\\n            line += (\" \"* remainingWidth)\\n        if line:\\n            lines.append(line)\\n            \\n        return lines\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        lines = [] #final result\\n        currentLine = \\'\\'\\n        left = 0 # tracks first word in current line\\n        \\n        currentLineLength = 0\\n        remainingWidth = 0 \\n        \\n        firstWord = True\\n        wordsLen = len(words)\\n        \\n        for i in range(wordsLen):\\n            wordLen = len(words[i])  \\n            \\n            # First word of the current line\\n            if firstWord:\\n                firstWord = False\\n                currentLineLength = wordLen\\n                left = i\\n            \\n            # Adding words[i] and a single space in the current line exceeds the maxWidth, thus words[i] will not be included in current line\\n            elif currentLineLength + 1 + wordLen > maxWidth:\\n                #  wordCount = number of words in the current line\\n                wordCount = i - left\\n                \\n                # For all lines except last line, distribute remaining width evenly among the each space placeholder\\n                if wordCount > 1: \\n                    # Number of space in each space placeholder = (remaining place to fill // (number of space placeholder)) + 1 (single space counted in currentLineLength). This is evenly distributed space\\n                    # Number of space placeholder in the current line = wordCount - 1 \\n                    totalSpaceInEachPlaceHolder = ((maxWidth - currentLineLength) // (wordCount - 1)) + 1 \\n            \\n                    # remainingWidth number of space can not be distributed evenly\\n                    remainingWidth = (maxWidth - currentLineLength) % (wordCount - 1)\\n                    \\n                else:\\n                    # Current line contains single word, thus 0 space placeHolder\\n                    totalSpaceInEachPlaceHolder = 0\\n                    remainingWidth = maxWidth - currentLineLength\\n                    \\n                line = words[left]\\n                left += 1\\n                \\n                # Process the current line and add it to final result\\n                # For fully-justified lines(all lines except last line), we have to distribute remainingWidth number of space to the space placeholder from leftmost space placeholder of current line to right\\n                while left < i:\\n                    line += (\" \"* totalSpaceInEachPlaceHolder)\\n                    if remainingWidth > 0:\\n                        line += \" \"\\n                        remainingWidth -= 1\\n                    line += words[left]\\n                    left += 1\\n                    \\n                if remainingWidth > 0:\\n                    line += (\" \"* remainingWidth)\\n                if line:\\n                    lines.append(line)\\n                \\n                currentLineLength = wordLen\\n                \\n            # Current line containing words[left], words[left+1], ..., words[i] fits perfectly in the maxWidth. Start new line after processing this line\\n            elif currentLineLength + 1 + wordLen == maxWidth:\\n                lines.append(\" \".join(words[left:i+1]))\\n                firstWord = True\\n                \\n            # Current line containing words[left], words[left+1], ..., words[i] does not fill upto maxWidth. Add one space and current word to the current line\\n            else:\\n                currentLineLength += 1 + wordLen\\n        \\n        # All words are processed and no remaingwidth to fill with space\\n        if firstWord:\\n            return lines\\n        \\n        \\n        # Process the last line. \\n        # It is left-justified: Add single space between consecutive word and remainingWidth number of space at the end\\n        wordCount = wordsLen - left\\n        if wordCount > 1:\\n            totalSpaceInEachPlaceHolder =  1\\n        else:\\n            totalSpaceInEachPlaceHolder = 0\\n            \\n        remainingWidth = maxWidth - currentLineLength\\n        line = words[left]\\n        left += 1\\n\\n        # Add single space between consecutive word of last line\\n        while left < wordsLen:\\n            line += (\" \"* totalSpaceInEachPlaceHolder)\\n            line += words[left]\\n            left += 1\\n\\n        # Add remainingWidth number of space at the end of last line\\n        if remainingWidth > 0:\\n            line += (\" \"* remainingWidth)\\n        if line:\\n            lines.append(line)\\n            \\n        return lines\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1160268,
                "title": "python-solution-easy-to-understand",
                "content": "Got this question in an interview then worked on my solution to get it to work! Not as complicated once I understood the problem! Split the problem into first how to parse the string and decide what goes into a line, then how to actually add the spaces. Then I do the last line seperately since it\\'s dealt with differently! \\n\\n\\t output_string = []\\n        \\n        #figure out how many can fit in a line (less than the width)\\n        curr_word_pos = 0 \\n        curr_width = 0\\n        curr_line = []\\n\\n        while curr_word_pos < len(words):\\n\\n            curr_word = words[curr_word_pos]\\n\\n            #if curr word can fit (without space b/c might be last word in line), then add to curr_line list and move position to next word\\n            if (curr_width+len(curr_word)) <= maxWidth: \\n                \\n                                  \\n                curr_line.append(curr_word)\\n                \\n                curr_width+=len(curr_word) + 1\\n                \\n                curr_word_pos +=1\\n                \\n            \\n            #no space left, process current words into line\\n            else: \\n\\n                #process the line, add spaces, \\n                spaces = maxWidth - curr_width + len(curr_line)\\n                \\n                #go through all left over spaces and add behind each word that isn\\'t the last one\\n                added = 0\\n                pos = 0\\n            \\n                while (added < spaces):\\n\\n                    #avoid last word\\n                    if pos >= len(curr_line)-1:\\n                        pos = 0\\n                        \\n                    curr_line[pos] += \" \"\\n                    added +=1\\n                    pos+=1\\n                    \\n                #building a string of the curr line and appending to output array\\n                output_string.append(\"\".join(curr_line))\\n                    \\n                #reset these for the next line \\n                curr_line = []\\n                curr_width  = 0\\n           \\n        \\n        #add each word with normal number of spaces for last line\\n        for word in range(len(curr_line)-1):\\n\\n            curr_line[word] +=\" \"\\n        \\n        #add all extra spaces to last line\\n        curr_line[-1]+=(maxWidth-curr_width+1)*\" \"\\n                \\n        output_string.append(\"\".join(curr_line))\\n            \\n        return output_string",
                "solutionTags": [
                    "Python"
                ],
                "code": "Got this question in an interview then worked on my solution to get it to work! Not as complicated once I understood the problem! Split the problem into first how to parse the string and decide what goes into a line, then how to actually add the spaces. Then I do the last line seperately since it\\'s dealt with differently! \\n\\n\\t output_string = []\\n        \\n        #figure out how many can fit in a line (less than the width)\\n        curr_word_pos = 0 \\n        curr_width = 0\\n        curr_line = []\\n\\n        while curr_word_pos < len(words):\\n\\n            curr_word = words[curr_word_pos]\\n\\n            #if curr word can fit (without space b/c might be last word in line), then add to curr_line list and move position to next word\\n            if (curr_width+len(curr_word)) <= maxWidth: \\n                \\n                                  \\n                curr_line.append(curr_word)\\n                \\n                curr_width+=len(curr_word) + 1\\n                \\n                curr_word_pos +=1\\n                \\n            \\n            #no space left, process current words into line\\n            else: \\n\\n                #process the line, add spaces, \\n                spaces = maxWidth - curr_width + len(curr_line)\\n                \\n                #go through all left over spaces and add behind each word that isn\\'t the last one\\n                added = 0\\n                pos = 0\\n            \\n                while (added < spaces):\\n\\n                    #avoid last word\\n                    if pos >= len(curr_line)-1:\\n                        pos = 0\\n                        \\n                    curr_line[pos] += \" \"\\n                    added +=1\\n                    pos+=1\\n                    \\n                #building a string of the curr line and appending to output array\\n                output_string.append(\"\".join(curr_line))\\n                    \\n                #reset these for the next line \\n                curr_line = []\\n                curr_width  = 0\\n           \\n        \\n        #add each word with normal number of spaces for last line\\n        for word in range(len(curr_line)-1):\\n\\n            curr_line[word] +=\" \"\\n        \\n        #add all extra spaces to last line\\n        curr_line[-1]+=(maxWidth-curr_width+1)*\" \"\\n                \\n        output_string.append(\"\".join(curr_line))\\n            \\n        return output_string",
                "codeTag": "Unknown"
            },
            {
                "id": 1126418,
                "title": "javascript-easy-to-understand-99-4",
                "content": "![image](https://assets.leetcode.com/users/images/3ec3ac94-a3bd-46bc-8c48-5a3668d3877c_1616683285.730853.png)\\n\\n```\\nvar fullJustify = function(words, maxWidth) {\\n    let currentLine = \\'\\', lines = [];\\n\\t//Group words into lines.\\n    for (const word of words) {\\n        if (!currentLine.length) currentLine += word;\\n        else if (word.length + 1 + currentLine.length <= maxWidth) currentLine += \\' \\' + word\\n        else {\\n            lines.push(currentLine);\\n            currentLine = word\\n        }\\n    }\\n    lines.push(currentLine)\\n    for (let i = 0; i < lines.length; i++) {\\n\\t\\t//Handle Last Line\\n        if (i === lines.length - 1) {\\n            lines[i] = lines[i] + \\' \\'.repeat(maxWidth - lines[i].length)\\n        } else {\\n            currentLine = lines[i];\\n            const lineLen = lines[i].replace(/[ ]/g, \\'\\').length;\\n\\t\\t\\t//Below handles if line only has one word. currLine.length - lineLen gives # of spaces on line.\\n            //If they are ===, then line has no spaces.  \\n            if (currentLine.length === lineLen) {\\n                currentLine = currentLine + \\' \\'.repeat(maxWidth - lineLen)\\n            } else {\\n                //This block handles regular lines with spaces.  Replace all spaces with biggest\\n\\t\\t\\t\\t//necessary space, then remove from right to left until lineWidth === maxWidth.\\n                //RepeatSpaces is the size of the largest space in the line.\\n                const repeatSpaces = Math.ceil((maxWidth - lineLen) / (lines[i].length - lineLen));\\n                currentLine = currentLine.replace(/[ ]/g, \\' \\'.repeat(repeatSpaces));\\n                while (currentLine.length > maxWidth) {\\n                    let spacePos = currentLine.lastIndexOf(\\' \\'.repeat(repeatSpaces));\\n                    currentLine = currentLine.substring(0, spacePos) + currentLine.substring(spacePos + 1)\\n                }\\n            }\\n            lines[i] = currentLine\\n        }\\n    }\\n    return lines\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar fullJustify = function(words, maxWidth) {\\n    let currentLine = \\'\\', lines = [];\\n\\t//Group words into lines.\\n    for (const word of words) {\\n        if (!currentLine.length) currentLine += word;\\n        else if (word.length + 1 + currentLine.length <= maxWidth) currentLine += \\' \\' + word\\n        else {\\n            lines.push(currentLine);\\n            currentLine = word\\n        }\\n    }\\n    lines.push(currentLine)\\n    for (let i = 0; i < lines.length; i++) {\\n\\t\\t//Handle Last Line\\n        if (i === lines.length - 1) {\\n            lines[i] = lines[i] + \\' \\'.repeat(maxWidth - lines[i].length)\\n        } else {\\n            currentLine = lines[i];\\n            const lineLen = lines[i].replace(/[ ]/g, \\'\\').length;\\n\\t\\t\\t//Below handles if line only has one word. currLine.length - lineLen gives # of spaces on line.\\n            //If they are ===, then line has no spaces.  \\n            if (currentLine.length === lineLen) {\\n                currentLine = currentLine + \\' \\'.repeat(maxWidth - lineLen)\\n            } else {\\n                //This block handles regular lines with spaces.  Replace all spaces with biggest\\n\\t\\t\\t\\t//necessary space, then remove from right to left until lineWidth === maxWidth.\\n                //RepeatSpaces is the size of the largest space in the line.\\n                const repeatSpaces = Math.ceil((maxWidth - lineLen) / (lines[i].length - lineLen));\\n                currentLine = currentLine.replace(/[ ]/g, \\' \\'.repeat(repeatSpaces));\\n                while (currentLine.length > maxWidth) {\\n                    let spacePos = currentLine.lastIndexOf(\\' \\'.repeat(repeatSpaces));\\n                    currentLine = currentLine.substring(0, spacePos) + currentLine.substring(spacePos + 1)\\n                }\\n            }\\n            lines[i] = currentLine\\n        }\\n    }\\n    return lines\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059497,
                "title": "javascript-solution-iterative-98-48-faster-76-06-less-memory-usage",
                "content": "```\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 907092,
                "title": "java-1ms-fast-solution-explained",
                "content": "If you found the solution helpful, kindly upvote. :)\\n\\n        METHOD:\\n        1. We need to check where the words length exceeds the maxWidth. When that happens, we need to add it to the result.\\n        2. During adding spaces, there are 2 allignments to consider:\\n            a. Left justify: (use in last line, or the lines where there is only one word) In this, the spaces will be at the end of the list\\n            b. Middle justify: in this, the spaces will be equally distributed in between the words. If there are any extra spaces, \\n            those will be added from left to right.\\n            Eg: if there are 3 words and 5 spaces\\n            word1_ _ _word2_ _word3\\n\\n\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n                /*\\n        */\\n        List<String> result= new ArrayList<>();  \\n        //We need to traverse the list to see upto where the words can be added\\n        int i=0; \\n        while(i<words.length){\\n            int j= i+1;\\n            //Initially the linelength just has the length of the word at position i\\n            int linelength= words[i].length();\\n            //Here, j+i-1 is the minimum spaces required between the words\\n            while(j<words.length && (linelength+words[j].length()+(j-i-1)<maxWidth)){\\n                linelength+= words[j].length();\\n                j++;\\n            }\\n            \\n            int diff= maxWidth-linelength;\\n            int numberOfWords=j-i;\\n            //Checking for the left justify case\\n            if(numberOfWords==1 || j >= words.length) result.add(leftJustify(words, diff,i,j));\\n            else result.add(middleJustify(words, diff,i,j));    \\n\\n            i=j;\\n        }\\n        return result;\\n    }\\n\\n    private String middleJustify(String[] words, int diff, int i, int j) {\\n        //Groups of spaces we need (equal to number of words-1)\\n        int groupSpaces= j-i-1;\\n        //Spaces minimum after every word\\n        int space= diff/groupSpaces;\\n        //The extra spaces left which would be added from the left to right\\n        int extraSpace= diff%groupSpaces;\\n        \\n        StringBuilder str= new StringBuilder(words[i]);\\n        for(int k=i+1; k<j; k++){\\n            //The spaces required after every word \\n            int spacesApply= space+(extraSpace-- >0 ? 1:0);\\n            str.append(\" \".repeat(spacesApply)+words[k]);\\n        }\\n        return str.toString();\\n    }\\n\\n    private String leftJustify(String[] words, int diff, int i, int j) {\\n        //number of spaces which are going to be at the end\\n        int rightSpaces= diff-(j-i-1);\\n        //Initially add the string at position i\\n        StringBuilder str= new StringBuilder(words[i]);\\n        for(int k=i+1; k<j; k++){\\n            //Adding 1 space after the word\\n            str.append(\" \"+words[k]);\\n        }\\n        //Add the extra spaces in the end\\n        str.append(\" \".repeat(rightSpaces));\\n        return str.toString();\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n                /*\\n        */\\n        List<String> result= new ArrayList<>();  \\n        //We need to traverse the list to see upto where the words can be added\\n        int i=0; \\n        while(i<words.length){\\n            int j= i+1;\\n            //Initially the linelength just has the length of the word at position i\\n            int linelength= words[i].length();\\n            //Here, j+i-1 is the minimum spaces required between the words\\n            while(j<words.length && (linelength+words[j].length()+(j-i-1)<maxWidth)){\\n                linelength+= words[j].length();\\n                j++;\\n            }\\n            \\n            int diff= maxWidth-linelength;\\n            int numberOfWords=j-i;\\n            //Checking for the left justify case\\n            if(numberOfWords==1 || j >= words.length) result.add(leftJustify(words, diff,i,j));\\n            else result.add(middleJustify(words, diff,i,j));    \\n\\n            i=j;\\n        }\\n        return result;\\n    }\\n\\n    private String middleJustify(String[] words, int diff, int i, int j) {\\n        //Groups of spaces we need (equal to number of words-1)\\n        int groupSpaces= j-i-1;\\n        //Spaces minimum after every word\\n        int space= diff/groupSpaces;\\n        //The extra spaces left which would be added from the left to right\\n        int extraSpace= diff%groupSpaces;\\n        \\n        StringBuilder str= new StringBuilder(words[i]);\\n        for(int k=i+1; k<j; k++){\\n            //The spaces required after every word \\n            int spacesApply= space+(extraSpace-- >0 ? 1:0);\\n            str.append(\" \".repeat(spacesApply)+words[k]);\\n        }\\n        return str.toString();\\n    }\\n\\n    private String leftJustify(String[] words, int diff, int i, int j) {\\n        //number of spaces which are going to be at the end\\n        int rightSpaces= diff-(j-i-1);\\n        //Initially add the string at position i\\n        StringBuilder str= new StringBuilder(words[i]);\\n        for(int k=i+1; k<j; k++){\\n            //Adding 1 space after the word\\n            str.append(\" \"+words[k]);\\n        }\\n        //Add the extra spaces in the end\\n        str.append(\" \".repeat(rightSpaces));\\n        return str.toString();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833996,
                "title": "easy-explanation-with-algorithm-and-code-c",
                "content": "The question seems quite difficult,but when u understand its simple. Basically u have to fit as many words as possible in single line with even spacing between them,if a word dosen\\'t fit it will go to next line.\\nRefernce Example:\\n```\\nwords = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\\nmaxWidth = 16\\n```\\n1. To make this possible we have to do a greedy approach,fit as many words in a line with single space between words, we take single space because if we have words whose toatl length is equal to maxWidth then we cant add spaces and will look like \"thisisanexample\".\\n In above example we can fit \"this,is,an\",if we try to fit \"example\" it will exceed maxWidth. So we know first line consits of \"this\",\"is\",\"an\".\\nFor this line we have to add spaces evenly between words until it reaches maxWidth.\\nSo for `\"This\",\"is\",\"an\"` should be a string `\"This     is    an\"` which has length == maxWidth.\\n3. Now we know how we can justify a line ,we need to form these lines\\n\\nAlgorithm\\n```\\nresult=[]                //To store the justified lines\\ncur_line=[]             //this is store the words in current line\\nnum_of_letters=0       // number of letters in current line  \\nIterate each word in input:\\n\\tcheck if we add word to cur_line exceeds maxWidth:\\n\\t\\tif it exceeds : \\n\\t\\t\\tadd spaces evenly to current line and add it result\\n\\t\\t\\tSince we are done with cur_line we empty it and set num_of_letters to 0\\n\\t\\tadd the word to cur_line                          //if the word exceeds maxWidth this word will be added to a newline beacuse we reset cur_line in previous step\\n\\t\\tadd num_of_letters with length of word\\nafter iterating all words check if cur_line is empty      // we add line to result only when it exceeds maxWidth,but when we finish all words some words might be left in cur_line\\nif not empty :\\n\\tadd spaces and add to result \\n\\nreturn result\\n```\\nNow u know approach try it, if u get stuck continue reading\\n* **Formula to check whether word will fit in cur_line** : `num_of_letters+len(word) + len(cur_line) > maxWidth`\\n\\tKeep in mind len(cur_line) is number of words in cur_line,so if there are two words it translates to single spaces between words after adding third word.\\n\\tUnderstand above statement properly,u are doing this in greedy approach words should have atleast a single space between them.\\n\\tEx: \\n\\t`cur_line=\"this\",is\",\"an\"` and  word to be added `\"example\"` then condition will be\\n\\tnum_of_letters=8, len(word)=len(\"example\")=7,len(cur_line)=3 so 8+3+7>16 so we break the line and add \"example\" to next Line.\\n\\t\"this is an example\" >16 (adding example will make line>maxWidth)\\n*  **How to justify a line** :To do that we need to find number of spaces to insert so it reaches maxWidth, so `maxWidth - num_of_letters (in cur_line) ` gives it.\\nSay we have 4 words (u have to fill 3 spots ) and 5 spaces to add to reach maxWidth,we need to distribute evenly from left to right according to question, so (2,2,1) will be spacing between them.(Think of adding 5 stones to 3 containers from left to right one at a time ,at end how many stones are in each container?)\\ndivide the number of spaces to add by (num of words -1) .\\nThe Qutioent is space to be added between words.\\nThe remainder is extra spaces we need to distribute from left to right one at a time (Think of stones 5/3=1 , 5%3=2 so first two containers will have extra one stone (1+1, 1+1, 1).\\nTo make it simple u are adding spaces in Round robin fashion,just to do it in one step we divide and use qutieont and remainder.\\n**A corner case while justifying is what if that line has only word then we need to add empty spaces until it reaches maxWidth**\\nWhile justifying last line a single space between words is enough with last word appended with spaces to cover maxWidth. (Last line should be left justified according to Problem)\\n\\n\\n\\nCode in C++\\n```\\nstring fillSpaces(vector<string> line,int num_letters, int maxWidth){\\n        string res;\\n        int spaces_to_add=maxWidth-num_letters;\\n        int between_space=spaces_to_add/(line.size()-1);\\n        int extra_spaces=spaces_to_add%(line.size()-1);\\n        for(int i=0;i<line.size()-1;i++){\\n            res+=line[i] + string(between_space,\\' \\')+ string(extra_spaces?1:0,\\' \\');\\n            if(extra_spaces>0) extra_spaces--;\\n        }\\n        res+=line.back();\\n        \\n        return res;\\n    }\\n    \\n    \\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        vector<string> line;\\n        int cur_letters = 0;\\n        for(auto word:words){\\n            if(cur_letters + word.length() + line.size() > maxWidth){   \\n                if(line.size()==1){\\n                    res.push_back(line[0]+string(maxWidth-cur_letters,\\' \\'));  //corner case\\n                }\\n                else\\n                   res.push_back(fillSpaces(line,cur_letters,maxWidth)); \\n                cur_letters=0;\\n                line.clear();\\n                \\n            }\\n            line.push_back(word);\\n            cur_letters+=word.length();\\n        }      \\n        string last;      //For the last line Left Justification\\n        for(int i=0;i<line.size()-1;i++){\\n            last+=line[i]+\" \";\\n            \\n        }\\n        last+=line.back()+string(maxWidth-(cur_letters+line.size()-1),\\' \\');\\n        res.push_back(last);\\n        return res;\\n        \\n    }\\n```\\nDo a Dry run ,u will get to know.\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nwords = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\\nmaxWidth = 16\\n```\n```\\nresult=[]                //To store the justified lines\\ncur_line=[]             //this is store the words in current line\\nnum_of_letters=0       // number of letters in current line  \\nIterate each word in input:\\n\\tcheck if we add word to cur_line exceeds maxWidth:\\n\\t\\tif it exceeds : \\n\\t\\t\\tadd spaces evenly to current line and add it result\\n\\t\\t\\tSince we are done with cur_line we empty it and set num_of_letters to 0\\n\\t\\tadd the word to cur_line                          //if the word exceeds maxWidth this word will be added to a newline beacuse we reset cur_line in previous step\\n\\t\\tadd num_of_letters with length of word\\nafter iterating all words check if cur_line is empty      // we add line to result only when it exceeds maxWidth,but when we finish all words some words might be left in cur_line\\nif not empty :\\n\\tadd spaces and add to result \\n\\nreturn result\\n```\n```\\nstring fillSpaces(vector<string> line,int num_letters, int maxWidth){\\n        string res;\\n        int spaces_to_add=maxWidth-num_letters;\\n        int between_space=spaces_to_add/(line.size()-1);\\n        int extra_spaces=spaces_to_add%(line.size()-1);\\n        for(int i=0;i<line.size()-1;i++){\\n            res+=line[i] + string(between_space,\\' \\')+ string(extra_spaces?1:0,\\' \\');\\n            if(extra_spaces>0) extra_spaces--;\\n        }\\n        res+=line.back();\\n        \\n        return res;\\n    }\\n    \\n    \\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        vector<string> line;\\n        int cur_letters = 0;\\n        for(auto word:words){\\n            if(cur_letters + word.length() + line.size() > maxWidth){   \\n                if(line.size()==1){\\n                    res.push_back(line[0]+string(maxWidth-cur_letters,\\' \\'));  //corner case\\n                }\\n                else\\n                   res.push_back(fillSpaces(line,cur_letters,maxWidth)); \\n                cur_letters=0;\\n                line.clear();\\n                \\n            }\\n            line.push_back(word);\\n            cur_letters+=word.length();\\n        }      \\n        string last;      //For the last line Left Justification\\n        for(int i=0;i<line.size()-1;i++){\\n            last+=line[i]+\" \";\\n            \\n        }\\n        last+=line.back()+string(maxWidth-(cur_letters+line.size()-1),\\' \\');\\n        res.push_back(last);\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 821052,
                "title": "thanks-to-michael-for-step-by-step-explanation-code-added-c-java",
                "content": "[Awesome Expalantion](https://youtu.be/GqXlEbFVTXY)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int i= 0;\\n        int n= words.size();\\n        vector<string> result;\\n        while(i<n){\\n            int j= i+1;\\n            int lineLength= words[i].length();\\n            \\n            while(j < n && (lineLength + words[j].length() + (j-i-1))  < maxWidth){\\n                lineLength= lineLength + words[j].length();\\n                j++;\\n            }\\n            \\n            int diff= maxWidth - lineLength;\\n            int numberOfwords= j-i;\\n            //Chcek if the line needs to be left justified o r not\\n            if(numberOfwords == 1  ||  j>=n){ \\n                result.push_back(leftJustify(words, diff, i, j));\\n            }else{\\n                result.push_back(middleJustify(words, diff, i, j));\\n            }\\n            \\n            i = j;\\n        }\\n        return result;\\n    }\\n    \\n    \\n    string middleJustify(vector<string>& words, int diff, int i, int j){\\n        string result;\\n        result = words[i];\\n        int sections= j-i-1;\\n        int spaces= diff/sections;\\n        int extraSpaces= diff % sections;\\n        for(int k= i+1; k<j; ++k){\\n            int spacesToApply= spaces + (extraSpaces-- > 0? 1:0);\\n            while(spacesToApply){\\n                result= result + \" \";\\n                spacesToApply--;\\n            }\\n            result= result + words[k];\\n        }\\n        return result;\\n    }\\n    \\n    \\n    string leftJustify(vector<string>& words, int diff, int i, int j){\\n        string result;\\n        int spacesInRight= diff - (j-i-1);\\n        result = words[i];\\n        for(int k= i+1; k<j; ++k){\\n            result += \" \" + words[k];\\n        }\\n        while(spacesInRight>0){\\n            result= result + \" \";\\n            spacesInRight--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int i= 0;\\n        int n= words.size();\\n        vector<string> result;\\n        while(i<n){\\n            int j= i+1;\\n            int lineLength= words[i].length();\\n            \\n            while(j < n && (lineLength + words[j].length() + (j-i-1))  < maxWidth){\\n                lineLength= lineLength + words[j].length();\\n                j++;\\n            }\\n            \\n            int diff= maxWidth - lineLength;\\n            int numberOfwords= j-i;\\n            //Chcek if the line needs to be left justified o r not\\n            if(numberOfwords == 1  ||  j>=n){ \\n                result.push_back(leftJustify(words, diff, i, j));\\n            }else{\\n                result.push_back(middleJustify(words, diff, i, j));\\n            }\\n            \\n            i = j;\\n        }\\n        return result;\\n    }\\n    \\n    \\n    string middleJustify(vector<string>& words, int diff, int i, int j){\\n        string result;\\n        result = words[i];\\n        int sections= j-i-1;\\n        int spaces= diff/sections;\\n        int extraSpaces= diff % sections;\\n        for(int k= i+1; k<j; ++k){\\n            int spacesToApply= spaces + (extraSpaces-- > 0? 1:0);\\n            while(spacesToApply){\\n                result= result + \" \";\\n                spacesToApply--;\\n            }\\n            result= result + words[k];\\n        }\\n        return result;\\n    }\\n    \\n    \\n    string leftJustify(vector<string>& words, int diff, int i, int j){\\n        string result;\\n        int spacesInRight= diff - (j-i-1);\\n        result = words[i];\\n        for(int k= i+1; k<j; ++k){\\n            result += \" \" + words[k];\\n        }\\n        while(spacesInRight>0){\\n            result= result + \" \";\\n            spacesInRight--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756745,
                "title": "java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        int n = words.length;\\n        List<String> result = new ArrayList<>();\\n        int left = 0;\\n        while(left < n) {\\n            int right = findRight(left, words, maxWidth);\\n            String str = justify(left, right, words, maxWidth);\\n            result.add(str); //add the justified line to result\\n            left = right + 1; // we have justified the words till left.\\n        }\\n        \\n        return result;\\n    }\\n    \\n    //return the right index till which the words can fit on current line\\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right].length();\\n        int n = words.length;\\n        right++;\\n        while(right < n && (sum + 1 + words[right].length()) <= maxWidth) {\\n            sum += 1 + words[right].length(); // add space and new word\\n            right++;\\n        }\\n        \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        int n = words.length;\\n        \\n        //if only one word\\n        if (left == right) {\\n            return words[left] + blanks(maxWidth - words[left].length());\\n        }\\n        \\n        if (isLastLine(right, n)) {\\n            String line = getLine(left, right, words);\\n            return line + blanks(maxWidth - line.length());\\n        }\\n        \\n        int len = getLineLength(left, right, words);\\n        int gaps = right - left;\\n        int spaces = maxWidth - len;\\n        String fixedSpace = blanks(spaces / gaps);\\n        int odd = 0;\\n        if (spaces % gaps != 0) {\\n            odd = spaces % gaps;\\n        }\\n        \\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (int i = left; i <= right; i++) {\\n            sb.append(words[i]).append(fixedSpace);\\n            if (odd > 0) {\\n                sb.append(\" \");\\n                odd--;\\n            }\\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n        \\n    \\n    private String getLine(int left, int right, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = left; i <= right; i++) {\\n            sb.append(words[i]).append(\" \");\\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n    \\n    private int getLineLength(int left, int right, String[] words) {\\n        int len = 0;\\n        for (int i = left; i <= right; i++) {\\n            len += words[i].length();\\n        }\\n        return len;\\n    }\\n\\n    \\n    \\n    private String blanks(int length) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < length; i++) {\\n            sb.append(\\' \\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n    private boolean isLastLine(int index, int n) {\\n        return index == n-1;\\n    }\\n}\\n\\n/*\\nLoop over the words array.\\nkeep on adding the words to current line until the width is less than max\\nCount the number of spaces required bw words.\\nEvenly append the spaces between each word. so n-1 places for spaces.\\nMake the current line string and add it to the sol\\nIn case all the words fit in one line and there are no more words, left justify\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        int n = words.length;\\n        List<String> result = new ArrayList<>();\\n        int left = 0;\\n        while(left < n) {\\n            int right = findRight(left, words, maxWidth);\\n            String str = justify(left, right, words, maxWidth);\\n            result.add(str); //add the justified line to result\\n            left = right + 1; // we have justified the words till left.\\n        }\\n        \\n        return result;\\n    }\\n    \\n    //return the right index till which the words can fit on current line\\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right].length();\\n        int n = words.length;\\n        right++;\\n        while(right < n && (sum + 1 + words[right].length()) <= maxWidth) {\\n            sum += 1 + words[right].length(); // add space and new word\\n            right++;\\n        }\\n        \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        int n = words.length;\\n        \\n        //if only one word\\n        if (left == right) {\\n            return words[left] + blanks(maxWidth - words[left].length());\\n        }\\n        \\n        if (isLastLine(right, n)) {\\n            String line = getLine(left, right, words);\\n            return line + blanks(maxWidth - line.length());\\n        }\\n        \\n        int len = getLineLength(left, right, words);\\n        int gaps = right - left;\\n        int spaces = maxWidth - len;\\n        String fixedSpace = blanks(spaces / gaps);\\n        int odd = 0;\\n        if (spaces % gaps != 0) {\\n            odd = spaces % gaps;\\n        }\\n        \\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (int i = left; i <= right; i++) {\\n            sb.append(words[i]).append(fixedSpace);\\n            if (odd > 0) {\\n                sb.append(\" \");\\n                odd--;\\n            }\\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n        \\n    \\n    private String getLine(int left, int right, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = left; i <= right; i++) {\\n            sb.append(words[i]).append(\" \");\\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n    \\n    private int getLineLength(int left, int right, String[] words) {\\n        int len = 0;\\n        for (int i = left; i <= right; i++) {\\n            len += words[i].length();\\n        }\\n        return len;\\n    }\\n\\n    \\n    \\n    private String blanks(int length) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < length; i++) {\\n            sb.append(\\' \\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n    private boolean isLastLine(int index, int n) {\\n        return index == n-1;\\n    }\\n}\\n\\n/*\\nLoop over the words array.\\nkeep on adding the words to current line until the width is less than max\\nCount the number of spaces required bw words.\\nEvenly append the spaces between each word. so n-1 places for spaces.\\nMake the current line string and add it to the sol\\nIn case all the words fit in one line and there are no more words, left justify\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534511,
                "title": "my-ac-c-codes-with-comments",
                "content": "Although it is a bit long, time and space complexity beat 100% C++ submission.\\nI think it is very straight forward with the help of comments.\\n\\nWithout comments:\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        int i = 0;\\n        vector<string> res{};\\n        string cur = \"\"; \\n        while (i < n) {\\n            int l = i;\\n            int sum = 0;\\n            while (i < n && sum + words[i].size() <= maxWidth) {\\n                sum += words[i].size() + 1;\\n                ++i;\\n            }\\n            if (i == n) {\\n                for (int j = l; j < i - 1; ++j) {\\n                    cur += words[j] + \\' \\';\\n                }\\n                cur += words[n - 1] + string(maxWidth - sum + 1, \\' \\');\\n                res.push_back(cur);\\n            } else {\\n                int count = 0;\\n                for (int j = l; j < i - 1; ++j) {\\n                    int remainder = (maxWidth - sum + i - l) % (i - l - 1);\\n                    int quotient = (maxWidth - sum + i - l) / (i - l - 1);\\n                    if (count < remainder) {\\n                        cur += words[j] + string(quotient + 1, \\' \\');\\n                        ++count;\\n                    } else {\\n                        cur += words[j] + string(quotient, \\' \\');\\n                    }\\n                }\\n                cur += words[i - 1];\\n                cur += string(maxWidth - cur.size(), \\' \\');\\n                res.push_back(cur);\\n                cur = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n \\nWith comments:\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        int i = 0; // index goes through the words vector\\n        vector<string> res{}; // return results\\n        string cur = \"\"; // string of each result row \\n        while (i < n) {\\n            int l = i; // l is the leftmost index of each row\\n            int sum = 0;\\n            // through this while loop, I wnat to find the end index of each row\\n            // for example, for row \"This    is    an\", after the wihle loop the \\n            // index will be 3\\n            while (i < n && sum + words[i].size() <= maxWidth) {\\n                sum += words[i].size() + 1;\\n                ++i;\\n            }\\n            // if i == n, it is the last row, we need only one space between each word\\n            if (i == n) {\\n                for (int j = l; j < i - 1; ++j) {\\n                    cur += words[j] + \\' \\';\\n                }\\n                // add the last word of each row and add the remain space to the end\\n                cur += words[n - 1] + string(maxWidth - sum + 1, \\' \\');\\n                res.push_back(cur);\\n            } else { // if i != n\\n                // count counts if the spaces do not divide evenly, then we need to count\\n                // number of remainder words to add one more space than others\\n                int count = 0;\\n                for (int j = l; j < i - 1; ++j) {\\n                    // for example, \"This    is    an\"\\n                    // maxWidth == 16;\\n                    // sum == (5 + 3 + 3 = 11); each word has one more white space to be counted\\n                    // i == 3;\\n                    // l == 0;\\n                    // then (maxWidth - sum + i - l) == (16 - 11 + 3 - 0 = 8) how many white spaces\\n                    int remainder = (maxWidth - sum + i - l) % (i - l - 1);\\n                    int quotient = (maxWidth - sum + i - l) / (i - l - 1);\\n                    // those words that need one more space than others\\n                    if (count < remainder) {\\n                        cur += words[j] + string(quotient + 1, \\' \\');\\n                        ++count;\\n                    } else {\\n                        cur += words[j] + string(quotient, \\' \\');\\n                    }\\n                }\\n                // add the last word of each row\\n                cur += words[i - 1];\\n                // in case of only one word in a row like \"acknowledgment  \"\\n                cur += string(maxWidth - cur.size(), \\' \\');\\n                res.push_back(cur);\\n                // reset cur\\n                cur = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        int i = 0;\\n        vector<string> res{};\\n        string cur = \"\"; \\n        while (i < n) {\\n            int l = i;\\n            int sum = 0;\\n            while (i < n && sum + words[i].size() <= maxWidth) {\\n                sum += words[i].size() + 1;\\n                ++i;\\n            }\\n            if (i == n) {\\n                for (int j = l; j < i - 1; ++j) {\\n                    cur += words[j] + \\' \\';\\n                }\\n                cur += words[n - 1] + string(maxWidth - sum + 1, \\' \\');\\n                res.push_back(cur);\\n            } else {\\n                int count = 0;\\n                for (int j = l; j < i - 1; ++j) {\\n                    int remainder = (maxWidth - sum + i - l) % (i - l - 1);\\n                    int quotient = (maxWidth - sum + i - l) / (i - l - 1);\\n                    if (count < remainder) {\\n                        cur += words[j] + string(quotient + 1, \\' \\');\\n                        ++count;\\n                    } else {\\n                        cur += words[j] + string(quotient, \\' \\');\\n                    }\\n                }\\n                cur += words[i - 1];\\n                cur += string(maxWidth - cur.size(), \\' \\');\\n                res.push_back(cur);\\n                cur = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        int i = 0; // index goes through the words vector\\n        vector<string> res{}; // return results\\n        string cur = \"\"; // string of each result row \\n        while (i < n) {\\n            int l = i; // l is the leftmost index of each row\\n            int sum = 0;\\n            // through this while loop, I wnat to find the end index of each row\\n            // for example, for row \"This    is    an\", after the wihle loop the \\n            // index will be 3\\n            while (i < n && sum + words[i].size() <= maxWidth) {\\n                sum += words[i].size() + 1;\\n                ++i;\\n            }\\n            // if i == n, it is the last row, we need only one space between each word\\n            if (i == n) {\\n                for (int j = l; j < i - 1; ++j) {\\n                    cur += words[j] + \\' \\';\\n                }\\n                // add the last word of each row and add the remain space to the end\\n                cur += words[n - 1] + string(maxWidth - sum + 1, \\' \\');\\n                res.push_back(cur);\\n            } else { // if i != n\\n                // count counts if the spaces do not divide evenly, then we need to count\\n                // number of remainder words to add one more space than others\\n                int count = 0;\\n                for (int j = l; j < i - 1; ++j) {\\n                    // for example, \"This    is    an\"\\n                    // maxWidth == 16;\\n                    // sum == (5 + 3 + 3 = 11); each word has one more white space to be counted\\n                    // i == 3;\\n                    // l == 0;\\n                    // then (maxWidth - sum + i - l) == (16 - 11 + 3 - 0 = 8) how many white spaces\\n                    int remainder = (maxWidth - sum + i - l) % (i - l - 1);\\n                    int quotient = (maxWidth - sum + i - l) / (i - l - 1);\\n                    // those words that need one more space than others\\n                    if (count < remainder) {\\n                        cur += words[j] + string(quotient + 1, \\' \\');\\n                        ++count;\\n                    } else {\\n                        cur += words[j] + string(quotient, \\' \\');\\n                    }\\n                }\\n                // add the last word of each row\\n                cur += words[i - 1];\\n                // in case of only one word in a row like \"acknowledgment  \"\\n                cur += string(maxWidth - cur.size(), \\' \\');\\n                res.push_back(cur);\\n                // reset cur\\n                cur = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529464,
                "title": "java-modularized-suitable-for-an-interview",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList();\\n        int lo = 0;\\n        while (lo < words.length) { // while we still have next line\\n            int hi = nextHiIndex(words, lo, maxWidth);\\n            formatLine(words, lo, hi, maxWidth, res);\\n            lo = hi;\\n        }\\n        return res;\\n    }\\n    \\n    private int nextHiIndex(String[] words, int lo, int maxWidth) {\\n        int hi = lo;\\n        // while next word could fit in\\n        while (hi < words.length && words[hi].length() <= maxWidth) {\\n            maxWidth -= words[hi].length(); // reduce word len\\n            maxWidth--; // reduce one space\\n            hi++;\\n        }\\n        return hi;\\n    }\\n    \\n    private void formatLine(String[] words, int lo, int hi, int maxWidth, List<String> res) {\\n        // compute signals needed for format\\n        List<String> wordsList = Arrays.asList(words).subList(lo, hi);\\n        int size = hi - lo;\\n        boolean isLastLine = (hi == words.length);\\n        boolean isSingleWordLine = (size == 1);\\n        // format\\n        if (isSingleWordLine || isLastLine) {\\n            // \"%-30s\"\\n            res.add(String.format(\"%-\" + maxWidth + \"s\", String.join(\" \", wordsList)));\\n        } else {\\n            StringBuilder sb = new StringBuilder();\\n            int wordsLen  = wordsList.stream().map(w -> w.length()).reduce(0, (a, b) -> a + b);\\n            int spacesLen = maxWidth - wordsLen;\\n            int avgSpaces = spacesLen / (size - 1);\\n            int extraSpaces = spacesLen % (size - 1);\\n            for (int i = lo; i < hi; i++) {\\n                sb.append(words[i] + String.format(\"%\" + avgSpaces + \"s\", \"\"));\\n                if (extraSpaces-- > 0) sb.append(\" \");\\n            }\\n            res.add(sb.toString().trim());\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList();\\n        int lo = 0;\\n        while (lo < words.length) { // while we still have next line\\n            int hi = nextHiIndex(words, lo, maxWidth);\\n            formatLine(words, lo, hi, maxWidth, res);\\n            lo = hi;\\n        }\\n        return res;\\n    }\\n    \\n    private int nextHiIndex(String[] words, int lo, int maxWidth) {\\n        int hi = lo;\\n        // while next word could fit in\\n        while (hi < words.length && words[hi].length() <= maxWidth) {\\n            maxWidth -= words[hi].length(); // reduce word len\\n            maxWidth--; // reduce one space\\n            hi++;\\n        }\\n        return hi;\\n    }\\n    \\n    private void formatLine(String[] words, int lo, int hi, int maxWidth, List<String> res) {\\n        // compute signals needed for format\\n        List<String> wordsList = Arrays.asList(words).subList(lo, hi);\\n        int size = hi - lo;\\n        boolean isLastLine = (hi == words.length);\\n        boolean isSingleWordLine = (size == 1);\\n        // format\\n        if (isSingleWordLine || isLastLine) {\\n            // \"%-30s\"\\n            res.add(String.format(\"%-\" + maxWidth + \"s\", String.join(\" \", wordsList)));\\n        } else {\\n            StringBuilder sb = new StringBuilder();\\n            int wordsLen  = wordsList.stream().map(w -> w.length()).reduce(0, (a, b) -> a + b);\\n            int spacesLen = maxWidth - wordsLen;\\n            int avgSpaces = spacesLen / (size - 1);\\n            int extraSpaces = spacesLen % (size - 1);\\n            for (int i = lo; i < hi; i++) {\\n                sb.append(words[i] + String.format(\"%\" + avgSpaces + \"s\", \"\"));\\n                if (extraSpaces-- > 0) sb.append(\" \");\\n            }\\n            res.add(sb.toString().trim());\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491150,
                "title": "o-n-solution-using-queue",
                "content": "```\\n/*\\n * add the queue if words not exceed the maxWidth. if exceed the maxWidth we pop all out to form the string\\n * when we reach the end we handle the special case \\n * see comments below on the conditions applied.\\n */\\n public List<String> fullJustify(String[] words, int maxWidth) {\\n        int curr = 0;\\n        Queue<String> queue = new LinkedList<>();\\n        List<String> res =new ArrayList<>();\\n        int size = 0;\\n        int space = 0;\\n        int extraleft = 0;\\n        \\n        for(int i=0; i<words.length; i++){\\n            size = queue.size();\\n            //if the current string addition plus the single space in between is still with in the maxWidth\\n            //the queue size here can be used to represent the single space between each word including the \\n            //addition of the words[i]\\n            if(curr + words[i].length() + size <= maxWidth){\\n                queue.offer(words[i]);\\n                curr+=words[i].length();\\n            }else{\\n            \\t//calculating the base space in between \\n                space = size == 1? maxWidth-curr : (maxWidth-curr)/(size-1);\\n                //if not even, I grab the reminder as the space to distribute across the words in queue starting from beginning \\n                //one at a time\\n                //of course special case handle if the current queue has only one word. all spaces added from left to right\\n                extraleft = size == 1? 0 : (maxWidth-curr)%(size-1);\\n                StringBuilder sb = new StringBuilder();\\n                while(!queue.isEmpty()){\\n                    sb.append(queue.poll());\\n                    //dont add the spaces to the last word\\n                    if(sb.length() < maxWidth){ \\n                        for(int j=0; j<space; j++) sb.append(\" \");\\n                        //now we add the extra space calculated above one per word from the starting until the extraleft reaches 0\\n                        if(extraleft-- > 0) sb.append(\" \");\\n                    }\\n                }\\n                //adding the builded string and reset curr and queue\\n                res.add(sb.toString());\\n                curr = words[i].length();\\n                queue.offer(words[i]);\\n            }\\n            \\n            //when i reaches the last word we build the last row as the special case\\n            if(i == words.length-1){\\n                StringBuilder sb = new StringBuilder();\\n                while(!queue.isEmpty()){\\n                    sb.append(queue.poll());\\n                    if(!queue.isEmpty()) sb.append(\" \");\\n                }\\n                while(sb.length() < maxWidth){\\n                    sb.append(\" \");\\n                }\\n                   res.add(sb.toString());\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * add the queue if words not exceed the maxWidth. if exceed the maxWidth we pop all out to form the string\\n * when we reach the end we handle the special case \\n * see comments below on the conditions applied.\\n */\\n public List<String> fullJustify(String[] words, int maxWidth) {\\n        int curr = 0;\\n        Queue<String> queue = new LinkedList<>();\\n        List<String> res =new ArrayList<>();\\n        int size = 0;\\n        int space = 0;\\n        int extraleft = 0;\\n        \\n        for(int i=0; i<words.length; i++){\\n            size = queue.size();\\n            //if the current string addition plus the single space in between is still with in the maxWidth\\n            //the queue size here can be used to represent the single space between each word including the \\n            //addition of the words[i]\\n            if(curr + words[i].length() + size <= maxWidth){\\n                queue.offer(words[i]);\\n                curr+=words[i].length();\\n            }else{\\n            \\t//calculating the base space in between \\n                space = size == 1? maxWidth-curr : (maxWidth-curr)/(size-1);\\n                //if not even, I grab the reminder as the space to distribute across the words in queue starting from beginning \\n                //one at a time\\n                //of course special case handle if the current queue has only one word. all spaces added from left to right\\n                extraleft = size == 1? 0 : (maxWidth-curr)%(size-1);\\n                StringBuilder sb = new StringBuilder();\\n                while(!queue.isEmpty()){\\n                    sb.append(queue.poll());\\n                    //dont add the spaces to the last word\\n                    if(sb.length() < maxWidth){ \\n                        for(int j=0; j<space; j++) sb.append(\" \");\\n                        //now we add the extra space calculated above one per word from the starting until the extraleft reaches 0\\n                        if(extraleft-- > 0) sb.append(\" \");\\n                    }\\n                }\\n                //adding the builded string and reset curr and queue\\n                res.add(sb.toString());\\n                curr = words[i].length();\\n                queue.offer(words[i]);\\n            }\\n            \\n            //when i reaches the last word we build the last row as the special case\\n            if(i == words.length-1){\\n                StringBuilder sb = new StringBuilder();\\n                while(!queue.isEmpty()){\\n                    sb.append(queue.poll());\\n                    if(!queue.isEmpty()) sb.append(\" \");\\n                }\\n                while(sb.length() < maxWidth){\\n                    sb.append(\" \");\\n                }\\n                   res.add(sb.toString());\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2027769,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1564657,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1848509,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1568133,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2027716,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1565739,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1567183,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2028196,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1717407,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1567836,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2027769,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1564657,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1848509,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1568133,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2027716,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1565739,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1567183,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2028196,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1717407,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1567836,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2027997,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2027824,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 1576360,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 1568889,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 1567184,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 1571160,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2028958,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2028293,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2027872,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2027795,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2027755,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1721898,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571161,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571162,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571164,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571167,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1888329,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1570416,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 2027770,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571163,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571166,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2069885,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2037564,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2036310,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2030690,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2029117,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2028898,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2028892,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2028874,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2028814,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2028481,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028372,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028302,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028285,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028223,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028206,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028175,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028152,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028123,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028121,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts – I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028119,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2028081,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2028041,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2028030,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027904,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027898,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027847,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027797,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027792,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027783,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027726,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 2027709,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 2027702,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 2027694,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 2016549,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 1967098,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 1955090,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 1754120,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 1734806,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 1575777,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            }
        ]
    }
]