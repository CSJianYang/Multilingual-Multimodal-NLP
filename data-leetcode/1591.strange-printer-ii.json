[
    {
        "title": "Defanging an IP Address",
        "question_content": "Given a valid (IPv4) IP address, return a defanged version of that IP address.\r\n\r\nA defanged&nbsp;IP address&nbsp;replaces every period \".\" with \"[.]\".\r\n\r\n&nbsp;\r\nExample 1:\r\nInput: address = \"1.1.1.1\"\r\nOutput: \"1[.]1[.]1[.]1\"\r\nExample 2:\r\nInput: address = \"255.100.50.0\"\r\nOutput: \"255[.]100[.]50[.]0\"\r\n\r\n&nbsp;\r\nConstraints:\r\n\r\n\r\n\tThe given address is a valid IPv4 address.",
        "solutions": [
            {
                "id": 328895,
                "title": "java-python-3-3-one-liners-one-w-o-lib-w-analysis",
                "content": "```java\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n    public String defangIPaddr(String address) {\\n        return String.join(\"[.]\", address.split(\"\\\\\\\\.\"));\\n    }\\n    public String defangIPaddr(String address) {\\n        return address.replaceAll(\"\\\\\\\\.\", \"[.]\");\\n    }\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : address.toCharArray()) {\\n            sb.append(c == \\'.\\' ? \"[.]\" : c);\\n        }\\n        return sb.toString();\\n    }\\n```\\n\\n```python\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\\'.\\', \\'[.]\\')\\n    def defangIPaddr(self, address: str) -> str:\\n        return \\'[.]\\'.join(address.split(\\'.\\'))\\n    def defangIPaddr(self, address: str) -> str:\\n        return re.sub(\\'\\\\.\\', \\'[.]\\', address)\\n    def defangIPaddr(self, address: str) -> str:\\n        return \\'\\'.join(\\'[.]\\' if c == \\'.\\' else c for c in address)\\n```\\n\\n**Analysis:**\\n\\nAll characters are visited at most twice, therefore, \\n\\nTime & space: `O(n)`, where `n = address.length()`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n    public String defangIPaddr(String address) {\\n        return String.join(\"[.]\", address.split(\"\\\\\\\\.\"));\\n    }\\n    public String defangIPaddr(String address) {\\n        return address.replaceAll(\"\\\\\\\\.\", \"[.]\");\\n    }\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : address.toCharArray()) {\\n            sb.append(c == \\'.\\' ? \"[.]\" : c);\\n        }\\n        return sb.toString();\\n    }\\n```\n```python\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\\'.\\', \\'[.]\\')\\n    def defangIPaddr(self, address: str) -> str:\\n        return \\'[.]\\'.join(address.split(\\'.\\'))\\n    def defangIPaddr(self, address: str) -> str:\\n        return re.sub(\\'\\\\.\\', \\'[.]\\', address)\\n    def defangIPaddr(self, address: str) -> str:\\n        return \\'\\'.join(\\'[.]\\' if c == \\'.\\' else c for c in address)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 328855,
                "title": "c-1-liner-regex-replace",
                "content": "```\\nstring defangIPaddr(string address) {\\n  return regex_replace(address, regex(\"[.]\"), \"[.]\");\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring defangIPaddr(string address) {\\n  return regex_replace(address, regex(\"[.]\"), \"[.]\");\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 351240,
                "title": "c-100-faster-solution-with-0ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string res;\\n        for(auto c: address) {\\n            if(c==\\'.\\') {\\n                res+=\"[.]\";\\n            } else res+=c;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string res;\\n        for(auto c: address) {\\n            if(c==\\'.\\') {\\n                res+=\"[.]\";\\n            } else res+=c;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332184,
                "title": "java-solution",
                "content": "Here is my solution. Runs in O(n) runtime.\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder str = new StringBuilder();\\n        for (int i = 0; i < address.length(); i++){\\n            if (address.charAt(i) == \\'.\\'){\\n                str.append(\"[.]\");\\n            } else {\\n                str.append(address.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder str = new StringBuilder();\\n        for (int i = 0; i < address.length(); i++){\\n            if (address.charAt(i) == \\'.\\'){\\n                str.append(\"[.]\");\\n            } else {\\n                str.append(address.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570466,
                "title": "python-3-solutions",
                "content": "**First Solution**\\n\\nTime: O(N)\\nSpace: O(1)\\n\\nUses Python\\'s built-in string replace method\\n\\n``` \\nclass Solution:\\n\\tdef defangIPaddr(self, address: str) -> str:\\n\\t\\treturn address.replace(\\'.\\', \\'[.]\\')\\n```\\n\\n**Second Solution**\\n\\nTime: O(N)\\nSpace: O(1)\\n\\nConvert the ip address into a list of the numbers using the split method. Add the \"[.]\" chars between the numbers using the join method.\\n\\n```\\nclass Solution:\\n\\tdef defangIPaddr(self, address: str) -> str:\\n\\t\\treturn \"[.]\".join(address.split(\".\"))\\n```\\n\\n**Third Solution**\\n\\nTime: O(N)\\nSpace: O(N)\\n\\nCreate an empty list. Iterate through the characters in the address, numbers get appended to the list while periods signal that \"[.]\" chars must be appended. This method had the best speed results out of all others.\\n\\n```\\nclass Solution:\\n\\tdef defangIPaddr(self, address: str) -> str:\\n\\t\\tans = []\\n\\t\\tfor ch in address:\\n\\t\\t\\tif ch.isdigit():\\n\\t\\t\\t\\tans.append(ch)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans.append(\"[.]\")\\n\\n\\t\\treturn \"\".join(ans)\\n```\\n\\t\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nclass Solution:\\n\\tdef defangIPaddr(self, address: str) -> str:\\n\\t\\treturn address.replace(\\'.\\', \\'[.]\\')\\n```\n```\\nclass Solution:\\n\\tdef defangIPaddr(self, address: str) -> str:\\n\\t\\treturn \"[.]\".join(address.split(\".\"))\\n```\n```\\nclass Solution:\\n\\tdef defangIPaddr(self, address: str) -> str:\\n\\t\\tans = []\\n\\t\\tfor ch in address:\\n\\t\\t\\tif ch.isdigit():\\n\\t\\t\\t\\tans.append(ch)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans.append(\"[.]\")\\n\\n\\t\\treturn \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340369,
                "title": "python-one-line",
                "content": "Using split and join functions\\n```\\n    def defangIPaddr(self, address: str) -> str:\\n        return \\'[.]\\'.join(address.split(\\'.\\'))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def defangIPaddr(self, address: str) -> str:\\n        return \\'[.]\\'.join(address.split(\\'.\\'))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 428284,
                "title": "javascript-w-o-cheating-o-n-time-o-n-space",
                "content": "Yeah, your one-liner set operations are cute, but clearly defeat the purpose of the exercise, which is having you understand the underlying, abstracted algorithms and what their complexity is.\\n\\n```\\n/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n    var result=\"\";\\n    \\n    for(var i=0;i<address.length;i++) {\\n        if(address[i] === \".\")\\n            result += \"[.]\";\\n        else\\n            result += address[i];\\n    }\\n    \\n    return result;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n    var result=\"\";\\n    \\n    for(var i=0;i<address.length;i++) {\\n        if(address[i] === \".\")\\n            result += \"[.]\";\\n        else\\n            result += address[i];\\n    }\\n    \\n    return result;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366971,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Just iterate through string and copy every character same into `ans` and replace `\\'.\\'` to `\\'[.]\\'`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n`Upvote ! It just takes a click :)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans;\\n        for(int i=0;i<address.size();i++){\\n            if(address[i] == \\'.\\'){\\n                ans+=\"[.]\";\\n            }\\n            else{\\n                ans+=address[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![Upvote.jpeg](https://assets.leetcode.com/users/images/cc50bb3d-5e68-4825-9a63-30100c047ab9_1680369640.3874342.jpeg)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans;\\n        for(int i=0;i<address.size();i++){\\n            if(address[i] == \\'.\\'){\\n                ans+=\"[.]\";\\n            }\\n            else{\\n                ans+=address[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840879,
                "title": "replace-insert-simple-100-00",
                "content": "**replace**\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string str=\"[.]\";\\n        for(int i=0;i<address.length();i++){\\n            if(address[i]==\\'.\\'){\\n                address.replace(i,1,str);\\n                i+=2;\\n            }\\n        }\\n        return address;\\n    }\\n};\\n```\\ninsert \\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        for(int i=0;i<address.length();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                address.insert(i,1,\\'[\\');\\n                address.insert(i+2,1,\\']\\');\\n                i+=2;\\n            }\\n        }\\n        return address;\\n    }\\n};\\n```\\nsimple \\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string m = \"[.]\";\\n        string sol = \"\";\\n        for(int i=0;i<address.length();i++){\\n            if(address[i]==\\'.\\'){\\n                sol+=m;\\n            }else{\\n                sol+=address[i];\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string str=\"[.]\";\\n        for(int i=0;i<address.length();i++){\\n            if(address[i]==\\'.\\'){\\n                address.replace(i,1,str);\\n                i+=2;\\n            }\\n        }\\n        return address;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        for(int i=0;i<address.length();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                address.insert(i,1,\\'[\\');\\n                address.insert(i+2,1,\\']\\');\\n                i+=2;\\n            }\\n        }\\n        return address;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string m = \"[.]\";\\n        string sol = \"\";\\n        for(int i=0;i<address.length();i++){\\n            if(address[i]==\\'.\\'){\\n                sol+=m;\\n            }else{\\n                sol+=address[i];\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442529,
                "title": "c-c-java-python-c-php-ruby-js-ts-go-rust-swift-regex-and-replace",
                "content": "### C using a for loop:\\n\\n```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nstatic const char *defangIPaddr(\\n    const char *address\\n) {\\n    char *ipv4_memory = calloc(1, sizeof(\"###[.]###[.]###[.]###\"));\\n    char *defanged = ipv4_memory;\\n\\n    for (const char *character = address; *character; character++) {\\n        if (*character == \\'.\\') {\\n            *ipv4_memory++ = \\'[\\';\\n            *ipv4_memory++ = \\'.\\';\\n            *ipv4_memory++ = \\']\\';\\n\\n        } else {\\n            *ipv4_memory++ = *character;\\n        }\\n    }\\n\\n    return defanged;\\n}\\n\\n```\\n\\n\\n### C using `asprintf()` (from Code Review SE):\\n\\n```\\n#include <stdio.h>\\n\\nchar *defangIPaddr(const char *address) {\\n    char *defanged;\\n    int ip[4];\\n\\n    if (sscanf(address, \"%d.%d.%d.%d\", &ip[0], &ip[1], &ip[2], &ip[3]) != 4) {\\n        return NULL;\\n    }\\n\\n    if (asprintf(&defanged, \"%d[.]%d[.]%d[.]%d\", ip[0], ip[1], ip[2], ip[3]) == -1) {\\n        return NULL;\\n    }\\n\\n    return defanged;\\n}\\n```\\n\\n### C using a for loop a bit simplified:\\n\\n```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nstatic const char *defangIPaddr(\\n    const char *address\\n) {\\n    char *q = calloc(1, sizeof(\"###[.]###[.]###[.]###\"));\\n    char *defanged = q;\\n\\n    for (const char *p = address; *p; p++) {\\n        if (*p == \\'.\\') {\\n            *q++ = \\'[\\';\\n            *q++ = \\'.\\';\\n            *q++ = \\']\\';\\n\\n        } else {\\n            *q++ = *p;\\n        }\\n    }\\n\\n    return defanged;\\n}\\n```\\n\\n\\n**C++**: with regex (using character class: `[]`):\\n\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string a) {\\n        return regex_replace(a, regex(\"[.]\"), \"[.]\");\\n    }\\n};\\n```\\n\\n**C++**: with regex (without using character class: `[]` with just escaping `\\\\\\\\.`):\\n\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string a) {\\n        return regex_replace(a, regex(\"\\\\\\\\.\"), \"[.]\");\\n    }\\n};\\n```\\n\\n**Java**: using `replace()`:\\n\\n```\\nclass Solution {\\n    public String defangIPaddr(String a) {\\n        return a.replace(\".\", \"[.]\");\\n    }\\n}\\n```\\n\\n**Java**: using `replaceAll()`:\\n\\n```\\nclass Solution {\\n    public String defangIPaddr(String a) {\\n        return a.replaceAll(\"\\\\\\\\.\", \"[.]\");\\n    }\\n}\\n```\\n\\n**Java**: similar to C++ using a character class `[]` with `replaceAll()`:\\n\\n```\\nclass Solution {\\n    public String defangIPaddr(String a) {\\n        return a.replaceAll(\"[.]\", \"[.]\");\\n    }\\n}\\n```\\n\\n**Python3 or Python:** with `re.sub()`:\\n\\n```\\nclass Solution:\\n    def defangIPaddr(self, a):\\n        return re.sub(\\'\\\\.\\', \\'[.]\\', a)\\n```\\n\\n**Python3 or Python:** with `replace()`:\\n\\n```\\nclass Solution:\\n    def defangIPaddr(self, a):\\n        return a.replace(\".\", \"[.]\")\\n```\\n\\n\\n**PHP**: using `str_replace()`:\\n\\n```\\nclass Solution\\n{\\n    public function defangIPaddr($a)\\n    {\\n        return str_replace(\\'.\\', \\'[.]\\', $a);\\n    }\\n}\\n```\\n\\n\\n**PHP**: using `preg_replace()`:\\n\\n```\\nclass Solution\\n{\\n    public function defangIPaddr($a)\\n    {\\n        return preg_replace(\\'/\\\\./\\', \\'[.]\\', $a);\\n    }\\n}\\n```\\n\\n**PHP**: using `preg_replace()` and a character class `[]`:\\n\\n```\\nclass Solution\\n{\\n    public function defangIPaddr($a)\\n    {\\n        return preg_replace(\\'/[.]/\\', \\'[.]\\', $a);\\n    }\\n}\\n```\\n\\n**Ruby**: similar to PHP using `gsub()`:\\n\\n```\\ndef defang_i_paddr(a)\\n  a.gsub(/\\\\./, \"[.]\")\\nend\\n```\\n\\n\\n**JavaScript/TypeScript**: using the `g` global flag (modifier) with `replace()`:\\n\\n```\\nconst defangIPaddr = function(a) {\\n    return a.replace(/\\\\./g, \"[.]\")\\n}\\n```\\n\\n```\\nfunction defangIPaddr(a: string): string {\\n    return a.replace(/\\\\./g, \"[.]\")\\n}\\n```\\n\\n**C#**: using `Replace()`:\\n\\n```\\nclass Solution {\\n    public string DefangIPaddr(string a) {\\n        return a.Replace(\".\", \"[.]\");\\n    }\\n}\\n```\\n\\n\\n**Go**: using `strings.Replace()`:\\n\\n```\\nfunc defangIPaddr(a string) string {\\n    return strings.Replace(a, \".\", \"[.]\", -1)\\n}\\n```\\n\\n**Rust**: using `replace()`:\\n\\n```\\nimpl Solution {\\n    pub fn defang_i_paddr(a: String) -> String {\\n       a.replace( \".\", \"[.]\" )\\n    }\\n}\\n```\\n\\n**Swift**: using `replacingOccurrences()`:\\n\\n\\n```\\nclass Solution {\\n    func defangIPaddr(_ a: String) -> String {\\n        return a.replacingOccurrences(of: \".\", with: \"[.]\")\\n    }\\n}\\n```\\n\\n\\n**Explanation**:\\n\\nThe `.` is a metachar in RegEx engines. We would either use a character class `[]` as a wrapper or we have to escape such metachars using one or two backslashes (depending on the language and functions).\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript",
                    "Ruby",
                    "Swift",
                    "Go",
                    "Rust",
                    "PHP",
                    "TypeScript"
                ],
                "code": "```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nstatic const char *defangIPaddr(\\n    const char *address\\n) {\\n    char *ipv4_memory = calloc(1, sizeof(\"###[.]###[.]###[.]###\"));\\n    char *defanged = ipv4_memory;\\n\\n    for (const char *character = address; *character; character++) {\\n        if (*character == \\'.\\') {\\n            *ipv4_memory++ = \\'[\\';\\n            *ipv4_memory++ = \\'.\\';\\n            *ipv4_memory++ = \\']\\';\\n\\n        } else {\\n            *ipv4_memory++ = *character;\\n        }\\n    }\\n\\n    return defanged;\\n}\\n\\n```\n```\\n#include <stdio.h>\\n\\nchar *defangIPaddr(const char *address) {\\n    char *defanged;\\n    int ip[4];\\n\\n    if (sscanf(address, \"%d.%d.%d.%d\", &ip[0], &ip[1], &ip[2], &ip[3]) != 4) {\\n        return NULL;\\n    }\\n\\n    if (asprintf(&defanged, \"%d[.]%d[.]%d[.]%d\", ip[0], ip[1], ip[2], ip[3]) == -1) {\\n        return NULL;\\n    }\\n\\n    return defanged;\\n}\\n```\n```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nstatic const char *defangIPaddr(\\n    const char *address\\n) {\\n    char *q = calloc(1, sizeof(\"###[.]###[.]###[.]###\"));\\n    char *defanged = q;\\n\\n    for (const char *p = address; *p; p++) {\\n        if (*p == \\'.\\') {\\n            *q++ = \\'[\\';\\n            *q++ = \\'.\\';\\n            *q++ = \\']\\';\\n\\n        } else {\\n            *q++ = *p;\\n        }\\n    }\\n\\n    return defanged;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string a) {\\n        return regex_replace(a, regex(\"[.]\"), \"[.]\");\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string a) {\\n        return regex_replace(a, regex(\"\\\\\\\\.\"), \"[.]\");\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String defangIPaddr(String a) {\\n        return a.replace(\".\", \"[.]\");\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String defangIPaddr(String a) {\\n        return a.replaceAll(\"\\\\\\\\.\", \"[.]\");\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String defangIPaddr(String a) {\\n        return a.replaceAll(\"[.]\", \"[.]\");\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def defangIPaddr(self, a):\\n        return re.sub(\\'\\\\.\\', \\'[.]\\', a)\\n```\n```\\nclass Solution:\\n    def defangIPaddr(self, a):\\n        return a.replace(\".\", \"[.]\")\\n```\n```\\nclass Solution\\n{\\n    public function defangIPaddr($a)\\n    {\\n        return str_replace(\\'.\\', \\'[.]\\', $a);\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public function defangIPaddr($a)\\n    {\\n        return preg_replace(\\'/\\\\./\\', \\'[.]\\', $a);\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public function defangIPaddr($a)\\n    {\\n        return preg_replace(\\'/[.]/\\', \\'[.]\\', $a);\\n    }\\n}\\n```\n```\\ndef defang_i_paddr(a)\\n  a.gsub(/\\\\./, \"[.]\")\\nend\\n```\n```\\nconst defangIPaddr = function(a) {\\n    return a.replace(/\\\\./g, \"[.]\")\\n}\\n```\n```\\nfunction defangIPaddr(a: string): string {\\n    return a.replace(/\\\\./g, \"[.]\")\\n}\\n```\n```\\nclass Solution {\\n    public string DefangIPaddr(string a) {\\n        return a.Replace(\".\", \"[.]\");\\n    }\\n}\\n```\n```\\nfunc defangIPaddr(a string) string {\\n    return strings.Replace(a, \".\", \"[.]\", -1)\\n}\\n```\n```\\nimpl Solution {\\n    pub fn defang_i_paddr(a: String) -> String {\\n       a.replace( \".\", \"[.]\" )\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func defangIPaddr(_ a: String) -> String {\\n        return a.replacingOccurrences(of: \".\", with: \"[.]\")\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 343181,
                "title": "simple-java-solution",
                "content": "The manual version is the best efficiency-wise, 0ms and 100% in both time and memory\\n\\n```\\nfinal StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < address.length(); i++) {\\n            if (address.charAt(i) == \\'.\\')\\n                sb.append(\"[.]\");\\n            else\\n                sb.append(address.charAt(i));\\n        }\\n        \\n        return sb.toString();\\n```\\n\\nBut a slightly less efficient solution is archivied using java\\'s build-in libraries, like so\\n\\n```\\nreturn address.replace(\".\", \"[.]\");\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nfinal StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < address.length(); i++) {\\n            if (address.charAt(i) == \\'.\\')\\n                sb.append(\"[.]\");\\n            else\\n                sb.append(address.charAt(i));\\n        }\\n        \\n        return sb.toString();\\n```\n```\\nreturn address.replace(\".\", \"[.]\");\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 338888,
                "title": "c-solution-o-n-100-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        for (int i = address.size() - 2; i >= 0; i--)\\n            if (address[i + 1] == \\'.\\')\\n                address = address.substr(0, i + 1) + \"[.]\" + address.substr(i + 2);\\n        return address;\\n    }\\n};\\n```\\n\\nWe start looking from the second to last position because we know the last character in address will never be \\'.\\'\\nWe look backward through the string because we don\\'t want to mess up our indices when we start inserting the brackets.\\n\\nThis scored in",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        for (int i = address.size() - 2; i >= 0; i--)\\n            if (address[i + 1] == \\'.\\')\\n                address = address.substr(0, i + 1) + \"[.]\" + address.substr(i + 2);\\n        return address;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031868,
                "title": "two-java-simple-solution-in-1-line-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# code1\\n```Java\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\" , \"[.]\");\\n    }\\n}\\n```\\n\\n\\n# Code2\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder str = new StringBuilder();\\n        for (char c : address.toCharArray()){\\n            str.append((c == \\'.\\')? \"[.]\" : c );\\n        }\\n        return str.toString();\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/5db11db7-1336-477d-af6c-d0ca683bb9b1_1694447536.287339.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\" , \"[.]\");\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder str = new StringBuilder();\\n        for (char c : address.toCharArray()){\\n            str.append((c == \\'.\\')? \"[.]\" : c );\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328909,
                "title": "very-simple-inbuilt-function",
                "content": "Java has inbuilt function\\nreplace(CharSequence target, CharSequence replacement)\\nreplaceAll(String regex, String replacement)\\n```\\npublic String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n```\\n\\n```\\npublic String defangIPaddr(String address) {\\n        return address.replaceAll(\"\\\\\\\\.\", \"[.]\");\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n```\n```\\npublic String defangIPaddr(String address) {\\n        return address.replaceAll(\"\\\\\\\\.\", \"[.]\");\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392115,
                "title": "quick-c-solution",
                "content": "quick c solution\\n```c\\nchar * defangIPaddr(char * address){\\n    char *re = malloc(24);\\n    char *out = re;\\n    while (*address) {\\n        if (*address == \\'.\\') {\\n            *out++ = \\'[\\';\\n            *out++ = \\'.\\';\\n            *out++ = \\']\\';\\n            *address++;\\n        } else {\\n            *out++ = *address++;\\n        }\\n    }\\n    *out = \\'\\\\0\\';\\n    return re;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```c\\nchar * defangIPaddr(char * address){\\n    char *re = malloc(24);\\n    char *out = re;\\n    while (*address) {\\n        if (*address == \\'.\\') {\\n            *out++ = \\'[\\';\\n            *out++ = \\'.\\';\\n            *out++ = \\']\\';\\n            *address++;\\n        } else {\\n            *out++ = *address++;\\n        }\\n    }\\n    *out = \\'\\\\0\\';\\n    return re;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3125643,
                "title": "java-best-solution-o-n-time-complexity-beats-100",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder str = new StringBuilder();\\n        for (int i = 0; i < address.length(); i++) {\\n            if (address.charAt(i) == \\'.\\') {\\n                str.append(\"[.]\");\\n            } else {\\n                str.append(address.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder str = new StringBuilder();\\n        for (int i = 0; i < address.length(); i++) {\\n            if (address.charAt(i) == \\'.\\') {\\n                str.append(\"[.]\");\\n            } else {\\n                str.append(address.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190287,
                "title": "java-1-line-code-beats-100",
                "content": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      \\n        String replaceString = address.replace(\".\",\"[.]\");\\n        return replaceString;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String defangIPaddr(String address) {\\n      \\n        String replaceString = address.replace(\".\",\"[.]\");\\n        return replaceString;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 989884,
                "title": "99-faster-1-liner-python-why-did-somebody-downvote-this",
                "content": "class Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n\\t\\n        address = address.replace(\\'.\\',\\'[.]\\')\\n        return(address)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n\\t\\n        address = address.replace(\\'.\\',\\'[.]\\')\\n        return(address)",
                "codeTag": "Java"
            },
            {
                "id": 575813,
                "title": "c-0ms-simple-and-short",
                "content": "```\\nchar * defangIPaddr(char * address){\\n    char *d = calloc(1, sizeof(\"xxx[.]xxx[.]xxx[.]xxx\")), *t = d;\\n    for (char *a = address ; *a ; a++)\\n        *a == \\'.\\' ? *d++ = \\'[\\', *d++ = \\'.\\', *d++ = \\']\\' : (*d++ = *a);\\n    return t;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * defangIPaddr(char * address){\\n    char *d = calloc(1, sizeof(\"xxx[.]xxx[.]xxx[.]xxx\")), *t = d;\\n    for (char *a = address ; *a ; a++)\\n        *a == \\'.\\' ? *d++ = \\'[\\', *d++ = \\'.\\', *d++ = \\']\\' : (*d++ = *a);\\n    return t;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331694,
                "title": "javascript-regex-solution",
                "content": "Simple one line that uses regex and the string.replace() method. \\n\\n```\\nvar defangIPaddr = function(address) {\\n    return address.replace(/\\\\./g, \"[.]\")\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar defangIPaddr = function(address) {\\n    return address.replace(/\\\\./g, \"[.]\")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2785391,
                "title": "c-beats-100-0ms-best-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\n//Please upvote if it helps..........\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans;\\n        for(int i=0;i<address.length();++i){\\n            if(address[i]==\\'.\\')\\n            ans+=\"[.]\";\\n            else\\n            ans+=address[i];\\n        } return ans;\\n    }\\n};\\n//.........\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n//Please upvote if it helps..........\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans;\\n        for(int i=0;i<address.length();++i){\\n            if(address[i]==\\'.\\')\\n            ans+=\"[.]\";\\n            else\\n            ans+=address[i];\\n        } return ans;\\n    }\\n};\\n//.........\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673600,
                "title": "simple-c-solution-3-method-100-faster",
                "content": "```\\n\\u2705 PLEASE UPVOTE IF YOU LIKE! \\u2705\\n```\\n# Simple\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string result;\\n        for(int i = 0 ; i < address.length();i++){\\n            if(address[i]==\\'.\\'){\\n                result +=\"[.]\";\\n            }\\n            else result += address[i];\\n        }\\n\\n        return result;\\n    }\\n};\\n```\\n\\n\\n# Code using insert\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n\\n        for(int i = 0 ; i < address.length();i++){\\n            if(address[i]==\\'.\\'){\\n                address.insert(address.begin() + (i), \\'[\\');\\n                i++;\\n                address.insert(address.begin() + (i + 1), \\']\\');\\n            }\\n        }\\n\\n        return address;\\n    }\\n};\\n```\\n# Code using regex_replace\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        return regex_replace(address, regex(\"[.]\"), \"[.]\");\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n\\u2705 PLEASE UPVOTE IF YOU LIKE! \\u2705\\n```\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string result;\\n        for(int i = 0 ; i < address.length();i++){\\n            if(address[i]==\\'.\\'){\\n                result +=\"[.]\";\\n            }\\n            else result += address[i];\\n        }\\n\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n\\n        for(int i = 0 ; i < address.length();i++){\\n            if(address[i]==\\'.\\'){\\n                address.insert(address.begin() + (i), \\'[\\');\\n                i++;\\n                address.insert(address.begin() + (i + 1), \\']\\');\\n            }\\n        }\\n\\n        return address;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        return regex_replace(address, regex(\"[.]\"), \"[.]\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641851,
                "title": "js-one-line",
                "content": "```\\nvar defangIPaddr = function(address) {\\n    return address.split(\\'.\\').join(\\'[.]\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar defangIPaddr = function(address) {\\n    return address.split(\\'.\\').join(\\'[.]\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1224178,
                "title": "java-100-stringbuilder-solution",
                "content": "if you like it pls upvote\\n\\nJAVA\\n\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder res = new StringBuilder();\\n        \\n        for(int i = 0;i<address.length();i++){\\n            if(address.charAt(i) == \\'.\\')\\n                res.append(\"[.]\");\\n            else\\n                res.append(address.charAt(i));\\n        }\\n        \\n        return res.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder res = new StringBuilder();\\n        \\n        for(int i = 0;i<address.length();i++){\\n            if(address.charAt(i) == \\'.\\')\\n                res.append(\"[.]\");\\n            else\\n                res.append(address.charAt(i));\\n        }\\n        \\n        return res.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471519,
                "title": "c-100",
                "content": "class Solution \\n{\\n    public:\\n    \\n    std::string defangIPaddr(std::string a) \\n    {       \\n        for(size_t i = 0 ;; i++)\\n        {\\n            if(a[i] == \\'.\\')\\n            {\\n                a.replace(i, 1, std::string(\"[.]\"));\\n                i++;\\n            }\\n                          \\n            if(i == a.size() - 1) break;\\n        }\\n        \\n        return a;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution \\n{\\n    public:\\n    \\n    std::string defangIPaddr(std::string a) \\n    {       \\n        for(size_t i = 0 ;; i++)\\n        {\\n            if(a[i] == \\'.\\')\\n            {\\n                a.replace(i, 1, std::string(\"[.]\"));\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 438253,
                "title": "python-3-24-ms-faster-than-96-73",
                "content": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\",\"[.]\")\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\",\"[.]\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 381707,
                "title": "javascript",
                "content": "```\\nvar defangIPaddr = function(address) {\\n    return address.split(\\'.\\').join(\\'[.]\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar defangIPaddr = function(address) {\\n    return address.split(\\'.\\').join(\\'[.]\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808184,
                "title": "java-one-line-code",
                "content": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673917,
                "title": "python-simple-solution-in-7-lines-faster-than-96-41",
                "content": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        s=\\'\\'\\n        for i in address:\\n            if i==\\'.\\':\\n                s+=\\'[.]\\'\\n            else:\\n                s+=i\\n        return s\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        s=\\'\\'\\n        for i in address:\\n            if i==\\'.\\':\\n                s+=\\'[.]\\'\\n            else:\\n                s+=i\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094299,
                "title": "c-solution",
                "content": "```\\nchar * defangIPaddr(char * address){\\n    char * buffer = (char *)malloc(30*sizeof(char));\\n    int a = 0, b = 0, c = 0, d = 0;\\n    sscanf(address,\"%d.%d.%d.%d\",&a ,&b ,&c ,&d);\\n    sprintf(buffer,\"%d[.]%d[.]%d[.]%d\",a ,b ,c ,d);\\n    return buffer;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar * defangIPaddr(char * address){\\n    char * buffer = (char *)malloc(30*sizeof(char));\\n    int a = 0, b = 0, c = 0, d = 0;\\n    sscanf(address,\"%d.%d.%d.%d\",&a ,&b ,&c ,&d);\\n    sprintf(buffer,\"%d[.]%d[.]%d[.]%d\",a ,b ,c ,d);\\n    return buffer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 872844,
                "title": "c-o-n-one-line-replace-easy-answer",
                "content": "```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        return address.Replace(\".\", \"[.]\");\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public string DefangIPaddr(string address) {\\n        return address.Replace(\".\", \"[.]\");\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3436082,
                "title": "java-easy-solution-beats-100-runtime-0ms-2-methods-to-solve",
                "content": "Hope this helps!!\\nDo Upvote if you like it.\\n\\nThanks :)\\n# Code\\n```\\n//Method-1\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb= new StringBuilder();\\n        for(int i=0; i<address.length(); i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                sb.append(\"[.]\");\\n            }else{\\n                sb.append(address.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }    \\n}\\n\\n\\n// Method-2\\n\\n// class Solution {\\n//     public String defangIPaddr(String address) {\\n//         String str= address.replace(\".\",\"[.]\");\\n//         return str;\\n//     }    \\n// }\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Method-1\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb= new StringBuilder();\\n        for(int i=0; i<address.length(); i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                sb.append(\"[.]\");\\n            }else{\\n                sb.append(address.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }    \\n}\\n\\n\\n// Method-2\\n\\n// class Solution {\\n//     public String defangIPaddr(String address) {\\n//         String str= address.replace(\".\",\"[.]\");\\n//         return str;\\n//     }    \\n// }\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479795,
                "title": "c-solution",
                "content": "```\\nchar * defangIPaddr(char * address){\\n    char *result = (char *)malloc(sizeof(char) * (strlen(address) + 10));\\n    memset(result,0,strlen(address) + 10);\\n    int k = 0;\\n    for (int i = 0;address[i] != \\'\\\\0\\';i++) {\\n        if (address[i]==\\'.\\') {\\n            result[k] = \\'[\\';\\n            result[k+1] = \\'.\\';\\n            result[k+2] = \\']\\';\\n            k+=3;\\n        }else {\\n            result[k++] = address[i];\\n        }\\n    }\\n    result[k] = 0;\\n    return result;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * defangIPaddr(char * address){\\n    char *result = (char *)malloc(sizeof(char) * (strlen(address) + 10));\\n    memset(result,0,strlen(address) + 10);\\n    int k = 0;\\n    for (int i = 0;address[i] != \\'\\\\0\\';i++) {\\n        if (address[i]==\\'.\\') {\\n            result[k] = \\'[\\';\\n            result[k+1] = \\'.\\';\\n            result[k+2] = \\']\\';\\n            k+=3;\\n        }else {\\n            result[k++] = address[i];\\n        }\\n    }\\n    result[k] = 0;\\n    return result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427653,
                "title": "c-two-solutions",
                "content": "It is important for me as a C# programmer to warm up all kinds of class and common APIs. string.Join and string.Split are two APIs which can be used to solve the problem. \\n\\n\\n\\nSolution 1: \\n\\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n     \\n        if(address == null || address.Length == 0)\\n            return \"\";\\n        \\n        return string.Join(\"[.]\", address.Split(\\'.\\'));\\n    }\\n}\\n```\\nSolution II:\\n```\\npublic string DefangIPaddr(string address)\\n{\\n\\tif (address == null || address.Length == 0)\\n\\t\\treturn \"\";\\n\\n    var defangled = new StringBuilder();\\n\\n    foreach (var item in address)\\n    {\\n\\t\\tif (item == \\'.\\')\\n        {\\n\\t\\t\\tdefangled.Append(\"[.]\");\\n        }\\n        else\\n        {\\n\\t\\t\\tdefangled.Append(item);\\n        }\\n\\t}\\n\\n    return defangled.ToString();\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n     \\n        if(address == null || address.Length == 0)\\n            return \"\";\\n        \\n        return string.Join(\"[.]\", address.Split(\\'.\\'));\\n    }\\n}\\n```\n```\\npublic string DefangIPaddr(string address)\\n{\\n\\tif (address == null || address.Length == 0)\\n\\t\\treturn \"\";\\n\\n    var defangled = new StringBuilder();\\n\\n    foreach (var item in address)\\n    {\\n\\t\\tif (item == \\'.\\')\\n        {\\n\\t\\t\\tdefangled.Append(\"[.]\");\\n        }\\n        else\\n        {\\n\\t\\t\\tdefangled.Append(item);\\n        }\\n\\t}\\n\\n    return defangled.ToString();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077687,
                "title": "100-beats-with-0ms-easy-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string s;\\n        for(int i=0;i<address.size();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                s=s+\"[.]\";\\n            }\\n            else\\n            {\\n                s=s+address[i];\\n            }\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string s;\\n        for(int i=0;i<address.size();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                s=s+\"[.]\";\\n            }\\n            else\\n            {\\n                s=s+address[i];\\n            }\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900111,
                "title": "beats-98-93-of-python-solutions-at-runtime-beats-95-22-of-python-solutions-in-memory-usage",
                "content": "Please Upvote if you find the solution useful.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Used String replace() function. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        x = address.replace(\".\",\"[.]\")\\n        return x\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        x = address.replace(\".\",\"[.]\")\\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833009,
                "title": "c-std-regex-replace-one-liner",
                "content": "Maybe a bit of an overkill, but quick to write. :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        return regex_replace(address, regex(\"[.]\"), \"[.]\");\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        return regex_replace(address, regex(\"[.]\"), \"[.]\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432727,
                "title": "java-easy-100-fast-stringbuilder-class",
                "content": "# Please Upvote\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n```\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Defanging an IP Address.\\nMemory Usage: 41.9 MB, less than 64.91% of Java online submissions for Defanging an IP Address.\\n```\\n```\\nStringBuilder sb = new StringBuilder();\\n        for(char c : address.toCharArray()){\\n            if(c == \\'.\\'){\\n                sb.append(\\'[\\');\\n                sb.append(c);\\n                sb.append(\\']\\');\\n            }else\\n                sb.append(c);\\n        }\\n        return sb.toString();\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Defanging an IP Address.\\nMemory Usage: 41.9 MB, less than 64.91% of Java online submissions for Defanging an IP Address.\\n```\n```\\nStringBuilder sb = new StringBuilder();\\n        for(char c : address.toCharArray()){\\n            if(c == \\'.\\'){\\n                sb.append(\\'[\\');\\n                sb.append(c);\\n                sb.append(\\']\\');\\n            }else\\n                sb.append(c);\\n        }\\n        return sb.toString();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1340914,
                "title": "simple-c-faster-than-100-00-basic-string",
                "content": "Using basic string operation we can solve this problem.\\nIn the given string where we find `\\'.\\'`, we add `[.]` to the answer string, otherwise we add the character normally.\\n```class Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans = \"\" ;\\n        for(auto i:address)\\n        {\\n            if(i == \\'.\\')\\n            {\\n                ans += \"[.]\" ;\\n            }\\n            else\\n            {\\n                ans += i ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans = \"\" ;\\n        for(auto i:address)\\n        {\\n            if(i == \\'.\\')\\n            {\\n                ans += \"[.]\" ;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1247232,
                "title": "100-faster-c-solution",
                "content": "The basic strategy for the solution is to add each character one by one to a new string and as soon as the pointer encounters \\'.\\' (period) we will add a string \\'[.]\\' to this new string else the char is added to that string.\\n\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string re=\"\";\\n        for(int i=0;i<address.length();++i)\\n        {\\n            if(address[i]==\\'.\\')\\n                re+=\"[.]\";\\n            else\\n                re+=address[i];\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string re=\"\";\\n        for(int i=0;i<address.length();++i)\\n        {\\n            if(address[i]==\\'.\\')\\n                re+=\"[.]\";\\n            else\\n                re+=address[i];\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153918,
                "title": "swift-defanging-an-ip-address",
                "content": "```swift\\nclass Solution {\\n    func defangIPaddr(_ address: String) -> String {\\n        return address.components(separatedBy: \".\").joined(separator: \"[.]\")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func defangIPaddr(_ address: String) -> String {\\n        return address.components(separatedBy: \".\").joined(separator: \"[.]\")\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113407,
                "title": "easy-to-understand-in-python-3",
                "content": "Easy To Understand Python Solution:\\n\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        \\n        answerString = \"\"\\n        for c in address:\\n            if c == \".\":\\n                answerString += \"[.]\"\\n            else:\\n                answerString += c\\n        \\n        return answerString\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        \\n        answerString = \"\"\\n        for c in address:\\n            if c == \".\":\\n                answerString += \"[.]\"\\n            else:\\n                answerString += c\\n        \\n        return answerString\\n```",
                "codeTag": "Java"
            },
            {
                "id": 996880,
                "title": "very-easy-solution-c-java-o-n-very-easy-to-understand",
                "content": "Implementation\\n\\n**1st Approach in C++**\\n\\n**Time Complexity = O(N), Space Complexity = O(N)**\\n\\n```\\nstring defangIPaddr(string address) {\\n    string str;\\n    for(int itr = 0; itr < address.size(); itr++){\\n        if(address[itr] == \\'.\\') str += \"[.]\";                \\n        else str += address[itr];                \\n    }            \\n    return str;\\n}\\n```\\n\\n\\n**2nd Approach in Java**\\n\\n**Time Complexity = O(N), Space Complexity = O(N)**\\n\\n```\\npublic String defangIPaddr(String address) {\\n    String str = \"\";\\n    for(int itr = 0; itr < address.length(); itr++){\\n        if(address.charAt(itr) == \\'.\\') str += \"[.]\";                \\n        else str += address.charAt(itr);                \\n    }            \\n    return str;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "String"
                ],
                "code": "```\\nstring defangIPaddr(string address) {\\n    string str;\\n    for(int itr = 0; itr < address.size(); itr++){\\n        if(address[itr] == \\'.\\') str += \"[.]\";                \\n        else str += address[itr];                \\n    }            \\n    return str;\\n}\\n```\n```\\npublic String defangIPaddr(String address) {\\n    String str = \"\";\\n    for(int itr = 0; itr < address.length(); itr++){\\n        if(address.charAt(itr) == \\'.\\') str += \"[.]\";                \\n        else str += address.charAt(itr);                \\n    }            \\n    return str;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 810808,
                "title": "javascript-solution-1108",
                "content": "```\\n/**\\n * @param {string} address\\n * @return {string}\\n */\\nlet defangIPaddr = function(address) {\\n        return address.replace(/[.]/g,\\'[.]\\')\\n    };\\n```\\n\\n**Runtime: 76 ms, faster than 54.73% of JavaScript online submissions for Defanging an IP Address.**\\n\\n**Memory Usage: 36.9 MB, less than 5.00% of JavaScript online submissions for Defanging an IP Address.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} address\\n * @return {string}\\n */\\nlet defangIPaddr = function(address) {\\n        return address.replace(/[.]/g,\\'[.]\\')\\n    };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774568,
                "title": "python-solution-with-and-without-inbuilt-function",
                "content": "With Inbuit Function:\\n---------------\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\", \"[.]\")\\n```\\n\\nWithout Inbuit Function: O(n)\\n--------------------\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        res=\"\"\\n        for i in range(len(address)):\\n            if (address[i]!=\\'.\\'):\\n                res+=address[i]\\n            else:\\n                res+=\"[.]\"\\n        return res\\n```\\nhttps://github.com/shubhamthrills",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\", \"[.]\")\\n```\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        res=\"\"\\n        for i in range(len(address)):\\n            if (address[i]!=\\'.\\'):\\n                res+=address[i]\\n            else:\\n                res+=\"[.]\"\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526222,
                "title": "java-replace-vs-replace-all-join",
                "content": "```\\npublic String defangIPaddr(String address) {\\n        //return String.join(\"[.]\", address.split(\"\\\\\\\\.\"));\\n        // return address.replaceAll(\"\\\\\\\\.\", \"[.]\"); // use reges \" \\\\\\\\.\" other than \".\";\\n        return address.replace(\".\", \"[.]\");\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String defangIPaddr(String address) {\\n        //return String.join(\"[.]\", address.split(\"\\\\\\\\.\"));\\n        // return address.replaceAll(\"\\\\\\\\.\", \"[.]\"); // use reges \" \\\\\\\\.\" other than \".\";\\n        return address.replace(\".\", \"[.]\");\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 415553,
                "title": "it-says-runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "***Runtime: 0 ms, faster than 100.00% of C online submissions for Defanging an IP Address.\\nMemory Usage: 6.6 MB, less than 100.00% of C online submissions for Defanging an IP Address.***\\n\\nI\\'m new to programming, any suggestion with this code would be appreciated.\\n```\\n\\n\\nchar * defangIPaddr(char * address){\\n    \\n    int length = strlen(address), j = 0;\\n    char * returnIp = malloc((length + 7));\\n    \\n    for (int i = 0; i < length; i++)\\n    {\\n        if (address[i] != \\'.\\')\\n        {\\n            *(returnIp + j) = address[i];\\n            j++;\\n        }\\n        else\\n        {\\n            *(returnIp + j) = \\'[\\';\\n            *(returnIp + (j + 1)) = \\'.\\';\\n            *(returnIp + (j + 2)) = \\']\\';\\n            j = j + 3;\\n        }\\n    }\\n    \\n    *(returnIp + j) = \\'\\\\0\\';\\n    \\n    return returnIp;\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nchar * defangIPaddr(char * address){\\n    \\n    int length = strlen(address), j = 0;\\n    char * returnIp = malloc((length + 7));\\n    \\n    for (int i = 0; i < length; i++)\\n    {\\n        if (address[i] != \\'.\\')\\n        {\\n            *(returnIp + j) = address[i];\\n            j++;\\n        }\\n        else\\n        {\\n            *(returnIp + j) = \\'[\\';\\n            *(returnIp + (j + 1)) = \\'.\\';\\n            *(returnIp + (j + 2)) = \\']\\';\\n            j = j + 3;\\n        }\\n    }\\n    \\n    *(returnIp + j) = \\'\\\\0\\';\\n    \\n    return returnIp;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383317,
                "title": "0ms-c-inverse-enumeration",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        for(int i = address.size(); i >= 0; i--){\\n            if(address[i] == \\'.\\'){\\n                address.replace(i, 1, \"[.]\");\\n            }\\n        }\\n        return address;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        for(int i = address.size(); i >= 0; i--){\\n            if(address[i] == \\'.\\'){\\n                address.replace(i, 1, \"[.]\");\\n            }\\n        }\\n        return address;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361331,
                "title": "defang-34-1mb-and-faster-than-100",
                "content": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder output =new StringBuilder();\\n        for (char ch: address.toCharArray()) {\\n            switch(ch) {\\n                case \\'.\\' : output.append(\"[.]\"); break;\\n                default: output.append(ch); break;\\n            }\\n        }\\n        return output.toString();\\n    }\\n}\\n```\\nSwitch is faster than if/else and \\'?\\' statements. StringBuilder saves memory.\\nhttps://leetcode.com/submissions/detail/252654344/\\n\\nCheers.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder output =new StringBuilder();\\n        for (char ch: address.toCharArray()) {\\n            switch(ch) {\\n                case \\'.\\' : output.append(\"[.]\"); break;\\n                default: output.append(ch); break;\\n            }\\n        }\\n        return output.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339583,
                "title": "kotlin-different-approach",
                "content": "```\\nclass Solution {\\n    fun defangIPaddr(address: String): String = StringBuilder().run { \\n        address.forEach{\\n            if(it.equals(\\'.\\')){\\n                append(\"[.]\")\\n            }else{\\n                append(it)\\n            }\\n        }\\n        toString()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun defangIPaddr(address: String): String = StringBuilder().run { \\n        address.forEach{\\n            if(it.equals(\\'.\\')){\\n                append(\"[.]\")\\n            }else{\\n                append(it)\\n            }\\n        }\\n        toString()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330713,
                "title": "python-one-liner",
                "content": "class Solution(object):\\n    def defangIPaddr(self, address):\\n        \"\"\"\\n        :type address: str\\n        :rtype: str\\n        \"\"\"\\n        return \"[.]\".join(address.split(\\'.\\'))",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def defangIPaddr(self, address):\\n        \"\"\"\\n        :type address: str\\n        :rtype: str\\n        \"\"\"\\n        return \"[.]\".join(address.split(\\'.\\'))",
                "codeTag": "Java"
            },
            {
                "id": 3650582,
                "title": "1108-defanging-an-ip-address-100-easy-java-program",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n\\n        String str = address.replace(\".\",\"[.]\");\\n        return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n\\n        String str = address.replace(\".\",\"[.]\");\\n        return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181188,
                "title": "100-beat-zero-run-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string a) {\\n        queue<char>q;\\n        int i=0;\\n        while(i<a.size()){\\n            q.push(a[i]);\\n            i++;\\n        }\\n\\n        string s;\\n        while(!q.empty()){\\n            if(q.front()==\\'.\\'){\\n                s+=\\'[\\';\\n                s+=\\'.\\';\\n                s+=\\']\\';\\n                q.pop();\\n            }\\n\\n            else{\\n                s+=q.front();\\n                q.pop();\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string a) {\\n        queue<char>q;\\n        int i=0;\\n        while(i<a.size()){\\n            q.push(a[i]);\\n            i++;\\n        }\\n\\n        string s;\\n        while(!q.empty()){\\n            if(q.front()==\\'.\\'){\\n                s+=\\'[\\';\\n                s+=\\'.\\';\\n                s+=\\']\\';\\n                q.pop();\\n            }\\n\\n            else{\\n                s+=q.front();\\n                q.pop();\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178837,
                "title": "c-straightforward-clean-code-beginner-friendly",
                "content": "![image](https://assets.leetcode.com/users/images/12c0dc6b-6db7-4dad-bed4-8b8b710ecdbe_1676265829.7416234.png)\\n\\n**n == address.size()\\nT->O(n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring defangIPaddr(string address) {\\n\\t\\t\\tstring defan = \"\";\\n\\n\\t\\t\\tfor(auto i : address){\\n\\t\\t\\t\\tif(i == \\'.\\'){\\n\\t\\t\\t\\t\\tdefan += \"[.]\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tdefan += i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn defan;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring defangIPaddr(string address) {\\n\\t\\t\\tstring defan = \"\";\\n\\n\\t\\t\\tfor(auto i : address){\\n\\t\\t\\t\\tif(i == \\'.\\'){\\n\\t\\t\\t\\t\\tdefan += \"[.]\";\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3127222,
                "title": "c-solution",
                "content": "\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans;\\n        for(int i=0;i<address.length();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            ans+=\"[.]\";\\n\\n            else\\n            ans+=address[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans;\\n        for(int i=0;i<address.length();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            ans+=\"[.]\";\\n\\n            else\\n            ans+=address[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087962,
                "title": "beats-94-61-in-time",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) \\n    {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < address.Length; i++)\\n        {\\n            if (address[i] == \\'.\\')\\n                sb.Append(\"[.]\");\\n            else\\n                sb.Append(address[i]);\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string DefangIPaddr(string address) \\n    {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < address.Length; i++)\\n        {\\n            if (address[i] == \\'.\\')\\n                sb.Append(\"[.]\");\\n            else\\n                sb.Append(address[i]);\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731024,
                "title": "one-line-easiest-python-solution",
                "content": "**Hi there!  Please upvote**\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str: \\n        \\n        return address.replace(\\'.\\', \\'[.]\\')\\n        \\n        \\n``` \\n**Happy Coding :)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str: \\n        \\n        return address.replace(\\'.\\', \\'[.]\\')\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673922,
                "title": "python-simple-one-line-solution",
                "content": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\\'.\\',\\'[.]\\')\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\\'.\\',\\'[.]\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212726,
                "title": "c-sol-in-place",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) \\n    {\\n        for(int i=0,j=0;j<3;i++){\\n            if(address[i]==\\'.\\'){\\n                address.insert(address.begin()+(i),\\'[\\');\\n                address.insert(address.begin()+(i+2),\\']\\');\\n                i++;\\n                j++;\\n            }\\n        }\\n        return address;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string defangIPaddr(string address) \\n    {\\n        for(int i=0,j=0;j<3;i++){\\n            if(address[i]==\\'.\\'){\\n                address.insert(address.begin()+(i),\\'[\\');\\n                address.insert(address.begin()+(i+2),\\']\\');\\n                i++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1493059,
                "title": "java-solution-faster-then-100-easy-explanation-with-code-and-comments",
                "content": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder ans = new StringBuilder();    // We are using StringBuilder instead of String bcz StringBuilder is mutable and using this we can change the string without creating new objects. While in case of String it will keep creating new objects hence wastage of memory\\n        \\n        for(int i=0;i<address.length();i++){\\n            if(address.charAt(i) == \\'.\\')    // if \\'.\\' is present in the string then replace it with \\'[.]\\'\\n                ans.append(\"[.]\");\\n            else\\n                ans.append(address.charAt(i));   // keep adding other things as it is\\n        }\\n        return ans.toString();    // We can\\'t directly return \"ans\" as \"ans\" is of type StringBuilder and we have to return String. Hence, ans.toString() \\n    }\\n}\\n\\n// If you find this post helpful then plz upvote :-)\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder ans = new StringBuilder();    // We are using StringBuilder instead of String bcz StringBuilder is mutable and using this we can change the string without creating new objects. While in case of String it will keep creating new objects hence wastage of memory\\n        \\n        for(int i=0;i<address.length();i++){\\n            if(address.charAt(i) == \\'.\\')    // if \\'.\\' is present in the string then replace it with \\'[.]\\'\\n                ans.append(\"[.]\");\\n            else\\n                ans.append(address.charAt(i));   // keep adding other things as it is\\n        }\\n        return ans.toString();    // We can\\'t directly return \"ans\" as \"ans\" is of type StringBuilder and we have to return String. Hence, ans.toString() \\n    }\\n}\\n\\n// If you find this post helpful then plz upvote :-)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263589,
                "title": "simple-c-code-100-faster",
                "content": "```\\nstring defangIPaddr(string address) {\\n       for(int i=1;i<address.size();i++){\\n           if(address[i]==\\'.\\'){\\n              address.insert(i,\"[\");\\n              address.insert(i+2,\"]\");\\n               i+=2;\\n           }\\n         }\\n        return address;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring defangIPaddr(string address) {\\n       for(int i=1;i<address.size();i++){\\n           if(address[i]==\\'.\\'){\\n              address.insert(i,\"[\");\\n              address.insert(i+2,\"]\");\\n               i+=2;\\n           }\\n         }\\n        return address;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 953318,
                "title": "rust-one-liner",
                "content": "```rust\\npub fn defang_i_paddr(address: String) -> String {\\n\\taddress.replace(\\'.\\', \"[.]\")\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn defang_i_paddr(address: String) -> String {\\n\\taddress.replace(\\'.\\', \"[.]\")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 857770,
                "title": "python-one-line-string-replace",
                "content": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\",\"[.]\")\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\",\"[.]\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703556,
                "title": "c-speed-mem-o-n-o-n-simple-video",
                "content": "\\nClick URL: https://youtu.be/LI-Jis4xOMI\\nClicking the play button does not work.\\n\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        \\n        string out;\\n        for(int i=0; i < address.size(); i++){\\n            if(address[i]==\\'.\\')\\n                out += \"[.]\";\\n            else\\n                out += address[i];\\n        }\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        \\n        string out;\\n        for(int i=0; i < address.size(); i++){\\n            if(address[i]==\\'.\\')\\n                out += \"[.]\";\\n            else\\n                out += address[i];\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621885,
                "title": "100-100-java-silly-question",
                "content": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533313,
                "title": "naive-c-97-5-time-100-memory",
                "content": "```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        char[] newAddress = new char[address.Length + 6];\\n        int pointer = 0;\\n        \\n        foreach(char c in address) {\\n            if (c == \\'.\\') {\\n                newAddress[pointer++] = \\'[\\';\\n                newAddress[pointer++] = \\'.\\';\\n                newAddress[pointer++] = \\']\\';\\n            } else {\\n                newAddress[pointer++] = c;\\n            }\\n        }\\n        \\n        return new string(newAddress);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        char[] newAddress = new char[address.Length + 6];\\n        int pointer = 0;\\n        \\n        foreach(char c in address) {\\n            if (c == \\'.\\') {\\n                newAddress[pointer++] = \\'[\\';\\n                newAddress[pointer++] = \\'.\\';\\n                newAddress[pointer++] = \\']\\';\\n            } else {\\n                newAddress[pointer++] = c;\\n            }\\n        }\\n        \\n        return new string(newAddress);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485800,
                "title": "1108-defanging-an-ip-address",
                "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        String result = \"\";\\n        for(int i = 0; i < address.length(); i ++){\\n            if(address.charAt(i)==\\'.\\'){\\n                result = result.concat(\"[\")\\n                               .concat(String.valueOf(address.charAt(i)))\\n                               .concat(\"]\");\\n            }else{\\n                result = result.concat(String.valueOf(address.charAt(i)));\\n            }\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String defangIPaddr(String address) {\\n        String result = \"\";\\n        for(int i = 0; i < address.length(); i ++){\\n            if(address.charAt(i)==\\'.\\'){\\n                result = result.concat(\"[\")\\n                               .concat(String.valueOf(address.charAt(i)))\\n                               .concat(\"]\");\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 361663,
                "title": "c-one-liner",
                "content": "```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        return address.Replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        return address.Replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358386,
                "title": "1-line-in-javascript",
                "content": "```javascript\\n\\taddress.split(\\'.\\').join(\\'[.]\\')\\n```\\n\\nThat\\'s it!",
                "solutionTags": [],
                "code": "```javascript\\n\\taddress.split(\\'.\\').join(\\'[.]\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349451,
                "title": "python-solution",
                "content": "```\\n    def defangIPaddr(self, address):\\n        return address.replace(\".\", \"[.]\")\\n```",
                "solutionTags": [],
                "code": "```\\n    def defangIPaddr(self, address):\\n        return address.replace(\".\", \"[.]\")\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 331492,
                "title": "javascript-solution-o-n-time",
                "content": "```\\nvar defangIPaddr = function(address) {\\n    let str = \\'\\';\\n    for(let i = 0; i < address.length; i++){\\n        let char = address.charAt(i);\\n        if(char == \\'.\\') char = \\'[.]\\';\\n        str = str + char;\\n    }\\n    return str;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar defangIPaddr = function(address) {\\n    let str = \\'\\';\\n    for(let i = 0; i < address.length; i++){\\n        let char = address.charAt(i);\\n        if(char == \\'.\\') char = \\'[.]\\';\\n        str = str + char;\\n    }\\n    return str;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330484,
                "title": "c-solution",
                "content": "\\tchar * defangIPaddr(char * address)\\n\\t{\\n\\t\\tint len = strlen(address);\\n\\t\\tchar *res = malloc(sizeof(char) * (len + 7)); // 6 for 3 sets of brackets + 1 NULL\\n\\n\\t\\tint i = 0, j = 0;\\n\\t\\twhile (i < len)\\n\\t\\t{   \\n\\t\\t\\tres[j++] = address[i];\\n\\n\\t\\t\\tif (address[i+1] == \\'.\\') \\n\\t\\t\\t{\\n\\t\\t\\t\\tres[j++] = \\'[\\';\\n\\t\\t\\t\\tres[j++] = address[++i];\\n\\t\\t\\t\\tres[j++] = \\']\\';\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tres[j] = \\'\\\\0\\';\\n\\t\\treturn res;\\n\\t}",
                "solutionTags": [],
                "code": "\\tchar * defangIPaddr(char * address)\\n\\t{\\n\\t\\tint len = strlen(address);\\n\\t\\tchar *res = malloc(sizeof(char) * (len + 7)); // 6 for 3 sets of brackets + 1 NULL\\n\\n\\t\\tint i = 0, j = 0;\\n\\t\\twhile (i < len)\\n\\t\\t{   \\n\\t\\t\\tres[j++] = address[i];\\n\\n\\t\\t\\tif (address[i+1] == \\'.\\') \\n\\t\\t\\t{\\n\\t\\t\\t\\tres[j++] = \\'[\\';\\n\\t\\t\\t\\tres[j++] = address[++i];\\n\\t\\t\\t\\tres[j++] = \\']\\';\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tres[j] = \\'\\\\0\\';\\n\\t\\treturn res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 329626,
                "title": "javascript-1-line-faster-than-100",
                "content": "This is a simple text replacement problem. Break the string into an array by separating on \".\" . Then rejoin the string with the new text, \"[.]\" using array join.\\n```\\n//100% on speed and space \\n//https://leetcode.com/problems/defanging-an-ip-address/submissions/\\n\\n/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n    return address.split(\".\").join(\\'[.]\\')\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//100% on speed and space \\n//https://leetcode.com/problems/defanging-an-ip-address/submissions/\\n\\n/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n    return address.split(\".\").join(\\'[.]\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3993949,
                "title": "1-line",
                "content": "***String has replace method which takes two parameters String.replace(\"old one\",\"new one\");\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n\\n\\n```\\n![f9e51783-3660-4252-933c-ec2c42b2d57d_1677809905.0379472.jpeg](https://assets.leetcode.com/users/images/607eea57-2eaf-4410-9174-96cee82995a0_1693680746.2719412.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934872,
                "title": "easy-peasy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string adress) {\\n        string ans=\"\";\\n\\n\\n        for(int i=0;i<adress.size();i++)\\n        {\\n            if(adress[i]==\\'.\\')\\n            {\\n                ans+=\"[.]\";\\n            }\\n            else\\n            {\\n                ans+=adress[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string adress) {\\n        string ans=\"\";\\n\\n\\n        for(int i=0;i<adress.size();i++)\\n        {\\n            if(adress[i]==\\'.\\')\\n            {\\n                ans+=\"[.]\";\\n            }\\n            else\\n            {\\n                ans+=adress[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862213,
                "title": "100-beats-in-time-and-99-50-beats-in-memory-java-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n       int n = address.length();\\n       StringBuilder sb = new StringBuilder();\\n       for(int i=0;i<n;i++){\\n           if(address.charAt(i)==\\'.\\'){\\n               sb.append(\"[\");\\n               sb.append(\".\");\\n               sb.append(\"]\");\\n           }\\n           else{\\n               sb.append(address.charAt(i));\\n           }\\n       } \\n       String str = sb.toString();\\n       return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n       int n = address.length();\\n       StringBuilder sb = new StringBuilder();\\n       for(int i=0;i<n;i++){\\n           if(address.charAt(i)==\\'.\\'){\\n               sb.append(\"[\");\\n               sb.append(\".\");\\n               sb.append(\"]\");\\n           }\\n           else{\\n               sb.append(address.charAt(i));\\n           }\\n       } \\n       String str = sb.toString();\\n       return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623258,
                "title": "java-very-easy-solution-with-100-beats-0ms-runtime-memory-40-6mb-t-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342662,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\\'.\\', \\'[.]\\')\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\\'.\\', \\'[.]\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339179,
                "title": "defangipaddr-function-is-simple",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the defangIPaddr function is simple. It loops through the input string character by character and checks if the character is a period .. If it is, it adds [.] to the defanged_address string. Otherwise, it adds the character as it is to the defanged_address string.\\n\\n# Complexity\\n\\nThe time complexity of this code is O(n), where n is the length of the input string. This is because the code loops through the input string character by character, and each character is examined only once.\\n\\nThe space complexity of this code is also O(n), where n is the length of the input string. This is because a new string defanged_address is created to hold the defanged IP address, and its size can be as large as the input string if every character in the input string is a period.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string defanged_address;\\n\\n        for (size_t i = 0; i < address.size(); i++) {\\n            if (address[i] == \\'.\\') {\\n                defanged_address += \"[.]\";\\n            } else {\\n                defanged_address += address[i];\\n        }\\n    }\\n\\n    return defanged_address;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string defanged_address;\\n\\n        for (size_t i = 0; i < address.size(); i++) {\\n            if (address[i] == \\'.\\') {\\n                defanged_address += \"[.]\";\\n            } else {\\n                defanged_address += address[i];\\n        }\\n    }\\n\\n    return defanged_address;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181930,
                "title": "faster-than-100-with-explanation-easy",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Declare a StringBuider class or you can just create another String to modify the value\\n2. If you find **\\' . \\'** in the String then append the String by **\"[.]\"** and increase the index.\\n3. Else add other characters as it is in the String.\\n4. then return the ans in the String by using sb.**toString()** method\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<address.length();i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                sb.append(\"[.]\");\\n                i++;\\n            }\\n            sb.append(address.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<address.length();i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                sb.append(\"[.]\");\\n                i++;\\n            }\\n            sb.append(address.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181192,
                "title": "100-beat-0ms-run-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string s) {\\n        queue<char> s1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'.\\'){\\n                s1.push(\\'[\\');\\n                s1.push(s[i]);\\n                s1.push(\\']\\');\\n            }else{\\n                s1.push(s[i]);\\n            }\\n        }\\n        string st;\\n        while(!s1.empty()){\\n            st+=s1.front();\\n            s1.pop();\\n        }\\n        return st;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string s) {\\n        queue<char> s1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'.\\'){\\n                s1.push(\\'[\\');\\n                s1.push(s[i]);\\n                s1.push(\\']\\');\\n            }else{\\n                s1.push(s[i]);\\n            }\\n        }\\n        string st;\\n        while(!s1.empty()){\\n            st+=s1.front();\\n            s1.pop();\\n        }\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181191,
                "title": "100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string str;\\n        for(int i=0;i<address.size();i++){\\n            if(address[i]==\\'.\\'){\\n                str+=\\'[\\';\\n                str+=\\'.\\';\\n                str+=\\']\\';\\n            }\\n            else\\n            str+=address[i];\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string str;\\n        for(int i=0;i<address.size();i++){\\n            if(address[i]==\\'.\\'){\\n                str+=\\'[\\';\\n                str+=\\'.\\';\\n                str+=\\']\\';\\n            }\\n            else\\n            str+=address[i];\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181177,
                "title": "100-beat-best-and-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string s) {\\n             queue<int>q;\\n             string p;\\n        for (int i=0;i<s.size();i++){\\n              q.push(s[i]); \\n        } \\n            while(!q.empty()){\\n                if (q.front()==\\'.\\'){\\n                  p+=\\'[\\';\\n                  p+=\\'.\\';\\n                  p+=\\']\\';\\n                }\\n                else {\\n                    p+=q.front();\\n                }\\n                q.pop();\\n            }\\n        return p; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string s) {\\n             queue<int>q;\\n             string p;\\n        for (int i=0;i<s.size();i++){\\n              q.push(s[i]); \\n        } \\n            while(!q.empty()){\\n                if (q.front()==\\'.\\'){\\n                  p+=\\'[\\';\\n                  p+=\\'.\\';\\n                  p+=\\']\\';\\n                }\\n                else {\\n                    p+=q.front();\\n                }\\n                q.pop();\\n            }\\n        return p; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127169,
                "title": "java-solution-fast-0-ms-100-simple-and-optimal",
                "content": "\\n1 method\\nRuntime : 0ms [100%]\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder str = new StringBuilder();\\n        for(char x:address.toCharArray()){\\n            if(x==\\'.\\')str.append(\"[.]\");\\n            else str.append(x);\\n        }\\n        return str.toString();\\n    }\\n}\\n-----------------------------------------------------------------\\n```\\n2 method \\n\\nRuntime : 2ms [29.51%]\\n# Code\\n```\\n\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replaceAll(\"\\\\\\\\.\",\"[.]\");\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder str = new StringBuilder();\\n        for(char x:address.toCharArray()){\\n            if(x==\\'.\\')str.append(\"[.]\");\\n            else str.append(x);\\n        }\\n        return str.toString();\\n    }\\n}\\n-----------------------------------------------------------------\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862446,
                "title": "java-clean-char-array-solution-two-pointers-0-ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        char[] charArray = new char[address.length() + (2 * 3)];\\n        for (int i = 0, y = 0; i < address.length(); i++, y++) {\\n            char current = address.charAt(i);\\n            if (current == \\'.\\') {\\n                charArray[y++] = \\'[\\';\\n                charArray[y++] = current;\\n                charArray[y] = \\']\\';\\n            } else {\\n                charArray[y] = current;\\n            }\\n        }\\n        return String.valueOf(charArray);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        char[] charArray = new char[address.length() + (2 * 3)];\\n        for (int i = 0, y = 0; i < address.length(); i++, y++) {\\n            char current = address.charAt(i);\\n            if (current == \\'.\\') {\\n                charArray[y++] = \\'[\\';\\n                charArray[y++] = current;\\n                charArray[y] = \\']\\';\\n            } else {\\n                charArray[y] = current;\\n            }\\n        }\\n        return String.valueOf(charArray);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796827,
                "title": "java-2-solutions-easy",
                "content": "### **Please Upvote** :D\\n##### 1. Using in-built **`replace()`** method:\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n\\n// TC: O(n)\\n```\\n##### 2. Using StringBuilder:\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (char c : address.toCharArray()) {\\n            if (c != \\'.\\') sb.append(c);\\n            else sb.append(\"[.]\");\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n\\n// TC: O(n)\\n```\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (char c : address.toCharArray()) {\\n            if (c != \\'.\\') sb.append(c);\\n            else sb.append(\"[.]\");\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561329,
                "title": "one-line-solution",
                "content": "```\\nvar defangIPaddr = function (address) {\\n  return address.split(\".\").join(\"[.]\");\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar defangIPaddr = function (address) {\\n  return address.split(\".\").join(\"[.]\");\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2441556,
                "title": "python-90-faster-and-low-memory-usage",
                "content": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\", \"[.]\")\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\", \"[.]\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415896,
                "title": "c-solution-easy-and-simple",
                "content": "class Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n\\t\\n        string ans=\"\";\\n        for(int i=0; i<address.length(); i++){\\n            if(address[i]==\\'.\\') \\n                ans+=\"[.]\"; \\n            else\\n                ans+=address[i];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n\\t\\n        string ans=\"\";\\n        for(int i=0; i<address.length(); i++){\\n            if(address[i]==\\'.\\') \\n                ans+=\"[.]\"; \\n            else\\n                ans+=address[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2389486,
                "title": "c-easiest-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n     string res;\\n        for(int i=0;i<address.length();i++){\\n         if(address[i]==\\'.\\'){\\n             res+=\"[.]\";\\n             \\n         }\\n        else{\\n                res+=address[i];\\n            }\\n     }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n     string res;\\n        for(int i=0;i<address.length();i++){\\n         if(address[i]==\\'.\\'){\\n             res+=\"[.]\";\\n             \\n         }\\n        else{\\n                res+=address[i];\\n            }\\n     }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203114,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "***If you lke it, Please Upvote***\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string str1 = \"[.]\";\\n        int i = 0;\\n        while(address[i] != \\'\\\\0\\') {\\n            if(address[i] == \\'.\\') {\\n                address.replace(i,1,str1);\\n                i++; //Incrementing for \\'.\\' presenting in \\'[.]\\' otherwise output will look like 255[[[[[[[.]]]]]]]100[[[[[[.]]]]]50[[[[[.]]]]]0\\n            }\\n            i++; //Incrementing for getting out of while loop\\n        }\\n        return address;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string str1 = \"[.]\";\\n        int i = 0;\\n        while(address[i] != \\'\\\\0\\') {\\n            if(address[i] == \\'.\\') {\\n                address.replace(i,1,str1);\\n                i++; //Incrementing for \\'.\\' presenting in \\'[.]\\' otherwise output will look like 255[[[[[[[.]]]]]]]100[[[[[[.]]]]]50[[[[[.]]]]]0\\n            }\\n            i++; //Incrementing for getting out of while loop\\n        }\\n        return address;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076384,
                "title": "c-easy-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string st;\\n        for(auto ch: address){\\n            if(ch==\\'.\\'){\\n                st=st+\"[.]\";\\n            }\\n            else{\\n                st=st+ch;}\\n        }\\n        return st;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string st;\\n        for(auto ch: address){\\n            if(ch==\\'.\\'){\\n                st=st+\"[.]\";\\n            }\\n            else{\\n                st=st+ch;}\\n        }\\n        return st;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697285,
                "title": "python-code-defanging-an-ip-address",
                "content": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        address=address.replace(\".\",\"[.]\")\\n        return address\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        address=address.replace(\".\",\"[.]\")\\n        return address\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507988,
                "title": "simple-to-understand-3-different-ways-using-basic-loops-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n**1. Using Split & Join**\\n\\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        var segments = address.Split(\".\");\\n        return string.Join(\"[.]\", segments);\\n    }\\n}\\n```\\n\\n**2. Using Basic Loop**\\n\\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        // Create new result\\n        var result = new StringBuilder();   \\n\\t\\t\\n        foreach (var ch in address) {\\n            if (ch == \\'.\\') {\\n                result.Append(\"[.]\");\\n            } else {\\n                result.Append(ch);\\n            }\\n        }        \\n        return result.ToString();\\n    }\\n}\\n```\\n\\n**3. Reconstruct New Result By Segments**\\n\\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        var segments = new List<string>();\\n        \\n        // Get the segments in the ip address\\n        var word = new StringBuilder();\\n        foreach (var ch in address) {\\n            if (ch != \\'.\\') {\\n                word.Append(ch);\\n            } else if (word.Length > 0) {\\n                segments.Add(word.ToString());\\n                word.Clear();\\n            }\\n        }\\n        \\n        // Add in any remaining data\\n        if (word.Length > 0) {\\n            segments.Add(word.ToString());\\n        }\\n        \\n        // Build the result \\n        var result = new StringBuilder();\\n        foreach (var item in segments) {\\n            if (result.Length > 0) {\\n                result.Append(\"[.]\");\\n            }\\n            result.Append(item);\\n        }\\n        \\n        return result.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        var segments = address.Split(\".\");\\n        return string.Join(\"[.]\", segments);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        // Create new result\\n        var result = new StringBuilder();   \\n\\t\\t\\n        foreach (var ch in address) {\\n            if (ch == \\'.\\') {\\n                result.Append(\"[.]\");\\n            } else {\\n                result.Append(ch);\\n            }\\n        }        \\n        return result.ToString();\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        var segments = new List<string>();\\n        \\n        // Get the segments in the ip address\\n        var word = new StringBuilder();\\n        foreach (var ch in address) {\\n            if (ch != \\'.\\') {\\n                word.Append(ch);\\n            } else if (word.Length > 0) {\\n                segments.Add(word.ToString());\\n                word.Clear();\\n            }\\n        }\\n        \\n        // Add in any remaining data\\n        if (word.Length > 0) {\\n            segments.Add(word.ToString());\\n        }\\n        \\n        // Build the result \\n        var result = new StringBuilder();\\n        foreach (var item in segments) {\\n            if (result.Length > 0) {\\n                result.Append(\"[.]\");\\n            }\\n            result.Append(item);\\n        }\\n        \\n        return result.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475717,
                "title": "c-simple-solution-beginner-friendly",
                "content": "```\\nstring defangIPaddr(string address) \\n    {\\n        string answer;\\n        for(int i=0;i<address.size();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                answer=answer+\"[.]\";\\n            }\\n            else \\n                answer=answer+address[i];\\n        }\\n        return answer;\\n    }\\n```\\n**Please Upvote if it helped you !!!\\nHappu Coding :)**",
                "solutionTags": [],
                "code": "```\\nstring defangIPaddr(string address) \\n    {\\n        string answer;\\n        for(int i=0;i<address.size();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                answer=answer+\"[.]\";\\n            }\\n            else \\n                answer=answer+address[i];\\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1446464,
                "title": "python-solutions",
                "content": "Method-1\\n```\\ndef defangingIPAddress(ipAddress):\\n    to_replace = \\'.\\'\\n    replaced = \\'[.]\\'\\n    new_string = \\'\\'\\n    for elem in ipAddress:\\n        if elem == to_replace:\\n            new_string += replaced\\n        else:\\n            new_string += elem\\n    return new_string\\n```\\n\\nMethod-2\\n```\\ndef defangingIPAddress(ipAddress):\\n    return ipAddress.replace(\\'.\\', \\'[.]\\')\\n```\\nMethod-3\\n```\\ndef defangingIPAddress(ipAddress):\\n    return \\'[.]\\'.join(ipAddress.split(\\'.\\'))\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef defangingIPAddress(ipAddress):\\n    to_replace = \\'.\\'\\n    replaced = \\'[.]\\'\\n    new_string = \\'\\'\\n    for elem in ipAddress:\\n        if elem == to_replace:\\n            new_string += replaced\\n        else:\\n            new_string += elem\\n    return new_string\\n```\n```\\ndef defangingIPAddress(ipAddress):\\n    return ipAddress.replace(\\'.\\', \\'[.]\\')\\n```\n```\\ndef defangingIPAddress(ipAddress):\\n    return \\'[.]\\'.join(ipAddress.split(\\'.\\'))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1408967,
                "title": "java-100-faster-and-93-48-less-memory-usage",
                "content": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n    StringBuilder sb = new StringBuilder();\\n    \\n    for(char a : address.toCharArray()){\\n        if(a == \\'.\\') sb.append(\"[.]\");\\n        else sb.append(a);\\n    }\\n    \\n    return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n    StringBuilder sb = new StringBuilder();\\n    \\n    for(char a : address.toCharArray()){\\n        if(a == \\'.\\') sb.append(\"[.]\");\\n        else sb.append(a);\\n    }\\n    \\n    return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395843,
                "title": "very-very-simple-c-solution-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        int n=address.length();\\n        string s=\"\";\\n        for(int i=0;i<n;i++){\\n            if(address[i]==\\'.\\'){\\n                s.push_back(\\'[\\');\\n                s.push_back(address[i]);\\n                s.push_back(\\']\\');\\n            }else{\\n                s.push_back(address[i]);\\n            }\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        int n=address.length();\\n        string s=\"\";\\n        for(int i=0;i<n;i++){\\n            if(address[i]==\\'.\\'){\\n                s.push_back(\\'[\\');\\n                s.push_back(address[i]);\\n                s.push_back(\\']\\');\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1265106,
                "title": "simple-java-solution-0ms-approach-100-faster",
                "content": "0ms Approach -\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");   //replacing all the occurences of  \".\"  with \"[.]\" and returning it\\n    }\\n}\\n```\\n\\nAnother approach(9ms Runtime)\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        String str = \"\";\\n        for(int i=0; i<address.length(); i++) {\\n\\t\\t//Replacing single occurence at a time and adding it to str\\n            if(address.charAt(i)==\\'.\\') {\\n                str = str + \"[.]\";\\n            }\\n            else {\\n                str = str + address.charAt(i);\\n            }\\n        }\\n        return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");   //replacing all the occurences of  \".\"  with \"[.]\" and returning it\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        String str = \"\";\\n        for(int i=0; i<address.length(); i++) {\\n\\t\\t//Replacing single occurence at a time and adding it to str\\n            if(address.charAt(i)==\\'.\\') {\\n                str = str + \"[.]\";\\n            }\\n            else {\\n                str = str + address.charAt(i);\\n            }\\n        }\\n        return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258669,
                "title": "runtime-0-ms-faster-than-100-00-of-java-1-liner-solution",
                "content": "We have a predefined function replace in java which is used to find and replace all the occurrences. \\nwant to know more - visit https://www.javatpoint.com/java-string-replace\\n\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        String s = address.replace(\".\",\"[.]\");\\n        return s;\\n    }\\n}\\n```\\n\\n**Upvote** if it is helpfull.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        String s = address.replace(\".\",\"[.]\");\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179242,
                "title": "cutest-solution-ever",
                "content": "**C++**\\n```\\nstring ans = \"\";\\nfor (char c: s)\\n\\tif (c == \\'.\\') ans += \"[.]\";\\n\\telse ans += c;\\nreturn ans;\\n```\\n**Java**\\n```\\nStringBuilder sb = new StringBuilder();\\nfor (int i = 0; i < s.length(); ++i)\\n\\tif (s.charAt(i) == \\'.\\') sb.append(\"[.]\");\\n\\telse sb.append(s.charAt(i));\\nreturn sb.toString();\\n```\\n**If you liked it, even a little bit then pls consider giving this solution a Upvote\\nThank You :)**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nstring ans = \"\";\\nfor (char c: s)\\n\\tif (c == \\'.\\') ans += \"[.]\";\\n\\telse ans += c;\\nreturn ans;\\n```\n```\\nStringBuilder sb = new StringBuilder();\\nfor (int i = 0; i < s.length(); ++i)\\n\\tif (s.charAt(i) == \\'.\\') sb.append(\"[.]\");\\n\\telse sb.append(s.charAt(i));\\nreturn sb.toString();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1167692,
                "title": "runtime-0-ms-faster-than-100-00",
                "content": "Memory Usage: 36.7 MB, less than 94.48%\\n\\nclass Solution {\\n    public String defangIPaddr(String address){\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String defangIPaddr(String address){\\n        return address.replace(\".\",\"[.]\");\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1137132,
                "title": "c-lambda-replace-runtime-80-ms-faster-than-85-84",
                "content": "```\\n public string DefangIPaddr( string address ) \\n        => address.Replace( \".\" ,  \"[.]\" );\\n```",
                "solutionTags": [],
                "code": "```\\n public string DefangIPaddr( string address ) \\n        => address.Replace( \".\" ,  \"[.]\" );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125365,
                "title": "python-3-one-liner",
                "content": "```\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\" , \"[.]\")\\n```",
                "solutionTags": [],
                "code": "```\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\" , \"[.]\")\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1116190,
                "title": "c-runtime-0ms-faster-than-100-submissions",
                "content": "```\\nchar * defangIPaddr(char * address){\\n    char *result;\\n    //Max size 22: 12 IP digits + 3 . + 6 braces + 1 null terminator\\n    result = (char*)malloc(22*sizeof(char));\\n    int i = 0, j = 0;\\n    for(i = 0; address[i] != \\'\\\\0\\'; i++){\\n        if (address[i] == \\'.\\') {\\n            result[j] = \\'[\\';\\n            result[j+1] = \\'.\\';\\n            result[j+2] = \\']\\';\\n            j = j+ 3;\\n        } else{\\n            result[j++] = address[i];\\n        }\\n    }\\n\\n    result[j] = \\'\\\\0\\';\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * defangIPaddr(char * address){\\n    char *result;\\n    //Max size 22: 12 IP digits + 3 . + 6 braces + 1 null terminator\\n    result = (char*)malloc(22*sizeof(char));\\n    int i = 0, j = 0;\\n    for(i = 0; address[i] != \\'\\\\0\\'; i++){\\n        if (address[i] == \\'.\\') {\\n            result[j] = \\'[\\';\\n            result[j+1] = \\'.\\';\\n            result[j+2] = \\']\\';\\n            j = j+ 3;\\n        } else{\\n            result[j++] = address[i];\\n        }\\n    }\\n\\n    result[j] = \\'\\\\0\\';\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1045209,
                "title": "javascript-oneliner-replace-with-regex-solution",
                "content": "```\\nconst defangIPaddr = address => address.replace(/\\\\./g, \\'[.]\\')\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst defangIPaddr = address => address.replace(/\\\\./g, \\'[.]\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1026311,
                "title": "one-line-in-java",
                "content": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941201,
                "title": "python-simple-solution",
                "content": "#### Solution 1: Using replace\\n\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\\'.\\',\\'[.]\\')\\n```\\n\\n#### Solution 2: Using join and split\\n\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return \\'[.]\\'.join(address.split(\\'.\\'))\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\\'.\\',\\'[.]\\')\\n```\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return \\'[.]\\'.join(address.split(\\'.\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930244,
                "title": "fastest-than-100-0-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        // string s;\\n        vector<int> v;\\n       for(auto x:address)\\n       {\\n           if(x==\\'.\\'){v.push_back(\\'[\\');}\\n           v.push_back(x);\\n           if(x==\\'.\\'){v.push_back(\\']\\');}\\n       }\\n        string s={v.begin() , v.end()};\\n        return s;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        // string s;\\n        vector<int> v;\\n       for(auto x:address)\\n       {\\n           if(x==\\'.\\'){v.push_back(\\'[\\');}\\n           v.push_back(x);\\n           if(x==\\'.\\'){v.push_back(\\']\\');}\\n       }\\n        string s={v.begin() , v.end()};\\n        return s;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 817488,
                "title": "swift-1-liner-readable-solution",
                "content": "Just use the standard swift library replacingOcurrences. No need do complex & unreadable stuff.\\n\\n```\\nfunc defangIPaddr(_ address: String) -> String {\\n\\treturn address.replacingOccurrences(of: \".\", with: \"[.]\")\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc defangIPaddr(_ address: String) -> String {\\n\\treturn address.replacingOccurrences(of: \".\", with: \"[.]\")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 760391,
                "title": "2-line-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) \\n    {\\n        regex re(\"\\\\\\\\.\"); \\n        return regex_replace(address, re, \"[.]\");                \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) \\n    {\\n        regex re(\"\\\\\\\\.\"); \\n        return regex_replace(address, re, \"[.]\");                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724309,
                "title": "one-line-java-code-so-easy-i-don-t-know-why-people-making-it-so-compicated",
                "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 666213,
                "title": "java-1-line-of-code-29-100",
                "content": "```\\npublic String defangIPaddr(String address) {\\n    return address.replaceAll(\"\\\\\\\\.\", \"[.]\");\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String defangIPaddr(String address) {\\n    return address.replaceAll(\"\\\\\\\\.\", \"[.]\");\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 629453,
                "title": "short-and-sweet-c-solution",
                "content": "\\tstring defangIPaddr(string address)\\n\\t{\\n\\t\\tstring result;\\n\\n\\t\\tfor (size_t i = 0; i < address.length(); i++)\\n\\t\\t{\\n\\t\\t\\tif (address[i] == \\'.\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.append(\"[.]\");\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.append(1, address[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\tstring defangIPaddr(string address)\\n\\t{\\n\\t\\tstring result;\\n\\n\\t\\tfor (size_t i = 0; i < address.length(); i++)\\n\\t\\t{\\n\\t\\t\\tif (address[i] == \\'.\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.append(\"[.]\");\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.append(1, address[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 562378,
                "title": "java-one-liner",
                "content": "```\\nreturn address.replaceAll(\"\\\\\\\\.\", \"[.]\")\\n```",
                "solutionTags": [],
                "code": "```\\nreturn address.replaceAll(\"\\\\\\\\.\", \"[.]\")\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560937,
                "title": "python-one-liner",
                "content": "this was easy with python\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\",\"[.]\")\\n",
                "solutionTags": [],
                "code": "this was easy with python\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\",\"[.]\")\\n",
                "codeTag": "Java"
            },
            {
                "id": 555145,
                "title": "c-100-time-and-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string a;\\n        int x = address.length();\\n        for(int i =0;i<x;i++){\\n            if(address[i] == \\'.\\'){\\n                a.push_back(\\'[\\');\\n                a.push_back(\\'.\\');\\n                a.push_back(\\']\\');\\n                \\n            }\\n            else{\\n                a.push_back(address[i]);\\n            }\\n        }\\n        return a;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string a;\\n        int x = address.length();\\n        for(int i =0;i<x;i++){\\n            if(address[i] == \\'.\\'){\\n                a.push_back(\\'[\\');\\n                a.push_back(\\'.\\');\\n                a.push_back(\\']\\');\\n                \\n            }\\n            else{\\n                a.push_back(address[i]);\\n            }\\n        }\\n        return a;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465595,
                "title": "100-00-faster-in-runtime-and-memory",
                "content": "Runtime: **0 ms**, faster than 1**00.00%** of C++ online submissions for Defanging an IP Address.\\nMemory Usage: **8.1** MB, less than **100.00%** of C++ online submissions for Defanging an IP Address.\\n\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string defangIP(\"\");\\n        for(char c: address)\\n            (c==\\'.\\')? defangIP+=\"[.]\":defangIP+=c;\\n        return defangIP;\\n    }\\n};\\n```\\n\\n-----\\nRuntime: **0 ms**, faster than **100.00%** of C++ online submissions for Defanging an IP Address.\\nMemory Usage: **8 MB**, less than **100.00%** of C++ online submissions for Defanging an IP Address.\\n```\\nclass Solution { // isdigit(char) stl\\npublic:\\n    string defangIPaddr(string address) {\\n        string defangIP(\"\");\\n        for(char c: address){\\n            if(isdigit(c)) defangIP+=c;\\n            else defangIP+=\"[.]\";\\n        }\\n        return defangIP;\\n    }\\n};\\n```\\n\\n----\\nRuntime: **4 ms**, faster than **54.08%** of C++ online submissions for Defanging an IP Address.\\nMemory Usage: **8 MB**, less than **100.00%** of C++ online submissions for Defanging an IP Address.\\n```\\nclass Solution { // using substr(pos,length) and substr(pos) stl\\npublic:\\n    string defangIPaddr(string address) {\\n        for(int i(address.length()-1);i>=0;i--){\\n            if(address[i]==\\'.\\')\\n                address = address.substr(0,i) + \"[.]\" + address.substr(i+1);\\n        }\\n        return address;\\n    }\\n};\\n```\\nWe start looking from the second to last position because we know the last character in address will never be \\'.\\'\\nWe look backward through the string because we don\\'t want to mess up our indices when we start inserting the brackets.\\n\\n----\\nRuntime: **4 ms**, faster than **54.08%** of C++ online submissions for Defanging an IP Address.\\nMemory Usage: 8.1 MB, less than **100.00%** of C++ online submissions for Defanging an IP Address.\\n```\\nclass Solution { // using replace(pos,length,withStr) stl\\npublic:\\n    string defangIPaddr(string address) {\\n        for(int i(address.length()-1);i>=0;i--){\\n            if(address[i]==\\'.\\')\\n                address = address.replace(i,1,\"[.]\");\\n        }\\n        return address;\\n    }\\n};\\n```\\n\\n----\\nRuntime: **12 ms**, faster than **54.08%** of C++ online submissions for Defanging an IP Address. **O(n^2)**\\nMemory Usage: **11.5 MB**, less than **100.00%** of C++ online submissions for Defanging an IP Address. \\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        return regex_replace(address,regex(\"[.]\"),\"[.]\");\\n    }\\n};\\n```\\n\\n---- \\nExtra\\n\\n----\\n\\n```\\nchar * defangIPaddr(char * address){\\n    char *re = malloc(24);\\n    char *out = re;\\n    while (*address) {\\n        if (*address == \\'.\\') {\\n            *out++ = \\'[\\';\\n            *out++ = \\'.\\';\\n            *out++ = \\']\\';\\n            *address++;\\n        } else {\\n            *out++ = *address++;\\n        }\\n    }\\n    *out = \\'\\\\0\\';\\n    return re;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string defangIP(\"\");\\n        for(char c: address)\\n            (c==\\'.\\')? defangIP+=\"[.]\":defangIP+=c;\\n        return defangIP;\\n    }\\n};\\n```\n```\\nclass Solution { // isdigit(char) stl\\npublic:\\n    string defangIPaddr(string address) {\\n        string defangIP(\"\");\\n        for(char c: address){\\n            if(isdigit(c)) defangIP+=c;\\n            else defangIP+=\"[.]\";\\n        }\\n        return defangIP;\\n    }\\n};\\n```\n```\\nclass Solution { // using substr(pos,length) and substr(pos) stl\\npublic:\\n    string defangIPaddr(string address) {\\n        for(int i(address.length()-1);i>=0;i--){\\n            if(address[i]==\\'.\\')\\n                address = address.substr(0,i) + \"[.]\" + address.substr(i+1);\\n        }\\n        return address;\\n    }\\n};\\n```\n```\\nclass Solution { // using replace(pos,length,withStr) stl\\npublic:\\n    string defangIPaddr(string address) {\\n        for(int i(address.length()-1);i>=0;i--){\\n            if(address[i]==\\'.\\')\\n                address = address.replace(i,1,\"[.]\");\\n        }\\n        return address;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        return regex_replace(address,regex(\"[.]\"),\"[.]\");\\n    }\\n};\\n```\n```\\nchar * defangIPaddr(char * address){\\n    char *re = malloc(24);\\n    char *out = re;\\n    while (*address) {\\n        if (*address == \\'.\\') {\\n            *out++ = \\'[\\';\\n            *out++ = \\'.\\';\\n            *out++ = \\']\\';\\n            *address++;\\n        } else {\\n            *out++ = *address++;\\n        }\\n    }\\n    *out = \\'\\\\0\\';\\n    return re;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461799,
                "title": "go",
                "content": "```golang\\nimport \"strings\"\\nfunc defangIPaddr(address string) string {\\n    return strings.Replace(address,\".\",\"[.]\",-1)\\n}\\n```",
                "solutionTags": [],
                "code": "```golang\\nimport \"strings\"\\nfunc defangIPaddr(address string) string {\\n    return strings.Replace(address,\".\",\"[.]\",-1)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 444826,
                "title": "javascript-one-liner-less-memory-than-100-of-other-solutions",
                "content": "```\\nvar defangIPaddr = function(address) {\\n    return address.split(\\'.\\').join(\\'[.]\\')\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar defangIPaddr = function(address) {\\n    return address.split(\\'.\\').join(\\'[.]\\')\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389729,
                "title": "ruby-code-20ms-faster-than-99-77",
                "content": "**Runtime:** 20 ms, faster than 99.77% of Ruby submissions.\\n**Memory Usage:** 9.2 MB, less than 100.00% of Ruby submissions.\\n\\n```ruby\\ndef defang_i_paddr(address)\\n  address.split(\\'.\\').join(\\'[.]\\')\\nend\\n```\\n\\n[Why `split` & `join` is faster than `gsub` (stackoverflow)](https://stackoverflow.com/a/29956753/9440171)\\n",
                "solutionTags": [],
                "code": "```ruby\\ndef defang_i_paddr(address)\\n  address.split(\\'.\\').join(\\'[.]\\')\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 385850,
                "title": "simplest-of-c-0ms",
                "content": "```\\nchar * defangIPaddr(char * addr){\\n\\n    char* ret = malloc(22);\\n    int f[4];\\n\\t\\n    sscanf(addr, \"%d.%d.%d.%d\", &f[0], &f[1], &f[2], &f[3]);\\n    sprintf(ret, \"%d[.]%d[.]%d[.]%d\", f[0], f[1], f[2], f[3]);\\n    \\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * defangIPaddr(char * addr){\\n\\n    char* ret = malloc(22);\\n    int f[4];\\n\\t\\n    sscanf(addr, \"%d.%d.%d.%d\", &f[0], &f[1], &f[2], &f[3]);\\n    sprintf(ret, \"%d[.]%d[.]%d[.]%d\", f[0], f[1], f[2], f[3]);\\n    \\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359714,
                "title": "python3-regex-solution",
                "content": "```import re\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        newadr = re.sub(\"\\\\.\",\"[.]\",address)\\n        return newadr\\n\\t\\n100% memory,99.8% speed,20ms",
                "solutionTags": [
                    "Python"
                ],
                "code": "```import re\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        newadr = re.sub(\"\\\\.\",\"[.]\",address)\\n        return newadr\\n\\t\\n100% memory,99.8% speed,20ms",
                "codeTag": "Java"
            },
            {
                "id": 342412,
                "title": "javascript",
                "content": "```\\nvar defangIPaddr = function(address) {\\n  let str = \\'\\'\\n  \\n  for (let i in address){\\n      address[i] !== \\'.\\' ? str += address[i] : str += \\'[.]\\'\\n  }\\n  return str\\n  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar defangIPaddr = function(address) {\\n  let str = \\'\\'\\n  \\n  for (let i in address){\\n      address[i] !== \\'.\\' ? str += address[i] : str += \\'[.]\\'\\n  }\\n  return str\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330471,
                "title": "javascript-one-liner",
                "content": "```\\n/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n    return address.replace(/[.]/g, \\'[.]\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n    return address.replace(/[.]/g, \\'[.]\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329803,
                "title": "100-very-very-easy-to-understand-python-code",
                "content": "class Solution(object):\\n    def defangIPaddr(self, address):\\n        \"\"\"\\n        :type address: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        a = list(address)\\n        for i in range(len(a)):\\n            if a[i] == \\'.\\':\\n                a[i] = \\'[.]\\'\\n                \\n        S = \"\".join(a)\\n        \\n        \\n            \\n        return S",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def defangIPaddr(self, address):\\n        \"\"\"\\n        :type address: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        a = list(address)\\n        for i in range(len(a)):\\n            if a[i] == \\'.\\':\\n                a[i] = \\'[.]\\'\\n                \\n        S = \"\".join(a)\\n        \\n        \\n            \\n        return S",
                "codeTag": "Java"
            },
            {
                "id": 4008980,
                "title": "easy-efficient-code-for-beginners-using-stringbuilder",
                "content": "# Intuition\\nFirst thought was to create a new variable and store the values while simultaneousely checking for the dots(\\'.\\'). Using a regular string will waste a lot of memory hence used StringBuilder\\n\\n# Approach\\nVery Simple and beats 100%\\nkeep adding characters of string address into a StringBuilder variable build until you find a dot. if character is dot then add [.] into build.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder build=new StringBuilder();\\n        for(int i=0;i<address.length();i++)\\n        {\\n            if(address.charAt(i)==\\'.\\')\\n            {\\n                build.append(\"[.]\");\\n                continue;\\n            }\\n            build.append(address.charAt(i));\\n        }\\n        return build.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder build=new StringBuilder();\\n        for(int i=0;i<address.length();i++)\\n        {\\n            if(address.charAt(i)==\\'.\\')\\n            {\\n                build.append(\"[.]\");\\n                continue;\\n            }\\n            build.append(address.charAt(i));\\n        }\\n        return build.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979906,
                "title": "waste-of-time-but-still",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n*String has replace method which takes two parameters String.replace(\"old one\",\"new one\");\\n1st one is what to replace \\n2nd one for what to replace instead.*\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908104,
                "title": "100-easy-and-optimised-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb=new StringBuilder();\\n       for(int i=0;i<address.length();i++){\\n           if(address.charAt(i)==\\'.\\'){\\n               sb.append(\"[\");\\n               sb.append(\".\");\\n               sb.append(\"]\");\\n           }\\n           else{\\n               sb.append(address.charAt(i));\\n           }\\n       }\\n       String str=sb.toString(); \\n       return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb=new StringBuilder();\\n       for(int i=0;i<address.length();i++){\\n           if(address.charAt(i)==\\'.\\'){\\n               sb.append(\"[\");\\n               sb.append(\".\");\\n               sb.append(\"]\");\\n           }\\n           else{\\n               sb.append(address.charAt(i));\\n           }\\n       }\\n       String str=sb.toString(); \\n       return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890213,
                "title": "c-easy-one-line-solution-with-explanation",
                "content": "\\n# Approach\\n\\nI used ```string.Split(\".\")``` method to get input string seperated by dots. So, that method returns an array of strings. Then I used ```string.Join(\"[.]\")``` to convert that array into one string while adding \"[.]\" between and returned via lambda expression. \\n\\n# Code\\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) => string.Join(\"[.]\", address.Split(\".\"));\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```string.Split(\".\")```\n```string.Join(\"[.]\")```\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) => string.Join(\"[.]\", address.Split(\".\"));\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864195,
                "title": "beats-100-java-one-line-solution-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687192,
                "title": "easy-solution-c",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInside the defangIPaddr function, we iterate through each character c in the input address. If c is a period (\\'.\\'), we append \"[.]\" to the defangedAddress string. Otherwise, we simply append c to defangedAddress.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address)\\n   {\\n       string defang;\\n       \\n       for(char c:address)\\n       {\\n           if(c==\\'.\\')\\n           {\\n               defang.push_back(\\'[\\');\\n               defang.push_back(\\'.\\');\\n               defang.push_back(\\']\\');\\n           }\\n           else\\n           {\\n               defang.push_back(c);\\n           }\\n       }\\n       return defang;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address)\\n   {\\n       string defang;\\n       \\n       for(char c:address)\\n       {\\n           if(c==\\'.\\')\\n           {\\n               defang.push_back(\\'[\\');\\n               defang.push_back(\\'.\\');\\n               defang.push_back(\\']\\');\\n           }\\n           else\\n           {\\n               defang.push_back(c);\\n           }\\n       }\\n       return defang;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566642,
                "title": "beginners-friendly",
                "content": "\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder t= new StringBuilder(address);\\n        StringBuilder s= new StringBuilder();\\n        for(int i=0;i<address.length();i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s.append(\"[.]\");\\n            }else s.append(address.charAt(i));\\n\\n        }\\n        return s.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder t= new StringBuilder(address);\\n        StringBuilder s= new StringBuilder();\\n        for(int i=0;i<address.length();i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s.append(\"[.]\");\\n            }else s.append(address.charAt(i));\\n\\n        }\\n        return s.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541617,
                "title": "defanging-an-ip-address-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        int i=0;\\n        string defanged_ip_address;\\n        for(i=0 ; i<address.length() ; i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                defanged_ip_address += \"[.]\";\\n            }\\n            else\\n            {\\n                defanged_ip_address += address[i];\\n            }\\n        }\\n        return defanged_ip_address;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/1db8f363-7ff2-4424-8ed0-adefc3973c07_1684498679.514323.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        int i=0;\\n        string defanged_ip_address;\\n        for(i=0 ; i<address.length() ; i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                defanged_ip_address += \"[.]\";\\n            }\\n            else\\n            {\\n                defanged_ip_address += address[i];\\n            }\\n        }\\n        return defanged_ip_address;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493485,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar defangIPaddr = function(address) {\\n \\n return address.replaceAll(\\'.\\', \\'[.]\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar defangIPaddr = function(address) {\\n \\n return address.replaceAll(\\'.\\', \\'[.]\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3399758,
                "title": "simple-go-solution-using-buffer",
                "content": "\\n# Code\\n```\\nfunc defangIPaddr(address string) string {\\n\\tvar b bytes.Buffer\\n\\tfor _, c := range address {\\n\\t\\tif c == \\'.\\' {\\n\\t\\t\\tb.WriteString(\"[.]\")\\n\\t\\t} else {\\n\\t\\t\\tb.WriteRune(c)\\n\\t\\t}\\n\\t}\\n\\treturn b.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc defangIPaddr(address string) string {\\n\\tvar b bytes.Buffer\\n\\tfor _, c := range address {\\n\\t\\tif c == \\'.\\' {\\n\\t\\t\\tb.WriteString(\"[.]\")\\n\\t\\t} else {\\n\\t\\t\\tb.WriteRune(c)\\n\\t\\t}\\n\\t}\\n\\treturn b.String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3358474,
                "title": "c-easy-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string a;\\n\\n        \\n        for(int i =0;i<address.size();i++){\\n            if(address[i]==\\'.\\'){\\n                a.push_back(\\'[\\');\\n                a.push_back(\\'.\\');\\n                a.push_back(\\']\\');\\n            }\\n            else{\\n                a.push_back(address[i]);\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string a;\\n\\n        \\n        for(int i =0;i<address.size();i++){\\n            if(address[i]==\\'.\\'){\\n                a.push_back(\\'[\\');\\n                a.push_back(\\'.\\');\\n                a.push_back(\\']\\');\\n            }\\n            else{\\n                a.push_back(address[i]);\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284617,
                "title": "1-line-solution-beats-100-runtime-0ms-o-n",
                "content": "\\n\\n# Complexity            \\n\\n\\n- Time complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275843,
                "title": "java-super-easy-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274516,
                "title": "one-line-code-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271905,
                "title": "defanging-an-ip-address-c-easy-approach-fast-simple",
                "content": "**PLEASEUPVOTE, IF YOU LIKE\\u2764\\uFE0F\\u2764\\uFE0F**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) \\n    {\\n        string ans;\\n        for(int i=0;i<address.length();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                ans=ans+\"[.]\";\\n            }\\n            else\\n                ans=ans+address[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) \\n    {\\n        string ans;\\n        for(int i=0;i<address.length();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                ans=ans+\"[.]\";\\n            }\\n            else\\n                ans=ans+address[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235317,
                "title": "beat-100-easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans;\\n        for(int i=0;i<address.size();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                ans.push_back(\\'[\\');\\n               ans.push_back(\\'.\\');\\n               ans.push_back(\\']\\');\\n\\n            }\\n             else\\n        {\\n            ans.push_back(address[i]);\\n        }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans;\\n        for(int i=0;i<address.size();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                ans.push_back(\\'[\\');\\n               ans.push_back(\\'.\\');\\n               ans.push_back(\\']\\');\\n\\n            }\\n             else\\n        {\\n            ans.push_back(address[i]);\\n        }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224266,
                "title": "simple-python-code-with-if-else-statement",
                "content": "# Approach\\nsimple approch\\n\\n# Code\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        s = \\'\\'\\n        for i in address:\\n            if i == \\'.\\': s+=\\'[.]\\'\\n            else: s+=i\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        s = \\'\\'\\n        for i in address:\\n            if i == \\'.\\': s+=\\'[.]\\'\\n            else: s+=i\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195145,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n\\n    string ans;\\n    for (int i = 0; i < address.size(); i++)\\n    {\\n        if (address[i] == \\'.\\')\\n        {\\n            ans.push_back(\\'[\\');\\n            ans.push_back(\\'.\\');\\n            ans.push_back(\\']\\');\\n        }\\n        else\\n        {\\n            ans.push_back(address[i]);\\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n\\n    string ans;\\n    for (int i = 0; i < address.size(); i++)\\n    {\\n        if (address[i] == \\'.\\')\\n        {\\n            ans.push_back(\\'[\\');\\n            ans.push_back(\\'.\\');\\n            ans.push_back(\\']\\');\\n        }\\n        else\\n        {\\n            ans.push_back(address[i]);\\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176670,
                "title": "simple-c-code-easy-beats-100",
                "content": "Runtime : Beats 100%\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string res=\"\";\\n        for(auto i: address){\\n            if(i==\\'.\\'){\\n                res=res+\"[.]\";\\n            }else{\\n                res=res+i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nHope you liked the implementation of the code, if you like it feel free to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string res=\"\";\\n        for(auto i: address){\\n            if(i==\\'.\\'){\\n                res=res+\"[.]\";\\n            }else{\\n                res=res+i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168477,
                "title": "one-line-in-python",
                "content": "```\\nclass Solution:\\n    def defangIPaddr(self, a: str) -> str:\\n        a = a.replace(\\'.\\',\"[.]\")\\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, a: str) -> str:\\n        a = a.replace(\\'.\\',\"[.]\")\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125746,
                "title": "c-easy-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLoop through the address checking for . and if it finds it, it will replace it with [.]\\nthen return that string\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans=\"\";\\n        for(int i=0;i<address.size();i++){\\n            if(address[i]==\\'.\\'){\\n                ans=ans+\"[.]\";\\n            }\\n            else{\\n                ans=ans+address[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans=\"\";\\n        for(int i=0;i<address.size();i++){\\n            if(address[i]==\\'.\\'){\\n                ans=ans+\"[.]\";\\n            }\\n            else{\\n                ans=ans+address[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083538,
                "title": "easiest-solution-c-with-0ms-beats-100-of-solutions",
                "content": "\\n# Approach\\nLoop through the address checking for `.` and if it finds it, it will replace it with `[.]`\\nthen return that string\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string temp {};\\n        for(int i {};i<address.size();i++){ if(address[i]==\\'.\\') temp+=\"[.]\";else temp+=address[i];}\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string temp {};\\n        for(int i {};i<address.size();i++){ if(address[i]==\\'.\\') temp+=\"[.]\";else temp+=address[i];}\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901064,
                "title": "simple-kotlin-solution-without-replace-function",
                "content": "# Useful links for StringBuilder() \\nhttps://medium.com/@ramazanbullet/what-is-stringbuilder-in-kotlin-729adc76dc31\\n# Code\\n```\\nclass Solution {\\n    fun defangIPaddr(address: String): String {\\n       // Defang the given address\\n    val defanged = StringBuilder()\\n    for (ch in address) {\\n        if (ch == \\'.\\') {\\n            defanged.append(\"[.]\")\\n        } else {\\n            defanged.append(ch)\\n        }\\n    }\\n    return defanged.toString()\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun defangIPaddr(address: String): String {\\n       // Defang the given address\\n    val defanged = StringBuilder()\\n    for (ch in address) {\\n        if (ch == \\'.\\') {\\n            defanged.append(\"[.]\")\\n        } else {\\n            defanged.append(ch)\\n        }\\n    }\\n    return defanged.toString()\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860236,
                "title": "simple-c-solution-easy-to-understand",
                "content": "**Intuition:**\\n\\n---\\nSimple replace \".\" with \"[.]\";\\nand return string as answer.\\n\\n---\\n**Solution:**\\n\\n---\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans =\"\";\\n\\n        for(char x:address)\\n        {\\n            if(x ==\\'.\\')\\n               ans = ans + \"[.]\";\\n            else\\n               ans = ans + x; \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n**Analysis:**\\n\\n**Time Complexity:** ```O(n)```  Where n is the length of the string.\\n**Space Complexity:** ```O(n)```\\n\\n---\\nIf this solution Helps you then please ```UPVOTE```.\\nTill then **Keep Learning, Keep Growing !!!!**\\n\\nThank You!!!\\n\\n---",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans =\"\";\\n\\n        for(char x:address)\\n        {\\n            if(x ==\\'.\\')\\n               ans = ans + \"[.]\";\\n            else\\n               ans = ans + x; \\n        }\\n        return ans;\\n    }\\n};\\n```\n```O(n)```\n```O(n)```\n```UPVOTE```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1756452,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1564950,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1568261,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1572880,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1569852,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1573980,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1575150,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1570285,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1573552,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1569554,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1756452,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1564950,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1568261,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1572880,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1569852,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1573980,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1575150,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1570285,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1573552,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1569554,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1573313,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1573225,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1572913,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1572827,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1569553,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1575282,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1573145,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1572983,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 2058583,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1918893,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1913637,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1902989,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1854943,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1848684,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1800375,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1795323,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1793978,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1781594,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1759034,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1758032,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            }
        ]
    },
    {
        "title": "Strange Printer II",
        "question_content": "<p>There is a strange printer with the following two special requirements:</p>\n\n<ul>\n\t<li>On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.</li>\n\t<li>Once the printer has used a color for the above operation, <strong>the same color cannot be used again</strong>.</li>\n</ul>\n\n<p>You are given a <code>m x n</code> matrix <code>targetGrid</code>, where <code>targetGrid[row][col]</code> is the color in the position <code>(row, col)</code> of the grid.</p>\n\n<p>Return <code>true</code><em> if it is possible to print the matrix </em><code>targetGrid</code><em>,</em><em> otherwise, return </em><code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/23/print1.jpg\" style=\"width: 600px; height: 175px;\" />\n<pre>\n<strong>Input:</strong> targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/23/print2.jpg\" style=\"width: 600px; height: 367px;\" />\n<pre>\n<strong>Input:</strong> targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> targetGrid = [[1,2,1],[2,1,2],[1,2,1]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> It is impossible to form targetGrid because it is not allowed to print the same color in different turns.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == targetGrid.length</code></li>\n\t<li><code>n == targetGrid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 60</code></li>\n\t<li><code>1 &lt;= targetGrid[row][col] &lt;= 60</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 854193,
                "title": "java-python-straight-forward",
                "content": "# **Explanation**\\nFor each color, find its edge most index.\\nThen we need to paint this color from [top, left] to [bottom, right].\\n\\nIf in the rectangle, all the colors are either the same or 0,\\nwe mark all of them to 0.\\n\\nIf we can mark the whole grid to 0, it means the target if printable.\\n<br>\\n\\n# **Complexity**\\nTime `O(CCMN)`\\nSpace `O(4N)`\\n<br>\\n\\n**Java:**\\nall by @blackspinner\\n```java\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        Map<Integer, int[]> pos = new HashMap<>();\\n        int n = targetGrid.length;\\n        int m = targetGrid[0].length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pos.putIfAbsent(targetGrid[i][j], new int[]{n, m, -1, -1});\\n                int[] coord = pos.get(targetGrid[i][j]);\\n                coord[0] = Math.min(coord[0], i);\\n                coord[1] = Math.min(coord[1], j);\\n                coord[2] = Math.max(coord[2], i);\\n                coord[3] = Math.max(coord[3], j);\\n            }\\n        }\\n        Set<Integer> colors = new HashSet<>(pos.keySet());\\n        while (!colors.isEmpty()) {\\n            Set<Integer> next = new HashSet<>();\\n            for (int color : colors) {\\n                if (!erase(targetGrid, pos.get(color), color)) {\\n                    next.add(color);\\n                }\\n            }\\n            if (colors.size() == next.size()) {\\n                return false;\\n            }\\n            colors = next;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean erase(int[][] targetGrid, int[] coord, int color) {\\n        for (int i = coord[0]; i <= coord[2]; i++) {\\n            for (int j = coord[1]; j <= coord[3]; j++) {\\n                if (targetGrid[i][j] > 0 && targetGrid[i][j] != color) {\\n                    return false;\\n                }\\n            }\\n        }\\n        for (int i = coord[0]; i <= coord[2]; i++) {\\n            for (int j = coord[1]; j <= coord[3]; j++) {\\n                targetGrid[i][j] = 0;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**Python:**\\n```py\\n    def isPrintable(self, A):\\n        m, n = len(A), len(A[0])\\n        pos = [[m, n, 0, 0] for i in xrange(61)]\\n        colors = set()\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                c = A[i][j]\\n                colors.add(c)\\n                pos[c][0] = min(pos[c][0], i)\\n                pos[c][1] = min(pos[c][1], j)\\n                pos[c][2] = max(pos[c][2], i)\\n                pos[c][3] = max(pos[c][3], j)\\n\\n        def test(c):\\n            for i in xrange(pos[c][0], pos[c][2] + 1):\\n                for j in xrange(pos[c][1], pos[c][3] + 1):\\n                    if A[i][j] > 0 and A[i][j] != c:\\n                        return False\\n            for i in xrange(pos[c][0], pos[c][2] + 1):\\n                for j in xrange(pos[c][1], pos[c][3] + 1):\\n                    A[i][j] = 0\\n            return True\\n\\n        while colors:\\n            colors2 = set()\\n            for c in colors:\\n                if not test(c):\\n                    colors2.add(c)\\n            if len(colors2) == len(colors):\\n                return False\\n            colors = colors2\\n        return True\\n```\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        Map<Integer, int[]> pos = new HashMap<>();\\n        int n = targetGrid.length;\\n        int m = targetGrid[0].length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pos.putIfAbsent(targetGrid[i][j], new int[]{n, m, -1, -1});\\n                int[] coord = pos.get(targetGrid[i][j]);\\n                coord[0] = Math.min(coord[0], i);\\n                coord[1] = Math.min(coord[1], j);\\n                coord[2] = Math.max(coord[2], i);\\n                coord[3] = Math.max(coord[3], j);\\n            }\\n        }\\n        Set<Integer> colors = new HashSet<>(pos.keySet());\\n        while (!colors.isEmpty()) {\\n            Set<Integer> next = new HashSet<>();\\n            for (int color : colors) {\\n                if (!erase(targetGrid, pos.get(color), color)) {\\n                    next.add(color);\\n                }\\n            }\\n            if (colors.size() == next.size()) {\\n                return false;\\n            }\\n            colors = next;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean erase(int[][] targetGrid, int[] coord, int color) {\\n        for (int i = coord[0]; i <= coord[2]; i++) {\\n            for (int j = coord[1]; j <= coord[3]; j++) {\\n                if (targetGrid[i][j] > 0 && targetGrid[i][j] != color) {\\n                    return false;\\n                }\\n            }\\n        }\\n        for (int i = coord[0]; i <= coord[2]; i++) {\\n            for (int j = coord[1]; j <= coord[3]; j++) {\\n                targetGrid[i][j] = 0;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```py\\n    def isPrintable(self, A):\\n        m, n = len(A), len(A[0])\\n        pos = [[m, n, 0, 0] for i in xrange(61)]\\n        colors = set()\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                c = A[i][j]\\n                colors.add(c)\\n                pos[c][0] = min(pos[c][0], i)\\n                pos[c][1] = min(pos[c][1], j)\\n                pos[c][2] = max(pos[c][2], i)\\n                pos[c][3] = max(pos[c][3], j)\\n\\n        def test(c):\\n            for i in xrange(pos[c][0], pos[c][2] + 1):\\n                for j in xrange(pos[c][1], pos[c][3] + 1):\\n                    if A[i][j] > 0 and A[i][j] != c:\\n                        return False\\n            for i in xrange(pos[c][0], pos[c][2] + 1):\\n                for j in xrange(pos[c][1], pos[c][3] + 1):\\n                    A[i][j] = 0\\n            return True\\n\\n        while colors:\\n            colors2 = set()\\n            for c in colors:\\n                if not test(c):\\n                    colors2.add(c)\\n            if len(colors2) == len(colors):\\n                return False\\n            colors = colors2\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854151,
                "title": "c-o-n-3-solution-checking-cycle-in-dependency-graph",
                "content": "**Idea**: Instead of thinking how to gradually print colors, we can think of the problem reversely and see this as a process of **removing colors** from the target grid to get a blank grid. In this process, a color rectangle can only be removed if and only if all the color rectangles \\u201Ccovering\\u201D it are removed first. We can model this dependency relationship between colors as a directed graph. The target can be achieved if and only if the graph doesn\\u2019t have any cycles, which can be easily checked by using a standard DFS. \\n\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        const int m = targetGrid.size(), n = targetGrid[0].size();\\n        // Dependency graph: dep[i] = j means color j covers color i;\\n        vector<unordered_set<int>> dep(61);\\n        for (int i = 1; i <= 60; ++i) {\\n            // Determine the rectangle of the current color i.\\n            int minx = m, miny = n, maxx = -1, maxy = -1;\\n            for (int x = 0; x < m; ++x) {\\n                for (int y = 0; y < n; ++y) {\\n                    if (targetGrid[x][y] == i) {\\n                        minx = min(x, minx);\\n                        miny = min(y, miny);\\n                        maxx = max(x, maxx);\\n                        maxy = max(y, maxy);\\n                    }\\n                }\\n            }\\n            // Add any color covering the current color as dependence.\\n            for (int tx = minx; tx <= maxx; ++tx) {\\n                for (int ty = miny; ty <= maxy; ++ty) {\\n                   if (targetGrid[tx][ty] != i) dep[i].insert(targetGrid[tx][ty]);\\n                }\\n            }\\n        }\\n        // Standard DFS to check the existence of a cycle.\\n        vector<int> vis(61, 0);\\n        for (int i = 1; i <= 60; ++i) {\\n            if (!vis[i] && hasCircle(i, dep, vis)) return false;\\n        }\\n        return true;\\n    }\\n    \\nprivate:\\n    bool hasCircle(int curr, const vector<unordered_set<int>>& dep, vector<int>& vis) {\\n        vis[curr] = 1;\\n        for (const int d : dep[curr]) {\\n            if (vis[d] == 2) continue;\\n            if (vis[d] == 1) return true;\\n            if (hasCircle(d, dep, vis)) return true;\\n        }\\n        vis[curr] = 2;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        const int m = targetGrid.size(), n = targetGrid[0].size();\\n        // Dependency graph: dep[i] = j means color j covers color i;\\n        vector<unordered_set<int>> dep(61);\\n        for (int i = 1; i <= 60; ++i) {\\n            // Determine the rectangle of the current color i.\\n            int minx = m, miny = n, maxx = -1, maxy = -1;\\n            for (int x = 0; x < m; ++x) {\\n                for (int y = 0; y < n; ++y) {\\n                    if (targetGrid[x][y] == i) {\\n                        minx = min(x, minx);\\n                        miny = min(y, miny);\\n                        maxx = max(x, maxx);\\n                        maxy = max(y, maxy);\\n                    }\\n                }\\n            }\\n            // Add any color covering the current color as dependence.\\n            for (int tx = minx; tx <= maxx; ++tx) {\\n                for (int ty = miny; ty <= maxy; ++ty) {\\n                   if (targetGrid[tx][ty] != i) dep[i].insert(targetGrid[tx][ty]);\\n                }\\n            }\\n        }\\n        // Standard DFS to check the existence of a cycle.\\n        vector<int> vis(61, 0);\\n        for (int i = 1; i <= 60; ++i) {\\n            if (!vis[i] && hasCircle(i, dep, vis)) return false;\\n        }\\n        return true;\\n    }\\n    \\nprivate:\\n    bool hasCircle(int curr, const vector<unordered_set<int>>& dep, vector<int>& vis) {\\n        vis[curr] = 1;\\n        for (const int d : dep[curr]) {\\n            if (vis[d] == 2) continue;\\n            if (vis[d] == 1) return true;\\n            if (hasCircle(d, dep, vis)) return true;\\n        }\\n        vis[curr] = 2;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854219,
                "title": "java-topological-sort",
                "content": "Well, this is a straight forward solution:\\n\\n1. if `color a` contains `color b`, then we must fill `color a` then `color b`. This is pretty similar to `to finish course b, you need to finish course a first.`\\n2. So we can build a graph: `color a` pointed by all other colors contained in `color a`\\'s rectangle.\\n3. topological sort(or dfs) to check whether we can reach all node. (Please refer to the idea behind [207. Course Schedule](https://leetcode.com/problems/course-schedule/))\\n\\n\\n\\n```\\nclass Solution {\\n    // same color should form a rectangle\\n    // topological sort\\n    // if a rectangle contains another one, then there is an edge between these two color\\n    \\n    public boolean isPrintable(int[][] targetGrid) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        int[] inDegree = new int[61];\\n        for(int i = 0; i <= 60; i++) graph.add(new ArrayList<>());\\n        for(int i = 1; i <= 60; i++) search(targetGrid, i, graph, inDegree);\\n        \\n        Deque<Integer> zeros = new ArrayDeque<>();\\n        HashSet<Integer> seen = new HashSet<>();\\n        for(int i = 0; i < inDegree.length; i++) if(inDegree[i] == 0) zeros.add(i);\\n        \\n        while(!zeros.isEmpty()) {\\n            int cur = zeros.poll();\\n            if(!seen.add(cur)) continue;\\n            \\n            for(Integer nbh : graph.get(cur)) {\\n                inDegree[nbh]--;\\n                if(inDegree[nbh] == 0) zeros.add(nbh);\\n            }\\n        }\\n        return seen.size() == 61;\\n    }\\n    \\n    private void search(int[][] grid, int color, List<List<Integer>> graph, int[] inDegree) {\\n        // get range\\n        int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE, maxX = Integer.MIN_VALUE, maxY = Integer.MIN_VALUE;\\n        for(int i = 0; i < grid.length; i++) for(int j = 0; j < grid[0].length; j++) {\\n            if(grid[i][j] == color) {\\n                minX = Math.min(minX, i);\\n                maxX = Math.max(maxX, i);\\n                minY = Math.min(minY, j);\\n                maxY = Math.max(maxY, j);\\n            }\\n        }\\n        \\n        if(minX == Integer.MAX_VALUE) return ;\\n        \\n        // check relations\\n        for(int i = minX; i <= maxX; i++) for(int j = minY; j <= maxY; j++) {\\n            if(grid[i][j] != color) {\\n                graph.get(grid[i][j]).add(color); // to paint current color, we need to paint color in grid[i][j] first\\n                inDegree[color]++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // same color should form a rectangle\\n    // topological sort\\n    // if a rectangle contains another one, then there is an edge between these two color\\n    \\n    public boolean isPrintable(int[][] targetGrid) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        int[] inDegree = new int[61];\\n        for(int i = 0; i <= 60; i++) graph.add(new ArrayList<>());\\n        for(int i = 1; i <= 60; i++) search(targetGrid, i, graph, inDegree);\\n        \\n        Deque<Integer> zeros = new ArrayDeque<>();\\n        HashSet<Integer> seen = new HashSet<>();\\n        for(int i = 0; i < inDegree.length; i++) if(inDegree[i] == 0) zeros.add(i);\\n        \\n        while(!zeros.isEmpty()) {\\n            int cur = zeros.poll();\\n            if(!seen.add(cur)) continue;\\n            \\n            for(Integer nbh : graph.get(cur)) {\\n                inDegree[nbh]--;\\n                if(inDegree[nbh] == 0) zeros.add(nbh);\\n            }\\n        }\\n        return seen.size() == 61;\\n    }\\n    \\n    private void search(int[][] grid, int color, List<List<Integer>> graph, int[] inDegree) {\\n        // get range\\n        int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE, maxX = Integer.MIN_VALUE, maxY = Integer.MIN_VALUE;\\n        for(int i = 0; i < grid.length; i++) for(int j = 0; j < grid[0].length; j++) {\\n            if(grid[i][j] == color) {\\n                minX = Math.min(minX, i);\\n                maxX = Math.max(maxX, i);\\n                minY = Math.min(minY, j);\\n                maxY = Math.max(maxY, j);\\n            }\\n        }\\n        \\n        if(minX == Integer.MAX_VALUE) return ;\\n        \\n        // check relations\\n        for(int i = minX; i <= maxX; i++) for(int j = minY; j <= maxY; j++) {\\n            if(grid[i][j] != color) {\\n                graph.get(grid[i][j]).add(color); // to paint current color, we need to paint color in grid[i][j] first\\n                inDegree[color]++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854394,
                "title": "c-dfs-on-overlaps",
                "content": "Just 3 simple steps:\\n- For each color, detect the printing rectangle using the min and max coordinates where that color appears.\\n- Within each color\\'s rectangle, collect collors that `overlap`.\\n- Finally, check that colors do not mutually overlap by using DFS.\\n\\t- We can use white/gray/black coloring for visited (`vis`) colors.\\n\\n**C++**\\n```cpp\\nbool dfs(int col, unordered_set<int> overlaps[], vector<int> &vis) {\\n    if (vis[col] != 0)\\n        return vis[col] == 2;\\n    vis[col] = 1;\\n    for (auto col1 : overlaps[col])\\n        if (!dfs(col1, overlaps, vis))\\n            return false;\\n    vis[col] = 2;\\n    return true;\\n}\\nbool isPrintable(vector<vector<int>>& grid) {\\n    vector<array<int, 4>> rects(61, {INT_MAX, INT_MAX, INT_MIN, INT_MIN});\\n    unordered_set<int> overlaps[61];\\n    for (int i = 0; i < grid.size(); ++i)\\n        for (int j = 0; j < grid[0].size(); ++j) {\\n            int col = grid[i][j];\\n            rects[col][0] = min(rects[col][0], i);\\n            rects[col][1] = min(rects[col][1], j);\\n            rects[col][2] = max(rects[col][2], i);\\n            rects[col][3] = max(rects[col][3], j);\\n        }\\n    for (auto col = 0; col <= 60; ++col)\\n        for (int i = rects[col][0]; i <= rects[col][2]; ++i)\\n            for (int j = rects[col][1]; j <= rects[col][3]; ++j)\\n                if (grid[i][j] != col)\\n                    overlaps[col].insert(grid[i][j]);\\n    for (auto col = 0; col <= 60; ++col)\\n        if (!dfs(col, overlaps, vector<int>(61) = {}))\\n            return false;\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool dfs(int col, unordered_set<int> overlaps[], vector<int> &vis) {\\n    if (vis[col] != 0)\\n        return vis[col] == 2;\\n    vis[col] = 1;\\n    for (auto col1 : overlaps[col])\\n        if (!dfs(col1, overlaps, vis))\\n            return false;\\n    vis[col] = 2;\\n    return true;\\n}\\nbool isPrintable(vector<vector<int>>& grid) {\\n    vector<array<int, 4>> rects(61, {INT_MAX, INT_MAX, INT_MIN, INT_MIN});\\n    unordered_set<int> overlaps[61];\\n    for (int i = 0; i < grid.size(); ++i)\\n        for (int j = 0; j < grid[0].size(); ++j) {\\n            int col = grid[i][j];\\n            rects[col][0] = min(rects[col][0], i);\\n            rects[col][1] = min(rects[col][1], j);\\n            rects[col][2] = max(rects[col][2], i);\\n            rects[col][3] = max(rects[col][3], j);\\n        }\\n    for (auto col = 0; col <= 60; ++col)\\n        for (int i = rects[col][0]; i <= rects[col][2]; ++i)\\n            for (int j = rects[col][1]; j <= rects[col][3]; ++j)\\n                if (grid[i][j] != col)\\n                    overlaps[col].insert(grid[i][j]);\\n    for (auto col = 0; col <= 60; ++col)\\n        if (!dfs(col, overlaps, vector<int>(61) = {}))\\n            return false;\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 859203,
                "title": "c-topological-sort",
                "content": "The approach to the solution can be started by removing the color instead of fill the solid rectangle with color.\\n* Maintain the starting and ending coordinates of the color .\\n* Than see when can we remove the color from rectangle i.e. this is possible only when the rectangle is filled with same color or all the color present in the rectangle is removed before removing that color.\\n* The 2 step is just smiliar to the topological ordering of the colors i.e. particular color can be removed if all the colors on which it depends is already being removed which is similar to the question [207. Course Schedule](http://https://leetcode.com/problems/course-schedule/)\\nHere is my code for the approach \\n\\nAny suggestion will be appreciated.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        unordered_set<int>st; // for keeping distant color\\n        map<int,vector<int>>row,col; // for keeping starting and ending row and column of color\\n        int n=grid.size(),m=grid[0].size();\\n\\t\\t\\n        // finding Distant color\\n\\t\\tfor(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n                st.insert(grid[i][j]);\\n        }\\n\\t\\t// finding coordinates of color\\n        for(auto it:st)\\n        {\\n            int mn1=max(n,m),mn2=max(m,n),mx1=0,mx2=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(grid[i][j]==it)\\n                    {\\n                        mn1=min(i,mn1);\\n                        mx1=max(i,mx1);\\n                        mn2=min(j,mn2);\\n                        mx2=max(j,mx2);\\n                    }\\n                }\\n            }\\n            row[it].push_back(mn1);\\n            row[it].push_back(mx1);\\n            col[it].push_back(mn2);\\n            col[it].push_back(mx2);\\n        }\\n\\t\\t\\n\\t\\t// for keeping dependency\\n        vector<vector<int>>graph(61,vector<int>());\\n        int indeg[61];\\n        memset(indeg,0,sizeof indeg);\\n        for(auto it:st)\\n        {\\n            int mnr=row[it][0],mxr=row[it][1],mnc=col[it][0],mxc=col[it][1];\\n            set<int>st2;\\n            for(int i=mnr;i<=mxr;i++)\\n            {\\n                for(int j=mnc;j<=mxc;j++)\\n                {\\n                    if(it!=grid[i][j])\\n                        st2.insert(grid[i][j]);\\n                }\\n            }\\n            indeg[it]+=st2.size();\\n            for(auto pt:st2)\\n                graph[pt].push_back(it);\\n        }\\n\\t\\t\\n\\t\\t// Standard Topological Sort \\n        int cnt=0;\\n        queue<int>q;\\n        for(int i=1;i<=61;i++)\\n        {\\n            if(st.find(i)!=st.end() and indeg[i]==0)\\n                q.push(i);\\n        }\\n        while(!q.empty())\\n        {\\n            int x=q.front();\\n            q.pop();\\n            cnt++;\\n            for(auto it:graph[x])\\n            {\\n                indeg[it]--;\\n                if(indeg[it]==0)\\n                    q.push(it);\\n            }\\n        }\\n        if(cnt==st.size())\\n            return true;\\n        return false;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        unordered_set<int>st; // for keeping distant color\\n        map<int,vector<int>>row,col; // for keeping starting and ending row and column of color\\n        int n=grid.size(),m=grid[0].size();\\n\\t\\t\\n        // finding Distant color\\n\\t\\tfor(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n                st.insert(grid[i][j]);\\n        }\\n\\t\\t// finding coordinates of color\\n        for(auto it:st)\\n        {\\n            int mn1=max(n,m),mn2=max(m,n),mx1=0,mx2=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(grid[i][j]==it)\\n                    {\\n                        mn1=min(i,mn1);\\n                        mx1=max(i,mx1);\\n                        mn2=min(j,mn2);\\n                        mx2=max(j,mx2);\\n                    }\\n                }\\n            }\\n            row[it].push_back(mn1);\\n            row[it].push_back(mx1);\\n            col[it].push_back(mn2);\\n            col[it].push_back(mx2);\\n        }\\n\\t\\t\\n\\t\\t// for keeping dependency\\n        vector<vector<int>>graph(61,vector<int>());\\n        int indeg[61];\\n        memset(indeg,0,sizeof indeg);\\n        for(auto it:st)\\n        {\\n            int mnr=row[it][0],mxr=row[it][1],mnc=col[it][0],mxc=col[it][1];\\n            set<int>st2;\\n            for(int i=mnr;i<=mxr;i++)\\n            {\\n                for(int j=mnc;j<=mxc;j++)\\n                {\\n                    if(it!=grid[i][j])\\n                        st2.insert(grid[i][j]);\\n                }\\n            }\\n            indeg[it]+=st2.size();\\n            for(auto pt:st2)\\n                graph[pt].push_back(it);\\n        }\\n\\t\\t\\n\\t\\t// Standard Topological Sort \\n        int cnt=0;\\n        queue<int>q;\\n        for(int i=1;i<=61;i++)\\n        {\\n            if(st.find(i)!=st.end() and indeg[i]==0)\\n                q.push(i);\\n        }\\n        while(!q.empty())\\n        {\\n            int x=q.front();\\n            q.pop();\\n            cnt++;\\n            for(auto it:graph[x])\\n            {\\n                indeg[it]--;\\n                if(indeg[it]==0)\\n                    q.push(it);\\n            }\\n        }\\n        if(cnt==st.size())\\n            return true;\\n        return false;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 911370,
                "title": "same-as-courseschedule-topological-sort",
                "content": "If color a is contained by color b, we can say a depends on b\\n```python\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        visited = [0] * 61\\n        graph = collections.defaultdict(set)\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        for c in range(1, 61):\\n            l,r,t,b = n,-1,m,-1\\n\\t\\t\\t#to specify the covered range of color c\\n            for i in range(m):\\n                for j in range(n):\\n                    if targetGrid[i][j] == c:\\n                        l = min(l, j)\\n                        r = max(r, j)\\n                        t = min(t, i)\\n                        b = max(b, i)\\n\\t\\t\\t#to find the contained colors\\n            for i in range(t, b + 1):\\n                for j in range(l, r + 1):\\n                    if targetGrid[i][j] != c:\\n                        graph[targetGrid[i][j]].add(c)\\n        \\n\\t\\t# to find if there is a cycle \\n        def dfs(graph,i):\\n            if visited[i] == -1:\\n                return False\\n            if visited[i] == 1:\\n                return True \\n            visited[i] = -1\\n            for j in graph[i]:\\n                if not dfs(graph,j):\\n                    return False\\n            visited[i] = 1\\n            return True\\n        \\n        for c in range(61):\\n            if not dfs(graph,c):\\n                return False\\n        return True\\n```\\n\\nI appreciate it if u vote up!",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```python\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        visited = [0] * 61\\n        graph = collections.defaultdict(set)\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        for c in range(1, 61):\\n            l,r,t,b = n,-1,m,-1\\n\\t\\t\\t#to specify the covered range of color c\\n            for i in range(m):\\n                for j in range(n):\\n                    if targetGrid[i][j] == c:\\n                        l = min(l, j)\\n                        r = max(r, j)\\n                        t = min(t, i)\\n                        b = max(b, i)\\n\\t\\t\\t#to find the contained colors\\n            for i in range(t, b + 1):\\n                for j in range(l, r + 1):\\n                    if targetGrid[i][j] != c:\\n                        graph[targetGrid[i][j]].add(c)\\n        \\n\\t\\t# to find if there is a cycle \\n        def dfs(graph,i):\\n            if visited[i] == -1:\\n                return False\\n            if visited[i] == 1:\\n                return True \\n            visited[i] = -1\\n            for j in graph[i]:\\n                if not dfs(graph,j):\\n                    return False\\n            visited[i] = 1\\n            return True\\n        \\n        for c in range(61):\\n            if not dfs(graph,c):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079485,
                "title": "java-topological-sort-with-intuition-explanation-and-comments",
                "content": "The intuition can be as follows:\\n\\n1. Each color should be either complete rectangle (printed last) or have some other color in the middle (something has been printed on top of it).\\n2. For each color, we find the top left corner and bottom right corner of rectangle by traversing the grid. \\n3. If all inside is of the same color, it satisfies the problem conditions - nothing has been printed on top of it.\\n4. Otherwise, it has some colors printed on top. This means, our given color **depends** or **should go before** the colors printed on top of it.\\n\\nWhat do the words in bold remind of? Yeah, typological sort!\\n\\n5. Collect dependencies for all colors to form a graph.\\n6. Topsort the graph. Managed to do it? Then printing was possible, return `true`. Return `false` otherwise.\\n\\n```\\npublic boolean isPrintable(int[][] targetGrid) {\\n    /*\\n    1. For each color, find left top corner and right bottom corner\\n    2. All colors interfering with given color means they should go after given\\n    3. Create dependencies (1 -> [2,3])\\n    4. TopSort. Loops mean it is not possible\\n    */\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        Set<Integer> colors = new HashSet<>();\\n        int rows = targetGrid.length, cols = targetGrid[0].length;\\n\\n\\t\\t// just collect all distinct colors\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) colors.add(targetGrid[i][j]);\\n        }\\n\\n\\t    // for each color\\n        for (var c : colors) {\\n            int fr = -1, fc = Integer.MAX_VALUE, lr = -1, lc = -1;\\n            for (int i = 0; i < rows; i++) {\\n                for (int j = 0; j < cols; j++) {\\n                    if (targetGrid[i][j] == c) {\\n                        // update first row if not set\\n                        if (fr == -1) {\\n                            fr = i;\\n                        }\\n\\t\\t\\t\\t\\t\\t// update first column to be as left as possible\\n                        fc = Math.min(fc, j);\\n\\t\\t\\t\\t\\t\\t// update last row to be as down as possible\\n                        lr = i;\\n\\t\\t\\t\\t\\t\\t// update last col to be as right as possible\\n                        lc = Math.max(lc, j);\\n                    }\\n                }\\n            }\\n            \\n\\t\\t\\t// we now have coordinates for our rectangle. Left top is (fr, fc), right bottom is (lr, lc).\\n            for (int i = fr; i <= lr; i++) {\\n                for (int j = fc; j <= lc; j++) {\\n                    if (targetGrid[i][j] != c) {\\n\\t\\t\\t\\t\\t    // there is a color inside our rectangle which is not the color of main rectangle. A dependency is created.\\n                        graph.computeIfAbsent(c, z->new HashSet<>()).add(targetGrid[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n\\n\\t\\t// just try topsort, return false if not possible, true otherwise\\n        var visited = new HashSet<Integer>();\\n        var visiting = new HashSet<Integer>();\\n        for (var c : colors) {\\n            if (!topSort(visited,visiting, c, graph)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    boolean topSort(Set<Integer> visited, Set<Integer> visiting, int c, Map<Integer, Set<Integer>> graph) {\\n        if (visited.contains(c)) return true;\\n        if (visiting.contains(c)) return false;\\n        visiting.add(c);\\n        \\n        for (var nei : graph.getOrDefault(c, Collections.emptySet())) {\\n            if (!topSort(visited,visiting,nei,graph)) return false;\\n        }\\n        \\n        visiting.remove(c);\\n        visited.add(c);\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isPrintable(int[][] targetGrid) {\\n    /*\\n    1. For each color, find left top corner and right bottom corner\\n    2. All colors interfering with given color means they should go after given\\n    3. Create dependencies (1 -> [2,3])\\n    4. TopSort. Loops mean it is not possible\\n    */\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        Set<Integer> colors = new HashSet<>();\\n        int rows = targetGrid.length, cols = targetGrid[0].length;\\n\\n\\t\\t// just collect all distinct colors\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) colors.add(targetGrid[i][j]);\\n        }\\n\\n\\t    // for each color\\n        for (var c : colors) {\\n            int fr = -1, fc = Integer.MAX_VALUE, lr = -1, lc = -1;\\n            for (int i = 0; i < rows; i++) {\\n                for (int j = 0; j < cols; j++) {\\n                    if (targetGrid[i][j] == c) {\\n                        // update first row if not set\\n                        if (fr == -1) {\\n                            fr = i;\\n                        }\\n\\t\\t\\t\\t\\t\\t// update first column to be as left as possible\\n                        fc = Math.min(fc, j);\\n\\t\\t\\t\\t\\t\\t// update last row to be as down as possible\\n                        lr = i;\\n\\t\\t\\t\\t\\t\\t// update last col to be as right as possible\\n                        lc = Math.max(lc, j);\\n                    }\\n                }\\n            }\\n            \\n\\t\\t\\t// we now have coordinates for our rectangle. Left top is (fr, fc), right bottom is (lr, lc).\\n            for (int i = fr; i <= lr; i++) {\\n                for (int j = fc; j <= lc; j++) {\\n                    if (targetGrid[i][j] != c) {\\n\\t\\t\\t\\t\\t    // there is a color inside our rectangle which is not the color of main rectangle. A dependency is created.\\n                        graph.computeIfAbsent(c, z->new HashSet<>()).add(targetGrid[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n\\n\\t\\t// just try topsort, return false if not possible, true otherwise\\n        var visited = new HashSet<Integer>();\\n        var visiting = new HashSet<Integer>();\\n        for (var c : colors) {\\n            if (!topSort(visited,visiting, c, graph)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    boolean topSort(Set<Integer> visited, Set<Integer> visiting, int c, Map<Integer, Set<Integer>> graph) {\\n        if (visited.contains(c)) return true;\\n        if (visiting.contains(c)) return false;\\n        visiting.add(c);\\n        \\n        for (var nei : graph.getOrDefault(c, Collections.emptySet())) {\\n            if (!topSort(visited,visiting,nei,graph)) return false;\\n        }\\n        \\n        visiting.remove(c);\\n        visited.add(c);\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 854276,
                "title": "c-o-colors-n-m-dfs-dependency-graph",
                "content": "For each color, find its maximal rectangle. Then, for each different color inside it, it must be a valid color. It will be a valid color if inside the maximal rectangle of this different color there is none of the original color. Ex:\\n\\n1 1 1 1 1\\n1 1 2 2 2\\n1 1 2 3 3\\n1 1 1 1 1\\n\\ncall dfs for color 1\\n--it will call dfs for color 2\\n----it will call dfs for color 3\\n------there is none of (1,2) inside color 3 rectangle, 3 is ok\\n----there is none of (1) inside color 2 rectangle, 2 is ok\\n--1 is ok.\\n\\n```\\nclass Solution {\\n\\nprivate: \\n    vector<int> vis; // visitation state for each color    \\n    int n, m;\\n    \\n    bool dfs(vector<vector<int>>& targetGrid, int color) {\\n        if(vis[color] == -1) return true;\\n        if(vis[color] == 1) return false;\\n        // find bounds\\n        int l = INT_MAX, r = INT_MIN, u = INT_MAX, d = INT_MIN;\\n        for(int i = 0; i < n; i ++) \\n            for(int j = 0; j < m; j ++) \\n                if(targetGrid[i][j] == color) l = min(l, j), r = max(r, j), u = min(u, i), d = max(d, i);\\n        \\n        if(l == INT_MAX) return true; // none of this color\\n\\n        vis[color] = 1;\\n        \\n        // now, start exploring inside my maximal rectangle\\n        for(int i = u; i <= d; i ++)\\n            for(int j = l; j <= r; j ++)\\n                if(targetGrid[i][j] != color && !dfs(targetGrid, targetGrid[i][j])) return false;\\n        \\n        vis[color] = -1;\\n        \\n        return true;\\n    }\\n    \\n    \\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        n = targetGrid.size();\\n        m = targetGrid[0].size();\\n        vis = vector<int> (61, 0); // 0: didnt open, 1: open, -1: closed\\n        for(int color = 1; color <= 60; color ++) if(!dfs(targetGrid, color)) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\nprivate: \\n    vector<int> vis; // visitation state for each color    \\n    int n, m;\\n    \\n    bool dfs(vector<vector<int>>& targetGrid, int color) {\\n        if(vis[color] == -1) return true;\\n        if(vis[color] == 1) return false;\\n        // find bounds\\n        int l = INT_MAX, r = INT_MIN, u = INT_MAX, d = INT_MIN;\\n        for(int i = 0; i < n; i ++) \\n            for(int j = 0; j < m; j ++) \\n                if(targetGrid[i][j] == color) l = min(l, j), r = max(r, j), u = min(u, i), d = max(d, i);\\n        \\n        if(l == INT_MAX) return true; // none of this color\\n\\n        vis[color] = 1;\\n        \\n        // now, start exploring inside my maximal rectangle\\n        for(int i = u; i <= d; i ++)\\n            for(int j = l; j <= r; j ++)\\n                if(targetGrid[i][j] != color && !dfs(targetGrid, targetGrid[i][j])) return false;\\n        \\n        vis[color] = -1;\\n        \\n        return true;\\n    }\\n    \\n    \\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        n = targetGrid.size();\\n        m = targetGrid[0].size();\\n        vis = vector<int> (61, 0); // 0: didnt open, 1: open, -1: closed\\n        for(int color = 1; color <= 60; color ++) if(!dfs(targetGrid, color)) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012697,
                "title": "c-topological-sort-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& tg) \\n    {\\n        int n=tg.size(),m=tg[0].size();\\n        vector<int> xmax(61,-1),xmin(61,n),ymax(61,-1),ymin(61,m);\\n        vector<vector<int>> g(61);\\n        for(int i=0;i<n;i++)// find max &min index in x& y\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                xmax[tg[i][j]]=max(xmax[tg[i][j]],i);\\n                xmin[tg[i][j]]=min(xmin[tg[i][j]],i);\\n                ymax[tg[i][j]]=max(ymax[tg[i][j]],j);\\n                ymin[tg[i][j]]=min(ymin[tg[i][j]],j);\\n            }\\n        }\\n        vector<int> indeg(61);\\n        for(int colr=1;colr<=60;colr++)\\n        {\\n            for(int i=xmin[colr];i<=xmax[colr];i++)\\n            {\\n                for(int j=ymin[colr];j<=ymax[colr];j++)\\n                {\\n                    if(tg[i][j]!=colr)\\n                    {\\n                        g[colr].push_back(tg[i][j]);\\n                        indeg[tg[i][j]]++;// count indegree\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        int visited=0;\\n        queue<int> q;\\n        for(int colr=1;colr<=60;colr++)///push whose indegree=0\\n        {\\n            if(!indeg[colr])\\n            {\\n                q.push(colr);\\n            }\\n        }\\n\\n            while(!q.empty())\\n            {\\n                int node=q.front();\\n                q.pop();\\n                visited++;\\n                for(auto &child:g[node])\\n                {\\n                    if(!(--indeg[child]))\\n                        q.push(child);\\n                }\\n            }\\n        \\n        return visited==60;\\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& tg) \\n    {\\n        int n=tg.size(),m=tg[0].size();\\n        vector<int> xmax(61,-1),xmin(61,n),ymax(61,-1),ymin(61,m);\\n        vector<vector<int>> g(61);\\n        for(int i=0;i<n;i++)// find max &min index in x& y\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                xmax[tg[i][j]]=max(xmax[tg[i][j]],i);\\n                xmin[tg[i][j]]=min(xmin[tg[i][j]],i);\\n                ymax[tg[i][j]]=max(ymax[tg[i][j]],j);\\n                ymin[tg[i][j]]=min(ymin[tg[i][j]],j);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 854187,
                "title": "c-o-m-n-c-2-think-backwards-and-brute-force-check",
                "content": "The method:\\n1. O(m\\\\*n) Iterate to get all colors and each color\\'s min x, min y, max x, max y\\n2. O(m\\\\*n\\\\*c^2) Think backwards from the last color to the first color. Loop to check each color if it satisfies the condition (from min x to max x, min y to max y, each postion\\'s value is the color or already printed(-1)).\\nReturn true if all colors are checked. Otherwise return false.\\n\\nRuntime complexity: O(m\\\\*n\\\\*c^2)\\nSpace complexity: O(c)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m = targetGrid.size();\\n        int n = targetGrid[0].size();\\n        unordered_map<int, vector<int>> hmap;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int val = targetGrid[i][j];\\n                if (hmap.find(val) == hmap.end()) {\\n                    hmap[val] = {i, j, i, j};\\n                } else {\\n                    hmap[val][0] = min(hmap[val][0], i);\\n                    hmap[val][1] = min(hmap[val][1], j);\\n                    hmap[val][2] = max(hmap[val][2], i);\\n                    hmap[val][3] = max(hmap[val][3], j);\\n                }\\n            }\\n        }\\n        int count = hmap.size();\\n        for (int i = 0; i < count; i++) {\\n            int found = -1;\\n            for (auto &it : hmap) {\\n                int val = it.first;\\n                bool valid = true;\\n                for (int x = it.second[0]; x <= it.second[2]; x++) {\\n                    for (int y = it.second[1]; y <= it.second[3]; y++) {\\n                        if (targetGrid[x][y] != -1 && targetGrid[x][y] != val) {\\n                            valid = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (valid) {\\n                    found = val;\\n                    for (int x = it.second[0]; x <= it.second[2]; x++) {\\n                        for (int y = it.second[1]; y <= it.second[3]; y++) {\\n                            targetGrid[x][y] = -1;\\n                        }\\n                    }\\n                }\\n            }\\n            if (found != -1) {\\n                hmap.erase(found);\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m = targetGrid.size();\\n        int n = targetGrid[0].size();\\n        unordered_map<int, vector<int>> hmap;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int val = targetGrid[i][j];\\n                if (hmap.find(val) == hmap.end()) {\\n                    hmap[val] = {i, j, i, j};\\n                } else {\\n                    hmap[val][0] = min(hmap[val][0], i);\\n                    hmap[val][1] = min(hmap[val][1], j);\\n                    hmap[val][2] = max(hmap[val][2], i);\\n                    hmap[val][3] = max(hmap[val][3], j);\\n                }\\n            }\\n        }\\n        int count = hmap.size();\\n        for (int i = 0; i < count; i++) {\\n            int found = -1;\\n            for (auto &it : hmap) {\\n                int val = it.first;\\n                bool valid = true;\\n                for (int x = it.second[0]; x <= it.second[2]; x++) {\\n                    for (int y = it.second[1]; y <= it.second[3]; y++) {\\n                        if (targetGrid[x][y] != -1 && targetGrid[x][y] != val) {\\n                            valid = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (valid) {\\n                    found = val;\\n                    for (int x = it.second[0]; x <= it.second[2]; x++) {\\n                        for (int y = it.second[1]; y <= it.second[3]; y++) {\\n                            targetGrid[x][y] = -1;\\n                        }\\n                    }\\n                }\\n            }\\n            if (found != -1) {\\n                hmap.erase(found);\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854185,
                "title": "python-3-n-3-with-clean-code",
                "content": "```\\n\"\"\"\\n1. Find minimal rectangle for printing each color. Its corners for color X can be found as minimal and maximal coordinates of cells with X.\\n2. Each such rectangular might contain cells with different colors, then those colors have to be printed after current one.\\n3. Using previous point, build dependency graph between colors.\\n4. If there are cycles in this graph, then it means that color X has to be printed after Y and Y after X, so it\\'s not possible to print.\\n\"\"\"\\n\\n\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        # FIND RECTANGLE BOUNDARIES FOR EACH COLOR\\n        boundaries = [(math.inf, math.inf, -math.inf, -math.inf) for _ in range(61)]\\n        for i in range(len(targetGrid)):\\n            for j in range(len(targetGrid[i])):\\n                color = targetGrid[i][j]\\n                min_i, min_j, max_i, max_j = boundaries[color]\\n                boundaries[color] = (min(min_i, i), min(min_j, j), max(max_i, i), max(max_j, j))\\n\\n        # BUILD GRAPH\\n        graph = defaultdict(set)\\n        for color in range(len(boundaries)):\\n            min_i, min_j, max_i, max_j = boundaries[color]\\n            if min_i != math.inf:\\n                for i in range(min_i, max_i + 1):\\n                    for j in range(min_j, max_j + 1):\\n                        if targetGrid[i][j] != color:\\n                            graph[color].add(targetGrid[i][j])\\n\\n        # DETECT CYCLES IN GRAPH\\n        visited = set()\\n        in_progress = set()\\n        def dfs(source):\\n            in_progress.add(source)\\n            for vertex in graph[source]:\\n                if (vertex in in_progress) or (vertex not in visited and not dfs(vertex)):\\n                    return False\\n            in_progress.remove(source)\\n            visited.add(source)\\n            return True\\n\\n        for color in range(61):\\n            if color not in visited and not dfs(color):\\n                return False\\n        return True\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n1. Find minimal rectangle for printing each color. Its corners for color X can be found as minimal and maximal coordinates of cells with X.\\n2. Each such rectangular might contain cells with different colors, then those colors have to be printed after current one.\\n3. Using previous point, build dependency graph between colors.\\n4. If there are cycles in this graph, then it means that color X has to be printed after Y and Y after X, so it\\'s not possible to print.\\n\"\"\"\\n\\n\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        # FIND RECTANGLE BOUNDARIES FOR EACH COLOR\\n        boundaries = [(math.inf, math.inf, -math.inf, -math.inf) for _ in range(61)]\\n        for i in range(len(targetGrid)):\\n            for j in range(len(targetGrid[i])):\\n                color = targetGrid[i][j]\\n                min_i, min_j, max_i, max_j = boundaries[color]\\n                boundaries[color] = (min(min_i, i), min(min_j, j), max(max_i, i), max(max_j, j))\\n\\n        # BUILD GRAPH\\n        graph = defaultdict(set)\\n        for color in range(len(boundaries)):\\n            min_i, min_j, max_i, max_j = boundaries[color]\\n            if min_i != math.inf:\\n                for i in range(min_i, max_i + 1):\\n                    for j in range(min_j, max_j + 1):\\n                        if targetGrid[i][j] != color:\\n                            graph[color].add(targetGrid[i][j])\\n\\n        # DETECT CYCLES IN GRAPH\\n        visited = set()\\n        in_progress = set()\\n        def dfs(source):\\n            in_progress.add(source)\\n            for vertex in graph[source]:\\n                if (vertex in in_progress) or (vertex not in visited and not dfs(vertex)):\\n                    return False\\n            in_progress.remove(source)\\n            visited.add(source)\\n            return True\\n\\n        for color in range(61):\\n            if color not in visited and not dfs(color):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855391,
                "title": "python-solution-with-explanation-100-tc-o-cmn-100-sc-o-c-2",
                "content": "Let M, N be the dimension of the grid, and let C be the number of colors. Define a class Box representing a rectangle region in the grid.\\n\\n(1) For each color, find the minimum (bounding) box that covers all its cells. Time complexity O(MN), space complexity O(C).\\n(2) For each color, find other colors that appear in its minimum box. Time complexity O(CMN), space complexity O(C^2).\\n(3) View all colors as vertices in a directed (dependency) graph. Color u connects to color v, if color v appears in color u\\'s minimum box. That means, color v must be painted after the primary color u of the box being painted.\\n(4) Perform depth-first search to check whether the directed graph is cyclic. Time complexity O(C + C^2), space complexity O(C + C^2).\\n\\nOverall time complexity O(CMN), overall space complexity O(C^2) (excluding the space of the MxN grid).\\n\\nAn alternative solution is to reverse the edges in the dependency graph and to perform a topological sort.\\n\\n```\\nclass Box(object):\\n    def __init__(self):\\n        self.top = float(\\'inf\\')\\n        self.bot = 0\\n        self.left = float(\\'inf\\')\\n        self.right = 0\\n    \\n    def update(self, r, c):\\n        self.top = min(self.top, r)\\n        self.bot = max(self.bot, r)\\n        self.left = min(self.left, c)\\n        self.right = max(self.right, c)\\n        \\n    def colors(self, grid):\\n        return set(grid[r][c]\\n                   for r in range(self.top, self.bot+1)\\n                   for c in range(self.left, self.right+1))\\n        \\nclass Solution(object):\\n    def isPrintable(self, targetGrid):\\n        \"\"\"\\n        :type targetGrid: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        R, C = len(targetGrid), len(targetGrid[0])\\n\\t\\t\\n\\t\\t# get the minimum box for each color \\n        boxes = collections.defaultdict(Box)\\n        for r in range(R):\\n            for c in range(C):\\n                boxes[targetGrid[r][c]].update(r, c)\\n        \\n\\t\\t# build the directed graph\\n        graph = {color: box.colors(targetGrid) - set([color]) \\n                 for color, box in boxes.items()}\\n\\t\\t\\t\\n        # perform dfs to check whether the graph is cyclic\\n        seen = set()\\n        path = set()\\n        def isCyclic(u):\\n            if u in seen:\\n                return u in path\\n            seen.add(u)\\n            path.add(u)\\n            for v in graph[u]:\\n                if isCyclic(v):\\n                    return True\\n            path.remove(u)\\n            return False\\n        \\n        for color in boxes.keys():\\n            if isCyclic(color):\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Box(object):\\n    def __init__(self):\\n        self.top = float(\\'inf\\')\\n        self.bot = 0\\n        self.left = float(\\'inf\\')\\n        self.right = 0\\n    \\n    def update(self, r, c):\\n        self.top = min(self.top, r)\\n        self.bot = max(self.bot, r)\\n        self.left = min(self.left, c)\\n        self.right = max(self.right, c)\\n        \\n    def colors(self, grid):\\n        return set(grid[r][c]\\n                   for r in range(self.top, self.bot+1)\\n                   for c in range(self.left, self.right+1))\\n        \\nclass Solution(object):\\n    def isPrintable(self, targetGrid):\\n        \"\"\"\\n        :type targetGrid: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        R, C = len(targetGrid), len(targetGrid[0])\\n\\t\\t\\n\\t\\t# get the minimum box for each color \\n        boxes = collections.defaultdict(Box)\\n        for r in range(R):\\n            for c in range(C):\\n                boxes[targetGrid[r][c]].update(r, c)\\n        \\n\\t\\t# build the directed graph\\n        graph = {color: box.colors(targetGrid) - set([color]) \\n                 for color, box in boxes.items()}\\n\\t\\t\\t\\n        # perform dfs to check whether the graph is cyclic\\n        seen = set()\\n        path = set()\\n        def isCyclic(u):\\n            if u in seen:\\n                return u in path\\n            seen.add(u)\\n            path.add(u)\\n            for v in graph[u]:\\n                if isCyclic(v):\\n                    return True\\n            path.remove(u)\\n            return False\\n        \\n        for color in boxes.keys():\\n            if isCyclic(color):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167855,
                "title": "java-very-easy-solution",
                "content": "*Comment if you have any doubt and upvote if you like the solution if I get **100** UpVote i will upload solution explantion on youtube as well*\\n\\n# Code\\n```\\nclass Solution {\\n    private boolean isRectangle(int[][] grid , int n , int r1 , int c1,int r2, int c2, Set<Integer> rect){\\n        for(; r1 <= r2; r1++){\\n            for(int i = c1; i <= c2; i++){\\n                if(grid[r1][i] == n || rect.contains(grid[r1][i])){\\n                    continue;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean isPrintable(int[][] grid) {\\n        Map<Integer, int[]> colors = new HashMap<>();\\n        Set<Integer> rect = new HashSet<>();\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(colors.containsKey(grid[i][j])){\\n                    int[] arr = colors.get(grid[i][j]);\\n                    arr[0] = Math.min(arr[0], i);\\n                    arr[1] = Math.min(arr[1], j);\\n                    arr[2] = Math.max(arr[2], i);\\n                    arr[3] = Math.max(arr[3], j);\\n                }else{\\n                    colors.put(grid[i][j], new int[]{i, j, i, j});\\n                }\\n            }\\n        }\\n        for(int color : colors.keySet()){\\n            int[] arr = colors.get(color);\\n            if(isRectangle(grid, color, arr[0], arr[1], arr[2], arr[3], rect)){\\n                rect.add(color);\\n            }\\n        }\\n        for(int i = 0; i < colors.size(); i++){\\n        for(int color : colors.keySet()){\\n            if(rect.contains(color))\\n            continue;\\n            int[] arr = colors.get(color);\\n            if(isRectangle(grid, color, arr[0], arr[1], arr[2], arr[3], rect)){\\n                rect.add(color);\\n            }\\n         }\\n        }\\n        return rect.size()==colors.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    private boolean isRectangle(int[][] grid , int n , int r1 , int c1,int r2, int c2, Set<Integer> rect){\\n        for(; r1 <= r2; r1++){\\n            for(int i = c1; i <= c2; i++){\\n                if(grid[r1][i] == n || rect.contains(grid[r1][i])){\\n                    continue;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean isPrintable(int[][] grid) {\\n        Map<Integer, int[]> colors = new HashMap<>();\\n        Set<Integer> rect = new HashSet<>();\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(colors.containsKey(grid[i][j])){\\n                    int[] arr = colors.get(grid[i][j]);\\n                    arr[0] = Math.min(arr[0], i);\\n                    arr[1] = Math.min(arr[1], j);\\n                    arr[2] = Math.max(arr[2], i);\\n                    arr[3] = Math.max(arr[3], j);\\n                }else{\\n                    colors.put(grid[i][j], new int[]{i, j, i, j});\\n                }\\n            }\\n        }\\n        for(int color : colors.keySet()){\\n            int[] arr = colors.get(color);\\n            if(isRectangle(grid, color, arr[0], arr[1], arr[2], arr[3], rect)){\\n                rect.add(color);\\n            }\\n        }\\n        for(int i = 0; i < colors.size(); i++){\\n        for(int color : colors.keySet()){\\n            if(rect.contains(color))\\n            continue;\\n            int[] arr = colors.get(color);\\n            if(isRectangle(grid, color, arr[0], arr[1], arr[2], arr[3], rect)){\\n                rect.add(color);\\n            }\\n         }\\n        }\\n        return rect.size()==colors.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374236,
                "title": "c-explained-topological-sort-cycle-detection-o-c-m-n",
                "content": "For each colour C find its max and min x, y coordinates, say xmin,xmax,ymin,ymax. All the colours except C that appear in 2D grid bounded by these x, y are \"contained\" in C, or we can say there is a directed edge from C to these colours. This is because while painting, C must have appeared before all the colours contained in C. If we get a cycle in the auxiliary graph we create from these dependencies then it is impossible to print. See code with comments below.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        \\n        vector<vector<int>> adj(60);\\n        populateAdj(adj, targetGrid);\\n\\n        int *visited = new int[60];\\n        \\n        for(int i=0;i<60;i++) visited[i]=0;\\n        \\n        for(int i=0;i<60;i++) {\\n            if(visited[i]==0) {\\n                bool temp = dfs(i,adj,targetGrid, visited);\\n                if(temp==0) {\\n                    return 0;\\n                }\\n            }\\n        }    \\n    \\n        return 1;     \\n    }\\n    \\n    void populateAdj(vector<vector<int>> &adj, vector<vector<int>>& targetGrid) {\\n        \\n        for(int k=0;k<60;k++) {\\n            \\n\\t\\t\\t//finds min,max x, y co-ordinates\\n\\t\\t\\t//finds all colors contained in k\\n\\t\\t\\t//adds them to the adj list of k\\n\\t\\t\\t\\n            int xmin=INT_MAX, xmax=INT_MIN, ymin=INT_MAX, ymax=INT_MIN;\\n            int n = targetGrid.size();\\n            int m = targetGrid[0].size();\\n            \\n            for(int i=0;i<n;i++) {\\n                for(int j=0;j<m;j++) {\\n                    if(targetGrid[i][j]==k+1) {\\n                        xmin = min(xmin,i);\\n                        xmax = max(xmax,i);\\n                        ymin = min(ymin,j);\\n                        ymax = max(ymax,j);\\n                    }\\n                }\\n            }\\n            \\n            if(xmin==INT_MAX) {\\n                continue;\\n            }\\n            \\n            unordered_set<int> seen;\\n            for(int i=xmin;i<=xmax;i++) {\\n                for(int j=ymin;j<=ymax;j++) {\\n                    if(targetGrid[i][j]!=k+1 && seen.find(targetGrid[i][j]-1)==seen.end()) {\\n                        seen.insert(targetGrid[i][j]-1);\\n                        adj[k].push_back(targetGrid[i][j]-1);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool dfs(int i, vector<vector<int>> &adj, vector<vector<int>>& targetGrid, int* &visited) {\\n        \\n\\t\\t//simple dfs for cycle detection in a graph\\n\\t\\t// See here for more explanation: https://cp-algorithms.com/graph/finding-cycle.html\\n\\t\\t\\n        visited[i]=1;\\n        \\n        for(auto &color : adj[i]) {\\n            if(visited[color]==1) {\\n                return 0;\\n            } else if(visited[color]==0) {\\n                if(!dfs(color,adj,targetGrid,visited)) {\\n                    return 0;\\n                }\\n            }\\n        }\\n        \\n        visited[i]=2;    \\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        \\n        vector<vector<int>> adj(60);\\n        populateAdj(adj, targetGrid);\\n\\n        int *visited = new int[60];\\n        \\n        for(int i=0;i<60;i++) visited[i]=0;\\n        \\n        for(int i=0;i<60;i++) {\\n            if(visited[i]==0) {\\n                bool temp = dfs(i,adj,targetGrid, visited);\\n                if(temp==0) {\\n                    return 0;\\n                }\\n            }\\n        }    \\n    \\n        return 1;     \\n    }\\n    \\n    void populateAdj(vector<vector<int>> &adj, vector<vector<int>>& targetGrid) {\\n        \\n        for(int k=0;k<60;k++) {\\n            \\n\\t\\t\\t//finds min,max x, y co-ordinates\\n\\t\\t\\t//finds all colors contained in k\\n\\t\\t\\t//adds them to the adj list of k\\n\\t\\t\\t\\n            int xmin=INT_MAX, xmax=INT_MIN, ymin=INT_MAX, ymax=INT_MIN;\\n            int n = targetGrid.size();\\n            int m = targetGrid[0].size();\\n            \\n            for(int i=0;i<n;i++) {\\n                for(int j=0;j<m;j++) {\\n                    if(targetGrid[i][j]==k+1) {\\n                        xmin = min(xmin,i);\\n                        xmax = max(xmax,i);\\n                        ymin = min(ymin,j);\\n                        ymax = max(ymax,j);\\n                    }\\n                }\\n            }\\n            \\n            if(xmin==INT_MAX) {\\n                continue;\\n            }\\n            \\n            unordered_set<int> seen;\\n            for(int i=xmin;i<=xmax;i++) {\\n                for(int j=ymin;j<=ymax;j++) {\\n                    if(targetGrid[i][j]!=k+1 && seen.find(targetGrid[i][j]-1)==seen.end()) {\\n                        seen.insert(targetGrid[i][j]-1);\\n                        adj[k].push_back(targetGrid[i][j]-1);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool dfs(int i, vector<vector<int>> &adj, vector<vector<int>>& targetGrid, int* &visited) {\\n        \\n\\t\\t//simple dfs for cycle detection in a graph\\n\\t\\t// See here for more explanation: https://cp-algorithms.com/graph/finding-cycle.html\\n\\t\\t\\n        visited[i]=1;\\n        \\n        for(auto &color : adj[i]) {\\n            if(visited[color]==1) {\\n                return 0;\\n            } else if(visited[color]==0) {\\n                if(!dfs(color,adj,targetGrid,visited)) {\\n                    return 0;\\n                }\\n            }\\n        }\\n        \\n        visited[i]=2;    \\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765673,
                "title": "c-solution-using-topo-sort",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool isPrintable(vector<vector<int>>& mat)\\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int>dp[65];\\n        vector<int>ind(65,0);\\n        unordered_set<int>uni;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                uni.insert(mat[i][j]);\\n            }\\n        }\\n        for(auto it:uni)\\n        {\\n            int min_x,min_y,max_x,max_y;\\n            min_x=min_y=INT_MAX;\\n            max_x=max_y=INT_MIN;\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(mat[i][j]==it)\\n                    {\\n                        min_x=min(min_x,i);\\n                        max_x=max(max_x,i);\\n                        min_y=min(min_y,j);\\n                        max_y=max(max_y,j);\\n                    }\\n                }\\n            }\\n            if(min_x==INT_MAX)\\n            {\\n                continue;\\n            }\\n            unordered_set<int>d;\\n            for(int i=min_x;i<=max_x;i++)\\n            {\\n                for(int j=min_y;j<=max_y;j++)\\n                {\\n                    if(mat[i][j]!=it)\\n                    {\\n                        d.insert(mat[i][j]);\\n                    }\\n                }\\n            }\\n            for(auto t:d)\\n            {\\n                dp[it].push_back(t);\\n                ind[t]++;\\n            }\\n        }\\n            queue<int>q;\\n            for(auto it:uni)\\n            {\\n                if(ind[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n             int count=0;\\n            while(q.size())\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                count++;\\n                for(auto it:dp[temp])\\n                {\\n                    if(--ind[it]==0)\\n                    {\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n        return (count==uni.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool isPrintable(vector<vector<int>>& mat)\\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int>dp[65];\\n        vector<int>ind(65,0);\\n        unordered_set<int>uni;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                uni.insert(mat[i][j]);\\n            }\\n        }\\n        for(auto it:uni)\\n        {\\n            int min_x,min_y,max_x,max_y;\\n            min_x=min_y=INT_MAX;\\n            max_x=max_y=INT_MIN;\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(mat[i][j]==it)\\n                    {\\n                        min_x=min(min_x,i);\\n                        max_x=max(max_x,i);\\n                        min_y=min(min_y,j);\\n                        max_y=max(max_y,j);\\n                    }\\n                }\\n            }\\n            if(min_x==INT_MAX)\\n            {\\n                continue;\\n            }\\n            unordered_set<int>d;\\n            for(int i=min_x;i<=max_x;i++)\\n            {\\n                for(int j=min_y;j<=max_y;j++)\\n                {\\n                    if(mat[i][j]!=it)\\n                    {\\n                        d.insert(mat[i][j]);\\n                    }\\n                }\\n            }\\n            for(auto t:d)\\n            {\\n                dp[it].push_back(t);\\n                ind[t]++;\\n            }\\n        }\\n            queue<int>q;\\n            for(auto it:uni)\\n            {\\n                if(ind[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n             int count=0;\\n            while(q.size())\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                count++;\\n                for(auto it:dp[temp])\\n                {\\n                    if(--ind[it]==0)\\n                    {\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n        return (count==uni.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516602,
                "title": "toposort-concept-python-code",
                "content": "```\\nclass Solution(object):\\n    def isPrintable(self, targetGrid):\\n        \"\"\"\\n        :type targetGrid: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n#doing reverse engineering like toposort concept find that reactangle which is completely independent,and remove and process futher\\n        m,n=len(targetGrid),len(targetGrid[0])\\n        # strore upper,left,right,bottom most for every color\\n        colors={}\\n        for i in range(m):\\n            for j in range(n):\\n                c=targetGrid[i][j]\\n                if c not in colors:\\n                    colors[c]=[sys.maxsize,sys.maxsize,-1*sys.maxsize,-1*sys.maxsize]\\n                colors[c][0]=min(colors[c][0],i)\\n                colors[c][1]=min(colors[c][1],j)\\n                colors[c][2]=max(colors[c][2],j)\\n                colors[c][3]=max(colors[c][3],i)\\n        # print(colors)\\n        # this is for check is it possible to fill with this color or not\\n        def isPossibleTofill(color):\\n            upper,left,right,bottom=colors[color]\\n            for i in range(upper,bottom+1):\\n                for j in range(left,right+1):\\n                    if targetGrid[i][j]>0 and targetGrid[i][j]!=color:return False\\n            for i in range(upper,bottom+1):\\n                for j in range(left,right+1):\\n                    targetGrid[i][j]=0\\n            return True\\n                                 \\n        c1=colors.keys()\\n        while c1:\\n            c2=set()\\n            for col in c1:\\n                if isPossibleTofill(col)==False:\\n                    c2.add(col)\\n            if len(c2)==len(c1):return False\\n            c1=c2\\n        if len(c1)==0:return True\\n        return False\\n                    \\n                    \\n        \\n                            \\n        \\n                                 \\n                           \\n                                 \\n                                 \\n                                 \\n                                 \\n                    \\n\\n                                \\n                                \\n                                 \\n    \\n                                 \\n        \\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def isPrintable(self, targetGrid):\\n        \"\"\"\\n        :type targetGrid: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n#doing reverse engineering like toposort concept find that reactangle which is completely independent,and remove and process futher\\n        m,n=len(targetGrid),len(targetGrid[0])\\n        # strore upper,left,right,bottom most for every color\\n        colors={}",
                "codeTag": "Java"
            },
            {
                "id": 885310,
                "title": "python3-simulate-the-reverse-process-of-painting",
                "content": "I think the question can be classified as **simulation**. We\\'re simulating the reverse process of painting the grid. We define color A is on top of color B if we paint A after B. Then, we\\'re removing colors from top to down. Actually, the function ```isTop``` is testing if the color is one of the top colors, if it\\'s then we won\\'t add it to ```not_top_colors```  which means we remove it. ```not_top_colors``` stores the colors that are not on the top currently and we\\'ll try to remove them after we remove the current top most colors.\\nSo, essentially the code does(**simulates**) the reverse process of painting.\\n\\nGot key inspiration from https://leetcode.com/problems/strange-printer-ii/discuss/854193/Python-Straight-Forward where the top colors are marked as 0 instead of some specific color.\\n```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        \\'\\'\\'\\n        Remove the colors from top to bottom\\n        \\'\\'\\'\\n        colors = set()\\n        rows, cols = len(targetGrid), len(targetGrid[0])\\n        for r in range(rows):\\n            for c in range(cols):\\n                colors.add(targetGrid[r][c])\\n\\t\\t# Find the left/top/right/bottom most positions of each color which can define a rectangle.\\n        # left, top, right, bottom\\n        pos = [[float(\\'inf\\'), float(\\'inf\\'), float(\\'-inf\\'), float(\\'-inf\\')] for _ in range(max(colors) + 1)]\\n        for r in range(rows):\\n            for c in range(cols):\\n                color = targetGrid[r][c]\\n                pos[color][0] = min(pos[color][0], c)\\n                pos[color][1] = min(pos[color][1], r)\\n                pos[color][2] = max(pos[color][2], c)\\n                pos[color][3] = max(pos[color][3], r)\\n        def isTop(color):\\n            \\'\\'\\'\\n            Return True if color is current to top most\\n            else return False\\n            A color is on the top if the rectangle contains only this color or no color\\n            \\'\\'\\'\\n            for r in range(pos[color][1], pos[color][3] + 1):\\n                for c in range(pos[color][0], pos[color][2] + 1):\\n                    if targetGrid[r][c] > 0 and targetGrid[r][c] != color:\\n                        return False\\n            for r in range(pos[color][1], pos[color][3] + 1):\\n                for c in range(pos[color][0], pos[color][2] + 1):\\n                    targetGrid[r][c] = 0\\n            return True\\n        while colors:\\n            not_top_colors = set()\\n            for color in colors:\\n                if not isTop(color):\\n                    not_top_colors.add(color)\\n            if len(colors) == len(not_top_colors):\\n                # no color is on the top, so there is no way to paint the target \\n                # because there is always a color that is on top of the other colors if\\n                # we paint the grid one color by one color\\n                return False\\n            colors = not_top_colors\\n        return True\\n```",
                "solutionTags": [],
                "code": "```isTop```\n```not_top_colors```\n```not_top_colors```\n```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        \\'\\'\\'\\n        Remove the colors from top to bottom\\n        \\'\\'\\'\\n        colors = set()\\n        rows, cols = len(targetGrid), len(targetGrid[0])\\n        for r in range(rows):\\n            for c in range(cols):\\n                colors.add(targetGrid[r][c])\\n\\t\\t# Find the left/top/right/bottom most positions of each color which can define a rectangle.\\n        # left, top, right, bottom\\n        pos = [[float(\\'inf\\'), float(\\'inf\\'), float(\\'-inf\\'), float(\\'-inf\\')] for _ in range(max(colors) + 1)]\\n        for r in range(rows):\\n            for c in range(cols):\\n                color = targetGrid[r][c]\\n                pos[color][0] = min(pos[color][0], c)\\n                pos[color][1] = min(pos[color][1], r)\\n                pos[color][2] = max(pos[color][2], c)\\n                pos[color][3] = max(pos[color][3], r)\\n        def isTop(color):\\n            \\'\\'\\'\\n            Return True if color is current to top most\\n            else return False\\n            A color is on the top if the rectangle contains only this color or no color\\n            \\'\\'\\'\\n            for r in range(pos[color][1], pos[color][3] + 1):\\n                for c in range(pos[color][0], pos[color][2] + 1):\\n                    if targetGrid[r][c] > 0 and targetGrid[r][c] != color:\\n                        return False\\n            for r in range(pos[color][1], pos[color][3] + 1):\\n                for c in range(pos[color][0], pos[color][2] + 1):\\n                    targetGrid[r][c] = 0\\n            return True\\n        while colors:\\n            not_top_colors = set()\\n            for color in colors:\\n                if not isTop(color):\\n                    not_top_colors.add(color)\\n            if len(colors) == len(not_top_colors):\\n                # no color is on the top, so there is no way to paint the target \\n                # because there is always a color that is on top of the other colors if\\n                # we paint the grid one color by one color\\n                return False\\n            colors = not_top_colors\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863681,
                "title": "c-simple-solution-o-n-3",
                "content": "1. For each color find most left, right, bottom, top. These coordinate finally should form a rectangle.\\n2. Build graph with indegrees. So virtual grid for each color has dependencies on its nested other colors.\\n3. Use topological sort technique.\\n\\n```\\nstruct coords\\n{\\n\\tint left = INT_MAX;\\n\\tint right = INT_MIN;\\n\\tint bottom = INT_MAX;\\n\\tint top = INT_MIN;\\n};\\n\\nbool isPrintable(vector<vector<int>>& grid) \\n{\\n\\tvector<coords> colors(61);\\n\\n\\tfor (int row = 0; row < grid.size(); ++row)\\n\\t\\tfor (int col = 0; col < grid[row].size(); ++col)\\n\\t\\t\\tcolors[grid[row][col]].left = min(colors[grid[row][col]].left, col),\\n\\t\\t\\tcolors[grid[row][col]].right = max(colors[grid[row][col]].right, col),\\n\\t\\t\\tcolors[grid[row][col]].bottom = min(colors[grid[row][col]].bottom, row),\\n\\t\\t\\tcolors[grid[row][col]].top = max(colors[grid[row][col]].top, row);\\n\\n\\tunordered_map<int, unordered_set<int>> indegrees, graph;\\n\\n\\tfor (int i = 0; i < colors.size(); ++i)\\n\\t\\tfor (int row = colors[i].bottom; row >= 0 && row <= colors[i].top; ++row)\\n\\t\\t\\tfor (int col = colors[i].left; col >= 0 && col <= colors[i].right; ++col)\\n\\t\\t\\t\\tif (grid[row][col] != i)\\n\\t\\t\\t\\t\\tindegrees[i].insert(grid[row][col]), graph[grid[row][col]].insert(i);\\n\\n\\tqueue<int> queue;\\n\\n\\tfor (int i = 0; i < colors.size(); ++i)\\n\\t\\tif (!indegrees.count(i))\\n\\t\\t\\tqueue.push(i);\\n\\n\\twhile (!queue.empty())\\n\\t{\\n\\t\\tauto cur = queue.front();\\n\\t\\tqueue.pop();\\n\\n\\t\\tfor (auto adj : graph[cur])\\n\\t\\t{\\n\\t\\t\\tindegrees[adj].erase(cur);\\n\\n\\t\\t\\tif (indegrees[adj].empty())\\n\\t\\t\\t\\tqueue.push(adj), indegrees.erase(adj);\\n\\t\\t}\\n\\t}\\n\\n\\treturn indegrees.empty();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct coords\\n{\\n\\tint left = INT_MAX;\\n\\tint right = INT_MIN;\\n\\tint bottom = INT_MAX;\\n\\tint top = INT_MIN;\\n};\\n\\nbool isPrintable(vector<vector<int>>& grid) \\n{\\n\\tvector<coords> colors(61);\\n\\n\\tfor (int row = 0; row < grid.size(); ++row)\\n\\t\\tfor (int col = 0; col < grid[row].size(); ++col)\\n\\t\\t\\tcolors[grid[row][col]].left = min(colors[grid[row][col]].left, col),\\n\\t\\t\\tcolors[grid[row][col]].right = max(colors[grid[row][col]].right, col),\\n\\t\\t\\tcolors[grid[row][col]].bottom = min(colors[grid[row][col]].bottom, row),\\n\\t\\t\\tcolors[grid[row][col]].top = max(colors[grid[row][col]].top, row);\\n\\n\\tunordered_map<int, unordered_set<int>> indegrees, graph;\\n\\n\\tfor (int i = 0; i < colors.size(); ++i)\\n\\t\\tfor (int row = colors[i].bottom; row >= 0 && row <= colors[i].top; ++row)\\n\\t\\t\\tfor (int col = colors[i].left; col >= 0 && col <= colors[i].right; ++col)\\n\\t\\t\\t\\tif (grid[row][col] != i)\\n\\t\\t\\t\\t\\tindegrees[i].insert(grid[row][col]), graph[grid[row][col]].insert(i);\\n\\n\\tqueue<int> queue;\\n\\n\\tfor (int i = 0; i < colors.size(); ++i)\\n\\t\\tif (!indegrees.count(i))\\n\\t\\t\\tqueue.push(i);\\n\\n\\twhile (!queue.empty())\\n\\t{\\n\\t\\tauto cur = queue.front();\\n\\t\\tqueue.pop();\\n\\n\\t\\tfor (auto adj : graph[cur])\\n\\t\\t{\\n\\t\\t\\tindegrees[adj].erase(cur);\\n\\n\\t\\t\\tif (indegrees[adj].empty())\\n\\t\\t\\t\\tqueue.push(adj), indegrees.erase(adj);\\n\\t\\t}\\n\\t}\\n\\n\\treturn indegrees.empty();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 854978,
                "title": "java-check-from-top-layer",
                "content": "real print need to print the bottom layer, then topper layer to override the lower layers.\\nto Solve the problem, we do the opposite, find the top layer which could form a rectangular, until we can not find any additonal candidate numbers.\\n\\n```\\nclass Solution {\\n    Set<Integer> vs = new HashSet<>(), pool = new HashSet<>();\\n    int m, n, l, r, u, b, g[][], dir[][] = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public boolean isPrintable(int[][] grid) {\\n        g = grid; m = g.length; n = g[0].length; \\n        for (int i = 0; i < m; i++) \\n            for (int j = 0; j < n; j++) \\n                pool.add(g[i][j]);\\n        while (pool.size() > 0) {\\n            Set<Integer> tr = new HashSet<>();\\n            for (int i : pool) {\\n                if (!vs.contains(i) && canPrint(i)) {\\n                    tr.add(i);\\n                    vs.add(i);\\n                }\\n            }\\n            if (tr.size() == 0) return false;\\n            for (int i : tr) pool.remove(i);\\n        }\\n        return true;\\n    }\\n    \\n    private boolean canPrint(int num) {\\n        l = m; r = 0; b = 0; u = n;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (g[i][j] == num) {\\n                    l = Math.min(l, i);\\n                    r = Math.max(r, i);\\n                    u = Math.min(u, j);\\n                    b = Math.max(b, j);\\n                }\\n        return isRect(num);\\n    }\\n    \\n    private boolean isRect(int num) {  // in the min rect, check if all element is valid, printed, or num;\\n        for (int i = l; i <= r; i++)\\n            for (int j = u; j <= b; j++)\\n                if (g[i][j] != num && !vs.contains(g[i][j])) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Set<Integer> vs = new HashSet<>(), pool = new HashSet<>();\\n    int m, n, l, r, u, b, g[][], dir[][] = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public boolean isPrintable(int[][] grid) {\\n        g = grid; m = g.length; n = g[0].length; \\n        for (int i = 0; i < m; i++) \\n            for (int j = 0; j < n; j++) \\n                pool.add(g[i][j]);\\n        while (pool.size() > 0) {\\n            Set<Integer> tr = new HashSet<>();\\n            for (int i : pool) {\\n                if (!vs.contains(i) && canPrint(i)) {\\n                    tr.add(i);\\n                    vs.add(i);\\n                }\\n            }\\n            if (tr.size() == 0) return false;\\n            for (int i : tr) pool.remove(i);\\n        }\\n        return true;\\n    }\\n    \\n    private boolean canPrint(int num) {\\n        l = m; r = 0; b = 0; u = n;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (g[i][j] == num) {\\n                    l = Math.min(l, i);\\n                    r = Math.max(r, i);\\n                    u = Math.min(u, j);\\n                    b = Math.max(b, j);\\n                }\\n        return isRect(num);\\n    }\\n    \\n    private boolean isRect(int num) {  // in the min rect, check if all element is valid, printed, or num;\\n        for (int i = l; i <= r; i++)\\n            for (int j = u; j <= b; j++)\\n                if (g[i][j] != num && !vs.contains(g[i][j])) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854172,
                "title": "python-3-same-solution-as-936-stamping-the-sequence",
                "content": "Keep removing all the colors which have valid rectangles and replace each of their elements  with -1.\\n\\nSimilar to [936. Stamping The Sequence](https://leetcode.com/problems/stamping-the-sequence/)\\n```\\nclass Solution:\\n    def isPrintable(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        m = len(grid[0])\\n        colors = set()\\n        maxx = {}\\n        maxy = {}\\n        minx = {}\\n        miny = {}\\n        for i in range(n):\\n            for j in range(m):\\n                c = grid[i][j]\\n                minx.setdefault(c, i)\\n                miny.setdefault(c, j)\\n                maxx.setdefault(c, i)\\n                maxy.setdefault(c, j)\\n                minx[c]=min(minx[c],i)\\n                maxx[c]=max(maxx[c],i)\\n                miny[c]=min(miny[c],j)\\n                maxy[c]=max(maxy[c],j)\\n                colors.add(c)\\n\\n        def isrect(c):\\n            for i in range(minx[c], maxx[c]+1):\\n                for j in range(miny[c],maxy[c]+1):\\n                    if not(grid[i][j]==c or grid[i][j]==-1):\\n                        return False\\n            return True\\n        \\n        def change(c):\\n            for i in range(minx[c], maxx[c]+1):\\n                for j in range(miny[c],maxy[c]+1):\\n                    grid[i][j]=-1\\n                    \\n        changed = True\\n        while changed:\\n            removethis = set()\\n            changed = False\\n            for c in colors:\\n                if isrect(c):\\n                    changed = True\\n                    removethis.add(c)\\n                    change(c)\\n            colors-=removethis\\n            \\n        if not colors:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        m = len(grid[0])\\n        colors = set()\\n        maxx = {}\\n        maxy = {}\\n        minx = {}\\n        miny = {}\\n        for i in range(n):\\n            for j in range(m):\\n                c = grid[i][j]\\n                minx.setdefault(c, i)\\n                miny.setdefault(c, j)\\n                maxx.setdefault(c, i)\\n                maxy.setdefault(c, j)\\n                minx[c]=min(minx[c],i)\\n                maxx[c]=max(maxx[c],i)\\n                miny[c]=min(miny[c],j)\\n                maxy[c]=max(maxy[c],j)\\n                colors.add(c)\\n\\n        def isrect(c):\\n            for i in range(minx[c], maxx[c]+1):\\n                for j in range(miny[c],maxy[c]+1):\\n                    if not(grid[i][j]==c or grid[i][j]==-1):\\n                        return False\\n            return True\\n        \\n        def change(c):\\n            for i in range(minx[c], maxx[c]+1):\\n                for j in range(miny[c],maxy[c]+1):\\n                    grid[i][j]=-1\\n                    \\n        changed = True\\n        while changed:\\n            removethis = set()\\n            changed = False\\n            for c in colors:\\n                if isrect(c):\\n                    changed = True\\n                    removethis.add(c)\\n                    change(c)\\n            colors-=removethis\\n            \\n        if not colors:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437076,
                "title": "easy-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach color has its dependency, return true if the graph of relationship is a directed acyclic graph. Otherwise return false.\\n# Complexity\\n- Time complexity:$$O(cmn)$$, where $$c$$ is the number of colors (nodes), and $$mn$$ is the number of grids (edges).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity$$O(mn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& g) {\\n        int n=g.size(),m=g[0].size();\\n        unordered_map<int,vector<int>> mp;\\n        unordered_set<int> cs;\\n        for(int i=0;i<n;i++) for(int j=0;j<m;j++){\\n            int c=g[i][j];\\n            cs.insert(c);\\n            if(c==0) continue;\\n            auto & v=mp[c];\\n            if(v.empty()){\\n                v={i,i,j,j};\\n            }else{\\n                v[0]=min(v[0],i);\\n                v[1]=max(v[1],i);\\n                v[2]=min(v[2],j);\\n                v[3]=max(v[3],j);\\n            }\\n        }\\n        unordered_map<int,unordered_set<int>> e;\\n        unordered_map<int,int> ind;\\n        for(auto& [c,v]:mp){\\n            int minx=v[0],maxx=v[1],miny=v[2],maxy=v[3];\\n            for(int i=minx;i<=maxx;i++) for(int j=miny;j<=maxy;j++){\\n                int d=g[i][j];\\n                if(d==0) return false;\\n                if(d==c or e[d].count(c)) continue;\\n                e[d].insert(c);\\n                ind[c]++;\\n            }\\n        }\\n        queue<int> q;\\n        for(auto c:cs){\\n            if(ind.count(c)) continue;\\n            q.push(c);\\n        }\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto v:e[u]){\\n                if(--ind[v]) continue;\\n                q.push(v);\\n            }\\n        }\\n        for(auto&[c,v]:ind){\\n            if(v) return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& g) {\\n        int n=g.size(),m=g[0].size();\\n        unordered_map<int,vector<int>> mp;\\n        unordered_set<int> cs;\\n        for(int i=0;i<n;i++) for(int j=0;j<m;j++){\\n            int c=g[i][j];\\n            cs.insert(c);\\n            if(c==0) continue;\\n            auto & v=mp[c];\\n            if(v.empty()){\\n                v={i,i,j,j};\\n            }else{\\n                v[0]=min(v[0],i);\\n                v[1]=max(v[1],i);\\n                v[2]=min(v[2],j);\\n                v[3]=max(v[3],j);\\n            }\\n        }\\n        unordered_map<int,unordered_set<int>> e;\\n        unordered_map<int,int> ind;\\n        for(auto& [c,v]:mp){\\n            int minx=v[0],maxx=v[1],miny=v[2],maxy=v[3];\\n            for(int i=minx;i<=maxx;i++) for(int j=miny;j<=maxy;j++){\\n                int d=g[i][j];\\n                if(d==0) return false;\\n                if(d==c or e[d].count(c)) continue;\\n                e[d].insert(c);\\n                ind[c]++;\\n            }\\n        }\\n        queue<int> q;\\n        for(auto c:cs){\\n            if(ind.count(c)) continue;\\n            q.push(c);\\n        }\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto v:e[u]){\\n                if(--ind[v]) continue;\\n                q.push(v);\\n            }\\n        }\\n        for(auto&[c,v]:ind){\\n            if(v) return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413210,
                "title": "solid-principles-100-memory-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is actually similar to whether or not we have edge collisions in polygon coloring for computer graphics. As such, we take the idea of a color bounding box as a polygon of that color, where we are trying to see if we can get to the back of the painting (aka 0) so we have painted all we need to. To get this as a visual application, simply assign each color to an rgb band. The original will show up, and as you go you can find the polygonal size of the rectangles showing and report on it. It\\'s really quite interesting in this fashion so I\\'ve left as much of it as possible in clear commented code for those interested in setting it up. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe want to track 3 things in our initial set up, so we establish fields for them at init. These are colors yet to reveal, colors not yet revealable, and color boundaries. The colors yet to reveal are those we have yet to process, and initially contains all colors. At each step, we will see if it is a top lying color (meaning we have it on the top of the stack of color boundaries) and if so, we can reveal it to zero and process the boundaries of it. This occurs if we have all values in bounding box of this color, or all values in the bounding box of this color are zero or some mixture of both. If we cannot yet do so, we place it into colors not yet revealable and then will check to see if any change occurred. If no change occurred we have directly conflicting edges and can not process accordingly, and should return False. On change though, we should update colors yet to reveal to the smaller form of those not yet revealable. \\n\\nTo do all this we need a few functions to help out. The first is our set up function, which gets passed the grid we are going to be working on. \\nWe set up our rows and cols of the grid, and get the max dimension as either the max of either of rows or cols or 60 based on problem description. This lets this extend beyond the scope of the problem space. \\n\\nOur color boundaries all start out with the box going from minimal of row and col for the color and maximal of the row and col for the color, found by looping over the grid. \\n\\nWhen done with set up we store the grid in its current form. We do this to not modify the original, and to allow us to report out state changes as we go if we so feel that it is appropriate to do so \\n\\nOur next function is our zero in range function. If a color has been revealed by either all of the cells in the range being that color, or all of the values in that range being that color or zero, we will set all of the cells in that boundary to zero with the zero in range function. It is passed a range of row start, row stop, col start and col stop to work within. \\n\\nWe also have our test color boundary function. This gets passed a color and pulls from our color boundaries the bounding box for that color. We increment the row stop and col stop by one so that python does go over that range in its for loops. We then loop over all cells in the bounding box, and if there is any cell that is not this color or zero, we return False. Otherwise, after processing all succesfully as either this color or zero, we zero this range and return True. \\n\\nTo process our colors finally, we do the following \\n- while our colors yet to reveal is not an empty set \\n    - set our colors not yet revealable to an empty set \\n    - for color in our colors yet to reveal \\n        - if our test of the color boundary is false, add it to not yet revealable. It will be processed otherwise. \\n    - if the size of our colors yet to reveal and our colors not yet revealable match, no change occurred in this loop, return False. \\n    - otherwise, set colors yet to reveal to colors not yet revealable\\nIf all colors processed, return True. \\n\\nTo check if printable, call set up with the target grid, then return the result of processing colors.    \\n\\n# Complexity\\n- Time complexity: O(C^2 * Rows * Cols)\\n    - We loop over colors in process colors \\n        - we build up a color list, which may have us reprocess colors. This makes it a double loop necessarily of the form I in range N -> J in range I, N, which is known to be N^2 at worst. \\n        - On each looping of this we loop over rows, nested with cols \\n        - This is O(C * C * Rows * Cols) where C is colors and rows and cols are the size of the grid    \\n\\n- Space complexity: O(Rows * Cols + Constant) \\n    - We store the grid \\n    - The color space boundary is technically a fixed size of color boundary factors, so can be treated as a constant  \\n\\n# Code\\n```\\nclass Solution:\\n    # initialize with colors that are about to be revealed and those we cannot reveal yet \\n    # initialize alongside this the bounding box of a given color area \\n    def __init__(self) : \\n        self.colors_yet_to_reveal = set()\\n        self.colors_not_yet_revealable = set()\\n        self.color_boundaries = []\\n\\n    def set_up(self, grid) : \\n        # set up according to grid \\n        self.rows = len(grid)\\n        self.cols = len(grid[0])\\n        # based on problem, should stop at dimension 60, but just in case of hooligans, use this \\n        self.max_dimension = max(self.rows, self.cols, 60)\\n        # color boundaries one greater than max dimension for off by one accounding \\n        self.color_boundaries = [[self.rows, self.cols, 0, 0] for _ in range(self.max_dimension + 1)]\\n        # loop in range \\n        for row in range(self.rows) : \\n            for col in range(self.cols) : \\n                # get the color \\n                color = grid[row][col]\\n                # add it if we don\\'t have it yet \\n                self.colors_yet_to_reveal.add(color)\\n                # set the boundary box as the min of the value there now and max of value \\n                # there now compared to the row and col current. This gets the bounding \\n                # box of the color areas like doing polygon bounding in graphical processing \\n                self.color_boundaries[color][0] = min(self.color_boundaries[color][0], row)\\n                self.color_boundaries[color][1] = min(self.color_boundaries[color][1], col)\\n                self.color_boundaries[color][2] = max(self.color_boundaries[color][2], row)\\n                self.color_boundaries[color][3] = max(self.color_boundaries[color][3], col)\\n        # mark the grid as is now for processing \\n        # this makes it so we don\\'t change the original data and can compare on a step by step if needed\\n        self.grid = grid\\n\\n    # set to zero all values in range for current grid \\n    def zero_in_range(self, r0, r1, c0, c1) : \\n        # loop in range \\n        # could include a print statement or export statement of some kind to see grid as it changes \\n        for row in range(r0, r1) : \\n            for col in range(c0, c1) : \\n                # set to default selected value, in this casce 0 \\n                self.grid[row][col] = 0\\n    \\n    # test color is contiguous in boundary \\n    def test_color_boundary(self, color) : \\n        # get stop and start for rows and cols \\n        r_start, c_start, r_stop, c_stop = self.color_boundaries[color]\\n        r_stop += 1 \\n        c_stop += 1 \\n        # loop in range \\n        for row in range(r_start, r_stop) : \\n            for col in range(c_start, c_stop) : \\n                # if it is not zero and not color, that\\'s not good \\n                # return False \\n                if self.grid[row][col] > 0 and self.grid[row][col] != color : \\n                    return False \\n        # otherwise, zero in range and return True \\n        self.zero_in_range(r_start, r_stop, c_start, c_stop)\\n        return True \\n\\n    # process colors in grid \\n    def process_colors(self) :\\n        # while we still have colors to reveal  \\n        while self.colors_yet_to_reveal : \\n            # reset your colors not yet revealable at start of each processing loop \\n            self.colors_not_yet_revealable = set()\\n            # reveal the current colors you have to reveal \\n            for color in self.colors_yet_to_reveal : \\n                # if the color is not yet ready to be revealed \\n                if self.test_color_boundary(color) == False : \\n                    # mark it as such and continue \\n                    self.colors_not_yet_revealable.add(color)\\n            # if we have the same amount to reveal as we started with, nothing changed \\n            # if nothing changed, it\\'s not possible, return False \\n            if len(self.colors_yet_to_reveal) == len(self.colors_not_yet_revealable) : \\n                return False \\n            # otherwise, update accordingly. On the loop where self.colors not yet revealable \\n            # is a set that had nothing added to it, we break \\n            self.colors_yet_to_reveal = self.colors_not_yet_revealable\\n        # return True on all colors revealed \\n        return True \\n\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        # set up \\n        self.set_up(targetGrid)\\n        # return results of processing \\n        return self.process_colors()\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # initialize with colors that are about to be revealed and those we cannot reveal yet \\n    # initialize alongside this the bounding box of a given color area \\n    def __init__(self) : \\n        self.colors_yet_to_reveal = set()\\n        self.colors_not_yet_revealable = set()\\n        self.color_boundaries = []\\n\\n    def set_up(self, grid) : \\n        # set up according to grid \\n        self.rows = len(grid)\\n        self.cols = len(grid[0])\\n        # based on problem, should stop at dimension 60, but just in case of hooligans, use this \\n        self.max_dimension = max(self.rows, self.cols, 60)\\n        # color boundaries one greater than max dimension for off by one accounding \\n        self.color_boundaries = [[self.rows, self.cols, 0, 0] for _ in range(self.max_dimension + 1)]\\n        # loop in range \\n        for row in range(self.rows) : \\n            for col in range(self.cols) : \\n                # get the color \\n                color = grid[row][col]\\n                # add it if we don\\'t have it yet \\n                self.colors_yet_to_reveal.add(color)\\n                # set the boundary box as the min of the value there now and max of value \\n                # there now compared to the row and col current. This gets the bounding \\n                # box of the color areas like doing polygon bounding in graphical processing \\n                self.color_boundaries[color][0] = min(self.color_boundaries[color][0], row)\\n                self.color_boundaries[color][1] = min(self.color_boundaries[color][1], col)\\n                self.color_boundaries[color][2] = max(self.color_boundaries[color][2], row)\\n                self.color_boundaries[color][3] = max(self.color_boundaries[color][3], col)\\n        # mark the grid as is now for processing \\n        # this makes it so we don\\'t change the original data and can compare on a step by step if needed\\n        self.grid = grid\\n\\n    # set to zero all values in range for current grid \\n    def zero_in_range(self, r0, r1, c0, c1) : \\n        # loop in range \\n        # could include a print statement or export statement of some kind to see grid as it changes \\n        for row in range(r0, r1) : \\n            for col in range(c0, c1) : \\n                # set to default selected value, in this casce 0 \\n                self.grid[row][col] = 0\\n    \\n    # test color is contiguous in boundary \\n    def test_color_boundary(self, color) : \\n        # get stop and start for rows and cols \\n        r_start, c_start, r_stop, c_stop = self.color_boundaries[color]\\n        r_stop += 1 \\n        c_stop += 1 \\n        # loop in range \\n        for row in range(r_start, r_stop) : \\n            for col in range(c_start, c_stop) : \\n                # if it is not zero and not color, that\\'s not good \\n                # return False \\n                if self.grid[row][col] > 0 and self.grid[row][col] != color : \\n                    return False \\n        # otherwise, zero in range and return True \\n        self.zero_in_range(r_start, r_stop, c_start, c_stop)\\n        return True \\n\\n    # process colors in grid \\n    def process_colors(self) :\\n        # while we still have colors to reveal  \\n        while self.colors_yet_to_reveal : \\n            # reset your colors not yet revealable at start of each processing loop \\n            self.colors_not_yet_revealable = set()\\n            # reveal the current colors you have to reveal \\n            for color in self.colors_yet_to_reveal : \\n                # if the color is not yet ready to be revealed \\n                if self.test_color_boundary(color) == False : \\n                    # mark it as such and continue \\n                    self.colors_not_yet_revealable.add(color)\\n            # if we have the same amount to reveal as we started with, nothing changed \\n            # if nothing changed, it\\'s not possible, return False \\n            if len(self.colors_yet_to_reveal) == len(self.colors_not_yet_revealable) : \\n                return False \\n            # otherwise, update accordingly. On the loop where self.colors not yet revealable \\n            # is a set that had nothing added to it, we break \\n            self.colors_yet_to_reveal = self.colors_not_yet_revealable\\n        # return True on all colors revealed \\n        return True \\n\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        # set up \\n        self.set_up(targetGrid)\\n        # return results of processing \\n        return self.process_colors()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386215,
                "title": "c-explained-simple-faster-and-space-efficient-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntopological sort can be applied keeping in mind that if a color is extended in a larger area so that must be printed first then the inner colors can be overpinted in it here DAG can be created from a smaller color value -> larger color value edges where first smaller color value must be printed before higher color values if there is an edge \\nThis can be done by creating coordinates top,right,bottom and left for every color till which it is expanded in the grid all the colors diffrent than this whose atleast one coordinate (t/r/b/l) lies inside this region must be printed first before curr color to be printed.\\nif there is any cycle in this dag then ans is no else true\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/5b6e5d8c-c9e7-43bd-9fdf-7a2317310787_1680778622.2249627.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool dfs(int col,int arr[][4],vector<vector<int>>& grid,int* visited){\\n    visited[col]=1;\\n    int t=arr[col][0];\\n    int r=arr[col][1];\\n    int b=arr[col][2];\\n    int l=arr[col][3];\\n    // cout<<col<<\" \"<<t<<\" \"<<b<<\" \"<<l<<\" \"<<r<<endl;\\n    for(int i=t;i<=b;i++){\\n        for(int j=l;j<=r;j++){\\n            int x=grid[i][j];\\n            if(x==col)  continue;\\n            if(visited[x]==1) return false;\\n            bool ans=1;\\n            if(visited[x]==0){\\n                ans=dfs(x,arr,grid,visited);\\n            }\\n            if(ans==0) return 0;\\n        }\\n    }\\n    visited[col]=2;\\n    return true;\\n}\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int arr[61][4]; // node->a particular color-> 4 cordinates top right bottom left till which that color is expanded in grid\\n        int visited[61];\\n        memset(visited,-1,sizeof(visited));  \\n        // -1 node not present in grid \\n        // 0 node is present but not yet visited\\n        // 1 node is currently being visited\\n        // 2 node has already been visited\\n        // here node is corresponding to ith color\\n        // and visited is corresponding to being printed\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int col=grid[i][j]; // color\\n                if(visited[col]==-1){   // color seen for the first time\\n                    visited[col]=0;\\n                    arr[col][0]=i;\\n                    arr[col][1]=j;\\n                    arr[col][2]=i;\\n                    arr[col][3]=j;\\n                }\\n                else{   //already seen must have some coordinates\\n                    arr[col][0]=min(i,arr[col][0]);\\n                    arr[col][1]=max(j,arr[col][1]);\\n                    arr[col][2]=max(i,arr[col][2]);\\n                    arr[col][3]=min(j,arr[col][3]);\\n                }\\n            }\\n        }\\n        bool ans=1;\\n        for(int i=0;i<61;i++){\\n            if(visited[i]==-1) continue;\\n            if(visited[i]==0){\\n                ans=dfs(i,arr,grid,visited);\\n                if(ans==0) return false;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool dfs(int col,int arr[][4],vector<vector<int>>& grid,int* visited){\\n    visited[col]=1;\\n    int t=arr[col][0];\\n    int r=arr[col][1];\\n    int b=arr[col][2];\\n    int l=arr[col][3];\\n    // cout<<col<<\" \"<<t<<\" \"<<b<<\" \"<<l<<\" \"<<r<<endl;\\n    for(int i=t;i<=b;i++){\\n        for(int j=l;j<=r;j++){\\n            int x=grid[i][j];\\n            if(x==col)  continue;\\n            if(visited[x]==1) return false;\\n            bool ans=1;\\n            if(visited[x]==0){\\n                ans=dfs(x,arr,grid,visited);\\n            }\\n            if(ans==0) return 0;\\n        }\\n    }\\n    visited[col]=2;\\n    return true;\\n}\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int arr[61][4]; // node->a particular color-> 4 cordinates top right bottom left till which that color is expanded in grid\\n        int visited[61];\\n        memset(visited,-1,sizeof(visited));  \\n        // -1 node not present in grid \\n        // 0 node is present but not yet visited\\n        // 1 node is currently being visited\\n        // 2 node has already been visited\\n        // here node is corresponding to ith color\\n        // and visited is corresponding to being printed\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int col=grid[i][j]; // color\\n                if(visited[col]==-1){   // color seen for the first time\\n                    visited[col]=0;\\n                    arr[col][0]=i;\\n                    arr[col][1]=j;\\n                    arr[col][2]=i;\\n                    arr[col][3]=j;\\n                }\\n                else{   //already seen must have some coordinates\\n                    arr[col][0]=min(i,arr[col][0]);\\n                    arr[col][1]=max(j,arr[col][1]);\\n                    arr[col][2]=max(i,arr[col][2]);\\n                    arr[col][3]=min(j,arr[col][3]);\\n                }\\n            }\\n        }\\n        bool ans=1;\\n        for(int i=0;i<61;i++){\\n            if(visited[i]==-1) continue;\\n            if(visited[i]==0){\\n                ans=dfs(i,arr,grid,visited);\\n                if(ans==0) return false;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2171580,
                "title": "python-solution-by-building-a-graph-and-topological-sort",
                "content": "```\\nfrom collections import deque\\nclass Solution(object):\\n    def isPrintable(self, targetGrid):\\n        \"\"\"\\n        :type targetGrid: List[List[int]]\\n        :rtype: bool\\n        idea: using targetGrid to construct a color region graph\\n        graph nodes are connected by overlapping \\n        nodeA --> nodeB if rangeA covering **pointsB**\\n        Then if the graph can be topological sorted\\n        the printer problem can be solved\\n        \"\"\"\\n        color_set = set()\\n        color_graph = dict()\\n        color_range = dict()\\n        indegrees = dict()\\n        Row, Col = len(targetGrid), len(targetGrid[0])\\n        for i in range(Row):\\n            for j in range(Col):\\n                if targetGrid[i][j] not in color_set:\\n                    color_set.add(targetGrid[i][j])\\n                    color_range[targetGrid[i][j]] = [i, j, i, j] # upper, left, bottom, right\\n                    indegrees[targetGrid[i][j]] = 0\\n                else:\\n                    color_range[targetGrid[i][j]][0] = min(i, color_range[targetGrid[i][j]][0])\\n                    color_range[targetGrid[i][j]][1] = min(j, color_range[targetGrid[i][j]][1])\\n                    color_range[targetGrid[i][j]][2] = max(i, color_range[targetGrid[i][j]][2])\\n                    color_range[targetGrid[i][j]][3] = max(j, color_range[targetGrid[i][j]][3])\\n        # build graph according to color_range coverage (max envelope)\\n        for c in color_set:\\n            color_graph[c] = set()\\n            # connect node c to other nodes\\n            # range of c coverges **points** of other nodes\\n            for i in range(color_range[c][0], color_range[c][2]+1):\\n                for j in range(color_range[c][1], color_range[c][3]+1):\\n                    cur = targetGrid[i][j]\\n                    if cur != c and cur not in color_graph[c]:\\n                        color_graph[c].add(cur)\\n                        # indegrees[c] += 1\\n        # compute indegrees\\n        for c in color_set:\\n            for n in color_graph[c]:\\n                indegrees[n] += 1\\n        # now the graph is built, then can use topological sort \\n        # print(color_graph)\\n        # print(indegrees)\\n        queue = deque()\\n        for c in color_set:\\n            if indegrees[c] == 0:\\n                queue.append(c)\\n        turns = 0\\n        while len(queue)>0:\\n            c = queue.popleft()\\n            turns += 1\\n            for n in color_graph[c]:\\n                indegrees[n] -= 1\\n                if indegrees[n]==0:\\n                    queue.append(n)\\n        # print(turns, len(color_set))         \\n        return turns==len(color_set)\\n```",
                "solutionTags": [
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution(object):\\n    def isPrintable(self, targetGrid):\\n        \"\"\"\\n        :type targetGrid: List[List[int]]\\n        :rtype: bool\\n        idea: using targetGrid to construct a color region graph\\n        graph nodes are connected by overlapping \\n        nodeA --> nodeB if rangeA covering **pointsB**\\n        Then if the graph can be topological sorted\\n        the printer problem can be solved\\n        \"\"\"\\n        color_set = set()\\n        color_graph = dict()\\n        color_range = dict()\\n        indegrees = dict()\\n        Row, Col = len(targetGrid), len(targetGrid[0])\\n        for i in range(Row):\\n            for j in range(Col):\\n                if targetGrid[i][j] not in color_set:\\n                    color_set.add(targetGrid[i][j])\\n                    color_range[targetGrid[i][j]] = [i, j, i, j] # upper, left, bottom, right\\n                    indegrees[targetGrid[i][j]] = 0\\n                else:\\n                    color_range[targetGrid[i][j]][0] = min(i, color_range[targetGrid[i][j]][0])\\n                    color_range[targetGrid[i][j]][1] = min(j, color_range[targetGrid[i][j]][1])\\n                    color_range[targetGrid[i][j]][2] = max(i, color_range[targetGrid[i][j]][2])\\n                    color_range[targetGrid[i][j]][3] = max(j, color_range[targetGrid[i][j]][3])\\n        # build graph according to color_range coverage (max envelope)\\n        for c in color_set:\\n            color_graph[c] = set()\\n            # connect node c to other nodes\\n            # range of c coverges **points** of other nodes\\n            for i in range(color_range[c][0], color_range[c][2]+1):\\n                for j in range(color_range[c][1], color_range[c][3]+1):\\n                    cur = targetGrid[i][j]\\n                    if cur != c and cur not in color_graph[c]:\\n                        color_graph[c].add(cur)\\n                        # indegrees[c] += 1\\n        # compute indegrees\\n        for c in color_set:\\n            for n in color_graph[c]:\\n                indegrees[n] += 1\\n        # now the graph is built, then can use topological sort \\n        # print(color_graph)\\n        # print(indegrees)\\n        queue = deque()\\n        for c in color_set:\\n            if indegrees[c] == 0:\\n                queue.append(c)\\n        turns = 0\\n        while len(queue)>0:\\n            c = queue.popleft()\\n            turns += 1\\n            for n in color_graph[c]:\\n                indegrees[n] -= 1\\n                if indegrees[n]==0:\\n                    queue.append(n)\\n        # print(turns, len(color_set))         \\n        return turns==len(color_set)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977386,
                "title": "easy-to-understand-c-17-build-the-graph-then-topological-sort",
                "content": "### [Easy-to-understand C++17] Build the graph, then Topological Sort\\nIdea:\\nwe can solve this problem in two steps.\\n1. Build a graph to represent the relationships between colors. \\n    *  it\\'s a bit tricky to see how colors depends on each other. \\n\\there an edge from U to V means color U appears in color V\\'s rectangle realm, thus U should be removed earlier than V. \\n\\t* we use an Object-Oriented way to do the statistics for a color. please see the code below.\\n\\t\\n2. Run a standard topological sort algorithm on the graph. \\n    * If the graph is a DAG, then all colors can be removed.\\n\\n```\\nclass Solution {\\n    /// \\\\brief statistics for a color\\n    struct ColorStat{\\n        int _color = 0;\\n        int _count = 0;\\n        int _top = -1;\\n        int _bottom = -1;\\n        int _left = -1;\\n        int _right = -1;\\n        \\n        /// \\\\brief record the color\\'s presence at a cell\\n        void record(int color, int row, int col) {\\n            ++_count;\\n            if (_count == 1) {\\n                _color = color;\\n                _top = row; \\n                _bottom = row;\\n                _left = col;\\n                _right = col;\\n                return;\\n            }\\n            _top = min(_top, row);\\n            _bottom = max(_bottom, row);\\n            _left = min(_left, col);\\n            _right = max(_right, col);\\n        }\\n        \\n        /// \\\\brief check whether the color\\'s rectangle contains only the color itself\\n        bool isTight() const {\\n            return (_bottom - _top + 1) * (_right - _left + 1) == _count;\\n        }\\n        \\n        /// \\\\brief Get the other colors that appear in this color\\'s rectangle realm.\\n        unordered_set<int> otherColorsInMyRealm(const vector<vector<int>>& grid) const {\\n            unordered_set<int> otherColors;\\n            if (isTight()) {\\n                return {};\\n            }\\n            for (int row = _top; row <= _bottom; ++row) {\\n                for (int col = _left; col <= _right; ++col) {\\n                    if (grid[row][col] != _color) {\\n                        otherColors.insert(grid[row][col]);\\n                    }\\n                }\\n            }\\n            return otherColors;\\n        }\\n    };\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        const int nrow = targetGrid.size(), ncol = targetGrid[0].size();\\n        \\n        // map from color to its stats.\\n        // because there can be gaps between color IDs, we\\'d better use a map here.\\n        unordered_map<int, ColorStat> colorToStats;\\n        int maxColor = 0;\\n        for (int r = 0; r < nrow; ++r) {\\n            for (int c = 0; c < ncol; ++c) {\\n                int color = targetGrid[r][c];\\n                colorToStats[color].record(color, r, c);\\n                maxColor = max(maxColor, color);\\n            }\\n        }\\n        // Build the graph.\\n        // adjacency list for the graph.\\n        // an edge from U to V means color U appears in color V\\'s rectangle realm.\\n        vector<vector<int>> adj(maxColor + 1, vector<int>());\\n        vector<int> inDegrees(maxColor + 1);\\n        for (const auto& [color, stats] : colorToStats) {\\n            auto otherColors = stats.otherColorsInMyRealm(targetGrid);\\n            // edge otherColor --> color\\n            inDegrees[color] = otherColors.size();\\n            for (int other : otherColors) {\\n                adj[other].emplace_back(color); \\n            }\\n        }\\n        \\n        // topological sort.\\n        queue<int> q;\\n        int doneColors = 0;\\n        const int occurredColors = colorToStats.size();\\n        // init: enqueue the color nodes with zero in-degrees.\\n        for (int c = 1; c <= maxColor; ++c) {\\n            if (inDegrees[c] == 0 && colorToStats.count(c)) {\\n                q.emplace(c);\\n            }\\n        }\\n        while (!q.empty()) {\\n            int currColor = q.front(); \\n            q.pop();\\n            ++doneColors;\\n            // free up/unleash other colors which depends on currColor\\n            for (int other : adj[currColor]) {\\n                // edge is from currColor --> other\\n                if (--inDegrees[other] == 0) {\\n                    q.emplace(other);\\n                }\\n            }\\n        }\\n        // if there are circular dependencies in the Graph,\\n        // those color nodes involved in the circular deps \\n        // cannot be resolved/printed. In that case, \\n        // doneColors will be smaller. \\n        return doneColors == occurredColors;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    /// \\\\brief statistics for a color\\n    struct ColorStat{\\n        int _color = 0;\\n        int _count = 0;\\n        int _top = -1;\\n        int _bottom = -1;\\n        int _left = -1;\\n        int _right = -1;\\n        \\n        /// \\\\brief record the color\\'s presence at a cell\\n        void record(int color, int row, int col) {\\n            ++_count;\\n            if (_count == 1) {\\n                _color = color;\\n                _top = row; \\n                _bottom = row;\\n                _left = col;\\n                _right = col;\\n                return;\\n            }\\n            _top = min(_top, row);\\n            _bottom = max(_bottom, row);\\n            _left = min(_left, col);\\n            _right = max(_right, col);\\n        }\\n        \\n        /// \\\\brief check whether the color\\'s rectangle contains only the color itself\\n        bool isTight() const {\\n            return (_bottom - _top + 1) * (_right - _left + 1) == _count;\\n        }\\n        \\n        /// \\\\brief Get the other colors that appear in this color\\'s rectangle realm.\\n        unordered_set<int> otherColorsInMyRealm(const vector<vector<int>>& grid) const {\\n            unordered_set<int> otherColors;\\n            if (isTight()) {\\n                return {};\\n            }\\n            for (int row = _top; row <= _bottom; ++row) {\\n                for (int col = _left; col <= _right; ++col) {\\n                    if (grid[row][col] != _color) {\\n                        otherColors.insert(grid[row][col]);\\n                    }\\n                }\\n            }\\n            return otherColors;\\n        }\\n    };\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        const int nrow = targetGrid.size(), ncol = targetGrid[0].size();\\n        \\n        // map from color to its stats.\\n        // because there can be gaps between color IDs, we\\'d better use a map here.\\n        unordered_map<int, ColorStat> colorToStats;\\n        int maxColor = 0;\\n        for (int r = 0; r < nrow; ++r) {\\n            for (int c = 0; c < ncol; ++c) {\\n                int color = targetGrid[r][c];\\n                colorToStats[color].record(color, r, c);\\n                maxColor = max(maxColor, color);\\n            }\\n        }\\n        // Build the graph.\\n        // adjacency list for the graph.\\n        // an edge from U to V means color U appears in color V\\'s rectangle realm.\\n        vector<vector<int>> adj(maxColor + 1, vector<int>());\\n        vector<int> inDegrees(maxColor + 1);\\n        for (const auto& [color, stats] : colorToStats) {\\n            auto otherColors = stats.otherColorsInMyRealm(targetGrid);\\n            // edge otherColor --> color\\n            inDegrees[color] = otherColors.size();\\n            for (int other : otherColors) {\\n                adj[other].emplace_back(color); \\n            }\\n        }\\n        \\n        // topological sort.\\n        queue<int> q;\\n        int doneColors = 0;\\n        const int occurredColors = colorToStats.size();\\n        // init: enqueue the color nodes with zero in-degrees.\\n        for (int c = 1; c <= maxColor; ++c) {\\n            if (inDegrees[c] == 0 && colorToStats.count(c)) {\\n                q.emplace(c);\\n            }\\n        }\\n        while (!q.empty()) {\\n            int currColor = q.front(); \\n            q.pop();\\n            ++doneColors;\\n            // free up/unleash other colors which depends on currColor\\n            for (int other : adj[currColor]) {\\n                // edge is from currColor --> other\\n                if (--inDegrees[other] == 0) {\\n                    q.emplace(other);\\n                }\\n            }\\n        }\\n        // if there are circular dependencies in the Graph,\\n        // those color nodes involved in the circular deps \\n        // cannot be resolved/printed. In that case, \\n        // doneColors will be smaller. \\n        return doneColors == occurredColors;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560935,
                "title": "python-with-explanations",
                "content": "First consider all cells with some color (value) `v`. From them we can reconstruct supposed boundary of the ractangle of value `v`. Now suppose some two rectangles `rec1, rec2` (with their reconstructed boundary) intersect, if there is color of the first rectangle in the intersection, that means rectangle first must be printed after rectangle second. Thus, we can connect with the directed edge `rec2` to `rec1` meaning `rec2` is printed first. That\\'s how we create our directed graph, and we need to check for it being acyclic which is done by dfs. After acyclicity just print rectangles from top of the graph (all roots) to bottom (leafs). Let\\'s show why this printing is proper below.\\n\\nSo why does acyclicity of the graph implies that there exist proper printing. Consider any cell and say its value is v. Then consider all rectangles (with reconstructed boundary) that cover that cell with value v and pick any, say rec_c. Obviously rectangle corresponding to color v also covers that cell, call it rec_v. So rec_c and rec_v intersect, and since there is color v in the intersection that means there is a link from rec_c to rec_v and rec_v will be printed later than any rec_c, thus initial cell will be eventually colored by color v. Proof is complete.\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def isPrintable(self, targetGrid):\\n        n = len(targetGrid)\\n        m = len(targetGrid[0])\\n        di_min, di_max, dj_min, dj_max = {}, {}, {}, {}\\n        vals = set()\\n        val2set = defaultdict(set)\\n        for i in range(n):\\n            for j in range(m):\\n                val = targetGrid[i][j]\\n                val2set[val].add((i, j))\\n                vals.add(val)\\n                di_min[val] = min(di_min.get(val, 10 ** 9), i)\\n                di_max[val] = max(di_max.get(val, 0), i)\\n                dj_min[val] = min(dj_min.get(val, 10 ** 9), j)\\n                dj_max[val] = max(dj_max.get(val, 0), j)\\n\\n        def inside(cell, v):\\n            i, j = cell\\n            return di_min[v] <= i <= di_max[v] and dj_min[v] <= j <= dj_max[v]\\n\\n        gr = defaultdict(list)\\n        for v1 in vals:\\n            for v2 in vals:\\n                if v1 == v2: continue\\n                for c1 in val2set[v1]:\\n                    if inside(c1, v2):\\n                        gr[v2].append(v1)\\n                for c2 in val2set[v2]:\\n                    if inside(c2, v1):\\n                        gr[v1].append(v2)\\n\\n        attended = set()\\n        path = set()\\n        def dfs(node):\\n            attended.add(node)\\n            path.add(node)\\n            boolean = True\\n            for to in gr[node]:\\n                if to in path:\\n                    boolean = False\\n                elif to not in attended:\\n                    boolean &= dfs(to)\\n                if not boolean: break\\n\\n            path.remove(node)\\n            return boolean\\n\\n        for v in vals:\\n            if v not in attended and not dfs(v):\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def isPrintable(self, targetGrid):\\n        n = len(targetGrid)\\n        m = len(targetGrid[0])\\n        di_min, di_max, dj_min, dj_max = {}, {}, {}, {}\\n        vals = set()\\n        val2set = defaultdict(set)\\n        for i in range(n):\\n            for j in range(m):\\n                val = targetGrid[i][j]\\n                val2set[val].add((i, j))\\n                vals.add(val)\\n                di_min[val] = min(di_min.get(val, 10 ** 9), i)\\n                di_max[val] = max(di_max.get(val, 0), i)\\n                dj_min[val] = min(dj_min.get(val, 10 ** 9), j)\\n                dj_max[val] = max(dj_max.get(val, 0), j)\\n\\n        def inside(cell, v):\\n            i, j = cell\\n            return di_min[v] <= i <= di_max[v] and dj_min[v] <= j <= dj_max[v]\\n\\n        gr = defaultdict(list)\\n        for v1 in vals:\\n            for v2 in vals:\\n                if v1 == v2: continue\\n                for c1 in val2set[v1]:\\n                    if inside(c1, v2):\\n                        gr[v2].append(v1)\\n                for c2 in val2set[v2]:\\n                    if inside(c2, v1):\\n                        gr[v1].append(v2)\\n\\n        attended = set()\\n        path = set()\\n        def dfs(node):\\n            attended.add(node)\\n            path.add(node)\\n            boolean = True\\n            for to in gr[node]:\\n                if to in path:\\n                    boolean = False\\n                elif to not in attended:\\n                    boolean &= dfs(to)\\n                if not boolean: break\\n\\n            path.remove(node)\\n            return boolean\\n\\n        for v in vals:\\n            if v not in attended and not dfs(v):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321075,
                "title": "java-dfs-with-explanation-clean-code",
                "content": "The idea is to find each color\\'s range with 2 points (min_i, min_j) and (max_i, max_j).\\n\\nThen, DFS each color in its range, if find new color that already printed, then return false, if find new color has not been printed, then DFS the new color in its range. During this, we also skip the points that already be visited, this is important as we rely on the printed color to detect false case, so we do not want to visit the same point multiple times.\\n\\n```\\nclass Solution {\\n    \\n    public boolean isPrintable(int[][] targetGrid) {\\n        int[][] colorBound = new int[61][4];\\n        Set<Integer> colors = new HashSet<>();\\n        \\n        // prepare colorBound with Max and Min integer for later compare\\n        for (int i = 0; i < colorBound.length; i ++) {\\n            for (int j = 0; j < colorBound[0].length; j ++) {\\n                if (j == 0 || j == 1) colorBound[i][j] = Integer.MAX_VALUE;\\n                else colorBound[i][j] = Integer.MIN_VALUE;\\n            }\\n        }\\n            \\n        // find the color range for each color\\n        // each color i has a colorBound[i] with {min_i, min_j, max_i, max_j}\\n        for (int i = 0; i < targetGrid.length; i ++) {\\n            for (int j = 0; j < targetGrid[0].length; j ++) {\\n                colorBound[targetGrid[i][j]][0] = Math.min(colorBound[targetGrid[i][j]][0], i);\\n                colorBound[targetGrid[i][j]][1] = Math.min(colorBound[targetGrid[i][j]][1], j);\\n                colorBound[targetGrid[i][j]][2] = Math.max(colorBound[targetGrid[i][j]][2], i);\\n                colorBound[targetGrid[i][j]][3] = Math.max(colorBound[targetGrid[i][j]][3], j);\\n                colors.add(targetGrid[i][j]);\\n            }\\n        }\\n        \\n        boolean[] printed = new boolean[61];\\n        boolean[][] visited = new boolean[targetGrid.length][targetGrid[0].length];\\n        \\n        //DFS all the colors, skip the color already be printed\\n        for (Integer color : colors) {\\n            if (printed[color]) continue;\\n            if (!dfs(targetGrid, printed, colorBound, visited, color)) return false;;\\n        }\\n        \\n        // if all color has been printed, then return true\\n        return true;\\n    }\\n    \\n    private boolean dfs(int[][] targetGrid, boolean[] printed, int[][] colorBound, boolean[][] visited, int color) {\\n        printed[color] = true;\\n        for (int i = colorBound[color][0]; i <= colorBound[color][2]; i ++) {\\n            for (int j = colorBound[color][1]; j <= colorBound[color][3]; j ++) {\\n                // if i, j is already visited, skip\\n                if (visited[i][j]) continue;\\n                // if we find a different color, then check if the color is already printed, if so, return false\\n                // otherwise, dfs the range of the new color\\n                if (targetGrid[i][j] != color) {\\n                    if (printed[targetGrid[i][j]]) return false;\\n                    if (!dfs(targetGrid, printed, colorBound, visited, targetGrid[i][j])) return false;\\n                }\\n                visited[i][j] = true;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public boolean isPrintable(int[][] targetGrid) {\\n        int[][] colorBound = new int[61][4];\\n        Set<Integer> colors = new HashSet<>();\\n        \\n        // prepare colorBound with Max and Min integer for later compare\\n        for (int i = 0; i < colorBound.length; i ++) {\\n            for (int j = 0; j < colorBound[0].length; j ++) {\\n                if (j == 0 || j == 1) colorBound[i][j] = Integer.MAX_VALUE;\\n                else colorBound[i][j] = Integer.MIN_VALUE;\\n            }\\n        }\\n            \\n        // find the color range for each color\\n        // each color i has a colorBound[i] with {min_i, min_j, max_i, max_j}\\n        for (int i = 0; i < targetGrid.length; i ++) {\\n            for (int j = 0; j < targetGrid[0].length; j ++) {\\n                colorBound[targetGrid[i][j]][0] = Math.min(colorBound[targetGrid[i][j]][0], i);\\n                colorBound[targetGrid[i][j]][1] = Math.min(colorBound[targetGrid[i][j]][1], j);\\n                colorBound[targetGrid[i][j]][2] = Math.max(colorBound[targetGrid[i][j]][2], i);\\n                colorBound[targetGrid[i][j]][3] = Math.max(colorBound[targetGrid[i][j]][3], j);\\n                colors.add(targetGrid[i][j]);\\n            }\\n        }\\n        \\n        boolean[] printed = new boolean[61];\\n        boolean[][] visited = new boolean[targetGrid.length][targetGrid[0].length];\\n        \\n        //DFS all the colors, skip the color already be printed\\n        for (Integer color : colors) {\\n            if (printed[color]) continue;\\n            if (!dfs(targetGrid, printed, colorBound, visited, color)) return false;;\\n        }\\n        \\n        // if all color has been printed, then return true\\n        return true;\\n    }\\n    \\n    private boolean dfs(int[][] targetGrid, boolean[] printed, int[][] colorBound, boolean[][] visited, int color) {\\n        printed[color] = true;\\n        for (int i = colorBound[color][0]; i <= colorBound[color][2]; i ++) {\\n            for (int j = colorBound[color][1]; j <= colorBound[color][3]; j ++) {\\n                // if i, j is already visited, skip\\n                if (visited[i][j]) continue;\\n                // if we find a different color, then check if the color is already printed, if so, return false\\n                // otherwise, dfs the range of the new color\\n                if (targetGrid[i][j] != color) {\\n                    if (printed[targetGrid[i][j]]) return false;\\n                    if (!dfs(targetGrid, printed, colorBound, visited, targetGrid[i][j])) return false;\\n                }\\n                visited[i][j] = true;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888143,
                "title": "straight-solution-brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n\\n\\n    map<int, vector<int> > getMinMax(vector<vector<int>>& targetGrid) {\\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();    \\n                \\n        int i, j;\\n        \\n        map<int, vector<int> >  M;\\n        \\n        for(i = 0; i < n; ++i) {\\n            for(j = 0; j < m; ++j) {\\n                int x = targetGrid[i][j];\\n                if(M.count(x) == 0) {\\n                   M[x] = {INT_MAX, INT_MAX, -1, -1};\\n                }\\n                M[x][0] = min(i, M[x][0]);\\n                M[x][1] = min(j, M[x][1]);\\n                M[x][2] = max(i, M[x][2]);\\n                M[x][3] = max(j, M[x][3]);\\n            }\\n        }                \\n        return M;   \\n    }\\n    \\n    bool checkAllSame(int r1, int c1, int r2, int c2, vector<vector<int>>& targetGrid, int l){\\n        int count = 0;\\n        int color = -1;\\n        for(int i=r1; i<=r2; i++){\\n            for(int j=c1; j<=c2; j++){\\n                if(targetGrid[i][j] != -1 && targetGrid[i][j] != l){\\n                   return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void replace(int r1, int c1, int r2, int c2, vector<vector<int>>& targetGrid){\\n       for(int i = r1; i<=r2; i++){\\n         for(int j = c1; j<=c2; j++){\\n            targetGrid[i][j] = -1 ;\\n         }\\n       }\\n    }\\n    \\n    bool checkAll(vector<vector<int>>& targetGrid){\\n         int n = targetGrid.size();\\n         int m = targetGrid[0].size();\\n         for(int i=0; i<n; i++){\\n             for(int j=0; j<m; j++){\\n                 if(targetGrid[i][j]!=-1){\\n                     return false;\\n                 }\\n             }\\n         }\\n        return true;\\n    }\\n    \\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        \\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        \\n        map<int, vector<int> > M = getMinMax(targetGrid);\\n        while(1) {\\n            int f = 0;\\n            vector<int> proc;\\n            for(auto it : M) {\\n                int l = it.first;\\n                if(checkAllSame(it.second[0], it.second[1], it.second[2], it.second[3], targetGrid, l)) { \\n                    f = 1;\\n                    proc.push_back(l);\\n                    replace(it.second[0], it.second[1], it.second[2], it.second[3], targetGrid);\\n                }\\n            \\n            }\\n            for(int z : proc) {\\n                M.erase(M.find(z));\\n            }\\n            if(f == 0) {\\n               break;\\n            }\\n        }\\n        return checkAll(targetGrid);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    map<int, vector<int> > getMinMax(vector<vector<int>>& targetGrid) {\\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();    \\n                \\n        int i, j;\\n        \\n        map<int, vector<int> >  M;\\n        \\n        for(i = 0; i < n; ++i) {\\n            for(j = 0; j < m; ++j) {\\n                int x = targetGrid[i][j];\\n                if(M.count(x) == 0) {\\n                   M[x] = {INT_MAX, INT_MAX, -1, -1};\\n                }\\n                M[x][0] = min(i, M[x][0]);\\n                M[x][1] = min(j, M[x][1]);\\n                M[x][2] = max(i, M[x][2]);\\n                M[x][3] = max(j, M[x][3]);\\n            }\\n        }                \\n        return M;   \\n    }\\n    \\n    bool checkAllSame(int r1, int c1, int r2, int c2, vector<vector<int>>& targetGrid, int l){\\n        int count = 0;\\n        int color = -1;\\n        for(int i=r1; i<=r2; i++){\\n            for(int j=c1; j<=c2; j++){\\n                if(targetGrid[i][j] != -1 && targetGrid[i][j] != l){\\n                   return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void replace(int r1, int c1, int r2, int c2, vector<vector<int>>& targetGrid){\\n       for(int i = r1; i<=r2; i++){\\n         for(int j = c1; j<=c2; j++){\\n            targetGrid[i][j] = -1 ;\\n         }\\n       }\\n    }\\n    \\n    bool checkAll(vector<vector<int>>& targetGrid){\\n         int n = targetGrid.size();\\n         int m = targetGrid[0].size();\\n         for(int i=0; i<n; i++){\\n             for(int j=0; j<m; j++){\\n                 if(targetGrid[i][j]!=-1){\\n                     return false;\\n                 }\\n             }\\n         }\\n        return true;\\n    }\\n    \\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        \\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        \\n        map<int, vector<int> > M = getMinMax(targetGrid);\\n        while(1) {\\n            int f = 0;\\n            vector<int> proc;\\n            for(auto it : M) {\\n                int l = it.first;\\n                if(checkAllSame(it.second[0], it.second[1], it.second[2], it.second[3], targetGrid, l)) { \\n                    f = 1;\\n                    proc.push_back(l);\\n                    replace(it.second[0], it.second[1], it.second[2], it.second[3], targetGrid);\\n                }\\n            \\n            }\\n            for(int z : proc) {\\n                M.erase(M.find(z));\\n            }\\n            if(f == 0) {\\n               break;\\n            }\\n        }\\n        return checkAll(targetGrid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856998,
                "title": "c-o-mnc-reverse-printing-by-removing-colours",
                "content": "```csharp\\npublic class Solution \\n{\\n    public bool IsPrintable(int[][] targetGrid)\\n    {\\n        int[,] grid = new int[targetGrid.Length, targetGrid[0].Length];\\n        (int minRow, int minColumn, int maxRow, int maxColumn)[] colorBounds = new (int, int, int, int)[61];\\n        for (int i = 0; i < colorBounds.Length; i++)\\n        {\\n            colorBounds[i] = (61, 61, 0, 0);\\n        }\\n        HashSet<int> colors = new HashSet<int>();\\n\\n        for (int i = 0; i < targetGrid.Length; i++)\\n        {\\n            for (int j = 0; j < targetGrid[i].Length; j++)\\n            {   \\n                int color = targetGrid[i][j];\\n                grid[i, j] = color;\\n                colors.Add(color);\\n\\n                colorBounds[color].minRow = Math.Min(colorBounds[color].minRow, i);                    \\n                colorBounds[color].minColumn = Math.Min(colorBounds[color].minColumn, j);\\n                colorBounds[color].maxRow = Math.Max(colorBounds[color].maxRow, i);\\n                colorBounds[color].maxColumn = Math.Max(colorBounds[color].maxColumn, j);\\n            }\\n        }\\n\\n\\n        while (colors.Count > 0)\\n        {\\n            HashSet<int> newColors = new HashSet<int>();\\n            foreach (int color in colors)\\n            {\\n                if (!CanRemoveColor(color, colorBounds[color], grid))\\n                {\\n                    newColors.Add(color);\\n                }\\n            }\\n\\n            // Not able to remove any color\\n            if (newColors.Count == colors.Count)\\n            {\\n                return false;\\n            }\\n\\n            colors = newColors;\\n        }\\n\\n        return true;\\n    }\\n\\n    private bool CanRemoveColor(int color, (int minRow, int minColumn, int maxRow, int maxColumn) colorBound, int[,] grid)\\n    {\\n        for (int i = colorBound.minRow; i <= colorBound.maxRow; i++)\\n        {\\n            for (int j = colorBound.minColumn; j <= colorBound.maxColumn; j++)\\n            {\\n                if (grid[i, j] > 0 && grid[i, j] != color)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for (int i = colorBound.minRow; i <= colorBound.maxRow; i++)\\n        {\\n            for (int j = colorBound.minColumn; j <= colorBound.maxColumn; j++)\\n            {\\n                grid[i, j] = 0;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution \\n{\\n    public bool IsPrintable(int[][] targetGrid)\\n    {\\n        int[,] grid = new int[targetGrid.Length, targetGrid[0].Length];\\n        (int minRow, int minColumn, int maxRow, int maxColumn)[] colorBounds = new (int, int, int, int)[61];\\n        for (int i = 0; i < colorBounds.Length; i++)\\n        {\\n            colorBounds[i] = (61, 61, 0, 0);\\n        }\\n        HashSet<int> colors = new HashSet<int>();\\n\\n        for (int i = 0; i < targetGrid.Length; i++)\\n        {\\n            for (int j = 0; j < targetGrid[i].Length; j++)\\n            {   \\n                int color = targetGrid[i][j];\\n                grid[i, j] = color;\\n                colors.Add(color);\\n\\n                colorBounds[color].minRow = Math.Min(colorBounds[color].minRow, i);                    \\n                colorBounds[color].minColumn = Math.Min(colorBounds[color].minColumn, j);\\n                colorBounds[color].maxRow = Math.Max(colorBounds[color].maxRow, i);\\n                colorBounds[color].maxColumn = Math.Max(colorBounds[color].maxColumn, j);\\n            }\\n        }\\n\\n\\n        while (colors.Count > 0)\\n        {\\n            HashSet<int> newColors = new HashSet<int>();\\n            foreach (int color in colors)\\n            {\\n                if (!CanRemoveColor(color, colorBounds[color], grid))\\n                {\\n                    newColors.Add(color);\\n                }\\n            }\\n\\n            // Not able to remove any color\\n            if (newColors.Count == colors.Count)\\n            {\\n                return false;\\n            }\\n\\n            colors = newColors;\\n        }\\n\\n        return true;\\n    }\\n\\n    private bool CanRemoveColor(int color, (int minRow, int minColumn, int maxRow, int maxColumn) colorBound, int[,] grid)\\n    {\\n        for (int i = colorBound.minRow; i <= colorBound.maxRow; i++)\\n        {\\n            for (int j = colorBound.minColumn; j <= colorBound.maxColumn; j++)\\n            {\\n                if (grid[i, j] > 0 && grid[i, j] != color)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for (int i = colorBound.minRow; i <= colorBound.maxRow; i++)\\n        {\\n            for (int j = colorBound.minColumn; j <= colorBound.maxColumn; j++)\\n            {\\n                grid[i, j] = 0;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855857,
                "title": "java-clean-solution-with-explanation-o-nmc-c-time",
                "content": "1. Find all rectangles in the grid (color, topLeft, topRight, width and height) - see `findRectangles` function. It takes O(NM) time\\n2. Construct dependency graph (iterate each rectangle from left to right and from top to bottom, each color that differ should be added as edge in the graph) - see `Graph.construct` function. This stage takes O(NMC)\\n3. Check if dependency graph (which is directed) is DAG (directed acyclic graph). I implemented topological sort, see `Graph.isDag` - it takes O(C\\xB2) time\\nOverall we have O(NM + NMC + C\\xB2) ~ O(NMC + C\\xB2) time complexity\\n\\n```\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        Map<Integer, Rectangle> rectangles = findRectangles(targetGrid);\\n        Graph graph = Graph.construct(targetGrid, rectangles);\\n        return graph.isDag();\\n    }\\n    \\n    private Map<Integer, Rectangle> findRectangles(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        Map<Integer, Rectangle> rectangles = new HashMap<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int color = grid[i][j];\\n                Rectangle rectangle = rectangles.getOrDefault(color, new Rectangle(j, i, 1, 1));\\n                \\n                rectangle = rectangle.enhance(j, i);\\n                rectangles.put(color, rectangle);\\n            }\\n        }\\n        \\n        return rectangles;\\n    }\\n    \\n    private static class Rectangle {\\n        public int x;\\n        public int y;\\n        public int width;\\n        public int height;\\n        \\n        public Rectangle(int x, int y, int width, int height) {\\n            this.x = x;\\n            this.y = y;\\n            this.width = width;\\n            this.height = height;\\n        }\\n        \\n        public Rectangle enhance(int x, int y) {\\n            if (this.x <= x && x < this.x + width && this.y <= y && y < this.y + this.height)\\n                return new Rectangle(this.x, this.y, this.width, this.height);\\n            \\n            int newX = Math.min(x, this.x);\\n            int newY = Math.min(y, this.y);\\n            int newWidth = Math.max(this.x + this.width, x + 1) - newX;\\n            int newHeight = Math.max(this.y + this.height, y + 1) - newY;\\n            \\n            return new Rectangle(newX, newY, newWidth, newHeight);\\n        }\\n    }\\n    \\n    private static class Graph {\\n        private Map<Integer, Set<Integer>> edges;\\n        \\n        public Graph(Map<Integer, Set<Integer>> edges) {\\n            this.edges = edges;\\n        }\\n        \\n        public static Graph construct(int[][] grid, Map<Integer, Rectangle> rectangles) {\\n            int n = grid.length;\\n            int m = grid[0].length;\\n            Map<Integer, Set<Integer>> edges = new HashMap<>();\\n            \\n            for (int color : rectangles.keySet()) {\\n                Rectangle rectangle = rectangles.get(color);\\n                Set<Integer> paths = new HashSet<>();\\n                \\n                for (int x = rectangle.x; x < rectangle.x + rectangle.width; x++) {\\n                    for (int y = rectangle.y; y < rectangle.y + rectangle.height; y++) {\\n                        if (grid[y][x] != color) {\\n                            paths.add(grid[y][x]);\\n                        }\\n                    }\\n                }\\n                \\n                edges.put(color, paths);\\n            }\\n            \\n            return new Graph(edges);\\n        }\\n        \\n        public boolean isDag() {\\n            Map<Integer, Integer> ingoing = new HashMap<>();\\n            for (int color : edges.keySet()) ingoing.put(color, 0);\\n            \\n            for (int color : edges.keySet()) {\\n                for (int edge : edges.get(color)) {\\n                    ingoing.put(edge, ingoing.get(edge) + 1);\\n                }\\n            }\\n            \\n            Queue<Integer> queue = new LinkedList<>();\\n            for (int color : ingoing.keySet()) if (ingoing.get(color) == 0) queue.add(color);\\n            \\n            while (!queue.isEmpty()) {\\n                int color = queue.poll();\\n                for (int neighbour : edges.get(color)) {\\n                    int previous = ingoing.get(neighbour);\\n                    ingoing.put(neighbour, previous - 1);\\n                    \\n                    if (previous == 1) {\\n                        queue.add(neighbour);\\n                    }\\n                }\\n            }\\n            \\n            for (int value : ingoing.values()) {\\n                if (value != 0) return false;\\n            }\\n            \\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        Map<Integer, Rectangle> rectangles = findRectangles(targetGrid);\\n        Graph graph = Graph.construct(targetGrid, rectangles);\\n        return graph.isDag();\\n    }\\n    \\n    private Map<Integer, Rectangle> findRectangles(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        Map<Integer, Rectangle> rectangles = new HashMap<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int color = grid[i][j];\\n                Rectangle rectangle = rectangles.getOrDefault(color, new Rectangle(j, i, 1, 1));\\n                \\n                rectangle = rectangle.enhance(j, i);\\n                rectangles.put(color, rectangle);\\n            }\\n        }\\n        \\n        return rectangles;\\n    }\\n    \\n    private static class Rectangle {\\n        public int x;\\n        public int y;\\n        public int width;\\n        public int height;\\n        \\n        public Rectangle(int x, int y, int width, int height) {\\n            this.x = x;\\n            this.y = y;\\n            this.width = width;\\n            this.height = height;\\n        }\\n        \\n        public Rectangle enhance(int x, int y) {\\n            if (this.x <= x && x < this.x + width && this.y <= y && y < this.y + this.height)\\n                return new Rectangle(this.x, this.y, this.width, this.height);\\n            \\n            int newX = Math.min(x, this.x);\\n            int newY = Math.min(y, this.y);\\n            int newWidth = Math.max(this.x + this.width, x + 1) - newX;\\n            int newHeight = Math.max(this.y + this.height, y + 1) - newY;\\n            \\n            return new Rectangle(newX, newY, newWidth, newHeight);\\n        }\\n    }\\n    \\n    private static class Graph {\\n        private Map<Integer, Set<Integer>> edges;\\n        \\n        public Graph(Map<Integer, Set<Integer>> edges) {\\n            this.edges = edges;\\n        }\\n        \\n        public static Graph construct(int[][] grid, Map<Integer, Rectangle> rectangles) {\\n            int n = grid.length;\\n            int m = grid[0].length;\\n            Map<Integer, Set<Integer>> edges = new HashMap<>();\\n            \\n            for (int color : rectangles.keySet()) {\\n                Rectangle rectangle = rectangles.get(color);\\n                Set<Integer> paths = new HashSet<>();\\n                \\n                for (int x = rectangle.x; x < rectangle.x + rectangle.width; x++) {\\n                    for (int y = rectangle.y; y < rectangle.y + rectangle.height; y++) {\\n                        if (grid[y][x] != color) {\\n                            paths.add(grid[y][x]);\\n                        }\\n                    }\\n                }\\n                \\n                edges.put(color, paths);\\n            }\\n            \\n            return new Graph(edges);\\n        }\\n        \\n        public boolean isDag() {\\n            Map<Integer, Integer> ingoing = new HashMap<>();\\n            for (int color : edges.keySet()) ingoing.put(color, 0);\\n            \\n            for (int color : edges.keySet()) {\\n                for (int edge : edges.get(color)) {\\n                    ingoing.put(edge, ingoing.get(edge) + 1);\\n                }\\n            }\\n            \\n            Queue<Integer> queue = new LinkedList<>();\\n            for (int color : ingoing.keySet()) if (ingoing.get(color) == 0) queue.add(color);\\n            \\n            while (!queue.isEmpty()) {\\n                int color = queue.poll();\\n                for (int neighbour : edges.get(color)) {\\n                    int previous = ingoing.get(neighbour);\\n                    ingoing.put(neighbour, previous - 1);\\n                    \\n                    if (previous == 1) {\\n                        queue.add(neighbour);\\n                    }\\n                }\\n            }\\n            \\n            for (int value : ingoing.values()) {\\n                if (value != 0) return false;\\n            }\\n            \\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061745,
                "title": "python-rectangle-overlap-graph",
                "content": "# Intuition\\nKey observation, filling color is on full rectangle only, if one rectangle has other color within its borders, then it has to be painted before that color. This way it can be constructed precedence graph, in another words problem becomes detecting is there cycle or not. More precisely for problem to be solvable it has to be DAG, meaning no cycles, otherwise you got chicken and egg situation. Hard part is to detect overlaps after that cycles can be found with various techniques like indegree counting or dfs with visited flags. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def get_color_borders(self, g, R, C):\\n        color_border = dict()\\n        for r in range(R):\\n            for c in range(C):\\n                color = g[r][c]\\n                if color in color_border:\\n                    border = color_border[color]\\n                    border[0], border[1] = min(border[0], r), min(border[1], c)\\n                    border[2], border[3] = max(border[2], r), max(border[3], c)\\n                else: color_border[color] = [r, c, r, c]     \\n        return color_border\\n\\n    def get_graph_and_indegree(self, color_border, g):\\n        graph, indeg = defaultdict(set), Counter()\\n        for color in color_border:\\n            cb = color_border[color]\\n            for r, c in product(range(cb[0], cb[2] + 1), range(cb[1], cb[3] + 1)):\\n                if g[r][c] != color:\\n                    if color not in graph[g[r][c]]:\\n                        graph[g[r][c]].add(color)\\n                        indeg[color] += 1        \\n        return graph, indeg\\n\\n    def isPrintable(self, g):\\n        R, C  = len(g), len(g[0])\\n        color_border = self.get_color_borders(g, R, C)\\n        graph, indeg = self.get_graph_and_indegree(color_border, g)\\n\\n        qu = deque()\\n\\n        for color in color_border:\\n            if indeg[color] == 0: qu.append(color)\\n\\n        while qu:\\n            color = qu.popleft()\\n            for to in graph[color]:\\n                indeg[to] -= 1\\n                if indeg[to] == 0: qu.append(to)\\n                \\n        return max(indeg.values()) == 0 if indeg else True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph",
                    "Topological Sort",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def get_color_borders(self, g, R, C):\\n        color_border = dict()\\n        for r in range(R):\\n            for c in range(C):\\n                color = g[r][c]\\n                if color in color_border:\\n                    border = color_border[color]\\n                    border[0], border[1] = min(border[0], r), min(border[1], c)\\n                    border[2], border[3] = max(border[2], r), max(border[3], c)\\n                else: color_border[color] = [r, c, r, c]     \\n        return color_border\\n\\n    def get_graph_and_indegree(self, color_border, g):\\n        graph, indeg = defaultdict(set), Counter()\\n        for color in color_border:\\n            cb = color_border[color]\\n            for r, c in product(range(cb[0], cb[2] + 1), range(cb[1], cb[3] + 1)):\\n                if g[r][c] != color:\\n                    if color not in graph[g[r][c]]:\\n                        graph[g[r][c]].add(color)\\n                        indeg[color] += 1        \\n        return graph, indeg\\n\\n    def isPrintable(self, g):\\n        R, C  = len(g), len(g[0])\\n        color_border = self.get_color_borders(g, R, C)\\n        graph, indeg = self.get_graph_and_indegree(color_border, g)\\n\\n        qu = deque()\\n\\n        for color in color_border:\\n            if indeg[color] == 0: qu.append(color)\\n\\n        while qu:\\n            color = qu.popleft()\\n            for to in graph[color]:\\n                indeg[to] -= 1\\n                if indeg[to] == 0: qu.append(to)\\n                \\n        return max(indeg.values()) == 0 if indeg else True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041732,
                "title": "c-solution-explanation-with-intuition-and-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLets look this problem backward. Instead of printing, we will try to remove paints in recantangle fashion.  \\nThe colour painted last will be forming a perfect recantangle, so we can easily remove that rectangle and each time we can repeat this. If we are able to do this, this is possible else its not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find unique colours in the grid\\n2. For each colour, check if we can remove that or not\\n3. If we can remove atleast one colour each iteration then its possible otherwise its not possible and at max we can have iterations equal to unique colours\\n\\n- How to check if a colour can be removed or not?\\n    1. Find the min and max index in a row where that colour exist, lets say x1 and x2.\\n    2. Find the min and max index in a row where that colour exist, lets say y1 and y2.\\n    3. So, now we have a smaller rectangle starting from x1 to x2 row wise and y1 to y2 column wise\\n    4. In this area check if all cells have the same colour that we want to remove or not (or it will have a default value where some colour that is already removed can come)\\n    5. If we can remove, change it to some default value (lets say 0)\\n# Complexity\\n- Time complexity: O(c * c * m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nc = unique colours\\n\\n- Space complexity: O(1)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        set<int> s;\\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        int x1=n-1, x2=0, y1=m-1, y2=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                s.insert(targetGrid[i][j]);\\n            }\\n        }\\n        int sz = s.size();\\n        for(int i=0; i<sz; i++) {\\n            int flag = 0;\\n            for(auto colour: s) {\\n                if(remove(targetGrid, colour)){\\n                    flag = colour;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n                return false;\\n            s.erase(flag);\\n        }\\n        return true;\\n    }\\n    bool remove(vector<vector<int>>& targetGrid, int c) {\\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        int x1=n-1, x2=0, y1=m-1, y2=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(targetGrid[i][j]==c) {\\n                    x1 = min(i, x1);\\n                    x2 = max(i, x2);\\n                    y1 = min(j, y1);\\n                    y2 = max(j, y2);\\n                }\\n            }\\n        }\\n        for(int i=x1; i<=x2; i++) {\\n            for(int j=y1; j<=y2; j++) {\\n                if(targetGrid[i][j]!=c && targetGrid[i][j]!=0) \\n                    return false;\\n            }\\n        }\\n        for(int i=x1; i<=x2; i++) {\\n            for(int j=y1; j<=y2; j++) {\\n                targetGrid[i][j]=0;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        set<int> s;\\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        int x1=n-1, x2=0, y1=m-1, y2=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                s.insert(targetGrid[i][j]);\\n            }\\n        }\\n        int sz = s.size();\\n        for(int i=0; i<sz; i++) {\\n            int flag = 0;\\n            for(auto colour: s) {\\n                if(remove(targetGrid, colour)){\\n                    flag = colour;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n                return false;\\n            s.erase(flag);\\n        }\\n        return true;\\n    }\\n    bool remove(vector<vector<int>>& targetGrid, int c) {\\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        int x1=n-1, x2=0, y1=m-1, y2=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(targetGrid[i][j]==c) {\\n                    x1 = min(i, x1);\\n                    x2 = max(i, x2);\\n                    y1 = min(j, y1);\\n                    y2 = max(j, y2);\\n                }\\n            }\\n        }\\n        for(int i=x1; i<=x2; i++) {\\n            for(int j=y1; j<=y2; j++) {\\n                if(targetGrid[i][j]!=c && targetGrid[i][j]!=0) \\n                    return false;\\n            }\\n        }\\n        for(int i=x1; i<=x2; i++) {\\n            for(int j=y1; j<=y2; j++) {\\n                targetGrid[i][j]=0;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946060,
                "title": "python-clean-and-simple-solution-using-topological-sorting",
                "content": "```\\nfrom collections import defaultdict\\nfrom graphlib import CycleError, TopologicalSorter\\nfrom itertools import product\\n\\nMAX_COLOR = 60\\n\\n\\nclass Solution:\\n    def isPrintable(self, M: list[list[int]]) -> bool:\\n        g = self.create_graph(M)\\n\\n        try:\\n            TopologicalSorter(g).prepare()\\n            return True\\n        except CycleError:\\n            return False\\n\\n    @staticmethod\\n    def create_graph(M: list[list[int]]) -> defaultdict[int, set[int]]:\\n        m, n = len(M), len(M[0])\\n\\n        g = defaultdict(set)\\n\\n        for c in range(1, MAX_COLOR + 1):  # notice that order of traversal, it is from smaller to larger color\\n            # now, finding the rectangle containing the color \"c\"\\n            x1, y1 = m, n  # will represent the top left of the square\\n            x2, y2 = -1, -1  # will represent the bottom right of the square\\n\\n            for i, j in product(range(m), range(n)):\\n                if M[i][j] == c:\\n                    x1, y1 = min(x1, i), min(y1, j)\\n                    x2, y2 = max(x2, i), max(y2, j)\\n\\n            for i, j in product(range(x1, x2 + 1), range(y1, y2 + 1)):\\n                if M[i][j] != c:\\n                    g[c].add(M[i][j])\\n\\n        return g\\n```",
                "solutionTags": [
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom graphlib import CycleError, TopologicalSorter\\nfrom itertools import product\\n\\nMAX_COLOR = 60\\n\\n\\nclass Solution:\\n    def isPrintable(self, M: list[list[int]]) -> bool:\\n        g = self.create_graph(M)\\n\\n        try:\\n            TopologicalSorter(g).prepare()\\n            return True\\n        except CycleError:\\n            return False\\n\\n    @staticmethod\\n    def create_graph(M: list[list[int]]) -> defaultdict[int, set[int]]:\\n        m, n = len(M), len(M[0])\\n\\n        g = defaultdict(set)\\n\\n        for c in range(1, MAX_COLOR + 1):  # notice that order of traversal, it is from smaller to larger color\\n            # now, finding the rectangle containing the color \"c\"\\n            x1, y1 = m, n  # will represent the top left of the square\\n            x2, y2 = -1, -1  # will represent the bottom right of the square\\n\\n            for i, j in product(range(m), range(n)):\\n                if M[i][j] == c:\\n                    x1, y1 = min(x1, i), min(y1, j)\\n                    x2, y2 = max(x2, i), max(y2, j)\\n\\n            for i, j in product(range(x1, x2 + 1), range(y1, y2 + 1)):\\n                if M[i][j] != c:\\n                    g[c].add(M[i][j])\\n\\n        return g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908091,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool checkCycle(int node,vector<int>&vis,vector<int>&dfsVis,\\n   vector<unordered_set<int>>&adj)\\n   {\\n       vis[node]=1;\\n       dfsVis[node]=1;\\n       for (auto it : adj[node] )\\n       {\\n           if (!vis[it])\\n           {\\n               if (checkCycle(it,vis,dfsVis,adj)) return true;\\n           }\\n           else{\\n               if (dfsVis[it])\\n               {\\n                   return true;\\n               }\\n           }\\n       }\\n       dfsVis[node]=0;\\n       return false;\\n   }\\n    bool isPrintable(vector<vector<int>>& targetGrid) \\n    {\\n        int n=targetGrid.size();\\n        int m=targetGrid[0].size();\\n      vector<unordered_set<int>>adj(61);\\n      for (int i=1;i<=60;i++)\\n      {\\n          int minx=n;\\n          int miny=m;\\n          int maxx=0;\\n          int maxy=0;\\n          for (int x=0;x<n;x++)\\n          {\\n              for (int y=0;y<m;y++)\\n              {\\n                  if (targetGrid[x][y]==i)\\n                  {\\n                     minx=min(x,minx);\\n                     miny=min(y,miny);\\n                     maxx=max(x,maxx);\\n                     maxy=max(y,maxy);\\n                  }\\n              }\\n          }\\n          for (int x=minx;x<=maxx;x++)\\n          {\\n              for (int y=miny;y<=maxy;y++)\\n              {\\n                  if (targetGrid[x][y]!=i)\\n                  {\\n                      adj[i].insert(targetGrid[x][y]);\\n                  }\\n              }\\n          }\\n      }  \\n      vector<int>vis(61,0);\\n      vector<int>dfsVis(61,0);\\n      for (int i=1;i<=60;i++)\\n      {\\n          if (vis[i]==0)\\n          {\\n              if (checkCycle(i,vis,dfsVis,adj)) return false;\\n          }\\n      } \\n      return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool checkCycle(int node,vector<int>&vis,vector<int>&dfsVis,\\n   vector<unordered_set<int>>&adj)\\n   {\\n       vis[node]=1;\\n       dfsVis[node]=1;\\n       for (auto it : adj[node] )\\n       {\\n           if (!vis[it])\\n           {\\n               if (checkCycle(it,vis,dfsVis,adj)) return true;\\n           }\\n           else{\\n               if (dfsVis[it])\\n               {\\n                   return true;\\n               }\\n           }\\n       }\\n       dfsVis[node]=0;\\n       return false;\\n   }\\n    bool isPrintable(vector<vector<int>>& targetGrid) \\n    {\\n        int n=targetGrid.size();\\n        int m=targetGrid[0].size();\\n      vector<unordered_set<int>>adj(61);\\n      for (int i=1;i<=60;i++)\\n      {\\n          int minx=n;\\n          int miny=m;\\n          int maxx=0;\\n          int maxy=0;\\n          for (int x=0;x<n;x++)\\n          {\\n              for (int y=0;y<m;y++)\\n              {\\n                  if (targetGrid[x][y]==i)\\n                  {\\n                     minx=min(x,minx);\\n                     miny=min(y,miny);\\n                     maxx=max(x,maxx);\\n                     maxy=max(y,maxy);\\n                  }\\n              }\\n          }\\n          for (int x=minx;x<=maxx;x++)\\n          {\\n              for (int y=miny;y<=maxy;y++)\\n              {\\n                  if (targetGrid[x][y]!=i)\\n                  {\\n                      adj[i].insert(targetGrid[x][y]);\\n                  }\\n              }\\n          }\\n      }  \\n      vector<int>vis(61,0);\\n      vector<int>dfsVis(61,0);\\n      for (int i=1;i<=60;i++)\\n      {\\n          if (vis[i]==0)\\n          {\\n              if (checkCycle(i,vis,dfsVis,adj)) return false;\\n          }\\n      } \\n      return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886125,
                "title": "c-valid-topological-sort-using-cycle-detection-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool dfs(int col,vector<int> adj[],vector<int> &vis,vector<int> &pvis,vector<vector<int>>& grid)\\n{\\n    vis[col]=1;\\n    pvis[col]=1;\\n    int i,j;\\n    for(i=adj[col][0];i<=adj[col][1];i++)\\n    {\\n        for(j=adj[col][2];j<=adj[col][3];j++)\\n        {\\n            int ccol=grid[i][j];\\n            if(ccol==col) continue;\\n            if(vis[ccol]==0)\\n            {\\n                bool b=dfs(ccol,adj,vis,pvis,grid);\\n                if(b==false) return false;\\n            }\\n            else if(pvis[ccol]==1)\\n            return false;\\n        }\\n    }\\n    pvis[col]=0;\\n    return true;\\n}\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        int i,j,n=grid.size(),m=grid[0].size();\\n        vector<int> adj[61];\\n        for(i=0;i<61;i++)\\n        {\\n            adj[i].push_back(n);\\n            adj[i].push_back(-1);\\n            adj[i].push_back(m);\\n            adj[i].push_back(-1);\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<m;j++)\\n            {\\n                int a=grid[i][j];\\n                adj[a][0]=min(adj[a][0],i);\\n                adj[a][1]=max(adj[a][1],i);\\n                adj[a][2]=min(adj[a][2],j);\\n                adj[a][3]=max(adj[a][3],j);\\n            }\\n        }\\n        vector<int> vis(61,0),pvis(61,0);\\n        for(i=0;i<61;i++)\\n        {\\n            if(adj[i][0]!=n)\\n            {\\n                bool b=dfs(i,adj,vis,pvis,grid);\\n                if(b==false)\\n                return false;\\n            }\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool dfs(int col,vector<int> adj[],vector<int> &vis,vector<int> &pvis,vector<vector<int>>& grid)\\n{\\n    vis[col]=1;\\n    pvis[col]=1;\\n    int i,j;\\n    for(i=adj[col][0];i<=adj[col][1];i++)\\n    {\\n        for(j=adj[col][2];j<=adj[col][3];j++)\\n        {\\n            int ccol=grid[i][j];\\n            if(ccol==col) continue;\\n            if(vis[ccol]==0)\\n            {\\n                bool b=dfs(ccol,adj,vis,pvis,grid);\\n                if(b==false) return false;\\n            }\\n            else if(pvis[ccol]==1)\\n            return false;\\n        }\\n    }\\n    pvis[col]=0;\\n    return true;\\n}\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        int i,j,n=grid.size(),m=grid[0].size();\\n        vector<int> adj[61];\\n        for(i=0;i<61;i++)\\n        {\\n            adj[i].push_back(n);\\n            adj[i].push_back(-1);\\n            adj[i].push_back(m);\\n            adj[i].push_back(-1);\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<m;j++)\\n            {\\n                int a=grid[i][j];\\n                adj[a][0]=min(adj[a][0],i);\\n                adj[a][1]=max(adj[a][1],i);\\n                adj[a][2]=min(adj[a][2],j);\\n                adj[a][3]=max(adj[a][3],j);\\n            }\\n        }\\n        vector<int> vis(61,0),pvis(61,0);\\n        for(i=0;i<61;i++)\\n        {\\n            if(adj[i][0]!=n)\\n            {\\n                bool b=dfs(i,adj,vis,pvis,grid);\\n                if(b==false)\\n                return false;\\n            }\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749277,
                "title": "my-solutions",
                "content": "**1. Use the topological sort to detect whether there exist cycles in the graph**\\n```\\nclass Solution {\\n private:\\n  class Rectangle {\\n   public:\\n    Rectangle() : min_row_(numeric_limits<int>::max())\\n                , max_row_(numeric_limits<int>::min())\\n                , min_col_(numeric_limits<int>::max())\\n                , max_col_(numeric_limits<int>::min()) {\\n    }\\n    \\n    bool is_valid() const {\\n      return min_row_ != numeric_limits<int>::max();\\n    }\\n    \\n    void update(const int r, const int c) {\\n      min_row_ = min(min_row_, r);\\n      max_row_ = max(max_row_, r);\\n      min_col_ = min(min_col_, c);\\n      max_col_ = max(max_col_, c);\\n    }\\n    \\n    int min_row() const {\\n      return min_row_;\\n    }\\n    \\n    int max_row() const {\\n      return max_row_;\\n    }\\n    \\n    int min_col() const {\\n      return min_col_;\\n    }\\n    \\n    int max_col() const {\\n      return max_col_;\\n    }\\n    \\n   private:\\n    int min_row_;\\n    int max_row_;\\n    int min_col_;\\n    int max_col_;\\n  };\\n  \\n public:\\n  bool isPrintable(const vector<vector<int>> &targetGrid) {\\n    const int rows = static_cast<int>(targetGrid.size());\\n    const int cols = static_cast<int>(targetGrid.front().size());\\n    int max_color = numeric_limits<int>::min();\\n    int min_color = numeric_limits<int>::max();\\n    for (const vector<int> &row : targetGrid) {\\n      for (const int color : row) {\\n        max_color = max(max_color, color);\\n        min_color = min(min_color, color);\\n      }\\n    }\\n    const int color_range = max_color - min_color + 1;\\n    \\n    Rectangle color_to_rectangle[color_range];\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        color_to_rectangle[targetGrid[r][c] - min_color].update(r, c);\\n      }\\n    }\\n    \\n    vector<vector<bool>> graph(color_range, vector<bool>(color_range, false));\\n    int indegrees[color_range];\\n    memset(indegrees, 0, sizeof(indegrees));\\n    for (int color = 0; color < color_range; ++color) {\\n      const Rectangle &rectangle = color_to_rectangle[color];\\n      if (!rectangle.is_valid()) {\\n        continue;\\n      }\\n      \\n      for (int r = rectangle.min_row(); r < rectangle.max_row() + 1; ++r) {\\n        for (int c = rectangle.min_col(); c < rectangle.max_col() + 1; ++c) {\\n          const int target_color = targetGrid[r][c] - min_color;\\n          if (target_color == color) {\\n            continue;\\n          }\\n\\n          if (!graph[color][target_color]) {\\n            graph[color][target_color] = true;\\n            ++indegrees[target_color];\\n          }\\n        }\\n      }\\n    }\\n    \\n    return !has_cycle(graph, indegrees);\\n  }\\n  \\n private:\\n  bool has_cycle(const vector<vector<bool>> &graph, int *indegrees) {\\n    const int n = static_cast<int>(graph.size());\\n    int visited = 0;\\n    queue<int> q;\\n    for (int i = 0; i < n; ++i) {\\n      if (indegrees[i] == 0) {\\n        q.emplace(i);\\n      }\\n    }\\n    \\n    while (!q.empty()) {\\n      const int node = q.front();\\n      q.pop();\\n      ++visited;\\n      for (int next = 0; next < n; ++next) {\\n        if (graph[node][next] && --indegrees[next] == 0) {\\n          q.emplace(next);\\n        }\\n      }\\n    }\\n    return visited != n;\\n  }\\n};\\n```\\n**2. Use the DFS to detect whether there exist cycles in the graph**\\n```\\nclass Solution {\\n private:\\n  enum class State : uint8_t {\\n    unvisited = 0,\\n    visiting,\\n    visited\\n  };\\n  \\n  class Rectangle {\\n   public:\\n    Rectangle() : min_row_(numeric_limits<int>::max())\\n                , max_row_(numeric_limits<int>::min())\\n                , min_col_(numeric_limits<int>::max())\\n                , max_col_(numeric_limits<int>::min()) {\\n    }\\n    \\n    bool is_valid() const {\\n      return min_row_ != numeric_limits<int>::max();\\n    }\\n    \\n    void update(const int r, const int c) {\\n      min_row_ = min(min_row_, r);\\n      max_row_ = max(max_row_, r);\\n      min_col_ = min(min_col_, c);\\n      max_col_ = max(max_col_, c);\\n    }\\n    \\n    int min_row() const {\\n      return min_row_;\\n    }\\n    \\n    int max_row() const {\\n      return max_row_;\\n    }\\n    \\n    int min_col() const {\\n      return min_col_;\\n    }\\n    \\n    int max_col() const {\\n      return max_col_;\\n    }\\n    \\n   private:\\n    int min_row_;\\n    int max_row_;\\n    int min_col_;\\n    int max_col_;\\n  };\\n  \\n public:\\n  bool isPrintable(const vector<vector<int>> &targetGrid) {\\n    const int rows = static_cast<int>(targetGrid.size());\\n    const int cols = static_cast<int>(targetGrid.front().size());\\n    int max_color = numeric_limits<int>::min();\\n    int min_color = numeric_limits<int>::max();\\n    for (const vector<int> &row : targetGrid) {\\n      for (const int color : row) {\\n        max_color = max(max_color, color);\\n        min_color = min(min_color, color);\\n      }\\n    }\\n    const int color_range = max_color - min_color + 1;\\n    \\n    Rectangle color_to_rectangle[color_range];\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        color_to_rectangle[targetGrid[r][c] - min_color].update(r, c);\\n      }\\n    }\\n    \\n    vector<vector<bool>> graph(color_range, vector<bool>(color_range, false));\\n    for (int color = 0; color < color_range; ++color) {\\n      const Rectangle &rectangle = color_to_rectangle[color];\\n      if (!rectangle.is_valid()) {\\n        continue;\\n      }\\n      \\n      for (int r = rectangle.min_row(); r < rectangle.max_row() + 1; ++r) {\\n        for (int c = rectangle.min_col(); c < rectangle.max_col() + 1; ++c) {\\n          const int target_color = targetGrid[r][c] - min_color;\\n          if (target_color == color) {\\n            continue;\\n          }\\n\\n          if (!graph[color][target_color]) {\\n            graph[color][target_color] = true;\\n          }\\n        }\\n      }\\n    }\\n    \\n    return !has_cycle(graph);\\n  }\\n  \\n private:\\n  bool has_cycle(const vector<vector<bool>> &graph) {\\n    const int n = static_cast<int>(graph.size());\\n    State states[n];\\n    memset(states, 0, sizeof(states));\\n    for (int node = 0; node < n; ++node) {\\n      if (dfs(graph, node, states) != State::visited) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  State dfs(const vector<vector<bool>> &graph, const int node, State *states) {\\n    const int n = static_cast<int>(graph.size());\\n    if (states[node] != State::unvisited) {\\n      return states[node];\\n    }\\n    \\n    states[node] = State::visiting;\\n    for (int next = 0; next < n; ++next) {\\n      if (graph[node][next]) {\\n        if (dfs(graph, next, states) != State::visited) {\\n          return states[node];\\n        }\\n      }\\n    }\\n    states[node] = State::visited;\\n    return states[node];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n private:\\n  class Rectangle {\\n   public:\\n    Rectangle() : min_row_(numeric_limits<int>::max())\\n                , max_row_(numeric_limits<int>::min())\\n                , min_col_(numeric_limits<int>::max())\\n                , max_col_(numeric_limits<int>::min()) {\\n    }\\n    \\n    bool is_valid() const {\\n      return min_row_ != numeric_limits<int>::max();\\n    }\\n    \\n    void update(const int r, const int c) {\\n      min_row_ = min(min_row_, r);\\n      max_row_ = max(max_row_, r);\\n      min_col_ = min(min_col_, c);\\n      max_col_ = max(max_col_, c);\\n    }\\n    \\n    int min_row() const {\\n      return min_row_;\\n    }\\n    \\n    int max_row() const {\\n      return max_row_;\\n    }\\n    \\n    int min_col() const {\\n      return min_col_;\\n    }\\n    \\n    int max_col() const {\\n      return max_col_;\\n    }\\n    \\n   private:\\n    int min_row_;\\n    int max_row_;\\n    int min_col_;\\n    int max_col_;\\n  };\\n  \\n public:\\n  bool isPrintable(const vector<vector<int>> &targetGrid) {\\n    const int rows = static_cast<int>(targetGrid.size());\\n    const int cols = static_cast<int>(targetGrid.front().size());\\n    int max_color = numeric_limits<int>::min();\\n    int min_color = numeric_limits<int>::max();\\n    for (const vector<int> &row : targetGrid) {\\n      for (const int color : row) {\\n        max_color = max(max_color, color);\\n        min_color = min(min_color, color);\\n      }\\n    }\\n    const int color_range = max_color - min_color + 1;\\n    \\n    Rectangle color_to_rectangle[color_range];\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        color_to_rectangle[targetGrid[r][c] - min_color].update(r, c);\\n      }\\n    }\\n    \\n    vector<vector<bool>> graph(color_range, vector<bool>(color_range, false));\\n    int indegrees[color_range];\\n    memset(indegrees, 0, sizeof(indegrees));\\n    for (int color = 0; color < color_range; ++color) {\\n      const Rectangle &rectangle = color_to_rectangle[color];\\n      if (!rectangle.is_valid()) {\\n        continue;\\n      }\\n      \\n      for (int r = rectangle.min_row(); r < rectangle.max_row() + 1; ++r) {\\n        for (int c = rectangle.min_col(); c < rectangle.max_col() + 1; ++c) {\\n          const int target_color = targetGrid[r][c] - min_color;\\n          if (target_color == color) {\\n            continue;\\n          }\\n\\n          if (!graph[color][target_color]) {\\n            graph[color][target_color] = true;\\n            ++indegrees[target_color];\\n          }\\n        }\\n      }\\n    }\\n    \\n    return !has_cycle(graph, indegrees);\\n  }\\n  \\n private:\\n  bool has_cycle(const vector<vector<bool>> &graph, int *indegrees) {\\n    const int n = static_cast<int>(graph.size());\\n    int visited = 0;\\n    queue<int> q;\\n    for (int i = 0; i < n; ++i) {\\n      if (indegrees[i] == 0) {\\n        q.emplace(i);\\n      }\\n    }\\n    \\n    while (!q.empty()) {\\n      const int node = q.front();\\n      q.pop();\\n      ++visited;\\n      for (int next = 0; next < n; ++next) {\\n        if (graph[node][next] && --indegrees[next] == 0) {\\n          q.emplace(next);\\n        }\\n      }\\n    }\\n    return visited != n;\\n  }\\n};\\n```\n```\\nclass Solution {\\n private:\\n  enum class State : uint8_t {\\n    unvisited = 0,\\n    visiting,\\n    visited\\n  };\\n  \\n  class Rectangle {\\n   public:\\n    Rectangle() : min_row_(numeric_limits<int>::max())\\n                , max_row_(numeric_limits<int>::min())\\n                , min_col_(numeric_limits<int>::max())\\n                , max_col_(numeric_limits<int>::min()) {\\n    }\\n    \\n    bool is_valid() const {\\n      return min_row_ != numeric_limits<int>::max();\\n    }\\n    \\n    void update(const int r, const int c) {\\n      min_row_ = min(min_row_, r);\\n      max_row_ = max(max_row_, r);\\n      min_col_ = min(min_col_, c);\\n      max_col_ = max(max_col_, c);\\n    }\\n    \\n    int min_row() const {\\n      return min_row_;\\n    }\\n    \\n    int max_row() const {\\n      return max_row_;\\n    }\\n    \\n    int min_col() const {\\n      return min_col_;\\n    }\\n    \\n    int max_col() const {\\n      return max_col_;\\n    }\\n    \\n   private:\\n    int min_row_;\\n    int max_row_;\\n    int min_col_;\\n    int max_col_;\\n  };\\n  \\n public:\\n  bool isPrintable(const vector<vector<int>> &targetGrid) {\\n    const int rows = static_cast<int>(targetGrid.size());\\n    const int cols = static_cast<int>(targetGrid.front().size());\\n    int max_color = numeric_limits<int>::min();\\n    int min_color = numeric_limits<int>::max();\\n    for (const vector<int> &row : targetGrid) {\\n      for (const int color : row) {\\n        max_color = max(max_color, color);\\n        min_color = min(min_color, color);\\n      }\\n    }\\n    const int color_range = max_color - min_color + 1;\\n    \\n    Rectangle color_to_rectangle[color_range];\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        color_to_rectangle[targetGrid[r][c] - min_color].update(r, c);\\n      }\\n    }\\n    \\n    vector<vector<bool>> graph(color_range, vector<bool>(color_range, false));\\n    for (int color = 0; color < color_range; ++color) {\\n      const Rectangle &rectangle = color_to_rectangle[color];\\n      if (!rectangle.is_valid()) {\\n        continue;\\n      }\\n      \\n      for (int r = rectangle.min_row(); r < rectangle.max_row() + 1; ++r) {\\n        for (int c = rectangle.min_col(); c < rectangle.max_col() + 1; ++c) {\\n          const int target_color = targetGrid[r][c] - min_color;\\n          if (target_color == color) {\\n            continue;\\n          }\\n\\n          if (!graph[color][target_color]) {\\n            graph[color][target_color] = true;\\n          }\\n        }\\n      }\\n    }\\n    \\n    return !has_cycle(graph);\\n  }\\n  \\n private:\\n  bool has_cycle(const vector<vector<bool>> &graph) {\\n    const int n = static_cast<int>(graph.size());\\n    State states[n];\\n    memset(states, 0, sizeof(states));\\n    for (int node = 0; node < n; ++node) {\\n      if (dfs(graph, node, states) != State::visited) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  State dfs(const vector<vector<bool>> &graph, const int node, State *states) {\\n    const int n = static_cast<int>(graph.size());\\n    if (states[node] != State::unvisited) {\\n      return states[node];\\n    }\\n    \\n    states[node] = State::visiting;\\n    for (int next = 0; next < n; ++next) {\\n      if (graph[node][next]) {\\n        if (dfs(graph, next, states) != State::visited) {\\n          return states[node];\\n        }\\n      }\\n    }\\n    states[node] = State::visited;\\n    return states[node];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741066,
                "title": "c-easy-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif you cannot solve in a given way . try it in a reverse way . \\ntry N times  1 to 60 \\ntry every color 1 to 60 \\n- check using f(color , grid ) ;\\n- find out l , r , u , d of that color in a grid \\n- if color not found return 0\\n- now check in that range can another color present other than 0 and color return 0 . \\n-  now make all numbers in that rectangle matrix to 0 .\\n\\nnow check if in  grid all are 0\\'s . if zeros return 1 ;\\nelse continue checking . \\n\\nif no color is matching in that turen return 0 ( means we cannot move forward )\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N ^ 4)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nconst int N = 60 ; \\nclass Solution {\\npublic:\\n    bool vis[N + 1] ;\\n\\n    bool check( vector<vector<int>> &grid ){\\n        int n = grid.size() , m = grid[0].size() ;\\n        for(int i = 0 ; i < n ; ++i ){\\n            for(int j = 0 ; j< m ; ++j ){\\n                if(grid[i][j] != 0 ) return 0 ; \\n            }\\n        }\\n        return 1 ;    \\n    }\\n    bool f(int color , vector<vector<int>>& grid ){\\n        int n = grid.size() , m = grid[0].size() ;\\n        int l = INT_MAX , r = -1 , u = INT_MAX , d = -1 ;\\n\\n        for(int i = 0 ; i < n ; ++i ){\\n            for(int j = 0 ; j< m ; ++j ){\\n                if( grid[i][j] == color ){\\n                    l = min( l , j ) ;\\n                    r = max( r , j ) ;\\n                    u = min( u , i ) ;\\n                    d = max( d , i ) ;\\n                }\\n            }\\n        }\\n\\n        if( l >= m || r < 0 || u >= n || d < 0 ) return 0 ;\\n\\n        bool found = true ; \\n        for(int i = u ; i <= d ; ++i ){\\n            for(int j = l ; j<= r ; ++j ){\\n                if( grid[i][j] == color || grid[i][j] == 0 ) continue ; \\n                else found = false ; \\n            }\\n        }\\n        if(found == false ) return 0 ; \\n        for(int i = u ; i <= d ; ++i ){\\n            for(int j = l ; j<= r ; ++j ){\\n                grid[i][j] = 0 ; \\n            }\\n        }\\n        vis[color] = 1 ;\\n        return 1 ; \\n    }\\n\\n    bool isPrintable(vector<vector<int>>& grid ) {\\n        memset(vis , 0 , sizeof(vis)) ;\\n\\n        for(int turn = 1 ; turn <= N ; ++turn ){\\n            bool found = false ; \\n            for(int col = 1 ; col<= N ; ++col ){\\n                if(!vis[col] )  found = found | f( col , grid ) ;\\n            }\\n            // cout<<turn<<\" \";\\n            if(check(grid)) return 1 ;\\n            if(found == false ) return 0 ; \\n        }\\n        return 1 ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int N = 60 ; \\nclass Solution {\\npublic:\\n    bool vis[N + 1] ;\\n\\n    bool check( vector<vector<int>> &grid ){\\n        int n = grid.size() , m = grid[0].size() ;\\n        for(int i = 0 ; i < n ; ++i ){\\n            for(int j = 0 ; j< m ; ++j ){\\n                if(grid[i][j] != 0 ) return 0 ; \\n            }\\n        }\\n        return 1 ;    \\n    }\\n    bool f(int color , vector<vector<int>>& grid ){\\n        int n = grid.size() , m = grid[0].size() ;\\n        int l = INT_MAX , r = -1 , u = INT_MAX , d = -1 ;\\n\\n        for(int i = 0 ; i < n ; ++i ){\\n            for(int j = 0 ; j< m ; ++j ){\\n                if( grid[i][j] == color ){\\n                    l = min( l , j ) ;\\n                    r = max( r , j ) ;\\n                    u = min( u , i ) ;\\n                    d = max( d , i ) ;\\n                }\\n            }\\n        }\\n\\n        if( l >= m || r < 0 || u >= n || d < 0 ) return 0 ;\\n\\n        bool found = true ; \\n        for(int i = u ; i <= d ; ++i ){\\n            for(int j = l ; j<= r ; ++j ){\\n                if( grid[i][j] == color || grid[i][j] == 0 ) continue ; \\n                else found = false ; \\n            }\\n        }\\n        if(found == false ) return 0 ; \\n        for(int i = u ; i <= d ; ++i ){\\n            for(int j = l ; j<= r ; ++j ){\\n                grid[i][j] = 0 ; \\n            }\\n        }\\n        vis[color] = 1 ;\\n        return 1 ; \\n    }\\n\\n    bool isPrintable(vector<vector<int>>& grid ) {\\n        memset(vis , 0 , sizeof(vis)) ;\\n\\n        for(int turn = 1 ; turn <= N ; ++turn ){\\n            bool found = false ; \\n            for(int col = 1 ; col<= N ; ++col ){\\n                if(!vis[col] )  found = found | f( col , grid ) ;\\n            }\\n            // cout<<turn<<\" \";\\n            if(check(grid)) return 1 ;\\n            if(found == false ) return 0 ; \\n        }\\n        return 1 ; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3722564,
                "title": "java-solution-55-ms-topological-sort-kahn-algorithm",
                "content": "# Intuition\\nsurrounding color comes before the contained color. if blue box contains red box then blue box surely need to be printed first and then only we can print blue box\\n\\n# Approach\\nthis video builds up the approach\\nLeetcode 1591. Strange Printer II : Elite Code.\\n(not posting link here you can search :) )\\n\\n\\n# Complexity\\n- Time complexity: O(60mn)\\n\\n- Space complexity: O(mn)\\n\\n# Code\\n```\\nclass Solution {\\n    private Set<Integer>[] graph;\\n    private int m, n;\\n    private final int maxColor = 60;\\n    public boolean isPrintable(int[][] targetGrid) {\\n        m = targetGrid.length;\\n        n = targetGrid[0].length;\\n        graph = new HashSet[maxColor + 1];\\n        for(int color = 1; color <= maxColor; ++color) {\\n            int minI = m, minJ = n;\\n            int maxI = -1, maxJ = -1;\\n            for(int i = 0; i < m; i++) {\\n                for(int j = 0; j < n; j++) {\\n                    if(targetGrid[i][j] == color) {\\n                        minI = Math.min(minI, i);\\n                        minJ = Math.min(minJ, j);\\n                        maxI = Math.max(maxI, i);\\n                        maxJ = Math.max(maxJ, j);\\n                    }\\n                }\\n            }\\n            graph[color] = new HashSet<>();\\n            for(int i = minI; i <= maxI; ++i) {\\n                for(int j = minJ; j <= maxJ; ++j) {\\n                    if(targetGrid[i][j] != color) {\\n                        graph[color].add(targetGrid[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        int[] indegree = new int[maxColor + 1];\\n        Queue<Integer> q = new ArrayDeque<>();\\n        for(int color = 1; color <= maxColor; ++color) {\\n            for(Integer containedColor : graph[color]) indegree[containedColor]++;\\n        }\\n        for(int color = 1; color <= maxColor; ++color) {\\n            if(indegree[color] == 0) {\\n                q.offer(color);\\n            }\\n        }\\n        int topoLength = 0;\\n        while(!q.isEmpty()) {\\n            Integer color = q.poll();\\n            topoLength++;\\n            for(Integer containedColor : graph[color]) {\\n                if(--indegree[containedColor] == 0) {\\n                    q.offer(containedColor);\\n                }\\n            }\\n        }\\n        return topoLength == maxColor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    private Set<Integer>[] graph;\\n    private int m, n;\\n    private final int maxColor = 60;\\n    public boolean isPrintable(int[][] targetGrid) {\\n        m = targetGrid.length;\\n        n = targetGrid[0].length;\\n        graph = new HashSet[maxColor + 1];\\n        for(int color = 1; color <= maxColor; ++color) {\\n            int minI = m, minJ = n;\\n            int maxI = -1, maxJ = -1;\\n            for(int i = 0; i < m; i++) {\\n                for(int j = 0; j < n; j++) {\\n                    if(targetGrid[i][j] == color) {\\n                        minI = Math.min(minI, i);\\n                        minJ = Math.min(minJ, j);\\n                        maxI = Math.max(maxI, i);\\n                        maxJ = Math.max(maxJ, j);\\n                    }\\n                }\\n            }\\n            graph[color] = new HashSet<>();\\n            for(int i = minI; i <= maxI; ++i) {\\n                for(int j = minJ; j <= maxJ; ++j) {\\n                    if(targetGrid[i][j] != color) {\\n                        graph[color].add(targetGrid[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        int[] indegree = new int[maxColor + 1];\\n        Queue<Integer> q = new ArrayDeque<>();\\n        for(int color = 1; color <= maxColor; ++color) {\\n            for(Integer containedColor : graph[color]) indegree[containedColor]++;\\n        }\\n        for(int color = 1; color <= maxColor; ++color) {\\n            if(indegree[color] == 0) {\\n                q.offer(color);\\n            }\\n        }\\n        int topoLength = 0;\\n        while(!q.isEmpty()) {\\n            Integer color = q.poll();\\n            topoLength++;\\n            for(Integer containedColor : graph[color]) {\\n                if(--indegree[containedColor] == 0) {\\n                    q.offer(containedColor);\\n                }\\n            }\\n        }\\n        return topoLength == maxColor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562158,
                "title": "brute-force-straight-forward",
                "content": "# Intuition\\nWe can only print rectangles. So in order to print a non-rectangle shape, we need to print a rectangle first, and cover this rectangles with another rectangle with same color. Therefore, the last color we printed, has to be a rectangle (since we cannot cover it with other colors). Therefore, we check if the pattern contains a rectangle, if so, this is the rectangle we color in the end. Then we un-color it, finding what color could we color before coloring the last one. We repeat this process until, we could not find any rectangle (return false), or we could un-color the entire board (return true).\\n\\n# Process\\nWe just check if any rectangle exist. That is, take a color\\'s top left most x and y, and bottom right most x and y, and see if the entire rectangle is the same color. Then, we check if all grids inside this could form any other rectangle.\\n\\n# Complexity\\n- Time complexity:\\nO(CCMN), C is the number of colors, MN is the size of the board.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        map<int, set<pair<int,int>>> all_colors;\\n        for(int i = 0; i < targetGrid.size(); ++i){\\n            for(int j = 0; j < targetGrid[0].size(); ++j){\\n                all_colors[targetGrid[i][j]].insert(make_pair(i, j));\\n            }\\n        }\\n        while(true){\\n            bool could_break = true;\\n            for(auto itr = all_colors.begin(); itr != all_colors.end(); ++itr){\\n                int left_x =  61, left_y = 61;\\n                int right_x = 0, right_y = 0;\\n                for(auto jtr = itr->second.begin(); jtr != itr->second.end(); ++jtr){\\n                    left_x = min(left_x, jtr->first);\\n                    left_y = min(left_y, jtr->second);\\n                    right_x = max(right_x, jtr->first);\\n                    right_y = max(right_y, jtr->second);\\n                }\\n                cout << itr->first << \"color with \" << left_x <<\",\" << left_y << \"  \" << right_x << \",\" << right_y << endl;\\n                // we check if it forms a square\\n                bool satisfy = true;\\n                for(int i = left_x; i <= right_x; ++i){\\n                    for(int j = left_y; j <= right_y; ++j){\\n                        if(targetGrid[i][j] != itr->first && targetGrid[i][j] != -1){\\n                            satisfy = false;\\n                        }\\n                    }\\n                }\\n                if(satisfy){\\n                    could_break = false;\\n                    for(int i = left_x; i <= right_x; ++i){\\n                        for(int j = left_y; j <= right_y; ++j){\\n                            targetGrid[i][j] = -1;\\n                        }\\n                    }\\n                    all_colors.erase(itr->first);\\n                    break;\\n                }\\n            }\\n            if(could_break){\\n                break;\\n            }\\n        }\\n\\n        return all_colors.size() == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        map<int, set<pair<int,int>>> all_colors;\\n        for(int i = 0; i < targetGrid.size(); ++i){\\n            for(int j = 0; j < targetGrid[0].size(); ++j){\\n                all_colors[targetGrid[i][j]].insert(make_pair(i, j));\\n            }\\n        }\\n        while(true){\\n            bool could_break = true;\\n            for(auto itr = all_colors.begin(); itr != all_colors.end(); ++itr){\\n                int left_x =  61, left_y = 61;\\n                int right_x = 0, right_y = 0;\\n                for(auto jtr = itr->second.begin(); jtr != itr->second.end(); ++jtr){\\n                    left_x = min(left_x, jtr->first);\\n                    left_y = min(left_y, jtr->second);\\n                    right_x = max(right_x, jtr->first);\\n                    right_y = max(right_y, jtr->second);\\n                }\\n                cout << itr->first << \"color with \" << left_x <<\",\" << left_y << \"  \" << right_x << \",\" << right_y << endl;\\n                // we check if it forms a square\\n                bool satisfy = true;\\n                for(int i = left_x; i <= right_x; ++i){\\n                    for(int j = left_y; j <= right_y; ++j){\\n                        if(targetGrid[i][j] != itr->first && targetGrid[i][j] != -1){\\n                            satisfy = false;\\n                        }\\n                    }\\n                }\\n                if(satisfy){\\n                    could_break = false;\\n                    for(int i = left_x; i <= right_x; ++i){\\n                        for(int j = left_y; j <= right_y; ++j){\\n                            targetGrid[i][j] = -1;\\n                        }\\n                    }\\n                    all_colors.erase(itr->first);\\n                    break;\\n                }\\n            }\\n            if(could_break){\\n                break;\\n            }\\n        }\\n\\n        return all_colors.size() == 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3547757,
                "title": "clean-c-solution-topological-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m = targetGrid.size();\\n        int n = targetGrid[0].size();\\n\\n        //---------Creating the dependence graph-------------\\n        vector<int> inDegree(61,0);\\n        vector<vector<int>> graph(61);\\n\\n        for(int colr=1; colr<=60; colr++){\\n            // Determine the rectangle of the current color \\'colr\\'\\n            int minx = m, miny = n, maxx = -1, maxy = -1;\\n            for (int x = 0; x < m; ++x) {\\n                for (int y = 0; y < n; ++y) {\\n                    if (targetGrid[x][y] == colr) {\\n                        minx = min(x, minx);\\n                        miny = min(y, miny);\\n                        maxx = max(x, maxx);\\n                        maxy = max(y, maxy);\\n                    }\\n                }\\n            }\\n            // Add any color covering the current color as dependence\\n            for (int tx = minx; tx <= maxx; ++tx) {\\n                for (int ty = miny; ty <= maxy; ++ty) {\\n                    if (targetGrid[tx][ty] != colr){\\n                        graph[colr].push_back(targetGrid[tx][ty]);\\n                        inDegree[targetGrid[tx][ty]]++;\\n                    } \\n                }\\n            }\\n        }\\n\\n        //-------------Kahns Algo------------\\n        int visited = 0;\\n        queue<int> q;\\n        for (int colr = 1; colr <= 60; colr++) {\\n            if (inDegree[colr] == 0)\\n                q.push(colr);\\n        }\\n        \\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            visited++;\\n            for (auto& child : graph[node]) {\\n                if (!(--inDegree[child]))\\n                    q.push(child);\\n            }\\n        }\\n        return visited==60;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m = targetGrid.size();\\n        int n = targetGrid[0].size();\\n\\n        //---------Creating the dependence graph-------------\\n        vector<int> inDegree(61,0);\\n        vector<vector<int>> graph(61);\\n\\n        for(int colr=1; colr<=60; colr++){\\n            // Determine the rectangle of the current color \\'colr\\'\\n            int minx = m, miny = n, maxx = -1, maxy = -1;\\n            for (int x = 0; x < m; ++x) {\\n                for (int y = 0; y < n; ++y) {\\n                    if (targetGrid[x][y] == colr) {\\n                        minx = min(x, minx);\\n                        miny = min(y, miny);\\n                        maxx = max(x, maxx);\\n                        maxy = max(y, maxy);\\n                    }\\n                }\\n            }\\n            // Add any color covering the current color as dependence\\n            for (int tx = minx; tx <= maxx; ++tx) {\\n                for (int ty = miny; ty <= maxy; ++ty) {\\n                    if (targetGrid[tx][ty] != colr){\\n                        graph[colr].push_back(targetGrid[tx][ty]);\\n                        inDegree[targetGrid[tx][ty]]++;\\n                    } \\n                }\\n            }\\n        }\\n\\n        //-------------Kahns Algo------------\\n        int visited = 0;\\n        queue<int> q;\\n        for (int colr = 1; colr <= 60; colr++) {\\n            if (inDegree[colr] == 0)\\n                q.push(colr);\\n        }\\n        \\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            visited++;\\n            for (auto& child : graph[node]) {\\n                if (!(--inDegree[child]))\\n                    q.push(child);\\n            }\\n        }\\n        return visited==60;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367936,
                "title": "python-simple-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrintable(self, targetGrid):\\n        m, n, dict1 = len(targetGrid), len(targetGrid[0]), defaultdict(set)\\n\\n        for c in range(1,61):\\n            i_mn = j_mn = 60\\n            i_mx = j_mx = 0\\n\\n            for i in range(m):\\n                for j in range(n):\\n                    if targetGrid[i][j] == c:\\n                        i_mn = min(i_mn,i)\\n                        i_mx = max(i_mx,i)\\n                        j_mn = min(j_mn,j)\\n                        j_mx = max(j_mx,j)\\n\\n            for i in range(i_mn,i_mx+1):\\n                for j in range(j_mn,j_mx+1):\\n                    if targetGrid[i][j] != c:\\n                        dict1[c].add(targetGrid[i][j])\\n\\n        def dfs(n):\\n            if visited[n]: return visited[n] == 1\\n            visited[n] = 1\\n            if any(dfs(j) for j in dict1[n]): return True\\n            visited[n] = 2\\n            return False \\n\\n        visited = [0]*61\\n\\n        return not any(dfs(i) for i in range(61))\\n\\n\\n\\n            \\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid):\\n        m, n, dict1 = len(targetGrid), len(targetGrid[0]), defaultdict(set)\\n\\n        for c in range(1,61):\\n            i_mn = j_mn = 60\\n            i_mx = j_mx = 0\\n\\n            for i in range(m):\\n                for j in range(n):\\n                    if targetGrid[i][j] == c:\\n                        i_mn = min(i_mn,i)\\n                        i_mx = max(i_mx,i)\\n                        j_mn = min(j_mn,j)\\n                        j_mx = max(j_mx,j)\\n\\n            for i in range(i_mn,i_mx+1):\\n                for j in range(j_mn,j_mx+1):\\n                    if targetGrid[i][j] != c:\\n                        dict1[c].add(targetGrid[i][j])\\n\\n        def dfs(n):\\n            if visited[n]: return visited[n] == 1\\n            visited[n] = 1\\n            if any(dfs(j) for j in dict1[n]): return True\\n            visited[n] = 2\\n            return False \\n\\n        visited = [0]*61\\n\\n        return not any(dfs(i) for i in range(61))\\n\\n\\n\\n            \\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357689,
                "title": "c-code-with-simple-explanation-using-dfs",
                "content": "# Intuition\\nOur aim is to determine the sequence for printing colors in sub-matrices that will result in the target matrix. If such a sequence is found, return **true** otherwise, return **false**.\\n\\n# Approach\\nTo establish the order in which colors should be printed to obtain the target matrix, we must identify the top-left and bottom-right corners for each color. Colors within these sub-matrices must be printed after the sub-matrix itself.\\n\\nThis process helps us identify dependencies between colors, which can be represented as a directed graph. If this graph contains a cycle, it is impossible to find an order of colors that will result in the target matrix. However, if the graph is acyclic, we can perform a topological sort to obtain an appropriate color printing order. In this context, our main concern is to determine if a valid color printing order exists or not. \\n\\n# Complexity\\n- Time complexity: $$(n^3)$$\\n\\n- Space complexity: $$(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isCycle(int node,bool G[61][61],vector<int> &vis)\\n    {\\n        vis[node] = 2;\\n        for(int i=1;i<=60;i++)\\n        {\\n            if(G[node][i] == true && vis[i] == 2)\\n            {\\n                return true;\\n            }\\n            else if(G[node][i] == true && vis[i] == -1)\\n            {\\n                if(isCycle(i,G,vis))\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[node] = 1;\\n        return false;\\n    }\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        bool G[61][61]= {0};\\n        for(int color=1;color<=60;color++)\\n        {\\n            int minX = 61,minY = 61,maxX = -1,maxY = -1;\\n            for(int i=0;i<targetGrid.size();i++)\\n            {\\n                for(int j=0;j<targetGrid[0].size();j++)\\n                {\\n                    if(targetGrid[i][j] == color)\\n                    {\\n                        minX = min(minX,i);\\n                        minY = min(minY,j);\\n                        maxX = max(maxX,i);\\n                        maxY = max(maxY,j);\\n                    }\\n                }\\n            }\\n            for(int i=minX;i<=maxX;i++)\\n            {\\n                for(int j=minY;j<=maxY;j++)\\n                {\\n                    if(targetGrid[i][j] != color)\\n                    {\\n                        G[color][targetGrid[i][j]] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<int> vis(61,-1);\\n        for(int i=1;i<=60;i++)\\n        {\\n            if(vis[i] == -1)\\n            {\\n                if(isCycle(i,G,vis))\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCycle(int node,bool G[61][61],vector<int> &vis)\\n    {\\n        vis[node] = 2;\\n        for(int i=1;i<=60;i++)\\n        {\\n            if(G[node][i] == true && vis[i] == 2)\\n            {\\n                return true;\\n            }\\n            else if(G[node][i] == true && vis[i] == -1)\\n            {\\n                if(isCycle(i,G,vis))\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[node] = 1;\\n        return false;\\n    }\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        bool G[61][61]= {0};\\n        for(int color=1;color<=60;color++)\\n        {\\n            int minX = 61,minY = 61,maxX = -1,maxY = -1;\\n            for(int i=0;i<targetGrid.size();i++)\\n            {\\n                for(int j=0;j<targetGrid[0].size();j++)\\n                {\\n                    if(targetGrid[i][j] == color)\\n                    {\\n                        minX = min(minX,i);\\n                        minY = min(minY,j);\\n                        maxX = max(maxX,i);\\n                        maxY = max(maxY,j);\\n                    }\\n                }\\n            }\\n            for(int i=minX;i<=maxX;i++)\\n            {\\n                for(int j=minY;j<=maxY;j++)\\n                {\\n                    if(targetGrid[i][j] != color)\\n                    {\\n                        G[color][targetGrid[i][j]] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<int> vis(61,-1);\\n        for(int i=1;i<=60;i++)\\n        {\\n            if(vis[i] == -1)\\n            {\\n                if(isCycle(i,G,vis))\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354966,
                "title": "find-continuous-rectangles-iterative-approach-c",
                "content": "# Intuition\\nThe prerequisite that every color is printed not more than once leads to the central idea of this solution:\\n- The color that is printed last must form a continuous rectangle\\n\\nTherefore we can iteratively solve the problem:\\n- Find continuous rectangle in `targetGrid` with properties:\\n    - All fields are either of color `c` or `dont care`\\n    - No fields outside that rectangle are of color `c`\\n- That rectangle will be printed in color `c`: Replace all `c` with `dont care`\\n- Repeat until all colors have been eliminated or no more suchg rectangles can be found\\n- If no color remains on `targetGrid`, it can be printed by the strange printer\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(mnk^2)$$, with $$m, n$$ dimensions of grid, $$k$$ number of colors\\n\\n- Space complexity:\\n$$O(k)$$ space additional to $$O(mn)$$ for `targetGrid`\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsPrintable(int[][] targetGrid) {\\n        int m = targetGrid.Length, n = targetGrid[0].Length;\\n\\n        //this array will contain information of the smallest and \\n        //largest row, col where to find a certain color\\n        int[,] minMax = new int[61, 4];\\n\\n        //colorExists[c] indicates color c exists \\n        bool[] colorExists = new bool[61];\\n\\n        //find smallest and largest row, col where to find a certain color\\n        for(int c = 0; c < 61; c++)\\n        {\\n            minMax[c, 0] = 60;\\n            minMax[c, 2] = 60;\\n        }\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                int c = targetGrid[i][j];\\n                colorExists[c] = true;\\n                minMax[c, 0] = Math.Min(minMax[c, 0], i);\\n                minMax[c, 1] = Math.Max(minMax[c, 1], i);\\n                minMax[c, 2] = Math.Min(minMax[c, 2], j);\\n                minMax[c, 3] = Math.Max(minMax[c, 3], j);\\n            }\\n        }\\n\\n        \\n        bool change = true;\\n        while(change)\\n        {\\n            change = false;\\n            //Iterate over all colors, if they exist, check that a \\n            //continuous rectangle containing all occurences exists.\\n            //Then mark that rectangle as printed\\n            for(int c = 1; c < 61; c++)\\n            {\\n                if(!colorExists[c])\\n                    continue;\\n                //is rectangle only this color?\\n                bool isPrintable = true;\\n                for(int i = minMax[c, 0]; isPrintable && i <= minMax[c, 1]; i++)\\n                    for(int j = minMax[c, 2]; isPrintable && j <= minMax[c, 3]; j++)\\n                        if(targetGrid[i][j] != c && targetGrid[i][j] != 0)\\n                            isPrintable = false;\\n                if(!isPrintable)\\n                    continue;\\n                change = true;\\n                //Fill printable rectangle with 0 = dont care\\n                for(int i = minMax[c, 0]; i <= minMax[c, 1]; i++)\\n                    for(int j = minMax[c, 2]; j <= minMax[c, 3]; j++)\\n                        targetGrid[i][j] = 0; \\n                colorExists[c] = false;\\n            }\\n        }\\n        //return true if all colors have been eliminated\\n        return (from x in colorExists where x select x).Count() == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsPrintable(int[][] targetGrid) {\\n        int m = targetGrid.Length, n = targetGrid[0].Length;\\n\\n        //this array will contain information of the smallest and \\n        //largest row, col where to find a certain color\\n        int[,] minMax = new int[61, 4];\\n\\n        //colorExists[c] indicates color c exists \\n        bool[] colorExists = new bool[61];\\n\\n        //find smallest and largest row, col where to find a certain color\\n        for(int c = 0; c < 61; c++)\\n        {\\n            minMax[c, 0] = 60;\\n            minMax[c, 2] = 60;\\n        }\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                int c = targetGrid[i][j];\\n                colorExists[c] = true;\\n                minMax[c, 0] = Math.Min(minMax[c, 0], i);\\n                minMax[c, 1] = Math.Max(minMax[c, 1], i);\\n                minMax[c, 2] = Math.Min(minMax[c, 2], j);\\n                minMax[c, 3] = Math.Max(minMax[c, 3], j);\\n            }\\n        }\\n\\n        \\n        bool change = true;\\n        while(change)\\n        {\\n            change = false;\\n            //Iterate over all colors, if they exist, check that a \\n            //continuous rectangle containing all occurences exists.\\n            //Then mark that rectangle as printed\\n            for(int c = 1; c < 61; c++)\\n            {\\n                if(!colorExists[c])\\n                    continue;\\n                //is rectangle only this color?\\n                bool isPrintable = true;\\n                for(int i = minMax[c, 0]; isPrintable && i <= minMax[c, 1]; i++)\\n                    for(int j = minMax[c, 2]; isPrintable && j <= minMax[c, 3]; j++)\\n                        if(targetGrid[i][j] != c && targetGrid[i][j] != 0)\\n                            isPrintable = false;\\n                if(!isPrintable)\\n                    continue;\\n                change = true;\\n                //Fill printable rectangle with 0 = dont care\\n                for(int i = minMax[c, 0]; i <= minMax[c, 1]; i++)\\n                    for(int j = minMax[c, 2]; j <= minMax[c, 3]; j++)\\n                        targetGrid[i][j] = 0; \\n                colorExists[c] = false;\\n            }\\n        }\\n        //return true if all colors have been eliminated\\n        return (from x in colorExists where x select x).Count() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343962,
                "title": "python-3-very-fast-beats-100-implicit-directed-graph-search-cycle-with-dfs",
                "content": "![Capture d\\u2019\\xE9cran 2023-03-26 134650.png](https://assets.leetcode.com/users/images/b5c4690d-6d2b-41c0-998e-19ed432ebb1c_1679834845.1809278.png)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*m)$$ to find limits of rectangle of each color.\\n$$O(n*m*c)$$ to construct the graph ; $$c$$ is the number of colors.\\n$$O(c)$$ to check if there is a cycle in the graph of $$c$$ nodes\\n\\n-> $$O(n*m*c)$$\\n\\n- Space complexity:\\nrectangle is a dictionnary with $$c$$ keys and its values are lists of 4 integers.\\nto_do_after is a dictionnary with $$c$$ keys and values are sets of at most $$c$$ values.\\nstatus is a dictionnary (values are integers) of length $$c$$.\\n\\n-> $$O(c\\xB2)$$\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def isPrintable(self, grid: List[List[int]]) -> bool:      \\n        # You search limits of each color\\'s rectangle  \\n        rectangle = {}\\n        for i, row in enumerate(grid):\\n            for j, color in enumerate(row):\\n                curr = rectangle.get(color, None)\\n                if not curr:\\n                    rectangle[color] = [i, i + 1, j, j + 1]\\n                else:\\n                    if i < curr[0]:\\n                        curr[0] = i\\n                    elif i >= curr[1]:\\n                        curr[1] = i + 1\\n                    if j < curr[2]:\\n                        curr[2] = j\\n                    elif j >= curr[3]:\\n                        curr[3] = j + 1\\n                    rectangle[color] = curr\\n        \\n        # You construct the dependecies graph\\n        to_do_after = {}\\n        for c1 in rectangle.keys():\\n            x, X, y, Y = rectangle[c1]\\n            to_do_after[c1] = set()\\n            for row in grid[x: X]:\\n                for c2 in row[y: Y]:\\n                    if c2 != c1:                        \\n                        if c1 in to_do_after.get(c2, []):\\n                            return False\\n                        to_do_after[c1].add(c2)\\n        \\n        # You check if there is no cycle in the dependencies graph\\n\\n        def cycle(node):\\n            status[node] = IN_PROGRESS\\n            for nn in to_do_after[node]:\\n                if status[nn] is IN_PROGRESS:\\n                    return True\\n                elif status[nn] is NOT_VISITED:\\n                    if cycle(nn):\\n                        return True\\n            status[node] = VISITED\\n            return False\\n        \\n        NOT_VISITED, IN_PROGRESS, VISITED = 1, 2, 3\\n        status = {c: NOT_VISITED for c in to_do_after.keys()}\\n        for c in to_do_after.keys():\\n            if status[c] == NOT_VISITED and cycle(c):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n\\n    def isPrintable(self, grid: List[List[int]]) -> bool:      \\n        # You search limits of each color\\'s rectangle  \\n        rectangle = {}\\n        for i, row in enumerate(grid):\\n            for j, color in enumerate(row):\\n                curr = rectangle.get(color, None)\\n                if not curr:\\n                    rectangle[color] = [i, i + 1, j, j + 1]\\n                else:\\n                    if i < curr[0]:\\n                        curr[0] = i\\n                    elif i >= curr[1]:\\n                        curr[1] = i + 1\\n                    if j < curr[2]:\\n                        curr[2] = j\\n                    elif j >= curr[3]:\\n                        curr[3] = j + 1\\n                    rectangle[color] = curr\\n        \\n        # You construct the dependecies graph\\n        to_do_after = {}\\n        for c1 in rectangle.keys():\\n            x, X, y, Y = rectangle[c1]\\n            to_do_after[c1] = set()\\n            for row in grid[x: X]:\\n                for c2 in row[y: Y]:\\n                    if c2 != c1:                        \\n                        if c1 in to_do_after.get(c2, []):\\n                            return False\\n                        to_do_after[c1].add(c2)\\n        \\n        # You check if there is no cycle in the dependencies graph\\n\\n        def cycle(node):\\n            status[node] = IN_PROGRESS\\n            for nn in to_do_after[node]:\\n                if status[nn] is IN_PROGRESS:\\n                    return True\\n                elif status[nn] is NOT_VISITED:\\n                    if cycle(nn):\\n                        return True\\n            status[node] = VISITED\\n            return False\\n        \\n        NOT_VISITED, IN_PROGRESS, VISITED = 1, 2, 3\\n        status = {c: NOT_VISITED for c in to_do_after.keys()}\\n        for c in to_do_after.keys():\\n            if status[c] == NOT_VISITED and cycle(c):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308965,
                "title": "c-straight-forward-toposort",
                "content": "### Upvote if you Find my solution Helpful!\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInstead of filling a solid rectangle with color, we can begin solving the problem by removing the color from the rectangle.\\n\\nTo do this, we should keep track of the starting and ending coordinates of the colored area.\\nWe can only remove the color from the rectangle if it is entirely filled with the same color or if all other colors in the rectangle have already been removed.\\nThis process is similar to a topological ordering of the colors, where a specific color can only be removed once all of the colors it depends on have already been removed.\\n\\n\\n# Complexity\\n- Time complexity :   O ( n x m x 3600)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        vector<vector<int>>adj(61);\\n\\n             // 61 stuff because total number of colors can be 60\\n        vector<int>row_min(61,n),row_max(61,-1),col_min(61,m),col_max(61,-1);\\n\\n            //Getting the Corners of every colors\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                \\n                int x = targetGrid[i][j];       \\n\\n                row_min[x] = min(row_min[x],i);\\n                row_max[x] = max(row_max[x],i);\\n                col_min[x] = min(col_min[x],j);\\n                col_max[x] = max(col_max[x],j);\\n            }\\n        }\\n        \\n            // Generating my Indegree array for Toposort\\n        vector<int>inDegree(61);\\n        for(int color = 1 ; color < 61 ; color++){\\n            for(int i = row_min[color] ; i <= row_max[color] ; i++){\\n                for(int j = col_min[color] ; j <= col_max[color] ; j++){\\n                    int x = targetGrid[i][j];\\n                    if(x != color){\\n                        adj[color].push_back(x);\\n                        inDegree[x]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n            // Simple TopoSort Algorithm\\n        queue<int>q;\\n        for(int color = 1 ; color < 61 ; color++){\\n            if(inDegree[color]==0) q.push(color);\\n        }\\n\\n        int cnt =0;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            cnt++;\\n            for(auto it :adj[node]){\\n                inDegree[it]--;\\n                if(inDegree[it]==0) q.push(it);\\n            }\\n        }\\n        if(cnt!=60) return false;\\n    \\n        return true;\\n    }\\n};\\n```\\n\\n.\\n\\n.\\n\\n# Here are some Topological Sort Problems :\\n\\n\\n\\n\\n- Course Schedule : https://leetcode.com/problems/course-schedule/\\n- Course Schedule II: https://leetcode.com/problems/course-schedule-ii/\\n- Sequence Reconstruction: https://leetcode.com/problems/sequence-reconstruction/\\n- Alien Dictionary: https://leetcode.com/problems/alien-dictionary/solution/\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        vector<vector<int>>adj(61);\\n\\n             // 61 stuff because total number of colors can be 60\\n        vector<int>row_min(61,n),row_max(61,-1),col_min(61,m),col_max(61,-1);\\n\\n            //Getting the Corners of every colors\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                \\n                int x = targetGrid[i][j];       \\n\\n                row_min[x] = min(row_min[x],i);\\n                row_max[x] = max(row_max[x],i);\\n                col_min[x] = min(col_min[x],j);\\n                col_max[x] = max(col_max[x],j);\\n            }\\n        }\\n        \\n            // Generating my Indegree array for Toposort\\n        vector<int>inDegree(61);\\n        for(int color = 1 ; color < 61 ; color++){\\n            for(int i = row_min[color] ; i <= row_max[color] ; i++){\\n                for(int j = col_min[color] ; j <= col_max[color] ; j++){\\n                    int x = targetGrid[i][j];\\n                    if(x != color){\\n                        adj[color].push_back(x);\\n                        inDegree[x]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n            // Simple TopoSort Algorithm\\n        queue<int>q;\\n        for(int color = 1 ; color < 61 ; color++){\\n            if(inDegree[color]==0) q.push(color);\\n        }\\n\\n        int cnt =0;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            cnt++;\\n            for(auto it :adj[node]){\\n                inDegree[it]--;\\n                if(inDegree[it]==0) q.push(it);\\n            }\\n        }\\n        if(cnt!=60) return false;\\n    \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175080,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn is_printable(target_grid: Vec<Vec<i32>>) -> bool {\\n        use std::collections::HashSet;\\n\\n        fn has_circle(curr: usize, dep: &Vec<HashSet<i32>>, vis: &mut Vec<i32>) -> bool {\\n            vis[curr] = 1;\\n            for &d in dep[curr].iter() {\\n                let d = d as usize;\\n                if vis[d] == 2 {\\n                    continue;\\n                }\\n                if vis[d] == 1 {\\n                    return true;\\n                }\\n                if has_circle(d, dep, vis) {\\n                    return true;\\n                }\\n            }\\n            vis[curr] = 2;\\n            false\\n        }\\n\\n        let (m, n) = (target_grid.len() as i32, target_grid[0].len() as i32);\\n        let mut dep = vec![HashSet::new(); 61];\\n        for i in 1..=60 {\\n            let (mut minx, mut miny, mut maxx, mut maxy) = (m, n, -1, -1);\\n            for x in 0..m {\\n                for y in 0..n {\\n                    if target_grid[x as usize][y as usize] == i {\\n                        minx = minx.min(x);\\n                        miny = miny.min(y);\\n                        maxx = maxx.max(x);\\n                        maxy = maxy.max(y);\\n                    }\\n                }\\n            }\\n            for tx in minx..=maxx {\\n                for ty in miny..=maxy {\\n                    if target_grid[tx as usize][ty as usize] != i {\\n                        dep[i as usize].insert(target_grid[tx as usize][ty as usize]);\\n                    }\\n                }\\n            }\\n        }\\n        let mut vis = vec![0; 61];\\n        for i in 1..=60 {\\n            if vis[i] == 0 && has_circle(i, &dep, &mut vis) {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_printable(target_grid: Vec<Vec<i32>>) -> bool {\\n        use std::collections::HashSet;\\n\\n        fn has_circle(curr: usize, dep: &Vec<HashSet<i32>>, vis: &mut Vec<i32>) -> bool {\\n            vis[curr] = 1;\\n            for &d in dep[curr].iter() {\\n                let d = d as usize;\\n                if vis[d] == 2 {\\n                    continue;\\n                }\\n                if vis[d] == 1 {\\n                    return true;\\n                }\\n                if has_circle(d, dep, vis) {\\n                    return true;\\n                }\\n            }\\n            vis[curr] = 2;\\n            false\\n        }\\n\\n        let (m, n) = (target_grid.len() as i32, target_grid[0].len() as i32);\\n        let mut dep = vec![HashSet::new(); 61];\\n        for i in 1..=60 {\\n            let (mut minx, mut miny, mut maxx, mut maxy) = (m, n, -1, -1);\\n            for x in 0..m {\\n                for y in 0..n {\\n                    if target_grid[x as usize][y as usize] == i {\\n                        minx = minx.min(x);\\n                        miny = miny.min(y);\\n                        maxx = maxx.max(x);\\n                        maxy = maxy.max(y);\\n                    }\\n                }\\n            }\\n            for tx in minx..=maxx {\\n                for ty in miny..=maxy {\\n                    if target_grid[tx as usize][ty as usize] != i {\\n                        dep[i as usize].insert(target_grid[tx as usize][ty as usize]);\\n                    }\\n                }\\n            }\\n        }\\n        let mut vis = vec![0; 61];\\n        for i in 1..=60 {\\n            if vis[i] == 0 && has_circle(i, &dep, &mut vis) {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3128315,
                "title": "c-toposort",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& g) {\\n      map<int ,int >col ;\\n        int n=0 ; \\n        for(auto it : g)\\n        {\\n            for(auto itr : it)\\n            {\\n                col[itr]++ ; \\n                n = max(n , itr) ; \\n            }\\n        }\\n    int c = col.size()  ; \\n        vector<int> maxx(n+1, -1 ) , maxy(n+1 , -1 ) , minx(n+1 , 1e9) , miny(n+1 , 1e9 ) ; \\n    \\n     for(int i =0 ; i<g.size(); i++)\\n     {\\n         for(int j= 0; j<g[0].size(); j++ )\\n         {\\n            \\n             maxx[g[i][j]] = max( maxx[g[i][j]] , i ) ; \\n             maxy[g[i][j]] = max( maxy[g[i][j]] , j ) ; \\n             minx[g[i][j]] = min( minx[g[i][j]] , i ) ; \\n             miny[g[i][j]] = min(miny[g[i][j]] , j ) ;\\n         }\\n     } \\n        map<int ,vector<int>> adj ;\\n        map<int ,int > indegree; \\n        for(int k =1; k<=n; k++ )\\n        {\\n            if(col[k])\\n            for(int i = minx[k]; i<=maxx[k]; i++ )\\n            {\\n                for(int j = miny[k]; j<=maxy[k] ;j++ )\\n                {\\n                    if(g[i][j]!=k)\\n                    {\\n                        adj[k].push_back(g[i][j]) ; \\n                        indegree[g[i][j]]++; \\n                    }\\n                }\\n            }\\n        }\\n        queue<int> q; \\n        \\n        for(int i =1; i<=n; i++ )\\n        {\\n            if(indegree[i]==0 && col[i])\\n            {\\n                q.push(i); \\n                cout << i << endl; \\n            }\\n        }\\n        int sum= 0; \\n        while(!q.empty())\\n        {\\n            int node = q.front() ; \\n            q.pop() ; \\n            sum++; \\n            for(auto it : adj[node])\\n            {\\n                indegree[it]-- ; \\n                if(indegree[it]==0)\\n                {\\n                    q.push(it) ; \\n                }\\n            }\\n        }\\n        \\n        // cout << sum << endl ;\\n        return sum==c; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& g) {\\n      map<int ,int >col ;\\n        int n=0 ; \\n        for(auto it : g)\\n        {\\n            for(auto itr : it)\\n            {\\n                col[itr]++ ; \\n                n = max(n , itr) ; \\n            }\\n        }\\n    int c = col.size()  ; \\n        vector<int> maxx(n+1, -1 ) , maxy(n+1 , -1 ) , minx(n+1 , 1e9) , miny(n+1 , 1e9 ) ; \\n    \\n     for(int i =0 ; i<g.size(); i++)\\n     {\\n         for(int j= 0; j<g[0].size(); j++ )\\n         {\\n            \\n             maxx[g[i][j]] = max( maxx[g[i][j]] , i ) ; \\n             maxy[g[i][j]] = max( maxy[g[i][j]] , j ) ; \\n             minx[g[i][j]] = min( minx[g[i][j]] , i ) ; \\n             miny[g[i][j]] = min(miny[g[i][j]] , j ) ;\\n         }\\n     } \\n        map<int ,vector<int>> adj ;\\n        map<int ,int > indegree; \\n        for(int k =1; k<=n; k++ )\\n        {\\n            if(col[k])\\n            for(int i = minx[k]; i<=maxx[k]; i++ )\\n            {\\n                for(int j = miny[k]; j<=maxy[k] ;j++ )\\n                {\\n                    if(g[i][j]!=k)\\n                    {\\n                        adj[k].push_back(g[i][j]) ; \\n                        indegree[g[i][j]]++; \\n                    }\\n                }\\n            }\\n        }\\n        queue<int> q; \\n        \\n        for(int i =1; i<=n; i++ )\\n        {\\n            if(indegree[i]==0 && col[i])\\n            {\\n                q.push(i); \\n                cout << i << endl; \\n            }\\n        }\\n        int sum= 0; \\n        while(!q.empty())\\n        {\\n            int node = q.front() ; \\n            q.pop() ; \\n            sum++; \\n            for(auto it : adj[node])\\n            {\\n                indegree[it]-- ; \\n                if(indegree[it]==0)\\n                {\\n                    q.push(it) ; \\n                }\\n            }\\n        }\\n        \\n        // cout << sum << endl ;\\n        return sum==c; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3085815,
                "title": "golang-topological-sorting-easy-understanding",
                "content": "```go\\nfunc isPrintable(targetGrid [][]int) bool {\\n  // Let\\'s find the top-left and bottom-right coordinates for each color\\n  colors := make(map[int][]int)\\n  m, n := len(targetGrid), len(targetGrid[0])\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      c := targetGrid[i][j]\\n      if _, ok := colors[c]; !ok {\\n        colors[c] = []int{math.MaxInt32, math.MaxInt32, math.MinInt32, math.MinInt32}\\n      }\\n      colors[c][0] = min(colors[c][0], i)\\n      colors[c][1] = min(colors[c][1], j)\\n      colors[c][2] = max(colors[c][2], i)\\n      colors[c][3] = max(colors[c][3], j)\\n    }\\n  }\\n  // Now we\\'re going to build a graph on colors based on overlaps.\\n  overlaps := make(map[int]map[int]struct{})\\n  indegrees := make(map[int]int)\\n  for c, coords := range colors {\\n    overlaps[c] = make(map[int]struct{})\\n    for i := coords[0]; i <= coords[2]; i++ {\\n      for j := coords[1]; j <= coords[3]; j++ {\\n        c2 := targetGrid[i][j]\\n        if c != c2 {\\n          if _, ok := overlaps[c][c2]; !ok {\\n            indegrees[c2]++\\n            overlaps[c][c2] = struct{}{}\\n          }\\n        }\\n      }\\n    }\\n  }\\n  // We\\'ll do a topological sorting based on the overlaps. We start by processing\\n  // all nodes that aren\\'t overlapping with anything else. \\n  var queue []int\\n  var handled int\\n  for c := range colors {\\n    if indegrees[c] == 0 {\\n      queue = append(queue, c)\\n    }\\n  }\\n  for len(queue) > 0 {\\n    var newQueue []int\\n    for _, c := range queue {\\n      handled++\\n      for c2 := range overlaps[c] {\\n        indegrees[c2]--\\n        if indegrees[c2] == 0 {\\n          newQueue = append(newQueue, c2)\\n        }\\n      }\\n    }\\n    queue = newQueue\\n  }\\n  // Return whether we can paint all colors\\n  return handled == len(colors)\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Topological Sort"
                ],
                "code": "```go\\nfunc isPrintable(targetGrid [][]int) bool {\\n  // Let\\'s find the top-left and bottom-right coordinates for each color\\n  colors := make(map[int][]int)\\n  m, n := len(targetGrid), len(targetGrid[0])\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      c := targetGrid[i][j]\\n      if _, ok := colors[c]; !ok {\\n        colors[c] = []int{math.MaxInt32, math.MaxInt32, math.MinInt32, math.MinInt32}\\n      }\\n      colors[c][0] = min(colors[c][0], i)\\n      colors[c][1] = min(colors[c][1], j)\\n      colors[c][2] = max(colors[c][2], i)\\n      colors[c][3] = max(colors[c][3], j)\\n    }\\n  }\\n  // Now we\\'re going to build a graph on colors based on overlaps.\\n  overlaps := make(map[int]map[int]struct{})\\n  indegrees := make(map[int]int)\\n  for c, coords := range colors {\\n    overlaps[c] = make(map[int]struct{})\\n    for i := coords[0]; i <= coords[2]; i++ {\\n      for j := coords[1]; j <= coords[3]; j++ {\\n        c2 := targetGrid[i][j]\\n        if c != c2 {\\n          if _, ok := overlaps[c][c2]; !ok {\\n            indegrees[c2]++\\n            overlaps[c][c2] = struct{}{}\\n          }\\n        }\\n      }\\n    }\\n  }\\n  // We\\'ll do a topological sorting based on the overlaps. We start by processing\\n  // all nodes that aren\\'t overlapping with anything else. \\n  var queue []int\\n  var handled int\\n  for c := range colors {\\n    if indegrees[c] == 0 {\\n      queue = append(queue, c)\\n    }\\n  }\\n  for len(queue) > 0 {\\n    var newQueue []int\\n    for _, c := range queue {\\n      handled++\\n      for c2 := range overlaps[c] {\\n        indegrees[c2]--\\n        if indegrees[c2] == 0 {\\n          newQueue = append(newQueue, c2)\\n        }\\n      }\\n    }\\n    queue = newQueue\\n  }\\n  // Return whether we can paint all colors\\n  return handled == len(colors)\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3043147,
                "title": "python-construct-graph-and-detect-cycle-in-the-directed-graph-easy-implementation",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        minRow, maxRow = defaultdict(lambda: math.inf), defaultdict(lambda:-math.inf)\\n        minCol, maxCol = defaultdict(lambda: math.inf), defaultdict(lambda:-math.inf)\\n\\n        # Part 1 - Finding left/right/top/bottom boundaries of a rectangular color block\\n        M, N = len(targetGrid), len(targetGrid[0])\\n        for i in range(M):\\n            for j in range(N):\\n                color = targetGrid[i][j]\\n                minRow[color], maxRow[color] = min(minRow[color], i), max(maxRow[color], i)\\n                minCol[color], maxCol[color] = min(minCol[color], j), max(maxCol[color], j)\\n        \\n        # Part 2 - Creation of Graph\\n        G = defaultdict(list)\\n        for color in minRow.keys():\\n            for i in range(minRow[color], maxRow[color] + 1):\\n                for j in range(minCol[color], maxCol[color] + 1):\\n                    if targetGrid[i][j] != color:\\n                        G[targetGrid[i][j]].append(color)\\n        \\n        # Part 3 - Cycle Detection Helper Function\\n        def dfs_cycle(node):\\n            visited.add(node)\\n            dfs_visited.add(node)\\n            for nei in G[node]:\\n                if nei in visited and nei in dfs_visited: return True\\n                if nei not in visited:\\n                    if dfs_cycle(nei): return True\\n            dfs_visited.remove(node)\\n            return False\\n\\n        # Part 4 - Cycle Detection in a Directed Graph\\n        visited, dfs_visited = set(), set()\\n        for color in minRow.keys():\\n            if color not in visited:\\n                if dfs_cycle(color):\\n                    return False  \\n        return True\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        minRow, maxRow = defaultdict(lambda: math.inf), defaultdict(lambda:-math.inf)\\n        minCol, maxCol = defaultdict(lambda: math.inf), defaultdict(lambda:-math.inf)\\n\\n        # Part 1 - Finding left/right/top/bottom boundaries of a rectangular color block\\n        M, N = len(targetGrid), len(targetGrid[0])\\n        for i in range(M):\\n            for j in range(N):\\n                color = targetGrid[i][j]\\n                minRow[color], maxRow[color] = min(minRow[color], i), max(maxRow[color], i)\\n                minCol[color], maxCol[color] = min(minCol[color], j), max(maxCol[color], j)\\n        \\n        # Part 2 - Creation of Graph\\n        G = defaultdict(list)\\n        for color in minRow.keys():\\n            for i in range(minRow[color], maxRow[color] + 1):\\n                for j in range(minCol[color], maxCol[color] + 1):\\n                    if targetGrid[i][j] != color:\\n                        G[targetGrid[i][j]].append(color)\\n        \\n        # Part 3 - Cycle Detection Helper Function\\n        def dfs_cycle(node):\\n            visited.add(node)\\n            dfs_visited.add(node)\\n            for nei in G[node]:\\n                if nei in visited and nei in dfs_visited: return True\\n                if nei not in visited:\\n                    if dfs_cycle(nei): return True\\n            dfs_visited.remove(node)\\n            return False\\n\\n        # Part 4 - Cycle Detection in a Directed Graph\\n        visited, dfs_visited = set(), set()\\n        for color in minRow.keys():\\n            if color not in visited:\\n                if dfs_cycle(color):\\n                    return False  \\n        return True\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010297,
                "title": "c-topology-sort-o-n-2-k",
                "content": "# Intuition\\n\\nEach priting rectangle is a layer on the paper. If we treat each layer as a node in a graph, the overlapping relation is an edge from the back layer to the front layer. If the layers could be sorted topologically, the print is valid.\\n\\n![strange-printer-ii.excalidraw.png](https://assets.leetcode.com/users/images/6554a929-79ae-4ecc-b75f-0b38b94be240_1673030311.190599.png)\\n\\n\\n\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n\\n    vector<int> colors;\\n    vector<int> nodes;\\n    vector<vector<int>> layers;\\n    vector<unordered_set<int>> adj;\\n    vector<int> in_degree;\\n    vector<vector<int>> * _grid;\\n\\n    void init_size(int k)\\n    {\\n        colors.resize(k);\\n        layers.resize(k);\\n        adj.resize(k);\\n        in_degree.resize(k, 0);\\n        nodes.resize(61);\\n    }\\n\\n    void build(int u)\\n    {\\n        const auto & r = layers[u];\\n        int self_color = colors[u];\\n        vector<vector<int>> & grid = *_grid;\\n        for (int i = r[0]; i <= r[1]; i++)\\n        {\\n            for (int j = r[2]; j <= r[3]; j++)\\n            {\\n                if (grid[i][j] != self_color)\\n                {\\n                    int v = nodes[grid[i][j]];\\n                    adj[u].insert(v);\\n                }\\n            }\\n        }\\n\\n        for (auto v : adj[u])\\n        {\\n            in_degree[v] ++;\\n        }\\n    }\\n\\n    void topology_sort(int k)\\n    {\\n        queue<int> q;\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (in_degree[i] == 0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n\\n        vector<bool> visited(k, false);\\n        while (!q.empty())\\n        {\\n            int u = q.front();\\n            q.pop();\\n            if (visited[u]) {continue;}\\n            visited[u] = true;\\n\\n            for (auto v : adj[u])\\n            {\\n                in_degree[v] --;\\n                if (in_degree[v] == 0)\\n                {\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        unordered_map<int, vector<int>> rect;\\n        int m = grid.size(), n = grid[0].size();\\n        _grid = &grid;\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int color = grid[i][j];\\n                if (rect.find(color) == rect.end())\\n                {\\n                    // {top, bottom, left, right}\\n                    rect[color] = {m, -1, n, -1};\\n                }\\n                vector<int> & r = rect[color];\\n                r[0] = std::min(r[0], i);\\n                r[1] = std::max(r[1], i);\\n                r[2] = std::min(r[2], j);\\n                r[3] = std::max(r[3], j);\\n            }\\n        }\\n\\n        int k = rect.size();\\n        init_size(k);\\n        int i = 0;\\n        for (const auto & [color, r] : rect)\\n        {\\n            colors[i] = color;\\n            layers[i] = r;\\n            nodes[color] = i;\\n            i++;\\n        }\\n\\n        for (int u = 0; u < k; u++)\\n        {\\n            build(u);\\n        }\\n\\n        topology_sort(k);\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (in_degree[i] > 0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n\\n    vector<int> colors;\\n    vector<int> nodes;\\n    vector<vector<int>> layers;\\n    vector<unordered_set<int>> adj;\\n    vector<int> in_degree;\\n    vector<vector<int>> * _grid;\\n\\n    void init_size(int k)\\n    {\\n        colors.resize(k);\\n        layers.resize(k);\\n        adj.resize(k);\\n        in_degree.resize(k, 0);\\n        nodes.resize(61);\\n    }\\n\\n    void build(int u)\\n    {\\n        const auto & r = layers[u];\\n        int self_color = colors[u];\\n        vector<vector<int>> & grid = *_grid;\\n        for (int i = r[0]; i <= r[1]; i++)\\n        {\\n            for (int j = r[2]; j <= r[3]; j++)\\n            {\\n                if (grid[i][j] != self_color)\\n                {\\n                    int v = nodes[grid[i][j]];\\n                    adj[u].insert(v);\\n                }\\n            }\\n        }\\n\\n        for (auto v : adj[u])\\n        {\\n            in_degree[v] ++;\\n        }\\n    }\\n\\n    void topology_sort(int k)\\n    {\\n        queue<int> q;\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (in_degree[i] == 0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n\\n        vector<bool> visited(k, false);\\n        while (!q.empty())\\n        {\\n            int u = q.front();\\n            q.pop();\\n            if (visited[u]) {continue;}\\n            visited[u] = true;\\n\\n            for (auto v : adj[u])\\n            {\\n                in_degree[v] --;\\n                if (in_degree[v] == 0)\\n                {\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        unordered_map<int, vector<int>> rect;\\n        int m = grid.size(), n = grid[0].size();\\n        _grid = &grid;\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int color = grid[i][j];\\n                if (rect.find(color) == rect.end())\\n                {\\n                    // {top, bottom, left, right}\\n                    rect[color] = {m, -1, n, -1};\\n                }\\n                vector<int> & r = rect[color];\\n                r[0] = std::min(r[0], i);\\n                r[1] = std::max(r[1], i);\\n                r[2] = std::min(r[2], j);\\n                r[3] = std::max(r[3], j);\\n            }\\n        }\\n\\n        int k = rect.size();\\n        init_size(k);\\n        int i = 0;\\n        for (const auto & [color, r] : rect)\\n        {\\n            colors[i] = color;\\n            layers[i] = r;\\n            nodes[color] = i;\\n            i++;\\n        }\\n\\n        for (int u = 0; u < k; u++)\\n        {\\n            build(u);\\n        }\\n\\n        topology_sort(k);\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (in_degree[i] > 0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005109,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[][]} targetGrid\\n * @return {boolean}\\n */\\nvar isPrintable = function (targetGrid) {\\n  const n = targetGrid.length;\\n  const m = targetGrid[0].length;\\n  let map = {};\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < m; j++) {\\n      const color = targetGrid[i][j];\\n      if (!(color in map)) {\\n        map[color] = {\\n          top: i,\\n          left: j,\\n          down: i,\\n          right: j,\\n        };\\n      } else {\\n        map[color].top = Math.min(map[color].top, i);\\n        map[color].left = Math.min(map[color].left, j);\\n        map[color].down = Math.max(map[color].down, i);\\n        map[color].right = Math.max(map[color].right, j);\\n      }\\n    }\\n  }\\n\\n  while (Object.keys(map).length > 0) {\\n    const next = {};\\n    for (const color in map) {\\n      if (!canPrint(map[color], color, targetGrid)) {\\n        next[color] = map[color];\\n      }\\n    }\\n    if (Object.keys(next).length === Object.keys(map).length) {\\n      return false;\\n    }\\n    map = next;\\n  }\\n  return true;\\n};\\n\\nfunction canPrint(position, color, targetGrid) {\\n  const { top, left, down, right } = position;\\n  for (let i = top; i <= down; i++) {\\n    for (let j = left; j <= right; j++) {\\n      if (targetGrid[i][j] > 0 && targetGrid[i][j] !== Number(color)) {\\n        return false;\\n      }\\n    }\\n  }\\n\\n  for (let i = top; i <= down; i++) {\\n    for (let j = left; j <= right; j++) {\\n      targetGrid[i][j] = 0;\\n    }\\n  }\\n  return true;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} targetGrid\\n * @return {boolean}\\n */\\nvar isPrintable = function (targetGrid) {\\n  const n = targetGrid.length;\\n  const m = targetGrid[0].length;\\n  let map = {};\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < m; j++) {\\n      const color = targetGrid[i][j];\\n      if (!(color in map)) {\\n        map[color] = {\\n          top: i,\\n          left: j,\\n          down: i,\\n          right: j,\\n        };\\n      } else {\\n        map[color].top = Math.min(map[color].top, i);\\n        map[color].left = Math.min(map[color].left, j);\\n        map[color].down = Math.max(map[color].down, i);\\n        map[color].right = Math.max(map[color].right, j);\\n      }\\n    }\\n  }\\n\\n  while (Object.keys(map).length > 0) {\\n    const next = {};\\n    for (const color in map) {\\n      if (!canPrint(map[color], color, targetGrid)) {\\n        next[color] = map[color];\\n      }\\n    }\\n    if (Object.keys(next).length === Object.keys(map).length) {\\n      return false;\\n    }\\n    map = next;\\n  }\\n  return true;\\n};\\n\\nfunction canPrint(position, color, targetGrid) {\\n  const { top, left, down, right } = position;\\n  for (let i = top; i <= down; i++) {\\n    for (let j = left; j <= right; j++) {\\n      if (targetGrid[i][j] > 0 && targetGrid[i][j] !== Number(color)) {\\n        return false;\\n      }\\n    }\\n  }\\n\\n  for (let i = top; i <= down; i++) {\\n    for (let j = left; j <= right; j++) {\\n      targetGrid[i][j] = 0;\\n    }\\n  }\\n  return true;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2990155,
                "title": "python-keep-unpaint-untill-canvas-is-blank",
                "content": "# Code\\r\\n``` python\\r\\nclass Solution:\\r\\n    def isPrintable(self, targetGrid):\\r\\n        R, C, limits = len(mat), len(mat[0]), dict()\\r\\n\\r\\n        for i in range(R):  # using corners of color dict as color\\'s set as well\\r\\n            for j in range(C):\\r\\n                color = mat[i][j]\\r\\n                if color not in limits: limits[color] = [R, C, 0, 0]\\r\\n                limits[color][0] = min(limits[color][0], i)  # min row\\r\\n                limits[color][1] = min(limits[color][1], j)  # max col\\r\\n                limits[color][2] = max(limits[color][2], i)  # min row\\r\\n                limits[color][3] = max(limits[color][3], j)  # max col\\r\\n\\r\\n        def unpaint(color) -> bool:\\r\\n            # test range of color\\r\\n            r, c, R, C = limits[color]\\r\\n            for i in range(r, R + 1):\\r\\n                for j in range(c, C + 1):\\r\\n                    if mat[i][j] not in [0, color]: return False\\r\\n            # unpaint\\r\\n            for i in range(r, R + 1):\\r\\n                for j in range(c, C + 1):\\r\\n                    mat[i][j] = 0\\r\\n\\r\\n            return True\\r\\n\\r\\n        while limits.keys():\\r\\n            unpainted = list(filter(unpaint, limits.keys()))\\r\\n            if not unpainted: return False\\r\\n            for color in unpainted:\\r\\n                del limits[color]\\r\\n\\r\\n        return True\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` python\\r\\nclass Solution:\\r\\n    def isPrintable(self, targetGrid):\\r\\n        R, C, limits = len(mat), len(mat[0]), dict()\\r\\n\\r\\n        for i in range(R):  # using corners of color dict as color\\'s set as well\\r\\n            for j in range(C):\\r\\n                color = mat[i][j]\\r\\n                if color not in limits: limits[color] = [R, C, 0, 0]\\r\\n                limits[color][0] = min(limits[color][0], i)  # min row\\r\\n                limits[color][1] = min(limits[color][1], j)  # max col\\r\\n                limits[color][2] = max(limits[color][2], i)  # min row\\r\\n                limits[color][3] = max(limits[color][3], j)  # max col\\r\\n\\r\\n        def unpaint(color) -> bool:\\r\\n            # test range of color\\r\\n            r, c, R, C = limits[color]\\r\\n            for i in range(r, R + 1):\\r\\n                for j in range(c, C + 1):\\r\\n                    if mat[i][j] not in [0, color]: return False\\r\\n            # unpaint\\r\\n            for i in range(r, R + 1):\\r\\n                for j in range(c, C + 1):\\r\\n                    mat[i][j] = 0\\r\\n\\r\\n            return True\\r\\n\\r\\n        while limits.keys():\\r\\n            unpainted = list(filter(unpaint, limits.keys()))\\r\\n            if not unpainted: return False\\r\\n            for color in unpainted:\\r\\n                del limits[color]\\r\\n\\r\\n        return True\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2922174,
                "title": "spend-whole-day-on-this-question-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    void dfs(set<ll>adj[],vector<vector<ll>>&cord,ll current,vector<vector<int>>& targetGrid){\\n        ll up_row=cord[current][0],down_row=cord[current][1],left_col=cord[current][2],right_col=cord[current][3];\\n        for(ll i=up_row;i<=down_row;i++){\\n            for(ll j=left_col;j<=right_col;j++){\\n                if(targetGrid[i][j]!=current){\\n                    adj[current].insert(targetGrid[i][j]);\\n                }\\n            }\\n        }\\n        return;\\n    }\\n\\n    bool checkcycle(set<ll>adj[],ll current,vector<bool>&visited){\\n        visited[current]=true;\\n        for(auto &x:adj[current]){\\n            if(visited[x]==true){\\n                return true;\\n            }\\n            else{\\n                if(checkcycle(adj,x,visited)){\\n                    return true;\\n                }\\n            }\\n        }\\n        visited[current]=false;\\n        return false;\\n    }\\n\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        ll n=targetGrid.size(),m=targetGrid[0].size();\\n        vector<ll>mp(61,0);\\n        vector<vector<ll>>cord(61,vector<ll>(4));\\n        set<ll>adj[61];\\n        for(ll i=1;i<=60;i++){\\n            for(ll j=0;j<=3;j++){\\n                if(j==0 || j==2){\\n                    cord[i][j]=INT_MAX;\\n                }\\n                else{\\n                    cord[i][j]=INT_MIN;\\n                }\\n            }\\n        }\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                mp[targetGrid[i][j]]++;\\n                cord[targetGrid[i][j]][0]=min(cord[targetGrid[i][j]][0],(ll)i);\\n                cord[targetGrid[i][j]][1]=max(cord[targetGrid[i][j]][1],(ll)i);\\n                cord[targetGrid[i][j]][2]=min(cord[targetGrid[i][j]][2],(ll)j);\\n                cord[targetGrid[i][j]][3]=max(cord[targetGrid[i][j]][3],(ll)j);\\n            }\\n        }\\n        for(ll i=1;i<=60;i++){\\n            if(mp[i]>0){\\n                dfs(adj,cord,i,targetGrid);\\n            }\\n        }\\n        vector<bool>visited(61,false);\\n        for(ll i=1;i<=60;i++){\\n            if(mp[i]>0){\\n                if(checkcycle(adj,i,visited)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    void dfs(set<ll>adj[],vector<vector<ll>>&cord,ll current,vector<vector<int>>& targetGrid){\\n        ll up_row=cord[current][0],down_row=cord[current][1],left_col=cord[current][2],right_col=cord[current][3];\\n        for(ll i=up_row;i<=down_row;i++){\\n            for(ll j=left_col;j<=right_col;j++){\\n                if(targetGrid[i][j]!=current){\\n                    adj[current].insert(targetGrid[i][j]);\\n                }\\n            }\\n        }\\n        return;\\n    }\\n\\n    bool checkcycle(set<ll>adj[],ll current,vector<bool>&visited){\\n        visited[current]=true;\\n        for(auto &x:adj[current]){\\n            if(visited[x]==true){\\n                return true;\\n            }\\n            else{\\n                if(checkcycle(adj,x,visited)){\\n                    return true;\\n                }\\n            }\\n        }\\n        visited[current]=false;\\n        return false;\\n    }\\n\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        ll n=targetGrid.size(),m=targetGrid[0].size();\\n        vector<ll>mp(61,0);\\n        vector<vector<ll>>cord(61,vector<ll>(4));\\n        set<ll>adj[61];\\n        for(ll i=1;i<=60;i++){\\n            for(ll j=0;j<=3;j++){\\n                if(j==0 || j==2){\\n                    cord[i][j]=INT_MAX;\\n                }\\n                else{\\n                    cord[i][j]=INT_MIN;\\n                }\\n            }\\n        }\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                mp[targetGrid[i][j]]++;\\n                cord[targetGrid[i][j]][0]=min(cord[targetGrid[i][j]][0],(ll)i);\\n                cord[targetGrid[i][j]][1]=max(cord[targetGrid[i][j]][1],(ll)i);\\n                cord[targetGrid[i][j]][2]=min(cord[targetGrid[i][j]][2],(ll)j);\\n                cord[targetGrid[i][j]][3]=max(cord[targetGrid[i][j]][3],(ll)j);\\n            }\\n        }\\n        for(ll i=1;i<=60;i++){\\n            if(mp[i]>0){\\n                dfs(adj,cord,i,targetGrid);\\n            }\\n        }\\n        vector<bool>visited(61,false);\\n        for(ll i=1;i<=60;i++){\\n            if(mp[i]>0){\\n                if(checkcycle(adj,i,visited)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914080,
                "title": "c-47ms-greedy",
                "content": "# Intuition\\nFirst try to find the $$(start-cord, end-cord)$$ fr each color. Now the last color say $$k$$ which was used by printer must have all cells in $$(start-cord(k), end-cord(k))$$ of color $$k$$. So just greedily remove color one by one. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the $$start$$ and $$end$$ co-ordinates for all the colors. This can be done in $$O(nm)$$. Then greedily check for every color wheter it have valid cell. Then remove it greedily. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nlet the total colors be $$k$$. Then time complexit is $$O(nmk^2)$$ but if we assume that $$k = O(n)$$ then it becomes $$O(n^3m)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check_color(vector<vector<int>>& t, pair<int,int> s, pair<int,int> e, int c){\\n\\n        for(int i = s.first; i <= e.first; i++){\\n            for(int j = s.second; j <= e.second; j++){\\n                //cout << c <<\" \"<<t[i][j]<<\" \"<<i <<\" \"<<j << endl;\\n                if(t[i][j] != c && t[i][j] != -1){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    void fill(vector<vector<int>>& t, pair<int,int> s, pair<int,int> e){\\n\\n        for(int i = s.first; i <= e.first; i++){\\n            for(int j = s.second; j <= e.second; j++){\\n                t[i][j] = -1;\\n            }\\n        }\\n    }\\n\\n    bool isPrintable(vector<vector<int>>& t) {\\n        \\n        //the start and end locations for colours\\n        unordered_map<int, pair<int,int>> start;\\n        unordered_map<int, pair<int,int>> end;\\n\\n        //now just iterate\\n        int n = t.size();\\n        int m = t[0].size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                int c = t[i][j];\\n                \\n                //find the start\\n                auto start_it = start.find(c);\\n                auto end_it = end.find(c);\\n\\n                //start pair and end pair\\n                pair<int,int> start_c;\\n                pair<int,int> end_c;\\n                \\n                if(start_it == start.end()){\\n                    start_c = make_pair(INT_MAX, INT_MAX);\\n                }\\n                else{\\n                    start_c = start_it->second;\\n                }\\n\\n                if(end_it == end.end()){\\n                    end_c = make_pair(INT_MIN, INT_MIN);\\n                }\\n                else{\\n                    end_c = end_it->second;\\n                }\\n\\n                start_c = make_pair(min(i, start_c.first), min(j, start_c.second));\\n                end_c = make_pair(max(i, end_c.first), max(j, end_c.second));\\n\\n                start[c] = start_c;\\n                end[c] = end_c;\\n            }\\n        }\\n\\n        //  for(auto it = start.begin(); it != start.end(); it++){\\n        //     int c = it->first;\\n        //     pair<int, int> t = it->second;\\n        //     cout << c <<\": \"<<t.first <<\",\"<<t.second;\\n        //     t = end[c];\\n        //     cout <<\" - \"<<t.first <<\",\"<<t.second<<endl;\\n        // }\\n\\n        while(true){\\n            bool changed = false;\\n            for(auto it = start.begin(); it != start.end(); it++){\\n                int c = it->first;\\n                pair<int,int> s = it->second;\\n                pair<int,int> e = end[c];\\n\\n                if(check_color(t, s, e, c)){\\n                    fill(t,s,e);\\n                    changed = true;\\n                    start.erase(it);\\n                    end.erase(c);\\n                    break;\\n                }\\n            }\\n            if(!changed){\\n                return false;\\n            }\\n            if(start.size() == 0){\\n                return true;\\n            }\\n        }\\n\\n        return false;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool check_color(vector<vector<int>>& t, pair<int,int> s, pair<int,int> e, int c){\\n\\n        for(int i = s.first; i <= e.first; i++){\\n            for(int j = s.second; j <= e.second; j++){\\n                //cout << c <<\" \"<<t[i][j]<<\" \"<<i <<\" \"<<j << endl;\\n                if(t[i][j] != c && t[i][j] != -1){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    void fill(vector<vector<int>>& t, pair<int,int> s, pair<int,int> e){\\n\\n        for(int i = s.first; i <= e.first; i++){\\n            for(int j = s.second; j <= e.second; j++){\\n                t[i][j] = -1;\\n            }\\n        }\\n    }\\n\\n    bool isPrintable(vector<vector<int>>& t) {\\n        \\n        //the start and end locations for colours\\n        unordered_map<int, pair<int,int>> start;\\n        unordered_map<int, pair<int,int>> end;\\n\\n        //now just iterate\\n        int n = t.size();\\n        int m = t[0].size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                int c = t[i][j];\\n                \\n                //find the start\\n                auto start_it = start.find(c);\\n                auto end_it = end.find(c);\\n\\n                //start pair and end pair\\n                pair<int,int> start_c;\\n                pair<int,int> end_c;\\n                \\n                if(start_it == start.end()){\\n                    start_c = make_pair(INT_MAX, INT_MAX);\\n                }\\n                else{\\n                    start_c = start_it->second;\\n                }\\n\\n                if(end_it == end.end()){\\n                    end_c = make_pair(INT_MIN, INT_MIN);\\n                }\\n                else{\\n                    end_c = end_it->second;\\n                }\\n\\n                start_c = make_pair(min(i, start_c.first), min(j, start_c.second));\\n                end_c = make_pair(max(i, end_c.first), max(j, end_c.second));\\n\\n                start[c] = start_c;\\n                end[c] = end_c;\\n            }\\n        }\\n\\n        //  for(auto it = start.begin(); it != start.end(); it++){\\n        //     int c = it->first;\\n        //     pair<int, int> t = it->second;\\n        //     cout << c <<\": \"<<t.first <<\",\"<<t.second;\\n        //     t = end[c];\\n        //     cout <<\" - \"<<t.first <<\",\"<<t.second<<endl;\\n        // }\\n\\n        while(true){\\n            bool changed = false;\\n            for(auto it = start.begin(); it != start.end(); it++){\\n                int c = it->first;\\n                pair<int,int> s = it->second;\\n                pair<int,int> e = end[c];\\n\\n                if(check_color(t, s, e, c)){\\n                    fill(t,s,e);\\n                    changed = true;\\n                    start.erase(it);\\n                    end.erase(c);\\n                    break;\\n                }\\n            }\\n            if(!changed){\\n                return false;\\n            }\\n            if(start.size() == 0){\\n                return true;\\n            }\\n        }\\n\\n        return false;   \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2873114,
                "title": "python-simple-topological-sort-o-c-m-n",
                "content": "```\\nclass Solution:\\n    def isPrintable(self, tg: List[List[int]]) -> bool:\\n        n = len(tg);\\n        m = len(tg[0]);\\n        cr = dict()\\n        for i in range(n):\\n            for j in range(m):\\n                c = tg[i][j];\\n                if(c not in cr):\\n                    cr[c] = [[i,j],[i,j]] # start y,x and end y,x\\n                else:\\n                    cr[c][0][0] = min(i,cr[c][0][0])\\n                    cr[c][0][1] = min(j,cr[c][0][1])\\n                    cr[c][1][0] = max(i,cr[c][1][0])\\n                    cr[c][1][1] = max(j,cr[c][1][1])\\n        colors = {c:i for i,c in enumerate(cr.keys())};\\n        adj = [[False]*len(colors) for i in range(len(colors))]\\n        for c in colors:\\n            u = colors[c]\\n            for i in range(cr[c][0][0],cr[c][1][0]+1):\\n                for j in range(cr[c][0][1],cr[c][1][1]+1):\\n                    v = colors[tg[i][j]]\\n                    if(u!=v):\\n                        adj[u][v] = True;\\n        \\n        visited = 0\\n        hasCycle = False\\n        target = (1<<len(colors))-1\\n        def dfs(u,vis):\\n            nonlocal hasCycle, visited\\n            visited |= (1<<u)\\n            for v in range(len(colors)):\\n                if(adj[u][v]):\\n                    if((vis&(1<<v))>0):\\n                        hasCycle = True\\n                    if(not hasCycle and (visited&(1<<v))==0):\\n                        dfs(v,vis | (1<<v))\\n        for u in range(len(colors)):\\n            if((visited&(1<<u))==0):\\n                dfs(u,1<<u);\\n                if(hasCycle): return False\\n                if(visited==target): return True\\n        return False\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, tg: List[List[int]]) -> bool:\\n        n = len(tg);\\n        m = len(tg[0]);\\n        cr = dict()\\n        for i in range(n):\\n            for j in range(m):\\n                c = tg[i][j];\\n                if(c not in cr):\\n                    cr[c] = [[i,j],[i,j]] # start y,x and end y,x\\n                else:\\n                    cr[c][0][0] = min(i,cr[c][0][0])\\n                    cr[c][0][1] = min(j,cr[c][0][1])\\n                    cr[c][1][0] = max(i,cr[c][1][0])\\n                    cr[c][1][1] = max(j,cr[c][1][1])\\n        colors = {c:i for i,c in enumerate(cr.keys())};\\n        adj = [[False]*len(colors) for i in range(len(colors))]\\n        for c in colors:\\n            u = colors[c]\\n            for i in range(cr[c][0][0],cr[c][1][0]+1):\\n                for j in range(cr[c][0][1],cr[c][1][1]+1):\\n                    v = colors[tg[i][j]]\\n                    if(u!=v):\\n                        adj[u][v] = True;\\n        \\n        visited = 0\\n        hasCycle = False\\n        target = (1<<len(colors))-1\\n        def dfs(u,vis):\\n            nonlocal hasCycle, visited\\n            visited |= (1<<u)\\n            for v in range(len(colors)):\\n                if(adj[u][v]):\\n                    if((vis&(1<<v))>0):\\n                        hasCycle = True\\n                    if(not hasCycle and (visited&(1<<v))==0):\\n                        dfs(v,vis | (1<<v))\\n        for u in range(len(colors)):\\n            if((visited&(1<<u))==0):\\n                dfs(u,1<<u);\\n                if(hasCycle): return False\\n                if(visited==target): return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851318,
                "title": "c-cycle-detect",
                "content": "```\\nbool hasCircle(int curr, vector<int>& vis, unordered_map<int, unordered_set<int>>& adj_list){\\n        vis[curr] = 1;\\n        for (const int d : adj_list[curr]) {\\n            if (vis[d] == 2) continue;\\n            if (vis[d] == 1) return true;\\n            if (hasCircle(d, vis, adj_list)) return true;\\n        }\\n        vis[curr] = 2;\\n        return false;\\n    }\\n    \\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m = targetGrid.size();\\n        int n = targetGrid[0].size();\\n        unordered_set<int> set_of_nums;\\n        int max_num = INT_MIN;\\n        using pos = pair<int, int>; //row, col\\n        unordered_map<int, pair<pos, pos>> M;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (M.find(targetGrid[i][j]) != M.end()) {\\n                    pair<pos,pos> p = M[targetGrid[i][j]];\\n                    M.erase(targetGrid[i][j]);\\n                    if (p.second.second > j) \\n                        M.insert(make_pair(targetGrid[i][j], make_pair(make_pair(p.first.first, j), make_pair(i, p.second.second))));\\n                    else \\n                        M.insert(make_pair(targetGrid[i][j], make_pair(p.first, make_pair(i, j))));\\n                }\\n                else {\\n                    M[targetGrid[i][j]] = {{i,j}, {i, j}};\\n                    set_of_nums.insert(targetGrid[i][j]);\\n                    max_num = std::max(max_num, targetGrid[i][j]);\\n                }\\n            }\\n        }\\n                \\n        unordered_map<int, unordered_set<int>> adj_list;\\n        for (auto& elem: M) {\\n            int curr = elem.first;\\n            pos start_pos = elem.second.first;\\n            pos end_pos = elem.second.second;\\n            for (int i = start_pos.first; i <= end_pos.first; i++) {\\n                for (int j = start_pos.second; j <= end_pos.second; j++) {\\n                    if (targetGrid[i][j] != curr) \\n                            adj_list[curr].insert(targetGrid[i][j]);\\n                }\\n            }\\n        }\\n        vector<int> visited(max_num  + 1, 0);\\n        for (int num : set_of_nums) {\\n            if (!visited[num] && hasCircle(num, visited, adj_list)) {\\n                 return false;\\n            }\\n        } \\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nbool hasCircle(int curr, vector<int>& vis, unordered_map<int, unordered_set<int>>& adj_list){\\n        vis[curr] = 1;\\n        for (const int d : adj_list[curr]) {\\n            if (vis[d] == 2) continue;\\n            if (vis[d] == 1) return true;\\n            if (hasCircle(d, vis, adj_list)) return true;\\n        }\\n        vis[curr] = 2;\\n        return false;\\n    }\\n    \\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m = targetGrid.size();\\n        int n = targetGrid[0].size();\\n        unordered_set<int> set_of_nums;\\n        int max_num = INT_MIN;\\n        using pos = pair<int, int>; //row, col\\n        unordered_map<int, pair<pos, pos>> M;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (M.find(targetGrid[i][j]) != M.end()) {\\n                    pair<pos,pos> p = M[targetGrid[i][j]];\\n                    M.erase(targetGrid[i][j]);\\n                    if (p.second.second > j) \\n                        M.insert(make_pair(targetGrid[i][j], make_pair(make_pair(p.first.first, j), make_pair(i, p.second.second))));\\n                    else \\n                        M.insert(make_pair(targetGrid[i][j], make_pair(p.first, make_pair(i, j))));\\n                }\\n                else {\\n                    M[targetGrid[i][j]] = {{i,j}, {i, j}};\\n                    set_of_nums.insert(targetGrid[i][j]);\\n                    max_num = std::max(max_num, targetGrid[i][j]);\\n                }\\n            }\\n        }\\n                \\n        unordered_map<int, unordered_set<int>> adj_list;\\n        for (auto& elem: M) {\\n            int curr = elem.first;\\n            pos start_pos = elem.second.first;\\n            pos end_pos = elem.second.second;\\n            for (int i = start_pos.first; i <= end_pos.first; i++) {\\n                for (int j = start_pos.second; j <= end_pos.second; j++) {\\n                    if (targetGrid[i][j] != curr) \\n                            adj_list[curr].insert(targetGrid[i][j]);\\n                }\\n            }\\n        }\\n        vector<int> visited(max_num  + 1, 0);\\n        for (int num : set_of_nums) {\\n            if (!visited[num] && hasCircle(num, visited, adj_list)) {\\n                 return false;\\n            }\\n        } \\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2799454,
                "title": "topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int n=targetGrid.size(),m=targetGrid[0].size();\\n        vector<int> v[61];\\n        vector<int> present(61,false);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int val=targetGrid[i][j];\\n                present[val]=true;\\n                if(v[val].size()==0){\\n                    vector<int> temp={i,i,j,j};\\n                    v[val]=temp;\\n                }\\n                else{\\n                    if(v[val][0]>i){v[val][0]=i;}\\n                    if(v[val][1]<i){v[val][1]=i;}\\n                    if(v[val][2]>j){v[val][2]=j;}\\n                    if(v[val][3]<j){v[val][3]=j;}\\n                }\\n            }\\n        }\\n        unordered_set<int> adj[61];\\n        for(int k=1;k<=60;k++){\\n            if(v[k].size()==0){continue;}\\n            int rs=v[k][0],re=v[k][1],cs=v[k][2],ce=v[k][3];\\n            for(int i=rs;i<=re;i++){\\n                for(int j=cs;j<=ce;j++){\\n                    int val=targetGrid[i][j];\\n                    if(val!=k){\\n                        adj[val].insert(k);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> indeg(61,0);\\n        for(int i=1;i<=60;i++){\\n            for(int u:adj[i]){\\n                indeg[u]++;\\n            }\\n        }\\n        queue<int> q;\\n        int count1=0;\\n        for(int i=1;i<=60;i++){\\n            if(present[i]){count1++;}\\n            if(indeg[i]==0 && present[i]){\\n                q.push(i);\\n            }\\n        }\\n        int count=0;\\n        while(!q.empty()){\\n            int u=q.front();q.pop();\\n            count++;\\n            for(int v:adj[u]){\\n                indeg[v]--;\\n                if(indeg[v]==0){\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        return count==count1;\\n    }\\n};",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int n=targetGrid.size(),m=targetGrid[0].size();\\n        vector<int> v[61];\\n        vector<int> present(61,false);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int val=targetGrid[i][j];\\n                present[val]=true;\\n                if(v[val].size()==0){\\n                    vector<int> temp={i,i,j,j}",
                "codeTag": "Java"
            },
            {
                "id": 2717470,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    vi(ll)vis;\\n    bool func(const vi(vi(ll))&g, ll nd){ // detect cycle\\n        if(vis[nd]==1){\\n            return 1;\\n        }\\n        if(vis[nd]==2){\\n            return 0;\\n        }\\n        vis[nd]=1;\\n        for(ll child:g[nd]){\\n            if(func(g, child)){\\n                return 1;\\n            }\\n        }\\n        vis[nd]=2;\\n        return 0;\\n    }\\n    bool isPrintable(vector<vector<int>>&v) {\\n        vi(vi(ll))g(61);\\n        ll m=v.size(), n=v[0].size();\\n        for(ll i=1;i<=60;++i){\\n            ll mnx=m, mny=n, mxx=-1, mxy=-1; //  min, max, x, y, blah blah...\\n            for(ll j=0;j<m;++j){\\n                for(ll k=0;k<n;++k){\\n                    if(v[j][k]==i){\\n                        mnx=min(mnx, j), mny=min(mny, k), mxx=max(mxx, j), mxy=max(mxy, k);\\n                    }\\n                }\\n            }\\n            for(ll r=mnx;r<=mxx;++r){\\n                for(ll c=mny;c<=mxy;++c){\\n                    if(v[r][c]!=i){\\n                        g[i].pb(v[r][c]);\\n                    }\\n                }\\n            }\\n        }\\n        vis.assign(61, 0);\\n        for(ll nd=1;nd<=60;++nd){\\n            if(!vis[nd] && func(g, nd)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    vi(ll)vis;\\n    bool func(const vi(vi(ll))&g, ll nd){ // detect cycle\\n        if(vis[nd]==1){\\n            return 1;\\n        }\\n        if(vis[nd]==2){\\n            return 0;\\n        }\\n        vis[nd]=1;\\n        for(ll child:g[nd]){\\n            if(func(g, child)){\\n                return 1;\\n            }\\n        }\\n        vis[nd]=2;\\n        return 0;\\n    }\\n    bool isPrintable(vector<vector<int>>&v) {\\n        vi(vi(ll))g(61);\\n        ll m=v.size(), n=v[0].size();\\n        for(ll i=1;i<=60;++i){\\n            ll mnx=m, mny=n, mxx=-1, mxy=-1; //  min, max, x, y, blah blah...\\n            for(ll j=0;j<m;++j){\\n                for(ll k=0;k<n;++k){\\n                    if(v[j][k]==i){\\n                        mnx=min(mnx, j), mny=min(mny, k), mxx=max(mxx, j), mxy=max(mxy, k);\\n                    }\\n                }\\n            }\\n            for(ll r=mnx;r<=mxx;++r){\\n                for(ll c=mny;c<=mxy;++c){\\n                    if(v[r][c]!=i){\\n                        g[i].pb(v[r][c]);\\n                    }\\n                }\\n            }\\n        }\\n        vis.assign(61, 0);\\n        for(ll nd=1;nd<=60;++nd){\\n            if(!vis[nd] && func(g, nd)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700331,
                "title": "o-mn-c-no-need-to-actually-repaint-grid-topological-sort-is-trying-too-hard",
                "content": "```\\nclass Solution:\\n    def isPrintable(self, G: List[List[int]]) -> bool:\\n        m = len(G)\\n        n = len(G[0])\\n        # 1) Find \"bounding box\" of each color. Boxes might overlap.\\n        box = dict()\\n        for i in range(m):\\n            for j in range(n):\\n                color = G[i][j]\\n                if color not in box:\\n                    box[color] = [i,j,i,j]\\n                else:\\n                    p = box[color]\\n                    p[:] = min(p[0],i), min(p[1],j), max(p[2],i), max(p[3],j)\\n        # 2) For each cell (i,j), any neighbor that has a different color\\n        #    but is in my color\\'s bounding box must be painted after me.\\n        over = 61*[0]\\n        under = defaultdict(set)\\n        for i in range(m):\\n            for j in range(n):\\n                c = G[i][j]\\n                p = box[c]\\n                for a,b in [ (i-1,j), (i+1,j), (i,j-1), (i,j+1) ]:\\n                    if p[0] <= a <= p[2] and p[1] <= b <= p[3] and G[a][b] != c and c not in under[G[a][b]]:\\n                        over[c] += 1\\n                        under[G[a][b]].add(c)\\n        # 3) Repeatedly unpaint each color that has no other color over its box.\\n        q = [c for c in range(1,len(over)) if not over[c]]\\n        while q:\\n            top = q.pop()\\n            for c in under[top]:\\n                over[c] -= 1\\n                if over[c] == 0:\\n                    q.append(c)\\n        return not any(over)\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, G: List[List[int]]) -> bool:\\n        m = len(G)\\n        n = len(G[0])\\n        # 1) Find \"bounding box\" of each color. Boxes might overlap.\\n        box = dict()\\n        for i in range(m):\\n            for j in range(n):\\n                color = G[i][j]\\n                if color not in box:\\n                    box[color] = [i,j,i,j]\\n                else:\\n                    p = box[color]\\n                    p[:] = min(p[0],i), min(p[1],j), max(p[2],i), max(p[3],j)\\n        # 2) For each cell (i,j), any neighbor that has a different color\\n        #    but is in my color\\'s bounding box must be painted after me.\\n        over = 61*[0]\\n        under = defaultdict(set)\\n        for i in range(m):\\n            for j in range(n):\\n                c = G[i][j]\\n                p = box[c]\\n                for a,b in [ (i-1,j), (i+1,j), (i,j-1), (i,j+1) ]:\\n                    if p[0] <= a <= p[2] and p[1] <= b <= p[3] and G[a][b] != c and c not in under[G[a][b]]:\\n                        over[c] += 1\\n                        under[G[a][b]].add(c)\\n        # 3) Repeatedly unpaint each color that has no other color over its box.\\n        q = [c for c in range(1,len(over)) if not over[c]]\\n        while q:\\n            top = q.pop()\\n            for c in under[top]:\\n                over[c] -= 1\\n                if over[c] == 0:\\n                    q.append(c)\\n        return not any(over)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661798,
                "title": "java-t-o-mn-c-only-check-neighbors-in-4-dirctions",
                "content": "```\\nprivate boolean sln5(int[][] t){\\n        int m = t.length;\\n        int n = t[0].length;\\n        int colorSize = 61;\\n        Set<Integer>[] es = new Set[colorSize];\\n        int[][] cs = new int[colorSize][4];\\n        int[] deg = new int[colorSize];\\n        int[][] dirs = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int i = 0;i<colorSize;i++){\\n            cs[i][0] = m;\\n            cs[i][1] = n;\\n            cs[i][2] = -1;\\n            cs[i][3] = -1;\\n            es[i] = new HashSet<>();\\n        }\\n        for(int i =0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                cs[t[i][j]][0] = Math.min(i, cs[t[i][j]][0]);\\n                cs[t[i][j]][1] = Math.min(j, cs[t[i][j]][1]);\\n                cs[t[i][j]][2] = Math.max(i, cs[t[i][j]][2]);\\n                cs[t[i][j]][3] = Math.max(j, cs[t[i][j]][3]);\\n            }\\n        }\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                int c1 = t[i][j];\\n                for(int[] d: dirs){\\n                    int ni = i+d[0];\\n                    int nj = j+d[1];\\n                    if(ni<0 || nj<0 || ni==m || nj==n || t[i][j] == t[ni][nj]) continue;\\n                    int c2 = t[ni][nj];\\n                    if(cs[c1][0] <= ni && cs[c1][1] <= nj && cs[c1][2] >= ni && cs[c1][3] >= nj){\\n                        if(!es[c1].contains(c2)){\\n                            es[c1].add(c2);\\n                            deg[c2]++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        Deque<Integer> que = new ArrayDeque<>();\\n        for(int i = 0;i<colorSize;i++){\\n            if(deg[i]==0) que.addLast(i);\\n        }\\n        while(que.size()>0){\\n            int curr = que.removeFirst();\\n            colorSize--;\\n            for(int next: es[curr]){\\n                deg[next]--;\\n                if(deg[next]==0) que.addLast(next);\\n            }\\n        }\\n        return colorSize==0;\\n    }",
                "solutionTags": [],
                "code": "```\\nprivate boolean sln5(int[][] t){\\n        int m = t.length;\\n        int n = t[0].length;\\n        int colorSize = 61;\\n        Set<Integer>[] es = new Set[colorSize];\\n        int[][] cs = new int[colorSize][4];\\n        int[] deg = new int[colorSize];\\n        int[][] dirs = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int i = 0;i<colorSize;i++){\\n            cs[i][0] = m;\\n            cs[i][1] = n;\\n            cs[i][2] = -1;\\n            cs[i][3] = -1;\\n            es[i] = new HashSet<>();\\n        }\\n        for(int i =0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                cs[t[i][j]][0] = Math.min(i, cs[t[i][j]][0]);\\n                cs[t[i][j]][1] = Math.min(j, cs[t[i][j]][1]);\\n                cs[t[i][j]][2] = Math.max(i, cs[t[i][j]][2]);\\n                cs[t[i][j]][3] = Math.max(j, cs[t[i][j]][3]);\\n            }\\n        }\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                int c1 = t[i][j];\\n                for(int[] d: dirs){\\n                    int ni = i+d[0];\\n                    int nj = j+d[1];\\n                    if(ni<0 || nj<0 || ni==m || nj==n || t[i][j] == t[ni][nj]) continue;\\n                    int c2 = t[ni][nj];\\n                    if(cs[c1][0] <= ni && cs[c1][1] <= nj && cs[c1][2] >= ni && cs[c1][3] >= nj){\\n                        if(!es[c1].contains(c2)){\\n                            es[c1].add(c2);\\n                            deg[c2]++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        Deque<Integer> que = new ArrayDeque<>();\\n        for(int i = 0;i<colorSize;i++){\\n            if(deg[i]==0) que.addLast(i);\\n        }\\n        while(que.size()>0){\\n            int curr = que.removeFirst();\\n            colorSize--;\\n            for(int next: es[curr]){\\n                deg[next]--;\\n                if(deg[next]==0) que.addLast(next);\\n            }\\n        }\\n        return colorSize==0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2648045,
                "title": "simple-greedy-approach-no-graphs-explained-python",
                "content": "```\\n   def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        #Greedy Approach:\\n        #instead of figuring out correct color order to paint from first to last\\n        #figure out the order from last to first by removing most recent painted layer\\n        #if u think about it most_recent_painted layer should not interact with any other layers\\n        #since it doesnt interact with other colors, u can remove it move on to different color without any consequence\\n        #if you can strip all the colors, then its possible to paint the matrix\\n        \\n        m = len(targetGrid); n = len(targetGrid[0])\\n        #we need to know the bounds of each color\\n        bounds = [[m, -1, n, -1] for _ in range(61)]#there are 60 colors (1 to 60)\\n        for i in range(m):\\n            for j in range(n):\\n                color = targetGrid[i][j]\\n                bounds[color][0] = min(bounds[color][0], i)\\n                bounds[color][1] = max(bounds[color][1], i)\\n                bounds[color][2] = min(bounds[color][2], j)\\n                bounds[color][3] = max(bounds[color][3], j)\\n        \\n        def canRemove(color):\\n            for i in range(bounds[color][0], bounds[color][1] + 1):\\n                for j in range(bounds[color][2], bounds[color][3] + 1):\\n                    #u cant remove this color, because there is another color sitting on it\\n                    if targetGrid[i][j] and targetGrid[i][j] != color:\\n                        return False\\n            #you can remove this color layer, because there is no another color on it\\n            for i in range(bounds[color][0], bounds[color][1] + 1):\\n                for j in range(bounds[color][2], bounds[color][3] + 1):\\n                    #u cant remove this color, because there is another color sitting on it\\n                    targetGrid[i][j] = 0\\n            return True\\n        \\n        colors = list(range(1, 61))\\n        \\n        #if we assume only one color is removed at a time\\n        #so size of colors goes from 60->59->58->......->2->1->0\\n        #so Time->O(m*n* (60 + 59 + .... + 1)) = O(m*n*colors^2)\\n        #space is O(colors)\\n        while colors:\\n            toDo = []\\n            for color in colors:\\n                if not canRemove(color):\\n                    toDo.append(color)\\n            \\n            #we havnt been able to remove a single color, so its not possible to paint the matrix\\n            if len(toDo) == len(colors):\\n                return False\\n            \\n            colors = toDo #if there is nothing in toDo that means all color layers were removed\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n   def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        #Greedy Approach:\\n        #instead of figuring out correct color order to paint from first to last\\n        #figure out the order from last to first by removing most recent painted layer\\n        #if u think about it most_recent_painted layer should not interact with any other layers\\n        #since it doesnt interact with other colors, u can remove it move on to different color without any consequence\\n        #if you can strip all the colors, then its possible to paint the matrix\\n        \\n        m = len(targetGrid); n = len(targetGrid[0])\\n        #we need to know the bounds of each color\\n        bounds = [[m, -1, n, -1] for _ in range(61)]#there are 60 colors (1 to 60)\\n        for i in range(m):\\n            for j in range(n):\\n                color = targetGrid[i][j]\\n                bounds[color][0] = min(bounds[color][0], i)\\n                bounds[color][1] = max(bounds[color][1], i)\\n                bounds[color][2] = min(bounds[color][2], j)\\n                bounds[color][3] = max(bounds[color][3], j)\\n        \\n        def canRemove(color):\\n            for i in range(bounds[color][0], bounds[color][1] + 1):\\n                for j in range(bounds[color][2], bounds[color][3] + 1):\\n                    #u cant remove this color, because there is another color sitting on it\\n                    if targetGrid[i][j] and targetGrid[i][j] != color:\\n                        return False\\n            #you can remove this color layer, because there is no another color on it\\n            for i in range(bounds[color][0], bounds[color][1] + 1):\\n                for j in range(bounds[color][2], bounds[color][3] + 1):\\n                    #u cant remove this color, because there is another color sitting on it\\n                    targetGrid[i][j] = 0\\n            return True\\n        \\n        colors = list(range(1, 61))\\n        \\n        #if we assume only one color is removed at a time\\n        #so size of colors goes from 60->59->58->......->2->1->0\\n        #so Time->O(m*n* (60 + 59 + .... + 1)) = O(m*n*colors^2)\\n        #space is O(colors)\\n        while colors:\\n            toDo = []\\n            for color in colors:\\n                if not canRemove(color):\\n                    toDo.append(color)\\n            \\n            #we havnt been able to remove a single color, so its not possible to paint the matrix\\n            if len(toDo) == len(colors):\\n                return False\\n            \\n            colors = toDo #if there is nothing in toDo that means all color layers were removed\\n        \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2640520,
                "title": "my-first-intuitive-c-recursive-solution-removing-layers-backwards-33ms",
                "content": "```\\nclass Solution {\\n    struct GridBounds {\\n        int left = -1;\\n        int right = -1;\\n        int upper = -1;\\n        int lower = -1;\\n        int color = -1;        \\n    };\\n\\npublic:\\n    bool isPrintable(std::vector<std::vector<int>>& targetGrid) {\\n        bool ret = true;\\n        std::unordered_set<int> underlying_colors;\\n        for (int i = 0; i < targetGrid.size(); ++i) {\\n            if (ret == false) {\\n                return false;\\n            }\\n            auto it = std::find_if_not(targetGrid[i].begin(), targetGrid[i].end(), [](int color) {\\n                return color == -1;\\n                                       });\\n            if (it == targetGrid[i].end()) {\\n                if (i == targetGrid.size() - 1) {\\n                    break;\\n                }\\n                continue;\\n            }            \\n            ret = isSolid(targetGrid, GetBounds(targetGrid, *it), underlying_colors);\\n            i = 0;\\n        }\\n        return ret;\\n    }\\n\\nprivate:\\n    GridBounds GetBounds(std::vector<std::vector<int>>& t, int color) {\\n        GridBounds bounds;\\n        bounds.color = color;\\n        auto Checker = [color](int col) {\\n            return col == color;\\n        };\\n        for (auto v_it = t.begin(); v_it != t.end(); ++v_it) {\\n            auto it = std::find_if(v_it->begin(), v_it->end(), Checker);\\n            if (it == v_it->end()) {\\n                continue;\\n            }\\n            if (bounds.upper == -1) {\\n                bounds.upper = v_it - t.begin();\\n            }\\n            bounds.lower = v_it - t.begin();\\n            bounds.left = bounds.left == -1 ? std::distance(v_it->begin(), it) : std::min(bounds.left, static_cast<int>(std::distance(v_it->begin(), it)));\\n            auto r_it = std::find_if(v_it->rbegin(), v_it->rend(), Checker);\\n            bounds.right = bounds.right == -1 ? std::distance(v_it->begin(), r_it.base() - 1) : std::max(bounds.right, static_cast<int>(std::distance(v_it->begin(), r_it.base() - 1)));\\n        }\\n        return bounds;\\n    }\\n\\n    bool isSolid(std::vector<std::vector<int>>& t, GridBounds grid, std::unordered_set<int>& underlying_colors) {\\n        int this_color = grid.color;\\n        for (int y = grid.upper; y <= grid.lower; ++y) {\\n            for (int x = grid.left; x <= grid.right; ++x) {\\n                if (underlying_colors.count(t[y][x]) != 0) {\\n                    return false;\\n                }\\n                if (t[y][x] == -1) {\\n                    continue;\\n                }\\n                if (t[y][x] != this_color) {\\n                    underlying_colors.insert(this_color);\\n                    if (isSolid(t, GetBounds(t, t[y][x]), underlying_colors)) {                        \\n                        underlying_colors.erase(this_color);\\n                    }\\n                    else {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        MarkDeleted(t, grid);\\n        return true;\\n    }\\n\\n    void MarkDeleted(std::vector<std::vector<int>>& t, GridBounds grid) {\\n        for (int y = grid.upper; y <= grid.lower; ++y) {\\n            for (int x = grid.left; x <= grid.right; ++x) {\\n                t[y][x] = -1;\\n            }\\n        }\\n    }\\n};\\n```\\n\\nMy first try without looking into common solution with Graphs. Anyway going to study and understand other ways))",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    struct GridBounds {\\n        int left = -1;\\n        int right = -1;\\n        int upper = -1;\\n        int lower = -1;\\n        int color = -1;        \\n    };\\n\\npublic:\\n    bool isPrintable(std::vector<std::vector<int>>& targetGrid) {\\n        bool ret = true;\\n        std::unordered_set<int> underlying_colors;\\n        for (int i = 0; i < targetGrid.size(); ++i) {\\n            if (ret == false) {\\n                return false;\\n            }\\n            auto it = std::find_if_not(targetGrid[i].begin(), targetGrid[i].end(), [](int color) {\\n                return color == -1;\\n                                       });\\n            if (it == targetGrid[i].end()) {\\n                if (i == targetGrid.size() - 1) {\\n                    break;\\n                }\\n                continue;\\n            }            \\n            ret = isSolid(targetGrid, GetBounds(targetGrid, *it), underlying_colors);\\n            i = 0;\\n        }\\n        return ret;\\n    }\\n\\nprivate:\\n    GridBounds GetBounds(std::vector<std::vector<int>>& t, int color) {\\n        GridBounds bounds;\\n        bounds.color = color;\\n        auto Checker = [color](int col) {\\n            return col == color;\\n        };\\n        for (auto v_it = t.begin(); v_it != t.end(); ++v_it) {\\n            auto it = std::find_if(v_it->begin(), v_it->end(), Checker);\\n            if (it == v_it->end()) {\\n                continue;\\n            }\\n            if (bounds.upper == -1) {\\n                bounds.upper = v_it - t.begin();\\n            }\\n            bounds.lower = v_it - t.begin();\\n            bounds.left = bounds.left == -1 ? std::distance(v_it->begin(), it) : std::min(bounds.left, static_cast<int>(std::distance(v_it->begin(), it)));\\n            auto r_it = std::find_if(v_it->rbegin(), v_it->rend(), Checker);\\n            bounds.right = bounds.right == -1 ? std::distance(v_it->begin(), r_it.base() - 1) : std::max(bounds.right, static_cast<int>(std::distance(v_it->begin(), r_it.base() - 1)));\\n        }\\n        return bounds;\\n    }\\n\\n    bool isSolid(std::vector<std::vector<int>>& t, GridBounds grid, std::unordered_set<int>& underlying_colors) {\\n        int this_color = grid.color;\\n        for (int y = grid.upper; y <= grid.lower; ++y) {\\n            for (int x = grid.left; x <= grid.right; ++x) {\\n                if (underlying_colors.count(t[y][x]) != 0) {\\n                    return false;\\n                }\\n                if (t[y][x] == -1) {\\n                    continue;\\n                }\\n                if (t[y][x] != this_color) {\\n                    underlying_colors.insert(this_color);\\n                    if (isSolid(t, GetBounds(t, t[y][x]), underlying_colors)) {                        \\n                        underlying_colors.erase(this_color);\\n                    }\\n                    else {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        MarkDeleted(t, grid);\\n        return true;\\n    }\\n\\n    void MarkDeleted(std::vector<std::vector<int>>& t, GridBounds grid) {\\n        for (int y = grid.upper; y <= grid.lower; ++y) {\\n            for (int x = grid.left; x <= grid.right; ++x) {\\n                t[y][x] = -1;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632686,
                "title": "c-straight-forward-less-space",
                "content": "Here below is my solution (without topological sort; it\\'s still a bit hard for me :D)\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        vector<vector<int>>& tg = targetGrid;\\n        map<int, pair<pair<int, int>, pair<int, int>>> color;\\n        const int m = tg.size(), n = tg[0].size();\\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                if(color.count(tg[i][j])){\\n                    auto &range = color[tg[i][j]];\\n                    auto &p1 = range.first, &p2 = range.second;\\n                    int &x1 = p1.first, &y1 = p1.second;\\n                    int &x2 = p2.first, &y2 = p2.second;\\n                    if(i < x1) x1 = i;\\n                    else if(i > x2)  x2 = i;\\n                    if(j < y1) y1 = j;\\n                    else if(j > y2)  y2 = j;\\n                }else\\n                    color[tg[i][j]] = {{i, j}, {i, j}};\\n            }\\n        }\\n        bool running = true;\\n        while(running && !color.empty()){\\n            running = false;\\n            for(auto [c, p]: color){\\n                auto p1 = p.first, p2 = p.second;\\n                int x1 = p1.first, y1 = p1.second;\\n                int x2 = p2.first, y2 = p2.second;\\n                bool valid = true;\\n                for(int i = 0; valid && i < m; ++i){\\n                    for(int j = 0; valid && j < n; ++j){\\n                        bool inRange = i >= x1 && i <= x2 && j >= y1 && j <= y2;\\n                        bool isColor = tg[i][j] == c;\\n                        bool isZero = tg[i][j] == 0;\\n                        if((inRange && !isColor && !isZero) || (!inRange && isColor))\\n                            valid = false;\\n                    }\\n                }\\n                if(valid){\\n                    color.erase(c);\\n                    for(int i = x1; i <= x2; ++i)\\n                        for(int j = y1; j <= y2; ++j)\\n                            tg[i][j] = 0;\\n                    running = true;\\n\\t\\t\\t\\t\\tbreak;\\n                }\\n            }\\n            if(!running)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        vector<vector<int>>& tg = targetGrid;\\n        map<int, pair<pair<int, int>, pair<int, int>>> color;\\n        const int m = tg.size(), n = tg[0].size();\\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                if(color.count(tg[i][j])){\\n                    auto &range = color[tg[i][j]];\\n                    auto &p1 = range.first, &p2 = range.second;\\n                    int &x1 = p1.first, &y1 = p1.second;\\n                    int &x2 = p2.first, &y2 = p2.second;\\n                    if(i < x1) x1 = i;\\n                    else if(i > x2)  x2 = i;\\n                    if(j < y1) y1 = j;\\n                    else if(j > y2)  y2 = j;\\n                }else\\n                    color[tg[i][j]] = {{i, j}, {i, j}};\\n            }\\n        }\\n        bool running = true;\\n        while(running && !color.empty()){\\n            running = false;\\n            for(auto [c, p]: color){\\n                auto p1 = p.first, p2 = p.second;\\n                int x1 = p1.first, y1 = p1.second;\\n                int x2 = p2.first, y2 = p2.second;\\n                bool valid = true;\\n                for(int i = 0; valid && i < m; ++i){\\n                    for(int j = 0; valid && j < n; ++j){\\n                        bool inRange = i >= x1 && i <= x2 && j >= y1 && j <= y2;\\n                        bool isColor = tg[i][j] == c;\\n                        bool isZero = tg[i][j] == 0;\\n                        if((inRange && !isColor && !isZero) || (!inRange && isColor))\\n                            valid = false;\\n                    }\\n                }\\n                if(valid){\\n                    color.erase(c);\\n                    for(int i = x1; i <= x2; ++i)\\n                        for(int j = y1; j <= y2; ++j)\\n                            tg[i][j] = 0;\\n                    running = true;\\n\\t\\t\\t\\t\\tbreak;\\n                }\\n            }\\n            if(!running)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602857,
                "title": "straightforward-python-solution",
                "content": "```\\nclass Solution:\\n    def isPrintable(self, grid: List[List[int]]) -> bool:\\n        R, C = len(grid), len(grid[0])\\n        V = 60\\n        adj = [[] for v in range(V)]\\n        d = collections.defaultdict(lambda: [[R, C], [-1, -1], set()])  # color: [start, end, set of all points of this color]\\n        \\n        # make the hashmap `d`\\n        for color in range(60):\\n            for r in range(R):\\n                for c in range(C):\\n                    cur = d[color]\\n                    start, end, pts = cur\\n                    if grid[r][c] - 1 == color:\\n                        start[0] = min(start[0], r)\\n                        start[1] = min(start[1], c)\\n                        end[0] = max(end[0], r)\\n                        end[1] = max(end[1], c)\\n                        pts.add((r, c))\\n        \\n        # make the dependencies i.e. the order in which colors must occur to be able to satisfy printer\\'s requirements\\n        for color1 in range(60):\\n            for color2 in range(60):\\n                if color1 == color2: continue\\n                color1_pts = d[color1][2]\\n                color2_start, color2_end, color2_pts = d[color2]\\n                for pt in color1_pts:\\n                    r, c = pt\\n                    r1, c1 = color2_start\\n                    r2, c2 = color2_end\\n                    if r1 <= r <= r2 and c1 <= c <= c2:\\n                        adj[color2].append(color1)\\n                        break\\n        \\n        # Check if there is an inconsistant order of colors i.e., if there is a cycle in our directed graph, return False\\n        def isCycle(s, visited1, visited2):\\n            visited1[s] = True\\n            visited2[s] = True\\n            for v in adj[s]:\\n                if visited2[v]:\\n                    return True\\n                if not visited1[v]:\\n                    if isCycle(v, visited1, visited2):\\n                        return True\\n            visited2[s] = False\\n            return False\\n        \\n        visited1 = [False] * V\\n        visited2 = [False] * V\\n        for v in range(V):\\n            if not visited1[v]:\\n                if isCycle(v, visited1, visited2):\\n                    return False\\n        \\n        return True\\n```\\n        \\n                    \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, grid: List[List[int]]) -> bool:\\n        R, C = len(grid), len(grid[0])\\n        V = 60\\n        adj = [[] for v in range(V)]\\n        d = collections.defaultdict(lambda: [[R, C], [-1, -1], set()])  # color: [start, end, set of all points of this color]\\n        \\n        # make the hashmap `d`\\n        for color in range(60):\\n            for r in range(R):\\n                for c in range(C):\\n                    cur = d[color]\\n                    start, end, pts = cur\\n                    if grid[r][c] - 1 == color:\\n                        start[0] = min(start[0], r)\\n                        start[1] = min(start[1], c)\\n                        end[0] = max(end[0], r)\\n                        end[1] = max(end[1], c)\\n                        pts.add((r, c))\\n        \\n        # make the dependencies i.e. the order in which colors must occur to be able to satisfy printer\\'s requirements\\n        for color1 in range(60):\\n            for color2 in range(60):\\n                if color1 == color2: continue\\n                color1_pts = d[color1][2]\\n                color2_start, color2_end, color2_pts = d[color2]\\n                for pt in color1_pts:\\n                    r, c = pt\\n                    r1, c1 = color2_start\\n                    r2, c2 = color2_end\\n                    if r1 <= r <= r2 and c1 <= c <= c2:\\n                        adj[color2].append(color1)\\n                        break\\n        \\n        # Check if there is an inconsistant order of colors i.e., if there is a cycle in our directed graph, return False\\n        def isCycle(s, visited1, visited2):\\n            visited1[s] = True\\n            visited2[s] = True\\n            for v in adj[s]:\\n                if visited2[v]:\\n                    return True\\n                if not visited1[v]:\\n                    if isCycle(v, visited1, visited2):\\n                        return True\\n            visited2[s] = False\\n            return False\\n        \\n        visited1 = [False] * V\\n        visited2 = [False] * V\\n        for v in range(V):\\n            if not visited1[v]:\\n                if isCycle(v, visited1, visited2):\\n                    return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568783,
                "title": "java-70-faster-o-m-n-k-k-number-of-times-printer-used",
                "content": "\\tMap<Integer, int[]> idxMap =new HashMap<>();\\n    int[][] grid;\\n    public boolean isPrintable(int[][] targetGrid) {\\n        int m = targetGrid.length;\\n        int n = targetGrid[0].length;\\n        grid = targetGrid;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int val = targetGrid[i][j];\\n                if(idxMap.containsKey(val)) {\\n                    int[] co_or = idxMap.get(val);\\n                    co_or[0] = Math.min(co_or[0], i); // min I\\n                    co_or[1] = Math.max(co_or[1], i); // max I\\n                    co_or[2] = Math.min(co_or[2], j); // min J\\n                    co_or[3] = Math.max(co_or[3], j); // max J\\n                } else {\\n                    idxMap.put(val, new int[]{i, i, j, j});\\n                }\\n            }\\n        }\\n        \\n        Set<Integer> finished = new HashSet<>();\\n        boolean validated = true;\\n        while(!allDone(targetGrid) && validated) {\\n            validated = false;\\n            for(Integer key : idxMap.keySet()) {\\n                if(!finished.contains(key)) {\\n                    if(isRectangle(key, idxMap.get(key))) {\\n                        finished.add(key);\\n                        validated = true;\\n                    }\\n                }\\n            }\\n        }\\n        return allDone(targetGrid);\\n    }\\n                   \\n    public boolean isRectangle(Integer key, int[] limits) {\\n        boolean validRectangle = true;\\n        for(int i=limits[0]; i<=limits[1]; i++) {\\n            for(int j=limits[2]; j<=limits[3]; j++) {\\n                if(grid[i][j] != -1 && grid[i][j] != key) {\\n                    validRectangle = false;\\n                }\\n            }\\n        }\\n        if(validRectangle) {\\n            for(int i=limits[0]; i<=limits[1]; i++) {\\n                for(int j=limits[2]; j<=limits[3]; j++) {\\n                    grid[i][j] = -1;\\n                }\\n            }\\n        }\\n        return validRectangle;\\n    }\\n    \\n    public boolean allDone(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] != -1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "\\tMap<Integer, int[]> idxMap =new HashMap<>();\\n    int[][] grid;\\n    public boolean isPrintable(int[][] targetGrid) {\\n        int m = targetGrid.length;\\n        int n = targetGrid[0].length;\\n        grid = targetGrid;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int val = targetGrid[i][j];\\n                if(idxMap.containsKey(val)) {\\n                    int[] co_or = idxMap.get(val);\\n                    co_or[0] = Math.min(co_or[0], i); // min I\\n                    co_or[1] = Math.max(co_or[1], i); // max I\\n                    co_or[2] = Math.min(co_or[2], j); // min J\\n                    co_or[3] = Math.max(co_or[3], j); // max J\\n                } else {\\n                    idxMap.put(val, new int[]{i, i, j, j});\\n                }\\n            }\\n        }\\n        \\n        Set<Integer> finished = new HashSet<>();\\n        boolean validated = true;\\n        while(!allDone(targetGrid) && validated) {\\n            validated = false;\\n            for(Integer key : idxMap.keySet()) {\\n                if(!finished.contains(key)) {\\n                    if(isRectangle(key, idxMap.get(key))) {\\n                        finished.add(key);\\n                        validated = true;\\n                    }\\n                }\\n            }\\n        }\\n        return allDone(targetGrid);\\n    }\\n                   \\n    public boolean isRectangle(Integer key, int[] limits) {\\n        boolean validRectangle = true;\\n        for(int i=limits[0]; i<=limits[1]; i++) {\\n            for(int j=limits[2]; j<=limits[3]; j++) {\\n                if(grid[i][j] != -1 && grid[i][j] != key) {\\n                    validRectangle = false;\\n                }\\n            }\\n        }\\n        if(validRectangle) {\\n            for(int i=limits[0]; i<=limits[1]; i++) {\\n                for(int j=limits[2]; j<=limits[3]; j++) {\\n                    grid[i][j] = -1;\\n                }\\n            }\\n        }\\n        return validRectangle;\\n    }\\n    \\n    public boolean allDone(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] != -1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2552969,
                "title": "python-topological-sort-with-brief-explanations",
                "content": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        \\n        # store maximum possible range of borders\\n        rects = defaultdict(lambda: {\\'l\\': 60, \\'r\\': -1, \\'t\\': 60, \\'d\\': -1})\\n        for i in range(m):\\n            for j in range(n):\\n                rects[targetGrid[i][j]][\\'l\\'] = min(rects[targetGrid[i][j]][\\'l\\'], j)\\n                rects[targetGrid[i][j]][\\'r\\'] = max(rects[targetGrid[i][j]][\\'r\\'], j)\\n                rects[targetGrid[i][j]][\\'t\\'] = min(rects[targetGrid[i][j]][\\'t\\'], i)\\n                rects[targetGrid[i][j]][\\'d\\'] = max(rects[targetGrid[i][j]][\\'d\\'], i)\\n                \\n        # indegree counts the number of rects covering the rect numbered i\\n        # outgoing memos the graph (top rect to the rects below)\\n        indegree, outgoing = {}, defaultdict(set)\\n        for i, d in rects.items():\\n            indegree.setdefault(i, 0)\\n            for r in range(d[\\'t\\'], d[\\'d\\'] + 1):\\n                for c in range(d[\\'l\\'], d[\\'r\\'] + 1):\\n                    num = targetGrid[r][c]\\n                    if num != i and i not in outgoing[num]:\\n                        outgoing[num].add(i)\\n                        indegree[i] += 1\\n                        \\n        # dump the rects with 0 indegrees (uncovered ones) into the queue\\n        uncovered = deque()\\n        for i, count in indegree.items():\\n            if not count: uncovered.append(i)\\n        \\n        # loop to uncover rects and add the new uncovered into queue\\n        while uncovered:\\n            i = uncovered.popleft()\\n            for j in outgoing[i]:\\n                indegree[j] -= 1\\n                if not indegree[j]:\\n                    uncovered.append(j)\\n                    \\n        # return True if there is no covered rects (all indegrees are 0)\\n        return not any(indegree.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        \\n        # store maximum possible range of borders\\n        rects = defaultdict(lambda: {\\'l\\': 60, \\'r\\': -1, \\'t\\': 60, \\'d\\': -1})\\n        for i in range(m):\\n            for j in range(n):\\n                rects[targetGrid[i][j]][\\'l\\'] = min(rects[targetGrid[i][j]][\\'l\\'], j)\\n                rects[targetGrid[i][j]][\\'r\\'] = max(rects[targetGrid[i][j]][\\'r\\'], j)\\n                rects[targetGrid[i][j]][\\'t\\'] = min(rects[targetGrid[i][j]][\\'t\\'], i)\\n                rects[targetGrid[i][j]][\\'d\\'] = max(rects[targetGrid[i][j]][\\'d\\'], i)\\n                \\n        # indegree counts the number of rects covering the rect numbered i\\n        # outgoing memos the graph (top rect to the rects below)\\n        indegree, outgoing = {}, defaultdict(set)\\n        for i, d in rects.items():\\n            indegree.setdefault(i, 0)\\n            for r in range(d[\\'t\\'], d[\\'d\\'] + 1):\\n                for c in range(d[\\'l\\'], d[\\'r\\'] + 1):\\n                    num = targetGrid[r][c]\\n                    if num != i and i not in outgoing[num]:\\n                        outgoing[num].add(i)\\n                        indegree[i] += 1\\n                        \\n        # dump the rects with 0 indegrees (uncovered ones) into the queue\\n        uncovered = deque()\\n        for i, count in indegree.items():\\n            if not count: uncovered.append(i)\\n        \\n        # loop to uncover rects and add the new uncovered into queue\\n        while uncovered:\\n            i = uncovered.popleft()\\n            for j in outgoing[i]:\\n                indegree[j] -= 1\\n                if not indegree[j]:\\n                    uncovered.append(j)\\n                    \\n        # return True if there is no covered rects (all indegrees are 0)\\n        return not any(indegree.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548347,
                "title": "c-cycle-detection",
                "content": "struct Node{\\n    int minx,miny,maxx,maxy;  \\n    Node()\\n    {\\n        minx = INT_MAX;\\n        miny = INT_MAX;\\n        maxx = INT_MIN;\\n        maxy = INT_MIN;\\n    }\\n};\\nclass Solution {\\npublic:\\n\\n        unordered_map<int,Node> mp;\\n        bool cycle(int src,vector<bool>&rec,vector<bool>&vis,vector<int>adj[]){\\n        if(vis[src]== false){\\n        vis[src]=true;\\n        rec[src]=true;\\n        for(auto node : adj[src]){\\n            if(!vis[node] && cycle(node,rec,vis,adj)){\\n                    return true;\\n            }\\n            else if(rec[node] == true)\\n            return true;\\n        }\\n        }\\n        rec[src]=false;\\n        return false;\\n        \\n    }\\n    bool isPrintable(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        int sz=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++)\\n                sz=max(sz,a[i][j]);\\n        }\\n        vector<int>adj[sz+1];\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                mp[a[i][j]].minx = min(mp[a[i][j]].minx,i);\\n                mp[a[i][j]].maxx = max(mp[a[i][j]].maxx,i);\\n                mp[a[i][j]].miny = min(mp[a[i][j]].miny,j);\\n                mp[a[i][j]].maxy = max(mp[a[i][j]].maxy,j);\\n            }\\n        }\\n        \\n        for(auto it:mp)\\n        { \\n            for(int i = it.second.minx;i<=it.second.maxx;i++)\\n            {\\n                for(int j = it.second.miny;j<=it.second.maxy;j++)\\n                {\\n                    if(a[i][j]!=it.first){\\n                       adj[it.first].push_back(a[i][j]);\\n                    }\\n                }\\n            }\\n            //cout<<endl;\\n        }\\n        // for(int i=1;i<=sz;i++){\\n        //     cout<<i<<\"->\";\\n        //     for(auto it : adj[i])\\n        //         cout<<it<<\" \";\\n        //     cout<<endl;\\n        // }\\n        vector<bool>vis(sz+1,false);\\n        vector<bool>rec(sz+1,false);\\n        for(int i=1;i<=sz;i++){\\n            if(vis[i]==false && cycle(i,rec,vis,adj))\\n                return false;\\n        }\\n        return true;\\n        \\n    }   \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n        unordered_map<int,Node> mp;\\n        bool cycle(int src,vector<bool>&rec,vector<bool>&vis,vector<int>adj[]){\\n        if(vis[src]== false){\\n        vis[src]=true;\\n        rec[src]=true;\\n        for(auto node : adj[src]){\\n            if(!vis[node] && cycle(node,rec,vis,adj)){\\n                    return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2518836,
                "title": "java-adjacency-map-topological-sort",
                "content": "```\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        int LEFT=0,RIGHT=1,TOP=2,BOTTOM=3;\\n        Map<Integer, int[]> coordinates = new HashMap();\\n        Map<Integer, Set<Integer>> adj = new HashMap();\\n        int rows = targetGrid.length, cols = targetGrid[0].length;\\n        for(int i = 0; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                int color = targetGrid[i][j];\\n                if (coordinates.containsKey(color)){\\n                    int[] coordinate = coordinates.get(color);\\n                    coordinate[LEFT]=Math.min(j, coordinate[LEFT]);\\n                    coordinate[RIGHT]=Math.max(j, coordinate[RIGHT]);\\n                    coordinate[TOP]=Math.min(i, coordinate[TOP]);\\n                    coordinate[BOTTOM]=Math.max(i, coordinate[BOTTOM]);\\n                }else{\\n                    coordinates.put(color, new int[]{j, j, i, i});\\n                    adj.put(color, new HashSet());\\n                }\\n            }\\n        }\\n        Map<Integer, Integer> indegree = new HashMap();\\n        for(Map.Entry<Integer, int[]> entry: coordinates.entrySet()){\\n            int currColor = entry.getKey();\\n            int[] coordinate=entry.getValue();\\n            for(int i = coordinate[TOP]; i <= coordinate[BOTTOM]; i++){\\n                for(int j = coordinate[LEFT]; j <= coordinate[RIGHT]; j++){\\n                    int color = targetGrid[i][j];\\n                    if (currColor!=color)\\n                        adj.get(currColor).add(color);\\n                }\\n            }\\n            indegree.put(currColor, 0);\\n        }\\n        for(Integer key: adj.keySet()){\\n            for (int color: adj.get(key))\\n                indegree.put(color, indegree.get(color)+1);\\n        }\\n        Queue<Integer> queue = new LinkedList();\\n        for(Integer key: indegree.keySet())\\n            if (indegree.get(key)==0)\\n                queue.offer(key);\\n        int size = 0;\\n        while(!queue.isEmpty()){\\n            int node = queue.poll();\\n            size++;\\n            for(int neighbor: adj.get(node)){\\n                indegree.put(neighbor, indegree.get(neighbor)-1);\\n                if (indegree.get(neighbor) == 0)\\n                    queue.offer(neighbor);\\n            }\\n        }\\n        return size == adj.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        int LEFT=0,RIGHT=1,TOP=2,BOTTOM=3;\\n        Map<Integer, int[]> coordinates = new HashMap();\\n        Map<Integer, Set<Integer>> adj = new HashMap();\\n        int rows = targetGrid.length, cols = targetGrid[0].length;\\n        for(int i = 0; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                int color = targetGrid[i][j];\\n                if (coordinates.containsKey(color)){\\n                    int[] coordinate = coordinates.get(color);\\n                    coordinate[LEFT]=Math.min(j, coordinate[LEFT]);\\n                    coordinate[RIGHT]=Math.max(j, coordinate[RIGHT]);\\n                    coordinate[TOP]=Math.min(i, coordinate[TOP]);\\n                    coordinate[BOTTOM]=Math.max(i, coordinate[BOTTOM]);\\n                }else{\\n                    coordinates.put(color, new int[]{j, j, i, i});\\n                    adj.put(color, new HashSet());\\n                }\\n            }\\n        }\\n        Map<Integer, Integer> indegree = new HashMap();\\n        for(Map.Entry<Integer, int[]> entry: coordinates.entrySet()){\\n            int currColor = entry.getKey();\\n            int[] coordinate=entry.getValue();\\n            for(int i = coordinate[TOP]; i <= coordinate[BOTTOM]; i++){\\n                for(int j = coordinate[LEFT]; j <= coordinate[RIGHT]; j++){\\n                    int color = targetGrid[i][j];\\n                    if (currColor!=color)\\n                        adj.get(currColor).add(color);\\n                }\\n            }\\n            indegree.put(currColor, 0);\\n        }\\n        for(Integer key: adj.keySet()){\\n            for (int color: adj.get(key))\\n                indegree.put(color, indegree.get(color)+1);\\n        }\\n        Queue<Integer> queue = new LinkedList();\\n        for(Integer key: indegree.keySet())\\n            if (indegree.get(key)==0)\\n                queue.offer(key);\\n        int size = 0;\\n        while(!queue.isEmpty()){\\n            int node = queue.poll();\\n            size++;\\n            for(int neighbor: adj.get(node)){\\n                indegree.put(neighbor, indegree.get(neighbor)-1);\\n                if (indegree.get(neighbor) == 0)\\n                    queue.offer(neighbor);\\n            }\\n        }\\n        return size == adj.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501527,
                "title": "python",
                "content": "\\tclass Solution:\\n\\t\\tdef isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n\\t\\t\\tcoords = defaultdict(lambda:[(math.inf,math.inf),(-1,-1)])\\n\\n\\t\\t\\tm = len(targetGrid)\\n\\t\\t\\tn = len(targetGrid[0])\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tcord = coords[targetGrid[i][j]]\\n\\t\\t\\t\\t\\tlx = cord[0][0]\\n\\t\\t\\t\\t\\tly = cord[0][1]\\n\\t\\t\\t\\t\\trx = cord[1][0]\\n\\t\\t\\t\\t\\try = cord[1][1]\\n\\n\\t\\t\\t\\t\\tcoords[targetGrid[i][j]] = [(min(lx,i),min(ly,j)),(max(rx,i),max(ry,j))]\\n\\n\\t\\t\\tused = defaultdict(lambda:None)\\n\\t\\t\\tdef dfs(color):\\n\\n\\t\\t\\t\\tif used[color] == False:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telif used[color] == True:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\tused[color] = False\\n\\n\\t\\t\\t\\tc = coords[color]\\n\\t\\t\\t\\tlxp, rxp, lyp, ryp = c[0][0],c[1][0],c[0][1],c[1][1]\\n\\t\\t\\t\\tfor i in range(lxp, rxp + 1):\\n\\t\\t\\t\\t\\tfor j in range(lyp, ryp + 1):\\n\\t\\t\\t\\t\\t\\tnxt = targetGrid[i][j]\\n\\t\\t\\t\\t\\t\\tif  nxt != color and not dfs(nxt):\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tused[color] = True\\n\\t\\t\\t\\treturn True\\n\\n\\n\\t\\t\\tfor key in coords:\\n\\t\\t\\t\\tif not dfs(key):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n\\t\\t\\tcoords = defaultdict(lambda:[(math.inf,math.inf),(-1,-1)])\\n\\n\\t\\t\\tm = len(targetGrid)\\n\\t\\t\\tn = len(targetGrid[0])\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tcord = coords[targetGrid[i][j]]\\n\\t\\t\\t\\t\\tlx = cord[0][0]\\n\\t\\t\\t\\t\\tly = cord[0][1]\\n\\t\\t\\t\\t\\trx = cord[1][0]\\n\\t\\t\\t\\t\\try = cord[1][1]\\n\\n\\t\\t\\t\\t\\tcoords[targetGrid[i][j]] = [(min(lx,i),min(ly,j)),(max(rx,i),max(ry,j))]\\n\\n\\t\\t\\tused = defaultdict(lambda:None)\\n\\t\\t\\tdef dfs(color):\\n\\n\\t\\t\\t\\tif used[color] == False:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telif used[color] == True:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\tused[color] = False\\n\\n\\t\\t\\t\\tc = coords[color]\\n\\t\\t\\t\\tlxp, rxp, lyp, ryp = c[0][0],c[1][0],c[0][1],c[1][1]\\n\\t\\t\\t\\tfor i in range(lxp, rxp + 1):\\n\\t\\t\\t\\t\\tfor j in range(lyp, ryp + 1):\\n\\t\\t\\t\\t\\t\\tnxt = targetGrid[i][j]\\n\\t\\t\\t\\t\\t\\tif  nxt != color and not dfs(nxt):\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tused[color] = True\\n\\t\\t\\t\\treturn True\\n\\n\\n\\t\\t\\tfor key in coords:\\n\\t\\t\\t\\tif not dfs(key):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n",
                "codeTag": "Java"
            },
            {
                "id": 2418475,
                "title": "clean-java-topological-sort-solution",
                "content": "The gist of this problem is to identify the fact that there would always be a color that have a rectangular shape. As a result we could:\\n\\n[1] Put the first colors that have rectangular shape in the queue first\\n\\n[2] Mark all those colors as CUSTOM_COLOR that could be used by any other color to form their rectangular shape.\\n\\n[3] Then find any other color that could use these CUSTOM_COLOR to form rectangular shape and repeat [1]\\n\\nIf at some point during [2] to [3], there are colors left but no rectangular shape has found, we know we could not use this printer to print this shape.\\n\\nCode:\\n\\n```\\nclass Solution {\\n    private static final int CUSTOM_COLOR = 0;\\n    public boolean isPrintable(int[][] targetGrid) {\\n        Set<Integer> colors = getColors(targetGrid);\\n        Map<Integer, int[]> minMaxXY = getMinMaxXY(colors, targetGrid);\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int color : colors) {\\n            if (isColorRectangular(color, targetGrid, minMaxXY.get(color))) {\\n                queue.offer(color);\\n            }\\n        }\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i=0; i < size; ++i) {\\n                int color = queue.poll();\\n                mark(color, targetGrid, minMaxXY.get(color));\\n                colors.remove(color);\\n            }\\n            for (int color : colors) {\\n                if (isColorRectangular(color, targetGrid, minMaxXY.get(color))) {\\n                    queue.offer(color);\\n                }\\n            }\\n        }\\n        \\n        return colors.isEmpty();\\n    }\\n    \\n    private void mark(int color, int[][] targetGrid, int[] minMaxXY) {\\n        int minX = minMaxXY[0], maxX = minMaxXY[1];\\n        int minY = minMaxXY[2], maxY = minMaxXY[3];\\n        for(int x=minX; x <= maxX; ++x) {\\n            for (int y = minY; y <= maxY; ++y) {\\n                targetGrid[x][y] = CUSTOM_COLOR;\\n            }\\n        }\\n    }\\n    \\n    private boolean isColorRectangular(int targetColor, int[][] targetGrid, int[] minMaxXY) {\\n        int minX = minMaxXY[0], maxX = minMaxXY[1];\\n        int minY = minMaxXY[2], maxY = minMaxXY[3];\\n        for(int x=minX; x <= maxX; ++x) {\\n            for (int y = minY; y <= maxY; ++y) {\\n                int color = targetGrid[x][y];\\n                if (color != targetColor && color != CUSTOM_COLOR) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private Map<Integer, int[]> getMinMaxXY(Set<Integer> colors, int[][] targetGrid) {\\n        // minX, maxX, minY, maxY\\n        Map<Integer, int[]> minMaxes = new HashMap<>();\\n        for(int color : colors) {\\n            minMaxes.put(color, new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE});\\n        }\\n        \\n        for (int x=0; x < targetGrid.length; ++x) {\\n            for (int y=0; y < targetGrid[0].length; ++y) {\\n                int color = targetGrid[x][y];\\n                int[] minMax = minMaxes.get(color);\\n                minMax[0] = Math.min(x, minMax[0]);\\n                minMax[1] = Math.max(x, minMax[1]);\\n                minMax[2] = Math.min(y, minMax[2]);\\n                minMax[3] = Math.max(y, minMax[3]);\\n            }\\n        }\\n        return minMaxes;\\n    }\\n    \\n    private Set<Integer> getColors(int[][] targetGrid) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int[] row : targetGrid) {\\n            for (int val : row) {\\n                set.add(val);\\n            }\\n        }\\n        return set;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    private static final int CUSTOM_COLOR = 0;\\n    public boolean isPrintable(int[][] targetGrid) {\\n        Set<Integer> colors = getColors(targetGrid);\\n        Map<Integer, int[]> minMaxXY = getMinMaxXY(colors, targetGrid);\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int color : colors) {\\n            if (isColorRectangular(color, targetGrid, minMaxXY.get(color))) {\\n                queue.offer(color);\\n            }\\n        }\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i=0; i < size; ++i) {\\n                int color = queue.poll();\\n                mark(color, targetGrid, minMaxXY.get(color));\\n                colors.remove(color);\\n            }\\n            for (int color : colors) {\\n                if (isColorRectangular(color, targetGrid, minMaxXY.get(color))) {\\n                    queue.offer(color);\\n                }\\n            }\\n        }\\n        \\n        return colors.isEmpty();\\n    }\\n    \\n    private void mark(int color, int[][] targetGrid, int[] minMaxXY) {\\n        int minX = minMaxXY[0], maxX = minMaxXY[1];\\n        int minY = minMaxXY[2], maxY = minMaxXY[3];\\n        for(int x=minX; x <= maxX; ++x) {\\n            for (int y = minY; y <= maxY; ++y) {\\n                targetGrid[x][y] = CUSTOM_COLOR;\\n            }\\n        }\\n    }\\n    \\n    private boolean isColorRectangular(int targetColor, int[][] targetGrid, int[] minMaxXY) {\\n        int minX = minMaxXY[0], maxX = minMaxXY[1];\\n        int minY = minMaxXY[2], maxY = minMaxXY[3];\\n        for(int x=minX; x <= maxX; ++x) {\\n            for (int y = minY; y <= maxY; ++y) {\\n                int color = targetGrid[x][y];\\n                if (color != targetColor && color != CUSTOM_COLOR) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private Map<Integer, int[]> getMinMaxXY(Set<Integer> colors, int[][] targetGrid) {\\n        // minX, maxX, minY, maxY\\n        Map<Integer, int[]> minMaxes = new HashMap<>();\\n        for(int color : colors) {\\n            minMaxes.put(color, new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE});\\n        }\\n        \\n        for (int x=0; x < targetGrid.length; ++x) {\\n            for (int y=0; y < targetGrid[0].length; ++y) {\\n                int color = targetGrid[x][y];\\n                int[] minMax = minMaxes.get(color);\\n                minMax[0] = Math.min(x, minMax[0]);\\n                minMax[1] = Math.max(x, minMax[1]);\\n                minMax[2] = Math.min(y, minMax[2]);\\n                minMax[3] = Math.max(y, minMax[3]);\\n            }\\n        }\\n        return minMaxes;\\n    }\\n    \\n    private Set<Integer> getColors(int[][] targetGrid) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int[] row : targetGrid) {\\n            for (int val : row) {\\n                set.add(val);\\n            }\\n        }\\n        return set;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410597,
                "title": "clean-c-solution-cycle-detection",
                "content": "```\\nstruct Node{\\n    int minx,miny,maxx,maxy;  \\n    Node()\\n    {\\n        minx = INT_MAX;\\n        miny = INT_MAX;\\n        maxx = INT_MIN;\\n        maxy = INT_MIN;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,unordered_set<int>> mpIn;\\n    unordered_map<int,Node> mp;\\n    unordered_set<int> vis;\\n    \\n    bool hasCycle(int sv,int parent)\\n    {\\n        vis.insert(sv);\\n        for(auto it:mpIn[sv])\\n        {\\n            if(vis.find(it)==vis.end())\\n            {\\n                if(hasCycle(it,sv))return true;\\n            }\\n            else\\n            {\\n                // cout<<\"yaha se \"<<it<<endl;\\n                return true;\\n            }\\n        }\\n        vis.erase(sv);\\n        return false;\\n    }\\n    \\n    bool isPrintable(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                mp[a[i][j]].minx = min(mp[a[i][j]].minx,i);\\n                mp[a[i][j]].maxx = max(mp[a[i][j]].maxx,i);\\n                mp[a[i][j]].miny = min(mp[a[i][j]].miny,j);\\n                mp[a[i][j]].maxy = max(mp[a[i][j]].maxy,j);\\n            }\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            for(int i = it.second.minx;i<=it.second.maxx;i++)\\n            {\\n                for(int j = it.second.miny;j<=it.second.maxy;j++)\\n                {\\n                    if(a[i][j]!=it.first)\\n                        mpIn[it.first].insert(a[i][j]);\\n                }\\n            }\\n        }\\n            \\n        \\n        for(auto it:mpIn)\\n        {\\n            if(hasCycle(it.first,-1))return false;\\n        }\\n        return true;\\n        \\n    }   \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct Node{\\n    int minx,miny,maxx,maxy;  \\n    Node()\\n    {\\n        minx = INT_MAX;\\n        miny = INT_MAX;\\n        maxx = INT_MIN;\\n        maxy = INT_MIN;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,unordered_set<int>> mpIn;\\n    unordered_map<int,Node> mp;\\n    unordered_set<int> vis;\\n    \\n    bool hasCycle(int sv,int parent)\\n    {\\n        vis.insert(sv);\\n        for(auto it:mpIn[sv])\\n        {\\n            if(vis.find(it)==vis.end())\\n            {\\n                if(hasCycle(it,sv))return true;\\n            }\\n            else\\n            {\\n                // cout<<\"yaha se \"<<it<<endl;\\n                return true;\\n            }\\n        }\\n        vis.erase(sv);\\n        return false;\\n    }\\n    \\n    bool isPrintable(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                mp[a[i][j]].minx = min(mp[a[i][j]].minx,i);\\n                mp[a[i][j]].maxx = max(mp[a[i][j]].maxx,i);\\n                mp[a[i][j]].miny = min(mp[a[i][j]].miny,j);\\n                mp[a[i][j]].maxy = max(mp[a[i][j]].maxy,j);\\n            }\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            for(int i = it.second.minx;i<=it.second.maxx;i++)\\n            {\\n                for(int j = it.second.miny;j<=it.second.maxy;j++)\\n                {\\n                    if(a[i][j]!=it.first)\\n                        mpIn[it.first].insert(a[i][j]);\\n                }\\n            }\\n        }\\n            \\n        \\n        for(auto it:mpIn)\\n        {\\n            if(hasCycle(it.first,-1))return false;\\n        }\\n        return true;\\n        \\n    }   \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2356777,
                "title": "c-solution-with-i-hope-it-is-an-easy-explanation",
                "content": "The idea is that we identify the boundaries of each color (minimum/maximum row and column for each color), and then one color, for instance, color 1, will relate to others using a graph in which the nodes are the colors that represent on the supplied target grid (for example, color 2). When color1 also has color2, add the direct edge of the border. Because particular color1 cells can turn into specific color2 cells, it suggests that there is a link between the nodes.\\n\\nThe issue arises if a cycle occurs, meaning some cells will change from their current color to an older one, violating the constraint ( the same color cannot be used again)\\n\\n```\\nclass Solution {\\npublic:\\n//this will be called 3rd order\\nbool is_dag(vector<vector<short>>& g, vector<short>&status,short node) {\\n\\t// this will be called recursively, so put the satus 0 to identify that it will \\n\\t// after vistied the child it will comes to this node\\n\\tstatus[node] = 0;\\n\\tfor (short v : g[node]) {\\n\\t\\tif (status[v] == 0)  // we visit parent twice this means it has a cycle\\n\\t\\t\\treturn false;\\n\\t\\tif (status[v] == -1) // we not visit this node yet then visit\\n\\t\\t\\tif (!is_dag(g, status, v)) // if the child has a cycle, just return false\\n\\t\\t\\t\\treturn false;\\n\\t}\\n\\tstatus[node] = 1; // after visited, change the status to 1\\n\\treturn true;\\n}\\n\\n//This will be call 2nd order\\nbool is_cycle(vector<vector<short>>& graph) {\\n\\tvector<short> status(graph.size(), -1);\\n\\tfor (short node = 0; node < graph.size(); ++node)\\n\\t\\tif (status[node] == -1) \\n\\t\\t\\tif (!is_dag(graph,status, node)) \\n\\t\\t\\t\\treturn true;\\n\\n\\treturn false;\\n}\\n\\nbool isPrintable(vector<vector<int>>& targetGrid) {\\n\\tshort mxcolor = 1;\\n\\tconst short R = targetGrid.size();\\n\\tconst short C = targetGrid[0].size();\\n\\n\\t// find out that what is the maximum nodes to use (use colors as nodes)\\n\\tfor (short r = 0; r < R; ++r)\\n\\t\\tfor (short c = 0; c < C; ++c)\\n\\t\\t\\tmxcolor = max(mxcolor, (short)targetGrid[r][c]);\\n\\t\\t\\t\\n\\tvector<short> mxcolor_row(mxcolor + 1, -1); // base 0 -> base 1;\\n\\tvector<short> mncolor_row(mxcolor + 1, R);  // put default high number for min\\n\\tvector<short> mxcolor_col(mxcolor + 1, -1); // put default low number for max\\n\\tvector<short> mncolor_col(mxcolor + 1, C);\\n\\n\\t// find the max/min (boundary) for each color(node) that appear on grid;\\n\\tfor (short r = 0; r < R; ++r) {\\n\\t\\tfor (short c = 0; c < C; ++c) {\\n\\t\\t\\tshort cur = targetGrid[r][c];\\n\\t\\t\\tmxcolor_row[cur] = max(mxcolor_row[cur], r);\\n\\t\\t\\tmxcolor_col[cur] = max(mxcolor_col[cur], c);\\n\\t\\t\\tmncolor_col[cur] = min(mncolor_col[cur], c);\\n\\t\\t\\tmncolor_row[cur] = min(mncolor_row[cur], r);\\n\\t\\t}\\n\\t}\\n\\n\\t// Create the graph which the relation is define as if the boundary of some color\\n\\t// eg. color1 has different color eg color 2, then add direct edge \\n\\t//from color1 to color2, So let\\'s build the graph\\n\\t\\n\\t// This is graph with no edges yet (just a nodes) base 1\\n\\tvector<vector<short>> graph(mxcolor + 1); \\n\\n\\tfor (short c = 1; c <= mxcolor; ++c) \\n\\t\\t//iterate to each color boundary (some color will have no boundary)\\n\\t\\tfor (short crow = mncolor_row[c]; crow <= mxcolor_row[c]; ++crow)\\n\\t\\t\\tfor (short ccol = mncolor_col[c]; ccol <= mxcolor_col[c]; ++ccol)\\n\\t\\t\\t\\t// if there are some color that not in current color boundary so add the relation.\\n\\t\\t\\t\\tif (targetGrid[crow][ccol] != c) \\n\\t\\t\\t\\t\\tgraph[c].push_back(targetGrid[crow][ccol]);\\n\\n// The graph that have a cycle will not be able to put the different color\\n// since the edge from color1 to color2 mean color1 will be transform to color2\\n// so if there are a cycle it means color2 will convert to color1 which violate the\\n// constraint (each color will use once)\\n\\treturn !is_cycle(graph);\\t\\t\\t\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//this will be called 3rd order\\nbool is_dag(vector<vector<short>>& g, vector<short>&status,short node) {\\n\\t// this will be called recursively, so put the satus 0 to identify that it will \\n\\t// after vistied the child it will comes to this node\\n\\tstatus[node] = 0;\\n\\tfor (short v : g[node]) {\\n\\t\\tif (status[v] == 0)  // we visit parent twice this means it has a cycle\\n\\t\\t\\treturn false;\\n\\t\\tif (status[v] == -1) // we not visit this node yet then visit\\n\\t\\t\\tif (!is_dag(g, status, v)) // if the child has a cycle, just return false\\n\\t\\t\\t\\treturn false;\\n\\t}\\n\\tstatus[node] = 1; // after visited, change the status to 1\\n\\treturn true;\\n}\\n\\n//This will be call 2nd order\\nbool is_cycle(vector<vector<short>>& graph) {\\n\\tvector<short> status(graph.size(), -1);\\n\\tfor (short node = 0; node < graph.size(); ++node)\\n\\t\\tif (status[node] == -1) \\n\\t\\t\\tif (!is_dag(graph,status, node)) \\n\\t\\t\\t\\treturn true;\\n\\n\\treturn false;\\n}\\n\\nbool isPrintable(vector<vector<int>>& targetGrid) {\\n\\tshort mxcolor = 1;\\n\\tconst short R = targetGrid.size();\\n\\tconst short C = targetGrid[0].size();\\n\\n\\t// find out that what is the maximum nodes to use (use colors as nodes)\\n\\tfor (short r = 0; r < R; ++r)\\n\\t\\tfor (short c = 0; c < C; ++c)\\n\\t\\t\\tmxcolor = max(mxcolor, (short)targetGrid[r][c]);\\n\\t\\t\\t\\n\\tvector<short> mxcolor_row(mxcolor + 1, -1); // base 0 -> base 1;\\n\\tvector<short> mncolor_row(mxcolor + 1, R);  // put default high number for min\\n\\tvector<short> mxcolor_col(mxcolor + 1, -1); // put default low number for max\\n\\tvector<short> mncolor_col(mxcolor + 1, C);\\n\\n\\t// find the max/min (boundary) for each color(node) that appear on grid;\\n\\tfor (short r = 0; r < R; ++r) {\\n\\t\\tfor (short c = 0; c < C; ++c) {\\n\\t\\t\\tshort cur = targetGrid[r][c];\\n\\t\\t\\tmxcolor_row[cur] = max(mxcolor_row[cur], r);\\n\\t\\t\\tmxcolor_col[cur] = max(mxcolor_col[cur], c);\\n\\t\\t\\tmncolor_col[cur] = min(mncolor_col[cur], c);\\n\\t\\t\\tmncolor_row[cur] = min(mncolor_row[cur], r);\\n\\t\\t}\\n\\t}\\n\\n\\t// Create the graph which the relation is define as if the boundary of some color\\n\\t// eg. color1 has different color eg color 2, then add direct edge \\n\\t//from color1 to color2, So let\\'s build the graph\\n\\t\\n\\t// This is graph with no edges yet (just a nodes) base 1\\n\\tvector<vector<short>> graph(mxcolor + 1); \\n\\n\\tfor (short c = 1; c <= mxcolor; ++c) \\n\\t\\t//iterate to each color boundary (some color will have no boundary)\\n\\t\\tfor (short crow = mncolor_row[c]; crow <= mxcolor_row[c]; ++crow)\\n\\t\\t\\tfor (short ccol = mncolor_col[c]; ccol <= mxcolor_col[c]; ++ccol)\\n\\t\\t\\t\\t// if there are some color that not in current color boundary so add the relation.\\n\\t\\t\\t\\tif (targetGrid[crow][ccol] != c) \\n\\t\\t\\t\\t\\tgraph[c].push_back(targetGrid[crow][ccol]);\\n\\n// The graph that have a cycle will not be able to put the different color\\n// since the edge from color1 to color2 mean color1 will be transform to color2\\n// so if there are a cycle it means color2 will convert to color1 which violate the\\n// constraint (each color will use once)\\n\\treturn !is_cycle(graph);\\t\\t\\t\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354583,
                "title": "c-o-60-n-m-time-kahn-s-algorithm-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>> &a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        vector<int> adj[61];\\n        for(int c=1 ; c<=60 ; c++) {\\n            int minx = max(n , m) , miny = max(n , m) , maxx = -1 , maxy = -1;\\n            for(int i=0 ; i<n ; i++) {\\n                for(int j=0 ; j<m ; j++) {\\n                    if(a[i][j] == c) {\\n                        minx = min(minx , i);\\n                        miny = min(miny , j);\\n                        maxx = max(maxx , i);\\n                        maxy = max(maxy , j);\\n                    }\\n                }\\n            }\\n            for(int i=minx ; i<=maxx ; i++) {\\n                for(int j=miny ; j<=maxy ; j++) {\\n                    if(a[i][j] != c) {\\n                        adj[c].push_back(a[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> indegree(61 , 0);\\n        for(int i=1 ; i<=60 ; i++) {\\n            for(int j=0 ; j<adj[i].size() ; j++) {\\n                indegree[adj[i][j]]++;\\n            }\\n        }\\n        queue<int> q;\\n        for(int i=1 ; i<=60 ; i++) {\\n            if(!indegree[i]) q.push(i); \\n        }\\n        int cnt = 0;\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for(int v : adj[u]) {\\n                indegree[v]--;\\n                if(!indegree[v]) q.push(v);\\n            }\\n            cnt++;\\n        }\\n        if(cnt != 60) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>> &a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        vector<int> adj[61];\\n        for(int c=1 ; c<=60 ; c++) {\\n            int minx = max(n , m) , miny = max(n , m) , maxx = -1 , maxy = -1;\\n            for(int i=0 ; i<n ; i++) {\\n                for(int j=0 ; j<m ; j++) {\\n                    if(a[i][j] == c) {\\n                        minx = min(minx , i);\\n                        miny = min(miny , j);\\n                        maxx = max(maxx , i);\\n                        maxy = max(maxy , j);\\n                    }\\n                }\\n            }\\n            for(int i=minx ; i<=maxx ; i++) {\\n                for(int j=miny ; j<=maxy ; j++) {\\n                    if(a[i][j] != c) {\\n                        adj[c].push_back(a[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> indegree(61 , 0);\\n        for(int i=1 ; i<=60 ; i++) {\\n            for(int j=0 ; j<adj[i].size() ; j++) {\\n                indegree[adj[i][j]]++;\\n            }\\n        }\\n        queue<int> q;\\n        for(int i=1 ; i<=60 ; i++) {\\n            if(!indegree[i]) q.push(i); \\n        }\\n        int cnt = 0;\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for(int v : adj[u]) {\\n                indegree[v]--;\\n                if(!indegree[v]) q.push(v);\\n            }\\n            cnt++;\\n        }\\n        if(cnt != 60) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283505,
                "title": "python-with-detailed-comments",
                "content": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        \\n        # White/Gray/Black DFS tree traversal to detect cycles \\n        def dfs(u):           \\n            # mark the node as a visited in the current dfs path\\n            seen[u] = 1 # 1 - Gray, seen in this dfs path\\n            for v in graph[u]:\\n                # if already seen in this dfs path, we got a cycle, return failure                \\n                if seen[v] == 1: # 1- Gray\\n                    return False  \\n                # already seen this node in a previous dfs path, the rest has been already checked for cycles\\n                if seen[v] == 2: # 2- Black\\n                    continue\\n                # check for cycles along the way, if at least one failure, return all way to the top\\n                if not dfs(v):\\n                    return False\\n            # mark this node as processed and checked no cycles down the way\\n            seen[u] = 2  # 2- Black\\n            return True                \\n        \\n        graph = defaultdict(set)\\n        rects = {}\\n        m = len(targetGrid)\\n        n = len(targetGrid[0])\\n        # 1. get max rectangle for all found colors per color\\n        for i in range(m):\\n            for j in range(n):\\n                c = targetGrid[i][j]\\n                if c not in rects:\\n                    rects[c] = [1, (i,j), (i,j)]\\n                else:\\n                    r = rects[c]\\n                    r[0] += 1\\n                    r[1] = (min(r[1][0], i), min(r[1][1], j))\\n                    r[2] = (max(r[2][0], i), max(r[2][1], j))\\n        # 2. for every max color rectange, link to a graph with all other overlapping colors as children\\n        for c, (cnt, (x0, y0), (x1, y1)) in rects.items():\\n            # the rectangle is completely filled with a single color, no other color children\\n            if (x1 - x0 + 1) * (y1 - y0 + 1) == cnt:\\n                continue\\n            # for every cell in the color box\\n            for i in range(x0, x1 + 1):\\n                for j in range(y0, y1 + 1):\\n                    if targetGrid[i][j] != c:\\n                        # add another color as this node\\'s child\\n                        graph[c].add(targetGrid[i][j])                \\n\\n        # 3. we just need to enure no cycles - two colors don\\'t depend on each other\\n        seen = defaultdict(str)\\n        # detect cycles using White/Grey/Black DFS, graph may be disjoint and we start from random nodes\\n        for c in list(graph.keys()):\\n            if not dfs(c):\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        \\n        # White/Gray/Black DFS tree traversal to detect cycles \\n        def dfs(u):           \\n            # mark the node as a visited in the current dfs path\\n            seen[u] = 1 # 1 - Gray, seen in this dfs path\\n            for v in graph[u]:\\n                # if already seen in this dfs path, we got a cycle, return failure                \\n                if seen[v] == 1: # 1- Gray\\n                    return False  \\n                # already seen this node in a previous dfs path, the rest has been already checked for cycles\\n                if seen[v] == 2: # 2- Black\\n                    continue\\n                # check for cycles along the way, if at least one failure, return all way to the top\\n                if not dfs(v):\\n                    return False\\n            # mark this node as processed and checked no cycles down the way\\n            seen[u] = 2  # 2- Black\\n            return True                \\n        \\n        graph = defaultdict(set)\\n        rects = {}\\n        m = len(targetGrid)\\n        n = len(targetGrid[0])\\n        # 1. get max rectangle for all found colors per color\\n        for i in range(m):\\n            for j in range(n):\\n                c = targetGrid[i][j]\\n                if c not in rects:\\n                    rects[c] = [1, (i,j), (i,j)]\\n                else:\\n                    r = rects[c]\\n                    r[0] += 1\\n                    r[1] = (min(r[1][0], i), min(r[1][1], j))\\n                    r[2] = (max(r[2][0], i), max(r[2][1], j))\\n        # 2. for every max color rectange, link to a graph with all other overlapping colors as children\\n        for c, (cnt, (x0, y0), (x1, y1)) in rects.items():\\n            # the rectangle is completely filled with a single color, no other color children\\n            if (x1 - x0 + 1) * (y1 - y0 + 1) == cnt:\\n                continue\\n            # for every cell in the color box\\n            for i in range(x0, x1 + 1):\\n                for j in range(y0, y1 + 1):\\n                    if targetGrid[i][j] != c:\\n                        # add another color as this node\\'s child\\n                        graph[c].add(targetGrid[i][j])                \\n\\n        # 3. we just need to enure no cycles - two colors don\\'t depend on each other\\n        seen = defaultdict(str)\\n        # detect cycles using White/Grey/Black DFS, graph may be disjoint and we start from random nodes\\n        for c in list(graph.keys()):\\n            if not dfs(c):\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265577,
                "title": "python-projection-non-dfs-with-thought-process-when-being-asked-during-interviews",
                "content": "### Projection\\nMy first intuition is to calculate the topological sort and find if there is cycle. However, it\\'s constructed as undirected graph by taking overlapping colors as dependency without knowing which color goes first.\\nBut it gives the basic idea that the last printed color is with complete rectangle and absolutely able to print. With this printed color, we can reset all of cells with the color to be `0` meaning any color which can be used to construct the incomplete rectangle with the different color. Then repeat this process until there is no more incomplete rectangle left. \\n\\n**So the first problem is how can we know if there is a complete rectangle for a given color `c`?**\\n\\nBecause of rectangle, we can know the size of rectangle once we know the left top corner and the right bottom corner which can be simpley gotten by iterating the target grid, and then compare it with the number of cells with the color `c`.\\n\\n**Then the next question is how can we reset the cells with the color `c` to make up the incomplete rectangle?**\\nWe can only update those incomplete rectangles with overlapping cells with color `c`. Then this question can be converted to find out the overlapping cells. If you are familiar with intersection interval, then you know how to find overlapping cells. We use the same idea but with a 2D array by projecting the coordinate to `rows` and `cols` axis respectively. Then we can simply detect if there is overlapping.\\n\\nOnce the number of cells after update is equals to the size of rectangle, the rectangle is complete, and can be put to the next queue to construct futher more rectangles.\\n\\n**Can we stop here, it looks a working solution?**\\nNo, I made this mistake by stopping here and just comparing the number without looking at the exactly overlapping coordinates. The solution failed on the last second test case. \\nThe reason is that it\\'s possible to add up the same cell mutliple times because of overlapped with multiple colors.\\nWe have to generate the actual coordinate for each cells that are overlapping and update to corresponding colors.\\n\\nSo let\\'s put all together\\n1. Iterate target grid to record cells for each color.\\n2. Find the colors with complete rectrangles, put to printed color set.\\n3. For each color `c`, iterate all the other incomplete color `d`, cacluate the overlapping cells, update to cells for color `d`.\\n4. As long as the number of cells equals to size of rectangle for color `d`, put `d` to the next printed color set.\\n5. Repeat step 2 - 4, until no more colors left to print, return True. Otherwise false when next printed set is empty.\\n\\n```python\\ndef isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n\\trows = defaultdict(lambda:[float(\\'inf\\'), float(\\'-inf\\')])\\n\\tcols = defaultdict(lambda:[float(\\'inf\\'), float(\\'-inf\\')])\\n\\tcolors = defaultdict(set)\\n        \\n\\tm, n = len(targetGrid), len(targetGrid[0])\\n        \\n\\tdef index(i, j):\\n\\t\\treturn i * n + j\\n        \\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tcolor = targetGrid[i][j]\\n\\t\\t\\trows[color] = [min(rows[color][0], i), max(rows[color][1], i)]\\n\\t\\t\\tcols[color] = [min(cols[color][0], j), max(cols[color][1], j)]\\n\\t\\t\\tcolors[color].add(index(i, j))\\n                \\n\\tdef get_size(color): \\n\\t\\trow = rows[color]\\n\\t\\tcol = cols[color]\\n\\t\\treturn (row[1] - row[0] + 1) * (col[1] - col[0] + 1)\\n        \\n\\tdef overlap_size(this, that):\\n\\t\\trow_this = rows[this]\\n\\t\\trow_that = rows[that]\\n\\t\\tcol_this = cols[this]\\n\\t\\tcol_that = cols[that]\\n\\t\\treturn {index(i, j) for i in range(max(row_this[0], row_that[0]), min(row_this[1], row_that[1]) + 1) for j in range(max(col_this[0], col_that[0]), min(col_this[1], col_that[1]) + 1)}\\n            \\n\\tprinted = {color for color in colors if get_size(color) == len(colors[color])}\\n\\tleft =  set(colors.keys()) - printed\\n        \\n    while left:\\n\\t\\tif not printed:\\n\\t\\t\\treturn False\\n\\t\\tnext_printed = set()\\n\\t\\tfor color in printed:\\n\\t\\t\\tfor remain in left:\\n\\t\\t\\t\\tif remain in next_printed:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tcolors[remain] |= overlap_size(color, remain)\\n\\t\\t\\t\\tif len(colors[remain]) == get_size(remain):\\n\\t\\t\\t\\t\\tnext_printed.add(remain)\\n\\t\\tprinted = next_printed\\n\\t\\tleft = left - printed \\n\\treturn True\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\ndef isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n\\trows = defaultdict(lambda:[float(\\'inf\\'), float(\\'-inf\\')])\\n\\tcols = defaultdict(lambda:[float(\\'inf\\'), float(\\'-inf\\')])\\n\\tcolors = defaultdict(set)\\n        \\n\\tm, n = len(targetGrid), len(targetGrid[0])\\n        \\n\\tdef index(i, j):\\n\\t\\treturn i * n + j\\n        \\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tcolor = targetGrid[i][j]\\n\\t\\t\\trows[color] = [min(rows[color][0], i), max(rows[color][1], i)]\\n\\t\\t\\tcols[color] = [min(cols[color][0], j), max(cols[color][1], j)]\\n\\t\\t\\tcolors[color].add(index(i, j))\\n                \\n\\tdef get_size(color): \\n\\t\\trow = rows[color]\\n\\t\\tcol = cols[color]\\n\\t\\treturn (row[1] - row[0] + 1) * (col[1] - col[0] + 1)\\n        \\n\\tdef overlap_size(this, that):\\n\\t\\trow_this = rows[this]\\n\\t\\trow_that = rows[that]\\n\\t\\tcol_this = cols[this]\\n\\t\\tcol_that = cols[that]\\n\\t\\treturn {index(i, j) for i in range(max(row_this[0], row_that[0]), min(row_this[1], row_that[1]) + 1) for j in range(max(col_this[0], col_that[0]), min(col_this[1], col_that[1]) + 1)}\\n            \\n\\tprinted = {color for color in colors if get_size(color) == len(colors[color])}\\n\\tleft =  set(colors.keys()) - printed\\n        \\n    while left:\\n\\t\\tif not printed:\\n\\t\\t\\treturn False\\n\\t\\tnext_printed = set()\\n\\t\\tfor color in printed:\\n\\t\\t\\tfor remain in left:\\n\\t\\t\\t\\tif remain in next_printed:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tcolors[remain] |= overlap_size(color, remain)\\n\\t\\t\\t\\tif len(colors[remain]) == get_size(remain):\\n\\t\\t\\t\\t\\tnext_printed.add(remain)\\n\\t\\tprinted = next_printed\\n\\t\\tleft = left - printed \\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2255333,
                "title": "c-find-most-recently-painted-blocks",
                "content": "The key to this problem is to think in reverse. It\\'s difficult to find out which color is printed first but it\\'s easier to find out which color is printed last.\\n```\\nclass Solution {\\npublic:\\n    int find(vector<vector<int>>& nums,int a,int b,int x,int y,int k){\\n        for(int i = a; i<=x;++i){\\n            for(int j = b; j<=y;++j){\\n                if(nums[i][j]==k || nums[i][j]==0) continue;\\n                else return 0;\\n            }\\n        }\\n        for(int i = a; i<=x;++i){\\n            for(int j = b; j<=y;++j) nums[i][j] = 0;\\n        }\\n        return 1;\\n    }\\n    bool isPrintable(vector<vector<int>>& nums) {\\n        unordered_map<int,pair<int,int>> max_;\\n        unordered_map<int,pair<int,int>> min_;\\n        unordered_set<int> mp;\\n        for(int i = 0; i<nums.size();++i){\\n            for(int j = 0; j<nums[0].size();++j){\\n                if(mp.find(nums[i][j])==mp.end()){\\n                    max_[nums[i][j]] = {i,j};\\n                    min_[nums[i][j]] = {i,j};\\n                }\\n                else{\\n                    max_[nums[i][j]].first = max(max_[nums[i][j]].first,i);\\n                    max_[nums[i][j]].second = max(max_[nums[i][j]].second,j);\\n                    min_[nums[i][j]].first = min(min_[nums[i][j]].first,i);\\n                    min_[nums[i][j]].second = min(min_[nums[i][j]].second,j);\\n                }\\n                mp.insert(nums[i][j]);\\n            }\\n        }\\n        while(mp.size()){\\n            bool st = 0;\\n            for(auto&it:mp){\\n                bool k = \\n                    find(nums,min_[it].first,min_[it].second,max_[it].first,max_[it].second,it);\\n                if(k==1){\\n                    st = 1; mp.erase(it);\\n                    break;\\n                }\\n            }\\n            if(st == 0) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<vector<int>>& nums,int a,int b,int x,int y,int k){\\n        for(int i = a; i<=x;++i){\\n            for(int j = b; j<=y;++j){\\n                if(nums[i][j]==k || nums[i][j]==0) continue;\\n                else return 0;\\n            }\\n        }\\n        for(int i = a; i<=x;++i){\\n            for(int j = b; j<=y;++j) nums[i][j] = 0;\\n        }\\n        return 1;\\n    }\\n    bool isPrintable(vector<vector<int>>& nums) {\\n        unordered_map<int,pair<int,int>> max_;\\n        unordered_map<int,pair<int,int>> min_;\\n        unordered_set<int> mp;\\n        for(int i = 0; i<nums.size();++i){\\n            for(int j = 0; j<nums[0].size();++j){\\n                if(mp.find(nums[i][j])==mp.end()){\\n                    max_[nums[i][j]] = {i,j};\\n                    min_[nums[i][j]] = {i,j};\\n                }\\n                else{\\n                    max_[nums[i][j]].first = max(max_[nums[i][j]].first,i);\\n                    max_[nums[i][j]].second = max(max_[nums[i][j]].second,j);\\n                    min_[nums[i][j]].first = min(min_[nums[i][j]].first,i);\\n                    min_[nums[i][j]].second = min(min_[nums[i][j]].second,j);\\n                }\\n                mp.insert(nums[i][j]);\\n            }\\n        }\\n        while(mp.size()){\\n            bool st = 0;\\n            for(auto&it:mp){\\n                bool k = \\n                    find(nums,min_[it].first,min_[it].second,max_[it].first,max_[it].second,it);\\n                if(k==1){\\n                    st = 1; mp.erase(it);\\n                    break;\\n                }\\n            }\\n            if(st == 0) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186860,
                "title": "c-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        unordered_map<int, vector<int>> myMap;\\n        int m = targetGrid.size();\\n        int n = targetGrid[0].size();\\n        unordered_map<int, unordered_set<int>> edge;\\n        unordered_map<int, int> indegree;\\n        int num_color = 0;\\n        for (int i=0; i<targetGrid.size(); ++i) {\\n            for (int j=0; j<targetGrid[0].size(); ++j) {\\n                int color = targetGrid[i][j];\\n                if (myMap.find(color) == myMap.end()) {\\n                    myMap[color] = {{INT_MAX, INT_MIN, INT_MAX, INT_MIN}};\\n                    indegree[color] = 0;\\n                    num_color ++;\\n                }\\n                myMap[color][0] = min(myMap[color][0], i);\\n                myMap[color][1] = max(myMap[color][1], i);\\n                myMap[color][2] = min(myMap[color][2], j);\\n                myMap[color][3] = max(myMap[color][3], j);\\n            }\\n        }\\n        \\n        for (auto it = myMap.begin(); it != myMap.end(); ++it) {\\n            for (int i=it->second[0]; i<=it->second[1]; ++i) {\\n                for (int j=it->second[2]; j <= it->second[3]; ++j) {\\n                    if (targetGrid[i][j] != it->first) {\\n                        if (edge[it->first].count(targetGrid[i][j]) == 0){\\n                            edge[it->first].insert(targetGrid[i][j]);\\n                            indegree[targetGrid[i][j]] ++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        queue<int> myQueue;\\n        for (auto it = indegree.begin(); it != indegree.end(); ++it) {\\n            if (it->second == 0) {\\n                myQueue.push(it->first);\\n            }\\n        }\\n        int color_count = 0;\\n        while (!myQueue.empty()) {\\n            int front = myQueue.front();\\n            myQueue.pop();\\n            color_count ++;\\n            for (auto it = edge[front].begin(); it!= edge[front].end(); ++it) {\\n                indegree[*it] --;\\n                if (indegree[*it] == 0) {\\n                    myQueue.push(*it);\\n                }\\n            }\\n        }\\n        return color_count == num_color;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        unordered_map<int, vector<int>> myMap;\\n        int m = targetGrid.size();\\n        int n = targetGrid[0].size();\\n        unordered_map<int, unordered_set<int>> edge;\\n        unordered_map<int, int> indegree;\\n        int num_color = 0;\\n        for (int i=0; i<targetGrid.size(); ++i) {\\n            for (int j=0; j<targetGrid[0].size(); ++j) {\\n                int color = targetGrid[i][j];\\n                if (myMap.find(color) == myMap.end()) {\\n                    myMap[color] = {{INT_MAX, INT_MIN, INT_MAX, INT_MIN}",
                "codeTag": "Java"
            },
            {
                "id": 2126926,
                "title": "javascript-topological-sort",
                "content": "The key to solving this is finding the colors that are mixed into a single colored rectangle. For example if there is a rectangle of 1s, and we can see that some segments of that rectangle are occupied by 2s and 3s, we should bind these into an adjacent set where we say the value 1 is adjacent to 2 and 3. And likewise the value of 1 is also within 2 and 3 within an opposite set.\\n\\nSorting backwards, any rectangle that is not sharing its space is easy to place and so we know we can paint those last. Afterwards we look for any rectangles that was sharing its space with the ones we just put into the back of the list. By checking to see if there\\'s no longer any shared colors in the adjacency map we can keep adding them to the list in this sorted order until the final sorted color is placed at the front of the list. This front color will be the color that shares most of its space with other colors and thus should be painted first so that the others can be painted on top.\\n\\n```\\nvar isPrintable = function (targetGrid) {\\n\\tconst n = targetGrid.length;\\n\\tconst m = targetGrid[0].length;\\n\\n\\tconst pointData = [];\\n\\n\\tlet list = new Set();\\n\\tconst outputCheck = [];\\n\\n\\tfor (let y = 0; y < n; ++y) {\\n\\t\\toutputCheck[y] = new Array(m).fill(0);\\n\\t\\tfor (let x = 0; x < m; ++x) {\\n\\t\\t\\tconst val = targetGrid[y][x];\\n\\t\\t\\tlist.add(val);\\n\\t\\t\\tif (pointData[val] === undefined) {\\n\\t\\t\\t\\tpointData[val] = {\\n\\t\\t\\t\\t\\tminX: Number.MAX_VALUE,\\n\\t\\t\\t\\t\\tminY: Number.MAX_VALUE,\\n\\t\\t\\t\\t\\tmaxX: -1,\\n\\t\\t\\t\\t\\tmaxY: -1,\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t\\tconst data = pointData[val];\\n\\t\\t\\tdata.minX = Math.min(data.minX, x);\\n\\t\\t\\tdata.minY = Math.min(data.minY, y);\\n\\t\\t\\tdata.maxX = Math.max(data.maxX, x);\\n\\t\\t\\tdata.maxY = Math.max(data.maxY, y);\\n\\t\\t}\\n\\t}\\n\\n\\t//this list is for storing all the colours inside the target color rectangle\\n\\t//example: box of 1s, has 2 and 3s inside it then this adj[1].has(2) && adj[1].has(3)\\n\\tconst adj = [];\\n\\n\\t//this list is the opposite to the adj list where this color exists in other colored rectangle spaces\\n\\t//example: if you have a rectangle of 2s and rectangle of 3s, the color 1 might exist in both of them so opp[1].has(2) && opp[1].has(3)\\n\\tconst opp = [];\\n\\n\\tfor (const val of list) {\\n\\t\\tconst { minX, minY, maxX, maxY } = pointData[val];\\n\\t\\tfor (let y = minY; y <= maxY; ++y) {\\n\\t\\t\\tfor (let x = minX; x <= maxX; ++x) {\\n\\t\\t\\t\\tconst cval = targetGrid[y][x];\\n\\t\\t\\t\\t//find colors that don\\'t belong to this space and bind them\\n\\t\\t\\t\\tif (cval !== val) {\\n\\t\\t\\t\\t\\tif (adj[val] === undefined) adj[val] = new Set();\\n\\t\\t\\t\\t\\tif (opp[cval] === undefined) opp[cval] = new Set();\\n\\t\\t\\t\\t\\tadj[val].add(cval);\\n\\t\\t\\t\\t\\topp[cval].add(val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tconst sortedList = getTopoSortedList(list);\\n\\n\\tfunction getTopoSortedList(list) {\\n\\t\\tlet output = new Set();\\n\\t\\tlet q = [];\\n\\t\\tfor (const val of list) {\\n\\t\\t\\tif (adj[val] === undefined) q.push(val);\\n\\t\\t}\\n\\t\\twhile (q.length) {\\n\\t\\t\\tconst value = q.shift();\\n\\t\\t\\tif (output.has(value)) continue;\\n\\t\\t\\toutput.add(value);\\n            if (opp[value]) {\\n                for (const node of opp[value]) {\\n                    adj[node].delete(value);\\n                    if (adj[node].size === 0) {\\n                        q.push(node);\\n                    }\\n                }   \\n            }\\n\\t\\t}\\n\\t\\treturn Array.from(output).reverse();\\n\\t}\\n\\n\\tfor (const val of sortedList) {\\n\\t\\tconst { minX, minY, maxX, maxY } = pointData[val];\\n\\t\\tfor (let y = minY; y <= maxY; ++y) {\\n\\t\\t\\tfor (let x = minX; x <= maxX; ++x) {\\n\\t\\t\\t\\toutputCheck[y][x] = val;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (let y = 0; y < n; ++y) {\\n\\t\\tfor (let x = 0; x < m; ++x) {\\n\\t\\t\\tif (targetGrid[y][x] !== outputCheck[y][x]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Topological Sort"
                ],
                "code": "```\\nvar isPrintable = function (targetGrid) {\\n\\tconst n = targetGrid.length;\\n\\tconst m = targetGrid[0].length;\\n\\n\\tconst pointData = [];\\n\\n\\tlet list = new Set();\\n\\tconst outputCheck = [];\\n\\n\\tfor (let y = 0; y < n; ++y) {\\n\\t\\toutputCheck[y] = new Array(m).fill(0);\\n\\t\\tfor (let x = 0; x < m; ++x) {\\n\\t\\t\\tconst val = targetGrid[y][x];\\n\\t\\t\\tlist.add(val);\\n\\t\\t\\tif (pointData[val] === undefined) {\\n\\t\\t\\t\\tpointData[val] = {\\n\\t\\t\\t\\t\\tminX: Number.MAX_VALUE,\\n\\t\\t\\t\\t\\tminY: Number.MAX_VALUE,\\n\\t\\t\\t\\t\\tmaxX: -1,\\n\\t\\t\\t\\t\\tmaxY: -1,\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t\\tconst data = pointData[val];\\n\\t\\t\\tdata.minX = Math.min(data.minX, x);\\n\\t\\t\\tdata.minY = Math.min(data.minY, y);\\n\\t\\t\\tdata.maxX = Math.max(data.maxX, x);\\n\\t\\t\\tdata.maxY = Math.max(data.maxY, y);\\n\\t\\t}\\n\\t}\\n\\n\\t//this list is for storing all the colours inside the target color rectangle\\n\\t//example: box of 1s, has 2 and 3s inside it then this adj[1].has(2) && adj[1].has(3)\\n\\tconst adj = [];\\n\\n\\t//this list is the opposite to the adj list where this color exists in other colored rectangle spaces\\n\\t//example: if you have a rectangle of 2s and rectangle of 3s, the color 1 might exist in both of them so opp[1].has(2) && opp[1].has(3)\\n\\tconst opp = [];\\n\\n\\tfor (const val of list) {\\n\\t\\tconst { minX, minY, maxX, maxY } = pointData[val];\\n\\t\\tfor (let y = minY; y <= maxY; ++y) {\\n\\t\\t\\tfor (let x = minX; x <= maxX; ++x) {\\n\\t\\t\\t\\tconst cval = targetGrid[y][x];\\n\\t\\t\\t\\t//find colors that don\\'t belong to this space and bind them\\n\\t\\t\\t\\tif (cval !== val) {\\n\\t\\t\\t\\t\\tif (adj[val] === undefined) adj[val] = new Set();\\n\\t\\t\\t\\t\\tif (opp[cval] === undefined) opp[cval] = new Set();\\n\\t\\t\\t\\t\\tadj[val].add(cval);\\n\\t\\t\\t\\t\\topp[cval].add(val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tconst sortedList = getTopoSortedList(list);\\n\\n\\tfunction getTopoSortedList(list) {\\n\\t\\tlet output = new Set();\\n\\t\\tlet q = [];\\n\\t\\tfor (const val of list) {\\n\\t\\t\\tif (adj[val] === undefined) q.push(val);\\n\\t\\t}\\n\\t\\twhile (q.length) {\\n\\t\\t\\tconst value = q.shift();\\n\\t\\t\\tif (output.has(value)) continue;\\n\\t\\t\\toutput.add(value);\\n            if (opp[value]) {\\n                for (const node of opp[value]) {\\n                    adj[node].delete(value);\\n                    if (adj[node].size === 0) {\\n                        q.push(node);\\n                    }\\n                }   \\n            }\\n\\t\\t}\\n\\t\\treturn Array.from(output).reverse();\\n\\t}\\n\\n\\tfor (const val of sortedList) {\\n\\t\\tconst { minX, minY, maxX, maxY } = pointData[val];\\n\\t\\tfor (let y = minY; y <= maxY; ++y) {\\n\\t\\t\\tfor (let x = minX; x <= maxX; ++x) {\\n\\t\\t\\t\\toutputCheck[y][x] = val;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (let y = 0; y < n; ++y) {\\n\\t\\tfor (let x = 0; x < m; ++x) {\\n\\t\\t\\tif (targetGrid[y][x] !== outputCheck[y][x]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2110826,
                "title": "c-brute-force",
                "content": "Let\\'s introduce *joker* `color == 0` - color which is overpainted by some other colors.\\nWe can draw `color` if and only if all cells of this color make a *rectangle* which has `color` and joker color only.\\nWhen we find `color` which can be painted we change all cells of this color into joker color:\\n\\n```\\ninitial       1st       2nd          3d\\n1111         1111       1111        0000\\n1133         1133       1100        0000\\n1134         1130       1100        0000\\n5514         0010       0010        0000\\n```\\n\\n**Code:**\\n\\n```\\npublic class Solution {\\n    \\n    private static bool TryColor(int[][] grid, \\n                                 int color, \\n                                 (int left, int top, int right, int bottom) rect) {\\n        bool result = true;\\n        \\n        for (int r = rect.top; r <= rect.bottom; ++r)\\n            for (int c = rect.left; c <= rect.right; ++c)\\n                if (grid[r][c] > 0 && grid[r][c] != color)\\n                    return false;\\n        \\n        for (int r = rect.top; r <= rect.bottom; ++r)\\n            for (int c = rect.left; c <= rect.right; ++c)\\n                grid[r][c] = 0;\\n        \\n        return true;\\n    }\\n    \\n    public bool IsPrintable(int[][] targetGrid) {\\n      Dictionary<int, (int left, int top, int right, int bottom)> patches = new();\\n\\n      HashSet<int> colors = new();\\n\\n      for (int r = 0; r < targetGrid.Length; ++r)\\n        for (int c = 0; c < targetGrid[r].Length; ++c) {\\n          int color = targetGrid[r][c];\\n\\n          colors.Add(color);\\n\\n          if (patches.TryGetValue(color, out var rect)) {\\n            patches[color] = (\\n                Math.Min(c, rect.left),\\n                Math.Min(r, rect.top),\\n                Math.Max(c, rect.right),\\n                Math.Max(r, rect.bottom)\\n            );\\n          }\\n          else\\n            patches.Add(color, (c, r, c, r));\\n        }\\n\\n      for (bool agenda = true; agenda;) {\\n        agenda = false;\\n\\n        foreach (var color in colors.ToList()) {\\n          if (TryColor(targetGrid, color, patches[color])) {\\n            agenda = true;\\n\\n            colors.Remove(color);\\n          }\\n        }\\n      }\\n\\n      return colors.Count <= 0;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\ninitial       1st       2nd          3d\\n1111         1111       1111        0000\\n1133         1133       1100        0000\\n1134         1130       1100        0000\\n5514         0010       0010        0000\\n```\n```\\npublic class Solution {\\n    \\n    private static bool TryColor(int[][] grid, \\n                                 int color, \\n                                 (int left, int top, int right, int bottom) rect) {\\n        bool result = true;\\n        \\n        for (int r = rect.top; r <= rect.bottom; ++r)\\n            for (int c = rect.left; c <= rect.right; ++c)\\n                if (grid[r][c] > 0 && grid[r][c] != color)\\n                    return false;\\n        \\n        for (int r = rect.top; r <= rect.bottom; ++r)\\n            for (int c = rect.left; c <= rect.right; ++c)\\n                grid[r][c] = 0;\\n        \\n        return true;\\n    }\\n    \\n    public bool IsPrintable(int[][] targetGrid) {\\n      Dictionary<int, (int left, int top, int right, int bottom)> patches = new();\\n\\n      HashSet<int> colors = new();\\n\\n      for (int r = 0; r < targetGrid.Length; ++r)\\n        for (int c = 0; c < targetGrid[r].Length; ++c) {\\n          int color = targetGrid[r][c];\\n\\n          colors.Add(color);\\n\\n          if (patches.TryGetValue(color, out var rect)) {\\n            patches[color] = (\\n                Math.Min(c, rect.left),\\n                Math.Min(r, rect.top),\\n                Math.Max(c, rect.right),\\n                Math.Max(r, rect.bottom)\\n            );\\n          }\\n          else\\n            patches.Add(color, (c, r, c, r));\\n        }\\n\\n      for (bool agenda = true; agenda;) {\\n        agenda = false;\\n\\n        foreach (var color in colors.ToList()) {\\n          if (TryColor(targetGrid, color, patches[color])) {\\n            agenda = true;\\n\\n            colors.Remove(color);\\n          }\\n        }\\n      }\\n\\n      return colors.Count <= 0;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105309,
                "title": "hard-brute-force",
                "content": "```\\n#define pll pair<int,int>\\n#define ff first\\n#define ss second\\n\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<pair<int,pair<pll,pll>>> v;\\n    vector<vector<int>> a;\\n    \\n    bool update()\\n    {\\n        vector<pair<pll,pll>> ans;\\n        for(int k=0;k<v.size();k++)\\n        {\\n            if(v[k].ff==-1) continue;\\n            int x=v[k].ss.ff.ff,y=v[k].ss.ff.ss;\\n            int p=v[k].ss.ss.ff,q=v[k].ss.ss.ss;\\n            int yes=1;\\n            for(int i=x;i<=p;i++)\\n                for(int j=y;j<=q;j++)\\n                    if(a[i][j]!=\\'0\\' && v[k].ff!=a[i][j]) \\n                        yes=0;\\n            if(yes)\\n            {\\n                v[k].ff=-1;\\n                for(int i=x;i<=p;i++)\\n                    for(int j=y;j<=q;j++)\\n                        a[i][j]=\\'0\\';\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    \\n    bool isPrintable(vector<vector<int>>& targetGrid) \\n    {\\n        a=targetGrid;\\n        n=a.size(); m=a[0].size();\\n       \\n        map<int,pll> mn,mx;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n                int cl=a[i][j];\\n                if(mn.count(cl))\\n                {\\n                    pll p=mn[cl],q=mx[cl];\\n                    p.ff=min(p.ff,i); p.ss=min(p.ss,j);\\n                    q.ff=max(q.ff,i); q.ss=max(q.ss,j);\\n                    mn[cl]=p; mx[cl]=q;\\n                }\\n                else mn[cl]=mx[cl]={i,j};\\n            }\\n        \\n        for(auto i:mn)\\n            v.push_back({i.ff,{i.ss,mx[i.ff]}});\\n       \\n        while(update());\\n        \\n        int yes=1;\\n        for(int i=0;i<v.size();i++)\\n            if(v[i].ff!=-1) yes=0;\\n        return yes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define pll pair<int,int>\\n#define ff first\\n#define ss second\\n\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<pair<int,pair<pll,pll>>> v;\\n    vector<vector<int>> a;\\n    \\n    bool update()\\n    {\\n        vector<pair<pll,pll>> ans;\\n        for(int k=0;k<v.size();k++)\\n        {\\n            if(v[k].ff==-1) continue;\\n            int x=v[k].ss.ff.ff,y=v[k].ss.ff.ss;\\n            int p=v[k].ss.ss.ff,q=v[k].ss.ss.ss;\\n            int yes=1;\\n            for(int i=x;i<=p;i++)\\n                for(int j=y;j<=q;j++)\\n                    if(a[i][j]!=\\'0\\' && v[k].ff!=a[i][j]) \\n                        yes=0;\\n            if(yes)\\n            {\\n                v[k].ff=-1;\\n                for(int i=x;i<=p;i++)\\n                    for(int j=y;j<=q;j++)\\n                        a[i][j]=\\'0\\';\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    \\n    bool isPrintable(vector<vector<int>>& targetGrid) \\n    {\\n        a=targetGrid;\\n        n=a.size(); m=a[0].size();\\n       \\n        map<int,pll> mn,mx;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n                int cl=a[i][j];\\n                if(mn.count(cl))\\n                {\\n                    pll p=mn[cl],q=mx[cl];\\n                    p.ff=min(p.ff,i); p.ss=min(p.ss,j);\\n                    q.ff=max(q.ff,i); q.ss=max(q.ss,j);\\n                    mn[cl]=p; mx[cl]=q;\\n                }\\n                else mn[cl]=mx[cl]={i,j};\\n            }\\n        \\n        for(auto i:mn)\\n            v.push_back({i.ff,{i.ss,mx[i.ff]}});\\n       \\n        while(update());\\n        \\n        int yes=1;\\n        for(int i=0;i<v.size();i++)\\n            if(v[i].ff!=-1) yes=0;\\n        return yes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091631,
                "title": "java-topological-sort-tc-o-n-3-sc-o-n-2",
                "content": "```\\nclass Solution {\\n    // store each color\\'s left, top, right, bottom\\n    private Set<Integer>[] graph;\\n    private int[] indegrees;\\n    private int[][] ranges; \\n    private boolean[] exists;\\n    private int m;\\n    private int n;\\n    private int maxColor = 60; \\n    public boolean isPrintable(int[][] targetGrid) {\\n        this.m = targetGrid.length;\\n        this.n = targetGrid[0].length;\\n        buildRanges(targetGrid);\\n        buildGraph(targetGrid);\\n        int count = 0;\\n        int totalCount = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 1; i <= maxColor; i++) {\\n            if (exists[i]) {\\n                if (indegrees[i] == 0) {\\n                    queue.offer(i);\\n                }\\n                totalCount++;\\n            }\\n        }\\n        while (!queue.isEmpty()) {\\n            count++;\\n            Integer current = queue.poll();\\n            for (Integer neighbor: graph[current]) {\\n                if (--indegrees[neighbor] == 0) {\\n                    queue.offer(neighbor);\\n                }\\n            }\\n        }\\n        return count == totalCount;\\n    }\\n    private void buildRanges(int[][] targetGrid) {\\n        this.ranges = new int[maxColor + 1][4];\\n        for (int i = 1; i <= maxColor; i++) {\\n            ranges[i][0] = ranges[i][1] = Integer.MAX_VALUE;\\n            ranges[i][2] = ranges[i][3] = Integer.MIN_VALUE;\\n        }\\n        exists = new boolean[maxColor + 1];\\n        int max = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int color = targetGrid[i][j];\\n                exists[color] = true;\\n                max = Math.max(max, color);\\n                ranges[color][0] = Math.min(ranges[color][0], j);\\n                ranges[color][1] = Math.min(ranges[color][1], i);\\n                ranges[color][2] = Math.max(ranges[color][2], j);\\n                ranges[color][3] = Math.max(ranges[color][3], i);\\n            }\\n        }\\n        maxColor = max;\\n    }\\n\\t// TC O(n^3) to build graph\\n    private void buildGraph(int[][] targetGrid) {\\n        graph = new Set[maxColor + 1];\\n        indegrees = new int[maxColor + 1];\\n        for (int c = 1; c <= maxColor; c++) {\\n            if (exists[c]) {\\n                graph[c] = new HashSet<>();\\n                for (int i = ranges[c][1]; i <= ranges[c][3]; i++) {\\n                    for (int j = ranges[c][0]; j <= ranges[c][2]; j++) {\\n                        int other = targetGrid[i][j];\\n                        if (other != c && !graph[c].contains(other)) {\\n                            graph[c].add(other);\\n                            indegrees[other]++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    // store each color\\'s left, top, right, bottom\\n    private Set<Integer>[] graph;\\n    private int[] indegrees;\\n    private int[][] ranges; \\n    private boolean[] exists;\\n    private int m;\\n    private int n;\\n    private int maxColor = 60; \\n    public boolean isPrintable(int[][] targetGrid) {\\n        this.m = targetGrid.length;\\n        this.n = targetGrid[0].length;\\n        buildRanges(targetGrid);\\n        buildGraph(targetGrid);\\n        int count = 0;\\n        int totalCount = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 1; i <= maxColor; i++) {\\n            if (exists[i]) {\\n                if (indegrees[i] == 0) {\\n                    queue.offer(i);\\n                }\\n                totalCount++;\\n            }\\n        }\\n        while (!queue.isEmpty()) {\\n            count++;\\n            Integer current = queue.poll();\\n            for (Integer neighbor: graph[current]) {\\n                if (--indegrees[neighbor] == 0) {\\n                    queue.offer(neighbor);\\n                }\\n            }\\n        }\\n        return count == totalCount;\\n    }\\n    private void buildRanges(int[][] targetGrid) {\\n        this.ranges = new int[maxColor + 1][4];\\n        for (int i = 1; i <= maxColor; i++) {\\n            ranges[i][0] = ranges[i][1] = Integer.MAX_VALUE;\\n            ranges[i][2] = ranges[i][3] = Integer.MIN_VALUE;\\n        }\\n        exists = new boolean[maxColor + 1];\\n        int max = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int color = targetGrid[i][j];\\n                exists[color] = true;\\n                max = Math.max(max, color);\\n                ranges[color][0] = Math.min(ranges[color][0], j);\\n                ranges[color][1] = Math.min(ranges[color][1], i);\\n                ranges[color][2] = Math.max(ranges[color][2], j);\\n                ranges[color][3] = Math.max(ranges[color][3], i);\\n            }\\n        }\\n        maxColor = max;\\n    }\\n\\t// TC O(n^3) to build graph\\n    private void buildGraph(int[][] targetGrid) {\\n        graph = new Set[maxColor + 1];\\n        indegrees = new int[maxColor + 1];\\n        for (int c = 1; c <= maxColor; c++) {\\n            if (exists[c]) {\\n                graph[c] = new HashSet<>();\\n                for (int i = ranges[c][1]; i <= ranges[c][3]; i++) {\\n                    for (int j = ranges[c][0]; j <= ranges[c][2]; j++) {\\n                        int other = targetGrid[i][j];\\n                        if (other != c && !graph[c].contains(other)) {\\n                            graph[c].add(other);\\n                            indegrees[other]++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073544,
                "title": "java-kahn-s-algorithm",
                "content": "```\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        int LEFT = 0, RIGHT = 1, TOP = 2, BOTTOM = 3;\\n        Map<Integer, int[]> coordinates = new HashMap<>();  // {left, right, top, bottom}\\n        Map<Integer, Set<Integer>> adj = new HashMap<>();   // adjacency list for colors\\n        Map<Integer, Integer> indegree = new HashMap<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        int m = targetGrid.length, n = targetGrid[0].length;\\n        \\n        // Finding the stretch of each color\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int color = targetGrid[i][j];\\n                if (coordinates.containsKey(color)) {\\n                    int[] coordinate = coordinates.get(color);\\n                    coordinate[LEFT] = Math.min(coordinate[LEFT], j);\\n                    coordinate[RIGHT] = Math.max(coordinate[RIGHT], j);\\n                    coordinate[TOP] = Math.min(coordinate[TOP], i);\\n                    coordinate[BOTTOM] = Math.max(coordinate[BOTTOM], i);\\n                } else {\\n                    coordinates.put(color, new int[]{j, j, i, i});\\n                    adj.put(color, new HashSet<>());\\n                }\\n            }\\n        }\\n        \\n        // Building an adjacency list\\n        for (Map.Entry<Integer, int[]> entry : coordinates.entrySet()) {\\n            Integer currentColor = entry.getKey();\\n            int[] coordinate = entry.getValue();\\n            for (int i = coordinate[TOP]; i <= coordinate[BOTTOM]; ++i) {\\n                for (int j = coordinate[LEFT]; j <= coordinate[RIGHT]; ++j) {\\n                    int color = targetGrid[i][j];\\n                    if (currentColor != color) {\\n                        adj.get(currentColor).add(color);\\n                    }\\n                }\\n            }\\n            indegree.put(currentColor, 0);\\n        }\\n        \\n        // Update indegrees of each color\\n        for (Set<Integer> entry : adj.values()) {\\n            for (int color : entry) {\\n                indegree.put(color, indegree.get(color) + 1);\\n            }\\n        }\\n        \\n        // Add nodes with zero indegree to the queue\\n        for (Map.Entry<Integer, Integer> entry : indegree.entrySet()) {\\n            if (entry.getValue() == 0)\\n                q.add(entry.getKey());\\n        }\\n        \\n\\t\\t// Kahn\\'s algorithm in action\\n        int size = 0;\\n        while (!q.isEmpty()) {\\n            int currentColor = q.remove();\\n            size++;\\n            for (int color : adj.get(currentColor)) {\\n                indegree.put(color, indegree.get(color) - 1);\\n                if (indegree.get(color) == 0)\\n                    q.add(color);\\n            }\\n        }\\n        \\n\\t\\t// If there was a cycle, all the nodes wouldn\\'t have been processed, \\n\\t\\t// since there is no valid topological order.\\n        return size == adj.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        int LEFT = 0, RIGHT = 1, TOP = 2, BOTTOM = 3;\\n        Map<Integer, int[]> coordinates = new HashMap<>();  // {left, right, top, bottom}\\n        Map<Integer, Set<Integer>> adj = new HashMap<>();   // adjacency list for colors\\n        Map<Integer, Integer> indegree = new HashMap<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        int m = targetGrid.length, n = targetGrid[0].length;\\n        \\n        // Finding the stretch of each color\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int color = targetGrid[i][j];\\n                if (coordinates.containsKey(color)) {\\n                    int[] coordinate = coordinates.get(color);\\n                    coordinate[LEFT] = Math.min(coordinate[LEFT], j);\\n                    coordinate[RIGHT] = Math.max(coordinate[RIGHT], j);\\n                    coordinate[TOP] = Math.min(coordinate[TOP], i);\\n                    coordinate[BOTTOM] = Math.max(coordinate[BOTTOM], i);\\n                } else {\\n                    coordinates.put(color, new int[]{j, j, i, i});\\n                    adj.put(color, new HashSet<>());\\n                }\\n            }\\n        }\\n        \\n        // Building an adjacency list\\n        for (Map.Entry<Integer, int[]> entry : coordinates.entrySet()) {\\n            Integer currentColor = entry.getKey();\\n            int[] coordinate = entry.getValue();\\n            for (int i = coordinate[TOP]; i <= coordinate[BOTTOM]; ++i) {\\n                for (int j = coordinate[LEFT]; j <= coordinate[RIGHT]; ++j) {\\n                    int color = targetGrid[i][j];\\n                    if (currentColor != color) {\\n                        adj.get(currentColor).add(color);\\n                    }\\n                }\\n            }\\n            indegree.put(currentColor, 0);\\n        }\\n        \\n        // Update indegrees of each color\\n        for (Set<Integer> entry : adj.values()) {\\n            for (int color : entry) {\\n                indegree.put(color, indegree.get(color) + 1);\\n            }\\n        }\\n        \\n        // Add nodes with zero indegree to the queue\\n        for (Map.Entry<Integer, Integer> entry : indegree.entrySet()) {\\n            if (entry.getValue() == 0)\\n                q.add(entry.getKey());\\n        }\\n        \\n\\t\\t// Kahn\\'s algorithm in action\\n        int size = 0;\\n        while (!q.isEmpty()) {\\n            int currentColor = q.remove();\\n            size++;\\n            for (int color : adj.get(currentColor)) {\\n                indegree.put(color, indegree.get(color) - 1);\\n                if (indegree.get(color) == 0)\\n                    q.add(color);\\n            }\\n        }\\n        \\n\\t\\t// If there was a cycle, all the nodes wouldn\\'t have been processed, \\n\\t\\t// since there is no valid topological order.\\n        return size == adj.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989601,
                "title": "c-with-comment",
                "content": "class Solution {\\npublic:\\n    /* 1. First find the (left/right/up/down) most grid index of one specific color\\n       It is documented in the map ma: ma[color index]={ box.l(min j), box.r(max j),  box.u(min i), box.d(max i)}\\n       this determines the rectangle(of this color) used for coloring.\\n       \\n       2. Determine the order of coloring from the overlap part of the grid. The order of coloring is documented\\n       in col_order vector, start coloring an empty grid with col_order[i] from i=0 to col_order.size()-1.\\n       \\n       3. col_order vector needed to be sort according to the overlap region coloring.\\n          function order : bubble sort the col_order.\\n          function flip  : if two color region overlaps, determine the color and decide whether exchange\\n          c1=col_order[i] &\\n          c2=col_order[j]\\n          .The top most part must be colored later.\\n       4. Color dummy grid t with color according to col_order in region ma[color index].\\n          Check if dummy t is the targetGrid.\\n          \\n        * print is for printing col_order. uncomment line 70 to observe bubble sort\\n    \\n    \\n    */\\n    map<int,vector<int>> ma;  //(color index)->{ box.l(min j), box.r(max j),  box.u(min i), box.d(max i)}\\n    map<int,vector<int>>::iterator it;\\n    vector<vector<int>> grid;\\n    bool flip(int c1,int c2){\\n        int i,j,l1,l2,r1,r2,d1,d2,u1,u2,m,n;\\n        m=grid.size();\\n        n=grid[0].size();\\n        l1=ma[c1][0];\\n        l2=ma[c2][0];\\n        r1=ma[c1][1];\\n        r2=ma[c2][1];\\n        d1=ma[c1][3];\\n        d2=ma[c2][3];\\n        u1=ma[c1][2];\\n        u2=ma[c2][2];\\n        if(r1<l2 or r2<l1 or u1>d2 or u2>d1) return false;\\n        //if(r1>l2 and u1<d2) return (grid[u1][r1]==c1);//upper right covered\\n        for(i=0;i<m;i++){\\n        for(j=0;j<n;j++){\\n            //cout<<d1<<d2<<u1<<u2<<endl;\\n            if(i>=u1 and i>=u2 and i<=d1 and i<=d2 and j>=l1 and j>=l2 and j<=r1 and j<=r2){\\n                //cout<<(grid[i][j])<<\" \"<<c1<<\" \"<<c2<<endl;\\n                return (grid[i][j] ==c1);\\n            }\\n        }\\n        }\\n        return false;\\n        \\n    }\\n    void print(vector<int>& col_order) {\\n        int i,j,n,tmp;\\n        n=col_order.size();\\n        for(i=0;i<n;i++){cout<<col_order[i]<<\" \";}\\n        cout<<endl;\\n        return;\\n    }\\n    void order(vector<int>& col_order) {\\n        int i,j,n,tmp;\\n        n=col_order.size();\\n        //col_order={5,4,3,1};\\n        //print(col_order);\\n        for(i=0;i<n;i++){\\n        for(j=i+1;j<n;j++){\\n            if(flip(col_order[i],col_order[j]) == true) {//col_order[j] is colored later than col_order[i]\\n            tmp=col_order[i];\\n            col_order[i]=col_order[j];\\n            col_order[j]=tmp;\\n            //print(col_order);\\n            }\\n        }    \\n        }\\n        return;\\n    }\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n    grid=targetGrid;  \\n    vector<vector<int>> t;\\n    vector<int> col_order;\\n    int i,j,k,n,m;\\n    //begin constructing map ma\\n    m=targetGrid.size();\\n    n=targetGrid[0].size();\\n    for(i=0;i<m;i++){\\n    for(j=0;j<n;j++){\\n        if(ma.find(targetGrid[i][j])==ma.end()){\\n            ma[targetGrid[i][j]]={j,j,i,i};\\n             \\n        }\\n        if(j<ma[targetGrid[i][j]][0]) ma[targetGrid[i][j]][0]=j;\\n        if(j>ma[targetGrid[i][j]][1]) ma[targetGrid[i][j]][1]=j;\\n        if(i<ma[targetGrid[i][j]][2]) ma[targetGrid[i][j]][2]=i;\\n        if(i>ma[targetGrid[i][j]][3]) ma[targetGrid[i][j]][3]=i;\\n    }   \\n    }\\n    //end constructing map ma\\n        \\n    //begin constructing coloring order col_order\\n    for(it=ma.begin();it!=ma.end();it++){\\n        col_order.push_back(it->first);\\n    }\\n    //print(col_order);\\n    order(col_order);   //bubble sort\\n    //print(col_order);\\n    //end constructing coloring order col_order\\n    \\n    //use dummy grid t to check if the grid can be reconstructed.\\n    t=vector(m,vector<int> (n,0));\\n    for(k=0;k<col_order.size();k++)  {\\n    for(i=ma[col_order[k]][2];i<=ma[col_order[k]][3];i++){\\n        for(j=ma[col_order[k]][0];j<=ma[col_order[k]][1];j++){\\n            t[i][j]=col_order[k];\\n        }\\n    }\\n    }\\n    //dummy grid t is constructed and colored\\n    //check\\n    for(i=0;i<m;i++){\\n    for(j=0;j<n;j++){\\n        if( targetGrid[i][j] !=t[i][j]) return false;\\n        \\n    }\\n    }\\n    return true;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    /* 1. First find the (left/right/up/down) most grid index of one specific color\\n       It is documented in the map ma: ma[color index]={ box.l(min j), box.r(max j),  box.u(min i), box.d(max i)}",
                "codeTag": "Java"
            },
            {
                "id": 1949381,
                "title": "c-99-34-faster-but-i-can-t-find-time-complexity",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstruct Color {\\n\\t\\t\\tint xmin, ymin, xmax, ymax, visited;\\n\\t\\t\\tColor () {\\n\\t\\t\\t\\txmin = 100; ymin = 100; xmax = -1; ymax = -1;\\n\\t\\t\\t\\tvisited = false;\\n\\t\\t\\t}\\n\\t\\t\\tvoid push(int i, int j) {\\n\\t\\t\\t\\txmin = min(i, xmin);\\n\\t\\t\\t\\tymin = min(j, ymin);\\n\\t\\t\\t\\txmax = max(i, xmax);\\n\\t\\t\\t\\tymax = max(j, ymax);\\n\\t\\t\\t}\\n\\t\\t\\tvoid change(vector<vector<int>>& grid) {\\n\\t\\t\\t\\tfor(int i = xmin; i <= xmax; i++) \\n\\t\\t\\t\\t\\tfor(int j = ymin; j <= ymax; j++) \\n\\t\\t\\t\\t\\t\\tgrid[i][j] = 100;\\n\\t\\t\\t\\tvisited = true;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tbool isPrintable(vector<vector<int>>& targetGrid) {\\n\\t\\t\\tint m = targetGrid.size(), n = targetGrid[0].size();\\n\\t\\t\\tvector<Color> color(70);\\n\\t\\t\\tunordered_set<int> colorInGrid;\\n\\t\\t\\tfor(int i = 0; i < m; i++) \\n\\t\\t\\t\\tfor(int j = 0; j < n; j++) \\n\\t\\t\\t\\t   color[targetGrid[i][j]].push(i, j), colorInGrid.insert(targetGrid[i][j]);       \\n\\n\\t\\t\\tbool ok = true;\\n\\t\\t\\twhile(ok) {\\n\\t\\t\\t\\tok = false;\\n\\t\\t\\t\\tfor(auto& c : colorInGrid) {\\n\\t\\t\\t\\t\\tif(color[c].visited) continue;\\n\\t\\t\\t\\t\\tbool findRec = true;\\n\\t\\t\\t\\t\\tfor(int i = color[c].xmin; i <= color[c].xmax && !findRec ; i++) \\n\\t\\t\\t\\t\\t\\tfor(int j = color[c].ymin; j <= color[c].ymax && !findRec ; j++) \\n\\t\\t\\t\\t\\t\\t\\tif(targetGrid[i][j] != 100 && targetGrid[i][j] != c) findRec  = true;\\n\\t\\t\\t\\t\\tif(findRec == true) {\\n\\t\\t\\t\\t\\t\\tok = true;\\n\\t\\t\\t\\t\\t\\tcolor[c].change(targetGrid);\\n\\t\\t\\t\\t\\t}    \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < m; i++) \\n\\t\\t\\t\\tfor(int j = 0; j < n; j++) \\n\\t\\t\\t\\t\\tif(targetGrid[i][j] != 100) return false;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstruct Color {\\n\\t\\t\\tint xmin, ymin, xmax, ymax, visited;\\n\\t\\t\\tColor () {\\n\\t\\t\\t\\txmin = 100; ymin = 100; xmax = -1; ymax = -1;\\n\\t\\t\\t\\tvisited = false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1831740,
                "title": "c-solution-using-topological-sort",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int maxColors=60;\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m=targetGrid.size();\\n        int n=targetGrid[0].size();\\n        unordered_map<int,vector<int>> umap;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int color = targetGrid[i][j];\\n                if(umap.find(color) == umap.end()){\\n                    umap[color]={i,i,j,j};\\n                }\\n                else{\\n                    umap[color][0]=min(umap[color][0],i);\\n                    umap[color][1]=max(umap[color][1],i);\\n                    umap[color][2]=min(umap[color][2],j);\\n                    umap[color][3]=max(umap[color][3],j);\\n                }\\n            }\\n        }\\n        vector<vector<int>> graph(maxColors+1,vector<int>());\\n        vector<int> inDegree(maxColors+1,-1);\\n        for(auto itr : umap){\\n            int color=itr.first;\\n            int rowStart=itr.second[0];\\n            int rowEnd=itr.second[1];\\n            int columnStart=itr.second[2];\\n            int columnEnd=itr.second[3];\\n            vector<int> visited(maxColors+1,false);\\n            if(inDegree[color] == -1){\\n                inDegree[color]=0;\\n            }\\n            for(int i=rowStart;i<=rowEnd;i++){\\n                for(int j=columnStart;j<=columnEnd;j++){\\n                    if(color != targetGrid[i][j]){\\n                        if(visited[targetGrid[i][j]] == false){\\n                            graph[color].push_back(targetGrid[i][j]);\\n                            if(inDegree[targetGrid[i][j]] == -1){\\n                                inDegree[targetGrid[i][j]]=0;\\n                            }\\n                            inDegree[targetGrid[i][j]]++;\\n                            visited[targetGrid[i][j]]=true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        queue<int> bfsQueue;\\n        int totalColors=0;\\n        for(int i=0;i<=maxColors;i++){\\n            if(inDegree[i] != -1){\\n                totalColors++;\\n            }\\n            if(inDegree[i] == 0){\\n                bfsQueue.push(i);\\n            }\\n        }\\n        while(!bfsQueue.empty()){\\n            int front=bfsQueue.front();\\n            bfsQueue.pop();\\n            totalColors--;\\n            for(int i=0;i<graph[front].size();i++){\\n                int p=graph[front][i];\\n                inDegree[p]--;\\n                if(inDegree[p] == 0){\\n                    bfsQueue.push(p);\\n                }\\n            }\\n        }\\n        return totalColors == 0;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int maxColors=60;\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m=targetGrid.size();\\n        int n=targetGrid[0].size();\\n        unordered_map<int,vector<int>> umap;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int color = targetGrid[i][j];\\n                if(umap.find(color) == umap.end()){\\n                    umap[color]={i,i,j,j}",
                "codeTag": "Java"
            },
            {
                "id": 1793267,
                "title": "c-topo-sort",
                "content": "```\\n//Find prerequisites for each color and then use toposort\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector<vector<int>>adj;\\n    vector<int>indeg;\\n    set<int>colors;\\n    void find(int col,vector<vector<int>>&grid)\\n    {\\n        //Find extreme points for the color \\'col\\'\\n        int r1=-1,r2=-1,c1=-1,c2=-1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==col)\\n                {\\n                    if(r1==-1)\\n                    {\\n                        r1=r2=i;\\n                        c1=c2=j;\\n                    }\\n                    else\\n                    {\\n                        r2=i;\\n                        c1=min(c1,j);\\n                        c2=max(c2,j);\\n                    }\\n                }\\n            }\\n        }\\n        if(r1==-1)\\n            return;\\n        colors.insert(col);\\n        // No. of different colors in this boundary are prerequisite for \\'col\\'\\n        for(int i=r1;i<=r2;i++)\\n        {\\n            for(int j=c1;j<=c2;j++)\\n            {\\n                if(grid[i][j]!=col)\\n                {\\n                    adj[grid[i][j]].push_back(col);\\n                    indeg[col]++;\\n                }\\n            }\\n        }\\n    }\\n    bool isPrintable(vector<vector<int>>&grid) \\n    {\\n        m=grid.size(),n=grid[0].size();\\n        adj.resize(61);\\n        indeg.resize(61);\\n        for(int i=1;i<=60;i++)\\n            find(i,grid);\\n        queue<int>q;\\n        for(int i=1;i<=60;i++)\\n        {\\n            if(indeg[i]==0 && colors.find(i)!=colors.end())\\n                q.push(i);\\n        }\\n        int count=0;\\n        while(!q.empty())\\n        {\\n            int u=q.front();\\n            count++;\\n            q.pop();\\n            for(auto &v:adj[u])\\n            {\\n                indeg[v]--;\\n                if(indeg[v]==0)\\n                    q.push(v);\\n            }\\n        }\\n        return count==colors.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Find prerequisites for each color and then use toposort\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector<vector<int>>adj;\\n    vector<int>indeg;\\n    set<int>colors;\\n    void find(int col,vector<vector<int>>&grid)\\n    {\\n        //Find extreme points for the color \\'col\\'\\n        int r1=-1,r2=-1,c1=-1,c2=-1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==col)\\n                {\\n                    if(r1==-1)\\n                    {\\n                        r1=r2=i;\\n                        c1=c2=j;\\n                    }\\n                    else\\n                    {\\n                        r2=i;\\n                        c1=min(c1,j);\\n                        c2=max(c2,j);\\n                    }\\n                }\\n            }\\n        }\\n        if(r1==-1)\\n            return;\\n        colors.insert(col);\\n        // No. of different colors in this boundary are prerequisite for \\'col\\'\\n        for(int i=r1;i<=r2;i++)\\n        {\\n            for(int j=c1;j<=c2;j++)\\n            {\\n                if(grid[i][j]!=col)\\n                {\\n                    adj[grid[i][j]].push_back(col);\\n                    indeg[col]++;\\n                }\\n            }\\n        }\\n    }\\n    bool isPrintable(vector<vector<int>>&grid) \\n    {\\n        m=grid.size(),n=grid[0].size();\\n        adj.resize(61);\\n        indeg.resize(61);\\n        for(int i=1;i<=60;i++)\\n            find(i,grid);\\n        queue<int>q;\\n        for(int i=1;i<=60;i++)\\n        {\\n            if(indeg[i]==0 && colors.find(i)!=colors.end())\\n                q.push(i);\\n        }\\n        int count=0;\\n        while(!q.empty())\\n        {\\n            int u=q.front();\\n            count++;\\n            q.pop();\\n            for(auto &v:adj[u])\\n            {\\n                indeg[v]--;\\n                if(indeg[v]==0)\\n                    q.push(v);\\n            }\\n        }\\n        return count==colors.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678639,
                "title": "very-interesting-problem-java-dfs",
                "content": "```\\nclass Solution {\\n    Set<Integer> allColors = new HashSet<>();\\n    List<int[]> list = new ArrayList<>();\\n    int maxR = -1, minR = 1000, maxC = -1, minC = 1000;\\n    int times = 0;\\n\\n    public boolean isPrintable(int[][] grid) {\\n        populateColors(grid);\\n        boolean removed = false;\\n        while (times <= 50) {\\n            int validColor = -1;\\n            if (allColors.size() == 0) {\\n                return true;\\n            }\\n            for (int color : allColors) {\\n                list.clear();\\n                maxR = -1;\\n                minR = 1000;\\n                maxC = -1;\\n                minC = 1000;\\n                boolean valid = true;\\n                boolean[][] vis = new boolean[grid.length][grid[0].length];\\n                for (boolean[] r : vis) Arrays.fill(r, false);\\n                for (int i = 0; i < grid.length; i++) {\\n                    for (int j = 0; j < grid[i].length; j++) {\\n                        if (grid[i][j] == color && !vis[i][j]) {\\n                            dfs(i, j, color, grid, vis);\\n                        }\\n                    }\\n                }\\n//                System.out.println(color + \" \" + list.size());\\n                // {maxR,minC},{maxR,maxC},{minR,maxC},{minR,minC}\\n                int numPoints = 0;\\n                //potentially valid color\\n                for (int i = minR; i <= maxR; i++) {\\n                    for (int j = minC; j <= maxC; j++) {\\n                        numPoints++;\\n                        if (!vis[i][j]) {\\n                            valid = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (valid && numPoints <= list.size()) {\\n                    validColor = color;\\n                    break;\\n                }\\n\\n            }\\n            if (validColor != -1) {\\n                //System.out.println(\"Removing Color = \" + validColor);\\n                for (int[] point : list) {\\n                    grid[point[0]][point[1]] = -1;\\n                }\\n                allColors.remove(validColor);\\n                removed =true;\\n            }\\n            if(!removed){\\n                break;\\n            }\\n            times++;\\n        }\\n        return false;\\n    }\\n\\n    void dfs(int row, int col, int color, int[][] grid, boolean[][] vis) {\\n        if (row < 0 || col < 0 || row >= grid.length || col >= grid[row].length) {\\n            return;\\n        }\\n        if (grid[row][col] == color || grid[row][col] < 0) {\\n            if (!vis[row][col]) {\\n                vis[row][col] = true;\\n                list.add(new int[]{row, col});\\n                if (grid[row][col] == color) {\\n                    maxR = Math.max(row, maxR);\\n                    maxC = Math.max(col, maxC);\\n                    minR = Math.min(row, minR);\\n                    minC = Math.min(col, minC);\\n                }\\n                int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n                for (int[] dir : dirs) {\\n                    dfs(row + dir[0], col + dir[1], color, grid, vis);\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    void populateColors(int[][] grid) {\\n        for (int[] arr : grid) {\\n            for (int color : arr) {\\n                allColors.add(color);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Set<Integer> allColors = new HashSet<>();\\n    List<int[]> list = new ArrayList<>();\\n    int maxR = -1, minR = 1000, maxC = -1, minC = 1000;\\n    int times = 0;\\n\\n    public boolean isPrintable(int[][] grid) {\\n        populateColors(grid);\\n        boolean removed = false;\\n        while (times <= 50) {\\n            int validColor = -1;\\n            if (allColors.size() == 0) {\\n                return true;\\n            }\\n            for (int color : allColors) {\\n                list.clear();\\n                maxR = -1;\\n                minR = 1000;\\n                maxC = -1;\\n                minC = 1000;\\n                boolean valid = true;\\n                boolean[][] vis = new boolean[grid.length][grid[0].length];\\n                for (boolean[] r : vis) Arrays.fill(r, false);\\n                for (int i = 0; i < grid.length; i++) {\\n                    for (int j = 0; j < grid[i].length; j++) {\\n                        if (grid[i][j] == color && !vis[i][j]) {\\n                            dfs(i, j, color, grid, vis);\\n                        }\\n                    }\\n                }\\n//                System.out.println(color + \" \" + list.size());\\n                // {maxR,minC},{maxR,maxC},{minR,maxC},{minR,minC}\\n                int numPoints = 0;\\n                //potentially valid color\\n                for (int i = minR; i <= maxR; i++) {\\n                    for (int j = minC; j <= maxC; j++) {\\n                        numPoints++;\\n                        if (!vis[i][j]) {\\n                            valid = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (valid && numPoints <= list.size()) {\\n                    validColor = color;\\n                    break;\\n                }\\n\\n            }\\n            if (validColor != -1) {\\n                //System.out.println(\"Removing Color = \" + validColor);\\n                for (int[] point : list) {\\n                    grid[point[0]][point[1]] = -1;\\n                }\\n                allColors.remove(validColor);\\n                removed =true;\\n            }\\n            if(!removed){\\n                break;\\n            }\\n            times++;\\n        }\\n        return false;\\n    }\\n\\n    void dfs(int row, int col, int color, int[][] grid, boolean[][] vis) {\\n        if (row < 0 || col < 0 || row >= grid.length || col >= grid[row].length) {\\n            return;\\n        }\\n        if (grid[row][col] == color || grid[row][col] < 0) {\\n            if (!vis[row][col]) {\\n                vis[row][col] = true;\\n                list.add(new int[]{row, col});\\n                if (grid[row][col] == color) {\\n                    maxR = Math.max(row, maxR);\\n                    maxC = Math.max(col, maxC);\\n                    minR = Math.min(row, minR);\\n                    minC = Math.min(col, minC);\\n                }\\n                int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n                for (int[] dir : dirs) {\\n                    dfs(row + dir[0], col + dir[1], color, grid, vis);\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    void populateColors(int[][] grid) {\\n        for (int[] arr : grid) {\\n            for (int color : arr) {\\n                allColors.add(color);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507261,
                "title": "python-o-cmn-time-o-c-space-very-fast",
                "content": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        #record min and max rows or columns for each color\\n        colorToRange = {}\\n        for row in range(m):\\n            for col in range(n):\\n                color = targetGrid[row][col]\\n                if color not in colorToRange:\\n                    colorToRange[color] = [row, row, col, col]\\n                else:\\n                    colorToRange[color][0] = min(colorToRange[color][0], row)\\n                    colorToRange[color][1] = max(colorToRange[color][1], row)\\n                    colorToRange[color][2] = min(colorToRange[color][2], col)\\n                    colorToRange[color][3] = max(colorToRange[color][3], col)\\n        \\n        #DFS for topological sort\\n        def topologicalSort(color: int):\\n            nonlocal colorStatus\\n            \\n            if colorStatus[color] == \"visited\":\\n                return False\\n            elif colorStatus[color] == \"resolved\":\\n                return True\\n            \\n            colorStatus[color] = \"visited\"\\n                \\n            row_min, row_max, col_min, col_max = colorToRange[color]\\n            for row in range(row_min, row_max + 1):\\n                for col in range(col_min, col_max + 1):\\n                    nextColor = targetGrid[row][col]\\n                    if  nextColor != color and not topologicalSort(nextColor):\\n                        return False\\n            \\n            colorStatus[color] = \\'resolved\\'\\n            return True\\n            \\n        colorStatus = dict.fromkeys(colorToRange)\\n        for color in colorToRange:\\n            if not topologicalSort(color):\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        #record min and max rows or columns for each color\\n        colorToRange = {}\\n        for row in range(m):\\n            for col in range(n):\\n                color = targetGrid[row][col]\\n                if color not in colorToRange:\\n                    colorToRange[color] = [row, row, col, col]\\n                else:\\n                    colorToRange[color][0] = min(colorToRange[color][0], row)\\n                    colorToRange[color][1] = max(colorToRange[color][1], row)\\n                    colorToRange[color][2] = min(colorToRange[color][2], col)\\n                    colorToRange[color][3] = max(colorToRange[color][3], col)\\n        \\n        #DFS for topological sort\\n        def topologicalSort(color: int):\\n            nonlocal colorStatus\\n            \\n            if colorStatus[color] == \"visited\":\\n                return False\\n            elif colorStatus[color] == \"resolved\":\\n                return True\\n            \\n            colorStatus[color] = \"visited\"\\n                \\n            row_min, row_max, col_min, col_max = colorToRange[color]\\n            for row in range(row_min, row_max + 1):\\n                for col in range(col_min, col_max + 1):\\n                    nextColor = targetGrid[row][col]\\n                    if  nextColor != color and not topologicalSort(nextColor):\\n                        return False\\n            \\n            colorStatus[color] = \\'resolved\\'\\n            return True\\n            \\n        colorStatus = dict.fromkeys(colorToRange)\\n        for color in colorToRange:\\n            if not topologicalSort(color):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434080,
                "title": "scala",
                "content": "```\\nimport math._\\n\\nobject Solution {\\n  def isPrintable(target: Array[Array[Int]]): Boolean = {\\n    val m = target.length\\n    val n = target.headOption.map(_.length).getOrElse(0)\\n\\n    val colors = (0 until m)\\n      .flatMap { i =>\\n        (0 until n).collect {\\n          case j if target(i)(j) > 0 => target(i)(j) -> ((i, i), (j, j))\\n        }\\n      }\\n      .groupMapReduce(_._1)(_._2) {\\n        case (((minRow1, maxRow1), (minCol1, maxCol1)), ((minRow2, maxRow2), (minCol2, maxCol2))) =>\\n          ((min(minRow1, minRow2), max(maxRow1, maxRow2)), (min(minCol1, minCol2), max(maxCol1, maxCol2)))\\n      }\\n    \\n    if (colors.nonEmpty) {\\n      def isColorPrintable(color: Int) = colors(color) match {\\n        case ((minRow, maxRow), (minCol, maxCol)) => (minRow to maxRow).forall { i =>\\n          (minCol to maxCol).forall(j => target(i)(j) == 0 || target(i)(j) == color)\\n        }\\n      }\\n\\n      val printableColors = colors.keySet.filter(isColorPrintable)\\n\\n      if (printableColors.nonEmpty) {\\n        for (i <- 0 until m; j <- 0 until n if printableColors.contains(target(i)(j))) {\\n          target(i)(j) = 0\\n        }\\n        isPrintable(target)\\n      } else {\\n        false\\n      }\\n    } else {\\n      true\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport math._\\n\\nobject Solution {\\n  def isPrintable(target: Array[Array[Int]]): Boolean = {\\n    val m = target.length\\n    val n = target.headOption.map(_.length).getOrElse(0)\\n\\n    val colors = (0 until m)\\n      .flatMap { i =>\\n        (0 until n).collect {\\n          case j if target(i)(j) > 0 => target(i)(j) -> ((i, i), (j, j))\\n        }\\n      }\\n      .groupMapReduce(_._1)(_._2) {\\n        case (((minRow1, maxRow1), (minCol1, maxCol1)), ((minRow2, maxRow2), (minCol2, maxCol2))) =>\\n          ((min(minRow1, minRow2), max(maxRow1, maxRow2)), (min(minCol1, minCol2), max(maxCol1, maxCol2)))\\n      }\\n    \\n    if (colors.nonEmpty) {\\n      def isColorPrintable(color: Int) = colors(color) match {\\n        case ((minRow, maxRow), (minCol, maxCol)) => (minRow to maxRow).forall { i =>\\n          (minCol to maxCol).forall(j => target(i)(j) == 0 || target(i)(j) == color)\\n        }\\n      }\\n\\n      val printableColors = colors.keySet.filter(isColorPrintable)\\n\\n      if (printableColors.nonEmpty) {\\n        for (i <- 0 until m; j <- 0 until n if printableColors.contains(target(i)(j))) {\\n          target(i)(j) = 0\\n        }\\n        isPrintable(target)\\n      } else {\\n        false\\n      }\\n    } else {\\n      true\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1421039,
                "title": "c-topological-sorting",
                "content": "```\\nclass Solution {\\n#define pb push_back\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int n=targetGrid.size(),m=targetGrid[0].size();\\n        vector<vector<int>>g(61);\\n        vector<int>xmax(61,-1),xmin(61,n),ymax(61,-1),ymin(61,m);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                xmax[targetGrid[i][j]]=max(xmax[targetGrid[i][j]],i);\\n                xmin[targetGrid[i][j]]=min(xmin[targetGrid[i][j]],i);\\n                ymax[targetGrid[i][j]]=max(ymax[targetGrid[i][j]],j);\\n                ymin[targetGrid[i][j]]=min(ymin[targetGrid[i][j]],j);\\n            }\\n        }\\n        vector<int>indeg(61);\\n        for(int col=1;col<=60;col++){\\n            for(int i=xmin[col];i<=xmax[col];i++){\\n                for(int j=ymin[col];j<=ymax[col];j++){\\n                    if(targetGrid[i][j]!=col){\\n                        g[col].pb(targetGrid[i][j]);\\n                        indeg[targetGrid[i][j]]++;\\n                    }\\n                }\\n            }\\n        }\\n        int visited=0;\\n        queue<int>q;\\n        for(int col=1;col<=60;col++){\\n            if(!indeg[col]){\\n                q.push(col);\\n            }\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            visited++;\\n            for(auto &child:g[node]){\\n                if(!(--indeg[child])){\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        return visited==60;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n#define pb push_back\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int n=targetGrid.size(),m=targetGrid[0].size();\\n        vector<vector<int>>g(61);\\n        vector<int>xmax(61,-1),xmin(61,n),ymax(61,-1),ymin(61,m);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                xmax[targetGrid[i][j]]=max(xmax[targetGrid[i][j]],i);\\n                xmin[targetGrid[i][j]]=min(xmin[targetGrid[i][j]],i);\\n                ymax[targetGrid[i][j]]=max(ymax[targetGrid[i][j]],j);\\n                ymin[targetGrid[i][j]]=min(ymin[targetGrid[i][j]],j);\\n            }\\n        }\\n        vector<int>indeg(61);\\n        for(int col=1;col<=60;col++){\\n            for(int i=xmin[col];i<=xmax[col];i++){\\n                for(int j=ymin[col];j<=ymax[col];j++){\\n                    if(targetGrid[i][j]!=col){\\n                        g[col].pb(targetGrid[i][j]);\\n                        indeg[targetGrid[i][j]]++;\\n                    }\\n                }\\n            }\\n        }\\n        int visited=0;\\n        queue<int>q;\\n        for(int col=1;col<=60;col++){\\n            if(!indeg[col]){\\n                q.push(col);\\n            }\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            visited++;\\n            for(auto &child:g[node]){\\n                if(!(--indeg[child])){\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        return visited==60;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407449,
                "title": "topological-sorting-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> g[65];\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int n  = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        int in[65];\\n        memset(in,0,sizeof in);\\n        for(int i=1;i<=60;i++)g[i].clear();\\n        for(int color=1;color<=60;color++)\\n        {\\n            int ur=1000,uc=1000;\\n            int lr=-1,lc=-1;\\n            int flag = 0;\\n            for(int i=1;i<=n;i++)\\n            {\\n                for(int j=1;j<=m;j++)\\n                {\\n                    if(targetGrid[i-1][j-1] == color)\\n                    {\\n                        flag = 1;\\n                        ur = min(ur,i);\\n                        uc = min(uc,j);\\n                        lr = max(lr,i);\\n                        lc = max(lc,j);\\n                    }\\n                }\\n            }\\n\\n            if(!flag)continue;\\n            for(int i=ur;i<=lr;i++)\\n            {\\n                for(int j=uc;j<=lc;j++)\\n                {\\n                    if(targetGrid[i-1][j-1] != color)\\n                    {\\n                        in[targetGrid[i-1][j-1]]++;\\n                        g[color].push_back(targetGrid[i-1][j-1]);\\n                    }\\n                }\\n            }\\n\\n        }\\n\\n        queue<int> q;\\n        for(int i=1;i<=60;i++)\\n        {\\n            if(in[i] == 0)q.push(i);\\n        }\\n\\n        while(!q.empty())\\n        {\\n            int f = q.front();q.pop();\\n            for(auto v:g[f])\\n            {\\n                in[v]--;\\n                if(in[v] == 0)q.push(v);\\n            }\\n        }\\n\\n        for(int i=1;i<=60;i++)\\n        {\\n            if(in[i]!=0)return 0;\\n        }\\n        return 1;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> g[65];\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int n  = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        int in[65];\\n        memset(in,0,sizeof in);\\n        for(int i=1;i<=60;i++)g[i].clear();\\n        for(int color=1;color<=60;color++)\\n        {\\n            int ur=1000,uc=1000;\\n            int lr=-1,lc=-1;\\n            int flag = 0;\\n            for(int i=1;i<=n;i++)\\n            {\\n                for(int j=1;j<=m;j++)\\n                {\\n                    if(targetGrid[i-1][j-1] == color)\\n                    {\\n                        flag = 1;\\n                        ur = min(ur,i);\\n                        uc = min(uc,j);\\n                        lr = max(lr,i);\\n                        lc = max(lc,j);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1347194,
                "title": "use-overlapping-rectangles-and-topological-sort-to-recreate-the-grid-explanation-in-comments",
                "content": "```\\nfrom graphlib import TopologicalSorter, CycleError\\n\\nColor = int\\nCorner = Tuple[int, int]\\nRect = Tuple[Corner, Corner]  # [upper-left, lower-right (non-inclusive)]\\nLayer = Tuple[Color, Rect]\\n\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        # Runtime is the summation of several steps but is dominated by the second step\\n        # O(M*N + C*C*M*N + (O(C*C) + O(M*N)) + M*N) -> O(C*C*M*N)\\n        def compare(a:Layer, b:Layer) -> int:\\n            \"\"\"\\n            Determine if two rectangles overlap.\\n\\n            Return:\\n                -1 if b is over a\\n                0 if there is no overlap or an order cannot be determined (the overlap contains no elements of a or b)\\n                1 if a is over b\\n            \"\"\"\\n            val_a, (a_ul, a_lr) = a\\n            val_b, (b_ul, b_lr) = b\\n\\n            # Get overlap rectangle\\n            ul, lr = (\\n                (max(a_ul[0], b_ul[0]), max(a_ul[1], b_ul[1])),\\n                (min(a_lr[0], b_lr[0]), min(a_lr[1], b_lr[1])),\\n            )\\n\\n            # If either dimension is non-positive, there is no overlap\\n            if lr[0] - ul[0] <= 0 or lr[1] - ul[1] <= 0:\\n                return 0\\n\\n            # Find the first element matching a or b in the overlap rectangle.\\n            # We\\'ll consider that the \"over\" value.\\n            for r in range(ul[0], lr[0]):\\n                for c in range(ul[1], lr[1]):\\n                    if targetGrid[r][c] == val_b:\\n                        return -1\\n                    elif targetGrid[r][c] == val_a:\\n                        return 1\\n            # We could find no values from a or b in the overlap.\\n            # The result is indeterminate.\\n            return 0\\n\\n        # Generate the enclosing rectangles for each visible color (ie. layers).\\n        # O(M*N)\\n        rects:Dict[Color, Rect] = defaultdict(lambda: ([100, 100], [0, 0]))\\n        for r, row in enumerate(targetGrid):\\n            for c, val in enumerate(row):\\n                ul, lr = rects[val]\\n                rects[val] = (\\n                    (min(ul[0], r), min(ul[1], c)),\\n                    (max(lr[0], r + 1), max(lr[1], c + 1))\\n                )\\n\\n        # Compare every pair of layers.\\n        # If overlap is detected, record that the \"upper\" rectangle depends on the \"lower\" one.\\n        # O(C*C*M*N)  # Number of colors\\n        layers:List[Layer] = list(rects.items())\\n        graph:Dict[Layer, Set[Layer]] = {layer: set() for layer in layers}\\n        for i, a in enumerate(layers):\\n            for b in layers[i + 1 :]:\\n                if (cmp := compare(a, b)) < 0:\\n                    graph[b].add(a)\\n                elif cmp > 0:\\n                    graph[a].add(b)\\n\\n        # Use topological sort on the graph to reproduce the printing order (in the absence\\n        # of cycles) and print our own grid.\\n        # O(C*C) + O(M*N)  // O(C*C) is derived from topological sort O(V+E)\\n        try:\\n            grid = [[0] * len(targetGrid[0]) for _ in targetGrid]\\n            for color, (ul, lr) in TopologicalSorter(graph).static_order():\\n                for r in range(ul[0], lr[0]):\\n                    for c in range(ul[1], lr[1]):\\n                        grid[r][c] = color\\n        except CycleError:\\n            return False\\n\\n        # Compare the grids\\n        # O(M*N)\\n        return grid == targetGrid\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nfrom graphlib import TopologicalSorter, CycleError\\n\\nColor = int\\nCorner = Tuple[int, int]\\nRect = Tuple[Corner, Corner]  # [upper-left, lower-right (non-inclusive)]\\nLayer = Tuple[Color, Rect]\\n\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        # Runtime is the summation of several steps but is dominated by the second step\\n        # O(M*N + C*C*M*N + (O(C*C) + O(M*N)) + M*N) -> O(C*C*M*N)\\n        def compare(a:Layer, b:Layer) -> int:\\n            \"\"\"\\n            Determine if two rectangles overlap.\\n\\n            Return:\\n                -1 if b is over a\\n                0 if there is no overlap or an order cannot be determined (the overlap contains no elements of a or b)\\n                1 if a is over b\\n            \"\"\"\\n            val_a, (a_ul, a_lr) = a\\n            val_b, (b_ul, b_lr) = b\\n\\n            # Get overlap rectangle\\n            ul, lr = (\\n                (max(a_ul[0], b_ul[0]), max(a_ul[1], b_ul[1])),\\n                (min(a_lr[0], b_lr[0]), min(a_lr[1], b_lr[1])),\\n            )\\n\\n            # If either dimension is non-positive, there is no overlap\\n            if lr[0] - ul[0] <= 0 or lr[1] - ul[1] <= 0:\\n                return 0\\n\\n            # Find the first element matching a or b in the overlap rectangle.\\n            # We\\'ll consider that the \"over\" value.\\n            for r in range(ul[0], lr[0]):\\n                for c in range(ul[1], lr[1]):\\n                    if targetGrid[r][c] == val_b:\\n                        return -1\\n                    elif targetGrid[r][c] == val_a:\\n                        return 1\\n            # We could find no values from a or b in the overlap.\\n            # The result is indeterminate.\\n            return 0\\n\\n        # Generate the enclosing rectangles for each visible color (ie. layers).\\n        # O(M*N)\\n        rects:Dict[Color, Rect] = defaultdict(lambda: ([100, 100], [0, 0]))\\n        for r, row in enumerate(targetGrid):\\n            for c, val in enumerate(row):\\n                ul, lr = rects[val]\\n                rects[val] = (\\n                    (min(ul[0], r), min(ul[1], c)),\\n                    (max(lr[0], r + 1), max(lr[1], c + 1))\\n                )\\n\\n        # Compare every pair of layers.\\n        # If overlap is detected, record that the \"upper\" rectangle depends on the \"lower\" one.\\n        # O(C*C*M*N)  # Number of colors\\n        layers:List[Layer] = list(rects.items())\\n        graph:Dict[Layer, Set[Layer]] = {layer: set() for layer in layers}\\n        for i, a in enumerate(layers):\\n            for b in layers[i + 1 :]:\\n                if (cmp := compare(a, b)) < 0:\\n                    graph[b].add(a)\\n                elif cmp > 0:\\n                    graph[a].add(b)\\n\\n        # Use topological sort on the graph to reproduce the printing order (in the absence\\n        # of cycles) and print our own grid.\\n        # O(C*C) + O(M*N)  // O(C*C) is derived from topological sort O(V+E)\\n        try:\\n            grid = [[0] * len(targetGrid[0]) for _ in targetGrid]\\n            for color, (ul, lr) in TopologicalSorter(graph).static_order():\\n                for r in range(ul[0], lr[0]):\\n                    for c in range(ul[1], lr[1]):\\n                        grid[r][c] = color\\n        except CycleError:\\n            return False\\n\\n        # Compare the grids\\n        # O(M*N)\\n        return grid == targetGrid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312786,
                "title": "c-easy-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    struct Color{\\n        int minh;\\n        int maxh;\\n        int minw;\\n        int maxw;\\n    };\\n    int n,m;\\n    unordered_map<int,Color>color;\\n    vector<vector<int>>grid;\\n    //function to check if it is valid or not\\n    bool isrect(int c){\\n        int a = color[c].minh;\\n        int b = color[c].minw;\\n        int cn = color[c].maxh;\\n        int cm = color[c].maxw;\\n        for(int i = a;i<=cn;i++){\\n            for(int j = b;j<=cm;j++){\\n                if(grid[i][j]==c||grid[i][j]==0) continue;\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    //function to set zero\\n    void setzero(int c){\\n        int a = color[c].minh;\\n        int b = color[c].minw;\\n        int cn = color[c].maxh;\\n        int cm = color[c].maxw;\\n        for(int i = a;i<=cn;i++){\\n            for(int j = b;j<=cm;j++){\\n                grid[i][j] = 0;\\n            }\\n        }\\n    }\\n    //function to set all the colors\\n    void getcolor(){\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(color.find(grid[i][j])==color.end()){\\n                    Color t;\\n                    t.minh = i;\\n                    t.maxh = i;\\n                    t.minw = j;\\n                    t.maxw = j;\\n                    color[grid[i][j]] = t;\\n                }\\n                else{\\n                    color[grid[i][j]].minw = min(color[grid[i][j]].minw,j);\\n                    color[grid[i][j]].maxw = max(color[grid[i][j]].maxw,j);\\n                    color[grid[i][j]].minh = min(color[grid[i][j]].minh,i);\\n                    color[grid[i][j]].maxh = max(color[grid[i][j]].maxh,i);\\n                }\\n            }\\n        }\\n    }   \\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        grid = targetGrid;\\n        n = grid.size();\\n        m = grid[0].size();\\n        getcolor();\\n        queue<int>q;\\n        for(auto &i : color){\\n            if(isrect(i.first)){\\n                q.push(i.first);\\n            }\\n        }\\n        vector<bool>visited(61,false);\\n        while(q.size()){\\n            int curr = q.front();\\n            q.pop();\\n            if(visited[curr]) continue;\\n            setzero(curr);\\n            \\n            visited[curr] = true;\\n            for(auto &i : color){\\n                if(isrect(i.first)) q.push(i.first);\\n            }\\n        }\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j]!=0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    struct Color{\\n        int minh;\\n        int maxh;\\n        int minw;\\n        int maxw;\\n    };\\n    int n,m;\\n    unordered_map<int,Color>color;\\n    vector<vector<int>>grid;\\n    //function to check if it is valid or not\\n    bool isrect(int c){\\n        int a = color[c].minh;\\n        int b = color[c].minw;\\n        int cn = color[c].maxh;\\n        int cm = color[c].maxw;\\n        for(int i = a;i<=cn;i++){\\n            for(int j = b;j<=cm;j++){\\n                if(grid[i][j]==c||grid[i][j]==0) continue;\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    //function to set zero\\n    void setzero(int c){\\n        int a = color[c].minh;\\n        int b = color[c].minw;\\n        int cn = color[c].maxh;\\n        int cm = color[c].maxw;\\n        for(int i = a;i<=cn;i++){\\n            for(int j = b;j<=cm;j++){\\n                grid[i][j] = 0;\\n            }\\n        }\\n    }\\n    //function to set all the colors\\n    void getcolor(){\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(color.find(grid[i][j])==color.end()){\\n                    Color t;\\n                    t.minh = i;\\n                    t.maxh = i;\\n                    t.minw = j;\\n                    t.maxw = j;\\n                    color[grid[i][j]] = t;\\n                }\\n                else{\\n                    color[grid[i][j]].minw = min(color[grid[i][j]].minw,j);\\n                    color[grid[i][j]].maxw = max(color[grid[i][j]].maxw,j);\\n                    color[grid[i][j]].minh = min(color[grid[i][j]].minh,i);\\n                    color[grid[i][j]].maxh = max(color[grid[i][j]].maxh,i);\\n                }\\n            }\\n        }\\n    }   \\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        grid = targetGrid;\\n        n = grid.size();\\n        m = grid[0].size();\\n        getcolor();\\n        queue<int>q;\\n        for(auto &i : color){\\n            if(isrect(i.first)){\\n                q.push(i.first);\\n            }\\n        }\\n        vector<bool>visited(61,false);\\n        while(q.size()){\\n            int curr = q.front();\\n            q.pop();\\n            if(visited[curr]) continue;\\n            setzero(curr);\\n            \\n            visited[curr] = true;\\n            for(auto &i : color){\\n                if(isrect(i.first)) q.push(i.first);\\n            }\\n        }\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j]!=0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295212,
                "title": "java-rectange-flip-solution",
                "content": "```\\n// Rectange Flip Solution\\n// 1. Find the up, bottom, most-left, most-right idx for each color, and store in HashMap\\n// 2. Flip a flippable color. If flippable, remove that color. If no color can be flipped, return false.\\n// Time complexity: O(M * N * C * C)\\n// Space complexity: O(C)\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        if (targetGrid == null || targetGrid.length == 0 || targetGrid[0].length == 0) return false;\\n        final int M = targetGrid.length, N = targetGrid[0].length;\\n        // HashMap to store the <color, Grid with {up, bottom, most-left, most-right idx}> \\n        Map<Integer, Grid> map = new HashMap<>();\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                int color = targetGrid[i][j];\\n                Grid grid = map.get(color);\\n                if (grid == null) {\\n                    grid = new Grid(M, -1, N, -1);\\n                    map.put(color, grid);\\n                }\\n                grid.up = Math.min(grid.up, i);\\n                grid.bottom = Math.max(grid.bottom, i);\\n                grid.left = Math.min(grid.left, j);\\n                grid.right = Math.max(grid.right, j);\\n            }\\n        }\\n        return isPrintable(targetGrid, map);\\n    }\\n    \\n    private boolean isPrintable(int[][] targetGrid, Map<Integer, Grid> map) {\\n        Set<Integer> colorSet = new HashSet<>(map.keySet());\\n        while (!colorSet.isEmpty()) {\\n            Set<Integer> nextSet = new HashSet<>(colorSet);\\n            for (int color : colorSet) {\\n                // If flippable, remove that color. \\n                if (flipRect(targetGrid, map.get(color), color)) {\\n                    nextSet.remove(color);\\n                }\\n            }\\n            // If no color can be flipped, return false.\\n            if (colorSet.size() == nextSet.size()) {\\n                return false;\\n            }\\n            colorSet = nextSet;\\n        }\\n        return true;\\n    }\\n    \\n    // Check whether a color can be flipped at this time.\\n    // If the rectangle contains other unflipped color, then the rectangle is not flippable.\\n    private boolean flipRect(int[][] targetGrid, Grid grid, int color) {\\n        for (int i = grid.up; i <= grid.bottom; i++) {\\n            for (int j = grid.left; j <= grid.right; j++) {\\n                if (targetGrid[i][j] > 0 && targetGrid[i][j] != color) {\\n                    return false;  // rectangle contains other unflipped color, return false. \\n                }\\n            }\\n        }\\n        // Flip the flippable rectangle.\\n        for (int i = grid.up; i <= grid.bottom; i++) {\\n            for (int j = grid.left; j <= grid.right; j++) {\\n                if (targetGrid[i][j] > 0) {\\n                    targetGrid[i][j] = -color;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    class Grid {\\n        int up, bottom, left, right;\\n        Grid(int up, int bottom, int left, int right) {\\n            this.up = up;\\n            this.bottom = bottom;\\n            this.left = left;\\n            this.right = right;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Rectange Flip Solution\\n// 1. Find the up, bottom, most-left, most-right idx for each color, and store in HashMap\\n// 2. Flip a flippable color. If flippable, remove that color. If no color can be flipped, return false.\\n// Time complexity: O(M * N * C * C)\\n// Space complexity: O(C)\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        if (targetGrid == null || targetGrid.length == 0 || targetGrid[0].length == 0) return false;\\n        final int M = targetGrid.length, N = targetGrid[0].length;\\n        // HashMap to store the <color, Grid with {up, bottom, most-left, most-right idx}> \\n        Map<Integer, Grid> map = new HashMap<>();\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                int color = targetGrid[i][j];\\n                Grid grid = map.get(color);\\n                if (grid == null) {\\n                    grid = new Grid(M, -1, N, -1);\\n                    map.put(color, grid);\\n                }\\n                grid.up = Math.min(grid.up, i);\\n                grid.bottom = Math.max(grid.bottom, i);\\n                grid.left = Math.min(grid.left, j);\\n                grid.right = Math.max(grid.right, j);\\n            }\\n        }\\n        return isPrintable(targetGrid, map);\\n    }\\n    \\n    private boolean isPrintable(int[][] targetGrid, Map<Integer, Grid> map) {\\n        Set<Integer> colorSet = new HashSet<>(map.keySet());\\n        while (!colorSet.isEmpty()) {\\n            Set<Integer> nextSet = new HashSet<>(colorSet);\\n            for (int color : colorSet) {\\n                // If flippable, remove that color. \\n                if (flipRect(targetGrid, map.get(color), color)) {\\n                    nextSet.remove(color);\\n                }\\n            }\\n            // If no color can be flipped, return false.\\n            if (colorSet.size() == nextSet.size()) {\\n                return false;\\n            }\\n            colorSet = nextSet;\\n        }\\n        return true;\\n    }\\n    \\n    // Check whether a color can be flipped at this time.\\n    // If the rectangle contains other unflipped color, then the rectangle is not flippable.\\n    private boolean flipRect(int[][] targetGrid, Grid grid, int color) {\\n        for (int i = grid.up; i <= grid.bottom; i++) {\\n            for (int j = grid.left; j <= grid.right; j++) {\\n                if (targetGrid[i][j] > 0 && targetGrid[i][j] != color) {\\n                    return false;  // rectangle contains other unflipped color, return false. \\n                }\\n            }\\n        }\\n        // Flip the flippable rectangle.\\n        for (int i = grid.up; i <= grid.bottom; i++) {\\n            for (int j = grid.left; j <= grid.right; j++) {\\n                if (targetGrid[i][j] > 0) {\\n                    targetGrid[i][j] = -color;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    class Grid {\\n        int up, bottom, left, right;\\n        Grid(int up, int bottom, int left, int right) {\\n            this.up = up;\\n            this.bottom = bottom;\\n            this.left = left;\\n            this.right = right;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244402,
                "title": "golang-brute-force-24ms-6-6mb-clean-code",
                "content": "use 0 for any color\\n```\\nfunc isPrintable(targetGrid [][]int) bool {\\n    list := make([]*clrRange, 61)\\n    \\n    for i := 0; i < len(targetGrid); i++ {\\n        for j := 0; j < len(targetGrid[i]); j++ {\\n            clr := targetGrid[i][j]\\n            \\n            if list[clr] == nil {\\n                list[clr] = &clrRange{clr:clr, x1:61, y1:61}\\n            }\\n            list[clr].setRange(i, j)\\n        }\\n    }\\n    \\n    for {\\n        state := 1\\n        for i := 0; i < len(list); i++ {\\n            if list[i] == nil || list[i].handle {\\n                continue\\n            }\\n            \\n            if state == 1 {\\n                state = 2\\n            }\\n            if list[i].can(targetGrid) {\\n                state = 3\\n                list[i].setGrid(targetGrid)\\n            }\\n        }\\n        \\n        if state == 2 {\\n            return false\\n        } else if state == 1 {\\n            return true\\n        }\\n    }\\n    return true\\n}\\n\\ntype clrRange struct {\\n    clr int\\n    x1, x2, y1, y2 int\\n    handle bool\\n}\\n\\nfunc (c *clrRange) setRange(x, y int) {\\n    if c.x1 > x {\\n        c.x1 = x\\n    }\\n    if c.x2 < x {\\n        c.x2 = x\\n    }\\n    if c.y1 > y {\\n        c.y1 = y\\n    }\\n    if c.y2 < y {\\n        c.y2 = y\\n    }\\n}\\n\\nfunc (c *clrRange) can (grid [][]int) bool {\\n    for x := c.x1; x <= c.x2; x++ {\\n        for y := c.y1; y <= c.y2; y++ {\\n            if grid[x][y] == 0 || grid[x][y] == c.clr {\\n                continue\\n            }\\n            return false\\n        }\\n    }\\n    return true\\n}\\n\\nfunc (c *clrRange) setGrid(grid [][]int) {\\n    for x := c.x1; x <= c.x2; x++ {\\n        for y := c.y1; y <= c.y2; y++ {\\n            grid[x][y] = 0\\n        }\\n    }\\n    c.handle = true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isPrintable(targetGrid [][]int) bool {\\n    list := make([]*clrRange, 61)\\n    \\n    for i := 0; i < len(targetGrid); i++ {\\n        for j := 0; j < len(targetGrid[i]); j++ {\\n            clr := targetGrid[i][j]\\n            \\n            if list[clr] == nil {\\n                list[clr] = &clrRange{clr:clr, x1:61, y1:61}\\n            }\\n            list[clr].setRange(i, j)\\n        }\\n    }\\n    \\n    for {\\n        state := 1\\n        for i := 0; i < len(list); i++ {\\n            if list[i] == nil || list[i].handle {\\n                continue\\n            }\\n            \\n            if state == 1 {\\n                state = 2\\n            }\\n            if list[i].can(targetGrid) {\\n                state = 3\\n                list[i].setGrid(targetGrid)\\n            }\\n        }\\n        \\n        if state == 2 {\\n            return false\\n        } else if state == 1 {\\n            return true\\n        }\\n    }\\n    return true\\n}\\n\\ntype clrRange struct {\\n    clr int\\n    x1, x2, y1, y2 int\\n    handle bool\\n}\\n\\nfunc (c *clrRange) setRange(x, y int) {\\n    if c.x1 > x {\\n        c.x1 = x\\n    }\\n    if c.x2 < x {\\n        c.x2 = x\\n    }\\n    if c.y1 > y {\\n        c.y1 = y\\n    }\\n    if c.y2 < y {\\n        c.y2 = y\\n    }\\n}\\n\\nfunc (c *clrRange) can (grid [][]int) bool {\\n    for x := c.x1; x <= c.x2; x++ {\\n        for y := c.y1; y <= c.y2; y++ {\\n            if grid[x][y] == 0 || grid[x][y] == c.clr {\\n                continue\\n            }\\n            return false\\n        }\\n    }\\n    return true\\n}\\n\\nfunc (c *clrRange) setGrid(grid [][]int) {\\n    for x := c.x1; x <= c.x2; x++ {\\n        for y := c.y1; y <= c.y2; y++ {\\n            grid[x][y] = 0\\n        }\\n    }\\n    c.handle = true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1169839,
                "title": "python3-bfs-to-check-dependencies",
                "content": "First identify the boundaries of all the rectangles. For each area bounded for rectangle i, if there is an overlap of another rectangle j, it means j must be printed after i. We use `nxt[i]` to record what rectangles have to be printed after rectangle i.\\n\\nThen we just use normal BFS to check if there is a cycle in the graph.\\n\\n```python\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        rect = defaultdict(lambda: [n, -1, m, -1])\\n        colors = set()\\n        for i in range(m):\\n            for j in range(n):\\n                c = targetGrid[i][j]\\n                colors.add(c)\\n                l, r, t, b = rect[c]\\n                l = min(l, j)\\n                r = max(r, j)\\n                t = min(t, i)\\n                b = max(b, i)\\n                rect[c] = [l, r, t, b]\\n\\n        nxt = defaultdict(set)\\n        for c in rect:\\n            l, r, t, b = rect[c]\\n            for i in range(t, b + 1):\\n                for j in range(l, r + 1):\\n                    if targetGrid[i][j] != c:\\n                        nxt[c].add(targetGrid[i][j])\\n\\n        degree = defaultdict(int)\\n        for i in nxt:\\n            for j in nxt[i]:\\n                degree[j] += 1\\n        queue = deque([])\\n        for i in colors:\\n            queue.append(i)\\n        while queue:\\n            found, size = False, len(queue)\\n            for _ in range(size):\\n                i = queue.popleft()\\n                if degree[i] == 0:\\n                    for j in nxt[i]:\\n                        degree[j] -= 1\\n                    found = True\\n                else:\\n                    queue.append(i)\\n            if not found:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        rect = defaultdict(lambda: [n, -1, m, -1])\\n        colors = set()\\n        for i in range(m):\\n            for j in range(n):\\n                c = targetGrid[i][j]\\n                colors.add(c)\\n                l, r, t, b = rect[c]\\n                l = min(l, j)\\n                r = max(r, j)\\n                t = min(t, i)\\n                b = max(b, i)\\n                rect[c] = [l, r, t, b]\\n\\n        nxt = defaultdict(set)\\n        for c in rect:\\n            l, r, t, b = rect[c]\\n            for i in range(t, b + 1):\\n                for j in range(l, r + 1):\\n                    if targetGrid[i][j] != c:\\n                        nxt[c].add(targetGrid[i][j])\\n\\n        degree = defaultdict(int)\\n        for i in nxt:\\n            for j in nxt[i]:\\n                degree[j] += 1\\n        queue = deque([])\\n        for i in colors:\\n            queue.append(i)\\n        while queue:\\n            found, size = False, len(queue)\\n            for _ in range(size):\\n                i = queue.popleft()\\n                if degree[i] == 0:\\n                    for j in nxt[i]:\\n                        degree[j] -= 1\\n                    found = True\\n                else:\\n                    queue.append(i)\\n            if not found:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090604,
                "title": "c",
                "content": "```\\nclass Solution {\\n    unordered_map<int, int> left, right, top, buttom;\\n    \\n    // For any 2 colors, their boundaries might overlap. If the overlap area contain 2 colors. Then this is invalid. \\n    // Otherwise, the only color in the overlap area is the color printed later. Now we have a directed graph relative order of painting between 2 colors.\\n    bool valid(vector<vector<int>>& grid, int x, int y, unordered_map<int, vector<int>>& g) {\\n\\n        int t = max(top[x], top[y]);\\n        int b = min(buttom[x], buttom[y]);\\n        int l = max(left[x], left[y]);\\n        int r = min(right[x], right[y]);\\n\\n        bool findX = false, findY = false;\\n        for(int i=t; i<=b; ++i) {\\n            for(int j=l; j<=r; ++j) {\\n                if(grid[i][j] == x) findX = true;\\n                if(grid[i][j] == y) findY = true;\\n            }\\n        }\\n        \\n        if(findX && findY) return false;\\n        if(findX) g[x].push_back(y);\\n        if(findY) g[y].push_back(x);    \\n        return true;\\n    }\\npublic:\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        left.clear();\\n        right.clear();\\n        top.clear();\\n        buttom.clear();\\n        \\n        int m = grid.size(), n = grid[0].size();\\n        \\n        // Get the boundaries of each color. {left, right, top, buttom}. The boundaries means for that color, we need to print at least the area from [left, top] to [right, buttom].\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int val = grid[i][j];\\n                if(left.find(val) != left.end()) left[val] = min(left[val], j);\\n                else left[val] = j;\\n                if(right.find(val) != right.end()) right[val] = max(right[val], j);\\n                else right[val] = j;\\n                if(top.find(val) != top.end()) top[val] = min(top[val], i);\\n                else top[val] = i;\\n                if(buttom.find(val) != buttom.end()) buttom[val] = max(buttom[val], i);\\n                else buttom[val] = i;\\n            }\\n        }\\n        \\n        unordered_map<int, vector<int>> g;\\n        vector<int> colors;\\n        for(auto it1 = left.begin(); it1 != left.end(); ++it1) {\\n            colors.push_back(it1->first);\\n            for(auto it2 = left.begin(); it2 != left.end(); ++it2) {\\n                if(it1->first >= it2->first) continue;\\n                if(!valid(grid, it1->first, it2->first, g)) return false;\\n            }\\n        }\\n        \\n        // Check if the graph has cycle. If it does, then there is no valid order to paint colors.\\n        unordered_set<int> visited;\\n        for(auto c : colors) {\\n            visited.clear();\\n            if(hasCycle(c, g, visited)) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    bool hasCycle(int cur, unordered_map<int, vector<int>>& g, unordered_set<int>& visited) {\\n        if(visited.count(cur)) return true;\\n        \\n        if(g.find(cur) == g.end()) {\\n            return false;\\n        }\\n        \\n        visited.insert(cur);\\n        for(auto nxt : g[cur]) {\\n            if(hasCycle(nxt, g, visited)) return true;\\n        }\\n        visited.erase(cur);\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<int, int> left, right, top, buttom;\\n    \\n    // For any 2 colors, their boundaries might overlap. If the overlap area contain 2 colors. Then this is invalid. \\n    // Otherwise, the only color in the overlap area is the color printed later. Now we have a directed graph relative order of painting between 2 colors.\\n    bool valid(vector<vector<int>>& grid, int x, int y, unordered_map<int, vector<int>>& g) {\\n\\n        int t = max(top[x], top[y]);\\n        int b = min(buttom[x], buttom[y]);\\n        int l = max(left[x], left[y]);\\n        int r = min(right[x], right[y]);\\n\\n        bool findX = false, findY = false;\\n        for(int i=t; i<=b; ++i) {\\n            for(int j=l; j<=r; ++j) {\\n                if(grid[i][j] == x) findX = true;\\n                if(grid[i][j] == y) findY = true;\\n            }\\n        }\\n        \\n        if(findX && findY) return false;\\n        if(findX) g[x].push_back(y);\\n        if(findY) g[y].push_back(x);    \\n        return true;\\n    }\\npublic:\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        left.clear();\\n        right.clear();\\n        top.clear();\\n        buttom.clear();\\n        \\n        int m = grid.size(), n = grid[0].size();\\n        \\n        // Get the boundaries of each color. {left, right, top, buttom}. The boundaries means for that color, we need to print at least the area from [left, top] to [right, buttom].\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int val = grid[i][j];\\n                if(left.find(val) != left.end()) left[val] = min(left[val], j);\\n                else left[val] = j;\\n                if(right.find(val) != right.end()) right[val] = max(right[val], j);\\n                else right[val] = j;\\n                if(top.find(val) != top.end()) top[val] = min(top[val], i);\\n                else top[val] = i;\\n                if(buttom.find(val) != buttom.end()) buttom[val] = max(buttom[val], i);\\n                else buttom[val] = i;\\n            }\\n        }\\n        \\n        unordered_map<int, vector<int>> g;\\n        vector<int> colors;\\n        for(auto it1 = left.begin(); it1 != left.end(); ++it1) {\\n            colors.push_back(it1->first);\\n            for(auto it2 = left.begin(); it2 != left.end(); ++it2) {\\n                if(it1->first >= it2->first) continue;\\n                if(!valid(grid, it1->first, it2->first, g)) return false;\\n            }\\n        }\\n        \\n        // Check if the graph has cycle. If it does, then there is no valid order to paint colors.\\n        unordered_set<int> visited;\\n        for(auto c : colors) {\\n            visited.clear();\\n            if(hasCycle(c, g, visited)) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    bool hasCycle(int cur, unordered_map<int, vector<int>>& g, unordered_set<int>& visited) {\\n        if(visited.count(cur)) return true;\\n        \\n        if(g.find(cur) == g.end()) {\\n            return false;\\n        }\\n        \\n        visited.insert(cur);\\n        for(auto nxt : g[cur]) {\\n            if(hasCycle(nxt, g, visited)) return true;\\n        }\\n        visited.erase(cur);\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038318,
                "title": "why-this-matrix-is-returning-true",
                "content": "I submit my application but it didn\\'t work because of the below test case. why this should be true??? \"Trace number 60 to know what I mean\"\\n\\n[[60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60]\\n,[60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60]\\n,[60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,36,36,36,36,36,36,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60]\\n,[60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,29,29,29,36,36,36,36,36,36,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,60,60,60]\\n,[60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,29,29,29,36,36,36,36,36,36,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,60,60,60]\\n,[60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,29,29,29,36,36,36,36,36,36,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,60,60,60]\\n,[60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,29,29,29,36,36,36,36,36,36,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,60,60,60]\\n,[60,60,60,60,60,60,60,60,60,60,60,60,60,45,45,45,45,45,45,36,36,36,36,36,36,29,29,29,29,29,29,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,60,60,60,60,60,60,60,60,60,60,60,45,45,45,45,45,45,36,36,36,36,36,36,29,29,29,29,29,29,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,60,60,60,60,60,60,60,23,23,23,23,45,45,45,45,45,45,36,36,36,36,36,36,29,29,29,29,29,29,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,60,60,60,60,60,60,60,23,23,23,23,45,45,45,45,45,45,36,36,36,36,36,36,29,29,29,29,29,29,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,60,60,60,60,60,60,60,23,23,23,23,45,45,45,45,45,45,36,36,36,36,36,36,29,29,29,29,29,29,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,18,18,18,18,18,23,23,23,23,45,45,45,45,45,45,36,36,36,36,36,36,29,29,29,29,29,29,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,18,18,18,18,18,23,23,23,23,23,23,23,29,29,29,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,48,48,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,34,34,34,34,34,34,34,34,34,34,34,34,34,32,36,36,46,46,46,46,46,46,46,46,46,46,48,48,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,46,46,46,46,46,46,46,46,46,46,48,48,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,46,46,46,46,46,46,46,46,46,46,48,48,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,48,48,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,38,38,38,38,38,38,38,38,38,37,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,38,38,38,38,38,38,38,38,38,37,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,37,37,40,40,40,37,37,37,37,37,37,37,37,37,37,37,37,38,38,38,38,38,38,38,38,38,37,44,44,49,49,49,49,49,44,44,44,44,44,44,44]\\n,[60,60,18,18,37,37,40,40,40,37,37,37,37,37,37,37,37,37,37,37,37,38,38,38,38,38,38,38,38,38,37,44,44,49,49,49,49,49,44,44,44,44,44,44,44]\\n,[60,60,18,18,18,34,40,40,40,34,34,34,34,34,34,34,34,34,31,36,36,38,47,47,47,47,47,47,47,47,47,47,47,49,49,49,49,49,47,47,47,47,44,44,44]\\n,[60,60,18,18,18,34,40,40,40,34,34,34,34,34,34,34,34,34,31,36,36,38,47,47,47,47,47,47,47,47,47,47,47,49,49,49,49,49,47,47,47,47,44,44,44]\\n,[60,60,18,18,18,34,40,40,40,34,34,34,34,34,34,34,34,34,28,36,36,36,47,47,47,47,47,47,47,47,47,47,47,49,49,49,49,49,47,47,47,47,44,44,44]\\n,[60,60,18,18,18,34,40,40,40,34,34,34,34,34,34,34,34,34,28,36,36,36,36,36,36,30,30,26,26,41,41,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,18,34,40,40,40,34,34,34,34,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,44,44,44,44]\\n,[60,60,60,60,60,34,40,40,40,34,34,34,34,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,22,22,60,60]\\n,[60,60,60,60,60,34,40,40,40,34,34,34,34,34,34,34,34,34,22,22,30,30,30,30,30,30,30,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,22,60,60]\\n,[60,60,60,60,60,60,60,60,60,60,60,22,22,22,22,22,22,22,22,22,30,30,30,30,30,30,30,26,26,41,41,41,41,41,22,22,22,22,22,22,42,22,22,60,60]\\n,[60,60,60,60,60, 3, 3, 3 ,3, 3, 3,22,22,22,22,22,22,22,22,22,22,22,22,22,22,26,26,26,26,41,41,41,41,41,22,22,25,25,25,25,42,22,22,60,60]\\n,[60,60,60,60,60, 3, 3, 3, 3, 3, 3,22,22,22,22,22,22,22,22,22,22,22,22,22,22,26,26,26,26,26,26,26,26,22,22,22,25,25,25,25,42,22,22,60,60]\\n,[60,60,12,12,12,12,12, 3, 3, 3, 3,22,22,22,22,22,22,22,22,22,22,22,22,22,22,26,26,26,26,26,26,26,26,22,22,22,22,22,22,22,22,24,24,24,24]]",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1026798,
                "title": "c-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        initGraph(targetGrid);\\n        const int n = g.size();\\n        vector<int> indegree(n);\\n        for(auto st:g) for(auto i:st) indegree[i]++;\\n        queue<int> q;\\n        for(int i=0;i<n;i++) if(indegree[i] == 0 && !g[i].empty()) q.push(i);\\n        while(!q.empty()){\\n            auto i = q.front(); q.pop();\\n            cout<<i<<endl;\\n            for(auto j:g[i]){\\n                if(--indegree[j] == 0) q.push(j);\\n            }\\n        }\\n        return count(indegree.begin(), indegree.end(), 0) == n;\\n    }\\n    \\n    void initGraph(vector<vector<int>>& vv){\\n        const int n = vv.size(), m = vv[0].size(); \\n        g.resize(61);  \\n        unordered_map<int, Boundry> mp;\\n        for(int i=0;i<n;i++) for(int j=0;j<m;j++){\\n            mp[vv[i][j]].update(i, j);\\n        }\\n        for(const auto& [color, bond] : mp){\\n            auto [x1, x2, y1, y2] = bond;\\n            for(int i=x1;i<=x2;i++) for(int j=y1;j<=y2;j++){\\n                if(vv[i][j] != color) g[color].insert(vv[i][j]);\\n            }\\n        }\\n    }\\n    \\n    struct Boundry{\\n        void update(int x, int y){\\n            x1 = min(x, x1);\\n            x2 = max(x, x2);\\n            y1 = min(y, y1);\\n            y2 = max(y, y2);\\n        }\\n        \\n        bool include(int x, int y) const{\\n            return x>=x1 && x<=x2 && y>=y1 && y<=y2;\\n        }\\n        \\n        int x1 = 100;\\n        int x2 = -1;\\n        int y1 = 100;\\n        int y2 = -1;\\n    };\\n    \\n    vector<unordered_set<int>> g; \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        initGraph(targetGrid);\\n        const int n = g.size();\\n        vector<int> indegree(n);\\n        for(auto st:g) for(auto i:st) indegree[i]++;\\n        queue<int> q;\\n        for(int i=0;i<n;i++) if(indegree[i] == 0 && !g[i].empty()) q.push(i);\\n        while(!q.empty()){\\n            auto i = q.front(); q.pop();\\n            cout<<i<<endl;\\n            for(auto j:g[i]){\\n                if(--indegree[j] == 0) q.push(j);\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 1018414,
                "title": "p23-5",
                "content": "Topo sort\\nTopo sort\\nTopo sort",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1012458,
                "title": "python-3-steps",
                "content": "**Key Insights:**\\n\\n1. Because each stamp is a rectangle, for each color, the stamp\\nmust span across [min(x<sub>i</sub>), max(x<sub>i</sub>)] and [min(y<sub>i</sub>), max(y<sub>i</sub>)] (inclusive).\\nWhere min(x<sub>i</sub>) is the left most cell of that color.\\n\\n\\n2. Because each color can only be used once, the colors that\\nform a perfect rectangle (without any other stamps overlapping\\nthem) must be the last stamps made. \\n\\n**Approach:** *step numbers match code comments*\\n\\n1. Find the left-most, top-most, right-most and bottom-most cell of each color.\\nThe points (left-most, top-most) and (right-most, bottom-most) will be the\\ntop-left and bottom-right corners of the stamp.\\n```rect[color] = [left-most, top-most, right-most, bottom-most]```\\n\\n2. Determine which stamps must come **before** other stamps.  If colors A\\nand B are in the rectangle for stamp of color C, then color C must be stamped\\nbefore color A and color B.  \\n\\n3. Work backwards to find an order of colors that agrees with the order from\\nstep 2.  Since we are working backwards, start with any stamps that do not\\nhave any other stamps on top of them.  Then use DFS to try all possible combinations\\nof next stamps.  <br>\\nThe exit condition is once all stamps have been placed, return True.  Otherwise\\ntry stamping all colors that 1. have not been stamped yet and 2. have all the prerequisite\\ncolors already stamped.  \\n\\n**Optimizations:**\\n\\nThe stamps that have been placed and the requirements for stamps that must be placed\\ncan be bitmasked such that 22 = \\'0b10110\\' represents stamps 1, 2, and 4.\\n\\n<br>\\n\\n```python\\nclass Solution:\\n    def isPrintable(self, grid: List[List[int]]) -> bool:\\n        \\n        # 1. Find the rectangle that each color is stamped over\\n        m, n = len(grid), len(grid[0])\\n        rect = collections.defaultdict(lambda: [m-1, n-1, 0, 0])\\n        for i in range(m):\\n            for j in range(n):\\n                color = grid[i][j]\\n                a, b, c, d = rect[color]\\n                rect[color] = [min(a, i), min(b, j), max(c, i), max(d, j)]\\n        \\n        # 2. Find which colors must come before each color\\n        before = collections.defaultdict(int)\\n        for color in rect:\\n            y1, x1, y2, x2 = rect[color]\\n            for i in range(y1, y2+1):\\n                for j in range(x1, x2+1):\\n                    if grid[i][j] != color:\\n                        before[color] |= (1 << grid[i][j])\\n        \\n        # 3. Can all stamps be placed without violating the order in before\\n        @functools.lru_cache(None)\\n        def helper(stamped):\\n            if stamped == target:\\n                return True\\n            for i in rect:\\n                if not (stamped & bitmask[i]) and (before[i] & stamped == before[i]):\\n                    if helper(stamped | bitmask[i]):\\n                        return True\\n            return False\\n        \\n        bitmask = [1 << i for i in range(max(rect)+1)]\\n        target = functools.reduce(lambda x, y: x|(bitmask[y]), rect, 0)\\n        start = functools.reduce(lambda x, y: x if before[y] else x|(bitmask[y]), rect, 0)\\n        return helper(start)\\n```",
                "solutionTags": [],
                "code": "```rect[color] = [left-most, top-most, right-most, bottom-most]```\n```python\\nclass Solution:\\n    def isPrintable(self, grid: List[List[int]]) -> bool:\\n        \\n        # 1. Find the rectangle that each color is stamped over\\n        m, n = len(grid), len(grid[0])\\n        rect = collections.defaultdict(lambda: [m-1, n-1, 0, 0])\\n        for i in range(m):\\n            for j in range(n):\\n                color = grid[i][j]\\n                a, b, c, d = rect[color]\\n                rect[color] = [min(a, i), min(b, j), max(c, i), max(d, j)]\\n        \\n        # 2. Find which colors must come before each color\\n        before = collections.defaultdict(int)\\n        for color in rect:\\n            y1, x1, y2, x2 = rect[color]\\n            for i in range(y1, y2+1):\\n                for j in range(x1, x2+1):\\n                    if grid[i][j] != color:\\n                        before[color] |= (1 << grid[i][j])\\n        \\n        # 3. Can all stamps be placed without violating the order in before\\n        @functools.lru_cache(None)\\n        def helper(stamped):\\n            if stamped == target:\\n                return True\\n            for i in rect:\\n                if not (stamped & bitmask[i]) and (before[i] & stamped == before[i]):\\n                    if helper(stamped | bitmask[i]):\\n                        return True\\n            return False\\n        \\n        bitmask = [1 << i for i in range(max(rect)+1)]\\n        target = functools.reduce(lambda x, y: x|(bitmask[y]), rect, 0)\\n        start = functools.reduce(lambda x, y: x if before[y] else x|(bitmask[y]), rect, 0)\\n        return helper(start)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907077,
                "title": "c-o-n-3-solution",
                "content": "1. Consider each color as node of a directed graph. \\n2. There is an edge from color **i** to color **j** if color **j** appears anywhere inside the maximum rectangle of color **i**.\\n3. Now if there is no cycle in this directed graph then there exisits a topological ordering of operations of the strange printer.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<unordered_set<int> > adj;\\n    vector<int> color;\\n    \\n    bool cycle_exists(int v){\\n        color[v]=1;\\n        for(int to: adj[v]){\\n            if(color[to]==1){\\n                return true;\\n            }\\n            else if(color[to]==0){\\n                if(cycle_exists(to)){\\n                    return true;\\n                }\\n            }\\n        }\\n        color[v]=2;\\n        return false;\\n    }\\n    \\n    bool isPrintable(vector<vector<int>>& g) {\\n        vector<int> left(61, 10000), right(61, -1), top(61, 10000), bottom(61, -1);\\n        int n=g.size(), m=g[0].size();\\n        adj=vector<unordered_set<int> >(61);\\n        color=vector<int>(61, 0);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                left[g[i][j]]=min(left[g[i][j]], j);\\n                right[g[i][j]]=max(right[g[i][j]], j);\\n                top[g[i][j]]=min(top[g[i][j]], i);\\n                bottom[g[i][j]]=max(bottom[g[i][j]], i);\\n            }\\n        }\\n        for(int i=1; i<=60; i++){\\n            if(top[i]==10000) continue;\\n            for(int x=top[i]; x<=bottom[i]; x++){\\n                for(int y=left[i]; y<=right[i]; y++){\\n                    if(g[x][y]!=i){\\n                        adj[i].insert(g[x][y]);\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=1; i<=60; i++){\\n            if(top[i]==10000) continue;\\n            if(color[i]==0){\\n                if(cycle_exists(i)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<unordered_set<int> > adj;\\n    vector<int> color;\\n    \\n    bool cycle_exists(int v){\\n        color[v]=1;\\n        for(int to: adj[v]){\\n            if(color[to]==1){\\n                return true;\\n            }\\n            else if(color[to]==0){\\n                if(cycle_exists(to)){\\n                    return true;\\n                }\\n            }\\n        }\\n        color[v]=2;\\n        return false;\\n    }\\n    \\n    bool isPrintable(vector<vector<int>>& g) {\\n        vector<int> left(61, 10000), right(61, -1), top(61, 10000), bottom(61, -1);\\n        int n=g.size(), m=g[0].size();\\n        adj=vector<unordered_set<int> >(61);\\n        color=vector<int>(61, 0);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                left[g[i][j]]=min(left[g[i][j]], j);\\n                right[g[i][j]]=max(right[g[i][j]], j);\\n                top[g[i][j]]=min(top[g[i][j]], i);\\n                bottom[g[i][j]]=max(bottom[g[i][j]], i);\\n            }\\n        }\\n        for(int i=1; i<=60; i++){\\n            if(top[i]==10000) continue;\\n            for(int x=top[i]; x<=bottom[i]; x++){\\n                for(int y=left[i]; y<=right[i]; y++){\\n                    if(g[x][y]!=i){\\n                        adj[i].insert(g[x][y]);\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=1; i<=60; i++){\\n            if(top[i]==10000) continue;\\n            if(color[i]==0){\\n                if(cycle_exists(i)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906886,
                "title": "java-o-mnc-beats97-with-explaintion-clean-code-but-a-little-long",
                "content": "1\\u3001Try to clean a rectangle of same number to 0 each time. Then Try to clean all numbers to 0. \\n2\\u3001If we meet different number , push the previos number to Stack and Try to clean the new number.\\n3\\u3001The cleaning will fail if the number to be cleaned has been in Stack , and the result is false. \\n4\\u3001After all numbers are cleaned ,return true.\\n\\n```\\nclass Solution {\\n    int[][] Range = new int[4][61];  //left,up,right,down;\\n    int[][] main;\\n    List<Integer> numToBeCleaned = new ArrayList<>();\\n    HashSet<Integer> cleanStack = new HashSet<>();\\n\\n    public boolean isPrintable(int[][] targetGrid) {\\n        initialize(targetGrid);\\n        while (!numToBeCleaned.isEmpty()){\\n            cleanStack.clear();\\n            if(!clean(numToBeCleaned.get(0)))return false;\\n        }\\n        return true;\\n    }\\n\\n    private boolean clean(int target){\\n        if(!cleanStack.add(target)) return false;\\n        for (int i = Range[1][target]; i <= Range[3][target]; i++)\\n            for (int j = Range[0][target]; j <= Range[2][target]; j++) {\\n                if(main[i][j]==0)continue;\\n                if(main[i][j]==target){main[i][j] = 0;continue;}\\n                if(!clean(main[i][j])){return false;}\\n            }\\n        numToBeCleaned.remove(numToBeCleaned.indexOf(target));\\n        return true;\\n    }\\n\\n    private void initialize(int[][] t){\\n        main = t;\\n        Arrays.fill(Range[0],Integer.MAX_VALUE);\\n        Arrays.fill(Range[1],Integer.MAX_VALUE);\\n        Arrays.fill(Range[2],-1);\\n        Arrays.fill(Range[3],-1);\\n\\n        int v = 0;\\n        for(int i = 0; i < main.length;i++)\\n            for (int j = 0; j < main[0].length; j++) {\\n                v = main[i][j];\\n                Range[0][v] = Math.min(j, Range[0][v]);\\n                Range[1][v] = Math.min(i, Range[1][v]);\\n                Range[2][v] = Math.max(j, Range[2][v]);\\n                Range[3][v] = Math.max(i, Range[3][v]);\\n            }\\n\\n\\n        for (int i = 0; i < 61; i++)\\n            if(Range[2][i] != -1)\\n                numToBeCleaned.add(i);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] Range = new int[4][61];  //left,up,right,down;\\n    int[][] main;\\n    List<Integer> numToBeCleaned = new ArrayList<>();\\n    HashSet<Integer> cleanStack = new HashSet<>();\\n\\n    public boolean isPrintable(int[][] targetGrid) {\\n        initialize(targetGrid);\\n        while (!numToBeCleaned.isEmpty()){\\n            cleanStack.clear();\\n            if(!clean(numToBeCleaned.get(0)))return false;\\n        }\\n        return true;\\n    }\\n\\n    private boolean clean(int target){\\n        if(!cleanStack.add(target)) return false;\\n        for (int i = Range[1][target]; i <= Range[3][target]; i++)\\n            for (int j = Range[0][target]; j <= Range[2][target]; j++) {\\n                if(main[i][j]==0)continue;\\n                if(main[i][j]==target){main[i][j] = 0;continue;}\\n                if(!clean(main[i][j])){return false;}\\n            }\\n        numToBeCleaned.remove(numToBeCleaned.indexOf(target));\\n        return true;\\n    }\\n\\n    private void initialize(int[][] t){\\n        main = t;\\n        Arrays.fill(Range[0],Integer.MAX_VALUE);\\n        Arrays.fill(Range[1],Integer.MAX_VALUE);\\n        Arrays.fill(Range[2],-1);\\n        Arrays.fill(Range[3],-1);\\n\\n        int v = 0;\\n        for(int i = 0; i < main.length;i++)\\n            for (int j = 0; j < main[0].length; j++) {\\n                v = main[i][j];\\n                Range[0][v] = Math.min(j, Range[0][v]);\\n                Range[1][v] = Math.min(i, Range[1][v]);\\n                Range[2][v] = Math.max(j, Range[2][v]);\\n                Range[3][v] = Math.max(i, Range[3][v]);\\n            }\\n\\n\\n        for (int i = 0; i < 61; i++)\\n            if(Range[2][i] != -1)\\n                numToBeCleaned.add(i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906641,
                "title": "python3-time-o-n-m-c-space-o-c-beats-98",
                "content": "Record the boundry of each color in the grid so we can constraint the search area, in which should we encounter a different color, we\\'ll try to resolve (revert the painting) that color first.\\n\\nA painting can\\'t be reverted successfully, `cleanRectangle => true`, if it relies on reverting some colors beforehand while they rely on reverting this color first. Which means, a circular dependency is detected. We mark a grid with `-1` if this grid is not resolved yet, and if in the recursive process we encounter such a value, we can abort the process because a circle exists.\\n\\nTime complexity: O(NMC)\\nThe first call to `cleanRectangle` for each color might take up to NM traverse to visit and update the targetGrid. The second call might happen and in that case, we detect the circle and abort early.\\n\\nSpace: O(C)\\nThe space for `boundry` is O(C), and the depth of recursive call is O(C).\\n\\n\\n\\n```python\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        N, M, colors = len(targetGrid), len(targetGrid[0]) if len(targetGrid) else 0, max( max(r) for r in targetGrid )\\n        boundry = [(N, 0, M, 0)]*(colors+1) # boundry[i] = (a, b, c, d) if the color shows in rows [a:b+1] and colums [c:d+1]\\n        resolved = set()\\n        for x in range(N):\\n            for y in range(M):\\n                c = targetGrid[x][y]\\n                boundry[c] = min(x, boundry[c][0]), max(x, boundry[c][1]), min(y, boundry[c][2]), max(y, boundry[c][3])\\n        \\n        def cleanRectangle(color: int) -> bool: # if we can form a rectangle, remove this color (label 0)\\n            frX, toX, frY, toY = boundry[color]\\n            if color in resolved:\\n                return True\\n            for i in range(frX, toX+1):\\n                for j in range(frY, toY+1):\\n                    if targetGrid[i][j] == color:\\n                        targetGrid[i][j] = -1\\n                    elif targetGrid[i][j] == -1: # circle back to a unsolved color, detect a deadlock (circular dependency)\\n                        return False\\n                    elif targetGrid[i][j] > 0 and not cleanRectangle(targetGrid[i][j]):\\n                        return False\\n            for i in range(frX, toX+1):\\n                for j in range(frY, toY+1):\\n                    targetGrid[i][j] = 0\\n            resolved.add(color)\\n            return True\\n        \\n        for i in range(N):\\n            for j in range(M):\\n                if targetGrid[i][j] and not cleanRectangle(targetGrid[i][j]):\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        N, M, colors = len(targetGrid), len(targetGrid[0]) if len(targetGrid) else 0, max( max(r) for r in targetGrid )\\n        boundry = [(N, 0, M, 0)]*(colors+1) # boundry[i] = (a, b, c, d) if the color shows in rows [a:b+1] and colums [c:d+1]\\n        resolved = set()\\n        for x in range(N):\\n            for y in range(M):\\n                c = targetGrid[x][y]\\n                boundry[c] = min(x, boundry[c][0]), max(x, boundry[c][1]), min(y, boundry[c][2]), max(y, boundry[c][3])\\n        \\n        def cleanRectangle(color: int) -> bool: # if we can form a rectangle, remove this color (label 0)\\n            frX, toX, frY, toY = boundry[color]\\n            if color in resolved:\\n                return True\\n            for i in range(frX, toX+1):\\n                for j in range(frY, toY+1):\\n                    if targetGrid[i][j] == color:\\n                        targetGrid[i][j] = -1\\n                    elif targetGrid[i][j] == -1: # circle back to a unsolved color, detect a deadlock (circular dependency)\\n                        return False\\n                    elif targetGrid[i][j] > 0 and not cleanRectangle(targetGrid[i][j]):\\n                        return False\\n            for i in range(frX, toX+1):\\n                for j in range(frY, toY+1):\\n                    targetGrid[i][j] = 0\\n            resolved.add(color)\\n            return True\\n        \\n        for i in range(N):\\n            for j in range(M):\\n                if targetGrid[i][j] and not cleanRectangle(targetGrid[i][j]):\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880691,
                "title": "c-cycle-detecion-dfs-coloring-clean-code-with-comments",
                "content": "```\\nclass Solution {\\n    struct Bounds {\\n        int left, right, top, bottom;\\n        Bounds() : left(INT_MAX), \\n                   right(INT_MIN),\\n                   top(INT_MAX), \\n                   bottom(INT_MIN)\\n                   {}\\n    };\\n    unordered_map<int, Bounds> colors;\\n    \\n    bool cycle(vector<vector<int>>& grid, int col){\\n        for (int i = colors[col].top; i <= colors[col].bottom; ++i){\\n            for (int j = colors[col].left; j <= colors[col].right; ++j){\\n                if (grid[i][j] == -1) return true; // already visited and unresolved!\\n                else if (grid[i][j] == col) grid[i][j] = -1; // mark visiting\\n                else if (grid[i][j] && cycle(grid, grid[i][j])) return true;\\n            }\\n        }\\n        \\n        for (int i = colors[col].top; i <= colors[col].bottom; ++i){\\n            for (int j = colors[col].left; j <= colors[col].right; ++j){\\n                grid[i][j] = 0; // resolved\\n            }\\n        }\\n        \\n        return false;\\n    }\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        for (int i = 0; i < targetGrid.size(); ++i){\\n            for (int j = 0; j < targetGrid[0].size(); ++j){\\n                colors[targetGrid[i][j]].left = min(colors[targetGrid[i][j]].left, j);\\n                colors[targetGrid[i][j]].top = min(colors[targetGrid[i][j]].top, i);\\n                colors[targetGrid[i][j]].right = max(colors[targetGrid[i][j]].right, j);\\n                colors[targetGrid[i][j]].bottom = max(colors[targetGrid[i][j]].bottom, i);\\n            }\\n        }\\n        \\n        for (int i = 0; i < targetGrid.size(); ++i){\\n            for (int j = 0; j < targetGrid[0].size(); ++j){\\n                if (targetGrid[i][j] && cycle(targetGrid, targetGrid[i][j])) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    struct Bounds {\\n        int left, right, top, bottom;\\n        Bounds() : left(INT_MAX), \\n                   right(INT_MIN),\\n                   top(INT_MAX), \\n                   bottom(INT_MIN)\\n                   {}\\n    };\\n    unordered_map<int, Bounds> colors;\\n    \\n    bool cycle(vector<vector<int>>& grid, int col){\\n        for (int i = colors[col].top; i <= colors[col].bottom; ++i){\\n            for (int j = colors[col].left; j <= colors[col].right; ++j){\\n                if (grid[i][j] == -1) return true; // already visited and unresolved!\\n                else if (grid[i][j] == col) grid[i][j] = -1; // mark visiting\\n                else if (grid[i][j] && cycle(grid, grid[i][j])) return true;\\n            }\\n        }\\n        \\n        for (int i = colors[col].top; i <= colors[col].bottom; ++i){\\n            for (int j = colors[col].left; j <= colors[col].right; ++j){\\n                grid[i][j] = 0; // resolved\\n            }\\n        }\\n        \\n        return false;\\n    }\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        for (int i = 0; i < targetGrid.size(); ++i){\\n            for (int j = 0; j < targetGrid[0].size(); ++j){\\n                colors[targetGrid[i][j]].left = min(colors[targetGrid[i][j]].left, j);\\n                colors[targetGrid[i][j]].top = min(colors[targetGrid[i][j]].top, i);\\n                colors[targetGrid[i][j]].right = max(colors[targetGrid[i][j]].right, j);\\n                colors[targetGrid[i][j]].bottom = max(colors[targetGrid[i][j]].bottom, i);\\n            }\\n        }\\n        \\n        for (int i = 0; i < targetGrid.size(); ++i){\\n            for (int j = 0; j < targetGrid[0].size(); ++j){\\n                if (targetGrid[i][j] && cycle(targetGrid, targetGrid[i][j])) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874875,
                "title": "o-c-mn-c-solution-with-2d-prefix-sum-array",
                "content": "Think of the reverse process, i.e. remove colors according to some order and finally leaves nothing. A color is removable if there is no other color in its bounding box.\\n\\nWe do C rounds, at each round, we check all remaining colors one by one and see if it\\'s fine to remove it. If it\\'s fine, we go to next round; otherwise, we return false.\\n\\nOnce a color is removed, we mark these cells as free. A color is removable iff the bounding box of this color contains only this color or free cells.\\n\\nDuring each round, we iterate all possible colors, and just need to check if this color\\'s bounding box contains only itself or free cells. We can know the bounding box and count of this color in advance easily. The key challenge is to get # free cells efficiently.\\n\\nBefore each round, we store the count of free cells in first r rows and first c columns in `dp[r][c]`, which can be computed using O(mn) time with dynamic programming. To query the count of free cells in a bounding box, we can use `dp[bottom][right] + dp[top - 1][left - 1] - dp[bottom][left - 1] - dp[top - 1][right]` which takes constant time. So it takes constant time to check for each color. Each round takes O(mn+c) time.\\n\\n```C++\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m = len(targetGrid)\\n        n = len(targetGrid[0])\\n        left = [n] * 65\\n        right = [0] * 65\\n        top = [m] * 65\\n        bottom = [0] * 65\\n        cnt = [0] * 65\\n        colors = set([])\\n        for i in range(m):\\n            for j in range(n):\\n                colors.add(targetGrid[i][j])\\n                left[targetGrid[i][j]] = min(left[targetGrid[i][j]],j)\\n                right[targetGrid[i][j]] = max(right[targetGrid[i][j]],j)\\n                top[targetGrid[i][j]]=min(top[targetGrid[i][j]],i)\\n                bottom[targetGrid[i][j]]=max(bottom[targetGrid[i][j]],i)\\n                cnt[targetGrid[i][j]]+=1\\n        while colors:\\n            to_delete = None\\n            # Update unknown.\\n            unknown = [[0 for _ in range(n)] for _ in range(m)]\\n            for i in range(m):\\n                for j in range(n):\\n                    if i==0 and j==0:\\n                        unknown[i][j]=1 if targetGrid[i][j]==0 else 0\\n                    elif i==0:\\n                        unknown[i][j]=unknown[i][j-1]\\n                        if targetGrid[i][j]==0:\\n                            unknown[i][j]+=1\\n                    elif j==0:\\n                        unknown[i][j]=unknown[i-1][j]\\n                        if targetGrid[i][j]==0:\\n                            unknown[i][j]+=1\\n                    else:\\n                        unknown[i][j]=unknown[i][j-1]+unknown[i-1][j]-unknown[i-1][j-1]\\n                        if targetGrid[i][j]==0:\\n                            unknown[i][j]+=1\\n            for color in colors:\\n                # Check if possible to remove color.\\n                l, r, t, b = left[color], right[color], top[color], bottom[color]\\n                unknown_cnt = unknown[b][r]\\n                if l and t:\\n                    unknown_cnt +=unknown[t-1][l-1]\\n                if l:\\n                    unknown_cnt -= unknown[b][l-1]\\n                if t:\\n                    unknown_cnt-=unknown[t-1][r]\\n                if unknown_cnt + cnt[color] == (r-l+1)*(b-t+1):\\n                    to_delete=color\\n                    break\\n            if not to_delete:\\n                return False\\n            colors.remove(to_delete)\\n            for i in range(m):\\n                for j in range(n):\\n                    if targetGrid[i][j]==to_delete:\\n                        targetGrid[i][j]=0\\n        return True\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m = len(targetGrid)\\n        n = len(targetGrid[0])\\n        left = [n] * 65\\n        right = [0] * 65\\n        top = [m] * 65\\n        bottom = [0] * 65\\n        cnt = [0] * 65\\n        colors = set([])\\n        for i in range(m):\\n            for j in range(n):\\n                colors.add(targetGrid[i][j])\\n                left[targetGrid[i][j]] = min(left[targetGrid[i][j]],j)\\n                right[targetGrid[i][j]] = max(right[targetGrid[i][j]],j)\\n                top[targetGrid[i][j]]=min(top[targetGrid[i][j]],i)\\n                bottom[targetGrid[i][j]]=max(bottom[targetGrid[i][j]],i)\\n                cnt[targetGrid[i][j]]+=1\\n        while colors:\\n            to_delete = None\\n            # Update unknown.\\n            unknown = [[0 for _ in range(n)] for _ in range(m)]\\n            for i in range(m):\\n                for j in range(n):\\n                    if i==0 and j==0:\\n                        unknown[i][j]=1 if targetGrid[i][j]==0 else 0\\n                    elif i==0:\\n                        unknown[i][j]=unknown[i][j-1]\\n                        if targetGrid[i][j]==0:\\n                            unknown[i][j]+=1\\n                    elif j==0:\\n                        unknown[i][j]=unknown[i-1][j]\\n                        if targetGrid[i][j]==0:\\n                            unknown[i][j]+=1\\n                    else:\\n                        unknown[i][j]=unknown[i][j-1]+unknown[i-1][j]-unknown[i-1][j-1]\\n                        if targetGrid[i][j]==0:\\n                            unknown[i][j]+=1\\n            for color in colors:\\n                # Check if possible to remove color.\\n                l, r, t, b = left[color], right[color], top[color], bottom[color]\\n                unknown_cnt = unknown[b][r]\\n                if l and t:\\n                    unknown_cnt +=unknown[t-1][l-1]\\n                if l:\\n                    unknown_cnt -= unknown[b][l-1]\\n                if t:\\n                    unknown_cnt-=unknown[t-1][r]\\n                if unknown_cnt + cnt[color] == (r-l+1)*(b-t+1):\\n                    to_delete=color\\n                    break\\n            if not to_delete:\\n                return False\\n            colors.remove(to_delete)\\n            for i in range(m):\\n                for j in range(n):\\n                    if targetGrid[i][j]==to_delete:\\n                        targetGrid[i][j]=0\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873695,
                "title": "python-simple-backtracking-with-memoization",
                "content": "A recursive back-tracking approach to this problem.\\n\\nBasic algorithm:\\n- Starting from the fully-printed grid, try to \"unprint\" colors one by one until we\\'re either able to unprint all the colors on the board or until we\\'ve exhausted possibilities.\\n- A color can only be unprinted if its bounding box in the initial grid is not covered by any other currently-printed color\\n\\nIt\\'s a simple approach, the only difficulty is figuring out when a color is \"valid\" to be unprinted and the rest is standard backtracking.\\n\\nIf we assume we know where each colors bounding box is, then we just need to check all the squares in the grid within that bounding box and check `square == color or square\\'s color is not printed`.\\n\\nGiven this, the check is pretty easy:\\n\\n```\\ndef isUncoveredRect(grid, color, colorRects, printed):\\n\\t\"\"\"Return whether color\\'s bounding box is currently uncovered by other colors in the grid\\n\\n\\tA colors bounding box is only uncovered by others if every square in the box is either the given color\\n\\tor !printed[color].\\n\\t\"\"\"\\n\\tstartRow, startCol, endRow, endCol = colorRects[color]\\n\\tfor row in range(startRow, endRow):\\n\\t\\tfor col in range(startCol, endCol):\\n\\t\\t\\tif grid[row][col] != color and printed[grid[row][col]]:\\n\\t\\t\\t\\treturn False\\n\\treturn True\\n```\\n\\nIn order to get `colorRects`, pre-process the grid to get this data structure `(color) -> topRow, leftCol, bottomRow, rightCol`\\n\\n```\\ncolorRects = {}\\nfor row in range(len(targetGrid)):\\n\\tfor col in range(len(targetGrid[0])):\\n\\t\\tcolor = targetGrid[row][col]\\n\\t\\tif color not in colorRects:\\n\\t\\t\\t# first row will always be start row since we\\'re moving top to bottom\\n\\t\\t\\tcolorRects[color] = (row, col, row + 1, col + 1)\\n\\t\\telse:\\n\\t\\t\\t# need to take care to update startCol and endCol for each rectangle accordingly\\n\\t\\t\\toldRow, oldCol, oldEndRow, oldEndCol = colorRects[color]\\n\\t\\t\\tcolorRects[color] = (oldRow, min(oldCol, col), row + 1, max(oldEndCol, col + 1))\\n```\\n\\nFinally, putting this together into a backtracking algorithm, we define a function `unprint` to recurse and backtrack, trying to \"unprint\" a color and then trying to `unprint` remaining printed colors which are uncovered on the board.\\n\\nFor performance, I needed to memo-ize the calculation so that we don\\'t get stuck in hopeless branches. This adds some extra space for the memo structure and is likely `O(2^C)` in theory, but in practice it only grows as much as we have valid \"uncovered\" branches which don\\'t lead to a solution.\\n\\n```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n                \\n        # recursive backtracking with memoization\\n        \\n        # alg: choose colors to \"unprint\" one by one and backtrack when grid constraint is not satissfied\\n        # return True if all numbers have been uncovered\\n        \\n        # setup: process grid to get positions of smallest possible rect for each color\\n        # represented with (startRow, startCol, endRow, endCol)\\n        # optimization is used to determine valid unprint color candidates\\n        \\n        # start with all colors printed\\n        \\n        # isUncoveredRect(grid, color, colorRects, printed) => true if colorRect for color in grid is all either color or !printed\\n                \\n        # backtrack (dfs), choose a non-printed color that is a valid uncovered rectangle to unprint\\n        # keep going until either we can\\'t add anymore or we\\'ve reached a solution\\n        # re-print color on the backtrack path\\n        # keep memo of if we\\'ve seen the same printed state for optimization (adds O(2^C) space but in practice\\n        # only a function of potential uncovered rectangles). likely room for improvement\\n        \\n        def isUncoveredRect(grid, color, colorRects, printed):\\n            \"\"\"Return whether color\\'s bounding box is currently uncovered by other colors in the grid\\n            \\n            A colors bounding box is only uncovered by others if every square in the box is either the given color\\n            or !printed[color].\\n            \"\"\"\\n            startRow, startCol, endRow, endCol = colorRects[color]\\n            for row in range(startRow, endRow):\\n                for col in range(startCol, endCol):\\n                    if grid[row][col] != color and printed[grid[row][col]]:\\n                        return False\\n            return True\\n        \\n                       \\n        def unprint(targetGrid, color, colorRects, printed, memo):\\n            \"\"\"Backtrack by unprinting color and then trying to unprint other printed, uncovered rectangle colors\\n            \\n            Assumes only called for valid uncovered, un-printed color color\\n            \\n            Selection criteria of which color to print next likely can be improved via heuristic but keeping simple seems to work\\n            \"\"\"\\n            \\n            # printed.values() -> boolean tuple of length C\\n            if tuple(printed.values()) in memo:\\n                return memo[tuple(printed.values())]\\n            \\n            printed[color] = False\\n            if not any(printed.values()):\\n                return True\\n            \\n            for printedColor in printed:\\n                if printed[printedColor] and isUncoveredRect(targetGrid, printedColor, colorRects, printed):\\n                    if unprint(targetGrid, printedColor, colorRects, printed, memo):\\n                        return True\\n            \\n            # failed to find solution in this path, \"re-print\" color\\n            printed[color] = True\\n            memo[tuple(printed.values())] = False\\n            return False\\n        \\n        if len(targetGrid) < 1:\\n            return False\\n        \\n        # setup O(MN), space O(C)\\n        colorRects = {}\\n        for row in range(len(targetGrid)):\\n            for col in range(len(targetGrid[0])):\\n                color = targetGrid[row][col]\\n                if color not in colorRects:\\n                    # first row will always be start row\\n                    colorRects[color] = (row, col, row + 1, col + 1)\\n                else:\\n                    # need to take care to update startCol and endCol for each rectangle accordingly\\n                    oldRow, oldCol, oldEndRow, oldEndCol = colorRects[color]\\n                    colorRects[color] = (oldRow, min(oldCol, col), row + 1, max(oldEndCol, col + 1))\\n       \\n        printed = { color: True for color in colorRects }\\n        memo = {}\\n        for color in printed:\\n            if isUncoveredRect(targetGrid, color, colorRects, printed) and unprint(targetGrid, color, colorRects, printed, memo):\\n                return True\\n        return False\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\ndef isUncoveredRect(grid, color, colorRects, printed):\\n\\t\"\"\"Return whether color\\'s bounding box is currently uncovered by other colors in the grid\\n\\n\\tA colors bounding box is only uncovered by others if every square in the box is either the given color\\n\\tor !printed[color].\\n\\t\"\"\"\\n\\tstartRow, startCol, endRow, endCol = colorRects[color]\\n\\tfor row in range(startRow, endRow):\\n\\t\\tfor col in range(startCol, endCol):\\n\\t\\t\\tif grid[row][col] != color and printed[grid[row][col]]:\\n\\t\\t\\t\\treturn False\\n\\treturn True\\n```\n```\\ncolorRects = {}\\nfor row in range(len(targetGrid)):\\n\\tfor col in range(len(targetGrid[0])):\\n\\t\\tcolor = targetGrid[row][col]\\n\\t\\tif color not in colorRects:\\n\\t\\t\\t# first row will always be start row since we\\'re moving top to bottom\\n\\t\\t\\tcolorRects[color] = (row, col, row + 1, col + 1)\\n\\t\\telse:\\n\\t\\t\\t# need to take care to update startCol and endCol for each rectangle accordingly\\n\\t\\t\\toldRow, oldCol, oldEndRow, oldEndCol = colorRects[color]\\n\\t\\t\\tcolorRects[color] = (oldRow, min(oldCol, col), row + 1, max(oldEndCol, col + 1))\\n```\n```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n                \\n        # recursive backtracking with memoization\\n        \\n        # alg: choose colors to \"unprint\" one by one and backtrack when grid constraint is not satissfied\\n        # return True if all numbers have been uncovered\\n        \\n        # setup: process grid to get positions of smallest possible rect for each color\\n        # represented with (startRow, startCol, endRow, endCol)\\n        # optimization is used to determine valid unprint color candidates\\n        \\n        # start with all colors printed\\n        \\n        # isUncoveredRect(grid, color, colorRects, printed) => true if colorRect for color in grid is all either color or !printed\\n                \\n        # backtrack (dfs), choose a non-printed color that is a valid uncovered rectangle to unprint\\n        # keep going until either we can\\'t add anymore or we\\'ve reached a solution\\n        # re-print color on the backtrack path\\n        # keep memo of if we\\'ve seen the same printed state for optimization (adds O(2^C) space but in practice\\n        # only a function of potential uncovered rectangles). likely room for improvement\\n        \\n        def isUncoveredRect(grid, color, colorRects, printed):\\n            \"\"\"Return whether color\\'s bounding box is currently uncovered by other colors in the grid\\n            \\n            A colors bounding box is only uncovered by others if every square in the box is either the given color\\n            or !printed[color].\\n            \"\"\"\\n            startRow, startCol, endRow, endCol = colorRects[color]\\n            for row in range(startRow, endRow):\\n                for col in range(startCol, endCol):\\n                    if grid[row][col] != color and printed[grid[row][col]]:\\n                        return False\\n            return True\\n        \\n                       \\n        def unprint(targetGrid, color, colorRects, printed, memo):\\n            \"\"\"Backtrack by unprinting color and then trying to unprint other printed, uncovered rectangle colors\\n            \\n            Assumes only called for valid uncovered, un-printed color color\\n            \\n            Selection criteria of which color to print next likely can be improved via heuristic but keeping simple seems to work\\n            \"\"\"\\n            \\n            # printed.values() -> boolean tuple of length C\\n            if tuple(printed.values()) in memo:\\n                return memo[tuple(printed.values())]\\n            \\n            printed[color] = False\\n            if not any(printed.values()):\\n                return True\\n            \\n            for printedColor in printed:\\n                if printed[printedColor] and isUncoveredRect(targetGrid, printedColor, colorRects, printed):\\n                    if unprint(targetGrid, printedColor, colorRects, printed, memo):\\n                        return True\\n            \\n            # failed to find solution in this path, \"re-print\" color\\n            printed[color] = True\\n            memo[tuple(printed.values())] = False\\n            return False\\n        \\n        if len(targetGrid) < 1:\\n            return False\\n        \\n        # setup O(MN), space O(C)\\n        colorRects = {}\\n        for row in range(len(targetGrid)):\\n            for col in range(len(targetGrid[0])):\\n                color = targetGrid[row][col]\\n                if color not in colorRects:\\n                    # first row will always be start row\\n                    colorRects[color] = (row, col, row + 1, col + 1)\\n                else:\\n                    # need to take care to update startCol and endCol for each rectangle accordingly\\n                    oldRow, oldCol, oldEndRow, oldEndCol = colorRects[color]\\n                    colorRects[color] = (oldRow, min(oldCol, col), row + 1, max(oldEndCol, col + 1))\\n       \\n        printed = { color: True for color in colorRects }\\n        memo = {}\\n        for color in printed:\\n            if isUncoveredRect(targetGrid, color, colorRects, printed) and unprint(targetGrid, color, colorRects, printed, memo):\\n                return True\\n        return False\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866940,
                "title": "python3-topological-sort",
                "content": "```\\nfrom typing import List\\nimport collections\\n\\n\\nclass Solution:\\n\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        limit = 60\\n        rectangles = {}\\n        for line in range(len(targetGrid)):\\n            for col in range(len(targetGrid[0])):\\n                color = targetGrid[line][col]\\n                if color not in rectangles:\\n                    rectangles[color] = {}\\n                rectangles[color] = {\\n                    \"left\":  min(rectangles[color].get(\"left\", limit), col),\\n                    \"right\": max(rectangles[color].get(\"right\", 0), col),\\n                    \"up\": min(rectangles[color].get(\"up\", limit), line),\\n                    \"down\": max(rectangles[color].get(\"down\", 0), line),\\n                }\\n\\n        graph = {}\\n        for color, rect in rectangles.items():\\n            graph[color] = set()\\n            for line in range(rect[\"up\"], rect[\"down\"]+1):\\n                for col in range(rect[\"left\"], rect[\"right\"]+1):\\n                    if targetGrid[line][col] != color:\\n                        graph[color].add(targetGrid[line][col])\\n\\n        dq = collections.deque()\\n\\n        for color in graph.keys():\\n            if len(graph[color]) == 0:\\n                dq.append(color)\\n                graph[color] = None\\n\\n        while len(dq) != 0:\\n            color = dq.pop()\\n            for deps in graph.values():\\n                if deps == None:\\n                    continue\\n                if color in deps:\\n                    deps.remove(color)\\n            for color in graph.keys():\\n                if graph[color] != None and len(graph[color]) == 0:\\n                    dq.append(color)\\n                    graph[color] = None\\n\\n        for v in graph.values():\\n            if v != None:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\nimport collections\\n\\n\\nclass Solution:\\n\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        limit = 60\\n        rectangles = {}\\n        for line in range(len(targetGrid)):\\n            for col in range(len(targetGrid[0])):\\n                color = targetGrid[line][col]\\n                if color not in rectangles:\\n                    rectangles[color] = {}\\n                rectangles[color] = {\\n                    \"left\":  min(rectangles[color].get(\"left\", limit), col),\\n                    \"right\": max(rectangles[color].get(\"right\", 0), col),\\n                    \"up\": min(rectangles[color].get(\"up\", limit), line),\\n                    \"down\": max(rectangles[color].get(\"down\", 0), line),\\n                }\\n\\n        graph = {}\\n        for color, rect in rectangles.items():\\n            graph[color] = set()\\n            for line in range(rect[\"up\"], rect[\"down\"]+1):\\n                for col in range(rect[\"left\"], rect[\"right\"]+1):\\n                    if targetGrid[line][col] != color:\\n                        graph[color].add(targetGrid[line][col])\\n\\n        dq = collections.deque()\\n\\n        for color in graph.keys():\\n            if len(graph[color]) == 0:\\n                dq.append(color)\\n                graph[color] = None\\n\\n        while len(dq) != 0:\\n            color = dq.pop()\\n            for deps in graph.values():\\n                if deps == None:\\n                    continue\\n                if color in deps:\\n                    deps.remove(color)\\n            for color in graph.keys():\\n                if graph[color] != None and len(graph[color]) == 0:\\n                    dq.append(color)\\n                    graph[color] = None\\n\\n        for v in graph.values():\\n            if v != None:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866050,
                "title": "concise-python",
                "content": "```\\nclass Solution:\\ndef isPrintable(self, g: List[List[int]]) -> bool:\\n\\tdef helper():\\n\\t\\tm = {}                \\n\\t\\tfor i, r in enumerate(g):\\n\\t\\t\\tfor j, c in enumerate(r):                \\n\\t\\t\\t\\tpos = m.get(c, (float(\\'inf\\'), float(\\'inf\\'), 0, 0))\\n\\t\\t\\t\\tm[c] = (min(pos[0], i), min(pos[1], j), max(pos[2], i), max(pos[3], j))\\n\\t\\treturn m        \\n\\tdef good(c, pos):            \\n\\t\\tfor i in range(pos[0], pos[2]+1):\\n\\t\\t\\tfor j in range(pos[1], pos[3]+1):\\n\\t\\t\\t\\tif g[i][j] not in [0, c]: return False\\n\\t\\treturn True                        \\n\\tM, N, mem = len(g), len(g[0]), helper()\\n\\twhile True:            \\n\\t\\tq = set(c for c in mem if good(c, mem[c]))\\n\\t\\tif not q: return not mem\\n\\t\\tfor i in range(M):\\n\\t\\t\\tfor j in range(N):\\n\\t\\t\\t\\tif g[i][j] in q: g[i][j] = 0\\n\\t\\tfor c in q: del mem[c]",
                "solutionTags": [],
                "code": "class Solution:\\ndef isPrintable(self, g: List[List[int]]) -> bool:\\n\\tdef helper():\\n\\t\\tm = {}",
                "codeTag": "Java"
            },
            {
                "id": 863645,
                "title": "c-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        //identify the possible four corners of the rectangle for each color\\n        vector<vector<int>> grid(61, vector<int>(4, -1));\\n        int n = targetGrid.size(), m = targetGrid[0].size();\\n        for(int row=0; row<n; row++){\\n            for(int col=0; col<m; col++){\\n                int color = targetGrid[row][col];\\n                (grid[color][0] == -1) ? grid[color][0] = row : grid[color][0] = min(row, grid[color][0]);\\n                (grid[color][1] == -1) ? grid[color][1] = col : grid[color][1] = min(col, grid[color][1]);\\n                (grid[color][2] == -1) ? grid[color][2] = row : grid[color][2] = max(row, grid[color][2]);\\n                (grid[color][3] == -1) ? grid[color][3] = col : grid[color][3] = max(col, grid[color][3]);\\n            }\\n        }\\n        \\n        //build graph\\n        vector<vector<int>> graph(61, vector<int>(61, 0));\\n        vector<int> indegree(61, -1);\\n        for(int color=1; color<61; color++){\\n            if(grid[color][0] == -1) continue;\\n            indegree[color] = 0;\\n            vector<int> visited(61, 0);\\n            for(int row=grid[color][0]; row<=grid[color][2]; row++){\\n                for(int col=grid[color][1]; col<=grid[color][3]; col++){\\n                    if(targetGrid[row][col] != color && !visited[targetGrid[row][col]]){\\n                        visited[targetGrid[row][col]] = 1;\\n                        graph[targetGrid[row][col]][color] = 1;\\n                        indegree[color]++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //topological sort\\n        queue<int> q;\\n        for(int color=1; color<=60; color++) if(indegree[color] == 0) q.push(color);\\n        while(!q.empty()){\\n            int front = q.front();\\n            q.pop();\\n            for(int color=1; color<61; color++){\\n                if(graph[front][color] == 1){\\n                    indegree[color]--;\\n                    if(indegree[color] == 0) q.push(color);\\n                }\\n            }\\n        }\\n        \\n        for(int color=1; color<61; color++){\\n            if(indegree[color] > 0) return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        //identify the possible four corners of the rectangle for each color\\n        vector<vector<int>> grid(61, vector<int>(4, -1));\\n        int n = targetGrid.size(), m = targetGrid[0].size();\\n        for(int row=0; row<n; row++){\\n            for(int col=0; col<m; col++){\\n                int color = targetGrid[row][col];\\n                (grid[color][0] == -1) ? grid[color][0] = row : grid[color][0] = min(row, grid[color][0]);\\n                (grid[color][1] == -1) ? grid[color][1] = col : grid[color][1] = min(col, grid[color][1]);\\n                (grid[color][2] == -1) ? grid[color][2] = row : grid[color][2] = max(row, grid[color][2]);\\n                (grid[color][3] == -1) ? grid[color][3] = col : grid[color][3] = max(col, grid[color][3]);\\n            }\\n        }\\n        \\n        //build graph\\n        vector<vector<int>> graph(61, vector<int>(61, 0));\\n        vector<int> indegree(61, -1);\\n        for(int color=1; color<61; color++){\\n            if(grid[color][0] == -1) continue;\\n            indegree[color] = 0;\\n            vector<int> visited(61, 0);\\n            for(int row=grid[color][0]; row<=grid[color][2]; row++){\\n                for(int col=grid[color][1]; col<=grid[color][3]; col++){\\n                    if(targetGrid[row][col] != color && !visited[targetGrid[row][col]]){\\n                        visited[targetGrid[row][col]] = 1;\\n                        graph[targetGrid[row][col]][color] = 1;\\n                        indegree[color]++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //topological sort\\n        queue<int> q;\\n        for(int color=1; color<=60; color++) if(indegree[color] == 0) q.push(color);\\n        while(!q.empty()){\\n            int front = q.front();\\n            q.pop();\\n            for(int color=1; color<61; color++){\\n                if(graph[front][color] == 1){\\n                    indegree[color]--;\\n                    if(indegree[color] == 0) q.push(color);\\n                }\\n            }\\n        }\\n        \\n        for(int color=1; color<61; color++){\\n            if(indegree[color] > 0) return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863010,
                "title": "python3-98-7-81",
                "content": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        LEN = 61\\n        self.left = [LEN]* LEN\\n        self.right = [-1] * LEN\\n        self.top = [LEN] * LEN\\n        self.bottom = [-1] * LEN\\n        m = len(targetGrid)\\n        n = len(targetGrid[0])\\n        for row in range(m):\\n            for col in range(n):\\n                a = targetGrid[row][col]\\n                if self.left[a] > row:\\n                    self.left[a] = row\\n                if self.right[a] < row:\\n                    self.right[a] = row\\n                if self.top[a] > col:\\n                    self.top[a] = col\\n                if self.bottom[a] < col:\\n                    self.bottom[a] = col\\n        keys = set()\\n        for i in range(len(self.left)):\\n            if self.left[i] != LEN:\\n                keys.add(i)\\n        flag = True\\n        while flag:\\n            flag = False\\n            for k in keys:\\n                if self.canprint(k, targetGrid):\\n                    flag = True\\n                    break\\n            if flag:\\n                keys.remove(k)\\n        return len(keys) == 0\\n    \\n    def canprint(self, k, targetGrid):\\n        for i in range(self.left[k], self.right[k] + 1):\\n            for j in range(self.top[k], self.bottom[k] + 1):\\n                if targetGrid[i][j] == k or targetGrid[i][j] == 0:\\n                    pass\\n                else:\\n                    return False\\n        for i in range(self.left[k], self.right[k] + 1):\\n            for j in range(self.top[k], self.bottom[k] + 1):\\n                targetGrid[i][j] = 0\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        LEN = 61\\n        self.left = [LEN]* LEN\\n        self.right = [-1] * LEN\\n        self.top = [LEN] * LEN\\n        self.bottom = [-1] * LEN\\n        m = len(targetGrid)\\n        n = len(targetGrid[0])\\n        for row in range(m):\\n            for col in range(n):\\n                a = targetGrid[row][col]\\n                if self.left[a] > row:\\n                    self.left[a] = row\\n                if self.right[a] < row:\\n                    self.right[a] = row\\n                if self.top[a] > col:\\n                    self.top[a] = col\\n                if self.bottom[a] < col:\\n                    self.bottom[a] = col\\n        keys = set()\\n        for i in range(len(self.left)):\\n            if self.left[i] != LEN:\\n                keys.add(i)\\n        flag = True\\n        while flag:\\n            flag = False\\n            for k in keys:\\n                if self.canprint(k, targetGrid):\\n                    flag = True\\n                    break\\n            if flag:\\n                keys.remove(k)\\n        return len(keys) == 0\\n    \\n    def canprint(self, k, targetGrid):\\n        for i in range(self.left[k], self.right[k] + 1):\\n            for j in range(self.top[k], self.bottom[k] + 1):\\n                if targetGrid[i][j] == k or targetGrid[i][j] == 0:\\n                    pass\\n                else:\\n                    return False\\n        for i in range(self.left[k], self.right[k] + 1):\\n            for j in range(self.top[k], self.bottom[k] + 1):\\n                targetGrid[i][j] = 0\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861516,
                "title": "python3-as-digraph",
                "content": "Learned the idea from this [post](https://leetcode.com/problems/strange-printer-ii/discuss/854151/C%2B%2B-O(n3)-solution-checking-cycle-in-dependency-graph).\\n```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m, n = len(targetGrid), len(targetGrid[0]) # dimensions \\n        \\n        # build directed graph (adjacency list)\\n        digraph = {} \\n        for c in range(1, 61): \\n            imn = jmn = 60\\n            imx = jmx = 0\\n            for i in range(m): \\n                for j in range(n): \\n                    if targetGrid[i][j] == c: \\n                        imn = min(imn, i)\\n                        imx = max(imx, i)\\n                        jmn = min(jmn, j)\\n                        jmx = max(jmx, j)\\n            for i in range(imn, imx+1):\\n                for j in range(jmn, jmx+1): \\n                    if targetGrid[i][j] != c: \\n                        digraph.setdefault(c, set()).add(targetGrid[i][j])\\n            \\n        # check for cycle in digraph (tri-color)\\n        def dfs(n): \\n            \"\"\"Return True if a cycle is detected.\"\"\"\\n            if seen[n]: return seen[n] == 1 \\n            seen[n] = 1\\n            if any(dfs(nn) for nn in digraph.get(n, set())): return True \\n            seen[n] = 2\\n            return False \\n        \\n        seen = [0]*61\\n        return not any(dfs(i) for i in range(61)) # cycle, i.e. impossible to print \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m, n = len(targetGrid), len(targetGrid[0]) # dimensions \\n        \\n        # build directed graph (adjacency list)\\n        digraph = {} \\n        for c in range(1, 61): \\n            imn = jmn = 60\\n            imx = jmx = 0\\n            for i in range(m): \\n                for j in range(n): \\n                    if targetGrid[i][j] == c: \\n                        imn = min(imn, i)\\n                        imx = max(imx, i)\\n                        jmn = min(jmn, j)\\n                        jmx = max(jmx, j)\\n            for i in range(imn, imx+1):\\n                for j in range(jmn, jmx+1): \\n                    if targetGrid[i][j] != c: \\n                        digraph.setdefault(c, set()).add(targetGrid[i][j])\\n            \\n        # check for cycle in digraph (tri-color)\\n        def dfs(n): \\n            \"\"\"Return True if a cycle is detected.\"\"\"\\n            if seen[n]: return seen[n] == 1 \\n            seen[n] = 1\\n            if any(dfs(nn) for nn in digraph.get(n, set())): return True \\n            seen[n] = 2\\n            return False \\n        \\n        seen = [0]*61\\n        return not any(dfs(i) for i in range(61)) # cycle, i.e. impossible to print \\n```",
                "codeTag": "Java"
            },
            {
                "id": 859391,
                "title": "c",
                "content": "```\\nclass Solution {\\n    bool solve(vector<vector<int>> &targetGrid, map<int, vector<int>> &dp) {\\n        if (dp.size() == 0) return true;\\n        vector<int> good;\\n        for (auto it = dp.begin(); it != dp.end(); ++it) {\\n            bool tmp = false;\\n            for (int i = it->second[0]; i <= it->second[2]; ++i) {\\n                for (int j = it->second[1]; j <= it->second[3]; ++j) {\\n                    if (targetGrid[i][j] != it->first && targetGrid[i][j] != -1) {\\n                        tmp = true;\\n                        break;\\n                    }\\n                }\\n                if (tmp) break;\\n            }\\n            if (!tmp) {\\n                for (int i = it->second[0]; i <= it->second[2]; ++i) {\\n                    for (int j = it->second[1]; j <= it->second[3]; ++j) {\\n                        targetGrid[i][j] = -1;\\n                    }\\n                }\\n                good.push_back(it->first);\\n            }\\n        }\\n        if (good.size() == 0) return false;\\n        for (int i = 0; i < good.size(); ++i) {\\n            dp.erase(good[i]);\\n        }\\n        return solve(targetGrid, dp);\\n    }\\n\\npublic:\\n    bool isPrintable(vector<vector<int>> &targetGrid) {\\n        map<int, vector<int>> dp;\\n        int n = targetGrid.size(), m = targetGrid[0].size();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                int c = targetGrid[i][j];\\n                if (dp.find(c) != dp.end()) {\\n                    dp[c][0] = min(dp[c][0], i);\\n                    dp[c][1] = min(dp[c][1], j);\\n                    dp[c][2] = max(dp[c][2], i);\\n                    dp[c][3] = max(dp[c][3], j);\\n                } else {\\n                    dp[c] = {i, j, i, j};\\n                }\\n            }\\n        }\\n        return solve(targetGrid, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool solve(vector<vector<int>> &targetGrid, map<int, vector<int>> &dp) {\\n        if (dp.size() == 0) return true;\\n        vector<int> good;\\n        for (auto it = dp.begin(); it != dp.end(); ++it) {\\n            bool tmp = false;\\n            for (int i = it->second[0]; i <= it->second[2]; ++i) {\\n                for (int j = it->second[1]; j <= it->second[3]; ++j) {\\n                    if (targetGrid[i][j] != it->first && targetGrid[i][j] != -1) {\\n                        tmp = true;\\n                        break;\\n                    }\\n                }\\n                if (tmp) break;\\n            }\\n            if (!tmp) {\\n                for (int i = it->second[0]; i <= it->second[2]; ++i) {\\n                    for (int j = it->second[1]; j <= it->second[3]; ++j) {\\n                        targetGrid[i][j] = -1;\\n                    }\\n                }\\n                good.push_back(it->first);\\n            }\\n        }\\n        if (good.size() == 0) return false;\\n        for (int i = 0; i < good.size(); ++i) {\\n            dp.erase(good[i]);\\n        }\\n        return solve(targetGrid, dp);\\n    }\\n\\npublic:\\n    bool isPrintable(vector<vector<int>> &targetGrid) {\\n        map<int, vector<int>> dp;\\n        int n = targetGrid.size(), m = targetGrid[0].size();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                int c = targetGrid[i][j];\\n                if (dp.find(c) != dp.end()) {\\n                    dp[c][0] = min(dp[c][0], i);\\n                    dp[c][1] = min(dp[c][1], j);\\n                    dp[c][2] = max(dp[c][2], i);\\n                    dp[c][3] = max(dp[c][3], j);\\n                } else {\\n                    dp[c] = {i, j, i, j};\\n                }\\n            }\\n        }\\n        return solve(targetGrid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859364,
                "title": "only-from-intuition-c",
                "content": "consider this matrix\\n1 1 1 1\\n1 1 1 1\\n1 3 3 3\\nIn this matrix which layer is on top?\\nVerifying this is the question\\nSo in quantifying this we introduce a term called loss\\nIn the above matrix rectangle of ones should start at (0,0) & end at (2,3)\\nso loss= nums in( (0,0)->(2,3) ) -actual counts of (1)\\ni.e., (4*3)-9=3;\\nNow we can see by intuition that 0 loss should be at top and highest loss should be the first layer\\n\\nwe sort by this and fill those rectangle with zeros.\\n\\n```\\nstruct rect{     // store max diagonal edges possible\\n    pair<int,int> start;\\n    pair<int,int> end;\\n};\\nclass Solution {\\npublic:\\n    unordered_map<int,rect> mp;int c;\\n    unordered_map<int,int> counts; // to count number of actual numbers\\n    bool vis[61]={};\\n    bool isPrintable(vector<vector<int>>& G) {\\n        int n=G.size(),m=G[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                c=G[i][j];\\n                if(mp.find(c)==mp.end()){\\n                    mp[c].start={i,j};mp[c].end={i,j};\\n                }\\n                else{\\n                    auto [x,y]=mp[c].start;\\n                    auto [p,q]=mp[c].end;\\n                    mp[c].start={min(x,i),min(y,j)};\\n                    mp[c].end={max(p,i),max(q,j)};\\n                }\\n                counts[c]++;\\n            }\\n        }\\n        int num,loss;\\n        vector<pair<int,int>> v;\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            c=it->first;\\n            num=(((it->second).end.second-(it->second).start.second)+1)*\\n                ((it->second).end.first-(it->second).start.first+1);\\n            loss=num-counts[c];\\n            v.push_back({loss,c});\\n        }\\n        sort(v.begin(),v.end());   //sort by loss\\n        for(int i=0;i<v.size();i++){\\n            rec=mp[v[i].second];\\n            if(!fillrec(rec,G,v[i].second)){  //if unable to fill maximal rectangle return false\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool fillrec(rect rec,vector<vector<int>>& G,int val){\\n        vis[val]=1; //mark the visited val\\n        for(int i=rec.start.first;i<=rec.end.first;i++){\\n            for(int j=rec.start.second;j<=rec.end.second;j++){\\n                if(G[i][j]==val || G[i][j]==0){\\n                    G[i][j]=0;\\n                }\\n                else{\\n                    if(vis[G[i][j]] || !fillrec(mp[G[i][j]],G,G[i][j]))return false; //recursion to encounter case when losses are equal\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nstruct rect{     // store max diagonal edges possible\\n    pair<int,int> start;\\n    pair<int,int> end;\\n};\\nclass Solution {\\npublic:\\n    unordered_map<int,rect> mp;int c;\\n    unordered_map<int,int> counts; // to count number of actual numbers\\n    bool vis[61]={};\\n    bool isPrintable(vector<vector<int>>& G) {\\n        int n=G.size(),m=G[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                c=G[i][j];\\n                if(mp.find(c)==mp.end()){\\n                    mp[c].start={i,j};mp[c].end={i,j};\\n                }\\n                else{\\n                    auto [x,y]=mp[c].start;\\n                    auto [p,q]=mp[c].end;\\n                    mp[c].start={min(x,i),min(y,j)};\\n                    mp[c].end={max(p,i),max(q,j)};\\n                }\\n                counts[c]++;\\n            }\\n        }\\n        int num,loss;\\n        vector<pair<int,int>> v;\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            c=it->first;\\n            num=(((it->second).end.second-(it->second).start.second)+1)*\\n                ((it->second).end.first-(it->second).start.first+1);\\n            loss=num-counts[c];\\n            v.push_back({loss,c});\\n        }\\n        sort(v.begin(),v.end());   //sort by loss\\n        for(int i=0;i<v.size();i++){\\n            rec=mp[v[i].second];\\n            if(!fillrec(rec,G,v[i].second)){  //if unable to fill maximal rectangle return false\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool fillrec(rect rec,vector<vector<int>>& G,int val){\\n        vis[val]=1; //mark the visited val\\n        for(int i=rec.start.first;i<=rec.end.first;i++){\\n            for(int j=rec.start.second;j<=rec.end.second;j++){\\n                if(G[i][j]==val || G[i][j]==0){\\n                    G[i][j]=0;\\n                }\\n                else{\\n                    if(vis[G[i][j]] || !fillrec(mp[G[i][j]],G,G[i][j]))return false; //recursion to encounter case when losses are equal\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857436,
                "title": "java-solution-straight-forward",
                "content": "```\\nclass Solution {\\n    \\n    boolean findRectAndUpdate(int[][] gg, int val){\\n\\t    // check if there is a rectangle with color val\\n        int minx = m;\\n        int maxx = -1;\\n        int miny = n;\\n        int maxy = -1;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(gg[i][j]==val){\\n                    minx = Math.min(minx, i);\\n                    maxx = Math.max(maxx, i);\\n                    miny = Math.min(miny, j);\\n                    maxy = Math.max(maxy, j);\\n                }\\n            }\\n        }\\n \\n        for(int i=minx; i<=maxx; i++)\\n            for(int j=miny; j<=maxy; j++)\\n                if(gg[i][j]!=val && gg[i][j]!=0)  // 0 means any color is ok\\n                    return false; \\n        // paint the rectangle to 0\\n        for(int i=minx; i<=maxx; i++)\\n            for(int j=miny; j<=maxy; j++)\\n                gg[i][j]=0;\\n        \\n        return true;\\n    }\\n\\n    int m = 0; int n = 0;\\n    \\n    public boolean isPrintable(int[][] gg) {\\n        \\n        m = gg.length;  n = gg[0].length;\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                set.add(gg[i][j]);\\n  \\n        while(!set.isEmpty()){\\n            Iterator<Integer> it = set.iterator();\\n            boolean flag = false;\\n            while(it.hasNext()){\\n                int next = it.next();\\n                if(findRectAndUpdate(gg, next)){\\n                    it.remove();\\n                    flag = true;\\n                }\\n            }\\n            if(!flag) // no more rectangle\\n                break;\\n        }\\n        \\n        return set.isEmpty(); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    boolean findRectAndUpdate(int[][] gg, int val){\\n\\t    // check if there is a rectangle with color val\\n        int minx = m;\\n        int maxx = -1;\\n        int miny = n;\\n        int maxy = -1;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(gg[i][j]==val){\\n                    minx = Math.min(minx, i);\\n                    maxx = Math.max(maxx, i);\\n                    miny = Math.min(miny, j);\\n                    maxy = Math.max(maxy, j);\\n                }\\n            }\\n        }\\n \\n        for(int i=minx; i<=maxx; i++)\\n            for(int j=miny; j<=maxy; j++)\\n                if(gg[i][j]!=val && gg[i][j]!=0)  // 0 means any color is ok\\n                    return false; \\n        // paint the rectangle to 0\\n        for(int i=minx; i<=maxx; i++)\\n            for(int j=miny; j<=maxy; j++)\\n                gg[i][j]=0;\\n        \\n        return true;\\n    }\\n\\n    int m = 0; int n = 0;\\n    \\n    public boolean isPrintable(int[][] gg) {\\n        \\n        m = gg.length;  n = gg[0].length;\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                set.add(gg[i][j]);\\n  \\n        while(!set.isEmpty()){\\n            Iterator<Integer> it = set.iterator();\\n            boolean flag = false;\\n            while(it.hasNext()){\\n                int next = it.next();\\n                if(findRectAndUpdate(gg, next)){\\n                    it.remove();\\n                    flag = true;\\n                }\\n            }\\n            if(!flag) // no more rectangle\\n                break;\\n        }\\n        \\n        return set.isEmpty(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856331,
                "title": "c-reverse-iteration-with-running-over-non-solid-areas-and-making-them-solid",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m = targetGrid.size();\\n        if(m==0) return true;\\n        int n = targetGrid[0].size();\\n        if(n==0) return true;\\n        \\n        int c = 0;\\n        unordered_map<int, int> seenSolid; \\n        for(int i = 0; i< m; i++)\\n            for(int j = 0; j< n; j++){                \\n                    c = targetGrid[i][j];\\n                    seenSolid[c]=0;                \\n            }\\n        \\n        int nonSolid=0;\\n         for(auto cv : seenSolid){\\n             int minx=INT_MAX;\\n             int maxx=INT_MIN;\\n             int miny=INT_MAX;\\n             int maxy=INT_MIN;\\n             for(int i = 0; i< m; i++)\\n                for(int j = 0; j< n; j++)\\n                    if(cv.first==targetGrid[i][j]) {\\n                        minx = min(minx, i);\\n                        maxx = max(maxx, i);\\n                        miny = min(miny, j);\\n                        maxy = max(maxy, j);\\n                    }                \\n             \\n             bool ok = true;\\n             for(int ki = minx; ki<= maxx; ki++)\\n                for(int kj = miny; kj<= maxy; kj++)\\n                    if(cv.first!=targetGrid[ki][kj]) {\\n                        ok = false;\\n                        break;\\n                    }                \\n             \\n             if(!ok){\\n                nonSolid++;\\n             }else{\\n                seenSolid[cv.first]=1;\\n                for(int ki = minx; ki<= maxx; ki++)\\n                for(int kj = miny; kj<= maxy; kj++){\\n                    targetGrid[ki][kj]=\\'s\\';                    \\n                }\\n             }                          \\n         }\\n        \\n        if(nonSolid==0) return true;\\n        \\n        while(nonSolid){\\n            \\n        bool foundSolid = false;\\n            \\n        for(auto cv : seenSolid){\\n            \\n            if(cv.second==1) {\\n                continue;\\n            }\\n                \\n             int minx=INT_MAX;\\n             int maxx=INT_MIN;\\n             int miny=INT_MAX;\\n             int maxy=INT_MIN;\\n             for(int i = 0; i< m; i++)\\n                for(int j = 0; j< n; j++)\\n                    if(cv.first==targetGrid[i][j]) {\\n                        minx = min(minx, i);\\n                        maxx = max(maxx, i);\\n                        miny = min(miny, j);\\n                        maxy = max(maxy, j);\\n                    }                            \\n            \\n            bool ok = true;\\n             for(int ki = minx; ki<= maxx; ki++)\\n                for(int kj = miny; kj<= maxy; kj++)\\n                    if(cv.first!=targetGrid[ki][kj]) \\n                        if(targetGrid[ki][kj]!=\\'s\\'){\\n                            ok = false;\\n                            break;\\n                        }                                                            \\n            \\n             if(!ok){                 \\n             }else{\\n                 seenSolid[cv.first]=1;\\n                 for(int ki = minx; ki<= maxx; ki++)\\n                for(int kj = miny; kj<= maxy; kj++){\\n                    targetGrid[ki][kj]=\\'s\\';                    \\n                }\\n                 nonSolid--;\\n                 foundSolid = true;\\n             }  \\n        }\\n            \\n        if(!foundSolid) return false;\\n            \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m = targetGrid.size();\\n        if(m==0) return true;\\n        int n = targetGrid[0].size();\\n        if(n==0) return true;\\n        \\n        int c = 0;\\n        unordered_map<int, int> seenSolid; \\n        for(int i = 0; i< m; i++)\\n            for(int j = 0; j< n; j++){                \\n                    c = targetGrid[i][j];\\n                    seenSolid[c]=0;                \\n            }\\n        \\n        int nonSolid=0;\\n         for(auto cv : seenSolid){\\n             int minx=INT_MAX;\\n             int maxx=INT_MIN;\\n             int miny=INT_MAX;\\n             int maxy=INT_MIN;\\n             for(int i = 0; i< m; i++)\\n                for(int j = 0; j< n; j++)\\n                    if(cv.first==targetGrid[i][j]) {\\n                        minx = min(minx, i);\\n                        maxx = max(maxx, i);\\n                        miny = min(miny, j);\\n                        maxy = max(maxy, j);\\n                    }                \\n             \\n             bool ok = true;\\n             for(int ki = minx; ki<= maxx; ki++)\\n                for(int kj = miny; kj<= maxy; kj++)\\n                    if(cv.first!=targetGrid[ki][kj]) {\\n                        ok = false;\\n                        break;\\n                    }                \\n             \\n             if(!ok){\\n                nonSolid++;\\n             }else{\\n                seenSolid[cv.first]=1;\\n                for(int ki = minx; ki<= maxx; ki++)\\n                for(int kj = miny; kj<= maxy; kj++){\\n                    targetGrid[ki][kj]=\\'s\\';                    \\n                }\\n             }                          \\n         }\\n        \\n        if(nonSolid==0) return true;\\n        \\n        while(nonSolid){\\n            \\n        bool foundSolid = false;\\n            \\n        for(auto cv : seenSolid){\\n            \\n            if(cv.second==1) {\\n                continue;\\n            }\\n                \\n             int minx=INT_MAX;\\n             int maxx=INT_MIN;\\n             int miny=INT_MAX;\\n             int maxy=INT_MIN;\\n             for(int i = 0; i< m; i++)\\n                for(int j = 0; j< n; j++)\\n                    if(cv.first==targetGrid[i][j]) {\\n                        minx = min(minx, i);\\n                        maxx = max(maxx, i);\\n                        miny = min(miny, j);\\n                        maxy = max(maxy, j);\\n                    }                            \\n            \\n            bool ok = true;\\n             for(int ki = minx; ki<= maxx; ki++)\\n                for(int kj = miny; kj<= maxy; kj++)\\n                    if(cv.first!=targetGrid[ki][kj]) \\n                        if(targetGrid[ki][kj]!=\\'s\\'){\\n                            ok = false;\\n                            break;\\n                        }                                                            \\n            \\n             if(!ok){                 \\n             }else{\\n                 seenSolid[cv.first]=1;\\n                 for(int ki = minx; ki<= maxx; ki++)\\n                for(int kj = miny; kj<= maxy; kj++){\\n                    targetGrid[ki][kj]=\\'s\\';                    \\n                }\\n                 nonSolid--;\\n                 foundSolid = true;\\n             }  \\n        }\\n            \\n        if(!foundSolid) return false;\\n            \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856262,
                "title": "rust-construct-graph-and-topological-sort",
                "content": "1) We find the min and max (x, y) coordinates for each number.\\n2) We construct a graph from the rectangle for each value, by checking if this rectangle intersects any other rectangle. i.e. if a rect of 1s is intersected with a rect of 2s, then 1s must be placed before the 2s, so add this directed edge in teh graph.\\n3) We simply do a topological sort to determine if there is no contradiction. \\n\\nAlso note that to iterate over `deps`, I use `deps.get(&cur).into_iter().flatten()` which is pretty nice :)\\n\\n```\\nuse std::collections::{HashMap, HashSet};\\n\\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\\nenum VisitStatus {\\n    Visiting,\\n    Visited,\\n}\\n\\nfn has_cycle(\\n    cur: i32,\\n    deps: &HashMap<i32, HashSet<i32>>,\\n    seen: &mut HashMap<i32, VisitStatus>,\\n) -> bool {\\n    match seen.get(&cur) {\\n        Some(VisitStatus::Visited) => return false,\\n        Some(VisitStatus::Visiting) => return true,\\n        None => {}\\n    }\\n    seen.insert(cur, VisitStatus::Visiting);\\n\\n    for dep in deps.get(&cur).into_iter().flatten() {\\n        if has_cycle(*dep, deps, seen) {\\n            return true;\\n        }\\n    }\\n\\n    seen.insert(cur, VisitStatus::Visited);\\n    false\\n}\\n\\nfn is_printable(target_grid: Vec<Vec<i32>>) -> bool {\\n    let mut starts_ends = HashMap::new();\\n\\n    for (i, row) in target_grid.iter().enumerate() {\\n        for (j, val) in row.iter().enumerate() {\\n            if let Some((x_min, y_min, x_max, y_max)) = starts_ends.get_mut(&val) {\\n                *x_min = std::cmp::min(*x_min, i);\\n                *y_min = std::cmp::min(*y_min, j);\\n\\n                *x_max = std::cmp::max(*x_max, i + 1);\\n                *y_max = std::cmp::max(*y_max, j + 1);\\n            } else {\\n                starts_ends.insert(val, (i, j, i + 1, j + 1));\\n            }\\n        }\\n    }\\n\\n    // println!(\"{:?}\", starts_ends);\\n\\n    let mut deps: HashMap<i32, HashSet<i32>> = HashMap::new();\\n    for (&&a_val, &(ax_min, ay_min, ax_max, ay_max)) in starts_ends.iter() {\\n        for (&&b_val, &(bx_min, by_min, bx_max, by_max)) in starts_ends.iter() {\\n            if a_val == b_val {\\n                continue;\\n            }\\n\\n            let (cx_min, cy_min, cx_max, cy_max) = (\\n                std::cmp::max(ax_min, bx_min),\\n                std::cmp::max(ay_min, by_min),\\n                std::cmp::min(ax_max, bx_max),\\n                std::cmp::min(ay_max, by_max),\\n            );\\n\\n            // println!(\"{:?}\", &(cx_min, cy_min, cx_max, cy_max));\\n\\n            for target_i in cx_min..cx_max {\\n                for target_j in cy_min..cy_max {\\n                    if target_grid[target_i][target_j] == b_val {\\n                        deps.entry(a_val).or_insert_with(HashSet::new).insert(b_val);\\n                    }\\n                    // else if target_grid[target_i][target_j] == a_val {\\n                    //     deps.entry(a_val).or_insert_with(Vec::new).push(b_val);\\n                    // }\\n                }\\n            }\\n        }\\n    }\\n\\n    // println!(\"{:?}\", deps);\\n\\n    let mut seen = HashMap::new();\\n    for (&&val, _) in starts_ends.iter() {\\n        // println!(\"{:?}\", val);\\n        if has_cycle(val, &deps, &mut seen) {\\n            // println!(\"{:?}\", val);\\n            return false;\\n        }\\n    }\\n\\n    true\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test_lc1_simple() {\\n        assert!(is_printable(vec![\\n            vec![1, 1, 1, 1],\\n            vec![1, 2, 2, 1],\\n            vec![1, 2, 2, 1],\\n            vec![1, 1, 1, 1]\\n        ]))\\n    }\\n\\n    #[test]\\n    fn test_lc1_hard() {\\n        assert!(is_printable(vec![\\n            vec![4, 4, 4, 1, 1, 1, 1, 1, 1, 1],\\n            vec![4, 4, 4, 1, 1, 1, 1, 1, 1, 1],\\n            vec![4, 4, 4, 3, 1, 1, 1, 1, 1, 1],\\n            vec![1, 3, 3, 3, 1, 1, 1, 1, 1, 1],\\n            vec![1, 3, 3, 3, 1, 1, 1, 1, 1, 1],\\n            vec![1, 3, 3, 3, 1, 1, 1, 1, 1, 1],\\n            vec![1, 3, 3, 6, 6, 6, 6, 6, 6, 5],\\n            vec![1, 3, 3, 6, 6, 6, 6, 6, 6, 5],\\n            vec![1, 1, 1, 6, 6, 6, 6, 6, 6, 2]\\n        ]))\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn is_printable(target_grid: Vec<Vec<i32>>) -> bool {\\n        is_printable(target_grid)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::{HashMap, HashSet};\\n\\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\\nenum VisitStatus {\\n    Visiting,\\n    Visited,\\n}\\n\\nfn has_cycle(\\n    cur: i32,\\n    deps: &HashMap<i32, HashSet<i32>>,\\n    seen: &mut HashMap<i32, VisitStatus>,\\n) -> bool {\\n    match seen.get(&cur) {\\n        Some(VisitStatus::Visited) => return false,\\n        Some(VisitStatus::Visiting) => return true,\\n        None => {}\\n    }\\n    seen.insert(cur, VisitStatus::Visiting);\\n\\n    for dep in deps.get(&cur).into_iter().flatten() {\\n        if has_cycle(*dep, deps, seen) {\\n            return true;\\n        }\\n    }\\n\\n    seen.insert(cur, VisitStatus::Visited);\\n    false\\n}\\n\\nfn is_printable(target_grid: Vec<Vec<i32>>) -> bool {\\n    let mut starts_ends = HashMap::new();\\n\\n    for (i, row) in target_grid.iter().enumerate() {\\n        for (j, val) in row.iter().enumerate() {\\n            if let Some((x_min, y_min, x_max, y_max)) = starts_ends.get_mut(&val) {\\n                *x_min = std::cmp::min(*x_min, i);\\n                *y_min = std::cmp::min(*y_min, j);\\n\\n                *x_max = std::cmp::max(*x_max, i + 1);\\n                *y_max = std::cmp::max(*y_max, j + 1);\\n            } else {\\n                starts_ends.insert(val, (i, j, i + 1, j + 1));\\n            }\\n        }\\n    }\\n\\n    // println!(\"{:?}\", starts_ends);\\n\\n    let mut deps: HashMap<i32, HashSet<i32>> = HashMap::new();\\n    for (&&a_val, &(ax_min, ay_min, ax_max, ay_max)) in starts_ends.iter() {\\n        for (&&b_val, &(bx_min, by_min, bx_max, by_max)) in starts_ends.iter() {\\n            if a_val == b_val {\\n                continue;\\n            }\\n\\n            let (cx_min, cy_min, cx_max, cy_max) = (\\n                std::cmp::max(ax_min, bx_min),\\n                std::cmp::max(ay_min, by_min),\\n                std::cmp::min(ax_max, bx_max),\\n                std::cmp::min(ay_max, by_max),\\n            );\\n\\n            // println!(\"{:?}\", &(cx_min, cy_min, cx_max, cy_max));\\n\\n            for target_i in cx_min..cx_max {\\n                for target_j in cy_min..cy_max {\\n                    if target_grid[target_i][target_j] == b_val {\\n                        deps.entry(a_val).or_insert_with(HashSet::new).insert(b_val);\\n                    }\\n                    // else if target_grid[target_i][target_j] == a_val {\\n                    //     deps.entry(a_val).or_insert_with(Vec::new).push(b_val);\\n                    // }\\n                }\\n            }\\n        }\\n    }\\n\\n    // println!(\"{:?}\", deps);\\n\\n    let mut seen = HashMap::new();\\n    for (&&val, _) in starts_ends.iter() {\\n        // println!(\"{:?}\", val);\\n        if has_cycle(val, &deps, &mut seen) {\\n            // println!(\"{:?}\", val);\\n            return false;\\n        }\\n    }\\n\\n    true\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test_lc1_simple() {\\n        assert!(is_printable(vec![\\n            vec![1, 1, 1, 1],\\n            vec![1, 2, 2, 1],\\n            vec![1, 2, 2, 1],\\n            vec![1, 1, 1, 1]\\n        ]))\\n    }\\n\\n    #[test]\\n    fn test_lc1_hard() {\\n        assert!(is_printable(vec![\\n            vec![4, 4, 4, 1, 1, 1, 1, 1, 1, 1],\\n            vec![4, 4, 4, 1, 1, 1, 1, 1, 1, 1],\\n            vec![4, 4, 4, 3, 1, 1, 1, 1, 1, 1],\\n            vec![1, 3, 3, 3, 1, 1, 1, 1, 1, 1],\\n            vec![1, 3, 3, 3, 1, 1, 1, 1, 1, 1],\\n            vec![1, 3, 3, 3, 1, 1, 1, 1, 1, 1],\\n            vec![1, 3, 3, 6, 6, 6, 6, 6, 6, 5],\\n            vec![1, 3, 3, 6, 6, 6, 6, 6, 6, 5],\\n            vec![1, 1, 1, 6, 6, 6, 6, 6, 6, 2]\\n        ]))\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn is_printable(target_grid: Vec<Vec<i32>>) -> bool {\\n        is_printable(target_grid)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855302,
                "title": "java-remove-possible-color-rectangles-iterative",
                "content": "The idea is Brute force, every time remove all possible rectangle in the current grid, do it iterative, until only 1 color left.\\n\\n1. How to remove color?\\nset all the points in this rectangle to 0 (0 can represent any color).\\n2. How to find the rectangle?\\nfind the topmost, leftmost, rightmost, bottommost of the color, if inside this rectangle only has target color and 0, then this rectangle can be removed.\\n\\nRun time is about 13ms. \\nTime O(MNC^2), C is different colors in the grid, \\nSpace O(C)\\n```\\nclass Solution {\\n    class ColorObj {\\n        int c;\\n        int left = 60;\\n        int top = 60;\\n        int right = 0;\\n        int bottom = 0;\\n        public ColorObj(int c) {\\n            this.c = c;\\n        }\\n    }\\n    public boolean isPrintable(int[][] targetGrid) {\\n        Set<Integer> colors = new HashSet<>();\\n        for (int i=0; i<targetGrid.length; i++){\\n            for (int j=0; j<targetGrid[0].length; j++) {\\n                colors.add(targetGrid[i][j]);\\n            }\\n        }\\n        while (colors.size() > 1) {\\n            Set<ColorObj> candidates = findColorCandidates(targetGrid, colors);\\n            if (candidates.isEmpty()) return false;\\n            for (ColorObj candidate : candidates) {\\n                colors.remove(candidate.c);\\n                removeColor(targetGrid, candidate);\\n            }\\n        }\\n        return true;\\n    }\\n    /** \\n     * Find all the color candidates at current grid which can be print in rectangle\\n     */\\n    private Set<ColorObj> findColorCandidates(int[][] grid, Set<Integer> colors){\\n        Map<Integer, ColorObj> map = new HashMap<>();\\n        // Find all the color status\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 0) continue; //0 present any number\\n                int c = grid[i][j];\\n                ColorObj colorObj = map.getOrDefault(c, new ColorObj(c));\\n                colorObj.left = Math.min(colorObj.left, j);\\n                colorObj.top = Math.min(colorObj.top, i);\\n                colorObj.right = Math.max(colorObj.right, j);\\n                colorObj.bottom = Math.max(colorObj.bottom, i);\\n                map.put(c, colorObj);\\n            }\\n        }\\n        // Verify if those color are in valid rectangle\\n        Set<ColorObj> candidates = new HashSet<>();\\n        for (ColorObj co : map.values()){\\n            if (isValidRect(grid, co)) {\\n                candidates.add(co);\\n            }\\n        }\\n        return candidates;\\n    }\\n    /**\\n     * Check if the rectangle contains only target color and 0\\n     */\\n    private boolean isValidRect(int[][] grid, ColorObj co){\\n        for (int i = co.top; i <= co.bottom; i++){\\n            for (int j = co.left;j <= co.right; j++) {\\n                if(grid[i][j] != 0 && grid[i][j] != co.c) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    /**\\n     * Remove target color from grid (set to 0)\\n     */\\n    private void removeColor(int[][] targetGrid, ColorObj co){\\n        for (int i = co.top; i <= co.bottom; i++) {\\n            for (int j = co.left; j <= co.right; j++) {\\n                targetGrid[i][j] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    class ColorObj {\\n        int c;\\n        int left = 60;\\n        int top = 60;\\n        int right = 0;\\n        int bottom = 0;\\n        public ColorObj(int c) {\\n            this.c = c;\\n        }\\n    }\\n    public boolean isPrintable(int[][] targetGrid) {\\n        Set<Integer> colors = new HashSet<>();\\n        for (int i=0; i<targetGrid.length; i++){\\n            for (int j=0; j<targetGrid[0].length; j++) {\\n                colors.add(targetGrid[i][j]);\\n            }\\n        }\\n        while (colors.size() > 1) {\\n            Set<ColorObj> candidates = findColorCandidates(targetGrid, colors);\\n            if (candidates.isEmpty()) return false;\\n            for (ColorObj candidate : candidates) {\\n                colors.remove(candidate.c);\\n                removeColor(targetGrid, candidate);\\n            }\\n        }\\n        return true;\\n    }\\n    /** \\n     * Find all the color candidates at current grid which can be print in rectangle\\n     */\\n    private Set<ColorObj> findColorCandidates(int[][] grid, Set<Integer> colors){\\n        Map<Integer, ColorObj> map = new HashMap<>();\\n        // Find all the color status\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 0) continue; //0 present any number\\n                int c = grid[i][j];\\n                ColorObj colorObj = map.getOrDefault(c, new ColorObj(c));\\n                colorObj.left = Math.min(colorObj.left, j);\\n                colorObj.top = Math.min(colorObj.top, i);\\n                colorObj.right = Math.max(colorObj.right, j);\\n                colorObj.bottom = Math.max(colorObj.bottom, i);\\n                map.put(c, colorObj);\\n            }\\n        }\\n        // Verify if those color are in valid rectangle\\n        Set<ColorObj> candidates = new HashSet<>();\\n        for (ColorObj co : map.values()){\\n            if (isValidRect(grid, co)) {\\n                candidates.add(co);\\n            }\\n        }\\n        return candidates;\\n    }\\n    /**\\n     * Check if the rectangle contains only target color and 0\\n     */\\n    private boolean isValidRect(int[][] grid, ColorObj co){\\n        for (int i = co.top; i <= co.bottom; i++){\\n            for (int j = co.left;j <= co.right; j++) {\\n                if(grid[i][j] != 0 && grid[i][j] != co.c) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    /**\\n     * Remove target color from grid (set to 0)\\n     */\\n    private void removeColor(int[][] targetGrid, ColorObj co){\\n        for (int i = co.top; i <= co.bottom; i++) {\\n            for (int j = co.left; j <= co.right; j++) {\\n                targetGrid[i][j] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855126,
                "title": "rust-translated-8ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn is_printable(mut a: Vec<Vec<i32>>) -> bool {\\n        use std::collections::HashSet;\\n\\n        fn test(a: &mut Vec<Vec<i32>>, pos: &[(i32, i32, i32, i32)], c: i32) -> bool {\\n            for i in pos[c as usize].0..pos[c as usize].2 + 1 {\\n                for j in pos[c as usize].1..pos[c as usize].3 + 1 {\\n                    if a[i as usize][j as usize] > 0 && a[i as usize][j as usize] != c {\\n                        return false;\\n                    }\\n                }\\n            }\\n            for i in pos[c as usize].0..pos[c as usize].2 + 1 {\\n                for j in pos[c as usize].1..pos[c as usize].3 + 1 {\\n                    a[i as usize][j as usize] = 0;\\n                }\\n            }\\n            true\\n        }\\n\\n        let m = a.len();\\n        let n = a[0].len();\\n        let mut pos = vec![(m as i32, n as i32, 0, 0); 61];\\n        let mut colors = HashSet::<i32>::new();\\n        for i in 0..m {\\n            for j in 0..n {\\n                let c = a[i][j];\\n                colors.insert(c);\\n                pos[c as usize].0 = std::cmp::min(pos[c as usize].0, i as i32);\\n                pos[c as usize].1 = std::cmp::min(pos[c as usize].1, j as i32);\\n                pos[c as usize].2 = std::cmp::max(pos[c as usize].2, i as i32);\\n                pos[c as usize].3 = std::cmp::max(pos[c as usize].3, j as i32);\\n            }\\n        }\\n\\n        while !colors.is_empty() {\\n            let mut c2 = HashSet::<i32>::new();\\n            for &c in colors.iter() {\\n                if !test(&mut a, &pos, c) {\\n                    c2.insert(c);\\n                }\\n            }\\n            if c2.len() == colors.len() {\\n                return false;\\n            }\\n            colors = c2;\\n        }\\n        true\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_is_printable() {\\n        assert_eq!(\\n            Solution::is_printable(vec![\\n                vec![1, 1, 1, 1],\\n                vec![1, 2, 2, 1],\\n                vec![1, 2, 2, 1],\\n                vec![1, 1, 1, 1]\\n            ]),\\n            true\\n        );\\n    }\\n\\n    #[test]\\n    fn test_is_printable_02() {\\n        assert_eq!(\\n            Solution::is_printable(vec![\\n                vec![1, 1, 1, 1],\\n                vec![1, 1, 3, 3],\\n                vec![1, 1, 3, 4],\\n                vec![5, 5, 1, 4]\\n            ]),\\n            true\\n        );\\n    }\\n\\n    #[test]\\n    fn test_is_printable_03() {\\n        assert_eq!(\\n            Solution::is_printable(vec![vec![1, 2, 1], vec![2, 1, 2], vec![1, 2, 1]]),\\n            false\\n        );\\n    }\\n\\n    #[test]\\n    fn test_is_printable_04() {\\n        assert_eq!(\\n            Solution::is_printable(vec![vec![1, 1, 1], vec![3, 1, 3]]),\\n            false\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_printable(mut a: Vec<Vec<i32>>) -> bool {\\n        use std::collections::HashSet;\\n\\n        fn test(a: &mut Vec<Vec<i32>>, pos: &[(i32, i32, i32, i32)], c: i32) -> bool {\\n            for i in pos[c as usize].0..pos[c as usize].2 + 1 {\\n                for j in pos[c as usize].1..pos[c as usize].3 + 1 {\\n                    if a[i as usize][j as usize] > 0 && a[i as usize][j as usize] != c {\\n                        return false;\\n                    }\\n                }\\n            }\\n            for i in pos[c as usize].0..pos[c as usize].2 + 1 {\\n                for j in pos[c as usize].1..pos[c as usize].3 + 1 {\\n                    a[i as usize][j as usize] = 0;\\n                }\\n            }\\n            true\\n        }\\n\\n        let m = a.len();\\n        let n = a[0].len();\\n        let mut pos = vec![(m as i32, n as i32, 0, 0); 61];\\n        let mut colors = HashSet::<i32>::new();\\n        for i in 0..m {\\n            for j in 0..n {\\n                let c = a[i][j];\\n                colors.insert(c);\\n                pos[c as usize].0 = std::cmp::min(pos[c as usize].0, i as i32);\\n                pos[c as usize].1 = std::cmp::min(pos[c as usize].1, j as i32);\\n                pos[c as usize].2 = std::cmp::max(pos[c as usize].2, i as i32);\\n                pos[c as usize].3 = std::cmp::max(pos[c as usize].3, j as i32);\\n            }\\n        }\\n\\n        while !colors.is_empty() {\\n            let mut c2 = HashSet::<i32>::new();\\n            for &c in colors.iter() {\\n                if !test(&mut a, &pos, c) {\\n                    c2.insert(c);\\n                }\\n            }\\n            if c2.len() == colors.len() {\\n                return false;\\n            }\\n            colors = c2;\\n        }\\n        true\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_is_printable() {\\n        assert_eq!(\\n            Solution::is_printable(vec![\\n                vec![1, 1, 1, 1],\\n                vec![1, 2, 2, 1],\\n                vec![1, 2, 2, 1],\\n                vec![1, 1, 1, 1]\\n            ]),\\n            true\\n        );\\n    }\\n\\n    #[test]\\n    fn test_is_printable_02() {\\n        assert_eq!(\\n            Solution::is_printable(vec![\\n                vec![1, 1, 1, 1],\\n                vec![1, 1, 3, 3],\\n                vec![1, 1, 3, 4],\\n                vec![5, 5, 1, 4]\\n            ]),\\n            true\\n        );\\n    }\\n\\n    #[test]\\n    fn test_is_printable_03() {\\n        assert_eq!(\\n            Solution::is_printable(vec![vec![1, 2, 1], vec![2, 1, 2], vec![1, 2, 1]]),\\n            false\\n        );\\n    }\\n\\n    #[test]\\n    fn test_is_printable_04() {\\n        assert_eq!(\\n            Solution::is_printable(vec![vec![1, 1, 1], vec![3, 1, 3]]),\\n            false\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 854828,
                "title": "javascript-all-pretty-commented",
                "content": "```\\n\\n// isPrintable returns true if every color in the grid could have been a valid rectangle\\nconst isPrintable = grid => {\\n\\n    // obtain info on each color\\n    const colors = new Map()\\n    grid.forEach( ( row, i ) => {\\n        row.forEach( ( color, j ) => {\\n\\n            let o = colors.get( color )\\n            if ( ! o ) {\\n                o = { left: Infinity, right: -Infinity, top: Infinity, bottom: -Infinity } \\n                colors.set( color, o )\\n            }\\n\\n            o.left   = Math.min( j, o.left )\\n            o.right  = Math.max( j, o.right )\\n            o.top    = Math.min( i, o.top )\\n            o.bottom = Math.max( i, o.bottom )\\n\\n        })\\n    })\\n\\n    // get every color key  this will serve to track which colors we need to validate\\n    const tofind = new Set([...colors.keys()])\\n    \\n    // a color is considered a rectangle if the cells of it\\'s 4 corners and inwards\\n    // contain only that color. Colors already validated could have been printed on top\\n\\t// so we\\'ll give those a pass too, and only break if it\\'s a color we\\'ve yet to find\\n    const isRectangle = ( color, { left, right, bottom, top } ) => {\\n\\n        for ( let i = top; i <= bottom; i++ ) {\\n            for ( let j = left; j <= right; j++ ) {\\n\\n                if ( grid[i][j] != color && tofind.has( grid[i][j] ) ) {\\n\\n                    return false\\n                    \\n                }\\n\\n            }\\n        }\\n        \\n        return true\\n\\n    }\\n\\n    // if a new rectangle is found that means it could uncover new, additional rectangles,\\n    // so keep looping while new rectangles are found\\n    let keepLooping = true\\n    while ( keepLooping ) {\\n\\n        keepLooping = false\\n        \\n        colors.forEach( ( info, color ) => {\\n\\n            if ( ! tofind.has( color ) ) return\\n\\n            if ( isRectangle( color, info ) ) {\\n                keepLooping = true\\n                \\n                tofind.delete( color )\\n            }\\n\\n        })\\n\\n    }\\n    \\n    return tofind.size === 0\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n// isPrintable returns true if every color in the grid could have been a valid rectangle\\nconst isPrintable = grid => {\\n\\n    // obtain info on each color\\n    const colors = new Map()\\n    grid.forEach( ( row, i ) => {\\n        row.forEach( ( color, j ) => {\\n\\n            let o = colors.get( color )\\n            if ( ! o ) {\\n                o = { left: Infinity, right: -Infinity, top: Infinity, bottom: -Infinity } \\n                colors.set( color, o )\\n            }\\n\\n            o.left   = Math.min( j, o.left )\\n            o.right  = Math.max( j, o.right )\\n            o.top    = Math.min( i, o.top )\\n            o.bottom = Math.max( i, o.bottom )\\n\\n        })\\n    })\\n\\n    // get every color key  this will serve to track which colors we need to validate\\n    const tofind = new Set([...colors.keys()])\\n    \\n    // a color is considered a rectangle if the cells of it\\'s 4 corners and inwards\\n    // contain only that color. Colors already validated could have been printed on top\\n\\t// so we\\'ll give those a pass too, and only break if it\\'s a color we\\'ve yet to find\\n    const isRectangle = ( color, { left, right, bottom, top } ) => {\\n\\n        for ( let i = top; i <= bottom; i++ ) {\\n            for ( let j = left; j <= right; j++ ) {\\n\\n                if ( grid[i][j] != color && tofind.has( grid[i][j] ) ) {\\n\\n                    return false\\n                    \\n                }\\n\\n            }\\n        }\\n        \\n        return true\\n\\n    }\\n\\n    // if a new rectangle is found that means it could uncover new, additional rectangles,\\n    // so keep looping while new rectangles are found\\n    let keepLooping = true\\n    while ( keepLooping ) {\\n\\n        keepLooping = false\\n        \\n        colors.forEach( ( info, color ) => {\\n\\n            if ( ! tofind.has( color ) ) return\\n\\n            if ( isRectangle( color, info ) ) {\\n                keepLooping = true\\n                \\n                tofind.delete( color )\\n            }\\n\\n        })\\n\\n    }\\n    \\n    return tofind.size === 0\\n}\\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1719213,
                "content": [
                    {
                        "username": "kkd14",
                        "content": "how to know whether this problem is related to graph?"
                    },
                    {
                        "username": "singhdurgesh",
                        "content": "[@Devin_Leamy](/Devin_Leamy) Yes. There we can use Topological Sort algorithm to solve problem."
                    },
                    {
                        "username": "Devin_Leamy",
                        "content": "If there some color \"A\" and within the bounds in which color \"A\" appears there is some other color \"B\", then \"A\" must be drawn before \"B\". Using this logic, you can view every color as having to be drawn before some set of other colors. You can then construct a dependency graph among the colors. Some colors need to be drawn before or after other colors and these relationships can be modelled with a graph."
                    }
                ]
            }
        ]
    }
]